begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2001-2014, Intel Corporation    All rights reserved.      Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are met:       1. Redistributions of source code must retain the above copyright notice,        this list of conditions and the following disclaimer.       2. Redistributions in binary form must reproduce the above copyright        notice, this list of conditions and the following disclaimer in the        documentation and/or other materials provided with the distribution.       3. Neither the name of the Intel Corporation nor the names of its        contributors may be used to endorse or promote products derived from        this software without specific prior written permission.      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|IXGBE_STANDALONE_BUILD
end_ifndef

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_rss.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ixgbe.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|RSS
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in_rss.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ** HW RSC control: **  this feature only works with **  IPv4, and only on 82599 and later. **  Also this will cause IP forwarding to **  fail and that can't be controlled by **  the stack as LRO can. For all these **  reasons I've deemed it best to leave **  this off and not bother with a tuneable **  interface, this would need to be compiled **  to enable. */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|ixgbe_rsc_enable
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|IXGBE_FDIR
end_ifdef

begin_comment
comment|/* ** For Flow Director: this is the ** number of TX packets we sample ** for the filter pool, this means ** every 20th packet will be probed. ** ** This feature can be disabled by ** setting this to 0. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|atr_sample_rate
init|=
literal|20
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Shared PCI config read/write */
end_comment

begin_function
specifier|inline
name|u16
name|ixgbe_read_pci_cfg
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|reg
parameter_list|)
block|{
name|u16
name|value
decl_stmt|;
name|value
operator|=
name|pci_read_config
argument_list|(
operator|(
operator|(
expr|struct
name|ixgbe_osdep
operator|*
operator|)
name|hw
operator|->
name|back
operator|)
operator|->
name|dev
argument_list|,
name|reg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_function
specifier|inline
name|void
name|ixgbe_write_pci_cfg
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|reg
parameter_list|,
name|u16
name|value
parameter_list|)
block|{
name|pci_write_config
argument_list|(
operator|(
operator|(
expr|struct
name|ixgbe_osdep
operator|*
operator|)
name|hw
operator|->
name|back
operator|)
operator|->
name|dev
argument_list|,
name|reg
argument_list|,
name|value
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  Local Function prototypes  *********************************************************************/
end_comment

begin_function_decl
specifier|static
name|void
name|ixgbe_setup_transmit_ring
parameter_list|(
name|struct
name|tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_free_transmit_buffers
parameter_list|(
name|struct
name|tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_setup_receive_ring
parameter_list|(
name|struct
name|rx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_free_receive_buffers
parameter_list|(
name|struct
name|rx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_rx_checksum
parameter_list|(
name|u32
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|u32
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_refresh_mbufs
parameter_list|(
name|struct
name|rx_ring
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_xmit
parameter_list|(
name|struct
name|tx_ring
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_tx_ctx_setup
parameter_list|(
name|struct
name|tx_ring
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|u32
modifier|*
parameter_list|,
name|u32
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ixgbe_tso_setup
parameter_list|(
name|struct
name|tx_ring
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|u32
modifier|*
parameter_list|,
name|u32
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|IXGBE_FDIR
end_ifdef

begin_function_decl
specifier|static
name|void
name|ixgbe_atr
parameter_list|(
name|struct
name|tx_ring
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|__inline
name|void
name|ixgbe_rx_discard
parameter_list|(
name|struct
name|rx_ring
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ixgbe_rx_input
parameter_list|(
name|struct
name|rx_ring
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|u32
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|IXGBE_LEGACY_TX
end_ifdef

begin_comment
comment|/*********************************************************************  *  Transmit entry point  *  *  ixgbe_start is called by the stack to initiate a transmit.  *  The driver will remain in this routine as long as there are  *  packets to transmit and transmit resources are available.  *  In case resources are not available stack is notified and  *  the packet is requeued.  **********************************************************************/
end_comment

begin_function
name|void
name|ixgbe_start_locked
parameter_list|(
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_head
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|IXGBE_TX_LOCK_ASSERT
argument_list|(
name|txr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
name|adapter
operator|->
name|link_active
condition|)
return|return;
while|while
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
block|{
if|if
condition|(
name|txr
operator|->
name|tx_avail
operator|<=
name|IXGBE_QUEUE_MIN_FREE
condition|)
break|break;
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_head
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|ixgbe_xmit
argument_list|(
name|txr
argument_list|,
operator|&
name|m_head
argument_list|)
condition|)
block|{
if|if
condition|(
name|m_head
operator|!=
name|NULL
condition|)
name|IFQ_DRV_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Send a copy of the frame to the BPF listener */
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Legacy TX start - called by the stack, this  * always uses the first tx ring, and should  * not be used with multiqueue tx enabled.  */
end_comment

begin_function
name|void
name|ixgbe_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|IXGBE_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|ixgbe_start_locked
argument_list|(
name|txr
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|IXGBE_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! IXGBE_LEGACY_TX */
end_comment

begin_comment
comment|/* ** Multiqueue Transmit driver ** */
end_comment

begin_function
name|int
name|ixgbe_mq_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ix_queue
modifier|*
name|que
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|RSS
name|uint32_t
name|bucket_id
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * When doing RSS, map it to the same outbound queue 	 * as the incoming flow would be mapped to. 	 * 	 * If everything is setup correctly, it should be the 	 * same bucket that the current CPU we're on is. 	 */
if|if
condition|(
name|M_HASHTYPE_GET
argument_list|(
name|m
argument_list|)
operator|!=
name|M_HASHTYPE_NONE
condition|)
block|{
ifdef|#
directive|ifdef
name|RSS
if|if
condition|(
name|rss_hash2bucket
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
argument_list|,
name|M_HASHTYPE_GET
argument_list|(
name|m
argument_list|)
argument_list|,
operator|&
name|bucket_id
argument_list|)
operator|==
literal|0
condition|)
comment|/* TODO: spit out something if bucket_id> num_queues? */
name|i
operator|=
name|bucket_id
operator|%
name|adapter
operator|->
name|num_queues
expr_stmt|;
else|else
endif|#
directive|endif
name|i
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|%
name|adapter
operator|->
name|num_queues
expr_stmt|;
block|}
else|else
name|i
operator|=
name|curcpu
operator|%
name|adapter
operator|->
name|num_queues
expr_stmt|;
comment|/* Check for a hung queue and pick alternative */
if|if
condition|(
operator|(
operator|(
literal|1
operator|<<
name|i
operator|)
operator|&
name|adapter
operator|->
name|active_queues
operator|)
operator|==
literal|0
condition|)
name|i
operator|=
name|ffsl
argument_list|(
name|adapter
operator|->
name|active_queues
argument_list|)
expr_stmt|;
name|txr
operator|=
operator|&
name|adapter
operator|->
name|tx_rings
index|[
name|i
index|]
expr_stmt|;
name|que
operator|=
operator|&
name|adapter
operator|->
name|queues
index|[
name|i
index|]
expr_stmt|;
name|err
operator|=
name|drbr_enqueue
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|IXGBE_TX_TRYLOCK
argument_list|(
name|txr
argument_list|)
condition|)
block|{
name|ixgbe_mq_start_locked
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
name|IXGBE_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
else|else
name|taskqueue_enqueue
argument_list|(
name|que
operator|->
name|tq
argument_list|,
operator|&
name|txr
operator|->
name|txq_task
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ixgbe_mq_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|next
decl_stmt|;
name|int
name|enqueued
init|=
literal|0
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
operator|)
operator|||
name|adapter
operator|->
name|link_active
operator|==
literal|0
condition|)
return|return
operator|(
name|ENETDOWN
operator|)
return|;
comment|/* Process the queue */
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|901504
name|next
operator|=
name|drbr_dequeue
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
expr_stmt|;
while|while
condition|(
name|next
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|ixgbe_xmit
argument_list|(
name|txr
argument_list|,
operator|&
name|next
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|next
operator|!=
name|NULL
condition|)
name|err
operator|=
name|drbr_enqueue
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|,
name|next
argument_list|)
expr_stmt|;
else|#
directive|else
while|while
condition|(
operator|(
name|next
operator|=
name|drbr_peek
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|ixgbe_xmit
argument_list|(
name|txr
argument_list|,
operator|&
name|next
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
block|{
name|drbr_advance
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|drbr_putback
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|901504
name|drbr_advance
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|enqueued
operator|++
expr_stmt|;
if|#
directive|if
literal|0
comment|// this is VF-only
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1100036
block|if (next->m_flags& M_MCAST) 			if_inc_counter(ifp, IFCOUNTER_OMCASTS, 1);
endif|#
directive|endif
endif|#
directive|endif
comment|/* Send a copy of the frame to the BPF listener */
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
break|break;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|901504
name|next
operator|=
name|drbr_dequeue
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|txr
operator|->
name|tx_avail
operator|<
name|IXGBE_TX_CLEANUP_THRESHOLD
condition|)
name|ixgbe_txeof
argument_list|(
name|txr
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/*  * Called from a taskqueue to drain queued transmit packets.  */
name|void
name|ixgbe_deferred_mq_start
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|arg
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|IXGBE_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|drbr_empty
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|br
argument_list|)
condition|)
name|ixgbe_mq_start_locked
argument_list|(
name|ifp
argument_list|,
name|txr
argument_list|)
expr_stmt|;
name|IXGBE_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
comment|/* ** Flush all ring buffers */
name|void
name|ixgbe_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|txr
operator|++
control|)
block|{
name|IXGBE_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|buf_ring_dequeue_sc
argument_list|(
name|txr
operator|->
name|br
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|IXGBE_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
name|if_qflush
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* IXGBE_LEGACY_TX */
comment|/*********************************************************************  *  *  This routine maps the mbufs to tx descriptors, allowing the  *  TX engine to transmit the packets.   *  	- return 0 on success, positive on failure  *  **********************************************************************/
specifier|static
name|int
name|ixgbe_xmit
parameter_list|(
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m_headp
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|u32
name|olinfo_status
init|=
literal|0
decl_stmt|,
name|cmd_type_len
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|error
decl_stmt|,
name|nsegs
decl_stmt|;
name|int
name|first
decl_stmt|;
name|bool
name|remap
init|=
name|TRUE
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_head
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
name|adapter
operator|->
name|num_segs
index|]
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|struct
name|ixgbe_tx_buf
modifier|*
name|txbuf
decl_stmt|;
name|union
name|ixgbe_adv_tx_desc
modifier|*
name|txd
init|=
name|NULL
decl_stmt|;
name|m_head
operator|=
operator|*
name|m_headp
expr_stmt|;
comment|/* Basic descriptor defines */
name|cmd_type_len
operator|=
operator|(
name|IXGBE_ADVTXD_DTYP_DATA
operator||
name|IXGBE_ADVTXD_DCMD_IFCS
operator||
name|IXGBE_ADVTXD_DCMD_DEXT
operator|)
expr_stmt|;
if|if
condition|(
name|m_head
operator|->
name|m_flags
operator|&
name|M_VLANTAG
condition|)
name|cmd_type_len
operator||=
name|IXGBE_ADVTXD_DCMD_VLE
expr_stmt|;
comment|/*          * Important to capture the first descriptor          * used because it will contain the index of          * the one we tell the hardware to report back          */
name|first
operator|=
name|txr
operator|->
name|next_avail_desc
expr_stmt|;
name|txbuf
operator|=
operator|&
name|txr
operator|->
name|tx_buffers
index|[
name|first
index|]
expr_stmt|;
name|map
operator|=
name|txbuf
operator|->
name|map
expr_stmt|;
comment|/* 	 * Map the packet for DMA. 	 */
name|retry
label|:
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|map
argument_list|,
operator|*
name|m_headp
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|error
argument_list|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|EFBIG
case|:
comment|/* Try it again? - one try */
if|if
condition|(
name|remap
operator|==
name|TRUE
condition|)
block|{
name|remap
operator|=
name|FALSE
expr_stmt|;
name|m
operator|=
name|m_defrag
argument_list|(
operator|*
name|m_headp
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|adapter
operator|->
name|mbuf_defrag_failed
operator|++
expr_stmt|;
name|m_freem
argument_list|(
operator|*
name|m_headp
argument_list|)
expr_stmt|;
operator|*
name|m_headp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
operator|*
name|m_headp
operator|=
name|m
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
else|else
return|return
operator|(
name|error
operator|)
return|;
case|case
name|ENOMEM
case|:
name|txr
operator|->
name|no_tx_dma_setup
operator|++
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
default|default:
name|txr
operator|->
name|no_tx_dma_setup
operator|++
expr_stmt|;
name|m_freem
argument_list|(
operator|*
name|m_headp
argument_list|)
expr_stmt|;
operator|*
name|m_headp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* Make certain there are enough descriptors */
if|if
condition|(
name|nsegs
operator|>
name|txr
operator|->
name|tx_avail
operator|-
literal|2
condition|)
block|{
name|txr
operator|->
name|no_desc_avail
operator|++
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|m_head
operator|=
operator|*
name|m_headp
expr_stmt|;
comment|/* 	** Set up the appropriate offload context 	** this will consume the first descriptor 	*/
name|error
operator|=
name|ixgbe_tx_ctx_setup
argument_list|(
name|txr
argument_list|,
name|m_head
argument_list|,
operator|&
name|cmd_type_len
argument_list|,
operator|&
name|olinfo_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|error
argument_list|)
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ENOBUFS
condition|)
operator|*
name|m_headp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|IXGBE_FDIR
comment|/* Do the flow director magic */
if|if
condition|(
operator|(
name|txr
operator|->
name|atr_sample
operator|)
operator|&&
operator|(
operator|!
name|adapter
operator|->
name|fdir_reinit
operator|)
condition|)
block|{
operator|++
name|txr
operator|->
name|atr_count
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|atr_count
operator|>=
name|atr_sample_rate
condition|)
block|{
name|ixgbe_atr
argument_list|(
name|txr
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
name|txr
operator|->
name|atr_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|olinfo_status
operator||=
name|IXGBE_ADVTXD_CC
expr_stmt|;
name|i
operator|=
name|txr
operator|->
name|next_avail_desc
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nsegs
condition|;
name|j
operator|++
control|)
block|{
name|bus_size_t
name|seglen
decl_stmt|;
name|bus_addr_t
name|segaddr
decl_stmt|;
name|txbuf
operator|=
operator|&
name|txr
operator|->
name|tx_buffers
index|[
name|i
index|]
expr_stmt|;
name|txd
operator|=
operator|&
name|txr
operator|->
name|tx_base
index|[
name|i
index|]
expr_stmt|;
name|seglen
operator|=
name|segs
index|[
name|j
index|]
operator|.
name|ds_len
expr_stmt|;
name|segaddr
operator|=
name|htole64
argument_list|(
name|segs
index|[
name|j
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|txd
operator|->
name|read
operator|.
name|buffer_addr
operator|=
name|segaddr
expr_stmt|;
name|txd
operator|->
name|read
operator|.
name|cmd_type_len
operator|=
name|htole32
argument_list|(
name|txr
operator|->
name|txd_cmd
operator||
name|cmd_type_len
operator||
name|seglen
argument_list|)
expr_stmt|;
name|txd
operator|->
name|read
operator|.
name|olinfo_status
operator|=
name|htole32
argument_list|(
name|olinfo_status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|txr
operator|->
name|num_desc
condition|)
name|i
operator|=
literal|0
expr_stmt|;
block|}
name|txd
operator|->
name|read
operator|.
name|cmd_type_len
operator||=
name|htole32
argument_list|(
name|IXGBE_TXD_CMD_EOP
operator||
name|IXGBE_TXD_CMD_RS
argument_list|)
expr_stmt|;
name|txr
operator|->
name|tx_avail
operator|-=
name|nsegs
expr_stmt|;
name|txr
operator|->
name|next_avail_desc
operator|=
name|i
expr_stmt|;
name|txbuf
operator|->
name|m_head
operator|=
name|m_head
expr_stmt|;
comment|/* 	** Here we swap the map so the last descriptor, 	** which gets the completion interrupt has the 	** real map, and the first descriptor gets the 	** unused map from this descriptor. 	*/
name|txr
operator|->
name|tx_buffers
index|[
name|first
index|]
operator|.
name|map
operator|=
name|txbuf
operator|->
name|map
expr_stmt|;
name|txbuf
operator|->
name|map
operator|=
name|map
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Set the EOP descriptor that will be marked done */
name|txbuf
operator|=
operator|&
name|txr
operator|->
name|tx_buffers
index|[
name|first
index|]
expr_stmt|;
name|txbuf
operator|->
name|eop
operator|=
name|txd
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txdma
operator|.
name|dma_tag
argument_list|,
name|txr
operator|->
name|txdma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* 	 * Advance the Transmit Descriptor Tail (Tdt), this tells the 	 * hardware that this frame is available to transmit. 	 */
operator|++
name|txr
operator|->
name|total_packets
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|txr
operator|->
name|tail
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Mark queue as having work */
if|if
condition|(
name|txr
operator|->
name|busy
operator|==
literal|0
condition|)
name|txr
operator|->
name|busy
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*********************************************************************  *  *  Allocate memory for tx_buffer structures. The tx_buffer stores all  *  the information needed to transmit a packet on the wire. This is  *  called only once at attach, setup is done every reset.  *  **********************************************************************/
name|int
name|ixgbe_allocate_transmit_buffers
parameter_list|(
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|ixgbe_tx_buf
modifier|*
name|txbuf
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * Setup DMA descriptor areas. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|IXGBE_TSO_SIZE
argument_list|,
comment|/* maxsize */
name|adapter
operator|->
name|num_segs
argument_list|,
comment|/* nsegments */
name|PAGE_SIZE
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockfuncarg */
operator|&
name|txr
operator|->
name|txtag
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate TX DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|txr
operator|->
name|tx_buffers
operator|=
operator|(
expr|struct
name|ixgbe_tx_buf
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ixgbe_tx_buf
argument_list|)
operator|*
name|adapter
operator|->
name|num_tx_desc
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate tx_buffer memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Create the descriptor buffer dma maps */
name|txbuf
operator|=
name|txr
operator|->
name|tx_buffers
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_tx_desc
condition|;
name|i
operator|++
operator|,
name|txbuf
operator|++
control|)
block|{
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
literal|0
argument_list|,
operator|&
name|txbuf
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to create TX DMA map\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
return|return
literal|0
return|;
name|fail
label|:
comment|/* We free all, it handles case where we are in the middle */
name|ixgbe_free_transmit_structures
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*********************************************************************  *  *  Initialize a transmit ring.  *  **********************************************************************/
specifier|static
name|void
name|ixgbe_setup_transmit_ring
parameter_list|(
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|struct
name|ixgbe_tx_buf
modifier|*
name|txbuf
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|adapter
operator|->
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_slot
modifier|*
name|slot
decl_stmt|;
endif|#
directive|endif
comment|/* DEV_NETMAP */
comment|/* Clear the old ring contents */
name|IXGBE_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
comment|/* 	 * (under lock): if in netmap mode, do some consistency 	 * checks and set slot to entry 0 of the netmap ring. 	 */
name|slot
operator|=
name|netmap_reset
argument_list|(
name|na
argument_list|,
name|NR_TX
argument_list|,
name|txr
operator|->
name|me
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEV_NETMAP */
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|txr
operator|->
name|tx_base
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|union
name|ixgbe_adv_tx_desc
argument_list|)
operator|)
operator|*
name|adapter
operator|->
name|num_tx_desc
argument_list|)
expr_stmt|;
comment|/* Reset indices */
name|txr
operator|->
name|next_avail_desc
operator|=
literal|0
expr_stmt|;
name|txr
operator|->
name|next_to_clean
operator|=
literal|0
expr_stmt|;
comment|/* Free any existing tx buffers. */
name|txbuf
operator|=
name|txr
operator|->
name|tx_buffers
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|txr
operator|->
name|num_desc
condition|;
name|i
operator|++
operator|,
name|txbuf
operator|++
control|)
block|{
if|if
condition|(
name|txbuf
operator|->
name|m_head
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|txbuf
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|txbuf
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|txbuf
operator|->
name|m_head
argument_list|)
expr_stmt|;
name|txbuf
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEV_NETMAP
comment|/* 		 * In netmap mode, set the map for the packet buffer. 		 * NOTE: Some drivers (not this one) also need to set 		 * the physical buffer address in the NIC ring. 		 * Slots in the netmap ring (indexed by "si") are 		 * kring->nkr_hwofs positions "ahead" wrt the 		 * corresponding slot in the NIC ring. In some drivers 		 * (not here) nkr_hwofs can be negative. Function 		 * netmap_idx_n2k() handles wraparounds properly. 		 */
if|if
condition|(
name|slot
condition|)
block|{
name|int
name|si
init|=
name|netmap_idx_n2k
argument_list|(
operator|&
name|na
operator|->
name|tx_rings
index|[
name|txr
operator|->
name|me
index|]
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|netmap_load_map
argument_list|(
name|na
argument_list|,
name|txr
operator|->
name|txtag
argument_list|,
name|txbuf
operator|->
name|map
argument_list|,
name|NMB
argument_list|(
name|na
argument_list|,
name|slot
operator|+
name|si
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEV_NETMAP */
comment|/* Clear the EOP descriptor pointer */
name|txbuf
operator|->
name|eop
operator|=
name|NULL
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IXGBE_FDIR
comment|/* Set the rate at which we sample packets */
if|if
condition|(
name|adapter
operator|->
name|hw
operator|.
name|mac
operator|.
name|type
operator|!=
name|ixgbe_mac_82598EB
condition|)
name|txr
operator|->
name|atr_sample
operator|=
name|atr_sample_rate
expr_stmt|;
endif|#
directive|endif
comment|/* Set number of descriptors available */
name|txr
operator|->
name|tx_avail
operator|=
name|adapter
operator|->
name|num_tx_desc
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txdma
operator|.
name|dma_tag
argument_list|,
name|txr
operator|->
name|txdma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|IXGBE_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
comment|/*********************************************************************  *  *  Initialize all transmit rings.  *  **********************************************************************/
name|int
name|ixgbe_setup_transmit_structures
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|txr
operator|++
control|)
name|ixgbe_setup_transmit_ring
argument_list|(
name|txr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*********************************************************************  *  *  Free all transmit rings.  *  **********************************************************************/
name|void
name|ixgbe_free_transmit_structures
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|tx_ring
modifier|*
name|txr
init|=
name|adapter
operator|->
name|tx_rings
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|txr
operator|++
control|)
block|{
name|IXGBE_TX_LOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|ixgbe_free_transmit_buffers
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|ixgbe_dma_free
argument_list|(
name|adapter
argument_list|,
operator|&
name|txr
operator|->
name|txdma
argument_list|)
expr_stmt|;
name|IXGBE_TX_UNLOCK
argument_list|(
name|txr
argument_list|)
expr_stmt|;
name|IXGBE_TX_LOCK_DESTROY
argument_list|(
name|txr
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|adapter
operator|->
name|tx_rings
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
comment|/*********************************************************************  *  *  Free transmit ring related data structures.  *  **********************************************************************/
specifier|static
name|void
name|ixgbe_free_transmit_buffers
parameter_list|(
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|struct
name|ixgbe_tx_buf
modifier|*
name|tx_buffer
decl_stmt|;
name|int
name|i
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgbe_free_transmit_ring: begin"
argument_list|)
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|tx_buffers
operator|==
name|NULL
condition|)
return|return;
name|tx_buffer
operator|=
name|txr
operator|->
name|tx_buffers
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_tx_desc
condition|;
name|i
operator|++
operator|,
name|tx_buffer
operator|++
control|)
block|{
if|if
condition|(
name|tx_buffer
operator|->
name|m_head
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|tx_buffer
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|tx_buffer
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|tx_buffer
operator|->
name|m_head
argument_list|)
expr_stmt|;
name|tx_buffer
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tx_buffer
operator|->
name|map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|tx_buffer
operator|->
name|map
argument_list|)
expr_stmt|;
name|tx_buffer
operator|->
name|map
operator|=
name|NULL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|tx_buffer
operator|->
name|map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|tx_buffer
operator|->
name|map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|tx_buffer
operator|->
name|map
argument_list|)
expr_stmt|;
name|tx_buffer
operator|->
name|map
operator|=
name|NULL
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|IXGBE_LEGACY_TX
if|if
condition|(
name|txr
operator|->
name|br
operator|!=
name|NULL
condition|)
name|buf_ring_free
argument_list|(
name|txr
operator|->
name|br
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|txr
operator|->
name|tx_buffers
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|txr
operator|->
name|tx_buffers
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|txr
operator|->
name|tx_buffers
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|txr
operator|->
name|txtag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|txr
operator|->
name|txtag
argument_list|)
expr_stmt|;
name|txr
operator|->
name|txtag
operator|=
name|NULL
expr_stmt|;
block|}
return|return;
block|}
comment|/*********************************************************************  *  *  Advanced Context Descriptor setup for VLAN, CSUM or TSO  *  **********************************************************************/
specifier|static
name|int
name|ixgbe_tx_ctx_setup
parameter_list|(
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mp
parameter_list|,
name|u32
modifier|*
name|cmd_type_len
parameter_list|,
name|u32
modifier|*
name|olinfo_status
parameter_list|)
block|{
name|struct
name|ixgbe_adv_tx_context_desc
modifier|*
name|TXD
decl_stmt|;
name|struct
name|ether_vlan_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|u32
name|vlan_macip_lens
init|=
literal|0
decl_stmt|,
name|type_tucmd_mlhl
init|=
literal|0
decl_stmt|;
name|int
name|ehdrlen
decl_stmt|,
name|ip_hlen
init|=
literal|0
decl_stmt|;
name|u16
name|etype
decl_stmt|;
name|u8
name|ipproto
init|=
literal|0
decl_stmt|;
name|int
name|offload
init|=
name|TRUE
decl_stmt|;
name|int
name|ctxd
init|=
name|txr
operator|->
name|next_avail_desc
decl_stmt|;
name|u16
name|vtag
init|=
literal|0
decl_stmt|;
comment|/* First check if TSO is to be used */
if|if
condition|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
condition|)
return|return
operator|(
name|ixgbe_tso_setup
argument_list|(
name|txr
argument_list|,
name|mp
argument_list|,
name|cmd_type_len
argument_list|,
name|olinfo_status
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_OFFLOAD
operator|)
operator|==
literal|0
condition|)
name|offload
operator|=
name|FALSE
expr_stmt|;
comment|/* Indicate the whole packet as payload when not doing TSO */
operator|*
name|olinfo_status
operator||=
name|mp
operator|->
name|m_pkthdr
operator|.
name|len
operator|<<
name|IXGBE_ADVTXD_PAYLEN_SHIFT
expr_stmt|;
comment|/* Now ready a context descriptor */
name|TXD
operator|=
operator|(
expr|struct
name|ixgbe_adv_tx_context_desc
operator|*
operator|)
operator|&
name|txr
operator|->
name|tx_base
index|[
name|ctxd
index|]
expr_stmt|;
comment|/* 	** In advanced descriptors the vlan tag must  	** be placed into the context descriptor. Hence 	** we need to make one even if not doing offloads. 	*/
if|if
condition|(
name|mp
operator|->
name|m_flags
operator|&
name|M_VLANTAG
condition|)
block|{
name|vtag
operator|=
name|htole16
argument_list|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
argument_list|)
expr_stmt|;
name|vlan_macip_lens
operator||=
operator|(
name|vtag
operator|<<
name|IXGBE_ADVTXD_VLAN_SHIFT
operator|)
expr_stmt|;
block|}
comment|/* 	 * Determine where frame payload starts. 	 * Jump over vlan headers if already present, 	 * helpful for QinQ too. 	 */
name|eh
operator|=
name|mtod
argument_list|(
name|mp
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|evl_encap_proto
operator|==
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
condition|)
block|{
name|etype
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|evl_proto
argument_list|)
expr_stmt|;
name|ehdrlen
operator|=
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
block|}
else|else
block|{
name|etype
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|evl_encap_proto
argument_list|)
expr_stmt|;
name|ehdrlen
operator|=
name|ETHER_HDR_LEN
expr_stmt|;
block|}
comment|/* Set the ether header length */
name|vlan_macip_lens
operator||=
name|ehdrlen
operator|<<
name|IXGBE_ADVTXD_MACLEN_SHIFT
expr_stmt|;
if|if
condition|(
name|offload
operator|==
name|FALSE
condition|)
goto|goto
name|no_offloads
goto|;
switch|switch
condition|(
name|etype
condition|)
block|{
case|case
name|ETHERTYPE_IP
case|:
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|mp
operator|->
name|m_data
operator|+
name|ehdrlen
operator|)
expr_stmt|;
name|ip_hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
name|ipproto
operator|=
name|ip
operator|->
name|ip_p
expr_stmt|;
name|type_tucmd_mlhl
operator||=
name|IXGBE_ADVTXD_TUCMD_IPV4
expr_stmt|;
break|break;
case|case
name|ETHERTYPE_IPV6
case|:
name|ip6
operator|=
operator|(
expr|struct
name|ip6_hdr
operator|*
operator|)
operator|(
name|mp
operator|->
name|m_data
operator|+
name|ehdrlen
operator|)
expr_stmt|;
name|ip_hlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
comment|/* XXX-BZ this will go badly in case of ext hdrs. */
name|ipproto
operator|=
name|ip6
operator|->
name|ip6_nxt
expr_stmt|;
name|type_tucmd_mlhl
operator||=
name|IXGBE_ADVTXD_TUCMD_IPV6
expr_stmt|;
break|break;
default|default:
name|offload
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
name|vlan_macip_lens
operator||=
name|ip_hlen
expr_stmt|;
switch|switch
condition|(
name|ipproto
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
if|if
condition|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TCP
condition|)
name|type_tucmd_mlhl
operator||=
name|IXGBE_ADVTXD_TUCMD_L4T_TCP
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
if|if
condition|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_UDP
condition|)
name|type_tucmd_mlhl
operator||=
name|IXGBE_ADVTXD_TUCMD_L4T_UDP
expr_stmt|;
break|break;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
case|case
name|IPPROTO_SCTP
case|:
if|if
condition|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_SCTP
condition|)
name|type_tucmd_mlhl
operator||=
name|IXGBE_ADVTXD_TUCMD_L4T_SCTP
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|offload
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|offload
condition|)
comment|/* For the TX descriptor setup */
operator|*
name|olinfo_status
operator||=
name|IXGBE_TXD_POPTS_TXSM
operator|<<
literal|8
expr_stmt|;
name|no_offloads
label|:
name|type_tucmd_mlhl
operator||=
name|IXGBE_ADVTXD_DCMD_DEXT
operator||
name|IXGBE_ADVTXD_DTYP_CTXT
expr_stmt|;
comment|/* Now copy bits into descriptor */
name|TXD
operator|->
name|vlan_macip_lens
operator|=
name|htole32
argument_list|(
name|vlan_macip_lens
argument_list|)
expr_stmt|;
name|TXD
operator|->
name|type_tucmd_mlhl
operator|=
name|htole32
argument_list|(
name|type_tucmd_mlhl
argument_list|)
expr_stmt|;
name|TXD
operator|->
name|seqnum_seed
operator|=
name|htole32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|TXD
operator|->
name|mss_l4len_idx
operator|=
name|htole32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* We've consumed the first desc, adjust counters */
if|if
condition|(
operator|++
name|ctxd
operator|==
name|txr
operator|->
name|num_desc
condition|)
name|ctxd
operator|=
literal|0
expr_stmt|;
name|txr
operator|->
name|next_avail_desc
operator|=
name|ctxd
expr_stmt|;
operator|--
name|txr
operator|->
name|tx_avail
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/**********************************************************************  *  *  Setup work for hardware segmentation offload (TSO) on  *  adapters using advanced tx descriptors  *  **********************************************************************/
specifier|static
name|int
name|ixgbe_tso_setup
parameter_list|(
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mp
parameter_list|,
name|u32
modifier|*
name|cmd_type_len
parameter_list|,
name|u32
modifier|*
name|olinfo_status
parameter_list|)
block|{
name|struct
name|ixgbe_adv_tx_context_desc
modifier|*
name|TXD
decl_stmt|;
name|u32
name|vlan_macip_lens
init|=
literal|0
decl_stmt|,
name|type_tucmd_mlhl
init|=
literal|0
decl_stmt|;
name|u32
name|mss_l4len_idx
init|=
literal|0
decl_stmt|,
name|paylen
decl_stmt|;
name|u16
name|vtag
init|=
literal|0
decl_stmt|,
name|eh_type
decl_stmt|;
name|int
name|ctxd
decl_stmt|,
name|ehdrlen
decl_stmt|,
name|ip_hlen
decl_stmt|,
name|tcp_hlen
decl_stmt|;
name|struct
name|ether_vlan_header
modifier|*
name|eh
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
endif|#
directive|endif
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|;
comment|/* 	 * Determine where frame payload starts. 	 * Jump over vlan headers if already present 	 */
name|eh
operator|=
name|mtod
argument_list|(
name|mp
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|evl_encap_proto
operator|==
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
condition|)
block|{
name|ehdrlen
operator|=
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
name|eh_type
operator|=
name|eh
operator|->
name|evl_proto
expr_stmt|;
block|}
else|else
block|{
name|ehdrlen
operator|=
name|ETHER_HDR_LEN
expr_stmt|;
name|eh_type
operator|=
name|eh
operator|->
name|evl_encap_proto
expr_stmt|;
block|}
switch|switch
condition|(
name|ntohs
argument_list|(
name|eh_type
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|ETHERTYPE_IPV6
case|:
name|ip6
operator|=
operator|(
expr|struct
name|ip6_hdr
operator|*
operator|)
operator|(
name|mp
operator|->
name|m_data
operator|+
name|ehdrlen
operator|)
expr_stmt|;
comment|/* XXX-BZ For now we do not pretend to support ext. hdrs. */
if|if
condition|(
name|ip6
operator|->
name|ip6_nxt
operator|!=
name|IPPROTO_TCP
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|ip_hlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
name|ip6
operator|=
operator|(
expr|struct
name|ip6_hdr
operator|*
operator|)
operator|(
name|mp
operator|->
name|m_data
operator|+
name|ehdrlen
operator|)
expr_stmt|;
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip6
operator|+
name|ip_hlen
operator|)
expr_stmt|;
name|th
operator|->
name|th_sum
operator|=
name|in6_cksum_pseudo
argument_list|(
name|ip6
argument_list|,
literal|0
argument_list|,
name|IPPROTO_TCP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|type_tucmd_mlhl
operator||=
name|IXGBE_ADVTXD_TUCMD_IPV6
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
case|case
name|ETHERTYPE_IP
case|:
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|mp
operator|->
name|m_data
operator|+
name|ehdrlen
operator|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|!=
name|IPPROTO_TCP
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|ip
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
name|ip_hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
name|ip_hlen
operator|)
expr_stmt|;
name|th
operator|->
name|th_sum
operator|=
name|in_pseudo
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|,
name|htons
argument_list|(
name|IPPROTO_TCP
argument_list|)
argument_list|)
expr_stmt|;
name|type_tucmd_mlhl
operator||=
name|IXGBE_ADVTXD_TUCMD_IPV4
expr_stmt|;
comment|/* Tell transmit desc to also do IPv4 checksum. */
operator|*
name|olinfo_status
operator||=
name|IXGBE_TXD_POPTS_IXSM
operator|<<
literal|8
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|panic
argument_list|(
literal|"%s: CSUM_TSO but no supported IP version (0x%04x)"
argument_list|,
name|__func__
argument_list|,
name|ntohs
argument_list|(
name|eh_type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|ctxd
operator|=
name|txr
operator|->
name|next_avail_desc
expr_stmt|;
name|TXD
operator|=
operator|(
expr|struct
name|ixgbe_adv_tx_context_desc
operator|*
operator|)
operator|&
name|txr
operator|->
name|tx_base
index|[
name|ctxd
index|]
expr_stmt|;
name|tcp_hlen
operator|=
name|th
operator|->
name|th_off
operator|<<
literal|2
expr_stmt|;
comment|/* This is used in the transmit desc in encap */
name|paylen
operator|=
name|mp
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|ehdrlen
operator|-
name|ip_hlen
operator|-
name|tcp_hlen
expr_stmt|;
comment|/* VLAN MACLEN IPLEN */
if|if
condition|(
name|mp
operator|->
name|m_flags
operator|&
name|M_VLANTAG
condition|)
block|{
name|vtag
operator|=
name|htole16
argument_list|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
argument_list|)
expr_stmt|;
name|vlan_macip_lens
operator||=
operator|(
name|vtag
operator|<<
name|IXGBE_ADVTXD_VLAN_SHIFT
operator|)
expr_stmt|;
block|}
name|vlan_macip_lens
operator||=
name|ehdrlen
operator|<<
name|IXGBE_ADVTXD_MACLEN_SHIFT
expr_stmt|;
name|vlan_macip_lens
operator||=
name|ip_hlen
expr_stmt|;
name|TXD
operator|->
name|vlan_macip_lens
operator|=
name|htole32
argument_list|(
name|vlan_macip_lens
argument_list|)
expr_stmt|;
comment|/* ADV DTYPE TUCMD */
name|type_tucmd_mlhl
operator||=
name|IXGBE_ADVTXD_DCMD_DEXT
operator||
name|IXGBE_ADVTXD_DTYP_CTXT
expr_stmt|;
name|type_tucmd_mlhl
operator||=
name|IXGBE_ADVTXD_TUCMD_L4T_TCP
expr_stmt|;
name|TXD
operator|->
name|type_tucmd_mlhl
operator|=
name|htole32
argument_list|(
name|type_tucmd_mlhl
argument_list|)
expr_stmt|;
comment|/* MSS L4LEN IDX */
name|mss_l4len_idx
operator||=
operator|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
operator|<<
name|IXGBE_ADVTXD_MSS_SHIFT
operator|)
expr_stmt|;
name|mss_l4len_idx
operator||=
operator|(
name|tcp_hlen
operator|<<
name|IXGBE_ADVTXD_L4LEN_SHIFT
operator|)
expr_stmt|;
name|TXD
operator|->
name|mss_l4len_idx
operator|=
name|htole32
argument_list|(
name|mss_l4len_idx
argument_list|)
expr_stmt|;
name|TXD
operator|->
name|seqnum_seed
operator|=
name|htole32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|ctxd
operator|==
name|txr
operator|->
name|num_desc
condition|)
name|ctxd
operator|=
literal|0
expr_stmt|;
name|txr
operator|->
name|tx_avail
operator|--
expr_stmt|;
name|txr
operator|->
name|next_avail_desc
operator|=
name|ctxd
expr_stmt|;
operator|*
name|cmd_type_len
operator||=
name|IXGBE_ADVTXD_DCMD_TSE
expr_stmt|;
operator|*
name|olinfo_status
operator||=
name|IXGBE_TXD_POPTS_TXSM
operator|<<
literal|8
expr_stmt|;
operator|*
name|olinfo_status
operator||=
name|paylen
operator|<<
name|IXGBE_ADVTXD_PAYLEN_SHIFT
expr_stmt|;
operator|++
name|txr
operator|->
name|tso_tx
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/**********************************************************************  *  *  Examine each tx_buffer in the used queue. If the hardware is done  *  processing the packet then free associated resources. The  *  tx_buffer is put back on the free queue.  *  **********************************************************************/
name|void
name|ixgbe_txeof
parameter_list|(
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
endif|#
directive|endif
name|u32
name|work
decl_stmt|,
name|processed
init|=
literal|0
decl_stmt|;
name|u16
name|limit
init|=
name|txr
operator|->
name|process_limit
decl_stmt|;
name|struct
name|ixgbe_tx_buf
modifier|*
name|buf
decl_stmt|;
name|union
name|ixgbe_adv_tx_desc
modifier|*
name|txd
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|txr
operator|->
name|tx_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
condition|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|tx_rings
index|[
name|txr
operator|->
name|me
index|]
decl_stmt|;
name|txd
operator|=
name|txr
operator|->
name|tx_base
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txdma
operator|.
name|dma_tag
argument_list|,
name|txr
operator|->
name|txdma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
comment|/* 		 * In netmap mode, all the work is done in the context 		 * of the client thread. Interrupt handlers only wake up 		 * clients, which may be sleeping on individual rings 		 * or on a global resource for all rings. 		 * To implement tx interrupt mitigation, we wake up the client 		 * thread roughly every half ring, even if the NIC interrupts 		 * more frequently. This is implemented as follows: 		 * - ixgbe_txsync() sets kring->nr_kflags with the index of 		 *   the slot that should wake up the thread (nkr_num_slots 		 *   means the user thread should not be woken up); 		 * - the driver ignores tx interrupts unless netmap_mitigate=0 		 *   or the slot has the DD bit set. 		 */
if|if
condition|(
operator|!
name|netmap_mitigate
operator|||
operator|(
name|kring
operator|->
name|nr_kflags
operator|<
name|kring
operator|->
name|nkr_num_slots
operator|&&
name|txd
index|[
name|kring
operator|->
name|nr_kflags
index|]
operator|.
name|wb
operator|.
name|status
operator|&
name|IXGBE_TXD_STAT_DD
operator|)
condition|)
block|{
name|netmap_tx_irq
argument_list|(
name|ifp
argument_list|,
name|txr
operator|->
name|me
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
endif|#
directive|endif
comment|/* DEV_NETMAP */
if|if
condition|(
name|txr
operator|->
name|tx_avail
operator|==
name|txr
operator|->
name|num_desc
condition|)
block|{
name|txr
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* Get work starting point */
name|work
operator|=
name|txr
operator|->
name|next_to_clean
expr_stmt|;
name|buf
operator|=
operator|&
name|txr
operator|->
name|tx_buffers
index|[
name|work
index|]
expr_stmt|;
name|txd
operator|=
operator|&
name|txr
operator|->
name|tx_base
index|[
name|work
index|]
expr_stmt|;
name|work
operator|-=
name|txr
operator|->
name|num_desc
expr_stmt|;
comment|/* The distance to ring end */
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txdma
operator|.
name|dma_tag
argument_list|,
name|txr
operator|->
name|txdma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
do|do
block|{
name|union
name|ixgbe_adv_tx_desc
modifier|*
name|eop
init|=
name|buf
operator|->
name|eop
decl_stmt|;
if|if
condition|(
name|eop
operator|==
name|NULL
condition|)
comment|/* No work */
break|break;
if|if
condition|(
operator|(
name|eop
operator|->
name|wb
operator|.
name|status
operator|&
name|IXGBE_TXD_STAT_DD
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* I/O not complete */
if|if
condition|(
name|buf
operator|->
name|m_head
condition|)
block|{
name|txr
operator|->
name|bytes
operator|+=
name|buf
operator|->
name|m_head
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|buf
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|buf
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|buf
operator|->
name|m_head
argument_list|)
expr_stmt|;
name|buf
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|map
operator|=
name|NULL
expr_stmt|;
block|}
name|buf
operator|->
name|eop
operator|=
name|NULL
expr_stmt|;
operator|++
name|txr
operator|->
name|tx_avail
expr_stmt|;
comment|/* We clean the range if multi segment */
while|while
condition|(
name|txd
operator|!=
name|eop
condition|)
block|{
operator|++
name|txd
expr_stmt|;
operator|++
name|buf
expr_stmt|;
operator|++
name|work
expr_stmt|;
comment|/* wrap the ring? */
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
name|work
argument_list|)
condition|)
block|{
name|work
operator|-=
name|txr
operator|->
name|num_desc
expr_stmt|;
name|buf
operator|=
name|txr
operator|->
name|tx_buffers
expr_stmt|;
name|txd
operator|=
name|txr
operator|->
name|tx_base
expr_stmt|;
block|}
if|if
condition|(
name|buf
operator|->
name|m_head
condition|)
block|{
name|txr
operator|->
name|bytes
operator|+=
name|buf
operator|->
name|m_head
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|buf
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|txr
operator|->
name|txtag
argument_list|,
name|buf
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|buf
operator|->
name|m_head
argument_list|)
expr_stmt|;
name|buf
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|map
operator|=
name|NULL
expr_stmt|;
block|}
operator|++
name|txr
operator|->
name|tx_avail
expr_stmt|;
name|buf
operator|->
name|eop
operator|=
name|NULL
expr_stmt|;
block|}
operator|++
name|txr
operator|->
name|packets
expr_stmt|;
operator|++
name|processed
expr_stmt|;
comment|/* Try the next packet */
operator|++
name|txd
expr_stmt|;
operator|++
name|buf
expr_stmt|;
operator|++
name|work
expr_stmt|;
comment|/* reset with a wrap */
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
name|work
argument_list|)
condition|)
block|{
name|work
operator|-=
name|txr
operator|->
name|num_desc
expr_stmt|;
name|buf
operator|=
name|txr
operator|->
name|tx_buffers
expr_stmt|;
name|txd
operator|=
name|txr
operator|->
name|tx_base
expr_stmt|;
block|}
name|prefetch
argument_list|(
name|txd
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|__predict_true
argument_list|(
operator|--
name|limit
argument_list|)
condition|)
do|;
name|bus_dmamap_sync
argument_list|(
name|txr
operator|->
name|txdma
operator|.
name|dma_tag
argument_list|,
name|txr
operator|->
name|txdma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|work
operator|+=
name|txr
operator|->
name|num_desc
expr_stmt|;
name|txr
operator|->
name|next_to_clean
operator|=
name|work
expr_stmt|;
comment|/* 	** Queue Hang detection, we know there's 	** work outstanding or the first return 	** would have been taken, so increment busy 	** if nothing managed to get cleaned, then 	** in local_timer it will be checked and  	** marked as HUNG if it exceeds a MAX attempt. 	*/
if|if
condition|(
operator|(
name|processed
operator|==
literal|0
operator|)
operator|&&
operator|(
name|txr
operator|->
name|busy
operator|!=
name|IXGBE_QUEUE_HUNG
operator|)
condition|)
operator|++
name|txr
operator|->
name|busy
expr_stmt|;
comment|/* 	** If anything gets cleaned we reset state to 1, 	** note this will turn off HUNG if its set. 	*/
if|if
condition|(
name|processed
condition|)
name|txr
operator|->
name|busy
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|tx_avail
operator|==
name|txr
operator|->
name|num_desc
condition|)
name|txr
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|IXGBE_FDIR
comment|/* ** This routine parses packet headers so that Flow ** Director can make a hashed filter table entry  ** allowing traffic flows to be identified and kept ** on the same cpu.  This would be a performance ** hit, but we only do it at IXGBE_FDIR_RATE of ** packets. */
specifier|static
name|void
name|ixgbe_atr
parameter_list|(
name|struct
name|tx_ring
modifier|*
name|txr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mp
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|txr
operator|->
name|adapter
decl_stmt|;
name|struct
name|ix_queue
modifier|*
name|que
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|;
name|struct
name|udphdr
modifier|*
name|uh
decl_stmt|;
name|struct
name|ether_vlan_header
modifier|*
name|eh
decl_stmt|;
name|union
name|ixgbe_atr_hash_dword
name|input
init|=
block|{
operator|.
name|dword
operator|=
literal|0
block|}
decl_stmt|;
name|union
name|ixgbe_atr_hash_dword
name|common
init|=
block|{
operator|.
name|dword
operator|=
literal|0
block|}
decl_stmt|;
name|int
name|ehdrlen
decl_stmt|,
name|ip_hlen
decl_stmt|;
name|u16
name|etype
decl_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|mp
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|evl_encap_proto
operator|==
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
condition|)
block|{
name|ehdrlen
operator|=
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
name|etype
operator|=
name|eh
operator|->
name|evl_proto
expr_stmt|;
block|}
else|else
block|{
name|ehdrlen
operator|=
name|ETHER_HDR_LEN
expr_stmt|;
name|etype
operator|=
name|eh
operator|->
name|evl_encap_proto
expr_stmt|;
block|}
comment|/* Only handling IPv4 */
if|if
condition|(
name|etype
operator|!=
name|htons
argument_list|(
name|ETHERTYPE_IP
argument_list|)
condition|)
return|return;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|mp
operator|->
name|m_data
operator|+
name|ehdrlen
operator|)
expr_stmt|;
name|ip_hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
comment|/* check if we're UDP or TCP */
switch|switch
condition|(
name|ip
operator|->
name|ip_p
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
name|ip_hlen
operator|)
expr_stmt|;
comment|/* src and dst are inverted */
name|common
operator|.
name|port
operator|.
name|dst
operator|^=
name|th
operator|->
name|th_sport
expr_stmt|;
name|common
operator|.
name|port
operator|.
name|src
operator|^=
name|th
operator|->
name|th_dport
expr_stmt|;
name|input
operator|.
name|formatted
operator|.
name|flow_type
operator|^=
name|IXGBE_ATR_FLOW_TYPE_TCPV4
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
name|uh
operator|=
operator|(
expr|struct
name|udphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
name|ip_hlen
operator|)
expr_stmt|;
comment|/* src and dst are inverted */
name|common
operator|.
name|port
operator|.
name|dst
operator|^=
name|uh
operator|->
name|uh_sport
expr_stmt|;
name|common
operator|.
name|port
operator|.
name|src
operator|^=
name|uh
operator|->
name|uh_dport
expr_stmt|;
name|input
operator|.
name|formatted
operator|.
name|flow_type
operator|^=
name|IXGBE_ATR_FLOW_TYPE_UDPV4
expr_stmt|;
break|break;
default|default:
return|return;
block|}
name|input
operator|.
name|formatted
operator|.
name|vlan_id
operator|=
name|htobe16
argument_list|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
condition|)
name|common
operator|.
name|flex_bytes
operator|^=
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
expr_stmt|;
else|else
name|common
operator|.
name|flex_bytes
operator|^=
name|etype
expr_stmt|;
name|common
operator|.
name|ip
operator|^=
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|^
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
expr_stmt|;
name|que
operator|=
operator|&
name|adapter
operator|->
name|queues
index|[
name|txr
operator|->
name|me
index|]
expr_stmt|;
comment|/* 	** This assumes the Rx queue and Tx 	** queue are bound to the same CPU 	*/
name|ixgbe_fdir_add_signature_filter_82599
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|input
argument_list|,
name|common
argument_list|,
name|que
operator|->
name|msix
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* IXGBE_FDIR */
comment|/* ** Used to detect a descriptor that has ** been merged by Hardware RSC. */
specifier|static
specifier|inline
name|u32
name|ixgbe_rsc_count
parameter_list|(
name|union
name|ixgbe_adv_rx_desc
modifier|*
name|rx
parameter_list|)
block|{
return|return
operator|(
name|le32toh
argument_list|(
name|rx
operator|->
name|wb
operator|.
name|lower
operator|.
name|lo_dword
operator|.
name|data
argument_list|)
operator|&
name|IXGBE_RXDADV_RSCCNT_MASK
operator|)
operator|>>
name|IXGBE_RXDADV_RSCCNT_SHIFT
return|;
block|}
comment|/*********************************************************************  *  *  Initialize Hardware RSC (LRO) feature on 82599  *  for an RX ring, this is toggled by the LRO capability  *  even though it is transparent to the stack.  *  *  NOTE: since this HW feature only works with IPV4 and   *        our testing has shown soft LRO to be as effective  *        I have decided to disable this by default.  *  **********************************************************************/
specifier|static
name|void
name|ixgbe_setup_hw_rsc
parameter_list|(
name|struct
name|rx_ring
modifier|*
name|rxr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|rxr
operator|->
name|adapter
decl_stmt|;
name|struct
name|ixgbe_hw
modifier|*
name|hw
init|=
operator|&
name|adapter
operator|->
name|hw
decl_stmt|;
name|u32
name|rscctrl
decl_stmt|,
name|rdrxctl
decl_stmt|;
comment|/* If turning LRO/RSC off we need to disable it */
if|if
condition|(
operator|(
name|adapter
operator|->
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_LRO
operator|)
operator|==
literal|0
condition|)
block|{
name|rscctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RSCCTL
argument_list|(
name|rxr
operator|->
name|me
argument_list|)
argument_list|)
expr_stmt|;
name|rscctrl
operator|&=
operator|~
name|IXGBE_RSCCTL_RSCEN
expr_stmt|;
return|return;
block|}
name|rdrxctl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RDRXCTL
argument_list|)
expr_stmt|;
name|rdrxctl
operator|&=
operator|~
name|IXGBE_RDRXCTL_RSCFRSTSIZE
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
comment|/* crcstrip is optional in netmap */
if|if
condition|(
name|adapter
operator|->
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
operator|&&
operator|!
name|ix_crcstrip
condition|)
endif|#
directive|endif
comment|/* DEV_NETMAP */
name|rdrxctl
operator||=
name|IXGBE_RDRXCTL_CRCSTRIP
expr_stmt|;
name|rdrxctl
operator||=
name|IXGBE_RDRXCTL_RSCACKC
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RDRXCTL
argument_list|,
name|rdrxctl
argument_list|)
expr_stmt|;
name|rscctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RSCCTL
argument_list|(
name|rxr
operator|->
name|me
argument_list|)
argument_list|)
expr_stmt|;
name|rscctrl
operator||=
name|IXGBE_RSCCTL_RSCEN
expr_stmt|;
comment|/* 	** Limit the total number of descriptors that 	** can be combined, so it does not exceed 64K 	*/
if|if
condition|(
name|rxr
operator|->
name|mbuf_sz
operator|==
name|MCLBYTES
condition|)
name|rscctrl
operator||=
name|IXGBE_RSCCTL_MAXDESC_16
expr_stmt|;
elseif|else
if|if
condition|(
name|rxr
operator|->
name|mbuf_sz
operator|==
name|MJUMPAGESIZE
condition|)
name|rscctrl
operator||=
name|IXGBE_RSCCTL_MAXDESC_8
expr_stmt|;
elseif|else
if|if
condition|(
name|rxr
operator|->
name|mbuf_sz
operator|==
name|MJUM9BYTES
condition|)
name|rscctrl
operator||=
name|IXGBE_RSCCTL_MAXDESC_4
expr_stmt|;
else|else
comment|/* Using 16K cluster */
name|rscctrl
operator||=
name|IXGBE_RSCCTL_MAXDESC_1
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RSCCTL
argument_list|(
name|rxr
operator|->
name|me
argument_list|)
argument_list|,
name|rscctrl
argument_list|)
expr_stmt|;
comment|/* Enable TCP header recognition */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PSRTYPE
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_PSRTYPE
argument_list|(
literal|0
argument_list|)
argument_list|)
operator||
name|IXGBE_PSRTYPE_TCPHDR
operator|)
argument_list|)
expr_stmt|;
comment|/* Disable RSC for ACK packets */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RSCDBU
argument_list|,
operator|(
name|IXGBE_RSCDBU_RSCACKDIS
operator||
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RSCDBU
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|hw_rsc
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/*********************************************************************  *  *  Refresh mbuf buffers for RX descriptor rings  *   - now keeps its own state so discards due to resource  *     exhaustion are unnecessary, if an mbuf cannot be obtained  *     it just returns, keeping its placeholder, thus it can simply  *     be recalled to try again.  *  **********************************************************************/
specifier|static
name|void
name|ixgbe_refresh_mbufs
parameter_list|(
name|struct
name|rx_ring
modifier|*
name|rxr
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|rxr
operator|->
name|adapter
decl_stmt|;
name|bus_dma_segment_t
name|seg
index|[
literal|1
index|]
decl_stmt|;
name|struct
name|ixgbe_rx_buf
modifier|*
name|rxbuf
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|nsegs
decl_stmt|,
name|error
decl_stmt|;
name|bool
name|refreshed
init|=
name|FALSE
decl_stmt|;
name|i
operator|=
name|j
operator|=
name|rxr
operator|->
name|next_to_refresh
expr_stmt|;
comment|/* Control the loop with one beyond */
if|if
condition|(
operator|++
name|j
operator|==
name|rxr
operator|->
name|num_desc
condition|)
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|j
operator|!=
name|limit
condition|)
block|{
name|rxbuf
operator|=
operator|&
name|rxr
operator|->
name|rx_buffers
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rxbuf
operator|->
name|buf
operator|==
name|NULL
condition|)
block|{
name|mp
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|rxr
operator|->
name|mbuf_sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
goto|goto
name|update
goto|;
if|if
condition|(
name|adapter
operator|->
name|max_frame_size
operator|<=
operator|(
name|MCLBYTES
operator|-
name|ETHER_ALIGN
operator|)
condition|)
name|m_adj
argument_list|(
name|mp
argument_list|,
name|ETHER_ALIGN
argument_list|)
expr_stmt|;
block|}
else|else
name|mp
operator|=
name|rxbuf
operator|->
name|buf
expr_stmt|;
name|mp
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|mp
operator|->
name|m_len
operator|=
name|rxr
operator|->
name|mbuf_sz
expr_stmt|;
comment|/* If we're dealing with an mbuf that was copied rather 		 * than replaced, there's no need to go through busdma. 		 */
if|if
condition|(
operator|(
name|rxbuf
operator|->
name|flags
operator|&
name|IXGBE_RX_COPY
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Get the memory mapping */
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
name|rxbuf
operator|->
name|pmap
argument_list|,
name|mp
argument_list|,
name|seg
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Refresh mbufs: payload dmamap load"
literal|" failure - %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|rxbuf
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
goto|goto
name|update
goto|;
block|}
name|rxbuf
operator|->
name|buf
operator|=
name|mp
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
name|rxbuf
operator|->
name|pmap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|rxbuf
operator|->
name|addr
operator|=
name|rxr
operator|->
name|rx_base
index|[
name|i
index|]
operator|.
name|read
operator|.
name|pkt_addr
operator|=
name|htole64
argument_list|(
name|seg
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rxr
operator|->
name|rx_base
index|[
name|i
index|]
operator|.
name|read
operator|.
name|pkt_addr
operator|=
name|rxbuf
operator|->
name|addr
expr_stmt|;
name|rxbuf
operator|->
name|flags
operator|&=
operator|~
name|IXGBE_RX_COPY
expr_stmt|;
block|}
name|refreshed
operator|=
name|TRUE
expr_stmt|;
comment|/* Next is precalculated */
name|i
operator|=
name|j
expr_stmt|;
name|rxr
operator|->
name|next_to_refresh
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|++
name|j
operator|==
name|rxr
operator|->
name|num_desc
condition|)
name|j
operator|=
literal|0
expr_stmt|;
block|}
name|update
label|:
if|if
condition|(
name|refreshed
condition|)
comment|/* Update hardware tail index */
name|IXGBE_WRITE_REG
argument_list|(
operator|&
name|adapter
operator|->
name|hw
argument_list|,
name|rxr
operator|->
name|tail
argument_list|,
name|rxr
operator|->
name|next_to_refresh
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*********************************************************************  *  *  Allocate memory for rx_buffer structures. Since we use one  *  rx_buffer per received packet, the maximum number of rx_buffer's  *  that we'll need is equal to the number of receive descriptors  *  that we've allocated.  *  **********************************************************************/
name|int
name|ixgbe_allocate_receive_buffers
parameter_list|(
name|struct
name|rx_ring
modifier|*
name|rxr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|rxr
operator|->
name|adapter
decl_stmt|;
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|ixgbe_rx_buf
modifier|*
name|rxbuf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|bsize
decl_stmt|,
name|error
decl_stmt|;
name|bsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ixgbe_rx_buf
argument_list|)
operator|*
name|rxr
operator|->
name|num_desc
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|rxr
operator|->
name|rx_buffers
operator|=
operator|(
expr|struct
name|ixgbe_rx_buf
operator|*
operator|)
name|malloc
argument_list|(
name|bsize
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate rx_buffer memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|MJUM16BYTES
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|MJUM16BYTES
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockfuncarg */
operator|&
name|rxr
operator|->
name|ptag
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to create RX DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rxr
operator|->
name|num_desc
condition|;
name|i
operator|++
operator|,
name|rxbuf
operator|++
control|)
block|{
name|rxbuf
operator|=
operator|&
name|rxr
operator|->
name|rx_buffers
index|[
name|i
index|]
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|rxbuf
operator|->
name|pmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to create RX dma map\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
comment|/* Frees all, but can handle partial completion */
name|ixgbe_free_receive_structures
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
specifier|static
name|void
name|ixgbe_free_receive_ring
parameter_list|(
name|struct
name|rx_ring
modifier|*
name|rxr
parameter_list|)
block|{
name|struct
name|ixgbe_rx_buf
modifier|*
name|rxbuf
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rxr
operator|->
name|num_desc
condition|;
name|i
operator|++
control|)
block|{
name|rxbuf
operator|=
operator|&
name|rxr
operator|->
name|rx_buffers
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rxbuf
operator|->
name|buf
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
name|rxbuf
operator|->
name|pmap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
name|rxbuf
operator|->
name|pmap
argument_list|)
expr_stmt|;
name|rxbuf
operator|->
name|buf
operator|->
name|m_flags
operator||=
name|M_PKTHDR
expr_stmt|;
name|m_freem
argument_list|(
name|rxbuf
operator|->
name|buf
argument_list|)
expr_stmt|;
name|rxbuf
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
name|rxbuf
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/*********************************************************************  *  *  Initialize a receive ring and its buffers.  *  **********************************************************************/
specifier|static
name|int
name|ixgbe_setup_receive_ring
parameter_list|(
name|struct
name|rx_ring
modifier|*
name|rxr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|struct
name|ixgbe_rx_buf
modifier|*
name|rxbuf
decl_stmt|;
name|bus_dma_segment_t
name|seg
index|[
literal|1
index|]
decl_stmt|;
name|struct
name|lro_ctrl
modifier|*
name|lro
init|=
operator|&
name|rxr
operator|->
name|lro
decl_stmt|;
name|int
name|rsize
decl_stmt|,
name|nsegs
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|rxr
operator|->
name|adapter
operator|->
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_slot
modifier|*
name|slot
decl_stmt|;
endif|#
directive|endif
comment|/* DEV_NETMAP */
name|adapter
operator|=
name|rxr
operator|->
name|adapter
expr_stmt|;
name|ifp
operator|=
name|adapter
operator|->
name|ifp
expr_stmt|;
name|dev
operator|=
name|adapter
operator|->
name|dev
expr_stmt|;
comment|/* Clear the ring contents */
name|IXGBE_RX_LOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
comment|/* same as in ixgbe_setup_transmit_ring() */
name|slot
operator|=
name|netmap_reset
argument_list|(
name|na
argument_list|,
name|NR_RX
argument_list|,
name|rxr
operator|->
name|me
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEV_NETMAP */
name|rsize
operator|=
name|roundup2
argument_list|(
name|adapter
operator|->
name|num_rx_desc
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|ixgbe_adv_rx_desc
argument_list|)
argument_list|,
name|DBA_ALIGN
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|rxr
operator|->
name|rx_base
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
comment|/* Cache the size */
name|rxr
operator|->
name|mbuf_sz
operator|=
name|adapter
operator|->
name|rx_mbuf_sz
expr_stmt|;
comment|/* Free current RX buffer structs and their mbufs */
name|ixgbe_free_receive_ring
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
comment|/* Now replenish the mbufs */
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|!=
name|rxr
operator|->
name|num_desc
condition|;
operator|++
name|j
control|)
block|{
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|;
name|rxbuf
operator|=
operator|&
name|rxr
operator|->
name|rx_buffers
index|[
name|j
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
comment|/* 		 * In netmap mode, fill the map and set the buffer 		 * address in the NIC ring, considering the offset 		 * between the netmap and NIC rings (see comment in 		 * ixgbe_setup_transmit_ring() ). No need to allocate 		 * an mbuf, so end the block with a continue; 		 */
if|if
condition|(
name|slot
condition|)
block|{
name|int
name|sj
init|=
name|netmap_idx_n2k
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|rxr
operator|->
name|me
index|]
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|uint64_t
name|paddr
decl_stmt|;
name|void
modifier|*
name|addr
decl_stmt|;
name|addr
operator|=
name|PNMB
argument_list|(
name|na
argument_list|,
name|slot
operator|+
name|sj
argument_list|,
operator|&
name|paddr
argument_list|)
expr_stmt|;
name|netmap_load_map
argument_list|(
name|na
argument_list|,
name|rxr
operator|->
name|ptag
argument_list|,
name|rxbuf
operator|->
name|pmap
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* Update descriptor and the cached value */
name|rxr
operator|->
name|rx_base
index|[
name|j
index|]
operator|.
name|read
operator|.
name|pkt_addr
operator|=
name|htole64
argument_list|(
name|paddr
argument_list|)
expr_stmt|;
name|rxbuf
operator|->
name|addr
operator|=
name|htole64
argument_list|(
name|paddr
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
comment|/* DEV_NETMAP */
name|rxbuf
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|rxbuf
operator|->
name|buf
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|adapter
operator|->
name|rx_mbuf_sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxbuf
operator|->
name|buf
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|mp
operator|=
name|rxbuf
operator|->
name|buf
expr_stmt|;
name|mp
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|mp
operator|->
name|m_len
operator|=
name|rxr
operator|->
name|mbuf_sz
expr_stmt|;
comment|/* Get the memory mapping */
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
name|rxbuf
operator|->
name|pmap
argument_list|,
name|mp
argument_list|,
name|seg
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
name|rxbuf
operator|->
name|pmap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
comment|/* Update the descriptor and the cached value */
name|rxr
operator|->
name|rx_base
index|[
name|j
index|]
operator|.
name|read
operator|.
name|pkt_addr
operator|=
name|htole64
argument_list|(
name|seg
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|rxbuf
operator|->
name|addr
operator|=
name|htole64
argument_list|(
name|seg
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
block|}
comment|/* Setup our descriptor indices */
name|rxr
operator|->
name|next_to_check
operator|=
literal|0
expr_stmt|;
name|rxr
operator|->
name|next_to_refresh
operator|=
literal|0
expr_stmt|;
name|rxr
operator|->
name|lro_enabled
operator|=
name|FALSE
expr_stmt|;
name|rxr
operator|->
name|rx_copies
operator|=
literal|0
expr_stmt|;
name|rxr
operator|->
name|rx_bytes
operator|=
literal|0
expr_stmt|;
name|rxr
operator|->
name|vtag_strip
operator|=
name|FALSE
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|rxdma
operator|.
name|dma_tag
argument_list|,
name|rxr
operator|->
name|rxdma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* 	** Now set up the LRO interface: 	*/
if|if
condition|(
name|ixgbe_rsc_enable
condition|)
name|ixgbe_setup_hw_rsc
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_LRO
condition|)
block|{
name|int
name|err
init|=
name|tcp_lro_init
argument_list|(
name|lro
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"LRO Initialization failed!\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|INIT_DEBUGOUT
argument_list|(
literal|"RX Soft LRO Initialized\n"
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|lro_enabled
operator|=
name|TRUE
expr_stmt|;
name|lro
operator|->
name|ifp
operator|=
name|adapter
operator|->
name|ifp
expr_stmt|;
block|}
name|IXGBE_RX_UNLOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|ixgbe_free_receive_ring
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
name|IXGBE_RX_UNLOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*********************************************************************  *  *  Initialize all receive rings.  *  **********************************************************************/
name|int
name|ixgbe_setup_receive_structures
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
name|adapter
operator|->
name|rx_rings
decl_stmt|;
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|j
operator|++
operator|,
name|rxr
operator|++
control|)
if|if
condition|(
name|ixgbe_setup_receive_ring
argument_list|(
name|rxr
argument_list|)
condition|)
goto|goto
name|fail
goto|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
comment|/* 	 * Free RX buffers allocated so far, we will only handle 	 * the rings that completed, the failing case will have 	 * cleaned up for itself. 'j' failed, so its the terminus. 	 */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|j
condition|;
operator|++
name|i
control|)
block|{
name|rxr
operator|=
operator|&
name|adapter
operator|->
name|rx_rings
index|[
name|i
index|]
expr_stmt|;
name|ixgbe_free_receive_ring
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/*********************************************************************  *  *  Free all receive rings.  *  **********************************************************************/
name|void
name|ixgbe_free_receive_structures
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
name|adapter
operator|->
name|rx_rings
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgbe_free_receive_structures: begin"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|rxr
operator|++
control|)
block|{
name|struct
name|lro_ctrl
modifier|*
name|lro
init|=
operator|&
name|rxr
operator|->
name|lro
decl_stmt|;
name|ixgbe_free_receive_buffers
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
comment|/* Free LRO memory */
name|tcp_lro_free
argument_list|(
name|lro
argument_list|)
expr_stmt|;
comment|/* Free the ring memory as well */
name|ixgbe_dma_free
argument_list|(
name|adapter
argument_list|,
operator|&
name|rxr
operator|->
name|rxdma
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|adapter
operator|->
name|rx_rings
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
comment|/*********************************************************************  *  *  Free receive ring data structures  *  **********************************************************************/
name|void
name|ixgbe_free_receive_buffers
parameter_list|(
name|struct
name|rx_ring
modifier|*
name|rxr
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|rxr
operator|->
name|adapter
decl_stmt|;
name|struct
name|ixgbe_rx_buf
modifier|*
name|rxbuf
decl_stmt|;
name|INIT_DEBUGOUT
argument_list|(
literal|"ixgbe_free_receive_buffers: begin"
argument_list|)
expr_stmt|;
comment|/* Cleanup any existing buffers */
if|if
condition|(
name|rxr
operator|->
name|rx_buffers
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_rx_desc
condition|;
name|i
operator|++
control|)
block|{
name|rxbuf
operator|=
operator|&
name|rxr
operator|->
name|rx_buffers
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rxbuf
operator|->
name|buf
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
name|rxbuf
operator|->
name|pmap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
name|rxbuf
operator|->
name|pmap
argument_list|)
expr_stmt|;
name|rxbuf
operator|->
name|buf
operator|->
name|m_flags
operator||=
name|M_PKTHDR
expr_stmt|;
name|m_freem
argument_list|(
name|rxbuf
operator|->
name|buf
argument_list|)
expr_stmt|;
block|}
name|rxbuf
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rxbuf
operator|->
name|pmap
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|,
name|rxbuf
operator|->
name|pmap
argument_list|)
expr_stmt|;
name|rxbuf
operator|->
name|pmap
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rxr
operator|->
name|rx_buffers
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|rxr
operator|->
name|rx_buffers
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|rx_buffers
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rxr
operator|->
name|ptag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|rxr
operator|->
name|ptag
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|ptag
operator|=
name|NULL
expr_stmt|;
block|}
return|return;
block|}
specifier|static
name|__inline
name|void
name|ixgbe_rx_input
parameter_list|(
name|struct
name|rx_ring
modifier|*
name|rxr
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|u32
name|ptype
parameter_list|)
block|{
comment|/*          * ATM LRO is only for IP/TCP packets and TCP checksum of the packet          * should be computed by hardware. Also it should not have VLAN tag in          * ethernet header.  In case of IPv6 we do not yet support ext. hdrs.          */
if|if
condition|(
name|rxr
operator|->
name|lro_enabled
operator|&&
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWTAGGING
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ptype
operator|&
name|IXGBE_RXDADV_PKTTYPE_ETQF
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|ptype
operator|&
operator|(
name|IXGBE_RXDADV_PKTTYPE_IPV4
operator||
name|IXGBE_RXDADV_PKTTYPE_TCP
operator|)
operator|)
operator|==
operator|(
name|IXGBE_RXDADV_PKTTYPE_IPV4
operator||
name|IXGBE_RXDADV_PKTTYPE_TCP
operator|)
operator|||
operator|(
name|ptype
operator|&
operator|(
name|IXGBE_RXDADV_PKTTYPE_IPV6
operator||
name|IXGBE_RXDADV_PKTTYPE_TCP
operator|)
operator|)
operator|==
operator|(
name|IXGBE_RXDADV_PKTTYPE_IPV6
operator||
name|IXGBE_RXDADV_PKTTYPE_TCP
operator|)
operator|)
operator|&&
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
operator|)
operator|==
operator|(
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
condition|)
block|{
comment|/*                  * Send to the stack if:                  **  - LRO not enabled, or                  **  - no LRO resources, or                  **  - lro enqueue fails                  */
if|if
condition|(
name|rxr
operator|->
name|lro
operator|.
name|lro_cnt
operator|!=
literal|0
condition|)
if|if
condition|(
name|tcp_lro_rx
argument_list|(
operator|&
name|rxr
operator|->
name|lro
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return;
block|}
name|IXGBE_RX_UNLOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|IXGBE_RX_LOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
block|}
specifier|static
name|__inline
name|void
name|ixgbe_rx_discard
parameter_list|(
name|struct
name|rx_ring
modifier|*
name|rxr
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|struct
name|ixgbe_rx_buf
modifier|*
name|rbuf
decl_stmt|;
name|rbuf
operator|=
operator|&
name|rxr
operator|->
name|rx_buffers
index|[
name|i
index|]
expr_stmt|;
comment|/* 	** With advanced descriptors the writeback 	** clobbers the buffer addrs, so its easier 	** to just free the existing mbufs and take 	** the normal refresh path to get new buffers 	** and mapping. 	*/
if|if
condition|(
name|rbuf
operator|->
name|fmp
operator|!=
name|NULL
condition|)
block|{
comment|/* Partial chain ? */
name|rbuf
operator|->
name|fmp
operator|->
name|m_flags
operator||=
name|M_PKTHDR
expr_stmt|;
name|m_freem
argument_list|(
name|rbuf
operator|->
name|fmp
argument_list|)
expr_stmt|;
name|rbuf
operator|->
name|fmp
operator|=
name|NULL
expr_stmt|;
name|rbuf
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
comment|/* rbuf->buf is part of fmp's chain */
block|}
elseif|else
if|if
condition|(
name|rbuf
operator|->
name|buf
condition|)
block|{
name|m_free
argument_list|(
name|rbuf
operator|->
name|buf
argument_list|)
expr_stmt|;
name|rbuf
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
block|}
name|rbuf
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/*********************************************************************  *  *  This routine executes in interrupt context. It replenishes  *  the mbufs in the descriptor and sends data which has been  *  dma'ed into host memory to upper layer.  *  *  We loop at most count times if count is> 0, or until done if  *  count< 0.  *  *  Return TRUE for more work, FALSE for all clean.  *********************************************************************/
name|bool
name|ixgbe_rxeof
parameter_list|(
name|struct
name|ix_queue
modifier|*
name|que
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|que
operator|->
name|adapter
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
init|=
name|que
operator|->
name|rxr
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|adapter
operator|->
name|ifp
decl_stmt|;
name|struct
name|lro_ctrl
modifier|*
name|lro
init|=
operator|&
name|rxr
operator|->
name|lro
decl_stmt|;
name|struct
name|lro_entry
modifier|*
name|queued
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nextp
decl_stmt|,
name|processed
init|=
literal|0
decl_stmt|;
name|u32
name|staterr
init|=
literal|0
decl_stmt|;
name|u16
name|count
init|=
name|rxr
operator|->
name|process_limit
decl_stmt|;
name|union
name|ixgbe_adv_rx_desc
modifier|*
name|cur
decl_stmt|;
name|struct
name|ixgbe_rx_buf
modifier|*
name|rbuf
decl_stmt|,
modifier|*
name|nbuf
decl_stmt|;
name|u16
name|pkt_info
decl_stmt|;
name|IXGBE_RX_LOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
comment|/* Same as the txeof routine: wakeup clients on intr. */
if|if
condition|(
name|netmap_rx_irq
argument_list|(
name|ifp
argument_list|,
name|rxr
operator|->
name|me
argument_list|,
operator|&
name|processed
argument_list|)
condition|)
block|{
name|IXGBE_RX_UNLOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* DEV_NETMAP */
for|for
control|(
name|i
operator|=
name|rxr
operator|->
name|next_to_check
init|;
name|count
operator|!=
literal|0
condition|;
control|)
block|{
name|struct
name|mbuf
modifier|*
name|sendmp
decl_stmt|,
modifier|*
name|mp
decl_stmt|;
name|u32
name|rsc
decl_stmt|,
name|ptype
decl_stmt|;
name|u16
name|len
decl_stmt|;
name|u16
name|vtag
init|=
literal|0
decl_stmt|;
name|bool
name|eop
decl_stmt|;
comment|/* Sync the ring. */
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|rxdma
operator|.
name|dma_tag
argument_list|,
name|rxr
operator|->
name|rxdma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|cur
operator|=
operator|&
name|rxr
operator|->
name|rx_base
index|[
name|i
index|]
expr_stmt|;
name|staterr
operator|=
name|le32toh
argument_list|(
name|cur
operator|->
name|wb
operator|.
name|upper
operator|.
name|status_error
argument_list|)
expr_stmt|;
name|pkt_info
operator|=
name|le16toh
argument_list|(
name|cur
operator|->
name|wb
operator|.
name|lower
operator|.
name|lo_dword
operator|.
name|hs_rss
operator|.
name|pkt_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|staterr
operator|&
name|IXGBE_RXD_STAT_DD
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
break|break;
name|count
operator|--
expr_stmt|;
name|sendmp
operator|=
name|NULL
expr_stmt|;
name|nbuf
operator|=
name|NULL
expr_stmt|;
name|rsc
operator|=
literal|0
expr_stmt|;
name|cur
operator|->
name|wb
operator|.
name|upper
operator|.
name|status_error
operator|=
literal|0
expr_stmt|;
name|rbuf
operator|=
operator|&
name|rxr
operator|->
name|rx_buffers
index|[
name|i
index|]
expr_stmt|;
name|mp
operator|=
name|rbuf
operator|->
name|buf
expr_stmt|;
name|len
operator|=
name|le16toh
argument_list|(
name|cur
operator|->
name|wb
operator|.
name|upper
operator|.
name|length
argument_list|)
expr_stmt|;
name|ptype
operator|=
name|le32toh
argument_list|(
name|cur
operator|->
name|wb
operator|.
name|lower
operator|.
name|lo_dword
operator|.
name|data
argument_list|)
operator|&
name|IXGBE_RXDADV_PKTTYPE_MASK
expr_stmt|;
name|eop
operator|=
operator|(
operator|(
name|staterr
operator|&
name|IXGBE_RXD_STAT_EOP
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
comment|/* Make sure bad packets are discarded */
if|if
condition|(
name|eop
operator|&&
operator|(
name|staterr
operator|&
name|IXGBE_RXDADV_ERR_FRAME_ERR_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
literal|0
comment|// VF-only
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1100036
block|if_inc_counter(ifp, IFCOUNTER_IERRORS, 1);
endif|#
directive|endif
endif|#
directive|endif
name|rxr
operator|->
name|rx_discarded
operator|++
expr_stmt|;
name|ixgbe_rx_discard
argument_list|(
name|rxr
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|next_desc
goto|;
block|}
comment|/* 		** On 82599 which supports a hardware 		** LRO (called HW RSC), packets need 		** not be fragmented across sequential 		** descriptors, rather the next descriptor 		** is indicated in bits of the descriptor. 		** This also means that we might proceses 		** more than one packet at a time, something 		** that has never been true before, it 		** required eliminating global chain pointers 		** in favor of what we are doing here.  -jfv 		*/
if|if
condition|(
operator|!
name|eop
condition|)
block|{
comment|/* 			** Figure out the next descriptor 			** of this frame. 			*/
if|if
condition|(
name|rxr
operator|->
name|hw_rsc
operator|==
name|TRUE
condition|)
block|{
name|rsc
operator|=
name|ixgbe_rsc_count
argument_list|(
name|cur
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|rsc_num
operator|+=
operator|(
name|rsc
operator|-
literal|1
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|rsc
condition|)
block|{
comment|/* Get hardware index */
name|nextp
operator|=
operator|(
operator|(
name|staterr
operator|&
name|IXGBE_RXDADV_NEXTP_MASK
operator|)
operator|>>
name|IXGBE_RXDADV_NEXTP_SHIFT
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Just sequential */
name|nextp
operator|=
name|i
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|nextp
operator|==
name|adapter
operator|->
name|num_rx_desc
condition|)
name|nextp
operator|=
literal|0
expr_stmt|;
block|}
name|nbuf
operator|=
operator|&
name|rxr
operator|->
name|rx_buffers
index|[
name|nextp
index|]
expr_stmt|;
name|prefetch
argument_list|(
name|nbuf
argument_list|)
expr_stmt|;
block|}
comment|/* 		** Rather than using the fmp/lmp global pointers 		** we now keep the head of a packet chain in the 		** buffer struct and pass this along from one 		** descriptor to the next, until we get EOP. 		*/
name|mp
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
comment|/* 		** See if there is a stored head 		** that determines what we are 		*/
name|sendmp
operator|=
name|rbuf
operator|->
name|fmp
expr_stmt|;
if|if
condition|(
name|sendmp
operator|!=
name|NULL
condition|)
block|{
comment|/* secondary frag */
name|rbuf
operator|->
name|buf
operator|=
name|rbuf
operator|->
name|fmp
operator|=
name|NULL
expr_stmt|;
name|mp
operator|->
name|m_flags
operator|&=
operator|~
name|M_PKTHDR
expr_stmt|;
name|sendmp
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|mp
operator|->
name|m_len
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Optimize.  This might be a small packet, 			 * maybe just a TCP ACK.  Do a fast copy that 			 * is cache aligned into a new mbuf, and 			 * leave the old mbuf+cluster for re-use. 			 */
if|if
condition|(
name|eop
operator|&&
name|len
operator|<=
name|IXGBE_RX_COPY_LEN
condition|)
block|{
name|sendmp
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendmp
operator|!=
name|NULL
condition|)
block|{
name|sendmp
operator|->
name|m_data
operator|+=
name|IXGBE_RX_COPY_ALIGN
expr_stmt|;
name|ixgbe_bcopy
argument_list|(
name|mp
operator|->
name|m_data
argument_list|,
name|sendmp
operator|->
name|m_data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sendmp
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|rxr
operator|->
name|rx_copies
operator|++
expr_stmt|;
name|rbuf
operator|->
name|flags
operator||=
name|IXGBE_RX_COPY
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sendmp
operator|==
name|NULL
condition|)
block|{
name|rbuf
operator|->
name|buf
operator|=
name|rbuf
operator|->
name|fmp
operator|=
name|NULL
expr_stmt|;
name|sendmp
operator|=
name|mp
expr_stmt|;
block|}
comment|/* first desc of a non-ps chain */
name|sendmp
operator|->
name|m_flags
operator||=
name|M_PKTHDR
expr_stmt|;
name|sendmp
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|mp
operator|->
name|m_len
expr_stmt|;
block|}
operator|++
name|processed
expr_stmt|;
comment|/* Pass the head pointer on */
if|if
condition|(
name|eop
operator|==
literal|0
condition|)
block|{
name|nbuf
operator|->
name|fmp
operator|=
name|sendmp
expr_stmt|;
name|sendmp
operator|=
name|NULL
expr_stmt|;
name|mp
operator|->
name|m_next
operator|=
name|nbuf
operator|->
name|buf
expr_stmt|;
block|}
else|else
block|{
comment|/* Sending this frame */
name|sendmp
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|rxr
operator|->
name|rx_packets
operator|++
expr_stmt|;
comment|/* capture data for AIM */
name|rxr
operator|->
name|bytes
operator|+=
name|sendmp
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|rxr
operator|->
name|rx_bytes
operator|+=
name|sendmp
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* Process vlan info */
if|if
condition|(
operator|(
name|rxr
operator|->
name|vtag_strip
operator|)
operator|&&
operator|(
name|staterr
operator|&
name|IXGBE_RXD_STAT_VP
operator|)
condition|)
name|vtag
operator|=
name|le16toh
argument_list|(
name|cur
operator|->
name|wb
operator|.
name|upper
operator|.
name|vlan
argument_list|)
expr_stmt|;
if|if
condition|(
name|vtag
condition|)
block|{
name|sendmp
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|=
name|vtag
expr_stmt|;
name|sendmp
operator|->
name|m_flags
operator||=
name|M_VLANTAG
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
operator|)
operator|!=
literal|0
condition|)
name|ixgbe_rx_checksum
argument_list|(
name|staterr
argument_list|,
name|sendmp
argument_list|,
name|ptype
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
ifdef|#
directive|ifdef
name|RSS
name|sendmp
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
name|le32toh
argument_list|(
name|cur
operator|->
name|wb
operator|.
name|lower
operator|.
name|hi_dword
operator|.
name|rss
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pkt_info
operator|&
name|IXGBE_RXDADV_RSSTYPE_MASK
condition|)
block|{
case|case
name|IXGBE_RXDADV_RSSTYPE_IPV4_TCP
case|:
name|M_HASHTYPE_SET
argument_list|(
name|sendmp
argument_list|,
name|M_HASHTYPE_RSS_TCP_IPV4
argument_list|)
expr_stmt|;
break|break;
case|case
name|IXGBE_RXDADV_RSSTYPE_IPV4
case|:
name|M_HASHTYPE_SET
argument_list|(
name|sendmp
argument_list|,
name|M_HASHTYPE_RSS_IPV4
argument_list|)
expr_stmt|;
break|break;
case|case
name|IXGBE_RXDADV_RSSTYPE_IPV6_TCP
case|:
name|M_HASHTYPE_SET
argument_list|(
name|sendmp
argument_list|,
name|M_HASHTYPE_RSS_TCP_IPV6
argument_list|)
expr_stmt|;
break|break;
case|case
name|IXGBE_RXDADV_RSSTYPE_IPV6_EX
case|:
name|M_HASHTYPE_SET
argument_list|(
name|sendmp
argument_list|,
name|M_HASHTYPE_RSS_IPV6_EX
argument_list|)
expr_stmt|;
break|break;
case|case
name|IXGBE_RXDADV_RSSTYPE_IPV6
case|:
name|M_HASHTYPE_SET
argument_list|(
name|sendmp
argument_list|,
name|M_HASHTYPE_RSS_IPV6
argument_list|)
expr_stmt|;
break|break;
case|case
name|IXGBE_RXDADV_RSSTYPE_IPV6_TCP_EX
case|:
name|M_HASHTYPE_SET
argument_list|(
name|sendmp
argument_list|,
name|M_HASHTYPE_RSS_TCP_IPV6_EX
argument_list|)
expr_stmt|;
break|break;
case|case
name|IXGBE_RXDADV_RSSTYPE_IPV4_UDP
case|:
name|M_HASHTYPE_SET
argument_list|(
name|sendmp
argument_list|,
name|M_HASHTYPE_RSS_UDP_IPV4
argument_list|)
expr_stmt|;
break|break;
case|case
name|IXGBE_RXDADV_RSSTYPE_IPV6_UDP
case|:
name|M_HASHTYPE_SET
argument_list|(
name|sendmp
argument_list|,
name|M_HASHTYPE_RSS_UDP_IPV6
argument_list|)
expr_stmt|;
break|break;
case|case
name|IXGBE_RXDADV_RSSTYPE_IPV6_UDP_EX
case|:
name|M_HASHTYPE_SET
argument_list|(
name|sendmp
argument_list|,
name|M_HASHTYPE_RSS_UDP_IPV6_EX
argument_list|)
expr_stmt|;
break|break;
default|default:
name|M_HASHTYPE_SET
argument_list|(
name|sendmp
argument_list|,
name|M_HASHTYPE_OPAQUE
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* RSS */
name|sendmp
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
name|que
operator|->
name|msix
expr_stmt|;
name|M_HASHTYPE_SET
argument_list|(
name|sendmp
argument_list|,
name|M_HASHTYPE_OPAQUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RSS */
endif|#
directive|endif
comment|/* FreeBSD_version */
block|}
name|next_desc
label|:
name|bus_dmamap_sync
argument_list|(
name|rxr
operator|->
name|rxdma
operator|.
name|dma_tag
argument_list|,
name|rxr
operator|->
name|rxdma
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Advance our pointers to the next descriptor. */
if|if
condition|(
operator|++
name|i
operator|==
name|rxr
operator|->
name|num_desc
condition|)
name|i
operator|=
literal|0
expr_stmt|;
comment|/* Now send to the stack or do LRO */
if|if
condition|(
name|sendmp
operator|!=
name|NULL
condition|)
block|{
name|rxr
operator|->
name|next_to_check
operator|=
name|i
expr_stmt|;
name|ixgbe_rx_input
argument_list|(
name|rxr
argument_list|,
name|ifp
argument_list|,
name|sendmp
argument_list|,
name|ptype
argument_list|)
expr_stmt|;
name|i
operator|=
name|rxr
operator|->
name|next_to_check
expr_stmt|;
block|}
comment|/* Every 8 descriptors we go to refresh mbufs */
if|if
condition|(
name|processed
operator|==
literal|8
condition|)
block|{
name|ixgbe_refresh_mbufs
argument_list|(
name|rxr
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|processed
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Refresh any remaining buf structs */
if|if
condition|(
name|ixgbe_rx_unrefreshed
argument_list|(
name|rxr
argument_list|)
condition|)
name|ixgbe_refresh_mbufs
argument_list|(
name|rxr
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rxr
operator|->
name|next_to_check
operator|=
name|i
expr_stmt|;
comment|/* 	 * Flush any outstanding LRO work 	 */
while|while
condition|(
operator|(
name|queued
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|lro
operator|->
name|lro_active
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|lro
operator|->
name|lro_active
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|tcp_lro_flush
argument_list|(
name|lro
argument_list|,
name|queued
argument_list|)
expr_stmt|;
block|}
name|IXGBE_RX_UNLOCK
argument_list|(
name|rxr
argument_list|)
expr_stmt|;
comment|/* 	** Still have cleaning to do? 	*/
if|if
condition|(
operator|(
name|staterr
operator|&
name|IXGBE_RXD_STAT_DD
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
else|else
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/*********************************************************************  *  *  Verify that the hardware indicated that the checksum is valid.  *  Inform the stack about the status of checksum so that stack  *  doesn't spend time verifying the checksum.  *  *********************************************************************/
specifier|static
name|void
name|ixgbe_rx_checksum
parameter_list|(
name|u32
name|staterr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mp
parameter_list|,
name|u32
name|ptype
parameter_list|)
block|{
name|u16
name|status
init|=
operator|(
name|u16
operator|)
name|staterr
decl_stmt|;
name|u8
name|errors
init|=
call|(
name|u8
call|)
argument_list|(
name|staterr
operator|>>
literal|24
argument_list|)
decl_stmt|;
name|bool
name|sctp
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|(
name|ptype
operator|&
name|IXGBE_RXDADV_PKTTYPE_ETQF
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ptype
operator|&
name|IXGBE_RXDADV_PKTTYPE_SCTP
operator|)
operator|!=
literal|0
condition|)
name|sctp
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|IXGBE_RXD_STAT_IPCS
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|errors
operator|&
name|IXGBE_RXD_ERR_IPE
operator|)
condition|)
block|{
comment|/* IP Checksum Good */
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
name|CSUM_IP_CHECKED
expr_stmt|;
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_IP_VALID
expr_stmt|;
block|}
else|else
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|IXGBE_RXD_STAT_L4CS
condition|)
block|{
name|u64
name|type
init|=
operator|(
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
if|if
condition|(
name|sctp
condition|)
name|type
operator|=
name|CSUM_SCTP_VALID
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|errors
operator|&
name|IXGBE_RXD_ERR_TCPE
operator|)
condition|)
block|{
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|type
expr_stmt|;
if|if
condition|(
operator|!
name|sctp
condition|)
name|mp
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
name|htons
argument_list|(
literal|0xffff
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
comment|/********************************************************************  * Manage DMA'able memory.  *******************************************************************/
specifier|static
name|void
name|ixgbe_dmamap_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
if|if
condition|(
name|error
condition|)
return|return;
operator|*
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
return|return;
block|}
name|int
name|ixgbe_dma_malloc
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|bus_size_t
name|size
parameter_list|,
name|struct
name|ixgbe_dma_alloc
modifier|*
name|dma
parameter_list|,
name|int
name|mapflags
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|int
name|r
decl_stmt|;
name|r
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|adapter
operator|->
name|dev
argument_list|)
argument_list|,
comment|/* parent */
name|DBA_ALIGN
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|size
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|size
argument_list|,
comment|/* maxsegsize */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockfuncarg */
operator|&
name|dma
operator|->
name|dma_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ixgbe_dma_malloc: bus_dma_tag_create failed; "
literal|"error %u\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
goto|goto
name|fail_0
goto|;
block|}
name|r
operator|=
name|bus_dmamem_alloc
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ixgbe_dma_malloc: bus_dmamem_alloc failed; "
literal|"error %u\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
goto|goto
name|fail_1
goto|;
block|}
name|r
operator|=
name|bus_dmamap_load
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|,
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|size
argument_list|,
name|ixgbe_dmamap_cb
argument_list|,
operator|&
name|dma
operator|->
name|dma_paddr
argument_list|,
name|mapflags
operator||
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ixgbe_dma_malloc: bus_dmamap_load failed; "
literal|"error %u\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
goto|goto
name|fail_2
goto|;
block|}
name|dma
operator|->
name|dma_size
operator|=
name|size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail_2
label|:
name|bus_dmamem_free
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|fail_1
label|:
name|bus_dma_tag_destroy
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|)
expr_stmt|;
name|fail_0
label|:
name|dma
operator|->
name|dma_tag
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
name|void
name|ixgbe_dma_free
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|struct
name|ixgbe_dma_alloc
modifier|*
name|dma
parameter_list|)
block|{
name|bus_dmamap_sync
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|)
expr_stmt|;
block|}
comment|/*********************************************************************  *  *  Allocate memory for the transmit and receive rings, and then  *  the descriptors associated with each, called only once at attach.  *  **********************************************************************/
name|int
name|ixgbe_allocate_queues
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|adapter
operator|->
name|dev
decl_stmt|;
name|struct
name|ix_queue
modifier|*
name|que
decl_stmt|;
name|struct
name|tx_ring
modifier|*
name|txr
decl_stmt|;
name|struct
name|rx_ring
modifier|*
name|rxr
decl_stmt|;
name|int
name|rsize
decl_stmt|,
name|tsize
decl_stmt|,
name|error
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|int
name|txconf
init|=
literal|0
decl_stmt|,
name|rxconf
init|=
literal|0
decl_stmt|;
comment|/* First allocate the top level queue structs */
if|if
condition|(
operator|!
operator|(
name|adapter
operator|->
name|queues
operator|=
operator|(
expr|struct
name|ix_queue
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ix_queue
argument_list|)
operator|*
name|adapter
operator|->
name|num_queues
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate queue memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* First allocate the TX ring struct memory */
if|if
condition|(
operator|!
operator|(
name|adapter
operator|->
name|tx_rings
operator|=
operator|(
expr|struct
name|tx_ring
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tx_ring
argument_list|)
operator|*
name|adapter
operator|->
name|num_queues
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate TX ring memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|tx_fail
goto|;
block|}
comment|/* Next allocate the RX */
if|if
condition|(
operator|!
operator|(
name|adapter
operator|->
name|rx_rings
operator|=
operator|(
expr|struct
name|rx_ring
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|rx_ring
argument_list|)
operator|*
name|adapter
operator|->
name|num_queues
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate RX ring memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|rx_fail
goto|;
block|}
comment|/* For the ring itself */
name|tsize
operator|=
name|roundup2
argument_list|(
name|adapter
operator|->
name|num_tx_desc
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|ixgbe_adv_tx_desc
argument_list|)
argument_list|,
name|DBA_ALIGN
argument_list|)
expr_stmt|;
comment|/* 	 * Now set up the TX queues, txconf is needed to handle the 	 * possibility that things fail midcourse and we need to 	 * undo memory gracefully 	 */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|txconf
operator|++
control|)
block|{
comment|/* Set up some basics */
name|txr
operator|=
operator|&
name|adapter
operator|->
name|tx_rings
index|[
name|i
index|]
expr_stmt|;
name|txr
operator|->
name|adapter
operator|=
name|adapter
expr_stmt|;
name|txr
operator|->
name|me
operator|=
name|i
expr_stmt|;
name|txr
operator|->
name|num_desc
operator|=
name|adapter
operator|->
name|num_tx_desc
expr_stmt|;
comment|/* Initialize the TX side lock */
name|snprintf
argument_list|(
name|txr
operator|->
name|mtx_name
argument_list|,
sizeof|sizeof
argument_list|(
name|txr
operator|->
name|mtx_name
argument_list|)
argument_list|,
literal|"%s:tx(%d)"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|txr
operator|->
name|me
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|txr
operator|->
name|tx_mtx
argument_list|,
name|txr
operator|->
name|mtx_name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
if|if
condition|(
name|ixgbe_dma_malloc
argument_list|(
name|adapter
argument_list|,
name|tsize
argument_list|,
operator|&
name|txr
operator|->
name|txdma
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate TX Descriptor memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_tx_desc
goto|;
block|}
name|txr
operator|->
name|tx_base
operator|=
operator|(
expr|union
name|ixgbe_adv_tx_desc
operator|*
operator|)
name|txr
operator|->
name|txdma
operator|.
name|dma_vaddr
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|txr
operator|->
name|tx_base
argument_list|,
name|tsize
argument_list|)
expr_stmt|;
comment|/* Now allocate transmit buffers for the ring */
if|if
condition|(
name|ixgbe_allocate_transmit_buffers
argument_list|(
name|txr
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Critical Failure setting up transmit buffers\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_tx_desc
goto|;
block|}
ifndef|#
directive|ifndef
name|IXGBE_LEGACY_TX
comment|/* Allocate a buf ring */
name|txr
operator|->
name|br
operator|=
name|buf_ring_alloc
argument_list|(
name|IXGBE_BR_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|,
operator|&
name|txr
operator|->
name|tx_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|txr
operator|->
name|br
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Critical Failure setting up buf ring\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_tx_desc
goto|;
block|}
endif|#
directive|endif
block|}
comment|/* 	 * Next the RX queues... 	 */
name|rsize
operator|=
name|roundup2
argument_list|(
name|adapter
operator|->
name|num_rx_desc
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|ixgbe_adv_rx_desc
argument_list|)
argument_list|,
name|DBA_ALIGN
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
operator|,
name|rxconf
operator|++
control|)
block|{
name|rxr
operator|=
operator|&
name|adapter
operator|->
name|rx_rings
index|[
name|i
index|]
expr_stmt|;
comment|/* Set up some basics */
name|rxr
operator|->
name|adapter
operator|=
name|adapter
expr_stmt|;
name|rxr
operator|->
name|me
operator|=
name|i
expr_stmt|;
name|rxr
operator|->
name|num_desc
operator|=
name|adapter
operator|->
name|num_rx_desc
expr_stmt|;
comment|/* Initialize the RX side lock */
name|snprintf
argument_list|(
name|rxr
operator|->
name|mtx_name
argument_list|,
sizeof|sizeof
argument_list|(
name|rxr
operator|->
name|mtx_name
argument_list|)
argument_list|,
literal|"%s:rx(%d)"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|rxr
operator|->
name|me
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|rxr
operator|->
name|rx_mtx
argument_list|,
name|rxr
operator|->
name|mtx_name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
if|if
condition|(
name|ixgbe_dma_malloc
argument_list|(
name|adapter
argument_list|,
name|rsize
argument_list|,
operator|&
name|rxr
operator|->
name|rxdma
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate RxDescriptor memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_rx_desc
goto|;
block|}
name|rxr
operator|->
name|rx_base
operator|=
operator|(
expr|union
name|ixgbe_adv_rx_desc
operator|*
operator|)
name|rxr
operator|->
name|rxdma
operator|.
name|dma_vaddr
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|rxr
operator|->
name|rx_base
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
comment|/* Allocate receive buffers for the ring*/
if|if
condition|(
name|ixgbe_allocate_receive_buffers
argument_list|(
name|rxr
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Critical Failure setting up receive buffers\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_rx_desc
goto|;
block|}
block|}
comment|/* 	** Finally set up the queue holding structs 	*/
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|adapter
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|que
operator|=
operator|&
name|adapter
operator|->
name|queues
index|[
name|i
index|]
expr_stmt|;
name|que
operator|->
name|adapter
operator|=
name|adapter
expr_stmt|;
name|que
operator|->
name|me
operator|=
name|i
expr_stmt|;
name|que
operator|->
name|txr
operator|=
operator|&
name|adapter
operator|->
name|tx_rings
index|[
name|i
index|]
expr_stmt|;
name|que
operator|->
name|rxr
operator|=
operator|&
name|adapter
operator|->
name|rx_rings
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|err_rx_desc
label|:
for|for
control|(
name|rxr
operator|=
name|adapter
operator|->
name|rx_rings
init|;
name|rxconf
operator|>
literal|0
condition|;
name|rxr
operator|++
operator|,
name|rxconf
operator|--
control|)
name|ixgbe_dma_free
argument_list|(
name|adapter
argument_list|,
operator|&
name|rxr
operator|->
name|rxdma
argument_list|)
expr_stmt|;
name|err_tx_desc
label|:
for|for
control|(
name|txr
operator|=
name|adapter
operator|->
name|tx_rings
init|;
name|txconf
operator|>
literal|0
condition|;
name|txr
operator|++
operator|,
name|txconf
operator|--
control|)
name|ixgbe_dma_free
argument_list|(
name|adapter
argument_list|,
operator|&
name|txr
operator|->
name|txdma
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|adapter
operator|->
name|rx_rings
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|rx_fail
label|:
name|free
argument_list|(
name|adapter
operator|->
name|tx_rings
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|tx_fail
label|:
name|free
argument_list|(
name|adapter
operator|->
name|queues
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|fail
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

