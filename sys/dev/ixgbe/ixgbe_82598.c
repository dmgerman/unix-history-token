begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************    Copyright (c) 2001-2017, Intel Corporation   All rights reserved.    Redistribution and use in source and binary forms, with or without   modification, are permitted provided that the following conditions are met:     1. Redistributions of source code must retain the above copyright notice,       this list of conditions and the following disclaimer.     2. Redistributions in binary form must reproduce the above copyright       notice, this list of conditions and the following disclaimer in the       documentation and/or other materials provided with the distribution.     3. Neither the name of the Intel Corporation nor the names of its       contributors may be used to endorse or promote products derived from       this software without specific prior written permission.    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   POSSIBILITY OF SUCH DAMAGE.  ******************************************************************************/
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"ixgbe_type.h"
end_include

begin_include
include|#
directive|include
file|"ixgbe_82598.h"
end_include

begin_include
include|#
directive|include
file|"ixgbe_api.h"
end_include

begin_include
include|#
directive|include
file|"ixgbe_common.h"
end_include

begin_include
include|#
directive|include
file|"ixgbe_phy.h"
end_include

begin_define
define|#
directive|define
name|IXGBE_82598_MAX_TX_QUEUES
value|32
end_define

begin_define
define|#
directive|define
name|IXGBE_82598_MAX_RX_QUEUES
value|64
end_define

begin_define
define|#
directive|define
name|IXGBE_82598_RAR_ENTRIES
value|16
end_define

begin_define
define|#
directive|define
name|IXGBE_82598_MC_TBL_SIZE
value|128
end_define

begin_define
define|#
directive|define
name|IXGBE_82598_VFT_TBL_SIZE
value|128
end_define

begin_define
define|#
directive|define
name|IXGBE_82598_RX_PB_SIZE
value|512
end_define

begin_function_decl
specifier|static
name|s32
name|ixgbe_get_link_capabilities_82598
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
modifier|*
name|speed
parameter_list|,
name|bool
modifier|*
name|autoneg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|ixgbe_media_type
name|ixgbe_get_media_type_82598
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_start_mac_link_82598
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|autoneg_wait_to_complete
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_check_mac_link_82598
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
modifier|*
name|speed
parameter_list|,
name|bool
modifier|*
name|link_up
parameter_list|,
name|bool
name|link_up_wait_to_complete
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_setup_mac_link_82598
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
name|speed
parameter_list|,
name|bool
name|autoneg_wait_to_complete
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_setup_copper_link_82598
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
name|speed
parameter_list|,
name|bool
name|autoneg_wait_to_complete
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_reset_hw_82598
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_clear_vmdq_82598
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|rar
parameter_list|,
name|u32
name|vmdq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_clear_vfta_82598
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixgbe_set_rxpba_82598
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|int
name|num_pb
parameter_list|,
name|u32
name|headroom
parameter_list|,
name|int
name|strategy
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|s32
name|ixgbe_read_i2c_sff8472_82598
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|byte_offset
parameter_list|,
name|u8
modifier|*
name|sff8472_data
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  *  ixgbe_set_pcie_completion_timeout - set pci-e completion timeout  *  @hw: pointer to the HW structure  *  *  The defaults for 82598 should be in the range of 50us to 50ms,  *  however the hardware default for these parts is 500us to 1ms which is less  *  than the 10ms recommended by the pci-e spec.  To address this we need to  *  increase the value to either 10ms to 250ms for capability version 1 config,  *  or 16ms to 55ms for version 2.  **/
end_comment

begin_function
name|void
name|ixgbe_set_pcie_completion_timeout
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|gcr
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GCR
argument_list|)
decl_stmt|;
name|u16
name|pcie_devctl2
decl_stmt|;
comment|/* only take action if timeout value is defaulted to 0 */
if|if
condition|(
name|gcr
operator|&
name|IXGBE_GCR_CMPL_TMOUT_MASK
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * if capababilities version is type 1 we can write the 	 * timeout of 10ms to 250ms through the GCR register 	 */
if|if
condition|(
operator|!
operator|(
name|gcr
operator|&
name|IXGBE_GCR_CAP_VER2
operator|)
condition|)
block|{
name|gcr
operator||=
name|IXGBE_GCR_CMPL_TMOUT_10ms
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * for version 2 capabilities we need to write the config space 	 * directly in order to set the completion timeout value for 	 * 16ms to 55ms 	 */
name|pcie_devctl2
operator|=
name|IXGBE_READ_PCIE_WORD
argument_list|(
name|hw
argument_list|,
name|IXGBE_PCI_DEVICE_CONTROL2
argument_list|)
expr_stmt|;
name|pcie_devctl2
operator||=
name|IXGBE_PCI_DEVICE_CONTROL2_16ms
expr_stmt|;
name|IXGBE_WRITE_PCIE_WORD
argument_list|(
name|hw
argument_list|,
name|IXGBE_PCI_DEVICE_CONTROL2
argument_list|,
name|pcie_devctl2
argument_list|)
expr_stmt|;
name|out
label|:
comment|/* disable completion timeout resend */
name|gcr
operator|&=
operator|~
name|IXGBE_GCR_CMPL_TMOUT_RESEND
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GCR
argument_list|,
name|gcr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_init_ops_82598 - Inits func ptrs and MAC type  *  @hw: pointer to hardware structure  *  *  Initialize the function pointers and assign the MAC type for 82598.  *  Does not touch the hardware.  **/
end_comment

begin_function
name|s32
name|ixgbe_init_ops_82598
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|struct
name|ixgbe_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_init_ops_82598"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|ixgbe_init_phy_ops_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|ixgbe_init_ops_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* PHY */
name|phy
operator|->
name|ops
operator|.
name|init
operator|=
name|ixgbe_init_phy_ops_82598
expr_stmt|;
comment|/* MAC */
name|mac
operator|->
name|ops
operator|.
name|start_hw
operator|=
name|ixgbe_start_hw_82598
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|enable_relaxed_ordering
operator|=
name|ixgbe_enable_relaxed_ordering_82598
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|reset_hw
operator|=
name|ixgbe_reset_hw_82598
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_media_type
operator|=
name|ixgbe_get_media_type_82598
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_supported_physical_layer
operator|=
name|ixgbe_get_supported_physical_layer_82598
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|read_analog_reg8
operator|=
name|ixgbe_read_analog_reg8_82598
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|write_analog_reg8
operator|=
name|ixgbe_write_analog_reg8_82598
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|set_lan_id
operator|=
name|ixgbe_set_lan_id_multi_port_pcie_82598
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|enable_rx_dma
operator|=
name|ixgbe_enable_rx_dma_82598
expr_stmt|;
comment|/* RAR, Multicast, VLAN */
name|mac
operator|->
name|ops
operator|.
name|set_vmdq
operator|=
name|ixgbe_set_vmdq_82598
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|clear_vmdq
operator|=
name|ixgbe_clear_vmdq_82598
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|set_vfta
operator|=
name|ixgbe_set_vfta_82598
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|set_vlvf
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|clear_vfta
operator|=
name|ixgbe_clear_vfta_82598
expr_stmt|;
comment|/* Flow Control */
name|mac
operator|->
name|ops
operator|.
name|fc_enable
operator|=
name|ixgbe_fc_enable_82598
expr_stmt|;
name|mac
operator|->
name|mcft_size
operator|=
name|IXGBE_82598_MC_TBL_SIZE
expr_stmt|;
name|mac
operator|->
name|vft_size
operator|=
name|IXGBE_82598_VFT_TBL_SIZE
expr_stmt|;
name|mac
operator|->
name|num_rar_entries
operator|=
name|IXGBE_82598_RAR_ENTRIES
expr_stmt|;
name|mac
operator|->
name|rx_pb_size
operator|=
name|IXGBE_82598_RX_PB_SIZE
expr_stmt|;
name|mac
operator|->
name|max_rx_queues
operator|=
name|IXGBE_82598_MAX_RX_QUEUES
expr_stmt|;
name|mac
operator|->
name|max_tx_queues
operator|=
name|IXGBE_82598_MAX_TX_QUEUES
expr_stmt|;
name|mac
operator|->
name|max_msix_vectors
operator|=
name|ixgbe_get_pcie_msix_count_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* SFP+ Module */
name|phy
operator|->
name|ops
operator|.
name|read_i2c_eeprom
operator|=
name|ixgbe_read_i2c_eeprom_82598
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|read_i2c_sff8472
operator|=
name|ixgbe_read_i2c_sff8472_82598
expr_stmt|;
comment|/* Link */
name|mac
operator|->
name|ops
operator|.
name|check_link
operator|=
name|ixgbe_check_mac_link_82598
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|setup_link
operator|=
name|ixgbe_setup_mac_link_82598
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|flap_tx_laser
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_link_capabilities
operator|=
name|ixgbe_get_link_capabilities_82598
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|setup_rxpba
operator|=
name|ixgbe_set_rxpba_82598
expr_stmt|;
comment|/* Manageability interface */
name|mac
operator|->
name|ops
operator|.
name|set_fw_drv_ver
operator|=
name|NULL
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_rtrup2tc
operator|=
name|NULL
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_init_phy_ops_82598 - PHY/SFP specific init  *  @hw: pointer to hardware structure  *  *  Initialize any function pointers that were not able to be  *  set during init_shared_code because the PHY/SFP type was  *  not known.  Perform the SFP init if necessary.  *  **/
end_comment

begin_function
name|s32
name|ixgbe_init_phy_ops_82598
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_mac_info
modifier|*
name|mac
init|=
operator|&
name|hw
operator|->
name|mac
decl_stmt|;
name|struct
name|ixgbe_phy_info
modifier|*
name|phy
init|=
operator|&
name|hw
operator|->
name|phy
decl_stmt|;
name|s32
name|ret_val
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u16
name|list_offset
decl_stmt|,
name|data_offset
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_init_phy_ops_82598"
argument_list|)
expr_stmt|;
comment|/* Identify the PHY */
name|phy
operator|->
name|ops
operator|.
name|identify
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Overwrite the link function pointers if copper PHY */
if|if
condition|(
name|mac
operator|->
name|ops
operator|.
name|get_media_type
argument_list|(
name|hw
argument_list|)
operator|==
name|ixgbe_media_type_copper
condition|)
block|{
name|mac
operator|->
name|ops
operator|.
name|setup_link
operator|=
name|ixgbe_setup_copper_link_82598
expr_stmt|;
name|mac
operator|->
name|ops
operator|.
name|get_link_capabilities
operator|=
name|ixgbe_get_copper_link_capabilities_generic
expr_stmt|;
block|}
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_phy_tn
case|:
name|phy
operator|->
name|ops
operator|.
name|setup_link
operator|=
name|ixgbe_setup_phy_link_tnx
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|check_link
operator|=
name|ixgbe_check_phy_link_tnx
expr_stmt|;
name|phy
operator|->
name|ops
operator|.
name|get_firmware_version
operator|=
name|ixgbe_get_phy_firmware_version_tnx
expr_stmt|;
break|break;
case|case
name|ixgbe_phy_nl
case|:
name|phy
operator|->
name|ops
operator|.
name|reset
operator|=
name|ixgbe_reset_phy_nl
expr_stmt|;
comment|/* Call SFP+ identify routine to get the SFP+ module type */
name|ret_val
operator|=
name|phy
operator|->
name|ops
operator|.
name|identify_sfp
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|out
goto|;
elseif|else
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|sfp_type
operator|==
name|ixgbe_sfp_type_unknown
condition|)
block|{
name|ret_val
operator|=
name|IXGBE_ERR_SFP_NOT_SUPPORTED
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Check to see if SFP+ module is supported */
name|ret_val
operator|=
name|ixgbe_get_sfp_init_sequence_offsets
argument_list|(
name|hw
argument_list|,
operator|&
name|list_offset
argument_list|,
operator|&
name|data_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|!=
name|IXGBE_SUCCESS
condition|)
block|{
name|ret_val
operator|=
name|IXGBE_ERR_SFP_NOT_SUPPORTED
expr_stmt|;
goto|goto
name|out
goto|;
block|}
break|break;
default|default:
break|break;
block|}
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_start_hw_82598 - Prepare hardware for Tx/Rx  *  @hw: pointer to hardware structure  *  *  Starts the hardware using the generic start_hw function.  *  Disables relaxed ordering Then set pcie completion timeout  *  **/
end_comment

begin_function
name|s32
name|ixgbe_start_hw_82598
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|regval
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|s32
name|ret_val
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_start_hw_82598"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|ixgbe_start_hw_generic
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
return|return
name|ret_val
return|;
comment|/* Disable relaxed ordering */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|(
name|i
operator|<
name|hw
operator|->
name|mac
operator|.
name|max_tx_queues
operator|)
operator|&&
operator|(
name|i
operator|<
name|IXGBE_DCA_MAX_QUEUES_82598
operator|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|regval
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DCA_TXCTRL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|regval
operator|&=
operator|~
name|IXGBE_DCA_TXCTRL_DESC_WRO_EN
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DCA_TXCTRL
argument_list|(
name|i
argument_list|)
argument_list|,
name|regval
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|(
name|i
operator|<
name|hw
operator|->
name|mac
operator|.
name|max_rx_queues
operator|)
operator|&&
operator|(
name|i
operator|<
name|IXGBE_DCA_MAX_QUEUES_82598
operator|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|regval
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DCA_RXCTRL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|regval
operator|&=
operator|~
operator|(
name|IXGBE_DCA_RXCTRL_DATA_WRO_EN
operator||
name|IXGBE_DCA_RXCTRL_HEAD_WRO_EN
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DCA_RXCTRL
argument_list|(
name|i
argument_list|)
argument_list|,
name|regval
argument_list|)
expr_stmt|;
block|}
comment|/* set the completion timeout for interface */
name|ixgbe_set_pcie_completion_timeout
argument_list|(
name|hw
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_link_capabilities_82598 - Determines link capabilities  *  @hw: pointer to hardware structure  *  @speed: pointer to link speed  *  @autoneg: boolean auto-negotiation value  *  *  Determines the link capabilities by reading the AUTOC register.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_get_link_capabilities_82598
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
modifier|*
name|speed
parameter_list|,
name|bool
modifier|*
name|autoneg
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u32
name|autoc
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_link_capabilities_82598"
argument_list|)
expr_stmt|;
comment|/* 	 * Determine link capabilities based on the stored value of AUTOC, 	 * which represents EEPROM defaults.  If AUTOC value has not been 	 * stored, use the current register value. 	 */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|orig_link_settings_stored
condition|)
name|autoc
operator|=
name|hw
operator|->
name|mac
operator|.
name|orig_autoc
expr_stmt|;
else|else
name|autoc
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|autoc
operator|&
name|IXGBE_AUTOC_LMS_MASK
condition|)
block|{
case|case
name|IXGBE_AUTOC_LMS_1G_LINK_NO_AN
case|:
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
operator|*
name|autoneg
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|IXGBE_AUTOC_LMS_10G_LINK_NO_AN
case|:
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
operator|*
name|autoneg
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|IXGBE_AUTOC_LMS_1G_AN
case|:
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
operator|*
name|autoneg
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|IXGBE_AUTOC_LMS_KX4_AN
case|:
case|case
name|IXGBE_AUTOC_LMS_KX4_AN_1G_AN
case|:
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_UNKNOWN
expr_stmt|;
if|if
condition|(
name|autoc
operator|&
name|IXGBE_AUTOC_KX4_SUPP
condition|)
operator|*
name|speed
operator||=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
if|if
condition|(
name|autoc
operator|&
name|IXGBE_AUTOC_KX_SUPP
condition|)
operator|*
name|speed
operator||=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
operator|*
name|autoneg
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|status
operator|=
name|IXGBE_ERR_LINK_SETUP
expr_stmt|;
break|break;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_media_type_82598 - Determines media type  *  @hw: pointer to hardware structure  *  *  Returns the media type (fiber, copper, backplane)  **/
end_comment

begin_function
specifier|static
name|enum
name|ixgbe_media_type
name|ixgbe_get_media_type_82598
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|enum
name|ixgbe_media_type
name|media_type
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_media_type_82598"
argument_list|)
expr_stmt|;
comment|/* Detect if there is a copper PHY attached. */
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_phy_cu_unknown
case|:
case|case
name|ixgbe_phy_tn
case|:
name|media_type
operator|=
name|ixgbe_media_type_copper
expr_stmt|;
goto|goto
name|out
goto|;
default|default:
break|break;
block|}
comment|/* Media type for I82598 is based on device ID */
switch|switch
condition|(
name|hw
operator|->
name|device_id
condition|)
block|{
case|case
name|IXGBE_DEV_ID_82598
case|:
case|case
name|IXGBE_DEV_ID_82598_BX
case|:
comment|/* Default device ID is mezzanine card KX/KX4 */
name|media_type
operator|=
name|ixgbe_media_type_backplane
expr_stmt|;
break|break;
case|case
name|IXGBE_DEV_ID_82598AF_DUAL_PORT
case|:
case|case
name|IXGBE_DEV_ID_82598AF_SINGLE_PORT
case|:
case|case
name|IXGBE_DEV_ID_82598_DA_DUAL_PORT
case|:
case|case
name|IXGBE_DEV_ID_82598_SR_DUAL_PORT_EM
case|:
case|case
name|IXGBE_DEV_ID_82598EB_XF_LR
case|:
case|case
name|IXGBE_DEV_ID_82598EB_SFP_LOM
case|:
name|media_type
operator|=
name|ixgbe_media_type_fiber
expr_stmt|;
break|break;
case|case
name|IXGBE_DEV_ID_82598EB_CX4
case|:
case|case
name|IXGBE_DEV_ID_82598_CX4_DUAL_PORT
case|:
name|media_type
operator|=
name|ixgbe_media_type_cx4
expr_stmt|;
break|break;
case|case
name|IXGBE_DEV_ID_82598AT
case|:
case|case
name|IXGBE_DEV_ID_82598AT2
case|:
name|media_type
operator|=
name|ixgbe_media_type_copper
expr_stmt|;
break|break;
default|default:
name|media_type
operator|=
name|ixgbe_media_type_unknown
expr_stmt|;
break|break;
block|}
name|out
label|:
return|return
name|media_type
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_fc_enable_82598 - Enable flow control  *  @hw: pointer to hardware structure  *  *  Enable flow control according to the current settings.  **/
end_comment

begin_function
name|s32
name|ixgbe_fc_enable_82598
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|ret_val
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u32
name|fctrl_reg
decl_stmt|;
name|u32
name|rmcs_reg
decl_stmt|;
name|u32
name|reg
decl_stmt|;
name|u32
name|fcrtl
decl_stmt|,
name|fcrth
decl_stmt|;
name|u32
name|link_speed
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bool
name|link_up
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_fc_enable_82598"
argument_list|)
expr_stmt|;
comment|/* Validate the water mark configuration */
if|if
condition|(
operator|!
name|hw
operator|->
name|fc
operator|.
name|pause_time
condition|)
block|{
name|ret_val
operator|=
name|IXGBE_ERR_INVALID_LINK_SETTINGS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Low water mark of zero causes XOFF floods */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_DCB_MAX_TRAFFIC_CLASS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|&
name|ixgbe_fc_tx_pause
operator|)
operator|&&
name|hw
operator|->
name|fc
operator|.
name|high_water
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|hw
operator|->
name|fc
operator|.
name|low_water
index|[
name|i
index|]
operator|||
name|hw
operator|->
name|fc
operator|.
name|low_water
index|[
name|i
index|]
operator|>=
name|hw
operator|->
name|fc
operator|.
name|high_water
index|[
name|i
index|]
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Invalid water mark configuration\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|IXGBE_ERR_INVALID_LINK_SETTINGS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
block|}
comment|/* 	 * On 82598 having Rx FC on causes resets while doing 1G 	 * so if it's on turn it off once we know link_speed. For 	 * more details see 82598 Specification update. 	 */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|check_link
argument_list|(
name|hw
argument_list|,
operator|&
name|link_speed
argument_list|,
operator|&
name|link_up
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_up
operator|&&
name|link_speed
operator|==
name|IXGBE_LINK_SPEED_1GB_FULL
condition|)
block|{
switch|switch
condition|(
name|hw
operator|->
name|fc
operator|.
name|requested_mode
condition|)
block|{
case|case
name|ixgbe_fc_full
case|:
name|hw
operator|->
name|fc
operator|.
name|requested_mode
operator|=
name|ixgbe_fc_tx_pause
expr_stmt|;
break|break;
case|case
name|ixgbe_fc_rx_pause
case|:
name|hw
operator|->
name|fc
operator|.
name|requested_mode
operator|=
name|ixgbe_fc_none
expr_stmt|;
break|break;
default|default:
comment|/* no change */
break|break;
block|}
block|}
comment|/* Negotiate the fc mode to use */
name|ixgbe_fc_autoneg
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Disable any previous flow control settings */
name|fctrl_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCTRL
argument_list|)
expr_stmt|;
name|fctrl_reg
operator|&=
operator|~
operator|(
name|IXGBE_FCTRL_RFCE
operator||
name|IXGBE_FCTRL_RPFCE
operator|)
expr_stmt|;
name|rmcs_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RMCS
argument_list|)
expr_stmt|;
name|rmcs_reg
operator|&=
operator|~
operator|(
name|IXGBE_RMCS_TFCE_PRIORITY
operator||
name|IXGBE_RMCS_TFCE_802_3X
operator|)
expr_stmt|;
comment|/* 	 * The possible values of fc.current_mode are: 	 * 0: Flow control is completely disabled 	 * 1: Rx flow control is enabled (we can receive pause frames, 	 *    but not send pause frames). 	 * 2: Tx flow control is enabled (we can send pause frames but 	 *     we do not support receiving pause frames). 	 * 3: Both Rx and Tx flow control (symmetric) are enabled. 	 * other: Invalid. 	 */
switch|switch
condition|(
name|hw
operator|->
name|fc
operator|.
name|current_mode
condition|)
block|{
case|case
name|ixgbe_fc_none
case|:
comment|/* 		 * Flow control is disabled by software override or autoneg. 		 * The code below will actually disable it in the HW. 		 */
break|break;
case|case
name|ixgbe_fc_rx_pause
case|:
comment|/* 		 * Rx Flow control is enabled and Tx Flow control is 		 * disabled by software override. Since there really 		 * isn't a way to advertise that we are capable of RX 		 * Pause ONLY, we will advertise that we support both 		 * symmetric and asymmetric Rx PAUSE.  Later, we will 		 * disable the adapter's ability to send PAUSE frames. 		 */
name|fctrl_reg
operator||=
name|IXGBE_FCTRL_RFCE
expr_stmt|;
break|break;
case|case
name|ixgbe_fc_tx_pause
case|:
comment|/* 		 * Tx Flow control is enabled, and Rx Flow control is 		 * disabled by software override. 		 */
name|rmcs_reg
operator||=
name|IXGBE_RMCS_TFCE_802_3X
expr_stmt|;
break|break;
case|case
name|ixgbe_fc_full
case|:
comment|/* Flow control (both Rx and Tx) is enabled by SW override. */
name|fctrl_reg
operator||=
name|IXGBE_FCTRL_RFCE
expr_stmt|;
name|rmcs_reg
operator||=
name|IXGBE_RMCS_TFCE_802_3X
expr_stmt|;
break|break;
default|default:
name|DEBUGOUT
argument_list|(
literal|"Flow control param set incorrectly\n"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|IXGBE_ERR_CONFIG
expr_stmt|;
goto|goto
name|out
goto|;
break|break;
block|}
comment|/* Set 802.3x based flow control settings. */
name|fctrl_reg
operator||=
name|IXGBE_FCTRL_DPF
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCTRL
argument_list|,
name|fctrl_reg
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RMCS
argument_list|,
name|rmcs_reg
argument_list|)
expr_stmt|;
comment|/* Set up and enable Rx high/low water mark thresholds, enable XON. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_DCB_MAX_TRAFFIC_CLASS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|hw
operator|->
name|fc
operator|.
name|current_mode
operator|&
name|ixgbe_fc_tx_pause
operator|)
operator|&&
name|hw
operator|->
name|fc
operator|.
name|high_water
index|[
name|i
index|]
condition|)
block|{
name|fcrtl
operator|=
operator|(
name|hw
operator|->
name|fc
operator|.
name|low_water
index|[
name|i
index|]
operator|<<
literal|10
operator|)
operator||
name|IXGBE_FCRTL_XONE
expr_stmt|;
name|fcrth
operator|=
operator|(
name|hw
operator|->
name|fc
operator|.
name|high_water
index|[
name|i
index|]
operator|<<
literal|10
operator|)
operator||
name|IXGBE_FCRTH_FCEN
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCRTL
argument_list|(
name|i
argument_list|)
argument_list|,
name|fcrtl
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCRTH
argument_list|(
name|i
argument_list|)
argument_list|,
name|fcrth
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCRTL
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCRTH
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Configure pause time (2 TCs per register) */
name|reg
operator|=
name|hw
operator|->
name|fc
operator|.
name|pause_time
operator|*
literal|0x00010001
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|IXGBE_DCB_MAX_TRAFFIC_CLASS
operator|/
literal|2
operator|)
condition|;
name|i
operator|++
control|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCTTV
argument_list|(
name|i
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Configure flow control refresh threshold value */
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_FCRTV
argument_list|,
name|hw
operator|->
name|fc
operator|.
name|pause_time
operator|/
literal|2
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret_val
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_start_mac_link_82598 - Configures MAC link settings  *  @hw: pointer to hardware structure  *  *  Configures link settings based on values in the ixgbe_hw struct.  *  Restarts the link.  Performs autonegotiation if needed.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_start_mac_link_82598
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|bool
name|autoneg_wait_to_complete
parameter_list|)
block|{
name|u32
name|autoc_reg
decl_stmt|;
name|u32
name|links_reg
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_start_mac_link_82598"
argument_list|)
expr_stmt|;
comment|/* Restart link */
name|autoc_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|)
expr_stmt|;
name|autoc_reg
operator||=
name|IXGBE_AUTOC_AN_RESTART
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|,
name|autoc_reg
argument_list|)
expr_stmt|;
comment|/* Only poll for autoneg to complete if specified to do so */
if|if
condition|(
name|autoneg_wait_to_complete
condition|)
block|{
if|if
condition|(
operator|(
name|autoc_reg
operator|&
name|IXGBE_AUTOC_LMS_MASK
operator|)
operator|==
name|IXGBE_AUTOC_LMS_KX4_AN
operator|||
operator|(
name|autoc_reg
operator|&
name|IXGBE_AUTOC_LMS_MASK
operator|)
operator|==
name|IXGBE_AUTOC_LMS_KX4_AN_1G_AN
condition|)
block|{
name|links_reg
operator|=
literal|0
expr_stmt|;
comment|/* Just in case Autoneg time = 0 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_AUTO_NEG_TIME
condition|;
name|i
operator|++
control|)
block|{
name|links_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LINKS
argument_list|)
expr_stmt|;
if|if
condition|(
name|links_reg
operator|&
name|IXGBE_LINKS_KX_AN_COMP
condition|)
break|break;
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|links_reg
operator|&
name|IXGBE_LINKS_KX_AN_COMP
operator|)
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_AUTONEG_NOT_COMPLETE
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Autonegotiation did not complete.\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Add delay to filter out noises during initial link setup */
name|msec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_validate_link_ready - Function looks for phy link  *  @hw: pointer to hardware structure  *  *  Function indicates success when phy link is available. If phy is not ready  *  within 5 seconds of MAC indicating link, the function returns error.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_validate_link_ready
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|timeout
decl_stmt|;
name|u16
name|an_reg
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|device_id
operator|!=
name|IXGBE_DEV_ID_82598AT2
condition|)
return|return
name|IXGBE_SUCCESS
return|;
for|for
control|(
name|timeout
operator|=
literal|0
init|;
name|timeout
operator|<
name|IXGBE_VALIDATE_LINK_READY_TIMEOUT
condition|;
name|timeout
operator|++
control|)
block|{
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_STATUS
argument_list|,
name|IXGBE_MDIO_AUTO_NEG_DEV_TYPE
argument_list|,
operator|&
name|an_reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|an_reg
operator|&
name|IXGBE_MII_AUTONEG_COMPLETE
operator|)
operator|&&
operator|(
name|an_reg
operator|&
name|IXGBE_MII_AUTONEG_LINK_UP
operator|)
condition|)
break|break;
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timeout
operator|==
name|IXGBE_VALIDATE_LINK_READY_TIMEOUT
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"Link was indicated but link is down\n"
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_LINK_SETUP
return|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_check_mac_link_82598 - Get link/speed status  *  @hw: pointer to hardware structure  *  @speed: pointer to link speed  *  @link_up: TRUE is link is up, FALSE otherwise  *  @link_up_wait_to_complete: bool used to wait for link up or not  *  *  Reads the links register to determine if link is up and the current speed  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_check_mac_link_82598
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
modifier|*
name|speed
parameter_list|,
name|bool
modifier|*
name|link_up
parameter_list|,
name|bool
name|link_up_wait_to_complete
parameter_list|)
block|{
name|u32
name|links_reg
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|u16
name|link_reg
decl_stmt|,
name|adapt_comp_reg
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_check_mac_link_82598"
argument_list|)
expr_stmt|;
comment|/* 	 * SERDES PHY requires us to read link status from undocumented 	 * register 0xC79F.  Bit 0 set indicates link is up/ready; clear 	 * indicates link down.  OxC00C is read to check that the XAUI lanes 	 * are active.  Bit 0 clear indicates active; set indicates inactive. 	 */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|ixgbe_phy_nl
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
literal|0xC79F
argument_list|,
name|IXGBE_TWINAX_DEV
argument_list|,
operator|&
name|link_reg
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
literal|0xC79F
argument_list|,
name|IXGBE_TWINAX_DEV
argument_list|,
operator|&
name|link_reg
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
literal|0xC00C
argument_list|,
name|IXGBE_TWINAX_DEV
argument_list|,
operator|&
name|adapt_comp_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_up_wait_to_complete
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hw
operator|->
name|mac
operator|.
name|max_link_up_time
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|link_reg
operator|&
literal|1
operator|)
operator|&&
operator|(
operator|(
name|adapt_comp_reg
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
operator|*
name|link_up
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
else|else
block|{
operator|*
name|link_up
operator|=
name|FALSE
expr_stmt|;
block|}
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
literal|0xC79F
argument_list|,
name|IXGBE_TWINAX_DEV
argument_list|,
operator|&
name|link_reg
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
literal|0xC00C
argument_list|,
name|IXGBE_TWINAX_DEV
argument_list|,
operator|&
name|adapt_comp_reg
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|link_reg
operator|&
literal|1
operator|)
operator|&&
operator|(
operator|(
name|adapt_comp_reg
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
condition|)
operator|*
name|link_up
operator|=
name|TRUE
expr_stmt|;
else|else
operator|*
name|link_up
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|link_up
operator|==
name|FALSE
condition|)
goto|goto
name|out
goto|;
block|}
name|links_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LINKS
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_up_wait_to_complete
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hw
operator|->
name|mac
operator|.
name|max_link_up_time
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|links_reg
operator|&
name|IXGBE_LINKS_UP
condition|)
block|{
operator|*
name|link_up
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
else|else
block|{
operator|*
name|link_up
operator|=
name|FALSE
expr_stmt|;
block|}
name|msec_delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|links_reg
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_LINKS
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|links_reg
operator|&
name|IXGBE_LINKS_UP
condition|)
operator|*
name|link_up
operator|=
name|TRUE
expr_stmt|;
else|else
operator|*
name|link_up
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|links_reg
operator|&
name|IXGBE_LINKS_SPEED
condition|)
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_10GB_FULL
expr_stmt|;
else|else
operator|*
name|speed
operator|=
name|IXGBE_LINK_SPEED_1GB_FULL
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|device_id
operator|==
name|IXGBE_DEV_ID_82598AT2
operator|)
operator|&&
operator|(
operator|*
name|link_up
operator|==
name|TRUE
operator|)
operator|&&
operator|(
name|ixgbe_validate_link_ready
argument_list|(
name|hw
argument_list|)
operator|!=
name|IXGBE_SUCCESS
operator|)
condition|)
operator|*
name|link_up
operator|=
name|FALSE
expr_stmt|;
name|out
label|:
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_setup_mac_link_82598 - Set MAC link speed  *  @hw: pointer to hardware structure  *  @speed: new link speed  *  @autoneg_wait_to_complete: TRUE when waiting for completion is needed  *  *  Set the link speed in the AUTOC register and restarts link.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_setup_mac_link_82598
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
name|speed
parameter_list|,
name|bool
name|autoneg_wait_to_complete
parameter_list|)
block|{
name|bool
name|autoneg
init|=
name|FALSE
decl_stmt|;
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|ixgbe_link_speed
name|link_capabilities
init|=
name|IXGBE_LINK_SPEED_UNKNOWN
decl_stmt|;
name|u32
name|curr_autoc
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|)
decl_stmt|;
name|u32
name|autoc
init|=
name|curr_autoc
decl_stmt|;
name|u32
name|link_mode
init|=
name|autoc
operator|&
name|IXGBE_AUTOC_LMS_MASK
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_setup_mac_link_82598"
argument_list|)
expr_stmt|;
comment|/* Check to see if speed passed in is supported. */
name|ixgbe_get_link_capabilities
argument_list|(
name|hw
argument_list|,
operator|&
name|link_capabilities
argument_list|,
operator|&
name|autoneg
argument_list|)
expr_stmt|;
name|speed
operator|&=
name|link_capabilities
expr_stmt|;
if|if
condition|(
name|speed
operator|==
name|IXGBE_LINK_SPEED_UNKNOWN
condition|)
name|status
operator|=
name|IXGBE_ERR_LINK_SETUP
expr_stmt|;
comment|/* Set KX4/KX support according to speed requested */
elseif|else
if|if
condition|(
name|link_mode
operator|==
name|IXGBE_AUTOC_LMS_KX4_AN
operator|||
name|link_mode
operator|==
name|IXGBE_AUTOC_LMS_KX4_AN_1G_AN
condition|)
block|{
name|autoc
operator|&=
operator|~
name|IXGBE_AUTOC_KX4_KX_SUPP_MASK
expr_stmt|;
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_10GB_FULL
condition|)
name|autoc
operator||=
name|IXGBE_AUTOC_KX4_SUPP
expr_stmt|;
if|if
condition|(
name|speed
operator|&
name|IXGBE_LINK_SPEED_1GB_FULL
condition|)
name|autoc
operator||=
name|IXGBE_AUTOC_KX_SUPP
expr_stmt|;
if|if
condition|(
name|autoc
operator|!=
name|curr_autoc
condition|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|,
name|autoc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|==
name|IXGBE_SUCCESS
condition|)
block|{
comment|/* 		 * Setup and restart the link based on the new values in 		 * ixgbe_hw This will write the AUTOC register based on the new 		 * stored values 		 */
name|status
operator|=
name|ixgbe_start_mac_link_82598
argument_list|(
name|hw
argument_list|,
name|autoneg_wait_to_complete
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_setup_copper_link_82598 - Set the PHY autoneg advertised field  *  @hw: pointer to hardware structure  *  @speed: new link speed  *  @autoneg_wait_to_complete: TRUE if waiting is needed to complete  *  *  Sets the link speed in the AUTOC register in the MAC and restarts link.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_setup_copper_link_82598
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|ixgbe_link_speed
name|speed
parameter_list|,
name|bool
name|autoneg_wait_to_complete
parameter_list|)
block|{
name|s32
name|status
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_setup_copper_link_82598"
argument_list|)
expr_stmt|;
comment|/* Setup the PHY according to input speed */
name|status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|setup_link_speed
argument_list|(
name|hw
argument_list|,
name|speed
argument_list|,
name|autoneg_wait_to_complete
argument_list|)
expr_stmt|;
comment|/* Set up MAC */
name|ixgbe_start_mac_link_82598
argument_list|(
name|hw
argument_list|,
name|autoneg_wait_to_complete
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_reset_hw_82598 - Performs hardware reset  *  @hw: pointer to hardware structure  *  *  Resets the hardware by resetting the transmit and receive units, masks and  *  clears all interrupts, performing a PHY reset, and performing a link (MAC)  *  reset.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_reset_hw_82598
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|s32
name|phy_status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u32
name|ctrl
decl_stmt|;
name|u32
name|gheccr
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|u32
name|autoc
decl_stmt|;
name|u8
name|analog_val
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_reset_hw_82598"
argument_list|)
expr_stmt|;
comment|/* Call adapter stop to disable tx/rx and clear interrupts */
name|status
operator|=
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|stop_adapter
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IXGBE_SUCCESS
condition|)
goto|goto
name|reset_hw_out
goto|;
comment|/* 	 * Power up the Atlas Tx lanes if they are currently powered down. 	 * Atlas Tx lanes are powered down for MAC loopback tests, but 	 * they are not automatically restored on reset. 	 */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|read_analog_reg8
argument_list|(
name|hw
argument_list|,
name|IXGBE_ATLAS_PDN_LPBK
argument_list|,
operator|&
name|analog_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|analog_val
operator|&
name|IXGBE_ATLAS_PDN_TX_REG_EN
condition|)
block|{
comment|/* Enable Tx Atlas so packets can be transmitted again */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|read_analog_reg8
argument_list|(
name|hw
argument_list|,
name|IXGBE_ATLAS_PDN_LPBK
argument_list|,
operator|&
name|analog_val
argument_list|)
expr_stmt|;
name|analog_val
operator|&=
operator|~
name|IXGBE_ATLAS_PDN_TX_REG_EN
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|write_analog_reg8
argument_list|(
name|hw
argument_list|,
name|IXGBE_ATLAS_PDN_LPBK
argument_list|,
name|analog_val
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|read_analog_reg8
argument_list|(
name|hw
argument_list|,
name|IXGBE_ATLAS_PDN_10G
argument_list|,
operator|&
name|analog_val
argument_list|)
expr_stmt|;
name|analog_val
operator|&=
operator|~
name|IXGBE_ATLAS_PDN_TX_10G_QL_ALL
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|write_analog_reg8
argument_list|(
name|hw
argument_list|,
name|IXGBE_ATLAS_PDN_10G
argument_list|,
name|analog_val
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|read_analog_reg8
argument_list|(
name|hw
argument_list|,
name|IXGBE_ATLAS_PDN_1G
argument_list|,
operator|&
name|analog_val
argument_list|)
expr_stmt|;
name|analog_val
operator|&=
operator|~
name|IXGBE_ATLAS_PDN_TX_1G_QL_ALL
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|write_analog_reg8
argument_list|(
name|hw
argument_list|,
name|IXGBE_ATLAS_PDN_1G
argument_list|,
name|analog_val
argument_list|)
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|read_analog_reg8
argument_list|(
name|hw
argument_list|,
name|IXGBE_ATLAS_PDN_AN
argument_list|,
operator|&
name|analog_val
argument_list|)
expr_stmt|;
name|analog_val
operator|&=
operator|~
name|IXGBE_ATLAS_PDN_TX_AN_QL_ALL
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|write_analog_reg8
argument_list|(
name|hw
argument_list|,
name|IXGBE_ATLAS_PDN_AN
argument_list|,
name|analog_val
argument_list|)
expr_stmt|;
block|}
comment|/* Reset PHY */
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|reset_disable
operator|==
name|FALSE
condition|)
block|{
comment|/* PHY ops must be identified and initialized prior to reset */
comment|/* Init PHY and function pointers, perform SFP setup */
name|phy_status
operator|=
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|init
argument_list|(
name|hw
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_status
operator|==
name|IXGBE_ERR_SFP_NOT_SUPPORTED
condition|)
goto|goto
name|reset_hw_out
goto|;
if|if
condition|(
name|phy_status
operator|==
name|IXGBE_ERR_SFP_NOT_PRESENT
condition|)
goto|goto
name|mac_reset_top
goto|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|reset
argument_list|(
name|hw
argument_list|)
expr_stmt|;
block|}
name|mac_reset_top
label|:
comment|/* 	 * Issue global reset to the MAC.  This needs to be a SW reset. 	 * If link reset is used, it might reset the MAC when mng is using it 	 */
name|ctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CTRL
argument_list|)
operator||
name|IXGBE_CTRL_RST
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Poll for reset bit to self-clear indicating reset is complete */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|usec_delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ctrl
operator|&
name|IXGBE_CTRL_RST
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|ctrl
operator|&
name|IXGBE_CTRL_RST
condition|)
block|{
name|status
operator|=
name|IXGBE_ERR_RESET_FAILED
expr_stmt|;
name|DEBUGOUT
argument_list|(
literal|"Reset polling failed to complete.\n"
argument_list|)
expr_stmt|;
block|}
name|msec_delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|/* 	 * Double resets are required for recovery from certain error 	 * conditions.  Between resets, it is necessary to stall to allow time 	 * for any pending HW events to complete. 	 */
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|flags
operator|&
name|IXGBE_FLAGS_DOUBLE_RESET_REQUIRED
condition|)
block|{
name|hw
operator|->
name|mac
operator|.
name|flags
operator|&=
operator|~
name|IXGBE_FLAGS_DOUBLE_RESET_REQUIRED
expr_stmt|;
goto|goto
name|mac_reset_top
goto|;
block|}
name|gheccr
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GHECCR
argument_list|)
expr_stmt|;
name|gheccr
operator|&=
operator|~
operator|(
operator|(
literal|1
operator|<<
literal|21
operator|)
operator||
operator|(
literal|1
operator|<<
literal|18
operator|)
operator||
operator|(
literal|1
operator|<<
literal|9
operator|)
operator||
operator|(
literal|1
operator|<<
literal|6
operator|)
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_GHECCR
argument_list|,
name|gheccr
argument_list|)
expr_stmt|;
comment|/* 	 * Store the original AUTOC value if it has not been 	 * stored off yet.  Otherwise restore the stored original 	 * AUTOC value since the reset operation sets back to deaults. 	 */
name|autoc
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|orig_link_settings_stored
operator|==
name|FALSE
condition|)
block|{
name|hw
operator|->
name|mac
operator|.
name|orig_autoc
operator|=
name|autoc
expr_stmt|;
name|hw
operator|->
name|mac
operator|.
name|orig_link_settings_stored
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|autoc
operator|!=
name|hw
operator|->
name|mac
operator|.
name|orig_autoc
condition|)
block|{
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|orig_autoc
argument_list|)
expr_stmt|;
block|}
comment|/* Store the permanent mac address */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|get_mac_addr
argument_list|(
name|hw
argument_list|,
name|hw
operator|->
name|mac
operator|.
name|perm_addr
argument_list|)
expr_stmt|;
comment|/* 	 * Store MAC address from RAR0, clear receive address registers, and 	 * clear the multicast table 	 */
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|init_rx_addrs
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|reset_hw_out
label|:
if|if
condition|(
name|phy_status
operator|!=
name|IXGBE_SUCCESS
condition|)
name|status
operator|=
name|phy_status
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_set_vmdq_82598 - Associate a VMDq set index with a rx address  *  @hw: pointer to hardware struct  *  @rar: receive address register index to associate with a VMDq index  *  @vmdq: VMDq set index  **/
end_comment

begin_function
name|s32
name|ixgbe_set_vmdq_82598
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|rar
parameter_list|,
name|u32
name|vmdq
parameter_list|)
block|{
name|u32
name|rar_high
decl_stmt|;
name|u32
name|rar_entries
init|=
name|hw
operator|->
name|mac
operator|.
name|num_rar_entries
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_set_vmdq_82598"
argument_list|)
expr_stmt|;
comment|/* Make sure we are using a valid rar index range */
if|if
condition|(
name|rar
operator|>=
name|rar_entries
condition|)
block|{
name|DEBUGOUT1
argument_list|(
literal|"RAR index %d is out of range.\n"
argument_list|,
name|rar
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_INVALID_ARGUMENT
return|;
block|}
name|rar_high
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAH
argument_list|(
name|rar
argument_list|)
argument_list|)
expr_stmt|;
name|rar_high
operator|&=
operator|~
name|IXGBE_RAH_VIND_MASK
expr_stmt|;
name|rar_high
operator||=
operator|(
operator|(
name|vmdq
operator|<<
name|IXGBE_RAH_VIND_SHIFT
operator|)
operator|&
name|IXGBE_RAH_VIND_MASK
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAH
argument_list|(
name|rar
argument_list|)
argument_list|,
name|rar_high
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_clear_vmdq_82598 - Disassociate a VMDq set index from an rx address  *  @hw: pointer to hardware struct  *  @rar: receive address register index to associate with a VMDq index  *  @vmdq: VMDq clear index (not used in 82598, but elsewhere)  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_clear_vmdq_82598
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|rar
parameter_list|,
name|u32
name|vmdq
parameter_list|)
block|{
name|u32
name|rar_high
decl_stmt|;
name|u32
name|rar_entries
init|=
name|hw
operator|->
name|mac
operator|.
name|num_rar_entries
decl_stmt|;
name|UNREFERENCED_1PARAMETER
argument_list|(
name|vmdq
argument_list|)
expr_stmt|;
comment|/* Make sure we are using a valid rar index range */
if|if
condition|(
name|rar
operator|>=
name|rar_entries
condition|)
block|{
name|DEBUGOUT1
argument_list|(
literal|"RAR index %d is out of range.\n"
argument_list|,
name|rar
argument_list|)
expr_stmt|;
return|return
name|IXGBE_ERR_INVALID_ARGUMENT
return|;
block|}
name|rar_high
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAH
argument_list|(
name|rar
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rar_high
operator|&
name|IXGBE_RAH_VIND_MASK
condition|)
block|{
name|rar_high
operator|&=
operator|~
name|IXGBE_RAH_VIND_MASK
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RAH
argument_list|(
name|rar
argument_list|)
argument_list|,
name|rar_high
argument_list|)
expr_stmt|;
block|}
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_set_vfta_82598 - Set VLAN filter table  *  @hw: pointer to hardware structure  *  @vlan: VLAN id to write to VLAN filter  *  @vind: VMDq output index that maps queue to VLAN id in VFTA  *  @vlan_on: boolean flag to turn on/off VLAN in VFTA  *  @vlvf_bypass: boolean flag - unused  *  *  Turn on/off specified VLAN in the VLAN filter table.  **/
end_comment

begin_function
name|s32
name|ixgbe_set_vfta_82598
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|vlan
parameter_list|,
name|u32
name|vind
parameter_list|,
name|bool
name|vlan_on
parameter_list|,
name|bool
name|vlvf_bypass
parameter_list|)
block|{
name|u32
name|regindex
decl_stmt|;
name|u32
name|bitindex
decl_stmt|;
name|u32
name|bits
decl_stmt|;
name|u32
name|vftabyte
decl_stmt|;
name|UNREFERENCED_1PARAMETER
argument_list|(
name|vlvf_bypass
argument_list|)
expr_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_set_vfta_82598"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vlan
operator|>
literal|4095
condition|)
return|return
name|IXGBE_ERR_PARAM
return|;
comment|/* Determine 32-bit word position in array */
name|regindex
operator|=
operator|(
name|vlan
operator|>>
literal|5
operator|)
operator|&
literal|0x7F
expr_stmt|;
comment|/* upper seven bits */
comment|/* Determine the location of the (VMD) queue index */
name|vftabyte
operator|=
operator|(
operator|(
name|vlan
operator|>>
literal|3
operator|)
operator|&
literal|0x03
operator|)
expr_stmt|;
comment|/* bits (4:3) indicating byte array */
name|bitindex
operator|=
operator|(
name|vlan
operator|&
literal|0x7
operator|)
operator|<<
literal|2
expr_stmt|;
comment|/* lower 3 bits indicate nibble */
comment|/* Set the nibble for VMD queue index */
name|bits
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFTAVIND
argument_list|(
name|vftabyte
argument_list|,
name|regindex
argument_list|)
argument_list|)
expr_stmt|;
name|bits
operator|&=
operator|(
operator|~
operator|(
literal|0x0F
operator|<<
name|bitindex
operator|)
operator|)
expr_stmt|;
name|bits
operator||=
operator|(
name|vind
operator|<<
name|bitindex
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFTAVIND
argument_list|(
name|vftabyte
argument_list|,
name|regindex
argument_list|)
argument_list|,
name|bits
argument_list|)
expr_stmt|;
comment|/* Determine the location of the bit for this VLAN id */
name|bitindex
operator|=
name|vlan
operator|&
literal|0x1F
expr_stmt|;
comment|/* lower five bits */
name|bits
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFTA
argument_list|(
name|regindex
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vlan_on
condition|)
comment|/* Turn on this VLAN id */
name|bits
operator||=
operator|(
literal|1
operator|<<
name|bitindex
operator|)
expr_stmt|;
else|else
comment|/* Turn off this VLAN id */
name|bits
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|bitindex
operator|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFTA
argument_list|(
name|regindex
argument_list|)
argument_list|,
name|bits
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_clear_vfta_82598 - Clear VLAN filter table  *  @hw: pointer to hardware structure  *  *  Clears the VLAN filer table, and the VMDq index associated with the filter  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_clear_vfta_82598
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|offset
decl_stmt|;
name|u32
name|vlanbyte
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_clear_vfta_82598"
argument_list|)
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|hw
operator|->
name|mac
operator|.
name|vft_size
condition|;
name|offset
operator|++
control|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFTA
argument_list|(
name|offset
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|vlanbyte
operator|=
literal|0
init|;
name|vlanbyte
operator|<
literal|4
condition|;
name|vlanbyte
operator|++
control|)
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|hw
operator|->
name|mac
operator|.
name|vft_size
condition|;
name|offset
operator|++
control|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_VFTAVIND
argument_list|(
name|vlanbyte
argument_list|,
name|offset
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_analog_reg8_82598 - Reads 8 bit Atlas analog register  *  @hw: pointer to hardware structure  *  @reg: analog register to read  *  @val: read value  *  *  Performs read operation to Atlas analog register specified.  **/
end_comment

begin_function
name|s32
name|ixgbe_read_analog_reg8_82598
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|reg
parameter_list|,
name|u8
modifier|*
name|val
parameter_list|)
block|{
name|u32
name|atlas_ctl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_read_analog_reg8_82598"
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ATLASCTL
argument_list|,
name|IXGBE_ATLASCTL_WRITE_CMD
operator||
operator|(
name|reg
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|atlas_ctl
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ATLASCTL
argument_list|)
expr_stmt|;
operator|*
name|val
operator|=
operator|(
name|u8
operator|)
name|atlas_ctl
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_write_analog_reg8_82598 - Writes 8 bit Atlas analog register  *  @hw: pointer to hardware structure  *  @reg: atlas register to write  *  @val: value to write  *  *  Performs write operation to Atlas analog register specified.  **/
end_comment

begin_function
name|s32
name|ixgbe_write_analog_reg8_82598
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|reg
parameter_list|,
name|u8
name|val
parameter_list|)
block|{
name|u32
name|atlas_ctl
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_write_analog_reg8_82598"
argument_list|)
expr_stmt|;
name|atlas_ctl
operator|=
operator|(
name|reg
operator|<<
literal|8
operator|)
operator||
name|val
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_ATLASCTL
argument_list|,
name|atlas_ctl
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_FLUSH
argument_list|(
name|hw
argument_list|)
expr_stmt|;
name|usec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_i2c_phy_82598 - Reads 8 bit word over I2C interface.  *  @hw: pointer to hardware structure  *  @dev_addr: address to read from  *  @byte_offset: byte offset to read from dev_addr  *  @eeprom_data: value read  *  *  Performs 8 byte read operation to SFP module's EEPROM over I2C interface.  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_read_i2c_phy_82598
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|dev_addr
parameter_list|,
name|u8
name|byte_offset
parameter_list|,
name|u8
modifier|*
name|eeprom_data
parameter_list|)
block|{
name|s32
name|status
init|=
name|IXGBE_SUCCESS
decl_stmt|;
name|u16
name|sfp_addr
init|=
literal|0
decl_stmt|;
name|u16
name|sfp_data
init|=
literal|0
decl_stmt|;
name|u16
name|sfp_stat
init|=
literal|0
decl_stmt|;
name|u16
name|gssr
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_read_i2c_phy_82598"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_STATUS
argument_list|)
operator|&
name|IXGBE_STATUS_LAN_ID_1
condition|)
name|gssr
operator|=
name|IXGBE_GSSR_PHY1_SM
expr_stmt|;
else|else
name|gssr
operator|=
name|IXGBE_GSSR_PHY0_SM
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|acquire_swfw_sync
argument_list|(
name|hw
argument_list|,
name|gssr
argument_list|)
operator|!=
name|IXGBE_SUCCESS
condition|)
return|return
name|IXGBE_ERR_SWFW_SYNC
return|;
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|ixgbe_phy_nl
condition|)
block|{
comment|/* 		 * NetLogic phy SDA/SCL registers are at addresses 0xC30A to 		 * 0xC30D. These registers are used to talk to the SFP+ 		 * module's EEPROM through the SDA/SCL (I2C) interface. 		 */
name|sfp_addr
operator|=
operator|(
name|dev_addr
operator|<<
literal|8
operator|)
operator|+
name|byte_offset
expr_stmt|;
name|sfp_addr
operator|=
operator|(
name|sfp_addr
operator||
name|IXGBE_I2C_EEPROM_READ_MASK
operator|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|write_reg_mdi
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_PMA_PMD_SDA_SCL_ADDR
argument_list|,
name|IXGBE_MDIO_PMA_PMD_DEV_TYPE
argument_list|,
name|sfp_addr
argument_list|)
expr_stmt|;
comment|/* Poll status */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg_mdi
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_PMA_PMD_SDA_SCL_STAT
argument_list|,
name|IXGBE_MDIO_PMA_PMD_DEV_TYPE
argument_list|,
operator|&
name|sfp_stat
argument_list|)
expr_stmt|;
name|sfp_stat
operator|=
name|sfp_stat
operator|&
name|IXGBE_I2C_EEPROM_STATUS_MASK
expr_stmt|;
if|if
condition|(
name|sfp_stat
operator|!=
name|IXGBE_I2C_EEPROM_STATUS_IN_PROGRESS
condition|)
break|break;
name|msec_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sfp_stat
operator|!=
name|IXGBE_I2C_EEPROM_STATUS_PASS
condition|)
block|{
name|DEBUGOUT
argument_list|(
literal|"EEPROM read did not pass.\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IXGBE_ERR_SFP_NOT_PRESENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Read data */
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg_mdi
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_PMA_PMD_SDA_SCL_DATA
argument_list|,
name|IXGBE_MDIO_PMA_PMD_DEV_TYPE
argument_list|,
operator|&
name|sfp_data
argument_list|)
expr_stmt|;
operator|*
name|eeprom_data
operator|=
call|(
name|u8
call|)
argument_list|(
name|sfp_data
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|IXGBE_ERR_PHY
expr_stmt|;
block|}
name|out
label|:
name|hw
operator|->
name|mac
operator|.
name|ops
operator|.
name|release_swfw_sync
argument_list|(
name|hw
argument_list|,
name|gssr
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_i2c_eeprom_82598 - Reads 8 bit word over I2C interface.  *  @hw: pointer to hardware structure  *  @byte_offset: EEPROM byte offset to read  *  @eeprom_data: value read  *  *  Performs 8 byte read operation to SFP module's EEPROM over I2C interface.  **/
end_comment

begin_function
name|s32
name|ixgbe_read_i2c_eeprom_82598
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|byte_offset
parameter_list|,
name|u8
modifier|*
name|eeprom_data
parameter_list|)
block|{
return|return
name|ixgbe_read_i2c_phy_82598
argument_list|(
name|hw
argument_list|,
name|IXGBE_I2C_EEPROM_DEV_ADDR
argument_list|,
name|byte_offset
argument_list|,
name|eeprom_data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_read_i2c_sff8472_82598 - Reads 8 bit word over I2C interface.  *  @hw: pointer to hardware structure  *  @byte_offset: byte offset at address 0xA2  *  @eeprom_data: value read  *  *  Performs 8 byte read operation to SFP module's SFF-8472 data over I2C  **/
end_comment

begin_function
specifier|static
name|s32
name|ixgbe_read_i2c_sff8472_82598
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u8
name|byte_offset
parameter_list|,
name|u8
modifier|*
name|sff8472_data
parameter_list|)
block|{
return|return
name|ixgbe_read_i2c_phy_82598
argument_list|(
name|hw
argument_list|,
name|IXGBE_I2C_EEPROM_DEV_ADDR2
argument_list|,
name|byte_offset
argument_list|,
name|sff8472_data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_get_supported_physical_layer_82598 - Returns physical layer type  *  @hw: pointer to hardware structure  *  *  Determines physical layer capabilities of the current configuration.  **/
end_comment

begin_function
name|u64
name|ixgbe_get_supported_physical_layer_82598
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u64
name|physical_layer
init|=
name|IXGBE_PHYSICAL_LAYER_UNKNOWN
decl_stmt|;
name|u32
name|autoc
init|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_AUTOC
argument_list|)
decl_stmt|;
name|u32
name|pma_pmd_10g
init|=
name|autoc
operator|&
name|IXGBE_AUTOC_10G_PMA_PMD_MASK
decl_stmt|;
name|u32
name|pma_pmd_1g
init|=
name|autoc
operator|&
name|IXGBE_AUTOC_1G_PMA_PMD_MASK
decl_stmt|;
name|u16
name|ext_ability
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_get_supported_physical_layer_82598"
argument_list|)
expr_stmt|;
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|identify
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* Copper PHY must be checked before AUTOC LMS to determine correct 	 * physical layer because 10GBase-T PHYs use LMS = KX4/KX */
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
condition|)
block|{
case|case
name|ixgbe_phy_tn
case|:
case|case
name|ixgbe_phy_cu_unknown
case|:
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|read_reg
argument_list|(
name|hw
argument_list|,
name|IXGBE_MDIO_PHY_EXT_ABILITY
argument_list|,
name|IXGBE_MDIO_PMA_PMD_DEV_TYPE
argument_list|,
operator|&
name|ext_ability
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext_ability
operator|&
name|IXGBE_MDIO_PHY_10GBASET_ABILITY
condition|)
name|physical_layer
operator||=
name|IXGBE_PHYSICAL_LAYER_10GBASE_T
expr_stmt|;
if|if
condition|(
name|ext_ability
operator|&
name|IXGBE_MDIO_PHY_1000BASET_ABILITY
condition|)
name|physical_layer
operator||=
name|IXGBE_PHYSICAL_LAYER_1000BASE_T
expr_stmt|;
if|if
condition|(
name|ext_ability
operator|&
name|IXGBE_MDIO_PHY_100BASETX_ABILITY
condition|)
name|physical_layer
operator||=
name|IXGBE_PHYSICAL_LAYER_100BASE_TX
expr_stmt|;
goto|goto
name|out
goto|;
default|default:
break|break;
block|}
switch|switch
condition|(
name|autoc
operator|&
name|IXGBE_AUTOC_LMS_MASK
condition|)
block|{
case|case
name|IXGBE_AUTOC_LMS_1G_AN
case|:
case|case
name|IXGBE_AUTOC_LMS_1G_LINK_NO_AN
case|:
if|if
condition|(
name|pma_pmd_1g
operator|==
name|IXGBE_AUTOC_1G_KX
condition|)
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_1000BASE_KX
expr_stmt|;
else|else
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_1000BASE_BX
expr_stmt|;
break|break;
case|case
name|IXGBE_AUTOC_LMS_10G_LINK_NO_AN
case|:
if|if
condition|(
name|pma_pmd_10g
operator|==
name|IXGBE_AUTOC_10G_CX4
condition|)
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_10GBASE_CX4
expr_stmt|;
elseif|else
if|if
condition|(
name|pma_pmd_10g
operator|==
name|IXGBE_AUTOC_10G_KX4
condition|)
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_10GBASE_KX4
expr_stmt|;
else|else
comment|/* XAUI */
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_UNKNOWN
expr_stmt|;
break|break;
case|case
name|IXGBE_AUTOC_LMS_KX4_AN
case|:
case|case
name|IXGBE_AUTOC_LMS_KX4_AN_1G_AN
case|:
if|if
condition|(
name|autoc
operator|&
name|IXGBE_AUTOC_KX_SUPP
condition|)
name|physical_layer
operator||=
name|IXGBE_PHYSICAL_LAYER_1000BASE_KX
expr_stmt|;
if|if
condition|(
name|autoc
operator|&
name|IXGBE_AUTOC_KX4_SUPP
condition|)
name|physical_layer
operator||=
name|IXGBE_PHYSICAL_LAYER_10GBASE_KX4
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|hw
operator|->
name|phy
operator|.
name|type
operator|==
name|ixgbe_phy_nl
condition|)
block|{
name|hw
operator|->
name|phy
operator|.
name|ops
operator|.
name|identify_sfp
argument_list|(
name|hw
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hw
operator|->
name|phy
operator|.
name|sfp_type
condition|)
block|{
case|case
name|ixgbe_sfp_type_da_cu
case|:
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_SFP_PLUS_CU
expr_stmt|;
break|break;
case|case
name|ixgbe_sfp_type_sr
case|:
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_10GBASE_SR
expr_stmt|;
break|break;
case|case
name|ixgbe_sfp_type_lr
case|:
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_10GBASE_LR
expr_stmt|;
break|break;
default|default:
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_UNKNOWN
expr_stmt|;
break|break;
block|}
block|}
switch|switch
condition|(
name|hw
operator|->
name|device_id
condition|)
block|{
case|case
name|IXGBE_DEV_ID_82598_DA_DUAL_PORT
case|:
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_SFP_PLUS_CU
expr_stmt|;
break|break;
case|case
name|IXGBE_DEV_ID_82598AF_DUAL_PORT
case|:
case|case
name|IXGBE_DEV_ID_82598AF_SINGLE_PORT
case|:
case|case
name|IXGBE_DEV_ID_82598_SR_DUAL_PORT_EM
case|:
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_10GBASE_SR
expr_stmt|;
break|break;
case|case
name|IXGBE_DEV_ID_82598EB_XF_LR
case|:
name|physical_layer
operator|=
name|IXGBE_PHYSICAL_LAYER_10GBASE_LR
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|out
label|:
return|return
name|physical_layer
return|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_set_lan_id_multi_port_pcie_82598 - Set LAN id for PCIe multiple  *  port devices.  *  @hw: pointer to the HW structure  *  *  Calls common function and corrects issue with some single port devices  *  that enable LAN1 but not LAN0.  **/
end_comment

begin_function
name|void
name|ixgbe_set_lan_id_multi_port_pcie_82598
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|struct
name|ixgbe_bus_info
modifier|*
name|bus
init|=
operator|&
name|hw
operator|->
name|bus
decl_stmt|;
name|u16
name|pci_gen
init|=
literal|0
decl_stmt|;
name|u16
name|pci_ctrl2
init|=
literal|0
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_set_lan_id_multi_port_pcie_82598"
argument_list|)
expr_stmt|;
name|ixgbe_set_lan_id_multi_port_pcie
argument_list|(
name|hw
argument_list|)
expr_stmt|;
comment|/* check if LAN0 is disabled */
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|IXGBE_PCIE_GENERAL_PTR
argument_list|,
operator|&
name|pci_gen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pci_gen
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|pci_gen
operator|!=
literal|0xFFFF
operator|)
condition|)
block|{
name|hw
operator|->
name|eeprom
operator|.
name|ops
operator|.
name|read
argument_list|(
name|hw
argument_list|,
name|pci_gen
operator|+
name|IXGBE_PCIE_CTRL2
argument_list|,
operator|&
name|pci_ctrl2
argument_list|)
expr_stmt|;
comment|/* if LAN0 is completely disabled force function to 0 */
if|if
condition|(
operator|(
name|pci_ctrl2
operator|&
name|IXGBE_PCIE_CTRL2_LAN_DISABLE
operator|)
operator|&&
operator|!
operator|(
name|pci_ctrl2
operator|&
name|IXGBE_PCIE_CTRL2_DISABLE_SELECT
operator|)
operator|&&
operator|!
operator|(
name|pci_ctrl2
operator|&
name|IXGBE_PCIE_CTRL2_DUMMY_ENABLE
operator|)
condition|)
block|{
name|bus
operator|->
name|func
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  *  ixgbe_enable_relaxed_ordering_82598 - enable relaxed ordering  *  @hw: pointer to hardware structure  *  **/
end_comment

begin_function
name|void
name|ixgbe_enable_relaxed_ordering_82598
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|)
block|{
name|u32
name|regval
decl_stmt|;
name|u32
name|i
decl_stmt|;
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_enable_relaxed_ordering_82598"
argument_list|)
expr_stmt|;
comment|/* Enable relaxed ordering */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|(
name|i
operator|<
name|hw
operator|->
name|mac
operator|.
name|max_tx_queues
operator|)
operator|&&
operator|(
name|i
operator|<
name|IXGBE_DCA_MAX_QUEUES_82598
operator|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|regval
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DCA_TXCTRL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|regval
operator||=
name|IXGBE_DCA_TXCTRL_DESC_WRO_EN
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DCA_TXCTRL
argument_list|(
name|i
argument_list|)
argument_list|,
name|regval
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|(
name|i
operator|<
name|hw
operator|->
name|mac
operator|.
name|max_rx_queues
operator|)
operator|&&
operator|(
name|i
operator|<
name|IXGBE_DCA_MAX_QUEUES_82598
operator|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|regval
operator|=
name|IXGBE_READ_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DCA_RXCTRL
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|regval
operator||=
name|IXGBE_DCA_RXCTRL_DATA_WRO_EN
operator||
name|IXGBE_DCA_RXCTRL_HEAD_WRO_EN
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_DCA_RXCTRL
argument_list|(
name|i
argument_list|)
argument_list|,
name|regval
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * ixgbe_set_rxpba_82598 - Initialize RX packet buffer  * @hw: pointer to hardware structure  * @num_pb: number of packet buffers to allocate  * @headroom: reserve n KB of headroom  * @strategy: packet buffer allocation strategy  **/
end_comment

begin_function
specifier|static
name|void
name|ixgbe_set_rxpba_82598
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|int
name|num_pb
parameter_list|,
name|u32
name|headroom
parameter_list|,
name|int
name|strategy
parameter_list|)
block|{
name|u32
name|rxpktsize
init|=
name|IXGBE_RXPBSIZE_64KB
decl_stmt|;
name|u8
name|i
init|=
literal|0
decl_stmt|;
name|UNREFERENCED_1PARAMETER
argument_list|(
name|headroom
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|num_pb
condition|)
return|return;
comment|/* Setup Rx packet buffer sizes */
switch|switch
condition|(
name|strategy
condition|)
block|{
case|case
name|PBA_STRATEGY_WEIGHTED
case|:
comment|/* Setup the first four at 80KB */
name|rxpktsize
operator|=
name|IXGBE_RXPBSIZE_80KB
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXPBSIZE
argument_list|(
name|i
argument_list|)
argument_list|,
name|rxpktsize
argument_list|)
expr_stmt|;
comment|/* Setup the last four at 48KB...don't re-init i */
name|rxpktsize
operator|=
name|IXGBE_RXPBSIZE_48KB
expr_stmt|;
comment|/* Fall Through */
case|case
name|PBA_STRATEGY_EQUAL
case|:
default|default:
comment|/* Divide the remaining Rx packet buffer evenly among the TCs */
for|for
control|(
init|;
name|i
operator|<
name|IXGBE_MAX_PACKET_BUFFERS
condition|;
name|i
operator|++
control|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXPBSIZE
argument_list|(
name|i
argument_list|)
argument_list|,
name|rxpktsize
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Setup Tx packet buffer sizes */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IXGBE_MAX_PACKET_BUFFERS
condition|;
name|i
operator|++
control|)
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_TXPBSIZE
argument_list|(
name|i
argument_list|)
argument_list|,
name|IXGBE_TXPBSIZE_40KB
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *  ixgbe_enable_rx_dma_82598 - Enable the Rx DMA unit  *  @hw: pointer to hardware structure  *  @regval: register value to write to RXCTRL  *  *  Enables the Rx DMA unit  **/
end_comment

begin_function
name|s32
name|ixgbe_enable_rx_dma_82598
parameter_list|(
name|struct
name|ixgbe_hw
modifier|*
name|hw
parameter_list|,
name|u32
name|regval
parameter_list|)
block|{
name|DEBUGFUNC
argument_list|(
literal|"ixgbe_enable_rx_dma_82598"
argument_list|)
expr_stmt|;
name|IXGBE_WRITE_REG
argument_list|(
name|hw
argument_list|,
name|IXGBE_RXCTRL
argument_list|,
name|regval
argument_list|)
expr_stmt|;
return|return
name|IXGBE_SUCCESS
return|;
block|}
end_function

end_unit

