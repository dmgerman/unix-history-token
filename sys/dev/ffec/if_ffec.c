begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2013 Ian Lepore<ian@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Driver for Freescale Fast Ethernet Controller, found on imx-series SoCs among  * others.  Also works for the ENET Gigibit controller found on imx6 and imx28,  * but the driver doesn't currently use any of the ENET advanced features other  * than enabling gigabit.  *  * The interface name 'fec' is already taken by netgraph's Fast Etherchannel  * (netgraph/ng_fec.c), so we use 'ffec'.  *  * Requires an FDT entry with at least these properties:  *   fec: ethernet@02188000 {  *      compatible = "fsl,imxNN-fec";  *      reg =<0x02188000 0x4000>;  *      interrupts =<150 151>;  *      phy-mode = "rgmii";  *      phy-disable-preamble; // optional  *   };  * The second interrupt number is for IEEE-1588, and is not currently used; it  * need not be present.  phy-mode must be one of: "mii", "rmii", "rgmii".  * There is also an optional property, phy-disable-preamble, which if present  * will disable the preamble bits, cutting the size of each mdio transaction  * (and thus the busy-wait time) in half.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<dev/fdt/fdt_common.h>
end_include

begin_include
include|#
directive|include
file|<dev/ffec/if_ffecreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus_subr.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/mii.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/miivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/mii_fdt.h>
end_include

begin_include
include|#
directive|include
file|"miibus_if.h"
end_include

begin_comment
comment|/*  * There are small differences in the hardware on various SoCs.  Not every SoC  * we support has its own FECTYPE; most work as GENERIC and only the ones that  * need different handling get their own entry.  In addition to the types in  * this list, there are some flags below that can be ORed into the upper bits.  */
end_comment

begin_enum
enum|enum
block|{
name|FECTYPE_NONE
block|,
name|FECTYPE_GENERIC
block|,
name|FECTYPE_IMX53
block|,
name|FECTYPE_IMX6
block|,
name|FECTYPE_MVF
block|, }
enum|;
end_enum

begin_comment
comment|/*  * Flags that describe general differences between the FEC hardware in various  * SoCs.  These are ORed into the FECTYPE enum values.  */
end_comment

begin_define
define|#
directive|define
name|FECTYPE_MASK
value|0x0000ffff
end_define

begin_define
define|#
directive|define
name|FECFLAG_GBE
value|(0x0001<< 16)
end_define

begin_comment
comment|/*  * Table of supported FDT compat strings and their associated FECTYPE values.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ofw_compat_data
name|compat_data
index|[]
init|=
block|{
block|{
literal|"fsl,imx51-fec"
block|,
name|FECTYPE_GENERIC
block|}
block|,
block|{
literal|"fsl,imx53-fec"
block|,
name|FECTYPE_IMX53
block|}
block|,
block|{
literal|"fsl,imx6q-fec"
block|,
name|FECTYPE_IMX6
operator||
name|FECFLAG_GBE
block|}
block|,
block|{
literal|"fsl,imx6ul-fec"
block|,
name|FECTYPE_IMX6
block|}
block|,
block|{
literal|"fsl,mvf600-fec"
block|,
name|FECTYPE_MVF
block|}
block|,
block|{
literal|"fsl,mvf-fec"
block|,
name|FECTYPE_MVF
block|}
block|,
block|{
name|NULL
block|,
name|FECTYPE_NONE
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Driver data and defines.  */
end_comment

begin_define
define|#
directive|define
name|RX_DESC_COUNT
value|64
end_define

begin_define
define|#
directive|define
name|RX_DESC_SIZE
value|(sizeof(struct ffec_hwdesc) * RX_DESC_COUNT)
end_define

begin_define
define|#
directive|define
name|TX_DESC_COUNT
value|64
end_define

begin_define
define|#
directive|define
name|TX_DESC_SIZE
value|(sizeof(struct ffec_hwdesc) * TX_DESC_COUNT)
end_define

begin_define
define|#
directive|define
name|WATCHDOG_TIMEOUT_SECS
value|5
end_define

begin_struct
struct|struct
name|ffec_bufmap
block|{
name|struct
name|mbuf
modifier|*
name|mbuf
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ffec_softc
block|{
name|device_t
name|dev
decl_stmt|;
name|device_t
name|miibus
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii_softc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|if_flags
decl_stmt|;
name|struct
name|mtx
name|mtx
decl_stmt|;
name|struct
name|resource
modifier|*
name|irq_res
decl_stmt|;
name|struct
name|resource
modifier|*
name|mem_res
decl_stmt|;
name|void
modifier|*
name|intr_cookie
decl_stmt|;
name|struct
name|callout
name|ffec_callout
decl_stmt|;
name|mii_contype_t
name|phy_conn_type
decl_stmt|;
name|uint8_t
name|fectype
decl_stmt|;
name|boolean_t
name|link_is_up
decl_stmt|;
name|boolean_t
name|is_attached
decl_stmt|;
name|boolean_t
name|is_detaching
decl_stmt|;
name|int
name|tx_watchdog_count
decl_stmt|;
name|bus_dma_tag_t
name|rxdesc_tag
decl_stmt|;
name|bus_dmamap_t
name|rxdesc_map
decl_stmt|;
name|struct
name|ffec_hwdesc
modifier|*
name|rxdesc_ring
decl_stmt|;
name|bus_addr_t
name|rxdesc_ring_paddr
decl_stmt|;
name|bus_dma_tag_t
name|rxbuf_tag
decl_stmt|;
name|struct
name|ffec_bufmap
name|rxbuf_map
index|[
name|RX_DESC_COUNT
index|]
decl_stmt|;
name|uint32_t
name|rx_idx
decl_stmt|;
name|bus_dma_tag_t
name|txdesc_tag
decl_stmt|;
name|bus_dmamap_t
name|txdesc_map
decl_stmt|;
name|struct
name|ffec_hwdesc
modifier|*
name|txdesc_ring
decl_stmt|;
name|bus_addr_t
name|txdesc_ring_paddr
decl_stmt|;
name|bus_dma_tag_t
name|txbuf_tag
decl_stmt|;
name|struct
name|ffec_bufmap
name|txbuf_map
index|[
name|TX_DESC_COUNT
index|]
decl_stmt|;
name|uint32_t
name|tx_idx_head
decl_stmt|;
name|uint32_t
name|tx_idx_tail
decl_stmt|;
name|int
name|txcount
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|FFEC_LOCK
parameter_list|(
name|sc
parameter_list|)
value|mtx_lock(&(sc)->mtx)
end_define

begin_define
define|#
directive|define
name|FFEC_UNLOCK
parameter_list|(
name|sc
parameter_list|)
value|mtx_unlock(&(sc)->mtx)
end_define

begin_define
define|#
directive|define
name|FFEC_LOCK_INIT
parameter_list|(
name|sc
parameter_list|)
value|mtx_init(&(sc)->mtx, \ 	    device_get_nameunit((sc)->dev), MTX_NETWORK_LOCK, MTX_DEF)
end_define

begin_define
define|#
directive|define
name|FFEC_LOCK_DESTROY
parameter_list|(
name|sc
parameter_list|)
value|mtx_destroy(&(sc)->mtx);
end_define

begin_define
define|#
directive|define
name|FFEC_ASSERT_LOCKED
parameter_list|(
name|sc
parameter_list|)
value|mtx_assert(&(sc)->mtx, MA_OWNED);
end_define

begin_define
define|#
directive|define
name|FFEC_ASSERT_UNLOCKED
parameter_list|(
name|sc
parameter_list|)
value|mtx_assert(&(sc)->mtx, MA_NOTOWNED);
end_define

begin_function_decl
specifier|static
name|void
name|ffec_init_locked
parameter_list|(
name|struct
name|ffec_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffec_stop_locked
parameter_list|(
name|struct
name|ffec_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffec_txstart_locked
parameter_list|(
name|struct
name|ffec_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffec_txfinish_locked
parameter_list|(
name|struct
name|ffec_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
specifier|inline
name|uint16_t
name|RD2
parameter_list|(
name|struct
name|ffec_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|off
parameter_list|)
block|{
return|return
operator|(
name|bus_read_2
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|off
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|WR2
parameter_list|(
name|struct
name|ffec_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|off
parameter_list|,
name|uint16_t
name|val
parameter_list|)
block|{
name|bus_write_2
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|off
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint32_t
name|RD4
parameter_list|(
name|struct
name|ffec_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|off
parameter_list|)
block|{
return|return
operator|(
name|bus_read_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|off
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|WR4
parameter_list|(
name|struct
name|ffec_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|off
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|bus_write_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|off
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint32_t
name|next_rxidx
parameter_list|(
name|struct
name|ffec_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|curidx
parameter_list|)
block|{
return|return
operator|(
operator|(
name|curidx
operator|==
name|RX_DESC_COUNT
operator|-
literal|1
operator|)
condition|?
literal|0
else|:
name|curidx
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint32_t
name|next_txidx
parameter_list|(
name|struct
name|ffec_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|curidx
parameter_list|)
block|{
return|return
operator|(
operator|(
name|curidx
operator|==
name|TX_DESC_COUNT
operator|-
literal|1
operator|)
condition|?
literal|0
else|:
name|curidx
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ffec_get1paddr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return;
operator|*
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ffec_miigasket_setup
parameter_list|(
name|struct
name|ffec_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|ifmode
decl_stmt|;
comment|/* 	 * We only need the gasket for MII and RMII connections on certain SoCs. 	 */
switch|switch
condition|(
name|sc
operator|->
name|fectype
operator|&
name|FECTYPE_MASK
condition|)
block|{
case|case
name|FECTYPE_IMX53
case|:
break|break;
default|default:
return|return;
block|}
switch|switch
condition|(
name|sc
operator|->
name|phy_conn_type
condition|)
block|{
case|case
name|MII_CONTYPE_MII
case|:
name|ifmode
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MII_CONTYPE_RMII
case|:
name|ifmode
operator|=
name|FEC_MIIGSK_CFGR_IF_MODE_RMII
expr_stmt|;
break|break;
default|default:
return|return;
block|}
comment|/* 	 * Disable the gasket, configure for either MII or RMII, then enable. 	 */
name|WR2
argument_list|(
name|sc
argument_list|,
name|FEC_MIIGSK_ENR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|RD2
argument_list|(
name|sc
argument_list|,
name|FEC_MIIGSK_ENR
argument_list|)
operator|&
name|FEC_MIIGSK_ENR_READY
condition|)
continue|continue;
name|WR2
argument_list|(
name|sc
argument_list|,
name|FEC_MIIGSK_CFGR
argument_list|,
name|ifmode
argument_list|)
expr_stmt|;
name|WR2
argument_list|(
name|sc
argument_list|,
name|FEC_MIIGSK_ENR
argument_list|,
name|FEC_MIIGSK_ENR_EN
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|RD2
argument_list|(
name|sc
argument_list|,
name|FEC_MIIGSK_ENR
argument_list|)
operator|&
name|FEC_MIIGSK_ENR_READY
operator|)
condition|)
continue|continue;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|ffec_miibus_iowait
parameter_list|(
name|struct
name|ffec_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|timeout
decl_stmt|;
for|for
control|(
name|timeout
operator|=
literal|10000
init|;
name|timeout
operator|!=
literal|0
condition|;
operator|--
name|timeout
control|)
if|if
condition|(
name|RD4
argument_list|(
name|sc
argument_list|,
name|FEC_IER_REG
argument_list|)
operator|&
name|FEC_IER_MII
condition|)
return|return
operator|(
name|true
operator|)
return|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ffec_miibus_readreg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|struct
name|ffec_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|val
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_IER_REG
argument_list|,
name|FEC_IER_MII
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_MMFR_REG
argument_list|,
name|FEC_MMFR_OP_READ
operator||
name|FEC_MMFR_ST_VALUE
operator||
name|FEC_MMFR_TA_VALUE
operator||
operator|(
operator|(
name|phy
operator|<<
name|FEC_MMFR_PA_SHIFT
operator|)
operator|&
name|FEC_MMFR_PA_MASK
operator|)
operator||
operator|(
operator|(
name|reg
operator|<<
name|FEC_MMFR_RA_SHIFT
operator|)
operator|&
name|FEC_MMFR_RA_MASK
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffec_miibus_iowait
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"timeout waiting for mii read\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* All-ones is a symptom of bad mdio. */
block|}
name|val
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|FEC_MMFR_REG
argument_list|)
operator|&
name|FEC_MMFR_DATA_MASK
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ffec_miibus_writereg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|struct
name|ffec_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_IER_REG
argument_list|,
name|FEC_IER_MII
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_MMFR_REG
argument_list|,
name|FEC_MMFR_OP_WRITE
operator||
name|FEC_MMFR_ST_VALUE
operator||
name|FEC_MMFR_TA_VALUE
operator||
operator|(
operator|(
name|phy
operator|<<
name|FEC_MMFR_PA_SHIFT
operator|)
operator|&
name|FEC_MMFR_PA_MASK
operator|)
operator||
operator|(
operator|(
name|reg
operator|<<
name|FEC_MMFR_RA_SHIFT
operator|)
operator|&
name|FEC_MMFR_RA_MASK
operator|)
operator||
operator|(
name|val
operator|&
name|FEC_MMFR_DATA_MASK
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffec_miibus_iowait
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"timeout waiting for mii write\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ffec_miibus_statchg
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ffec_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|uint32_t
name|ecr
decl_stmt|,
name|rcr
decl_stmt|,
name|tcr
decl_stmt|;
comment|/* 	 * Called by the MII bus driver when the PHY establishes link to set the 	 * MAC interface registers. 	 */
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|FFEC_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mii
operator|=
name|sc
operator|->
name|mii_softc
expr_stmt|;
if|if
condition|(
name|mii
operator|->
name|mii_media_status
operator|&
name|IFM_ACTIVE
condition|)
name|sc
operator|->
name|link_is_up
operator|=
name|true
expr_stmt|;
else|else
name|sc
operator|->
name|link_is_up
operator|=
name|false
expr_stmt|;
name|ecr
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|FEC_ECR_REG
argument_list|)
operator|&
operator|~
name|FEC_ECR_SPEED
expr_stmt|;
name|rcr
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|FEC_RCR_REG
argument_list|)
operator|&
operator|~
operator|(
name|FEC_RCR_RMII_10T
operator||
name|FEC_RCR_RMII_MODE
operator||
name|FEC_RCR_RGMII_EN
operator||
name|FEC_RCR_DRT
operator||
name|FEC_RCR_FCE
operator|)
expr_stmt|;
name|tcr
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|FEC_TCR_REG
argument_list|)
operator|&
operator|~
name|FEC_TCR_FDEN
expr_stmt|;
name|rcr
operator||=
name|FEC_RCR_MII_MODE
expr_stmt|;
comment|/* Must always be on even for R[G]MII. */
switch|switch
condition|(
name|sc
operator|->
name|phy_conn_type
condition|)
block|{
case|case
name|MII_CONTYPE_RMII
case|:
name|rcr
operator||=
name|FEC_RCR_RMII_MODE
expr_stmt|;
break|break;
case|case
name|MII_CONTYPE_RGMII
case|:
case|case
name|MII_CONTYPE_RGMII_ID
case|:
case|case
name|MII_CONTYPE_RGMII_RXID
case|:
case|case
name|MII_CONTYPE_RGMII_TXID
case|:
name|rcr
operator||=
name|FEC_RCR_RGMII_EN
expr_stmt|;
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|IFM_SUBTYPE
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
condition|)
block|{
case|case
name|IFM_1000_T
case|:
case|case
name|IFM_1000_SX
case|:
name|ecr
operator||=
name|FEC_ECR_SPEED
expr_stmt|;
break|break;
case|case
name|IFM_100_TX
case|:
comment|/* Not-FEC_ECR_SPEED + not-FEC_RCR_RMII_10T means 100TX */
break|break;
case|case
name|IFM_10_T
case|:
name|rcr
operator||=
name|FEC_RCR_RMII_10T
expr_stmt|;
break|break;
case|case
name|IFM_NONE
case|:
name|sc
operator|->
name|link_is_up
operator|=
name|false
expr_stmt|;
return|return;
default|default:
name|sc
operator|->
name|link_is_up
operator|=
name|false
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unsupported media %u\n"
argument_list|,
name|IFM_SUBTYPE
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|IFM_OPTIONS
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
operator|&
name|IFM_FDX
operator|)
operator|!=
literal|0
condition|)
name|tcr
operator||=
name|FEC_TCR_FDEN
expr_stmt|;
else|else
name|rcr
operator||=
name|FEC_RCR_DRT
expr_stmt|;
if|if
condition|(
operator|(
name|IFM_OPTIONS
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
operator|&
name|IFM_FLOW
operator|)
operator|!=
literal|0
condition|)
name|rcr
operator||=
name|FEC_RCR_FCE
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_RCR_REG
argument_list|,
name|rcr
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_TCR_REG
argument_list|,
name|tcr
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_ECR_REG
argument_list|,
name|ecr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ffec_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|ffec_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|mii
operator|=
name|sc
operator|->
name|mii_softc
expr_stmt|;
name|FFEC_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mii_pollstat
argument_list|(
name|mii
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|mii
operator|->
name|mii_media_active
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|mii
operator|->
name|mii_media_status
expr_stmt|;
name|FFEC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ffec_media_change_locked
parameter_list|(
name|struct
name|ffec_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
name|mii_mediachg
argument_list|(
name|sc
operator|->
name|mii_softc
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ffec_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ffec_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|FFEC_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|ffec_media_change_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|FFEC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ffec_clear_stats
parameter_list|(
name|struct
name|ffec_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|mibc
decl_stmt|;
name|mibc
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|FEC_MIBC_REG
argument_list|)
expr_stmt|;
comment|/* 	 * On newer hardware the statistic regs are cleared by toggling a bit in 	 * the mib control register.  On older hardware the clear procedure is 	 * to disable statistics collection, zero the regs, then re-enable. 	 */
if|if
condition|(
name|sc
operator|->
name|fectype
operator|==
name|FECTYPE_IMX6
operator|||
name|sc
operator|->
name|fectype
operator|==
name|FECTYPE_MVF
condition|)
block|{
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_MIBC_REG
argument_list|,
name|mibc
operator||
name|FEC_MIBC_CLEAR
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_MIBC_REG
argument_list|,
name|mibc
operator|&
operator|~
name|FEC_MIBC_CLEAR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_MIBC_REG
argument_list|,
name|mibc
operator||
name|FEC_MIBC_DIS
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_IEEE_R_DROP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_IEEE_R_MACERR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_RMON_R_CRC_ALIGN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_RMON_R_FRAG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_RMON_R_JAB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_RMON_R_MC_PKT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_RMON_R_OVERSIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_RMON_R_PACKETS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_RMON_R_UNDERSIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_RMON_T_COL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_RMON_T_CRC_ALIGN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_RMON_T_FRAG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_RMON_T_JAB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_RMON_T_MC_PKT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_RMON_T_OVERSIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_RMON_T_PACKETS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_RMON_T_UNDERSIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_MIBC_REG
argument_list|,
name|mibc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ffec_harvest_stats
parameter_list|(
name|struct
name|ffec_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
comment|/* 	 * - FEC_IEEE_R_DROP is "dropped due to invalid start frame delimiter" 	 *   so it's really just another type of input error. 	 * - FEC_IEEE_R_MACERR is "no receive fifo space"; count as input drops. 	 */
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_IPACKETS
argument_list|,
name|RD4
argument_list|(
name|sc
argument_list|,
name|FEC_RMON_R_PACKETS
argument_list|)
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_IMCASTS
argument_list|,
name|RD4
argument_list|(
name|sc
argument_list|,
name|FEC_RMON_R_MC_PKT
argument_list|)
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_IERRORS
argument_list|,
name|RD4
argument_list|(
name|sc
argument_list|,
name|FEC_RMON_R_CRC_ALIGN
argument_list|)
operator|+
name|RD4
argument_list|(
name|sc
argument_list|,
name|FEC_RMON_R_UNDERSIZE
argument_list|)
operator|+
name|RD4
argument_list|(
name|sc
argument_list|,
name|FEC_RMON_R_OVERSIZE
argument_list|)
operator|+
name|RD4
argument_list|(
name|sc
argument_list|,
name|FEC_RMON_R_FRAG
argument_list|)
operator|+
name|RD4
argument_list|(
name|sc
argument_list|,
name|FEC_RMON_R_JAB
argument_list|)
operator|+
name|RD4
argument_list|(
name|sc
argument_list|,
name|FEC_IEEE_R_DROP
argument_list|)
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_IQDROPS
argument_list|,
name|RD4
argument_list|(
name|sc
argument_list|,
name|FEC_IEEE_R_MACERR
argument_list|)
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OPACKETS
argument_list|,
name|RD4
argument_list|(
name|sc
argument_list|,
name|FEC_RMON_T_PACKETS
argument_list|)
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OMCASTS
argument_list|,
name|RD4
argument_list|(
name|sc
argument_list|,
name|FEC_RMON_T_MC_PKT
argument_list|)
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
name|RD4
argument_list|(
name|sc
argument_list|,
name|FEC_RMON_T_CRC_ALIGN
argument_list|)
operator|+
name|RD4
argument_list|(
name|sc
argument_list|,
name|FEC_RMON_T_UNDERSIZE
argument_list|)
operator|+
name|RD4
argument_list|(
name|sc
argument_list|,
name|FEC_RMON_T_OVERSIZE
argument_list|)
operator|+
name|RD4
argument_list|(
name|sc
argument_list|,
name|FEC_RMON_T_FRAG
argument_list|)
operator|+
name|RD4
argument_list|(
name|sc
argument_list|,
name|FEC_RMON_T_JAB
argument_list|)
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_COLLISIONS
argument_list|,
name|RD4
argument_list|(
name|sc
argument_list|,
name|FEC_RMON_T_COL
argument_list|)
argument_list|)
expr_stmt|;
name|ffec_clear_stats
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ffec_tick
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ffec_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|link_was_up
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|FFEC_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
return|return;
comment|/* 	 * Typical tx watchdog.  If this fires it indicates that we enqueued 	 * packets for output and never got a txdone interrupt for them.  Maybe 	 * it's a missed interrupt somehow, just pretend we got one. 	 */
if|if
condition|(
name|sc
operator|->
name|tx_watchdog_count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|--
name|sc
operator|->
name|tx_watchdog_count
operator|==
literal|0
condition|)
block|{
name|ffec_txfinish_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Gather stats from hardware counters. */
name|ffec_harvest_stats
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Check the media status. */
name|link_was_up
operator|=
name|sc
operator|->
name|link_is_up
expr_stmt|;
name|mii_tick
argument_list|(
name|sc
operator|->
name|mii_softc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|link_is_up
operator|&&
operator|!
name|link_was_up
condition|)
name|ffec_txstart_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Schedule another check one second from now. */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|ffec_callout
argument_list|,
name|hz
argument_list|,
name|ffec_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|inline
specifier|static
name|uint32_t
name|ffec_setup_txdesc
parameter_list|(
name|struct
name|ffec_softc
modifier|*
name|sc
parameter_list|,
name|int
name|idx
parameter_list|,
name|bus_addr_t
name|paddr
parameter_list|,
name|uint32_t
name|len
parameter_list|)
block|{
name|uint32_t
name|nidx
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|nidx
operator|=
name|next_txidx
argument_list|(
name|sc
argument_list|,
name|idx
argument_list|)
expr_stmt|;
comment|/* Addr/len 0 means we're clearing the descriptor after xmit done. */
if|if
condition|(
name|paddr
operator|==
literal|0
operator|||
name|len
operator|==
literal|0
condition|)
block|{
name|flags
operator|=
literal|0
expr_stmt|;
operator|--
name|sc
operator|->
name|txcount
expr_stmt|;
block|}
else|else
block|{
name|flags
operator|=
name|FEC_TXDESC_READY
operator||
name|FEC_TXDESC_L
operator||
name|FEC_TXDESC_TC
expr_stmt|;
operator|++
name|sc
operator|->
name|txcount
expr_stmt|;
block|}
if|if
condition|(
name|nidx
operator|==
literal|0
condition|)
name|flags
operator||=
name|FEC_TXDESC_WRAP
expr_stmt|;
comment|/* 	 * The hardware requires 32-bit physical addresses.  We set up the dma 	 * tag to indicate that, so the cast to uint32_t should never lose 	 * significant bits. 	 */
name|sc
operator|->
name|txdesc_ring
index|[
name|idx
index|]
operator|.
name|buf_paddr
operator|=
operator|(
name|uint32_t
operator|)
name|paddr
expr_stmt|;
name|sc
operator|->
name|txdesc_ring
index|[
name|idx
index|]
operator|.
name|flags_len
operator|=
name|flags
operator||
name|len
expr_stmt|;
comment|/* Must be set last! */
return|return
operator|(
name|nidx
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ffec_setup_txbuf
parameter_list|(
name|struct
name|ffec_softc
modifier|*
name|sc
parameter_list|,
name|int
name|idx
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|,
name|nsegs
decl_stmt|;
name|struct
name|bus_dma_segment
name|seg
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|m_defrag
argument_list|(
operator|*
name|mp
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
operator|*
name|mp
operator|=
name|m
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|txbuf_tag
argument_list|,
name|sc
operator|->
name|txbuf_map
index|[
name|idx
index|]
operator|.
name|map
argument_list|,
name|m
argument_list|,
operator|&
name|seg
argument_list|,
operator|&
name|nsegs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|txbuf_tag
argument_list|,
name|sc
operator|->
name|txbuf_map
index|[
name|idx
index|]
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|txbuf_map
index|[
name|idx
index|]
operator|.
name|mbuf
operator|=
name|m
expr_stmt|;
name|ffec_setup_txdesc
argument_list|(
name|sc
argument_list|,
name|idx
argument_list|,
name|seg
operator|.
name|ds_addr
argument_list|,
name|seg
operator|.
name|ds_len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ffec_txstart_locked
parameter_list|(
name|struct
name|ffec_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|enqueued
decl_stmt|;
name|FFEC_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|link_is_up
condition|)
return|return;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_OACTIVE
condition|)
return|return;
name|enqueued
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|txcount
operator|==
operator|(
name|TX_DESC_COUNT
operator|-
literal|1
operator|)
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
break|break;
block|}
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|ffec_setup_txbuf
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tx_idx_head
argument_list|,
operator|&
name|m
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|IFQ_DRV_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx_idx_head
operator|=
name|next_txidx
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tx_idx_head
argument_list|)
expr_stmt|;
operator|++
name|enqueued
expr_stmt|;
block|}
if|if
condition|(
name|enqueued
operator|!=
literal|0
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|txdesc_tag
argument_list|,
name|sc
operator|->
name|txdesc_map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_TDAR_REG
argument_list|,
name|FEC_TDAR_TDAR
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|txdesc_tag
argument_list|,
name|sc
operator|->
name|txdesc_map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx_watchdog_count
operator|=
name|WATCHDOG_TIMEOUT_SECS
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ffec_txstart
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ffec_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|FFEC_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ffec_txstart_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|FFEC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ffec_txfinish_locked
parameter_list|(
name|struct
name|ffec_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ffec_hwdesc
modifier|*
name|desc
decl_stmt|;
name|struct
name|ffec_bufmap
modifier|*
name|bmap
decl_stmt|;
name|boolean_t
name|retired_buffer
decl_stmt|;
name|FFEC_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX Can't set PRE|POST right now, but we need both. */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|txdesc_tag
argument_list|,
name|sc
operator|->
name|txdesc_map
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|txdesc_tag
argument_list|,
name|sc
operator|->
name|txdesc_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
name|retired_buffer
operator|=
name|false
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|tx_idx_tail
operator|!=
name|sc
operator|->
name|tx_idx_head
condition|)
block|{
name|desc
operator|=
operator|&
name|sc
operator|->
name|txdesc_ring
index|[
name|sc
operator|->
name|tx_idx_tail
index|]
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|flags_len
operator|&
name|FEC_TXDESC_READY
condition|)
break|break;
name|retired_buffer
operator|=
name|true
expr_stmt|;
name|bmap
operator|=
operator|&
name|sc
operator|->
name|txbuf_map
index|[
name|sc
operator|->
name|tx_idx_tail
index|]
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|txbuf_tag
argument_list|,
name|bmap
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|txbuf_tag
argument_list|,
name|bmap
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|bmap
operator|->
name|mbuf
argument_list|)
expr_stmt|;
name|bmap
operator|->
name|mbuf
operator|=
name|NULL
expr_stmt|;
name|ffec_setup_txdesc
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tx_idx_tail
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx_idx_tail
operator|=
name|next_txidx
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tx_idx_tail
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we retired any buffers, there will be open tx slots available in 	 * the descriptor ring, go try to start some new output. 	 */
if|if
condition|(
name|retired_buffer
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|ffec_txstart_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* If there are no buffers outstanding, muzzle the watchdog. */
if|if
condition|(
name|sc
operator|->
name|tx_idx_tail
operator|==
name|sc
operator|->
name|tx_idx_head
condition|)
block|{
name|sc
operator|->
name|tx_watchdog_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|inline
specifier|static
name|uint32_t
name|ffec_setup_rxdesc
parameter_list|(
name|struct
name|ffec_softc
modifier|*
name|sc
parameter_list|,
name|int
name|idx
parameter_list|,
name|bus_addr_t
name|paddr
parameter_list|)
block|{
name|uint32_t
name|nidx
decl_stmt|;
comment|/* 	 * The hardware requires 32-bit physical addresses.  We set up the dma 	 * tag to indicate that, so the cast to uint32_t should never lose 	 * significant bits. 	 */
name|nidx
operator|=
name|next_rxidx
argument_list|(
name|sc
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rxdesc_ring
index|[
name|idx
index|]
operator|.
name|buf_paddr
operator|=
operator|(
name|uint32_t
operator|)
name|paddr
expr_stmt|;
name|sc
operator|->
name|rxdesc_ring
index|[
name|idx
index|]
operator|.
name|flags_len
operator|=
name|FEC_RXDESC_EMPTY
operator||
operator|(
operator|(
name|nidx
operator|==
literal|0
operator|)
condition|?
name|FEC_RXDESC_WRAP
else|:
literal|0
operator|)
expr_stmt|;
return|return
operator|(
name|nidx
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ffec_setup_rxbuf
parameter_list|(
name|struct
name|ffec_softc
modifier|*
name|sc
parameter_list|,
name|int
name|idx
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|nsegs
decl_stmt|;
name|struct
name|bus_dma_segment
name|seg
decl_stmt|;
comment|/* 	 * We need to leave at least ETHER_ALIGN bytes free at the beginning of 	 * the buffer to allow the data to be re-aligned after receiving it (by 	 * copying it backwards ETHER_ALIGN bytes in the same buffer).  We also 	 * have to ensure that the beginning of the buffer is aligned to the 	 * hardware's requirements. 	 */
name|m_adj
argument_list|(
name|m
argument_list|,
name|roundup
argument_list|(
name|ETHER_ALIGN
argument_list|,
name|FEC_RXBUF_ALIGN
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|rxbuf_tag
argument_list|,
name|sc
operator|->
name|rxbuf_map
index|[
name|idx
index|]
operator|.
name|map
argument_list|,
name|m
argument_list|,
operator|&
name|seg
argument_list|,
operator|&
name|nsegs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rxbuf_tag
argument_list|,
name|sc
operator|->
name|rxbuf_map
index|[
name|idx
index|]
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rxbuf_map
index|[
name|idx
index|]
operator|.
name|mbuf
operator|=
name|m
expr_stmt|;
name|ffec_setup_rxdesc
argument_list|(
name|sc
argument_list|,
name|idx
argument_list|,
name|seg
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|ffec_alloc_mbufcl
parameter_list|(
name|struct
name|ffec_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|m_getcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_ext
operator|.
name|ext_size
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ffec_rxfinish_onebuf
parameter_list|(
name|struct
name|ffec_softc
modifier|*
name|sc
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|newmbuf
decl_stmt|;
name|struct
name|ffec_bufmap
modifier|*
name|bmap
decl_stmt|;
name|uint8_t
modifier|*
name|dst
decl_stmt|,
modifier|*
name|src
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 *  First try to get a new mbuf to plug into this slot in the rx ring. 	 *  If that fails, drop the current packet and recycle the current 	 *  mbuf, which is still mapped and loaded. 	 */
if|if
condition|(
operator|(
name|newmbuf
operator|=
name|ffec_alloc_mbufcl
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|if_inc_counter
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|IFCOUNTER_IQDROPS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ffec_setup_rxdesc
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|rx_idx
argument_list|,
name|sc
operator|->
name|rxdesc_ring
index|[
name|sc
operator|->
name|rx_idx
index|]
operator|.
name|buf_paddr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 *  Unfortunately, the protocol headers need to be aligned on a 32-bit 	 *  boundary for the upper layers.  The hardware requires receive 	 *  buffers to be 16-byte aligned.  The ethernet header is 14 bytes, 	 *  leaving the protocol header unaligned.  We used m_adj() after 	 *  allocating the buffer to leave empty space at the start of the 	 *  buffer, now we'll use the alignment agnostic bcopy() routine to 	 *  shuffle all the data backwards 2 bytes and adjust m_data. 	 * 	 *  XXX imx6 hardware is able to do this 2-byte alignment by setting the 	 *  SHIFT16 bit in the RACC register.  Older hardware doesn't have that 	 *  feature, but for them could we speed this up by copying just the 	 *  protocol headers into their own small mbuf then chaining the cluster 	 *  to it?  That way we'd only need to copy like 64 bytes or whatever 	 *  the biggest header is, instead of the whole 1530ish-byte frame. 	 */
name|FFEC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bmap
operator|=
operator|&
name|sc
operator|->
name|rxbuf_map
index|[
name|sc
operator|->
name|rx_idx
index|]
expr_stmt|;
name|len
operator|-=
name|ETHER_CRC_LEN
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rxbuf_tag
argument_list|,
name|bmap
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|rxbuf_tag
argument_list|,
name|bmap
operator|->
name|map
argument_list|)
expr_stmt|;
name|m
operator|=
name|bmap
operator|->
name|mbuf
expr_stmt|;
name|bmap
operator|->
name|mbuf
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
name|src
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
name|dst
operator|=
name|src
operator|-
name|ETHER_ALIGN
expr_stmt|;
name|bcopy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|=
name|dst
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_input
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|FFEC_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ffec_setup_rxbuf
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|rx_idx
argument_list|,
name|newmbuf
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"ffec_setup_rxbuf error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* XXX Now what?  We've got a hole in the rx ring. */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ffec_rxfinish_locked
parameter_list|(
name|struct
name|ffec_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ffec_hwdesc
modifier|*
name|desc
decl_stmt|;
name|int
name|len
decl_stmt|;
name|boolean_t
name|produced_empty_buffer
decl_stmt|;
name|FFEC_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX Can't set PRE|POST right now, but we need both. */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rxdesc_tag
argument_list|,
name|sc
operator|->
name|rxdesc_map
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rxdesc_tag
argument_list|,
name|sc
operator|->
name|rxdesc_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|produced_empty_buffer
operator|=
name|false
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|desc
operator|=
operator|&
name|sc
operator|->
name|rxdesc_ring
index|[
name|sc
operator|->
name|rx_idx
index|]
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|flags_len
operator|&
name|FEC_RXDESC_EMPTY
condition|)
break|break;
name|produced_empty_buffer
operator|=
name|true
expr_stmt|;
name|len
operator|=
operator|(
name|desc
operator|->
name|flags_len
operator|&
name|FEC_RXDESC_LEN_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|64
condition|)
block|{
comment|/* 			 * Just recycle the descriptor and continue.           . 			 */
name|ffec_setup_rxdesc
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|rx_idx
argument_list|,
name|sc
operator|->
name|rxdesc_ring
index|[
name|sc
operator|->
name|rx_idx
index|]
operator|.
name|buf_paddr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|desc
operator|->
name|flags_len
operator|&
name|FEC_RXDESC_L
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * The entire frame is not in this buffer.  Impossible. 			 * Recycle the descriptor and continue. 			 * 			 * XXX what's the right way to handle this? Probably we 			 * should stop/init the hardware because this should 			 * just really never happen when we have buffers bigger 			 * than the maximum frame size. 			 */
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"fec_rxfinish: received frame without LAST bit set"
argument_list|)
expr_stmt|;
name|ffec_setup_rxdesc
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|rx_idx
argument_list|,
name|sc
operator|->
name|rxdesc_ring
index|[
name|sc
operator|->
name|rx_idx
index|]
operator|.
name|buf_paddr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|desc
operator|->
name|flags_len
operator|&
name|FEC_RXDESC_ERROR_BITS
condition|)
block|{
comment|/* 			 *  Something went wrong with receiving the frame, we 			 *  don't care what (the hardware has counted the error 			 *  in the stats registers already), we just reuse the 			 *  same mbuf, which is still dma-mapped, by resetting 			 *  the rx descriptor. 			 */
name|ffec_setup_rxdesc
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|rx_idx
argument_list|,
name|sc
operator|->
name|rxdesc_ring
index|[
name|sc
operator|->
name|rx_idx
index|]
operator|.
name|buf_paddr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 *  Normal case: a good frame all in one buffer. 			 */
name|ffec_rxfinish_onebuf
argument_list|(
name|sc
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|rx_idx
operator|=
name|next_rxidx
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|rx_idx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|produced_empty_buffer
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rxdesc_tag
argument_list|,
name|sc
operator|->
name|rxdesc_map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_RDAR_REG
argument_list|,
name|FEC_RDAR_RDAR
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rxdesc_tag
argument_list|,
name|sc
operator|->
name|rxdesc_map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ffec_get_hwaddr
parameter_list|(
name|struct
name|ffec_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
modifier|*
name|hwaddr
parameter_list|)
block|{
name|uint32_t
name|palr
decl_stmt|,
name|paur
decl_stmt|,
name|rnd
decl_stmt|;
comment|/* 	 * Try to recover a MAC address from the running hardware. If there's 	 * something non-zero there, assume the bootloader did the right thing 	 * and just use it. 	 * 	 * Otherwise, set the address to a convenient locally assigned address, 	 * 'bsd' + random 24 low-order bits.  'b' is 0x62, which has the locally 	 * assigned bit set, and the broadcast/multicast bit clear. 	 */
name|palr
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|FEC_PALR_REG
argument_list|)
expr_stmt|;
name|paur
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|FEC_PAUR_REG
argument_list|)
operator|&
name|FEC_PAUR_PADDR2_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|palr
operator||
name|paur
operator|)
operator|!=
literal|0
condition|)
block|{
name|hwaddr
index|[
literal|0
index|]
operator|=
name|palr
operator|>>
literal|24
expr_stmt|;
name|hwaddr
index|[
literal|1
index|]
operator|=
name|palr
operator|>>
literal|16
expr_stmt|;
name|hwaddr
index|[
literal|2
index|]
operator|=
name|palr
operator|>>
literal|8
expr_stmt|;
name|hwaddr
index|[
literal|3
index|]
operator|=
name|palr
operator|>>
literal|0
expr_stmt|;
name|hwaddr
index|[
literal|4
index|]
operator|=
name|paur
operator|>>
literal|24
expr_stmt|;
name|hwaddr
index|[
literal|5
index|]
operator|=
name|paur
operator|>>
literal|16
expr_stmt|;
block|}
else|else
block|{
name|rnd
operator|=
name|arc4random
argument_list|()
operator|&
literal|0x00ffffff
expr_stmt|;
name|hwaddr
index|[
literal|0
index|]
operator|=
literal|'b'
expr_stmt|;
name|hwaddr
index|[
literal|1
index|]
operator|=
literal|'s'
expr_stmt|;
name|hwaddr
index|[
literal|2
index|]
operator|=
literal|'d'
expr_stmt|;
name|hwaddr
index|[
literal|3
index|]
operator|=
name|rnd
operator|>>
literal|16
expr_stmt|;
name|hwaddr
index|[
literal|4
index|]
operator|=
name|rnd
operator|>>
literal|8
expr_stmt|;
name|hwaddr
index|[
literal|5
index|]
operator|=
name|rnd
operator|>>
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"MAC address %02x:%02x:%02x:%02x:%02x:%02x:\n"
argument_list|,
name|hwaddr
index|[
literal|0
index|]
argument_list|,
name|hwaddr
index|[
literal|1
index|]
argument_list|,
name|hwaddr
index|[
literal|2
index|]
argument_list|,
name|hwaddr
index|[
literal|3
index|]
argument_list|,
name|hwaddr
index|[
literal|4
index|]
argument_list|,
name|hwaddr
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ffec_setup_rxfilter
parameter_list|(
name|struct
name|ffec_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|uint8_t
modifier|*
name|eaddr
decl_stmt|;
name|uint32_t
name|crc
decl_stmt|;
name|uint64_t
name|ghash
decl_stmt|,
name|ihash
decl_stmt|;
name|FFEC_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
comment|/* 	 * Set the multicast (group) filter hash. 	 */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
operator|)
condition|)
name|ghash
operator|=
literal|0xffffffffffffffffLLU
expr_stmt|;
else|else
block|{
name|ghash
operator|=
literal|0
expr_stmt|;
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&sc->ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
comment|/* 6 bits from MSB in LE CRC32 are used for hash. */
name|crc
operator|=
name|ether_crc32_le
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|ghash
operator||=
literal|1LLU
operator|<<
operator|(
operator|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|crc
operator|)
index|[
literal|3
index|]
operator|>>
literal|2
operator|)
expr_stmt|;
block|}
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_GAUR_REG
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|ghash
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_GALR_REG
argument_list|,
operator|(
name|uint32_t
operator|)
name|ghash
argument_list|)
expr_stmt|;
comment|/* 	 * Set the individual address filter hash. 	 * 	 * XXX Is 0 the right value when promiscuous is off?  This hw feature 	 * seems to support the concept of MAC address aliases, does such a 	 * thing even exist? 	 */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
condition|)
name|ihash
operator|=
literal|0xffffffffffffffffLLU
expr_stmt|;
else|else
block|{
name|ihash
operator|=
literal|0
expr_stmt|;
block|}
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_IAUR_REG
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|ihash
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_IALR_REG
argument_list|,
operator|(
name|uint32_t
operator|)
name|ihash
argument_list|)
expr_stmt|;
comment|/* 	 * Set the primary address. 	 */
name|eaddr
operator|=
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_PALR_REG
argument_list|,
operator|(
name|eaddr
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|eaddr
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|eaddr
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
name|eaddr
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_PAUR_REG
argument_list|,
operator|(
name|eaddr
index|[
literal|4
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|eaddr
index|[
literal|5
index|]
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ffec_stop_locked
parameter_list|(
name|struct
name|ffec_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ffec_hwdesc
modifier|*
name|desc
decl_stmt|;
name|struct
name|ffec_bufmap
modifier|*
name|bmap
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|FFEC_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
name|sc
operator|->
name|tx_watchdog_count
operator|=
literal|0
expr_stmt|;
comment|/*  	 * Stop the hardware, mask all interrupts, and clear all current 	 * interrupt status bits. 	 */
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_ECR_REG
argument_list|,
name|RD4
argument_list|(
name|sc
argument_list|,
name|FEC_ECR_REG
argument_list|)
operator|&
operator|~
name|FEC_ECR_ETHEREN
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_IEM_REG
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_IER_REG
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* 	 * Stop the media-check callout.  Do not use callout_drain() because 	 * we're holding a mutex the callout acquires, and if it's currently 	 * waiting to acquire it, we'd deadlock.  If it is waiting now, the 	 * ffec_tick() routine will return without doing anything when it sees 	 * that IFF_DRV_RUNNING is not set, so avoiding callout_drain() is safe. 	 */
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|ffec_callout
argument_list|)
expr_stmt|;
comment|/* 	 * Discard all untransmitted buffers.  Each buffer is simply freed; 	 * it's as if the bits were transmitted and then lost on the wire. 	 * 	 * XXX Is this right?  Or should we use IFQ_DRV_PREPEND() to put them 	 * back on the queue for when we get restarted later? 	 */
name|idx
operator|=
name|sc
operator|->
name|tx_idx_tail
expr_stmt|;
while|while
condition|(
name|idx
operator|!=
name|sc
operator|->
name|tx_idx_head
condition|)
block|{
name|desc
operator|=
operator|&
name|sc
operator|->
name|txdesc_ring
index|[
name|idx
index|]
expr_stmt|;
name|bmap
operator|=
operator|&
name|sc
operator|->
name|txbuf_map
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|buf_paddr
operator|!=
literal|0
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|txbuf_tag
argument_list|,
name|bmap
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|bmap
operator|->
name|mbuf
argument_list|)
expr_stmt|;
name|bmap
operator|->
name|mbuf
operator|=
name|NULL
expr_stmt|;
name|ffec_setup_txdesc
argument_list|(
name|sc
argument_list|,
name|idx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|idx
operator|=
name|next_txidx
argument_list|(
name|sc
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Discard all unprocessed receive buffers.  This amounts to just 	 * pretending that nothing ever got received into them.  We reuse the 	 * mbuf already mapped for each desc, simply turning the EMPTY flags 	 * back on so they'll get reused when we start up again. 	 */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|RX_DESC_COUNT
condition|;
operator|++
name|idx
control|)
block|{
name|desc
operator|=
operator|&
name|sc
operator|->
name|rxdesc_ring
index|[
name|idx
index|]
expr_stmt|;
name|ffec_setup_rxdesc
argument_list|(
name|sc
argument_list|,
name|idx
argument_list|,
name|desc
operator|->
name|buf_paddr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ffec_init_locked
parameter_list|(
name|struct
name|ffec_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|uint32_t
name|maxbuf
decl_stmt|,
name|maxfl
decl_stmt|,
name|regval
decl_stmt|;
name|FFEC_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * The hardware has a limit of 0x7ff as the max frame length (see 	 * comments for MRBR below), and we use mbuf clusters as receive 	 * buffers, and we currently are designed to receive an entire frame 	 * into a single buffer. 	 * 	 * We start with a MCLBYTES-sized cluster, but we have to offset into 	 * the buffer by ETHER_ALIGN to make room for post-receive re-alignment, 	 * and then that value has to be rounded up to the hardware's DMA 	 * alignment requirements, so all in all our buffer is that much smaller 	 * than MCLBYTES. 	 * 	 * The resulting value is used as the frame truncation length and the 	 * max buffer receive buffer size for now.  It'll become more complex 	 * when we support jumbo frames and receiving fragments of them into 	 * separate buffers. 	 */
name|maxbuf
operator|=
name|MCLBYTES
operator|-
name|roundup
argument_list|(
name|ETHER_ALIGN
argument_list|,
name|FEC_RXBUF_ALIGN
argument_list|)
expr_stmt|;
name|maxfl
operator|=
name|min
argument_list|(
name|maxbuf
argument_list|,
literal|0x7ff
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
return|return;
comment|/* Mask all interrupts and clear all current interrupt status bits. */
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_IEM_REG
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_IER_REG
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* 	 * Go set up palr/puar, galr/gaur, ialr/iaur. 	 */
name|ffec_setup_rxfilter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * TFWR - Transmit FIFO watermark register. 	 * 	 * Set the transmit fifo watermark register to "store and forward" mode 	 * and also set a threshold of 128 bytes in the fifo before transmission 	 * of a frame begins (to avoid dma underruns).  Recent FEC hardware 	 * supports STRFWD and when that bit is set, the watermark level in the 	 * low bits is ignored.  Older hardware doesn't have STRFWD, but writing 	 * to that bit is innocuous, and the TWFR bits get used instead. 	 */
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_TFWR_REG
argument_list|,
name|FEC_TFWR_STRFWD
operator||
name|FEC_TFWR_TWFR_128BYTE
argument_list|)
expr_stmt|;
comment|/* RCR - Receive control register. 	 * 	 * Set max frame length + clean out anything left from u-boot. 	 */
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_RCR_REG
argument_list|,
operator|(
name|maxfl
operator|<<
name|FEC_RCR_MAX_FL_SHIFT
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * TCR - Transmit control register. 	 * 	 * Clean out anything left from u-boot.  Any necessary values are set in 	 * ffec_miibus_statchg() based on the media type. 	 */
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_TCR_REG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * OPD - Opcode/pause duration. 	 * 	 * XXX These magic numbers come from u-boot. 	 */
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_OPD_REG
argument_list|,
literal|0x00010020
argument_list|)
expr_stmt|;
comment|/* 	 * FRSR - Fifo receive start register. 	 * 	 * This register does not exist on imx6, it is present on earlier 	 * hardware. The u-boot code sets this to a non-default value that's 32 	 * bytes larger than the default, with no clue as to why.  The default 	 * value should work fine, so there's no code to init it here. 	 */
comment|/* 	 *  MRBR - Max RX buffer size. 	 * 	 *  Note: For hardware prior to imx6 this value cannot exceed 0x07ff, 	 *  but the datasheet says no such thing for imx6.  On the imx6, setting 	 *  this to 2K without setting EN1588 resulted in a crazy runaway 	 *  receive loop in the hardware, where every rx descriptor in the ring 	 *  had its EMPTY flag cleared, no completion or error flags set, and a 	 *  length of zero.  I think maybe you can only exceed it when EN1588 is 	 *  set, like maybe that's what enables jumbo frames, because in general 	 *  the EN1588 flag seems to be the "enable new stuff" vs. "be legacy- 	 *  compatible" flag. 	 */
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_MRBR_REG
argument_list|,
name|maxfl
operator|<<
name|FEC_MRBR_R_BUF_SIZE_SHIFT
argument_list|)
expr_stmt|;
comment|/* 	 * FTRL - Frame truncation length. 	 * 	 * Must be greater than or equal to the value set in FEC_RCR_MAXFL. 	 */
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_FTRL_REG
argument_list|,
name|maxfl
argument_list|)
expr_stmt|;
comment|/* 	 * RDSR / TDSR descriptor ring pointers. 	 * 	 * When we turn on ECR_ETHEREN at the end, the hardware zeroes its 	 * internal current descriptor index values for both rings, so we zero 	 * our index values as well. 	 */
name|sc
operator|->
name|rx_idx
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|tx_idx_head
operator|=
name|sc
operator|->
name|tx_idx_tail
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|txcount
operator|=
literal|0
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_RDSR_REG
argument_list|,
name|sc
operator|->
name|rxdesc_ring_paddr
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_TDSR_REG
argument_list|,
name|sc
operator|->
name|txdesc_ring_paddr
argument_list|)
expr_stmt|;
comment|/* 	 * EIM - interrupt mask register. 	 * 	 * We always enable the same set of interrupts while running; unlike 	 * some drivers there's no need to change the mask on the fly depending 	 * on what operations are in progress. 	 */
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_IEM_REG
argument_list|,
name|FEC_IER_TXF
operator||
name|FEC_IER_RXF
operator||
name|FEC_IER_EBERR
argument_list|)
expr_stmt|;
comment|/* 	 * MIBC - MIB control (hardware stats); clear all statistics regs, then 	 * enable collection of statistics. 	 */
name|regval
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|FEC_MIBC_REG
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_MIBC_REG
argument_list|,
name|regval
operator||
name|FEC_MIBC_DIS
argument_list|)
expr_stmt|;
name|ffec_clear_stats
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_MIBC_REG
argument_list|,
name|regval
operator|&
operator|~
name|FEC_MIBC_DIS
argument_list|)
expr_stmt|;
comment|/* 	 * ECR - Ethernet control register. 	 * 	 * This must happen after all the other config registers are set.  If 	 * we're running on little-endian hardware, also set the flag for byte- 	 * swapping descriptor ring entries.  This flag doesn't exist on older 	 * hardware, but it can be safely set -- the bit position it occupies 	 * was unused. 	 */
name|regval
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|FEC_ECR_REG
argument_list|)
expr_stmt|;
if|#
directive|if
name|_BYTE_ORDER
operator|==
name|_LITTLE_ENDIAN
name|regval
operator||=
name|FEC_ECR_DBSWP
expr_stmt|;
endif|#
directive|endif
name|regval
operator||=
name|FEC_ECR_ETHEREN
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_ECR_REG
argument_list|,
name|regval
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
comment|/* 	* Call mii_mediachg() which will call back into ffec_miibus_statchg() to 	* set up the remaining config registers based on the current media. 	*/
name|mii_mediachg
argument_list|(
name|sc
operator|->
name|mii_softc
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|ffec_callout
argument_list|,
name|hz
argument_list|,
name|ffec_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Tell the hardware that receive buffers are available.  They were made 	 * available in ffec_attach() or ffec_stop(). 	 */
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_RDAR_REG
argument_list|,
name|FEC_RDAR_RDAR
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ffec_init
parameter_list|(
name|void
modifier|*
name|if_softc
parameter_list|)
block|{
name|struct
name|ffec_softc
modifier|*
name|sc
init|=
name|if_softc
decl_stmt|;
name|FFEC_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ffec_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|FFEC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ffec_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ffec_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|ier
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|FFEC_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ier
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|FEC_IER_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|ier
operator|&
name|FEC_IER_TXF
condition|)
block|{
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_IER_REG
argument_list|,
name|FEC_IER_TXF
argument_list|)
expr_stmt|;
name|ffec_txfinish_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ier
operator|&
name|FEC_IER_RXF
condition|)
block|{
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_IER_REG
argument_list|,
name|FEC_IER_RXF
argument_list|)
expr_stmt|;
name|ffec_rxfinish_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We actually don't care about most errors, because the hardware copes 	 * with them just fine, discarding the incoming bad frame, or forcing a 	 * bad CRC onto an outgoing bad frame, and counting the errors in the 	 * stats registers.  The one that really matters is EBERR (DMA bus 	 * error) because the hardware automatically clears ECR[ETHEREN] and we 	 * have to restart it here.  It should never happen. 	 */
if|if
condition|(
name|ier
operator|&
name|FEC_IER_EBERR
condition|)
block|{
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_IER_REG
argument_list|,
name|FEC_IER_EBERR
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Ethernet DMA error, restarting controller.\n"
argument_list|)
expr_stmt|;
name|ffec_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ffec_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|FFEC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ffec_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|ffec_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
name|int
name|mask
decl_stmt|,
name|error
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|ifr
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
name|FFEC_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|^
name|sc
operator|->
name|if_flags
operator|)
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
condition|)
name|ffec_setup_rxfilter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|sc
operator|->
name|is_detaching
condition|)
name|ffec_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|ffec_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|FFEC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|FFEC_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ffec_setup_rxfilter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|FFEC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|mii
operator|=
name|sc
operator|->
name|mii_softc
expr_stmt|;
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|mii
operator|->
name|mii_media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
name|mask
operator|=
name|ifp
operator|->
name|if_capenable
operator|^
name|ifr
operator|->
name|ifr_reqcap
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_MTU
condition|)
block|{
comment|/* No work to do except acknowledge the change took. */
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_MTU
expr_stmt|;
block|}
break|break;
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ffec_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ffec_softc
modifier|*
name|sc
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|int
name|idx
decl_stmt|;
comment|/* 	 * NB: This function can be called internally to unwind a failure to 	 * attach. Make sure a resource got allocated/created before destroying. 	 */
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|is_attached
condition|)
block|{
name|FFEC_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|is_detaching
operator|=
name|true
expr_stmt|;
name|ffec_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|FFEC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|ffec_callout
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
block|}
comment|/* XXX no miibus detach? */
comment|/* Clean up RX DMA resources and free mbufs. */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|RX_DESC_COUNT
condition|;
operator|++
name|idx
control|)
block|{
if|if
condition|(
operator|(
name|map
operator|=
name|sc
operator|->
name|rxbuf_map
index|[
name|idx
index|]
operator|.
name|map
operator|)
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|rxbuf_tag
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|rxbuf_tag
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|sc
operator|->
name|rxbuf_map
index|[
name|idx
index|]
operator|.
name|mbuf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|rxbuf_tag
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|rxbuf_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rxdesc_map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|rxdesc_tag
argument_list|,
name|sc
operator|->
name|rxdesc_map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|rxdesc_tag
argument_list|,
name|sc
operator|->
name|rxdesc_map
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|rxdesc_tag
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|rxdesc_tag
argument_list|)
expr_stmt|;
comment|/* Clean up TX DMA resources. */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|TX_DESC_COUNT
condition|;
operator|++
name|idx
control|)
block|{
if|if
condition|(
operator|(
name|map
operator|=
name|sc
operator|->
name|txbuf_map
index|[
name|idx
index|]
operator|.
name|map
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* TX maps are already unloaded. */
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|txbuf_tag
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|txbuf_tag
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|txbuf_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|txdesc_map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|txdesc_tag
argument_list|,
name|sc
operator|->
name|txdesc_map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|txdesc_tag
argument_list|,
name|sc
operator|->
name|txdesc_map
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|txdesc_tag
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|txdesc_tag
argument_list|)
expr_stmt|;
comment|/* Release bus resources. */
if|if
condition|(
name|sc
operator|->
name|intr_cookie
condition|)
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|sc
operator|->
name|intr_cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq_res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem_res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|FFEC_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ffec_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ffec_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|NULL
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|void
modifier|*
name|dummy
decl_stmt|;
name|phandle_t
name|ofw_node
decl_stmt|;
name|int
name|error
decl_stmt|,
name|phynum
decl_stmt|,
name|rid
decl_stmt|;
name|uint8_t
name|eaddr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|uint32_t
name|idx
decl_stmt|,
name|mscr
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|FFEC_LOCK_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * There are differences in the implementation and features of the FEC 	 * hardware on different SoCs, so figure out what type we are. 	 */
name|sc
operator|->
name|fectype
operator|=
name|ofw_bus_search_compatible
argument_list|(
name|dev
argument_list|,
name|compat_data
argument_list|)
operator|->
name|ocd_data
expr_stmt|;
comment|/* 	 * We have to be told what kind of electrical connection exists between 	 * the MAC and PHY or we can't operate correctly. 	 */
if|if
condition|(
operator|(
name|ofw_node
operator|=
name|ofw_bus_get_node
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Impossible: Can't find ofw bus node\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|sc
operator|->
name|phy_conn_type
operator|=
name|mii_fdt_get_contype
argument_list|(
name|ofw_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|phy_conn_type
operator|==
name|MII_CONTYPE_UNKNOWN
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"No valid 'phy-mode' "
literal|"property found in FDT data for device.\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOATTR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|ffec_callout
argument_list|,
operator|&
name|sc
operator|->
name|mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Allocate bus resources for accessing the hardware. */
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|mem_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate memory resources.\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|irq_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate interrupt resources.\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Set up TX descriptor ring, descriptors, and dma maps. 	 */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
comment|/* Parent tag. */
name|FEC_DESC_RING_ALIGN
argument_list|,
literal|0
argument_list|,
comment|/* alignment, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|TX_DESC_SIZE
argument_list|,
literal|1
argument_list|,
comment|/* maxsize, nsegments */
name|TX_DESC_SIZE
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|txdesc_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"could not create TX ring DMA tag.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|txdesc_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|txdesc_ring
argument_list|,
name|BUS_DMA_COHERENT
operator||
name|BUS_DMA_WAITOK
operator||
name|BUS_DMA_ZERO
argument_list|,
operator|&
name|sc
operator|->
name|txdesc_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"could not allocate TX descriptor ring.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|txdesc_tag
argument_list|,
name|sc
operator|->
name|txdesc_map
argument_list|,
name|sc
operator|->
name|txdesc_ring
argument_list|,
name|TX_DESC_SIZE
argument_list|,
name|ffec_get1paddr
argument_list|,
operator|&
name|sc
operator|->
name|txdesc_ring_paddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"could not load TX descriptor ring map.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
comment|/* Parent tag. */
name|FEC_TXBUF_ALIGN
argument_list|,
literal|0
argument_list|,
comment|/* alignment, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|MCLBYTES
argument_list|,
literal|1
argument_list|,
comment|/* maxsize, nsegments */
name|MCLBYTES
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|txbuf_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"could not create TX ring DMA tag.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|TX_DESC_COUNT
condition|;
operator|++
name|idx
control|)
block|{
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|txbuf_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|txbuf_map
index|[
name|idx
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"could not create TX buffer DMA map.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ffec_setup_txdesc
argument_list|(
name|sc
argument_list|,
name|idx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set up RX descriptor ring, descriptors, dma maps, and mbufs. 	 */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
comment|/* Parent tag. */
name|FEC_DESC_RING_ALIGN
argument_list|,
literal|0
argument_list|,
comment|/* alignment, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|RX_DESC_SIZE
argument_list|,
literal|1
argument_list|,
comment|/* maxsize, nsegments */
name|RX_DESC_SIZE
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|rxdesc_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"could not create RX ring DMA tag.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|rxdesc_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|rxdesc_ring
argument_list|,
name|BUS_DMA_COHERENT
operator||
name|BUS_DMA_WAITOK
operator||
name|BUS_DMA_ZERO
argument_list|,
operator|&
name|sc
operator|->
name|rxdesc_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"could not allocate RX descriptor ring.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|rxdesc_tag
argument_list|,
name|sc
operator|->
name|rxdesc_map
argument_list|,
name|sc
operator|->
name|rxdesc_ring
argument_list|,
name|RX_DESC_SIZE
argument_list|,
name|ffec_get1paddr
argument_list|,
operator|&
name|sc
operator|->
name|rxdesc_ring_paddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"could not load RX descriptor ring map.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
comment|/* Parent tag. */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* alignment, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|MCLBYTES
argument_list|,
literal|1
argument_list|,
comment|/* maxsize, nsegments */
name|MCLBYTES
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|rxbuf_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"could not create RX buf DMA tag.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|RX_DESC_COUNT
condition|;
operator|++
name|idx
control|)
block|{
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|rxbuf_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|rxbuf_map
index|[
name|idx
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"could not create RX buffer DMA map.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|m
operator|=
name|ffec_alloc_mbufcl
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not alloc mbuf\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|ffec_setup_rxbuf
argument_list|(
name|sc
argument_list|,
name|idx
argument_list|,
name|m
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"could not create new RX buffer.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* Try to get the MAC address from the hardware before resetting it. */
name|ffec_get_hwaddr
argument_list|(
name|sc
argument_list|,
name|eaddr
argument_list|)
expr_stmt|;
comment|/* Reset the hardware.  Disables all interrupts. */
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_ECR_REG
argument_list|,
name|FEC_ECR_RESET
argument_list|)
expr_stmt|;
comment|/* Setup interrupt handler. */
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|ffec_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|intr_cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not setup interrupt handler.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Set up the PHY control register. 	 * 	 * Speed formula for ENET is md_clock = mac_clock / ((N + 1) * 2). 	 * Speed formula for FEC is  md_clock = mac_clock / (N * 2) 	 * 	 * XXX - Revisit this... 	 * 	 * For a Wandboard imx6 (ENET) I was originally using 4, but the uboot 	 * code uses 10.  Both values seem to work, but I suspect many modern 	 * PHY parts can do mdio at speeds far above the standard 2.5 MHz. 	 * 	 * Different imx manuals use confusingly different terminology (things 	 * like "system clock" and "internal module clock") with examples that 	 * use frequencies that have nothing to do with ethernet, giving the 	 * vague impression that maybe the clock in question is the periphclock 	 * or something.  In fact, on an imx53 development board (FEC), 	 * measuring the mdio clock at the pin on the PHY and playing with 	 * various divisors showed that the root speed was 66 MHz (clk_ipg_root 	 * aka periphclock) and 13 was the right divisor. 	 * 	 * All in all, it seems likely that 13 is a safe divisor for now, 	 * because if we really do need to base it on the peripheral clock 	 * speed, then we need a platform-independant get-clock-freq API. 	 */
name|mscr
operator|=
literal|13
operator|<<
name|FEC_MSCR_MII_SPEED_SHIFT
expr_stmt|;
if|if
condition|(
name|OF_hasprop
argument_list|(
name|ofw_node
argument_list|,
literal|"phy-disable-preamble"
argument_list|)
condition|)
block|{
name|mscr
operator||=
name|FEC_MSCR_DIS_PRE
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"PHY preamble disabled\n"
argument_list|)
expr_stmt|;
block|}
name|WR4
argument_list|(
name|sc
argument_list|,
name|FEC_MSCR_REG
argument_list|,
name|mscr
argument_list|)
expr_stmt|;
comment|/* Set up the ethernet interface. */
name|sc
operator|->
name|ifp
operator|=
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator|=
name|IFCAP_VLAN_MTU
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|ffec_txstart
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|ffec_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|ffec_init
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|TX_DESC_COUNT
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|TX_DESC_COUNT
operator|-
literal|1
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX The hardware keeps stats we could use for these. */
block|ifp->if_linkmib =&sc->mibdata; 	ifp->if_linkmiblen = sizeof(sc->mibdata);
endif|#
directive|endif
comment|/* Set up the miigasket hardware (if any). */
name|ffec_miigasket_setup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Attach the mii driver. */
if|if
condition|(
name|fdt_get_phyaddr
argument_list|(
name|ofw_node
argument_list|,
name|dev
argument_list|,
operator|&
name|phynum
argument_list|,
operator|&
name|dummy
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|phynum
operator|=
name|MII_PHY_ANY
expr_stmt|;
block|}
name|error
operator|=
name|mii_attach
argument_list|(
name|dev
argument_list|,
operator|&
name|sc
operator|->
name|miibus
argument_list|,
name|ifp
argument_list|,
name|ffec_media_change
argument_list|,
name|ffec_media_status
argument_list|,
name|BMSR_DEFCAPMASK
argument_list|,
name|phynum
argument_list|,
name|MII_OFFSET_ANY
argument_list|,
operator|(
name|sc
operator|->
name|fectype
operator|&
name|FECTYPE_MVF
operator|)
condition|?
name|MIIF_FORCEANEG
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"PHY attach failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|sc
operator|->
name|mii_softc
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|miibus
argument_list|)
expr_stmt|;
comment|/* All ready to run, attach the ethernet interface. */
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|eaddr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|is_attached
operator|=
name|true
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|out
label|:
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|ffec_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ffec_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|uintptr_t
name|fectype
decl_stmt|;
if|if
condition|(
operator|!
name|ofw_bus_status_okay
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|fectype
operator|=
name|ofw_bus_search_compatible
argument_list|(
name|dev
argument_list|,
name|compat_data
argument_list|)
operator|->
name|ocd_data
expr_stmt|;
if|if
condition|(
name|fectype
operator|==
name|FECTYPE_NONE
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
operator|(
name|fectype
operator|&
name|FECFLAG_GBE
operator|)
condition|?
literal|"Freescale Gigabit Ethernet Controller"
else|:
literal|"Freescale Fast Ethernet Controller"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|ffec_methods
index|[]
init|=
block|{
comment|/* Device interface. */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ffec_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ffec_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ffec_detach
argument_list|)
block|,
comment|/* 	DEVMETHOD(device_shutdown,	ffec_shutdown), 	DEVMETHOD(device_suspend,	ffec_suspend), 	DEVMETHOD(device_resume,	ffec_resume), */
comment|/* MII interface. */
name|DEVMETHOD
argument_list|(
name|miibus_readreg
argument_list|,
name|ffec_miibus_readreg
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_writereg
argument_list|,
name|ffec_miibus_writereg
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_statchg
argument_list|,
name|ffec_miibus_statchg
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ffec_driver
init|=
block|{
literal|"ffec"
block|,
name|ffec_methods
block|,
expr|sizeof
operator|(
expr|struct
name|ffec_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|ffec_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ffec
argument_list|,
name|simplebus
argument_list|,
name|ffec_driver
argument_list|,
name|ffec_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|miibus
argument_list|,
name|ffec
argument_list|,
name|miibus_driver
argument_list|,
name|miibus_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ffec
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ffec
argument_list|,
name|miibus
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

