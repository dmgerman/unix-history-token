begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *   BSD LICENSE  *  *   Copyright(c) 2017 Cavium, Inc.. All rights reserved.  *   All rights reserved.  *  *   Redistribution and use in source and binary forms, with or without  *   modification, are permitted provided that the following conditions  *   are met:  *  *     * Redistributions of source code must retain the above copyright  *       notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above copyright  *       notice, this list of conditions and the following disclaimer in  *       the documentation and/or other materials provided with the  *       distribution.  *     * Neither the name of Cavium, Inc. nor the names of its  *       contributors may be used to endorse or promote products derived  *       from this software without specific prior written permission.  *  *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  *   OWNER(S) OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"lio_bsd.h"
end_include

begin_include
include|#
directive|include
file|"lio_common.h"
end_include

begin_include
include|#
directive|include
file|"lio_droq.h"
end_include

begin_include
include|#
directive|include
file|"lio_iq.h"
end_include

begin_include
include|#
directive|include
file|"lio_response_manager.h"
end_include

begin_include
include|#
directive|include
file|"lio_device.h"
end_include

begin_include
include|#
directive|include
file|"lio_network.h"
end_include

begin_include
include|#
directive|include
file|"lio_ctrl.h"
end_include

begin_include
include|#
directive|include
file|"cn23xx_pf_device.h"
end_include

begin_include
include|#
directive|include
file|"lio_image.h"
end_include

begin_include
include|#
directive|include
file|"lio_ioctl.h"
end_include

begin_include
include|#
directive|include
file|"lio_main.h"
end_include

begin_include
include|#
directive|include
file|"lio_rxtx.h"
end_include

begin_function_decl
specifier|static
name|int
name|lio_set_rx_csum
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|uint32_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lio_set_tso4
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lio_set_tso6
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lio_set_lro
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lio_change_mtu
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|new_mtu
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lio_set_mcast_list
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|enum
name|lio_ifflags
name|lio_get_new_flags
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
specifier|inline
name|bool
name|lio_is_valid_ether_addr
parameter_list|(
specifier|const
name|uint8_t
modifier|*
name|addr
parameter_list|)
block|{
return|return
operator|(
operator|!
operator|(
literal|0x01
operator|&
name|addr
index|[
literal|0
index|]
operator|)
operator|&&
operator|!
operator|(
operator|(
name|addr
index|[
literal|0
index|]
operator|+
name|addr
index|[
literal|1
index|]
operator|+
name|addr
index|[
literal|2
index|]
operator|+
name|addr
index|[
literal|3
index|]
operator|+
name|addr
index|[
literal|4
index|]
operator|+
name|addr
index|[
literal|5
index|]
operator|)
operator|==
literal|0x00
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lio_change_dev_flags
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|lio_ctrl_pkt
name|nctrl
decl_stmt|;
name|struct
name|lio
modifier|*
name|lio
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|octeon_device
modifier|*
name|oct
init|=
name|lio
operator|->
name|oct_dev
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|nctrl
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lio_ctrl_pkt
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create a ctrl pkt command to be sent to core app. */
name|nctrl
operator|.
name|ncmd
operator|.
name|cmd64
operator|=
literal|0
expr_stmt|;
name|nctrl
operator|.
name|ncmd
operator|.
name|s
operator|.
name|cmd
operator|=
name|LIO_CMD_CHANGE_DEVFLAGS
expr_stmt|;
name|nctrl
operator|.
name|ncmd
operator|.
name|s
operator|.
name|param1
operator|=
name|lio_get_new_flags
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|nctrl
operator|.
name|iq_no
operator|=
name|lio
operator|->
name|linfo
operator|.
name|txpciq
index|[
literal|0
index|]
operator|.
name|s
operator|.
name|q_no
expr_stmt|;
name|nctrl
operator|.
name|lio
operator|=
name|lio
expr_stmt|;
name|nctrl
operator|.
name|cb_fn
operator|=
name|lio_ctrl_cmd_completion
expr_stmt|;
name|ret
operator|=
name|lio_send_ctrl_pkt
argument_list|(
name|oct
argument_list|,
operator|&
name|nctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Failed to change flags ret %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * lio_ioctl : User calls this routine for configuring  * the interface.  *  * return 0 on success, positive on failure  */
end_comment

begin_function
name|int
name|lio_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|lio
modifier|*
name|lio
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifrequest
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
name|lio_dev_dbg
argument_list|(
name|lio
operator|->
name|oct_dev
argument_list|,
literal|"ioctl: SIOCSIFADDR\n"
argument_list|)
expr_stmt|;
name|if_setflagbits
argument_list|(
name|ifp
argument_list|,
name|IFF_UP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMTU
case|:
name|lio_dev_dbg
argument_list|(
name|lio
operator|->
name|oct_dev
argument_list|,
literal|"ioctl: SIOCSIFMTU\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|lio_change_mtu
argument_list|(
name|ifp
argument_list|,
name|ifrequest
operator|->
name|ifr_mtu
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|lio_dev_dbg
argument_list|(
name|lio
operator|->
name|oct_dev
argument_list|,
literal|"ioctl: SIOCSIFFLAGS\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|if_getflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
if|if
condition|(
operator|(
name|if_getflags
argument_list|(
name|ifp
argument_list|)
operator|^
name|lio
operator|->
name|if_flags
operator|)
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
condition|)
name|error
operator|=
name|lio_change_dev_flags
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|lio
operator|->
name|ifstate
argument_list|)
operator|&
name|LIO_IFSTATE_DETACH
operator|)
condition|)
name|lio_open
argument_list|(
name|lio
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
condition|)
name|lio_stop
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
name|lio
operator|->
name|if_flags
operator|=
name|if_getflags
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
name|lio_dev_dbg
argument_list|(
name|lio
operator|->
name|oct_dev
argument_list|,
literal|"ioctl: SIOCADDMULTI\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
condition|)
name|error
operator|=
name|lio_set_mcast_list
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCDELMULTI
case|:
name|lio_dev_dbg
argument_list|(
name|lio
operator|->
name|oct_dev
argument_list|,
literal|"ioctl: SIOCSIFMULTI\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMEDIA
case|:
name|lio_dev_dbg
argument_list|(
name|lio
operator|->
name|oct_dev
argument_list|,
literal|"ioctl: SIOCSIFMEDIA\n"
argument_list|)
expr_stmt|;
case|case
name|SIOCGIFMEDIA
case|:
name|lio_dev_dbg
argument_list|(
name|lio
operator|->
name|oct_dev
argument_list|,
literal|"ioctl: SIOCGIFMEDIA\n"
argument_list|)
expr_stmt|;
case|case
name|SIOCGIFXMEDIA
case|:
name|lio_dev_dbg
argument_list|(
name|lio
operator|->
name|oct_dev
argument_list|,
literal|"ioctl: SIOCGIFXMEDIA\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifrequest
argument_list|,
operator|&
name|lio
operator|->
name|ifmedia
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
block|{
name|int
name|features
init|=
name|ifrequest
operator|->
name|ifr_reqcap
operator|^
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|lio_dev_dbg
argument_list|(
name|lio
operator|->
name|oct_dev
argument_list|,
literal|"ioctl: SIOCSIFCAP (Set Capabilities)\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|features
condition|)
break|break;
if|if
condition|(
name|features
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
name|if_togglecapenable
argument_list|(
name|ifp
argument_list|,
name|IFCAP_TXCSUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_TXCSUM
condition|)
name|if_sethwassistbits
argument_list|(
name|ifp
argument_list|,
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator||
name|CSUM_IP
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|if_sethwassistbits
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|,
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator||
name|CSUM_IP
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|features
operator|&
name|IFCAP_TXCSUM_IPV6
condition|)
block|{
name|if_togglecapenable
argument_list|(
name|ifp
argument_list|,
name|IFCAP_TXCSUM_IPV6
argument_list|)
expr_stmt|;
if|if
condition|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_TXCSUM_IPV6
condition|)
name|if_sethwassistbits
argument_list|(
name|ifp
argument_list|,
operator|(
name|CSUM_UDP_IPV6
operator||
name|CSUM_TCP_IPV6
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|if_sethwassistbits
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|,
operator|(
name|CSUM_UDP_IPV6
operator||
name|CSUM_TCP_IPV6
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|features
operator|&
operator|(
name|IFCAP_RXCSUM
operator||
name|IFCAP_RXCSUM_IPV6
operator|)
condition|)
name|error
operator||=
name|lio_set_rx_csum
argument_list|(
name|ifp
argument_list|,
operator|(
name|features
operator|&
operator|(
name|IFCAP_RXCSUM
operator||
name|IFCAP_RXCSUM_IPV6
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|features
operator|&
name|IFCAP_TSO4
condition|)
name|error
operator||=
name|lio_set_tso4
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|features
operator|&
name|IFCAP_TSO6
condition|)
name|error
operator||=
name|lio_set_tso6
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|features
operator|&
name|IFCAP_LRO
condition|)
name|error
operator||=
name|lio_set_lro
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|features
operator|&
name|IFCAP_VLAN_HWTAGGING
condition|)
name|if_togglecapenable
argument_list|(
name|ifp
argument_list|,
name|IFCAP_VLAN_HWTAGGING
argument_list|)
expr_stmt|;
if|if
condition|(
name|features
operator|&
name|IFCAP_VLAN_HWFILTER
condition|)
name|if_togglecapenable
argument_list|(
name|ifp
argument_list|,
name|IFCAP_VLAN_HWFILTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|features
operator|&
name|IFCAP_VLAN_HWTSO
condition|)
name|if_togglecapenable
argument_list|(
name|ifp
argument_list|,
name|IFCAP_VLAN_HWTSO
argument_list|)
expr_stmt|;
name|VLAN_CAPABILITIES
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|lio_dev_dbg
argument_list|(
name|lio
operator|->
name|oct_dev
argument_list|,
literal|"ioctl: UNKNOWN (0x%X)\n"
argument_list|,
operator|(
name|int
operator|)
name|cmd
argument_list|)
expr_stmt|;
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lio_set_tso4
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|lio
modifier|*
name|lio
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
if|if
condition|(
name|if_getcapabilities
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_TSO4
condition|)
block|{
name|if_togglecapenable
argument_list|(
name|ifp
argument_list|,
name|IFCAP_TSO4
argument_list|)
expr_stmt|;
if|if
condition|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_TSO4
condition|)
name|if_sethwassistbits
argument_list|(
name|ifp
argument_list|,
name|CSUM_IP_TSO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|if_sethwassistbits
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|,
name|CSUM_IP_TSO
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lio_dev_info
argument_list|(
name|lio
operator|->
name|oct_dev
argument_list|,
literal|"TSO4 capability not supported\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lio_set_tso6
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|lio
modifier|*
name|lio
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
if|if
condition|(
name|if_getcapabilities
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_TSO6
condition|)
block|{
name|if_togglecapenable
argument_list|(
name|ifp
argument_list|,
name|IFCAP_TSO6
argument_list|)
expr_stmt|;
if|if
condition|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_TSO6
condition|)
name|if_sethwassistbits
argument_list|(
name|ifp
argument_list|,
name|CSUM_IP6_TSO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|if_sethwassistbits
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|,
name|CSUM_IP6_TSO
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lio_dev_info
argument_list|(
name|lio
operator|->
name|oct_dev
argument_list|,
literal|"TSO6 capability not supported\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lio_set_rx_csum
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|uint32_t
name|data
parameter_list|)
block|{
name|struct
name|lio
modifier|*
name|lio
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|if_getcapabilities
argument_list|(
name|ifp
argument_list|)
operator|&
operator|(
name|IFCAP_RXCSUM
operator||
name|IFCAP_RXCSUM_IPV6
operator|)
condition|)
block|{
name|if_togglecapenable
argument_list|(
name|ifp
argument_list|,
operator|(
name|IFCAP_RXCSUM
operator||
name|IFCAP_RXCSUM_IPV6
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
condition|)
block|{
comment|/* LRO requires RXCSUM */
if|if
condition|(
operator|(
name|if_getcapabilities
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_LRO
operator|)
operator|&&
operator|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_LRO
operator|)
condition|)
block|{
name|ret
operator|=
name|lio_set_feature
argument_list|(
name|ifp
argument_list|,
name|LIO_CMD_LRO_DISABLE
argument_list|,
name|LIO_LROIPV4
operator||
name|LIO_LROIPV6
argument_list|)
expr_stmt|;
name|if_togglecapenable
argument_list|(
name|ifp
argument_list|,
name|IFCAP_LRO
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|lio_dev_info
argument_list|(
name|lio
operator|->
name|oct_dev
argument_list|,
literal|"Rx checksum offload capability not supported\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|ret
operator|)
condition|?
name|EINVAL
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lio_set_lro
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|lio
modifier|*
name|lio
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|if_getcapabilities
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_LRO
operator|)
condition|)
block|{
name|lio_dev_info
argument_list|(
name|lio
operator|->
name|oct_dev
argument_list|,
literal|"LRO capability not supported\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
if|if
condition|(
operator|(
operator|!
operator|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_LRO
operator|)
operator|)
operator|&&
operator|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_RXCSUM
operator|)
operator|&&
operator|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_RXCSUM_IPV6
operator|)
condition|)
block|{
name|if_togglecapenable
argument_list|(
name|ifp
argument_list|,
name|IFCAP_LRO
argument_list|)
expr_stmt|;
if|if
condition|(
name|lio_hwlro
condition|)
name|ret
operator|=
name|lio_set_feature
argument_list|(
name|ifp
argument_list|,
name|LIO_CMD_LRO_ENABLE
argument_list|,
name|LIO_LROIPV4
operator||
name|LIO_LROIPV6
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_LRO
condition|)
block|{
name|if_togglecapenable
argument_list|(
name|ifp
argument_list|,
name|IFCAP_LRO
argument_list|)
expr_stmt|;
if|if
condition|(
name|lio_hwlro
condition|)
name|ret
operator|=
name|lio_set_feature
argument_list|(
name|ifp
argument_list|,
name|LIO_CMD_LRO_DISABLE
argument_list|,
name|LIO_LROIPV4
operator||
name|LIO_LROIPV6
argument_list|)
expr_stmt|;
block|}
else|else
name|lio_dev_info
argument_list|(
name|lio
operator|->
name|oct_dev
argument_list|,
literal|"LRO requires RXCSUM"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|ret
operator|)
condition|?
name|EINVAL
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lio_mtu_ctl_callback
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|uint32_t
name|status
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|lio_soft_command
modifier|*
name|sc
init|=
name|buf
decl_stmt|;
specifier|volatile
name|int
modifier|*
name|mtu_sc_ctx
decl_stmt|;
name|mtu_sc_ctx
operator|=
name|sc
operator|->
name|ctxptr
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"MTU updation ctl instruction failed. Status: %llx\n"
argument_list|,
name|LIO_CAST64
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|mtu_sc_ctx
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 		 * This barrier is required to be sure that the 		 * response has been written fully. 		 */
name|wmb
argument_list|()
expr_stmt|;
return|return;
block|}
operator|*
name|mtu_sc_ctx
operator|=
literal|1
expr_stmt|;
comment|/* 	 * This barrier is required to be sure that the response has been 	 * written fully. 	 */
name|wmb
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* @param ifp is network device */
end_comment

begin_function
specifier|static
name|int
name|lio_change_mtu
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|new_mtu
parameter_list|)
block|{
name|struct
name|lio
modifier|*
name|lio
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|octeon_device
modifier|*
name|oct
init|=
name|lio
operator|->
name|oct_dev
decl_stmt|;
name|struct
name|lio_soft_command
modifier|*
name|sc
decl_stmt|;
name|union
name|octeon_cmd
modifier|*
name|ncmd
decl_stmt|;
specifier|volatile
name|int
modifier|*
name|mtu_sc_ctx
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|lio
operator|->
name|mtu
operator|==
name|new_mtu
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Limit the MTU to make sure the ethernet packets are between 	 * LIO_MIN_MTU_SIZE bytes and LIO_MAX_MTU_SIZE bytes 	 */
if|if
condition|(
operator|(
name|new_mtu
operator|<
name|LIO_MIN_MTU_SIZE
operator|)
operator|||
operator|(
name|new_mtu
operator|>
name|LIO_MAX_MTU_SIZE
operator|)
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Invalid MTU: %d\n"
argument_list|,
name|new_mtu
argument_list|)
expr_stmt|;
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Valid range %d and %d\n"
argument_list|,
name|LIO_MIN_MTU_SIZE
argument_list|,
name|LIO_MAX_MTU_SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|sc
operator|=
name|lio_alloc_soft_command
argument_list|(
name|oct
argument_list|,
name|OCTEON_CMD_SIZE
argument_list|,
literal|16
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mtu_sc_ctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|ncmd
operator|=
operator|(
expr|union
name|octeon_cmd
operator|*
operator|)
name|sc
operator|->
name|virtdptr
expr_stmt|;
name|mtu_sc_ctx
operator|=
name|sc
operator|->
name|ctxptr
expr_stmt|;
operator|*
name|mtu_sc_ctx
operator|=
literal|0
expr_stmt|;
name|ncmd
operator|->
name|cmd64
operator|=
literal|0
expr_stmt|;
name|ncmd
operator|->
name|s
operator|.
name|cmd
operator|=
name|LIO_CMD_CHANGE_MTU
expr_stmt|;
name|ncmd
operator|->
name|s
operator|.
name|param1
operator|=
name|new_mtu
expr_stmt|;
name|lio_swap_8B_data
argument_list|(
operator|(
name|uint64_t
operator|*
operator|)
name|ncmd
argument_list|,
operator|(
name|OCTEON_CMD_SIZE
operator|>>
literal|3
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|iq_no
operator|=
name|lio
operator|->
name|linfo
operator|.
name|txpciq
index|[
literal|0
index|]
operator|.
name|s
operator|.
name|q_no
expr_stmt|;
name|lio_prepare_soft_command
argument_list|(
name|oct
argument_list|,
name|sc
argument_list|,
name|LIO_OPCODE_NIC
argument_list|,
name|LIO_OPCODE_NIC_CMD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|callback
operator|=
name|lio_mtu_ctl_callback
expr_stmt|;
name|sc
operator|->
name|callback_arg
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|wait_time
operator|=
literal|5000
expr_stmt|;
name|retval
operator|=
name|lio_send_soft_command
argument_list|(
name|oct
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|LIO_IQ_SEND_FAILED
condition|)
block|{
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"Failed to send MTU update Control message\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|mtu_updation_failed
goto|;
block|}
comment|/* 	 * Sleep on a wait queue till the cond flag indicates that the 	 * response arrived or timed-out. 	 */
name|lio_sleep_cond
argument_list|(
name|oct
argument_list|,
name|mtu_sc_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mtu_sc_ctx
operator|<
literal|0
condition|)
block|{
name|retval
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|mtu_updation_failed
goto|;
block|}
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"MTU Changed from %d to %d\n"
argument_list|,
name|if_getmtu
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|new_mtu
argument_list|)
expr_stmt|;
name|if_setmtu
argument_list|(
name|ifp
argument_list|,
name|new_mtu
argument_list|)
expr_stmt|;
name|lio
operator|->
name|mtu
operator|=
name|new_mtu
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
comment|/* 				         * this updation is make sure that LIO_IQ_SEND_STOP case 				         * also success 				         */
name|mtu_updation_failed
label|:
name|lio_free_soft_command
argument_list|(
name|oct
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/* @param ifp network device */
end_comment

begin_function
name|int
name|lio_set_mac
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|uint8_t
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|lio_ctrl_pkt
name|nctrl
decl_stmt|;
name|struct
name|lio
modifier|*
name|lio
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|octeon_device
modifier|*
name|oct
init|=
name|lio
operator|->
name|oct_dev
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|lio_is_valid_ether_addr
argument_list|(
name|p
argument_list|)
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
name|bzero
argument_list|(
operator|&
name|nctrl
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lio_ctrl_pkt
argument_list|)
argument_list|)
expr_stmt|;
name|nctrl
operator|.
name|ncmd
operator|.
name|cmd64
operator|=
literal|0
expr_stmt|;
name|nctrl
operator|.
name|ncmd
operator|.
name|s
operator|.
name|cmd
operator|=
name|LIO_CMD_CHANGE_MACADDR
expr_stmt|;
name|nctrl
operator|.
name|ncmd
operator|.
name|s
operator|.
name|param1
operator|=
literal|0
expr_stmt|;
name|nctrl
operator|.
name|ncmd
operator|.
name|s
operator|.
name|more
operator|=
literal|1
expr_stmt|;
name|nctrl
operator|.
name|iq_no
operator|=
name|lio
operator|->
name|linfo
operator|.
name|txpciq
index|[
literal|0
index|]
operator|.
name|s
operator|.
name|q_no
expr_stmt|;
name|nctrl
operator|.
name|lio
operator|=
name|lio
expr_stmt|;
name|nctrl
operator|.
name|cb_fn
operator|=
name|lio_ctrl_cmd_completion
expr_stmt|;
name|nctrl
operator|.
name|wait_time
operator|=
literal|100
expr_stmt|;
name|nctrl
operator|.
name|udd
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* The MAC Address is presented in network byte order. */
name|memcpy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|nctrl
operator|.
name|udd
index|[
literal|0
index|]
operator|+
literal|2
argument_list|,
name|p
argument_list|,
name|ETHER_HDR_LEN
argument_list|)
expr_stmt|;
name|ret
operator|=
name|lio_send_ctrl_pkt
argument_list|(
name|lio
operator|->
name|oct_dev
argument_list|,
operator|&
name|nctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"MAC Address change failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|memcpy
argument_list|(
operator|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|lio
operator|->
name|linfo
operator|.
name|hw_addr
operator|)
operator|+
literal|2
argument_list|,
name|p
argument_list|,
name|ETHER_HDR_LEN
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * \brief Converts a mask based on ifp flags  * @param ifp network device  *  * This routine generates a lio_ifflags mask from the ifp flags  * received from the OS.  */
end_comment

begin_function
specifier|static
specifier|inline
name|enum
name|lio_ifflags
name|lio_get_new_flags
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|enum
name|lio_ifflags
name|f
init|=
name|LIO_IFFLAG_UNICAST
decl_stmt|;
if|if
condition|(
name|if_getflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_PROMISC
condition|)
name|f
operator||=
name|LIO_IFFLAG_PROMISC
expr_stmt|;
if|if
condition|(
name|if_getflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_ALLMULTI
condition|)
name|f
operator||=
name|LIO_IFFLAG_ALLMULTI
expr_stmt|;
if|if
condition|(
name|if_getflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_MULTICAST
condition|)
block|{
name|f
operator||=
name|LIO_IFFLAG_MULTICAST
expr_stmt|;
comment|/* 		 * Accept all multicast addresses if there are more than we 		 * can handle 		 */
if|if
condition|(
name|if_getamcount
argument_list|(
name|ifp
argument_list|)
operator|>
name|LIO_MAX_MULTICAST_ADDR
condition|)
name|f
operator||=
name|LIO_IFFLAG_ALLMULTI
expr_stmt|;
block|}
if|if
condition|(
name|if_getflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_BROADCAST
condition|)
name|f
operator||=
name|LIO_IFFLAG_BROADCAST
expr_stmt|;
return|return
operator|(
name|f
operator|)
return|;
block|}
end_function

begin_comment
comment|/* @param ifp network device */
end_comment

begin_function
specifier|static
name|int
name|lio_set_mcast_list
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|lio
modifier|*
name|lio
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|octeon_device
modifier|*
name|oct
init|=
name|lio
operator|->
name|oct_dev
decl_stmt|;
name|struct
name|lio_ctrl_pkt
name|nctrl
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|uint64_t
modifier|*
name|mc
decl_stmt|;
name|int
name|mc_count
init|=
literal|0
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|nctrl
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lio_ctrl_pkt
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create a ctrl pkt command to be sent to core app. */
name|nctrl
operator|.
name|ncmd
operator|.
name|cmd64
operator|=
literal|0
expr_stmt|;
name|nctrl
operator|.
name|ncmd
operator|.
name|s
operator|.
name|cmd
operator|=
name|LIO_CMD_SET_MULTI_LIST
expr_stmt|;
name|nctrl
operator|.
name|ncmd
operator|.
name|s
operator|.
name|param1
operator|=
name|lio_get_new_flags
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|nctrl
operator|.
name|iq_no
operator|=
name|lio
operator|->
name|linfo
operator|.
name|txpciq
index|[
literal|0
index|]
operator|.
name|s
operator|.
name|q_no
expr_stmt|;
name|nctrl
operator|.
name|lio
operator|=
name|lio
expr_stmt|;
name|nctrl
operator|.
name|cb_fn
operator|=
name|lio_ctrl_cmd_completion
expr_stmt|;
comment|/* copy all the addresses into the udd */
name|mc
operator|=
operator|&
name|nctrl
operator|.
name|udd
index|[
literal|0
index|]
expr_stmt|;
comment|/* to protect access to if_multiaddrs */
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
operator|*
name|mc
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|mc
operator|)
operator|+
literal|2
argument_list|,
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* no need to swap bytes */
name|mc_count
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|mc
operator|>
operator|&
name|nctrl
operator|.
name|udd
index|[
name|LIO_MAX_MULTICAST_ADDR
index|]
condition|)
break|break;
block|}
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * Apparently, any activity in this call from the kernel has to 	 * be atomic. So we won't wait for response. 	 */
name|nctrl
operator|.
name|wait_time
operator|=
literal|0
expr_stmt|;
name|nctrl
operator|.
name|ncmd
operator|.
name|s
operator|.
name|param2
operator|=
name|mc_count
expr_stmt|;
name|nctrl
operator|.
name|ncmd
operator|.
name|s
operator|.
name|more
operator|=
name|mc_count
expr_stmt|;
name|ret
operator|=
name|lio_send_ctrl_pkt
argument_list|(
name|lio
operator|->
name|oct_dev
argument_list|,
operator|&
name|nctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"DEVFLAGS change failed in core (ret: 0x%x)\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|ret
operator|)
condition|?
name|EINVAL
else|:
literal|0
operator|)
return|;
block|}
end_function

end_unit

