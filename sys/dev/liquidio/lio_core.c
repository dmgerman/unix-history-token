begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *   BSD LICENSE  *  *   Copyright(c) 2017 Cavium, Inc.. All rights reserved.  *   All rights reserved.  *  *   Redistribution and use in source and binary forms, with or without  *   modification, are permitted provided that the following conditions  *   are met:  *  *     * Redistributions of source code must retain the above copyright  *       notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above copyright  *       notice, this list of conditions and the following disclaimer in  *       the documentation and/or other materials provided with the  *       distribution.  *     * Neither the name of Cavium, Inc. nor the names of its  *       contributors may be used to endorse or promote products derived  *       from this software without specific prior written permission.  *  *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  *   OWNER(S) OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"lio_bsd.h"
end_include

begin_include
include|#
directive|include
file|"lio_common.h"
end_include

begin_include
include|#
directive|include
file|"lio_droq.h"
end_include

begin_include
include|#
directive|include
file|"lio_iq.h"
end_include

begin_include
include|#
directive|include
file|"lio_response_manager.h"
end_include

begin_include
include|#
directive|include
file|"lio_device.h"
end_include

begin_include
include|#
directive|include
file|"lio_ctrl.h"
end_include

begin_include
include|#
directive|include
file|"lio_main.h"
end_include

begin_include
include|#
directive|include
file|"lio_rxtx.h"
end_include

begin_include
include|#
directive|include
file|"lio_network.h"
end_include

begin_function
name|int
name|lio_set_feature
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|cmd
parameter_list|,
name|uint16_t
name|param1
parameter_list|)
block|{
name|struct
name|lio_ctrl_pkt
name|nctrl
decl_stmt|;
name|struct
name|lio
modifier|*
name|lio
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|octeon_device
modifier|*
name|oct
init|=
name|lio
operator|->
name|oct_dev
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|nctrl
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lio_ctrl_pkt
argument_list|)
argument_list|)
expr_stmt|;
name|nctrl
operator|.
name|ncmd
operator|.
name|cmd64
operator|=
literal|0
expr_stmt|;
name|nctrl
operator|.
name|ncmd
operator|.
name|s
operator|.
name|cmd
operator|=
name|cmd
expr_stmt|;
name|nctrl
operator|.
name|ncmd
operator|.
name|s
operator|.
name|param1
operator|=
name|param1
expr_stmt|;
name|nctrl
operator|.
name|iq_no
operator|=
name|lio
operator|->
name|linfo
operator|.
name|txpciq
index|[
literal|0
index|]
operator|.
name|s
operator|.
name|q_no
expr_stmt|;
name|nctrl
operator|.
name|wait_time
operator|=
literal|100
expr_stmt|;
name|nctrl
operator|.
name|lio
operator|=
name|lio
expr_stmt|;
name|nctrl
operator|.
name|cb_fn
operator|=
name|lio_ctrl_cmd_completion
expr_stmt|;
name|ret
operator|=
name|lio_send_ctrl_pkt
argument_list|(
name|lio
operator|->
name|oct_dev
argument_list|,
operator|&
name|nctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Feature change failed in core (ret: 0x%x)\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
name|lio_ctrl_cmd_completion
parameter_list|(
name|void
modifier|*
name|nctrl_ptr
parameter_list|)
block|{
name|struct
name|lio_ctrl_pkt
modifier|*
name|nctrl
init|=
operator|(
expr|struct
name|lio_ctrl_pkt
operator|*
operator|)
name|nctrl_ptr
decl_stmt|;
name|struct
name|lio
modifier|*
name|lio
decl_stmt|;
name|struct
name|octeon_device
modifier|*
name|oct
decl_stmt|;
name|uint8_t
modifier|*
name|mac
decl_stmt|;
name|lio
operator|=
name|nctrl
operator|->
name|lio
expr_stmt|;
if|if
condition|(
name|lio
operator|->
name|oct_dev
operator|==
name|NULL
condition|)
return|return;
name|oct
operator|=
name|lio
operator|->
name|oct_dev
expr_stmt|;
switch|switch
condition|(
name|nctrl
operator|->
name|ncmd
operator|.
name|s
operator|.
name|cmd
condition|)
block|{
case|case
name|LIO_CMD_CHANGE_DEVFLAGS
case|:
case|case
name|LIO_CMD_SET_MULTI_LIST
case|:
break|break;
case|case
name|LIO_CMD_CHANGE_MACADDR
case|:
name|mac
operator|=
operator|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|nctrl
operator|->
name|udd
index|[
literal|0
index|]
operator|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|nctrl
operator|->
name|ncmd
operator|.
name|s
operator|.
name|param1
condition|)
block|{
comment|/* vfidx is 0 based, but vf_num (param1) is 1 based */
name|int
name|vfidx
init|=
name|nctrl
operator|->
name|ncmd
operator|.
name|s
operator|.
name|param1
operator|-
literal|1
decl_stmt|;
name|bool
name|mac_is_admin_assigned
init|=
name|nctrl
operator|->
name|ncmd
operator|.
name|s
operator|.
name|param2
decl_stmt|;
if|if
condition|(
name|mac_is_admin_assigned
condition|)
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"MAC Address %pM is configured for VF %d\n"
argument_list|,
name|mac
argument_list|,
name|vfidx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"MAC Address changed to %02x:%02x:%02x:%02x:%02x:%02x\n"
argument_list|,
name|mac
index|[
literal|0
index|]
argument_list|,
name|mac
index|[
literal|1
index|]
argument_list|,
name|mac
index|[
literal|2
index|]
argument_list|,
name|mac
index|[
literal|3
index|]
argument_list|,
name|mac
index|[
literal|4
index|]
argument_list|,
name|mac
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LIO_CMD_GPIO_ACCESS
case|:
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"LED Flashing visual identification\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIO_CMD_ID_ACTIVE
case|:
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"LED Flashing visual identification\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIO_CMD_LRO_ENABLE
case|:
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"HW LRO Enabled\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIO_CMD_LRO_DISABLE
case|:
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"HW LRO Disabled\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIO_CMD_VERBOSE_ENABLE
case|:
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"Firmware debug enabled\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIO_CMD_VERBOSE_DISABLE
case|:
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"Firmware debug disabled\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIO_CMD_VLAN_FILTER_CTL
case|:
if|if
condition|(
name|nctrl
operator|->
name|ncmd
operator|.
name|s
operator|.
name|param1
condition|)
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"VLAN filter enabled\n"
argument_list|)
expr_stmt|;
else|else
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"VLAN filter disabled\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIO_CMD_ADD_VLAN_FILTER
case|:
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"VLAN filter %d added\n"
argument_list|,
name|nctrl
operator|->
name|ncmd
operator|.
name|s
operator|.
name|param1
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIO_CMD_DEL_VLAN_FILTER
case|:
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"VLAN filter %d removed\n"
argument_list|,
name|nctrl
operator|->
name|ncmd
operator|.
name|s
operator|.
name|param1
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIO_CMD_SET_SETTINGS
case|:
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"Settings changed\n"
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * Case to handle "LIO_CMD_TNL_RX_CSUM_CTL" 		 * Command passed by NIC driver 		 */
case|case
name|LIO_CMD_TNL_RX_CSUM_CTL
case|:
if|if
condition|(
name|nctrl
operator|->
name|ncmd
operator|.
name|s
operator|.
name|param1
operator|==
name|LIO_CMD_RXCSUM_ENABLE
condition|)
block|{
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"RX Checksum Offload Enabled\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nctrl
operator|->
name|ncmd
operator|.
name|s
operator|.
name|param1
operator|==
name|LIO_CMD_RXCSUM_DISABLE
condition|)
block|{
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"RX Checksum Offload Disabled\n"
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 		 * Case to handle "LIO_CMD_TNL_TX_CSUM_CTL" 		 * Command passed by NIC driver 		 */
case|case
name|LIO_CMD_TNL_TX_CSUM_CTL
case|:
if|if
condition|(
name|nctrl
operator|->
name|ncmd
operator|.
name|s
operator|.
name|param1
operator|==
name|LIO_CMD_TXCSUM_ENABLE
condition|)
block|{
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"TX Checksum Offload Enabled\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nctrl
operator|->
name|ncmd
operator|.
name|s
operator|.
name|param1
operator|==
name|LIO_CMD_TXCSUM_DISABLE
condition|)
block|{
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"TX Checksum Offload Disabled\n"
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 		 * Case to handle "LIO_CMD_VXLAN_PORT_CONFIG" 		 * Command passed by NIC driver 		 */
case|case
name|LIO_CMD_VXLAN_PORT_CONFIG
case|:
if|if
condition|(
name|nctrl
operator|->
name|ncmd
operator|.
name|s
operator|.
name|more
operator|==
name|LIO_CMD_VXLAN_PORT_ADD
condition|)
block|{
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"VxLAN Destination UDP PORT:%d ADDED\n"
argument_list|,
name|nctrl
operator|->
name|ncmd
operator|.
name|s
operator|.
name|param1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nctrl
operator|->
name|ncmd
operator|.
name|s
operator|.
name|more
operator|==
name|LIO_CMD_VXLAN_PORT_DEL
condition|)
block|{
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"VxLAN Destination UDP PORT:%d DELETED\n"
argument_list|,
name|nctrl
operator|->
name|ncmd
operator|.
name|s
operator|.
name|param1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LIO_CMD_SET_FLOW_CTL
case|:
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"Set RX/TX flow control parameters\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIO_CMD_SET_FNV
case|:
if|if
condition|(
name|nctrl
operator|->
name|ncmd
operator|.
name|s
operator|.
name|param1
operator|==
name|LIO_CMD_FNV_ENABLE
condition|)
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"FNV Enabled\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nctrl
operator|->
name|ncmd
operator|.
name|s
operator|.
name|param1
operator|==
name|LIO_CMD_FNV_DISABLE
condition|)
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"FNV Disabled\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIO_CMD_PKT_STEERING_CTL
case|:
if|if
condition|(
name|nctrl
operator|->
name|ncmd
operator|.
name|s
operator|.
name|param1
operator|==
name|LIO_CMD_PKT_STEERING_ENABLE
condition|)
block|{
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"Packet Steering Enabled\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nctrl
operator|->
name|ncmd
operator|.
name|s
operator|.
name|param1
operator|==
name|LIO_CMD_PKT_STEERING_DISABLE
condition|)
block|{
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"Packet Steering Disabled\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LIO_CMD_QUEUE_COUNT_CTL
case|:
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"Queue count updated to %d\n"
argument_list|,
name|nctrl
operator|->
name|ncmd
operator|.
name|s
operator|.
name|param1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"%s Unknown cmd %d\n"
argument_list|,
name|__func__
argument_list|,
name|nctrl
operator|->
name|ncmd
operator|.
name|s
operator|.
name|cmd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * \brief Setup output queue  * @param oct octeon device  * @param q_no which queue  * @param num_descs how many descriptors  * @param desc_size size of each descriptor  * @param app_ctx application context  */
end_comment

begin_function
specifier|static
name|int
name|lio_setup_droq
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|int
name|q_no
parameter_list|,
name|int
name|num_descs
parameter_list|,
name|int
name|desc_size
parameter_list|,
name|void
modifier|*
name|app_ctx
parameter_list|)
block|{
name|int
name|ret_val
init|=
literal|0
decl_stmt|;
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"Creating Droq: %d\n"
argument_list|,
name|q_no
argument_list|)
expr_stmt|;
comment|/* droq creation and local register settings. */
name|ret_val
operator|=
name|lio_create_droq
argument_list|(
name|oct
argument_list|,
name|q_no
argument_list|,
name|num_descs
argument_list|,
name|desc_size
argument_list|,
name|app_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
operator|<
literal|0
condition|)
return|return
operator|(
name|ret_val
operator|)
return|;
if|if
condition|(
name|ret_val
operator|==
literal|1
condition|)
block|{
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"Using default droq %d\n"
argument_list|,
name|q_no
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Send Credit for Octeon Output queues. Credits are always          * sent after the output queue is enabled.          */
name|lio_write_csr32
argument_list|(
name|oct
argument_list|,
name|oct
operator|->
name|droq
index|[
name|q_no
index|]
operator|->
name|pkts_credit_reg
argument_list|,
name|oct
operator|->
name|droq
index|[
name|q_no
index|]
operator|->
name|max_count
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret_val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lio_push_packet
parameter_list|(
name|void
modifier|*
name|m_buff
parameter_list|,
name|uint32_t
name|len
parameter_list|,
name|union
name|octeon_rh
modifier|*
name|rh
parameter_list|,
name|void
modifier|*
name|rxq
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mbuf
init|=
name|m_buff
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|arg
decl_stmt|;
name|struct
name|lio_droq
modifier|*
name|droq
init|=
name|rxq
decl_stmt|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
block|{
name|struct
name|lio
modifier|*
name|lio
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
comment|/* Do not proceed if the interface is not in RUNNING state. */
if|if
condition|(
operator|!
name|lio_ifstate_check
argument_list|(
name|lio
argument_list|,
name|LIO_IFSTATE_RUNNING
argument_list|)
condition|)
block|{
name|lio_recv_buffer_free
argument_list|(
name|mbuf
argument_list|)
expr_stmt|;
name|droq
operator|->
name|stats
operator|.
name|rx_dropped
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rh
operator|->
name|r_dh
operator|.
name|has_hash
condition|)
block|{
name|uint32_t
name|hashtype
decl_stmt|,
name|hashval
decl_stmt|;
if|if
condition|(
name|rh
operator|->
name|r_dh
operator|.
name|has_hwtstamp
condition|)
block|{
name|hashval
operator|=
name|htobe32
argument_list|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|(
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|mbuf
operator|->
name|m_data
operator|)
operator|+
operator|(
operator|(
name|rh
operator|->
name|r_dh
operator|.
name|len
operator|-
literal|2
operator|)
operator|*
name|BYTES_PER_DHLEN_UNIT
operator|)
operator|)
argument_list|)
expr_stmt|;
name|hashtype
operator|=
name|htobe32
argument_list|(
operator|*
operator|(
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|(
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|mbuf
operator|->
name|m_data
operator|)
operator|+
operator|(
operator|(
name|rh
operator|->
name|r_dh
operator|.
name|len
operator|-
literal|2
operator|)
operator|*
name|BYTES_PER_DHLEN_UNIT
operator|)
operator|)
operator|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hashval
operator|=
name|htobe32
argument_list|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|(
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|mbuf
operator|->
name|m_data
operator|)
operator|+
operator|(
operator|(
name|rh
operator|->
name|r_dh
operator|.
name|len
operator|-
literal|1
operator|)
operator|*
name|BYTES_PER_DHLEN_UNIT
operator|)
operator|)
argument_list|)
expr_stmt|;
name|hashtype
operator|=
name|htobe32
argument_list|(
operator|*
operator|(
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|(
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|mbuf
operator|->
name|m_data
operator|)
operator|+
operator|(
operator|(
name|rh
operator|->
name|r_dh
operator|.
name|len
operator|-
literal|1
operator|)
operator|*
name|BYTES_PER_DHLEN_UNIT
operator|)
operator|)
operator|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
name|hashval
expr_stmt|;
switch|switch
condition|(
name|hashtype
condition|)
block|{
case|case
name|LIO_RSS_HASH_IPV4
case|:
name|M_HASHTYPE_SET
argument_list|(
name|mbuf
argument_list|,
name|M_HASHTYPE_RSS_IPV4
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIO_RSS_HASH_TCP_IPV4
case|:
name|M_HASHTYPE_SET
argument_list|(
name|mbuf
argument_list|,
name|M_HASHTYPE_RSS_TCP_IPV4
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIO_RSS_HASH_IPV6
case|:
name|M_HASHTYPE_SET
argument_list|(
name|mbuf
argument_list|,
name|M_HASHTYPE_RSS_IPV6
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIO_RSS_HASH_TCP_IPV6
case|:
name|M_HASHTYPE_SET
argument_list|(
name|mbuf
argument_list|,
name|M_HASHTYPE_RSS_TCP_IPV6
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIO_RSS_HASH_IPV6_EX
case|:
name|M_HASHTYPE_SET
argument_list|(
name|mbuf
argument_list|,
name|M_HASHTYPE_RSS_IPV6_EX
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIO_RSS_HASH_TCP_IPV6_EX
case|:
name|M_HASHTYPE_SET
argument_list|(
name|mbuf
argument_list|,
name|M_HASHTYPE_RSS_TCP_IPV6_EX
argument_list|)
expr_stmt|;
break|break;
default|default:
name|M_HASHTYPE_SET
argument_list|(
name|mbuf
argument_list|,
name|M_HASHTYPE_OPAQUE_HASH
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*                          * This case won't hit as FW will always set has_hash                          * in rh.                          */
name|M_HASHTYPE_SET
argument_list|(
name|mbuf
argument_list|,
name|M_HASHTYPE_OPAQUE
argument_list|)
expr_stmt|;
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
name|droq
operator|->
name|q_no
expr_stmt|;
block|}
name|m_adj
argument_list|(
name|mbuf
argument_list|,
name|rh
operator|->
name|r_dh
operator|.
name|len
operator|*
literal|8
argument_list|)
expr_stmt|;
name|len
operator|-=
name|rh
operator|->
name|r_dh
operator|.
name|len
operator|*
literal|8
expr_stmt|;
name|mbuf
operator|->
name|m_flags
operator||=
name|M_PKTHDR
expr_stmt|;
if|if
condition|(
operator|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_VLAN_HWTAGGING
operator|)
operator|&&
operator|(
name|rh
operator|->
name|r_dh
operator|.
name|priority
operator|||
name|rh
operator|->
name|r_dh
operator|.
name|vlan
operator|)
condition|)
block|{
name|uint16_t
name|priority
init|=
name|rh
operator|->
name|r_dh
operator|.
name|priority
decl_stmt|;
name|uint16_t
name|vid
init|=
name|rh
operator|->
name|r_dh
operator|.
name|vlan
decl_stmt|;
name|uint16_t
name|vtag
decl_stmt|;
name|vtag
operator|=
name|priority
operator|<<
literal|13
operator||
name|vid
expr_stmt|;
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|=
name|vtag
expr_stmt|;
name|mbuf
operator|->
name|m_flags
operator||=
name|M_VLANTAG
expr_stmt|;
block|}
if|if
condition|(
name|rh
operator|->
name|r_dh
operator|.
name|csum_verified
operator|&
name|LIO_IPSUM_VERIFIED
condition|)
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
operator|(
name|CSUM_L3_CALC
operator||
name|CSUM_L3_VALID
operator|)
expr_stmt|;
if|if
condition|(
name|rh
operator|->
name|r_dh
operator|.
name|csum_verified
operator|&
name|LIO_L4SUM_VERIFIED
condition|)
block|{
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
operator|(
name|CSUM_L4_CALC
operator||
name|CSUM_L4_VALID
operator|)
expr_stmt|;
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
operator|(
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
expr_stmt|;
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
name|htons
argument_list|(
literal|0xffff
argument_list|)
expr_stmt|;
block|}
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
if|if
condition|(
operator|(
name|lio_hwlro
operator|==
literal|0
operator|)
operator|&&
operator|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_LRO
operator|)
operator|&&
operator|(
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_L3_VALID
operator||
name|CSUM_L4_VALID
operator||
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
operator|)
operator|==
operator|(
name|CSUM_L3_VALID
operator||
name|CSUM_L4_VALID
operator||
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
condition|)
block|{
if|if
condition|(
name|droq
operator|->
name|lro
operator|.
name|lro_cnt
condition|)
block|{
if|if
condition|(
name|tcp_lro_rx
argument_list|(
operator|&
name|droq
operator|->
name|lro
argument_list|,
name|mbuf
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|droq
operator|->
name|stats
operator|.
name|rx_bytes_received
operator|+=
name|len
expr_stmt|;
name|droq
operator|->
name|stats
operator|.
name|rx_pkts_received
operator|++
expr_stmt|;
return|return;
block|}
block|}
block|}
name|if_input
argument_list|(
name|ifp
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
name|droq
operator|->
name|stats
operator|.
name|rx_bytes_received
operator|+=
name|len
expr_stmt|;
name|droq
operator|->
name|stats
operator|.
name|rx_pkts_received
operator|++
expr_stmt|;
block|}
else|else
block|{
name|lio_recv_buffer_free
argument_list|(
name|mbuf
argument_list|)
expr_stmt|;
name|droq
operator|->
name|stats
operator|.
name|rx_dropped
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * \brief Setup input and output queues  * @param octeon_dev octeon device  * @param ifidx  Interface Index  *  * Note: Queues are with respect to the octeon device. Thus  * an input queue is for egress packets, and output queues  * are for ingress packets.  */
end_comment

begin_function
name|int
name|lio_setup_io_queues
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|octeon_dev
parameter_list|,
name|int
name|ifidx
parameter_list|,
name|uint32_t
name|num_iqs
parameter_list|,
name|uint32_t
name|num_oqs
parameter_list|)
block|{
name|struct
name|lio_droq_ops
name|droq_ops
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|lio_droq
modifier|*
name|droq
decl_stmt|;
name|struct
name|lio
modifier|*
name|lio
decl_stmt|;
specifier|static
name|int
name|cpu_id
decl_stmt|,
name|cpu_id_modulus
decl_stmt|;
name|int
name|num_tx_descs
decl_stmt|,
name|q
decl_stmt|,
name|q_no
decl_stmt|,
name|retval
init|=
literal|0
decl_stmt|;
name|ifp
operator|=
name|octeon_dev
operator|->
name|props
operator|.
name|ifp
expr_stmt|;
name|lio
operator|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|droq_ops
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lio_droq_ops
argument_list|)
argument_list|)
expr_stmt|;
name|droq_ops
operator|.
name|fptr
operator|=
name|lio_push_packet
expr_stmt|;
name|droq_ops
operator|.
name|farg
operator|=
operator|(
name|void
operator|*
operator|)
name|ifp
expr_stmt|;
name|cpu_id
operator|=
literal|0
expr_stmt|;
name|cpu_id_modulus
operator|=
name|mp_ncpus
expr_stmt|;
comment|/* set up DROQs. */
for|for
control|(
name|q
operator|=
literal|0
init|;
name|q
operator|<
name|num_oqs
condition|;
name|q
operator|++
control|)
block|{
name|q_no
operator|=
name|lio
operator|->
name|linfo
operator|.
name|rxpciq
index|[
name|q
index|]
operator|.
name|s
operator|.
name|q_no
expr_stmt|;
name|lio_dev_dbg
argument_list|(
name|octeon_dev
argument_list|,
literal|"lio_setup_io_queues index:%d linfo.rxpciq.s.q_no:%d\n"
argument_list|,
name|q
argument_list|,
name|q_no
argument_list|)
expr_stmt|;
name|retval
operator|=
name|lio_setup_droq
argument_list|(
name|octeon_dev
argument_list|,
name|q_no
argument_list|,
name|LIO_GET_NUM_RX_DESCS_NIC_IF_CFG
argument_list|(
name|lio_get_conf
argument_list|(
name|octeon_dev
argument_list|)
argument_list|,
name|lio
operator|->
name|ifidx
argument_list|)
argument_list|,
name|LIO_GET_NUM_RX_BUF_SIZE_NIC_IF_CFG
argument_list|(
name|lio_get_conf
argument_list|(
name|octeon_dev
argument_list|)
argument_list|,
name|lio
operator|->
name|ifidx
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
block|{
name|lio_dev_err
argument_list|(
name|octeon_dev
argument_list|,
literal|"%s : Runtime DROQ(RxQ) creation failed.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|droq
operator|=
name|octeon_dev
operator|->
name|droq
index|[
name|q_no
index|]
expr_stmt|;
comment|/* designate a CPU for this droq */
name|droq
operator|->
name|cpu_id
operator|=
name|cpu_id
expr_stmt|;
name|cpu_id
operator|++
expr_stmt|;
if|if
condition|(
name|cpu_id
operator|>=
name|cpu_id_modulus
condition|)
name|cpu_id
operator|=
literal|0
expr_stmt|;
name|lio_register_droq_ops
argument_list|(
name|octeon_dev
argument_list|,
name|q_no
argument_list|,
operator|&
name|droq_ops
argument_list|)
expr_stmt|;
block|}
comment|/* set up IQs. */
for|for
control|(
name|q
operator|=
literal|0
init|;
name|q
operator|<
name|num_iqs
condition|;
name|q
operator|++
control|)
block|{
name|num_tx_descs
operator|=
name|LIO_GET_NUM_TX_DESCS_NIC_IF_CFG
argument_list|(
name|lio_get_conf
argument_list|(
name|octeon_dev
argument_list|)
argument_list|,
name|lio
operator|->
name|ifidx
argument_list|)
expr_stmt|;
name|retval
operator|=
name|lio_setup_iq
argument_list|(
name|octeon_dev
argument_list|,
name|ifidx
argument_list|,
name|q
argument_list|,
name|lio
operator|->
name|linfo
operator|.
name|txpciq
index|[
name|q
index|]
argument_list|,
name|num_tx_descs
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
block|{
name|lio_dev_err
argument_list|(
name|octeon_dev
argument_list|,
literal|" %s : Runtime IQ(TxQ) creation failed.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * \brief Droq packet processor sceduler  * @param oct octeon device  */
end_comment

begin_function
specifier|static
name|void
name|lio_schedule_droq_pkt_handlers
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
name|struct
name|lio_droq
modifier|*
name|droq
decl_stmt|;
name|uint64_t
name|oq_no
decl_stmt|;
if|if
condition|(
name|oct
operator|->
name|int_status
operator|&
name|LIO_DEV_INTR_PKT_DATA
condition|)
block|{
for|for
control|(
name|oq_no
operator|=
literal|0
init|;
name|oq_no
operator|<
name|LIO_MAX_OUTPUT_QUEUES
argument_list|(
name|oct
argument_list|)
condition|;
name|oq_no
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|oct
operator|->
name|io_qmask
operator|.
name|oq
operator|&
name|BIT_ULL
argument_list|(
name|oq_no
argument_list|)
operator|)
condition|)
continue|continue;
name|droq
operator|=
name|oct
operator|->
name|droq
index|[
name|oq_no
index|]
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|droq
operator|->
name|droq_taskqueue
argument_list|,
operator|&
name|droq
operator|->
name|droq_task
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|lio_msix_intr_handler
parameter_list|(
name|void
modifier|*
name|vector
parameter_list|)
block|{
name|struct
name|lio_ioq_vector
modifier|*
name|ioq_vector
init|=
operator|(
expr|struct
name|lio_ioq_vector
operator|*
operator|)
name|vector
decl_stmt|;
name|struct
name|octeon_device
modifier|*
name|oct
init|=
name|ioq_vector
operator|->
name|oct_dev
decl_stmt|;
name|struct
name|lio_droq
modifier|*
name|droq
init|=
name|oct
operator|->
name|droq
index|[
name|ioq_vector
operator|->
name|droq_index
index|]
decl_stmt|;
name|uint64_t
name|ret
decl_stmt|;
name|ret
operator|=
name|oct
operator|->
name|fn_list
operator|.
name|msix_interrupt_handler
argument_list|(
name|ioq_vector
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|&
name|LIO_MSIX_PO_INT
operator|)
operator|||
operator|(
name|ret
operator|&
name|LIO_MSIX_PI_INT
operator|)
condition|)
block|{
name|struct
name|lio_instr_queue
modifier|*
name|iq
init|=
name|oct
operator|->
name|instr_queue
index|[
name|droq
operator|->
name|q_no
index|]
decl_stmt|;
name|int
name|reschedule
decl_stmt|,
name|tx_done
init|=
literal|1
decl_stmt|;
name|reschedule
operator|=
name|lio_droq_process_packets
argument_list|(
name|oct
argument_list|,
name|droq
argument_list|,
name|oct
operator|->
name|rx_budget
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|iq
operator|->
name|instr_pending
argument_list|)
condition|)
name|tx_done
operator|=
name|lio_flush_iq
argument_list|(
name|oct
argument_list|,
name|iq
argument_list|,
name|oct
operator|->
name|tx_budget
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|oct
operator|->
name|props
operator|.
name|ifp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|iq
operator|->
name|br
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|mtx_trylock
argument_list|(
operator|&
name|iq
operator|->
name|enq_lock
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|drbr_empty
argument_list|(
name|oct
operator|->
name|props
operator|.
name|ifp
argument_list|,
name|iq
operator|->
name|br
argument_list|)
condition|)
name|lio_mq_start_locked
argument_list|(
name|oct
operator|->
name|props
operator|.
name|ifp
argument_list|,
name|iq
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|iq
operator|->
name|enq_lock
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|reschedule
operator|||
operator|!
name|tx_done
condition|)
name|taskqueue_enqueue
argument_list|(
name|droq
operator|->
name|droq_taskqueue
argument_list|,
operator|&
name|droq
operator|->
name|droq_task
argument_list|)
expr_stmt|;
else|else
name|lio_enable_irq
argument_list|(
name|droq
argument_list|,
name|iq
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|lio_intr_handler
parameter_list|(
name|void
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|octeon_device
modifier|*
name|oct
init|=
operator|(
expr|struct
name|octeon_device
operator|*
operator|)
name|dev
decl_stmt|;
comment|/* Disable our interrupts for the duration of ISR */
name|oct
operator|->
name|fn_list
operator|.
name|disable_interrupt
argument_list|(
name|oct
argument_list|,
name|OCTEON_ALL_INTR
argument_list|)
expr_stmt|;
name|oct
operator|->
name|fn_list
operator|.
name|process_interrupt_regs
argument_list|(
name|oct
argument_list|)
expr_stmt|;
name|lio_schedule_droq_pkt_handlers
argument_list|(
name|oct
argument_list|)
expr_stmt|;
comment|/* Re-enable our interrupts  */
if|if
condition|(
operator|!
operator|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|oct
operator|->
name|status
argument_list|)
operator|==
name|LIO_DEV_IN_RESET
operator|)
condition|)
name|oct
operator|->
name|fn_list
operator|.
name|enable_interrupt
argument_list|(
name|oct
argument_list|,
name|OCTEON_ALL_INTR
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|lio_setup_interrupt
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|uint32_t
name|num_ioqs
parameter_list|)
block|{
name|device_t
name|device
decl_stmt|;
name|struct
name|lio_ioq_vector
modifier|*
name|ioq_vector
decl_stmt|;
name|int
name|cpu_id
decl_stmt|,
name|err
decl_stmt|,
name|i
decl_stmt|;
name|int
name|num_alloc_ioq_vectors
decl_stmt|;
name|int
name|num_ioq_vectors
decl_stmt|;
name|int
name|res_id
decl_stmt|;
if|if
condition|(
operator|!
name|oct
operator|->
name|msix_on
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ioq_vector
operator|=
name|oct
operator|->
name|ioq_vector
expr_stmt|;
ifdef|#
directive|ifdef
name|RSS
if|if
condition|(
name|oct
operator|->
name|sriov_info
operator|.
name|num_pf_rings
operator|!=
name|rss_getnumbuckets
argument_list|()
condition|)
block|{
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"IOQ vectors (%d) are not equal number of RSS buckets (%d)\n"
argument_list|,
name|oct
operator|->
name|sriov_info
operator|.
name|num_pf_rings
argument_list|,
name|rss_getnumbuckets
argument_list|()
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|device
operator|=
name|oct
operator|->
name|device
expr_stmt|;
name|oct
operator|->
name|num_msix_irqs
operator|=
name|num_ioqs
expr_stmt|;
comment|/* one non ioq interrupt for handling sli_mac_pf_int_sum */
name|oct
operator|->
name|num_msix_irqs
operator|+=
literal|1
expr_stmt|;
name|num_alloc_ioq_vectors
operator|=
name|oct
operator|->
name|num_msix_irqs
expr_stmt|;
if|if
condition|(
name|pci_alloc_msix
argument_list|(
name|device
argument_list|,
operator|&
name|num_alloc_ioq_vectors
argument_list|)
operator|||
operator|(
name|num_alloc_ioq_vectors
operator|!=
name|oct
operator|->
name|num_msix_irqs
operator|)
condition|)
goto|goto
name|err
goto|;
name|num_ioq_vectors
operator|=
name|oct
operator|->
name|num_msix_irqs
expr_stmt|;
comment|/* For PF, there is one non-ioq interrupt handler */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_ioq_vectors
operator|-
literal|1
condition|;
name|i
operator|++
operator|,
name|ioq_vector
operator|++
control|)
block|{
name|res_id
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|ioq_vector
operator|->
name|msix_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|device
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|res_id
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioq_vector
operator|->
name|msix_res
operator|==
name|NULL
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Unable to allocate bus res msix[%d]\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|err_1
goto|;
block|}
name|err
operator|=
name|bus_setup_intr
argument_list|(
name|device
argument_list|,
name|ioq_vector
operator|->
name|msix_res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|lio_msix_intr_handler
argument_list|,
name|ioq_vector
argument_list|,
operator|&
name|ioq_vector
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|bus_release_resource
argument_list|(
name|device
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|res_id
argument_list|,
name|ioq_vector
operator|->
name|msix_res
argument_list|)
expr_stmt|;
name|ioq_vector
operator|->
name|msix_res
operator|=
name|NULL
expr_stmt|;
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Failed to register intr handler"
argument_list|)
expr_stmt|;
goto|goto
name|err_1
goto|;
block|}
name|bus_describe_intr
argument_list|(
name|device
argument_list|,
name|ioq_vector
operator|->
name|msix_res
argument_list|,
name|ioq_vector
operator|->
name|tag
argument_list|,
literal|"rxtx%u"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ioq_vector
operator|->
name|vector
operator|=
name|res_id
expr_stmt|;
ifdef|#
directive|ifdef
name|RSS
name|cpu_id
operator|=
name|rss_getcpu
argument_list|(
name|i
operator|%
name|rss_getnumbuckets
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
name|cpu_id
operator|=
name|i
operator|%
name|mp_ncpus
expr_stmt|;
endif|#
directive|endif
name|CPU_SETOF
argument_list|(
name|cpu_id
argument_list|,
operator|&
name|ioq_vector
operator|->
name|affinity_mask
argument_list|)
expr_stmt|;
comment|/* Setting the IRQ affinity. */
name|err
operator|=
name|bus_bind_intr
argument_list|(
name|device
argument_list|,
name|ioq_vector
operator|->
name|msix_res
argument_list|,
name|cpu_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"bus bind interrupt fail"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RSS
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"Bound RSS bucket %d to CPU %d\n"
argument_list|,
name|i
argument_list|,
name|cpu_id
argument_list|)
expr_stmt|;
else|#
directive|else
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"Bound Queue %d to CPU %d\n"
argument_list|,
name|i
argument_list|,
name|cpu_id
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"MSI-X enabled\n"
argument_list|)
expr_stmt|;
name|res_id
operator|=
name|num_ioq_vectors
expr_stmt|;
name|oct
operator|->
name|msix_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|device
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|res_id
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|oct
operator|->
name|msix_res
operator|==
name|NULL
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Unable to allocate bus res msix for non-ioq interrupt\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_1
goto|;
block|}
name|err
operator|=
name|bus_setup_intr
argument_list|(
name|device
argument_list|,
name|oct
operator|->
name|msix_res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|lio_intr_handler
argument_list|,
name|oct
argument_list|,
operator|&
name|oct
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|bus_release_resource
argument_list|(
name|device
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|res_id
argument_list|,
name|oct
operator|->
name|msix_res
argument_list|)
expr_stmt|;
name|oct
operator|->
name|msix_res
operator|=
name|NULL
expr_stmt|;
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Failed to register intr handler"
argument_list|)
expr_stmt|;
goto|goto
name|err_1
goto|;
block|}
name|bus_describe_intr
argument_list|(
name|device
argument_list|,
name|oct
operator|->
name|msix_res
argument_list|,
name|oct
operator|->
name|tag
argument_list|,
literal|"aux"
argument_list|)
expr_stmt|;
name|oct
operator|->
name|aux_vector
operator|=
name|res_id
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err_1
label|:
if|if
condition|(
name|oct
operator|->
name|tag
operator|!=
name|NULL
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|device
argument_list|,
name|oct
operator|->
name|msix_res
argument_list|,
name|oct
operator|->
name|tag
argument_list|)
expr_stmt|;
name|oct
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
block|}
while|while
condition|(
name|i
condition|)
block|{
name|i
operator|--
expr_stmt|;
name|ioq_vector
operator|--
expr_stmt|;
if|if
condition|(
name|ioq_vector
operator|->
name|tag
operator|!=
name|NULL
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|device
argument_list|,
name|ioq_vector
operator|->
name|msix_res
argument_list|,
name|ioq_vector
operator|->
name|tag
argument_list|)
expr_stmt|;
name|ioq_vector
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ioq_vector
operator|->
name|msix_res
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|device
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|ioq_vector
operator|->
name|vector
argument_list|,
name|ioq_vector
operator|->
name|msix_res
argument_list|)
expr_stmt|;
name|ioq_vector
operator|->
name|msix_res
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|oct
operator|->
name|msix_res
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|device
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|oct
operator|->
name|aux_vector
argument_list|,
name|oct
operator|->
name|msix_res
argument_list|)
expr_stmt|;
name|oct
operator|->
name|msix_res
operator|=
name|NULL
expr_stmt|;
block|}
name|err
label|:
name|pci_release_msi
argument_list|(
name|device
argument_list|)
expr_stmt|;
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"MSI-X disabled\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

end_unit

