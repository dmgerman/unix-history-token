begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *   BSD LICENSE  *  *   Copyright(c) 2017 Cavium, Inc.. All rights reserved.  *   All rights reserved.  *  *   Redistribution and use in source and binary forms, with or without  *   modification, are permitted provided that the following conditions  *   are met:  *  *     * Redistributions of source code must retain the above copyright  *       notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above copyright  *       notice, this list of conditions and the following disclaimer in  *       the documentation and/or other materials provided with the  *       distribution.  *     * Neither the name of Cavium, Inc. nor the names of its  *       contributors may be used to endorse or promote products derived  *       from this software without specific prior written permission.  *  *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  *   OWNER(S) OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"lio_bsd.h"
end_include

begin_include
include|#
directive|include
file|"lio_common.h"
end_include

begin_include
include|#
directive|include
file|"lio_droq.h"
end_include

begin_include
include|#
directive|include
file|"lio_iq.h"
end_include

begin_include
include|#
directive|include
file|"lio_response_manager.h"
end_include

begin_include
include|#
directive|include
file|"lio_device.h"
end_include

begin_include
include|#
directive|include
file|"lio_main.h"
end_include

begin_include
include|#
directive|include
file|"lio_network.h"
end_include

begin_include
include|#
directive|include
file|"cn23xx_pf_device.h"
end_include

begin_include
include|#
directive|include
file|"lio_rxtx.h"
end_include

begin_struct
struct|struct
name|lio_iq_post_status
block|{
name|int
name|status
decl_stmt|;
name|int
name|index
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|lio_check_db_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|__lio_check_db_timeout
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|uint64_t
name|iq_no
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Return 0 on success, 1 on failure */
end_comment

begin_function
name|int
name|lio_init_instr_queue
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|union
name|octeon_txpciq
name|txpciq
parameter_list|,
name|uint32_t
name|num_descs
parameter_list|)
block|{
name|struct
name|lio_instr_queue
modifier|*
name|iq
decl_stmt|;
name|struct
name|lio_iq_config
modifier|*
name|conf
init|=
name|NULL
decl_stmt|;
name|struct
name|lio_tq
modifier|*
name|db_tq
decl_stmt|;
name|struct
name|lio_request_list
modifier|*
name|request_buf
decl_stmt|;
name|bus_size_t
name|max_size
decl_stmt|;
name|uint32_t
name|iq_no
init|=
operator|(
name|uint32_t
operator|)
name|txpciq
operator|.
name|s
operator|.
name|q_no
decl_stmt|;
name|uint32_t
name|q_size
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|LIO_CN23XX_PF
argument_list|(
name|oct
argument_list|)
condition|)
name|conf
operator|=
operator|&
operator|(
name|LIO_GET_IQ_CFG
argument_list|(
name|LIO_CHIP_CONF
argument_list|(
name|oct
argument_list|,
name|cn23xx_pf
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|conf
operator|==
name|NULL
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Unsupported Chip %x\n"
argument_list|,
name|oct
operator|->
name|chip_id
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|q_size
operator|=
operator|(
name|uint32_t
operator|)
name|conf
operator|->
name|instr_type
operator|*
name|num_descs
expr_stmt|;
name|iq
operator|=
name|oct
operator|->
name|instr_queue
index|[
name|iq_no
index|]
expr_stmt|;
name|iq
operator|->
name|oct_dev
operator|=
name|oct
expr_stmt|;
name|max_size
operator|=
name|LIO_CN23XX_PKI_MAX_FRAME_SIZE
operator|*
name|num_descs
expr_stmt|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|oct
operator|->
name|device
argument_list|)
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|max_size
argument_list|,
comment|/* maxsize */
name|LIO_MAX_SG
argument_list|,
comment|/* nsegments */
name|PAGE_SIZE
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockfuncarg */
operator|&
name|iq
operator|->
name|txtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Cannot allocate memory for instr queue %d\n"
argument_list|,
name|iq_no
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|iq
operator|->
name|base_addr
operator|=
name|lio_dma_alloc
argument_list|(
name|q_size
argument_list|,
operator|&
name|iq
operator|->
name|base_addr_dma
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iq
operator|->
name|base_addr
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Cannot allocate memory for instr queue %d\n"
argument_list|,
name|iq_no
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|iq
operator|->
name|max_count
operator|=
name|num_descs
expr_stmt|;
comment|/* 	 * Initialize a list to holds requests that have been posted to 	 * Octeon but has yet to be fetched by octeon 	 */
name|iq
operator|->
name|request_list
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|iq
operator|->
name|request_list
argument_list|)
operator|*
name|num_descs
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|iq
operator|->
name|request_list
operator|==
name|NULL
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Alloc failed for IQ[%d] nr free list\n"
argument_list|,
name|iq_no
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"IQ[%d]: base: %p basedma: %lx count: %d\n"
argument_list|,
name|iq_no
argument_list|,
name|iq
operator|->
name|base_addr
argument_list|,
name|iq
operator|->
name|base_addr_dma
argument_list|,
name|iq
operator|->
name|max_count
argument_list|)
expr_stmt|;
comment|/* Create the descriptor buffer dma maps */
name|request_buf
operator|=
name|iq
operator|->
name|request_list
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_descs
condition|;
name|i
operator|++
operator|,
name|request_buf
operator|++
control|)
block|{
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|iq
operator|->
name|txtag
argument_list|,
literal|0
argument_list|,
operator|&
name|request_buf
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Unable to create TX DMA map\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|iq
operator|->
name|txpciq
operator|.
name|txpciq64
operator|=
name|txpciq
operator|.
name|txpciq64
expr_stmt|;
name|iq
operator|->
name|fill_cnt
operator|=
literal|0
expr_stmt|;
name|iq
operator|->
name|host_write_index
operator|=
literal|0
expr_stmt|;
name|iq
operator|->
name|octeon_read_index
operator|=
literal|0
expr_stmt|;
name|iq
operator|->
name|flush_index
operator|=
literal|0
expr_stmt|;
name|iq
operator|->
name|last_db_time
operator|=
literal|0
expr_stmt|;
name|iq
operator|->
name|db_timeout
operator|=
operator|(
name|uint32_t
operator|)
name|conf
operator|->
name|db_timeout
expr_stmt|;
name|atomic_store_rel_int
argument_list|(
operator|&
name|iq
operator|->
name|instr_pending
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Initialize the lock for this instruction queue */
name|mtx_init
argument_list|(
operator|&
name|iq
operator|->
name|lock
argument_list|,
literal|"Tx_lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|iq
operator|->
name|post_lock
argument_list|,
literal|"iq_post_lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|iq
operator|->
name|enq_lock
argument_list|,
literal|"enq_lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|iq
operator|->
name|iq_flush_running_lock
argument_list|,
literal|"iq_flush_running_lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|oct
operator|->
name|io_qmask
operator|.
name|iq
operator||=
name|BIT_ULL
argument_list|(
name|iq_no
argument_list|)
expr_stmt|;
comment|/* Set the 32B/64B mode for each input queue */
name|oct
operator|->
name|io_qmask
operator|.
name|iq64B
operator||=
operator|(
operator|(
name|conf
operator|->
name|instr_type
operator|==
literal|64
operator|)
operator|<<
name|iq_no
operator|)
expr_stmt|;
name|iq
operator|->
name|iqcmd_64B
operator|=
operator|(
name|conf
operator|->
name|instr_type
operator|==
literal|64
operator|)
expr_stmt|;
name|oct
operator|->
name|fn_list
operator|.
name|setup_iq_regs
argument_list|(
name|oct
argument_list|,
name|iq_no
argument_list|)
expr_stmt|;
name|db_tq
operator|=
operator|&
name|oct
operator|->
name|check_db_tq
index|[
name|iq_no
index|]
expr_stmt|;
name|db_tq
operator|->
name|tq
operator|=
name|taskqueue_create
argument_list|(
literal|"lio_check_db_timeout"
argument_list|,
name|M_WAITOK
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|db_tq
operator|->
name|tq
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_tq
operator|->
name|tq
operator|==
name|NULL
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"check db wq create failed for iq %d\n"
argument_list|,
name|iq_no
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|TIMEOUT_TASK_INIT
argument_list|(
name|db_tq
operator|->
name|tq
argument_list|,
operator|&
name|db_tq
operator|->
name|work
argument_list|,
literal|0
argument_list|,
name|lio_check_db_timeout
argument_list|,
operator|(
name|void
operator|*
operator|)
name|db_tq
argument_list|)
expr_stmt|;
name|db_tq
operator|->
name|ctxul
operator|=
name|iq_no
expr_stmt|;
name|db_tq
operator|->
name|ctxptr
operator|=
name|oct
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|db_tq
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"lio%d_check_db_timeout:%d"
argument_list|,
name|oct
operator|->
name|octeon_id
argument_list|,
name|iq_no
argument_list|)
expr_stmt|;
name|taskqueue_enqueue_timeout
argument_list|(
name|db_tq
operator|->
name|tq
argument_list|,
operator|&
name|db_tq
operator|->
name|work
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Allocate a buf ring */
name|oct
operator|->
name|instr_queue
index|[
name|iq_no
index|]
operator|->
name|br
operator|=
name|buf_ring_alloc
argument_list|(
name|LIO_BR_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|,
operator|&
name|oct
operator|->
name|instr_queue
index|[
name|iq_no
index|]
operator|->
name|enq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|oct
operator|->
name|instr_queue
index|[
name|iq_no
index|]
operator|->
name|br
operator|==
name|NULL
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Critical Failure setting up buf ring\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lio_delete_instr_queue
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|uint32_t
name|iq_no
parameter_list|)
block|{
name|struct
name|lio_instr_queue
modifier|*
name|iq
init|=
name|oct
operator|->
name|instr_queue
index|[
name|iq_no
index|]
decl_stmt|;
name|struct
name|lio_request_list
modifier|*
name|request_buf
decl_stmt|;
name|struct
name|lio_mbuf_free_info
modifier|*
name|finfo
decl_stmt|;
name|uint64_t
name|desc_size
init|=
literal|0
decl_stmt|,
name|q_size
decl_stmt|;
name|int
name|i
decl_stmt|;
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"%s[%d]\n"
argument_list|,
name|__func__
argument_list|,
name|iq_no
argument_list|)
expr_stmt|;
if|if
condition|(
name|oct
operator|->
name|check_db_tq
index|[
name|iq_no
index|]
operator|.
name|tq
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|taskqueue_cancel_timeout
argument_list|(
name|oct
operator|->
name|check_db_tq
index|[
name|iq_no
index|]
operator|.
name|tq
argument_list|,
operator|&
name|oct
operator|->
name|check_db_tq
index|[
name|iq_no
index|]
operator|.
name|work
argument_list|,
name|NULL
argument_list|)
condition|)
name|taskqueue_drain_timeout
argument_list|(
name|oct
operator|->
name|check_db_tq
index|[
name|iq_no
index|]
operator|.
name|tq
argument_list|,
operator|&
name|oct
operator|->
name|check_db_tq
index|[
name|iq_no
index|]
operator|.
name|work
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|oct
operator|->
name|check_db_tq
index|[
name|iq_no
index|]
operator|.
name|tq
argument_list|)
expr_stmt|;
name|oct
operator|->
name|check_db_tq
index|[
name|iq_no
index|]
operator|.
name|tq
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|LIO_CN23XX_PF
argument_list|(
name|oct
argument_list|)
condition|)
name|desc_size
operator|=
name|LIO_GET_IQ_INSTR_TYPE_CFG
argument_list|(
name|LIO_CHIP_CONF
argument_list|(
name|oct
argument_list|,
name|cn23xx_pf
argument_list|)
argument_list|)
expr_stmt|;
name|request_buf
operator|=
name|iq
operator|->
name|request_list
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iq
operator|->
name|max_count
condition|;
name|i
operator|++
operator|,
name|request_buf
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|request_buf
operator|->
name|reqtype
operator|==
name|LIO_REQTYPE_NORESP_NET
operator|)
operator|||
operator|(
name|request_buf
operator|->
name|reqtype
operator|==
name|LIO_REQTYPE_NORESP_NET_SG
operator|)
condition|)
block|{
if|if
condition|(
name|request_buf
operator|->
name|buf
operator|!=
name|NULL
condition|)
block|{
name|finfo
operator|=
name|request_buf
operator|->
name|buf
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|iq
operator|->
name|txtag
argument_list|,
name|request_buf
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|iq
operator|->
name|txtag
argument_list|,
name|request_buf
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|finfo
operator|->
name|mb
argument_list|)
expr_stmt|;
name|request_buf
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|request_buf
operator|->
name|map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|iq
operator|->
name|txtag
argument_list|,
name|request_buf
operator|->
name|map
argument_list|)
expr_stmt|;
name|request_buf
operator|->
name|map
operator|=
name|NULL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|request_buf
operator|->
name|map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|iq
operator|->
name|txtag
argument_list|,
name|request_buf
operator|->
name|map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|iq
operator|->
name|txtag
argument_list|,
name|request_buf
operator|->
name|map
argument_list|)
expr_stmt|;
name|request_buf
operator|->
name|map
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|iq
operator|->
name|br
operator|!=
name|NULL
condition|)
block|{
name|buf_ring_free
argument_list|(
name|iq
operator|->
name|br
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|iq
operator|->
name|br
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|iq
operator|->
name|request_list
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|iq
operator|->
name|request_list
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|iq
operator|->
name|request_list
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|iq
operator|->
name|txtag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|iq
operator|->
name|txtag
argument_list|)
expr_stmt|;
name|iq
operator|->
name|txtag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|iq
operator|->
name|base_addr
condition|)
block|{
name|q_size
operator|=
name|iq
operator|->
name|max_count
operator|*
name|desc_size
expr_stmt|;
name|lio_dma_free
argument_list|(
operator|(
name|uint32_t
operator|)
name|q_size
argument_list|,
name|iq
operator|->
name|base_addr
argument_list|)
expr_stmt|;
name|oct
operator|->
name|io_qmask
operator|.
name|iq
operator|&=
operator|~
operator|(
literal|1ULL
operator|<<
name|iq_no
operator|)
expr_stmt|;
name|bzero
argument_list|(
name|oct
operator|->
name|instr_queue
index|[
name|iq_no
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lio_instr_queue
argument_list|)
argument_list|)
expr_stmt|;
name|oct
operator|->
name|num_iqs
operator|--
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 0 on success, 1 on failure */
end_comment

begin_function
name|int
name|lio_setup_iq
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|int
name|ifidx
parameter_list|,
name|int
name|q_index
parameter_list|,
name|union
name|octeon_txpciq
name|txpciq
parameter_list|,
name|uint32_t
name|num_descs
parameter_list|)
block|{
name|uint32_t
name|iq_no
init|=
operator|(
name|uint32_t
operator|)
name|txpciq
operator|.
name|s
operator|.
name|q_no
decl_stmt|;
if|if
condition|(
name|oct
operator|->
name|instr_queue
index|[
name|iq_no
index|]
operator|->
name|oct_dev
operator|!=
name|NULL
condition|)
block|{
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"IQ is in use. Cannot create the IQ: %d again\n"
argument_list|,
name|iq_no
argument_list|)
expr_stmt|;
name|oct
operator|->
name|instr_queue
index|[
name|iq_no
index|]
operator|->
name|txpciq
operator|.
name|txpciq64
operator|=
name|txpciq
operator|.
name|txpciq64
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|oct
operator|->
name|instr_queue
index|[
name|iq_no
index|]
operator|->
name|q_index
operator|=
name|q_index
expr_stmt|;
name|oct
operator|->
name|instr_queue
index|[
name|iq_no
index|]
operator|->
name|ifidx
operator|=
name|ifidx
expr_stmt|;
if|if
condition|(
name|lio_init_instr_queue
argument_list|(
name|oct
argument_list|,
name|txpciq
argument_list|,
name|num_descs
argument_list|)
condition|)
block|{
name|lio_delete_instr_queue
argument_list|(
name|oct
argument_list|,
name|iq_no
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|oct
operator|->
name|num_iqs
operator|++
expr_stmt|;
if|if
condition|(
name|oct
operator|->
name|fn_list
operator|.
name|enable_io_queues
argument_list|(
name|oct
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lio_wait_for_instr_fetch
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|retry
init|=
literal|1000
decl_stmt|,
name|pending
decl_stmt|,
name|instr_cnt
init|=
literal|0
decl_stmt|;
do|do
block|{
name|instr_cnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LIO_MAX_INSTR_QUEUES
argument_list|(
name|oct
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|oct
operator|->
name|io_qmask
operator|.
name|iq
operator|&
name|BIT_ULL
argument_list|(
name|i
argument_list|)
operator|)
condition|)
continue|continue;
name|pending
operator|=
name|atomic_load_acq_int
argument_list|(
operator|&
name|oct
operator|->
name|instr_queue
index|[
name|i
index|]
operator|->
name|instr_pending
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending
condition|)
name|__lio_check_db_timeout
argument_list|(
name|oct
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|instr_cnt
operator|+=
name|pending
expr_stmt|;
block|}
if|if
condition|(
name|instr_cnt
operator|==
literal|0
condition|)
break|break;
name|lio_sleep_timeout
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|retry
operator|--
operator|&&
name|instr_cnt
condition|)
do|;
return|return
operator|(
name|instr_cnt
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|lio_ring_doorbell
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|struct
name|lio_instr_queue
modifier|*
name|iq
parameter_list|)
block|{
if|if
condition|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|oct
operator|->
name|status
argument_list|)
operator|==
name|LIO_DEV_RUNNING
condition|)
block|{
name|lio_write_csr32
argument_list|(
name|oct
argument_list|,
name|iq
operator|->
name|doorbell_reg
argument_list|,
name|iq
operator|->
name|fill_cnt
argument_list|)
expr_stmt|;
comment|/* make sure doorbell write goes through */
name|__compiler_membar
argument_list|()
expr_stmt|;
name|iq
operator|->
name|fill_cnt
operator|=
literal|0
expr_stmt|;
name|iq
operator|->
name|last_db_time
operator|=
name|ticks
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|__lio_copy_cmd_into_iq
parameter_list|(
name|struct
name|lio_instr_queue
modifier|*
name|iq
parameter_list|,
name|uint8_t
modifier|*
name|cmd
parameter_list|)
block|{
name|uint8_t
modifier|*
name|iqptr
decl_stmt|,
name|cmdsize
decl_stmt|;
name|cmdsize
operator|=
operator|(
operator|(
name|iq
operator|->
name|iqcmd_64B
operator|)
condition|?
literal|64
else|:
literal|32
operator|)
expr_stmt|;
name|iqptr
operator|=
name|iq
operator|->
name|base_addr
operator|+
operator|(
name|cmdsize
operator|*
name|iq
operator|->
name|host_write_index
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|iqptr
argument_list|,
name|cmd
argument_list|,
name|cmdsize
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|lio_iq_post_status
name|__lio_post_command2
parameter_list|(
name|struct
name|lio_instr_queue
modifier|*
name|iq
parameter_list|,
name|uint8_t
modifier|*
name|cmd
parameter_list|)
block|{
name|struct
name|lio_iq_post_status
name|st
decl_stmt|;
name|st
operator|.
name|status
operator|=
name|LIO_IQ_SEND_OK
expr_stmt|;
comment|/* 	 * This ensures that the read index does not wrap around to the same 	 * position if queue gets full before Octeon could fetch any instr. 	 */
if|if
condition|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|iq
operator|->
name|instr_pending
argument_list|)
operator|>=
call|(
name|int32_t
call|)
argument_list|(
name|iq
operator|->
name|max_count
operator|-
literal|1
argument_list|)
condition|)
block|{
name|st
operator|.
name|status
operator|=
name|LIO_IQ_SEND_FAILED
expr_stmt|;
name|st
operator|.
name|index
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|st
operator|)
return|;
block|}
if|if
condition|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|iq
operator|->
name|instr_pending
argument_list|)
operator|>=
call|(
name|int32_t
call|)
argument_list|(
name|iq
operator|->
name|max_count
operator|-
literal|2
argument_list|)
condition|)
name|st
operator|.
name|status
operator|=
name|LIO_IQ_SEND_STOP
expr_stmt|;
name|__lio_copy_cmd_into_iq
argument_list|(
name|iq
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
comment|/* "index" is returned, host_write_index is modified. */
name|st
operator|.
name|index
operator|=
name|iq
operator|->
name|host_write_index
expr_stmt|;
name|iq
operator|->
name|host_write_index
operator|=
name|lio_incr_index
argument_list|(
name|iq
operator|->
name|host_write_index
argument_list|,
literal|1
argument_list|,
name|iq
operator|->
name|max_count
argument_list|)
expr_stmt|;
name|iq
operator|->
name|fill_cnt
operator|++
expr_stmt|;
comment|/* 	 * Flush the command into memory. We need to be sure the data is in 	 * memory before indicating that the instruction is pending. 	 */
name|wmb
argument_list|()
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|iq
operator|->
name|instr_pending
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|st
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|__lio_add_to_request_list
parameter_list|(
name|struct
name|lio_instr_queue
modifier|*
name|iq
parameter_list|,
name|int
name|idx
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|int
name|reqtype
parameter_list|)
block|{
name|iq
operator|->
name|request_list
index|[
name|idx
index|]
operator|.
name|buf
operator|=
name|buf
expr_stmt|;
name|iq
operator|->
name|request_list
index|[
name|idx
index|]
operator|.
name|reqtype
operator|=
name|reqtype
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Can only run in process context */
end_comment

begin_function
name|int
name|lio_process_iq_request_list
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|struct
name|lio_instr_queue
modifier|*
name|iq
parameter_list|,
name|uint32_t
name|budget
parameter_list|)
block|{
name|struct
name|lio_soft_command
modifier|*
name|sc
decl_stmt|;
name|struct
name|octeon_instr_irh
modifier|*
name|irh
init|=
name|NULL
decl_stmt|;
name|struct
name|lio_mbuf_free_info
modifier|*
name|finfo
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|uint32_t
name|inst_count
init|=
literal|0
decl_stmt|;
name|uint32_t
name|old
init|=
name|iq
operator|->
name|flush_index
decl_stmt|;
name|int
name|reqtype
decl_stmt|;
while|while
condition|(
name|old
operator|!=
name|iq
operator|->
name|octeon_read_index
condition|)
block|{
name|reqtype
operator|=
name|iq
operator|->
name|request_list
index|[
name|old
index|]
operator|.
name|reqtype
expr_stmt|;
name|buf
operator|=
name|iq
operator|->
name|request_list
index|[
name|old
index|]
operator|.
name|buf
expr_stmt|;
name|finfo
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|reqtype
operator|==
name|LIO_REQTYPE_NONE
condition|)
goto|goto
name|skip_this
goto|;
switch|switch
condition|(
name|reqtype
condition|)
block|{
case|case
name|LIO_REQTYPE_NORESP_NET
case|:
name|lio_free_mbuf
argument_list|(
name|iq
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIO_REQTYPE_NORESP_NET_SG
case|:
name|lio_free_sgmbuf
argument_list|(
name|iq
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIO_REQTYPE_RESP_NET
case|:
case|case
name|LIO_REQTYPE_SOFT_COMMAND
case|:
name|sc
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|LIO_CN23XX_PF
argument_list|(
name|oct
argument_list|)
condition|)
name|irh
operator|=
operator|(
expr|struct
name|octeon_instr_irh
operator|*
operator|)
operator|&
name|sc
operator|->
name|cmd
operator|.
name|cmd3
operator|.
name|irh
expr_stmt|;
if|if
condition|(
name|irh
operator|->
name|rflag
condition|)
block|{
comment|/* 				 * We're expecting a response from Octeon. 				 * It's up to lio_process_ordered_list() to 				 * process  sc. Add sc to the ordered soft 				 * command response list because we expect 				 * a response from Octeon. 				 */
name|mtx_lock
argument_list|(
operator|&
name|oct
operator|->
name|response_list
index|[
name|LIO_ORDERED_SC_LIST
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|oct
operator|->
name|response_list
index|[
name|LIO_ORDERED_SC_LIST
index|]
operator|.
name|pending_req_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|oct
operator|->
name|response_list
index|[
name|LIO_ORDERED_SC_LIST
index|]
operator|.
name|head
argument_list|,
operator|&
name|sc
operator|->
name|node
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|oct
operator|->
name|response_list
index|[
name|LIO_ORDERED_SC_LIST
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|callback
operator|!=
name|NULL
condition|)
block|{
comment|/* This callback must not sleep */
name|sc
operator|->
name|callback
argument_list|(
name|oct
argument_list|,
name|LIO_REQUEST_DONE
argument_list|,
name|sc
operator|->
name|callback_arg
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"%s Unknown reqtype: %d buf: %p at idx %d\n"
argument_list|,
name|__func__
argument_list|,
name|reqtype
argument_list|,
name|buf
argument_list|,
name|old
argument_list|)
expr_stmt|;
block|}
name|iq
operator|->
name|request_list
index|[
name|old
index|]
operator|.
name|buf
operator|=
name|NULL
expr_stmt|;
name|iq
operator|->
name|request_list
index|[
name|old
index|]
operator|.
name|reqtype
operator|=
literal|0
expr_stmt|;
name|skip_this
label|:
name|inst_count
operator|++
expr_stmt|;
name|old
operator|=
name|lio_incr_index
argument_list|(
name|old
argument_list|,
literal|1
argument_list|,
name|iq
operator|->
name|max_count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|budget
operator|)
operator|&&
operator|(
name|inst_count
operator|>=
name|budget
operator|)
condition|)
break|break;
block|}
name|iq
operator|->
name|flush_index
operator|=
name|old
expr_stmt|;
return|return
operator|(
name|inst_count
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Can only be called from process context */
end_comment

begin_function
name|int
name|lio_flush_iq
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|struct
name|lio_instr_queue
modifier|*
name|iq
parameter_list|,
name|uint32_t
name|budget
parameter_list|)
block|{
name|uint32_t
name|inst_processed
init|=
literal|0
decl_stmt|;
name|uint32_t
name|tot_inst_processed
init|=
literal|0
decl_stmt|;
name|int
name|tx_done
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|mtx_trylock
argument_list|(
operator|&
name|iq
operator|->
name|iq_flush_running_lock
argument_list|)
condition|)
return|return
operator|(
name|tx_done
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|iq
operator|->
name|lock
argument_list|)
expr_stmt|;
name|iq
operator|->
name|octeon_read_index
operator|=
name|oct
operator|->
name|fn_list
operator|.
name|update_iq_read_idx
argument_list|(
name|iq
argument_list|)
expr_stmt|;
do|do
block|{
comment|/* Process any outstanding IQ packets. */
if|if
condition|(
name|iq
operator|->
name|flush_index
operator|==
name|iq
operator|->
name|octeon_read_index
condition|)
break|break;
if|if
condition|(
name|budget
condition|)
name|inst_processed
operator|=
name|lio_process_iq_request_list
argument_list|(
name|oct
argument_list|,
name|iq
argument_list|,
name|budget
operator|-
name|tot_inst_processed
argument_list|)
expr_stmt|;
else|else
name|inst_processed
operator|=
name|lio_process_iq_request_list
argument_list|(
name|oct
argument_list|,
name|iq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst_processed
condition|)
block|{
name|atomic_subtract_int
argument_list|(
operator|&
name|iq
operator|->
name|instr_pending
argument_list|,
name|inst_processed
argument_list|)
expr_stmt|;
name|iq
operator|->
name|stats
operator|.
name|instr_processed
operator|+=
name|inst_processed
expr_stmt|;
block|}
name|tot_inst_processed
operator|+=
name|inst_processed
expr_stmt|;
name|inst_processed
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
name|tot_inst_processed
operator|<
name|budget
condition|)
do|;
if|if
condition|(
name|budget
operator|&&
operator|(
name|tot_inst_processed
operator|>=
name|budget
operator|)
condition|)
name|tx_done
operator|=
literal|0
expr_stmt|;
name|iq
operator|->
name|last_db_time
operator|=
name|ticks
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|iq
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|iq
operator|->
name|iq_flush_running_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|tx_done
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process instruction queue after timeout.  * This routine gets called from a taskqueue or when removing the module.  */
end_comment

begin_function
specifier|static
name|void
name|__lio_check_db_timeout
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|uint64_t
name|iq_no
parameter_list|)
block|{
name|struct
name|lio_instr_queue
modifier|*
name|iq
decl_stmt|;
name|uint64_t
name|next_time
decl_stmt|;
if|if
condition|(
name|oct
operator|==
name|NULL
condition|)
return|return;
name|iq
operator|=
name|oct
operator|->
name|instr_queue
index|[
name|iq_no
index|]
expr_stmt|;
if|if
condition|(
name|iq
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|iq
operator|->
name|instr_pending
argument_list|)
condition|)
block|{
comment|/* If ticks - last_db_time< db_timeout do nothing  */
name|next_time
operator|=
name|iq
operator|->
name|last_db_time
operator|+
name|lio_ms_to_ticks
argument_list|(
name|iq
operator|->
name|db_timeout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lio_check_timeout
argument_list|(
name|ticks
argument_list|,
name|next_time
argument_list|)
condition|)
return|return;
name|iq
operator|->
name|last_db_time
operator|=
name|ticks
expr_stmt|;
comment|/* Flush the instruction queue */
name|lio_flush_iq
argument_list|(
name|oct
argument_list|,
name|iq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lio_enable_irq
argument_list|(
name|NULL
argument_list|,
name|iq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oct
operator|->
name|props
operator|.
name|ifp
operator|!=
name|NULL
operator|&&
name|iq
operator|->
name|br
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|mtx_trylock
argument_list|(
operator|&
name|iq
operator|->
name|enq_lock
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|drbr_empty
argument_list|(
name|oct
operator|->
name|props
operator|.
name|ifp
argument_list|,
name|iq
operator|->
name|br
argument_list|)
condition|)
name|lio_mq_start_locked
argument_list|(
name|oct
operator|->
name|props
operator|.
name|ifp
argument_list|,
name|iq
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|iq
operator|->
name|enq_lock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Called by the Poll thread at regular intervals to check the instruction  * queue for commands to be posted and for commands that were fetched by Octeon.  */
end_comment

begin_function
specifier|static
name|void
name|lio_check_db_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|lio_tq
modifier|*
name|db_tq
init|=
operator|(
expr|struct
name|lio_tq
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|octeon_device
modifier|*
name|oct
init|=
name|db_tq
operator|->
name|ctxptr
decl_stmt|;
name|uint64_t
name|iq_no
init|=
name|db_tq
operator|->
name|ctxul
decl_stmt|;
name|uint32_t
name|delay
init|=
literal|10
decl_stmt|;
name|__lio_check_db_timeout
argument_list|(
name|oct
argument_list|,
name|iq_no
argument_list|)
expr_stmt|;
name|taskqueue_enqueue_timeout
argument_list|(
name|db_tq
operator|->
name|tq
argument_list|,
operator|&
name|db_tq
operator|->
name|work
argument_list|,
name|lio_ms_to_ticks
argument_list|(
name|delay
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|lio_send_command
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|uint32_t
name|iq_no
parameter_list|,
name|uint32_t
name|force_db
parameter_list|,
name|void
modifier|*
name|cmd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|uint32_t
name|datasize
parameter_list|,
name|uint32_t
name|reqtype
parameter_list|)
block|{
name|struct
name|lio_iq_post_status
name|st
decl_stmt|;
name|struct
name|lio_instr_queue
modifier|*
name|iq
init|=
name|oct
operator|->
name|instr_queue
index|[
name|iq_no
index|]
decl_stmt|;
comment|/* 	 * Get the lock and prevent other tasks and tx interrupt handler 	 * from running. 	 */
name|mtx_lock
argument_list|(
operator|&
name|iq
operator|->
name|post_lock
argument_list|)
expr_stmt|;
name|st
operator|=
name|__lio_post_command2
argument_list|(
name|iq
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|.
name|status
operator|!=
name|LIO_IQ_SEND_FAILED
condition|)
block|{
name|__lio_add_to_request_list
argument_list|(
name|iq
argument_list|,
name|st
operator|.
name|index
argument_list|,
name|buf
argument_list|,
name|reqtype
argument_list|)
expr_stmt|;
name|LIO_INCR_INSTRQUEUE_PKT_COUNT
argument_list|(
name|oct
argument_list|,
name|iq_no
argument_list|,
name|bytes_sent
argument_list|,
name|datasize
argument_list|)
expr_stmt|;
name|LIO_INCR_INSTRQUEUE_PKT_COUNT
argument_list|(
name|oct
argument_list|,
name|iq_no
argument_list|,
name|instr_posted
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|force_db
operator|||
operator|(
name|st
operator|.
name|status
operator|==
name|LIO_IQ_SEND_STOP
operator|)
condition|)
name|lio_ring_doorbell
argument_list|(
name|oct
argument_list|,
name|iq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LIO_INCR_INSTRQUEUE_PKT_COUNT
argument_list|(
name|oct
argument_list|,
name|iq_no
argument_list|,
name|instr_dropped
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|iq
operator|->
name|post_lock
argument_list|)
expr_stmt|;
comment|/* 	 * This is only done here to expedite packets being flushed for 	 * cases where there are no IQ completion interrupts. 	 */
return|return
operator|(
name|st
operator|.
name|status
operator|)
return|;
block|}
end_function

begin_function
name|void
name|lio_prepare_soft_command
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|struct
name|lio_soft_command
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|opcode
parameter_list|,
name|uint8_t
name|subcode
parameter_list|,
name|uint32_t
name|irh_ossp
parameter_list|,
name|uint64_t
name|ossp0
parameter_list|,
name|uint64_t
name|ossp1
parameter_list|)
block|{
name|struct
name|lio_config
modifier|*
name|lio_cfg
decl_stmt|;
name|struct
name|octeon_instr_ih3
modifier|*
name|ih3
decl_stmt|;
name|struct
name|octeon_instr_pki_ih3
modifier|*
name|pki_ih3
decl_stmt|;
name|struct
name|octeon_instr_irh
modifier|*
name|irh
decl_stmt|;
name|struct
name|octeon_instr_rdp
modifier|*
name|rdp
decl_stmt|;
name|KASSERT
argument_list|(
name|opcode
operator|<=
literal|15
argument_list|,
operator|(
literal|"%s, %d, opcode> 15"
operator|,
name|__func__
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|subcode
operator|<=
literal|127
argument_list|,
operator|(
literal|"%s, %d, opcode> 127"
operator|,
name|__func__
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|lio_cfg
operator|=
name|lio_get_conf
argument_list|(
name|oct
argument_list|)
expr_stmt|;
if|if
condition|(
name|LIO_CN23XX_PF
argument_list|(
name|oct
argument_list|)
condition|)
block|{
name|ih3
operator|=
operator|(
expr|struct
name|octeon_instr_ih3
operator|*
operator|)
operator|&
name|sc
operator|->
name|cmd
operator|.
name|cmd3
operator|.
name|ih3
expr_stmt|;
name|ih3
operator|->
name|pkind
operator|=
name|oct
operator|->
name|instr_queue
index|[
name|sc
operator|->
name|iq_no
index|]
operator|->
name|txpciq
operator|.
name|s
operator|.
name|pkind
expr_stmt|;
name|pki_ih3
operator|=
operator|(
expr|struct
name|octeon_instr_pki_ih3
operator|*
operator|)
operator|&
name|sc
operator|->
name|cmd
operator|.
name|cmd3
operator|.
name|pki_ih3
expr_stmt|;
name|pki_ih3
operator|->
name|w
operator|=
literal|1
expr_stmt|;
name|pki_ih3
operator|->
name|raw
operator|=
literal|1
expr_stmt|;
name|pki_ih3
operator|->
name|utag
operator|=
literal|1
expr_stmt|;
name|pki_ih3
operator|->
name|uqpg
operator|=
name|oct
operator|->
name|instr_queue
index|[
name|sc
operator|->
name|iq_no
index|]
operator|->
name|txpciq
operator|.
name|s
operator|.
name|use_qpg
expr_stmt|;
name|pki_ih3
operator|->
name|utt
operator|=
literal|1
expr_stmt|;
name|pki_ih3
operator|->
name|tag
operator|=
name|LIO_CONTROL
expr_stmt|;
name|pki_ih3
operator|->
name|tagtype
operator|=
name|LIO_ATOMIC_TAG
expr_stmt|;
name|pki_ih3
operator|->
name|qpg
operator|=
name|oct
operator|->
name|instr_queue
index|[
name|sc
operator|->
name|iq_no
index|]
operator|->
name|txpciq
operator|.
name|s
operator|.
name|qpg
expr_stmt|;
name|pki_ih3
operator|->
name|pm
operator|=
literal|0x7
expr_stmt|;
name|pki_ih3
operator|->
name|sl
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|datasize
condition|)
name|ih3
operator|->
name|dlengsz
operator|=
name|sc
operator|->
name|datasize
expr_stmt|;
name|irh
operator|=
operator|(
expr|struct
name|octeon_instr_irh
operator|*
operator|)
operator|&
name|sc
operator|->
name|cmd
operator|.
name|cmd3
operator|.
name|irh
expr_stmt|;
name|irh
operator|->
name|opcode
operator|=
name|opcode
expr_stmt|;
name|irh
operator|->
name|subcode
operator|=
name|subcode
expr_stmt|;
comment|/* opcode/subcode specific parameters (ossp) */
name|irh
operator|->
name|ossp
operator|=
name|irh_ossp
expr_stmt|;
name|sc
operator|->
name|cmd
operator|.
name|cmd3
operator|.
name|ossp
index|[
literal|0
index|]
operator|=
name|ossp0
expr_stmt|;
name|sc
operator|->
name|cmd
operator|.
name|cmd3
operator|.
name|ossp
index|[
literal|1
index|]
operator|=
name|ossp1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rdatasize
condition|)
block|{
name|rdp
operator|=
operator|(
expr|struct
name|octeon_instr_rdp
operator|*
operator|)
operator|&
name|sc
operator|->
name|cmd
operator|.
name|cmd3
operator|.
name|rdp
expr_stmt|;
name|rdp
operator|->
name|pcie_port
operator|=
name|oct
operator|->
name|pcie_port
expr_stmt|;
name|rdp
operator|->
name|rlen
operator|=
name|sc
operator|->
name|rdatasize
expr_stmt|;
name|irh
operator|->
name|rflag
operator|=
literal|1
expr_stmt|;
comment|/* PKI IH3 */
comment|/* pki_ih3 irh+ossp[0]+ossp[1]+rdp+rptr = 48 bytes */
name|ih3
operator|->
name|fsz
operator|=
name|LIO_SOFTCMDRESP_IH3
expr_stmt|;
block|}
else|else
block|{
name|irh
operator|->
name|rflag
operator|=
literal|0
expr_stmt|;
comment|/* PKI IH3 */
comment|/* pki_h3 + irh + ossp[0] + ossp[1] = 32 bytes */
name|ih3
operator|->
name|fsz
operator|=
name|LIO_PCICMD_O3
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|lio_send_soft_command
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|struct
name|lio_soft_command
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|octeon_instr_ih3
modifier|*
name|ih3
decl_stmt|;
name|struct
name|octeon_instr_irh
modifier|*
name|irh
decl_stmt|;
name|uint32_t
name|len
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|LIO_CN23XX_PF
argument_list|(
name|oct
argument_list|)
condition|)
block|{
name|ih3
operator|=
operator|(
expr|struct
name|octeon_instr_ih3
operator|*
operator|)
operator|&
name|sc
operator|->
name|cmd
operator|.
name|cmd3
operator|.
name|ih3
expr_stmt|;
if|if
condition|(
name|ih3
operator|->
name|dlengsz
condition|)
block|{
name|KASSERT
argument_list|(
name|sc
operator|->
name|dmadptr
argument_list|,
operator|(
literal|"%s, %d, sc->dmadptr is NULL"
operator|,
name|__func__
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cmd
operator|.
name|cmd3
operator|.
name|dptr
operator|=
name|sc
operator|->
name|dmadptr
expr_stmt|;
block|}
name|irh
operator|=
operator|(
expr|struct
name|octeon_instr_irh
operator|*
operator|)
operator|&
name|sc
operator|->
name|cmd
operator|.
name|cmd3
operator|.
name|irh
expr_stmt|;
if|if
condition|(
name|irh
operator|->
name|rflag
condition|)
block|{
name|KASSERT
argument_list|(
name|sc
operator|->
name|dmarptr
argument_list|,
operator|(
literal|"%s, %d, sc->dmarptr is NULL"
operator|,
name|__func__
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|status_word
argument_list|,
operator|(
literal|"%s, %d, sc->status_word is NULL"
operator|,
name|__func__
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
operator|*
name|sc
operator|->
name|status_word
operator|=
name|COMPLETION_WORD_INIT
expr_stmt|;
name|sc
operator|->
name|cmd
operator|.
name|cmd3
operator|.
name|rptr
operator|=
name|sc
operator|->
name|dmarptr
expr_stmt|;
block|}
name|len
operator|=
operator|(
name|uint32_t
operator|)
name|ih3
operator|->
name|dlengsz
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|wait_time
condition|)
name|sc
operator|->
name|timeout
operator|=
name|ticks
operator|+
name|lio_ms_to_ticks
argument_list|(
name|sc
operator|->
name|wait_time
argument_list|)
expr_stmt|;
return|return
operator|(
name|lio_send_command
argument_list|(
name|oct
argument_list|,
name|sc
operator|->
name|iq_no
argument_list|,
literal|1
argument_list|,
operator|&
name|sc
operator|->
name|cmd
argument_list|,
name|sc
argument_list|,
name|len
argument_list|,
name|LIO_REQTYPE_SOFT_COMMAND
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lio_setup_sc_buffer_pool
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
name|struct
name|lio_soft_command
modifier|*
name|sc
decl_stmt|;
name|uint64_t
name|dma_addr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|oct
operator|->
name|sc_buf_pool
operator|.
name|head
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|oct
operator|->
name|sc_buf_pool
operator|.
name|lock
argument_list|,
literal|"sc_pool_lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|atomic_store_rel_int
argument_list|(
operator|&
name|oct
operator|->
name|sc_buf_pool
operator|.
name|alloc_buf_count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LIO_MAX_SOFT_COMMAND_BUFFERS
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|=
operator|(
expr|struct
name|lio_soft_command
operator|*
operator|)
name|lio_dma_alloc
argument_list|(
name|LIO_SOFT_COMMAND_BUFFER_SIZE
argument_list|,
operator|&
name|dma_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|lio_free_sc_buffer_pool
argument_list|(
name|oct
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|sc
operator|->
name|dma_addr
operator|=
name|dma_addr
expr_stmt|;
name|sc
operator|->
name|size
operator|=
name|LIO_SOFT_COMMAND_BUFFER_SIZE
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|oct
operator|->
name|sc_buf_pool
operator|.
name|head
argument_list|,
operator|&
name|sc
operator|->
name|node
argument_list|,
name|entries
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lio_free_sc_buffer_pool
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
name|struct
name|lio_stailq_node
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|tmp2
decl_stmt|;
name|struct
name|lio_soft_command
modifier|*
name|sc
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|oct
operator|->
name|sc_buf_pool
operator|.
name|lock
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|tmp
argument_list|,
argument|&oct->sc_buf_pool.head
argument_list|,
argument|entries
argument_list|,
argument|tmp2
argument_list|)
block|{
name|sc
operator|=
name|LIO_STAILQ_FIRST_ENTRY
argument_list|(
operator|&
name|oct
operator|->
name|sc_buf_pool
operator|.
name|head
argument_list|,
expr|struct
name|lio_soft_command
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|oct
operator|->
name|sc_buf_pool
operator|.
name|head
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|lio_dma_free
argument_list|(
name|sc
operator|->
name|size
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
name|STAILQ_INIT
argument_list|(
operator|&
name|oct
operator|->
name|sc_buf_pool
operator|.
name|head
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|oct
operator|->
name|sc_buf_pool
operator|.
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|lio_soft_command
modifier|*
name|lio_alloc_soft_command
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|uint32_t
name|datasize
parameter_list|,
name|uint32_t
name|rdatasize
parameter_list|,
name|uint32_t
name|ctxsize
parameter_list|)
block|{
name|struct
name|lio_soft_command
modifier|*
name|sc
init|=
name|NULL
decl_stmt|;
name|struct
name|lio_stailq_node
modifier|*
name|tmp
decl_stmt|;
name|uint64_t
name|dma_addr
decl_stmt|;
name|uint32_t
name|size
decl_stmt|;
name|uint32_t
name|offset
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|lio_soft_command
argument_list|)
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|offset
operator|+
name|datasize
operator|+
name|rdatasize
operator|+
name|ctxsize
operator|)
operator|<=
name|LIO_SOFT_COMMAND_BUFFER_SIZE
argument_list|,
operator|(
literal|"%s, %d, offset + datasize + rdatasize + ctxsize> LIO_SOFT_COMMAND_BUFFER_SIZE"
operator|,
name|__func__
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|oct
operator|->
name|sc_buf_pool
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|STAILQ_EMPTY
argument_list|(
operator|&
name|oct
operator|->
name|sc_buf_pool
operator|.
name|head
argument_list|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|oct
operator|->
name|sc_buf_pool
operator|.
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|tmp
operator|=
name|STAILQ_LAST
argument_list|(
operator|&
name|oct
operator|->
name|sc_buf_pool
operator|.
name|head
argument_list|,
name|lio_stailq_node
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE
argument_list|(
operator|&
name|oct
operator|->
name|sc_buf_pool
operator|.
name|head
argument_list|,
name|tmp
argument_list|,
name|lio_stailq_node
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|oct
operator|->
name|sc_buf_pool
operator|.
name|alloc_buf_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|oct
operator|->
name|sc_buf_pool
operator|.
name|lock
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|lio_soft_command
operator|*
operator|)
name|tmp
expr_stmt|;
name|dma_addr
operator|=
name|sc
operator|->
name|dma_addr
expr_stmt|;
name|size
operator|=
name|sc
operator|->
name|size
expr_stmt|;
name|bzero
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|size
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dma_addr
operator|=
name|dma_addr
expr_stmt|;
name|sc
operator|->
name|size
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|ctxsize
condition|)
block|{
name|sc
operator|->
name|ctxptr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|sc
operator|+
name|offset
expr_stmt|;
name|sc
operator|->
name|ctxsize
operator|=
name|ctxsize
expr_stmt|;
block|}
comment|/* Start data at 128 byte boundary */
name|offset
operator|=
operator|(
name|offset
operator|+
name|ctxsize
operator|+
literal|127
operator|)
operator|&
literal|0xffffff80
expr_stmt|;
if|if
condition|(
name|datasize
condition|)
block|{
name|sc
operator|->
name|virtdptr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|sc
operator|+
name|offset
expr_stmt|;
name|sc
operator|->
name|dmadptr
operator|=
name|dma_addr
operator|+
name|offset
expr_stmt|;
name|sc
operator|->
name|datasize
operator|=
name|datasize
expr_stmt|;
block|}
comment|/* Start rdata at 128 byte boundary */
name|offset
operator|=
operator|(
name|offset
operator|+
name|datasize
operator|+
literal|127
operator|)
operator|&
literal|0xffffff80
expr_stmt|;
if|if
condition|(
name|rdatasize
condition|)
block|{
name|KASSERT
argument_list|(
name|rdatasize
operator|>=
literal|16
argument_list|,
operator|(
literal|"%s, %d, rdatasize< 16"
operator|,
name|__func__
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|virtrptr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|sc
operator|+
name|offset
expr_stmt|;
name|sc
operator|->
name|dmarptr
operator|=
name|dma_addr
operator|+
name|offset
expr_stmt|;
name|sc
operator|->
name|rdatasize
operator|=
name|rdatasize
expr_stmt|;
name|sc
operator|->
name|status_word
operator|=
operator|(
name|uint64_t
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|sc
operator|->
name|virtrptr
operator|)
operator|+
name|rdatasize
operator|-
literal|8
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|sc
operator|)
return|;
block|}
end_function

begin_function
name|void
name|lio_free_soft_command
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|struct
name|lio_soft_command
modifier|*
name|sc
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|oct
operator|->
name|sc_buf_pool
operator|.
name|lock
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|oct
operator|->
name|sc_buf_pool
operator|.
name|head
argument_list|,
operator|&
name|sc
operator|->
name|node
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|oct
operator|->
name|sc_buf_pool
operator|.
name|alloc_buf_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|oct
operator|->
name|sc_buf_pool
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

