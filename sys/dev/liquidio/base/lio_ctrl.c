begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *   BSD LICENSE  *  *   Copyright(c) 2017 Cavium, Inc.. All rights reserved.  *   All rights reserved.  *  *   Redistribution and use in source and binary forms, with or without  *   modification, are permitted provided that the following conditions  *   are met:  *  *     * Redistributions of source code must retain the above copyright  *       notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above copyright  *       notice, this list of conditions and the following disclaimer in  *       the documentation and/or other materials provided with the  *       distribution.  *     * Neither the name of Cavium, Inc. nor the names of its  *       contributors may be used to endorse or promote products derived  *       from this software without specific prior written permission.  *  *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  *   OWNER(S) OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"lio_bsd.h"
end_include

begin_include
include|#
directive|include
file|"lio_common.h"
end_include

begin_include
include|#
directive|include
file|"lio_droq.h"
end_include

begin_include
include|#
directive|include
file|"lio_iq.h"
end_include

begin_include
include|#
directive|include
file|"lio_response_manager.h"
end_include

begin_include
include|#
directive|include
file|"lio_device.h"
end_include

begin_include
include|#
directive|include
file|"lio_ctrl.h"
end_include

begin_include
include|#
directive|include
file|"lio_main.h"
end_include

begin_function
name|int
name|lio_send_data_pkt
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|struct
name|lio_data_pkt
modifier|*
name|ndata
parameter_list|)
block|{
name|int
name|ring_doorbell
init|=
literal|1
decl_stmt|;
return|return
operator|(
name|lio_send_command
argument_list|(
name|oct
argument_list|,
name|ndata
operator|->
name|q_no
argument_list|,
name|ring_doorbell
argument_list|,
operator|&
name|ndata
operator|->
name|cmd
argument_list|,
name|ndata
operator|->
name|buf
argument_list|,
name|ndata
operator|->
name|datasize
argument_list|,
name|ndata
operator|->
name|reqtype
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lio_ctrl_callback
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|uint32_t
name|status
parameter_list|,
name|void
modifier|*
name|sc_ptr
parameter_list|)
block|{
name|struct
name|lio_soft_command
modifier|*
name|sc
init|=
operator|(
expr|struct
name|lio_soft_command
operator|*
operator|)
name|sc_ptr
decl_stmt|;
name|struct
name|lio_ctrl_pkt
modifier|*
name|nctrl
decl_stmt|;
name|nctrl
operator|=
operator|(
expr|struct
name|lio_ctrl_pkt
operator|*
operator|)
name|sc
operator|->
name|ctxptr
expr_stmt|;
comment|/* 	 * Call the callback function if status is OK. 	 * Status is OK only if a response was expected and core returned 	 * success. 	 * If no response was expected, status is OK if the command was posted 	 * successfully. 	 */
if|if
condition|(
operator|!
name|status
operator|&&
name|nctrl
operator|->
name|cb_fn
condition|)
name|nctrl
operator|->
name|cb_fn
argument_list|(
name|nctrl
argument_list|)
expr_stmt|;
name|lio_free_soft_command
argument_list|(
name|oct
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|lio_soft_command
modifier|*
name|lio_alloc_ctrl_pkt_sc
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|struct
name|lio_ctrl_pkt
modifier|*
name|nctrl
parameter_list|)
block|{
name|struct
name|lio_soft_command
modifier|*
name|sc
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|datasize
init|=
literal|0
decl_stmt|,
name|rdatasize
decl_stmt|,
name|uddsize
init|=
literal|0
decl_stmt|;
name|uint8_t
modifier|*
name|data
decl_stmt|;
name|uddsize
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|nctrl
operator|->
name|ncmd
operator|.
name|s
operator|.
name|more
operator|*
literal|8
argument_list|)
expr_stmt|;
name|datasize
operator|=
name|OCTEON_CMD_SIZE
operator|+
name|uddsize
expr_stmt|;
name|rdatasize
operator|=
operator|(
name|nctrl
operator|->
name|wait_time
operator|)
condition|?
literal|16
else|:
literal|0
expr_stmt|;
name|sc
operator|=
name|lio_alloc_soft_command
argument_list|(
name|oct
argument_list|,
name|datasize
argument_list|,
name|rdatasize
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lio_ctrl_pkt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|memcpy
argument_list|(
name|sc
operator|->
name|ctxptr
argument_list|,
name|nctrl
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lio_ctrl_pkt
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|sc
operator|->
name|virtdptr
expr_stmt|;
name|memcpy
argument_list|(
name|data
argument_list|,
operator|&
name|nctrl
operator|->
name|ncmd
argument_list|,
name|OCTEON_CMD_SIZE
argument_list|)
expr_stmt|;
name|lio_swap_8B_data
argument_list|(
operator|(
name|uint64_t
operator|*
operator|)
name|data
argument_list|,
operator|(
name|OCTEON_CMD_SIZE
operator|>>
literal|3
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|uddsize
condition|)
block|{
comment|/* Endian-Swap for UDD should have been done by caller. */
name|memcpy
argument_list|(
name|data
operator|+
name|OCTEON_CMD_SIZE
argument_list|,
name|nctrl
operator|->
name|udd
argument_list|,
name|uddsize
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|iq_no
operator|=
operator|(
name|uint32_t
operator|)
name|nctrl
operator|->
name|iq_no
expr_stmt|;
name|lio_prepare_soft_command
argument_list|(
name|oct
argument_list|,
name|sc
argument_list|,
name|LIO_OPCODE_NIC
argument_list|,
name|LIO_OPCODE_NIC_CMD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|callback
operator|=
name|lio_ctrl_callback
expr_stmt|;
name|sc
operator|->
name|callback_arg
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|wait_time
operator|=
name|nctrl
operator|->
name|wait_time
expr_stmt|;
return|return
operator|(
name|sc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lio_send_ctrl_pkt
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|struct
name|lio_ctrl_pkt
modifier|*
name|nctrl
parameter_list|)
block|{
name|struct
name|lio_soft_command
modifier|*
name|sc
init|=
name|NULL
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|oct
operator|->
name|cmd_resp_wqlock
argument_list|)
expr_stmt|;
comment|/* 	 * Allow only rx ctrl command to stop traffic on the chip 	 * during offline operations 	 */
if|if
condition|(
operator|(
name|oct
operator|->
name|cmd_resp_state
operator|==
name|LIO_DRV_OFFLINE
operator|)
operator|&&
operator|(
name|nctrl
operator|->
name|ncmd
operator|.
name|s
operator|.
name|cmd
operator|!=
name|LIO_CMD_RX_CTL
operator|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|oct
operator|->
name|cmd_resp_wqlock
argument_list|)
expr_stmt|;
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"%s cmd:%d not processed since driver offline\n"
argument_list|,
name|__func__
argument_list|,
name|nctrl
operator|->
name|ncmd
operator|.
name|s
operator|.
name|cmd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|sc
operator|=
name|lio_alloc_ctrl_pkt_sc
argument_list|(
name|oct
argument_list|,
name|nctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"%s soft command alloc failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|oct
operator|->
name|cmd_resp_wqlock
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|retval
operator|=
name|lio_send_soft_command
argument_list|(
name|oct
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|LIO_IQ_SEND_FAILED
condition|)
block|{
name|lio_free_soft_command
argument_list|(
name|oct
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"%s pf_num:%d soft command:%d send failed status: %x\n"
argument_list|,
name|__func__
argument_list|,
name|oct
operator|->
name|pf_num
argument_list|,
name|nctrl
operator|->
name|ncmd
operator|.
name|s
operator|.
name|cmd
argument_list|,
name|retval
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|oct
operator|->
name|cmd_resp_wqlock
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|oct
operator|->
name|cmd_resp_wqlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

end_unit

