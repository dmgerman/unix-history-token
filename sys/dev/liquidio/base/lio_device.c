begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *   BSD LICENSE  *  *   Copyright(c) 2017 Cavium, Inc.. All rights reserved.  *   All rights reserved.  *  *   Redistribution and use in source and binary forms, with or without  *   modification, are permitted provided that the following conditions  *   are met:  *  *     * Redistributions of source code must retain the above copyright  *       notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above copyright  *       notice, this list of conditions and the following disclaimer in  *       the documentation and/or other materials provided with the  *       distribution.  *     * Neither the name of Cavium, Inc. nor the names of its  *       contributors may be used to endorse or promote products derived  *       from this software without specific prior written permission.  *  *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  *   OWNER(S) OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"lio_bsd.h"
end_include

begin_include
include|#
directive|include
file|"lio_common.h"
end_include

begin_include
include|#
directive|include
file|"lio_droq.h"
end_include

begin_include
include|#
directive|include
file|"lio_iq.h"
end_include

begin_include
include|#
directive|include
file|"lio_response_manager.h"
end_include

begin_include
include|#
directive|include
file|"lio_device.h"
end_include

begin_include
include|#
directive|include
file|"lio_main.h"
end_include

begin_include
include|#
directive|include
file|"lio_network.h"
end_include

begin_include
include|#
directive|include
file|"cn23xx_pf_device.h"
end_include

begin_include
include|#
directive|include
file|"lio_image.h"
end_include

begin_include
include|#
directive|include
file|"lio_mem_ops.h"
end_include

begin_decl_stmt
specifier|static
name|struct
name|lio_config
name|default_cn23xx_conf
init|=
block|{
operator|.
name|card_type
operator|=
name|LIO_23XX
block|,
operator|.
name|card_name
operator|=
name|LIO_23XX_NAME
block|,
comment|/* IQ attributes */
operator|.
name|iq
operator|=
block|{
operator|.
name|max_iqs
operator|=
name|LIO_CN23XX_CFG_IO_QUEUES
block|,
operator|.
name|pending_list_size
operator|=
operator|(
name|LIO_CN23XX_DEFAULT_IQ_DESCRIPTORS
operator|*
name|LIO_CN23XX_CFG_IO_QUEUES
operator|)
block|,
operator|.
name|instr_type
operator|=
name|LIO_64BYTE_INSTR
block|,
operator|.
name|db_min
operator|=
name|LIO_CN23XX_DB_MIN
block|,
operator|.
name|db_timeout
operator|=
name|LIO_CN23XX_DB_TIMEOUT
block|,
operator|.
name|iq_intr_pkt
operator|=
name|LIO_CN23XX_DEF_IQ_INTR_THRESHOLD
block|, 	}
block|,
comment|/* OQ attributes */
operator|.
name|oq
operator|=
block|{
operator|.
name|max_oqs
operator|=
name|LIO_CN23XX_CFG_IO_QUEUES
block|,
operator|.
name|pkts_per_intr
operator|=
name|LIO_CN23XX_OQ_PKTS_PER_INTR
block|,
operator|.
name|refill_threshold
operator|=
name|LIO_CN23XX_OQ_REFIL_THRESHOLD
block|,
operator|.
name|oq_intr_pkt
operator|=
name|LIO_CN23XX_OQ_INTR_PKT
block|,
operator|.
name|oq_intr_time
operator|=
name|LIO_CN23XX_OQ_INTR_TIME
block|, 	}
block|,
operator|.
name|num_nic_ports
operator|=
name|LIO_CN23XX_DEFAULT_NUM_PORTS
block|,
operator|.
name|num_def_rx_descs
operator|=
name|LIO_CN23XX_DEFAULT_OQ_DESCRIPTORS
block|,
operator|.
name|num_def_tx_descs
operator|=
name|LIO_CN23XX_DEFAULT_IQ_DESCRIPTORS
block|,
operator|.
name|def_rx_buf_size
operator|=
name|LIO_CN23XX_OQ_BUF_SIZE
block|,
comment|/* For ethernet interface 0:  Port cfg Attributes */
operator|.
name|nic_if_cfg
index|[
literal|0
index|]
operator|=
block|{
comment|/* Max Txqs: Half for each of the two ports :max_iq/2 */
operator|.
name|max_txqs
operator|=
name|LIO_MAX_TXQS_PER_INTF
block|,
comment|/* Actual configured value. Range could be: 1...max_txqs */
operator|.
name|num_txqs
operator|=
name|LIO_DEF_TXQS_PER_INTF
block|,
comment|/* Max Rxqs: Half for each of the two ports :max_oq/2  */
operator|.
name|max_rxqs
operator|=
name|LIO_MAX_RXQS_PER_INTF
block|,
comment|/* Actual configured value. Range could be: 1...max_rxqs */
operator|.
name|num_rxqs
operator|=
name|LIO_DEF_RXQS_PER_INTF
block|,
comment|/* Num of desc for rx rings */
operator|.
name|num_rx_descs
operator|=
name|LIO_CN23XX_DEFAULT_OQ_DESCRIPTORS
block|,
comment|/* Num of desc for tx rings */
operator|.
name|num_tx_descs
operator|=
name|LIO_CN23XX_DEFAULT_IQ_DESCRIPTORS
block|,
comment|/* 		 * Mbuf size, We need not change buf size even for Jumbo frames. 		 * Octeon can send jumbo frames in 4 consecutive descriptors, 		 */
operator|.
name|rx_buf_size
operator|=
name|LIO_CN23XX_OQ_BUF_SIZE
block|,
operator|.
name|base_queue
operator|=
name|LIO_BASE_QUEUE_NOT_REQUESTED
block|,
operator|.
name|gmx_port_id
operator|=
literal|0
block|, 	}
block|,
operator|.
name|nic_if_cfg
index|[
literal|1
index|]
operator|=
block|{
comment|/* Max Txqs: Half for each of the two ports :max_iq/2 */
operator|.
name|max_txqs
operator|=
name|LIO_MAX_TXQS_PER_INTF
block|,
comment|/* Actual configured value. Range could be: 1...max_txqs */
operator|.
name|num_txqs
operator|=
name|LIO_DEF_TXQS_PER_INTF
block|,
comment|/* Max Rxqs: Half for each of the two ports :max_oq/2  */
operator|.
name|max_rxqs
operator|=
name|LIO_MAX_RXQS_PER_INTF
block|,
comment|/* Actual configured value. Range could be: 1...max_rxqs */
operator|.
name|num_rxqs
operator|=
name|LIO_DEF_RXQS_PER_INTF
block|,
comment|/* Num of desc for rx rings */
operator|.
name|num_rx_descs
operator|=
name|LIO_CN23XX_DEFAULT_OQ_DESCRIPTORS
block|,
comment|/* Num of desc for tx rings */
operator|.
name|num_tx_descs
operator|=
name|LIO_CN23XX_DEFAULT_IQ_DESCRIPTORS
block|,
comment|/* 		 * Mbuf size, We need not change buf size even for Jumbo frames. 		 * Octeon can send jumbo frames in 4 consecutive descriptors, 		 */
operator|.
name|rx_buf_size
operator|=
name|LIO_CN23XX_OQ_BUF_SIZE
block|,
operator|.
name|base_queue
operator|=
name|LIO_BASE_QUEUE_NOT_REQUESTED
block|,
operator|.
name|gmx_port_id
operator|=
literal|1
block|, 	}
block|,
operator|.
name|misc
operator|=
block|{
comment|/* Host driver link query interval */
operator|.
name|oct_link_query_interval
operator|=
literal|100
block|,
comment|/* Octeon link query interval */
operator|.
name|host_link_query_interval
operator|=
literal|500
block|,
operator|.
name|enable_sli_oq_bp
operator|=
literal|0
block|,
comment|/* Control queue group */
operator|.
name|ctrlq_grp
operator|=
literal|1
block|, 	}
block|}
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
name|lio_config_ptr
block|{
name|uint32_t
name|conf_type
decl_stmt|;
block|}
name|oct_conf_info
index|[
name|LIO_MAX_DEVICES
index|]
init|=
block|{
block|{
name|LIO_CFG_TYPE_DEFAULT
block|, 	}
block|,
block|{
name|LIO_CFG_TYPE_DEFAULT
block|, 	}
block|,
block|{
name|LIO_CFG_TYPE_DEFAULT
block|, 	}
block|,
block|{
name|LIO_CFG_TYPE_DEFAULT
block|, 	}
block|, }
struct|;
end_struct

begin_decl_stmt
specifier|static
name|char
name|lio_state_str
index|[
name|LIO_DEV_STATES
operator|+
literal|1
index|]
index|[
literal|32
index|]
init|=
block|{
literal|"BEGIN"
block|,
literal|"PCI-ENABLE-DONE"
block|,
literal|"PCI-MAP-DONE"
block|,
literal|"DISPATCH-INIT-DONE"
block|,
literal|"IQ-INIT-DONE"
block|,
literal|"SCBUFF-POOL-INIT-DONE"
block|,
literal|"RESPLIST-INIT-DONE"
block|,
literal|"DROQ-INIT-DONE"
block|,
literal|"MBOX-SETUP-DONE"
block|,
literal|"MSIX-ALLOC-VECTOR-DONE"
block|,
literal|"INTR-SET-DONE"
block|,
literal|"IO-QUEUES-INIT-DONE"
block|,
literal|"CONSOLE-INIT-DONE"
block|,
literal|"HOST-READY"
block|,
literal|"CORE-READY"
block|,
literal|"RUNNING"
block|,
literal|"IN-RESET"
block|,
literal|"INVALID"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|lio_app_str
index|[
name|LIO_DRV_APP_COUNT
operator|+
literal|1
index|]
index|[
literal|32
index|]
init|=
block|{
literal|"BASE"
block|,
literal|"NIC"
block|,
literal|"UNKNOWN"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|octeon_device
modifier|*
name|octeon_device
index|[
name|LIO_MAX_DEVICES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|lio_adapter_refcounts
index|[
name|LIO_MAX_DEVICES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|octeon_device_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* locks device array (i.e. octeon_device[]) */
end_comment

begin_decl_stmt
name|struct
name|mtx
name|octeon_devices_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|lio_core_setup
name|core_setup
index|[
name|LIO_MAX_DEVICES
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|oct_set_config_info
parameter_list|(
name|int
name|oct_id
parameter_list|,
name|int
name|conf_type
parameter_list|)
block|{
if|if
condition|(
name|conf_type
operator|<
literal|0
operator|||
name|conf_type
operator|>
operator|(
name|LIO_NUM_CFGS
operator|-
literal|1
operator|)
condition|)
name|conf_type
operator|=
name|LIO_CFG_TYPE_DEFAULT
expr_stmt|;
name|oct_conf_info
index|[
name|oct_id
index|]
operator|.
name|conf_type
operator|=
name|conf_type
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lio_init_device_list
parameter_list|(
name|int
name|conf_type
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|bzero
argument_list|(
name|octeon_device
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
name|LIO_MAX_DEVICES
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LIO_MAX_DEVICES
condition|;
name|i
operator|++
control|)
name|oct_set_config_info
argument_list|(
name|i
argument_list|,
name|conf_type
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|octeon_devices_lock
argument_list|,
literal|"octeon_devices_lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|__lio_retrieve_config_info
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|uint16_t
name|card_type
parameter_list|)
block|{
name|void
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|oct_id
init|=
name|oct
operator|->
name|octeon_id
decl_stmt|;
switch|switch
condition|(
name|oct_conf_info
index|[
name|oct_id
index|]
operator|.
name|conf_type
condition|)
block|{
case|case
name|LIO_CFG_TYPE_DEFAULT
case|:
if|if
condition|(
name|oct
operator|->
name|chip_id
operator|==
name|LIO_CN23XX_PF_VID
condition|)
block|{
name|ret
operator|=
operator|&
name|default_cn23xx_conf
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|lio_get_config_info
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|uint16_t
name|card_type
parameter_list|)
block|{
name|void
modifier|*
name|conf
init|=
name|NULL
decl_stmt|;
name|conf
operator|=
name|__lio_retrieve_config_info
argument_list|(
name|oct
argument_list|,
name|card_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|conf
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|lio_get_state_string
parameter_list|(
specifier|volatile
name|int
modifier|*
name|state_ptr
parameter_list|)
block|{
name|int32_t
name|istate
init|=
operator|(
name|int32_t
operator|)
name|atomic_load_acq_int
argument_list|(
name|state_ptr
argument_list|)
decl_stmt|;
if|if
condition|(
name|istate
operator|>
name|LIO_DEV_STATES
operator|||
name|istate
operator|<
literal|0
condition|)
return|return
operator|(
name|lio_state_str
index|[
name|LIO_DEV_STATE_INVALID
index|]
operator|)
return|;
return|return
operator|(
name|lio_state_str
index|[
name|istate
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|lio_get_app_string
parameter_list|(
name|uint32_t
name|app_mode
parameter_list|)
block|{
if|if
condition|(
name|app_mode
operator|<=
name|LIO_DRV_APP_END
condition|)
return|return
operator|(
name|lio_app_str
index|[
name|app_mode
operator|-
name|LIO_DRV_APP_START
index|]
operator|)
return|;
return|return
operator|(
name|lio_app_str
index|[
name|LIO_DRV_INVALID_APP
operator|-
name|LIO_DRV_APP_START
index|]
operator|)
return|;
block|}
end_function

begin_function
name|void
name|lio_free_device_mem
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LIO_MAX_OUTPUT_QUEUES
argument_list|(
name|oct
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|oct
operator|->
name|io_qmask
operator|.
name|oq
operator|&
name|BIT_ULL
argument_list|(
name|i
argument_list|)
operator|)
operator|&&
operator|(
name|oct
operator|->
name|droq
index|[
name|i
index|]
operator|)
condition|)
name|free
argument_list|(
name|oct
operator|->
name|droq
index|[
name|i
index|]
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LIO_MAX_INSTR_QUEUES
argument_list|(
name|oct
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|oct
operator|->
name|io_qmask
operator|.
name|iq
operator|&
name|BIT_ULL
argument_list|(
name|i
argument_list|)
operator|)
operator|&&
operator|(
name|oct
operator|->
name|instr_queue
index|[
name|i
index|]
operator|)
condition|)
name|free
argument_list|(
name|oct
operator|->
name|instr_queue
index|[
name|i
index|]
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|oct
operator|->
name|octeon_id
expr_stmt|;
name|free
argument_list|(
name|oct
operator|->
name|chip
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|octeon_device
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|octeon_device_count
operator|--
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|octeon_device
modifier|*
name|lio_allocate_device_mem
parameter_list|(
name|device_t
name|device
parameter_list|)
block|{
name|struct
name|octeon_device
modifier|*
name|oct
decl_stmt|;
name|uint32_t
name|configsize
init|=
literal|0
decl_stmt|,
name|pci_id
init|=
literal|0
decl_stmt|,
name|size
decl_stmt|;
name|uint8_t
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|pci_id
operator|=
name|pci_get_device
argument_list|(
name|device
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pci_id
condition|)
block|{
case|case
name|LIO_CN23XX_PF_VID
case|:
name|configsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|lio_cn23xx_pf
argument_list|)
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|device
argument_list|,
literal|"Error: Unknown PCI Device: 0x%x\n"
argument_list|,
name|pci_id
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|configsize
operator|&
literal|0x7
condition|)
name|configsize
operator|+=
operator|(
literal|8
operator|-
operator|(
name|configsize
operator|&
literal|0x7
operator|)
operator|)
expr_stmt|;
name|size
operator|=
name|configsize
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|lio_dispatch
argument_list|)
operator|*
name|LIO_DISPATCH_LIST_SIZE
operator|)
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|oct
operator|=
operator|(
expr|struct
name|octeon_device
operator|*
operator|)
name|device_get_softc
argument_list|(
name|device
argument_list|)
expr_stmt|;
name|oct
operator|->
name|chip
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|buf
operator|)
expr_stmt|;
name|oct
operator|->
name|dispatch
operator|.
name|dlist
operator|=
operator|(
expr|struct
name|lio_dispatch
operator|*
operator|)
operator|(
name|buf
operator|+
name|configsize
operator|)
expr_stmt|;
return|return
operator|(
name|oct
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|octeon_device
modifier|*
name|lio_allocate_device
parameter_list|(
name|device_t
name|device
parameter_list|)
block|{
name|struct
name|octeon_device
modifier|*
name|oct
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|oct_idx
init|=
literal|0
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|octeon_devices_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|oct_idx
operator|=
literal|0
init|;
name|oct_idx
operator|<
name|LIO_MAX_DEVICES
condition|;
name|oct_idx
operator|++
control|)
if|if
condition|(
operator|!
name|octeon_device
index|[
name|oct_idx
index|]
condition|)
break|break;
if|if
condition|(
name|oct_idx
operator|<
name|LIO_MAX_DEVICES
condition|)
block|{
name|oct
operator|=
name|lio_allocate_device_mem
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|oct
operator|!=
name|NULL
condition|)
block|{
name|octeon_device_count
operator|++
expr_stmt|;
name|octeon_device
index|[
name|oct_idx
index|]
operator|=
name|oct
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|octeon_devices_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|oct
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|mtx_init
argument_list|(
operator|&
name|oct
operator|->
name|pci_win_lock
argument_list|,
literal|"pci_win_lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|oct
operator|->
name|mem_access_lock
argument_list|,
literal|"mem_access_lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|oct
operator|->
name|octeon_id
operator|=
name|oct_idx
expr_stmt|;
name|snprintf
argument_list|(
name|oct
operator|->
name|device_name
argument_list|,
sizeof|sizeof
argument_list|(
name|oct
operator|->
name|device_name
argument_list|)
argument_list|,
literal|"%s%d"
argument_list|,
name|LIO_DRV_NAME
argument_list|,
name|oct
operator|->
name|octeon_id
argument_list|)
expr_stmt|;
return|return
operator|(
name|oct
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Register a device's bus location at initialization time.  *  @param oct        - pointer to the octeon device structure.  *  @param bus        - PCIe bus #  *  @param dev        - PCIe device #  *  @param func       - PCIe function #  *  @param is_pf      - TRUE for PF, FALSE for VF  *  @return reference count of device's adapter  */
end_comment

begin_function
name|int
name|lio_register_device
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
name|dev
parameter_list|,
name|int
name|func
parameter_list|,
name|int
name|is_pf
parameter_list|)
block|{
name|int
name|idx
decl_stmt|,
name|refcount
decl_stmt|;
name|oct
operator|->
name|loc
operator|.
name|bus
operator|=
name|bus
expr_stmt|;
name|oct
operator|->
name|loc
operator|.
name|dev
operator|=
name|dev
expr_stmt|;
name|oct
operator|->
name|loc
operator|.
name|func
operator|=
name|func
expr_stmt|;
name|oct
operator|->
name|adapter_refcount
operator|=
operator|&
name|lio_adapter_refcounts
index|[
name|oct
operator|->
name|octeon_id
index|]
expr_stmt|;
name|atomic_store_rel_int
argument_list|(
name|oct
operator|->
name|adapter_refcount
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|octeon_devices_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
operator|(
name|int
operator|)
name|oct
operator|->
name|octeon_id
operator|-
literal|1
init|;
name|idx
operator|>=
literal|0
condition|;
name|idx
operator|--
control|)
block|{
if|if
condition|(
name|octeon_device
index|[
name|idx
index|]
operator|==
name|NULL
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"%s: Internal driver error, missing dev\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|octeon_devices_lock
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
name|oct
operator|->
name|adapter_refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* here, refcount is guaranteed to be 1 */
block|}
comment|/* if another device is at same bus/dev, use its refcounter */
if|if
condition|(
operator|(
name|octeon_device
index|[
name|idx
index|]
operator|->
name|loc
operator|.
name|bus
operator|==
name|bus
operator|)
operator|&&
operator|(
name|octeon_device
index|[
name|idx
index|]
operator|->
name|loc
operator|.
name|dev
operator|==
name|dev
operator|)
condition|)
block|{
name|oct
operator|->
name|adapter_refcount
operator|=
name|octeon_device
index|[
name|idx
index|]
operator|->
name|adapter_refcount
expr_stmt|;
break|break;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|octeon_devices_lock
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
name|oct
operator|->
name|adapter_refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|refcount
operator|=
name|atomic_load_acq_int
argument_list|(
name|oct
operator|->
name|adapter_refcount
argument_list|)
expr_stmt|;
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"%s: %02x:%02x:%d refcount %u\n"
argument_list|,
name|__func__
argument_list|,
name|oct
operator|->
name|loc
operator|.
name|bus
argument_list|,
name|oct
operator|->
name|loc
operator|.
name|dev
argument_list|,
name|oct
operator|->
name|loc
operator|.
name|func
argument_list|,
name|refcount
argument_list|)
expr_stmt|;
return|return
operator|(
name|refcount
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Deregister a device at de-initialization time.  *  @param oct - pointer to the octeon device structure.  *  @return reference count of device's adapter  */
end_comment

begin_function
name|int
name|lio_deregister_device
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
name|int
name|refcount
decl_stmt|;
name|atomic_subtract_int
argument_list|(
name|oct
operator|->
name|adapter_refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|refcount
operator|=
name|atomic_load_acq_int
argument_list|(
name|oct
operator|->
name|adapter_refcount
argument_list|)
expr_stmt|;
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"%s: %04d:%02d:%d refcount %u\n"
argument_list|,
name|__func__
argument_list|,
name|oct
operator|->
name|loc
operator|.
name|bus
argument_list|,
name|oct
operator|->
name|loc
operator|.
name|dev
argument_list|,
name|oct
operator|->
name|loc
operator|.
name|func
argument_list|,
name|refcount
argument_list|)
expr_stmt|;
return|return
operator|(
name|refcount
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lio_allocate_ioq_vector
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
name|struct
name|lio_ioq_vector
modifier|*
name|ioq_vector
decl_stmt|;
name|int
name|i
decl_stmt|,
name|cpu_num
decl_stmt|,
name|num_ioqs
init|=
literal|0
decl_stmt|,
name|size
decl_stmt|;
if|if
condition|(
name|LIO_CN23XX_PF
argument_list|(
name|oct
argument_list|)
condition|)
name|num_ioqs
operator|=
name|oct
operator|->
name|sriov_info
operator|.
name|num_pf_rings
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|lio_ioq_vector
argument_list|)
operator|*
name|num_ioqs
expr_stmt|;
name|oct
operator|->
name|ioq_vector
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|oct
operator|->
name|ioq_vector
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_ioqs
condition|;
name|i
operator|++
control|)
block|{
name|ioq_vector
operator|=
operator|&
name|oct
operator|->
name|ioq_vector
index|[
name|i
index|]
expr_stmt|;
name|ioq_vector
operator|->
name|oct_dev
operator|=
name|oct
expr_stmt|;
name|ioq_vector
operator|->
name|droq_index
operator|=
name|i
expr_stmt|;
name|cpu_num
operator|=
name|i
operator|%
name|mp_ncpus
expr_stmt|;
name|CPU_SETOF
argument_list|(
name|cpu_num
argument_list|,
operator|&
name|ioq_vector
operator|->
name|affinity_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|oct
operator|->
name|chip_id
operator|==
name|LIO_CN23XX_PF_VID
condition|)
name|ioq_vector
operator|->
name|ioq_num
operator|=
name|i
operator|+
name|oct
operator|->
name|sriov_info
operator|.
name|pf_srn
expr_stmt|;
else|else
name|ioq_vector
operator|->
name|ioq_num
operator|=
name|i
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|lio_free_ioq_vector
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
name|free
argument_list|(
name|oct
operator|->
name|ioq_vector
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|oct
operator|->
name|ioq_vector
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* this function is only for setting up the first queue */
end_comment

begin_function
name|int
name|lio_setup_instr_queue0
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
name|union
name|octeon_txpciq
name|txpciq
decl_stmt|;
name|uint32_t
name|iq_no
init|=
literal|0
decl_stmt|;
name|uint32_t
name|num_descs
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|LIO_CN23XX_PF
argument_list|(
name|oct
argument_list|)
condition|)
name|num_descs
operator|=
name|LIO_GET_NUM_DEF_TX_DESCS_CFG
argument_list|(
name|LIO_CHIP_CONF
argument_list|(
name|oct
argument_list|,
name|cn23xx_pf
argument_list|)
argument_list|)
expr_stmt|;
name|oct
operator|->
name|num_iqs
operator|=
literal|0
expr_stmt|;
name|oct
operator|->
name|instr_queue
index|[
literal|0
index|]
operator|->
name|q_index
operator|=
literal|0
expr_stmt|;
name|oct
operator|->
name|instr_queue
index|[
literal|0
index|]
operator|->
name|app_ctx
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|size_t
operator|)
literal|0
expr_stmt|;
name|oct
operator|->
name|instr_queue
index|[
literal|0
index|]
operator|->
name|ifidx
operator|=
literal|0
expr_stmt|;
name|txpciq
operator|.
name|txpciq64
operator|=
literal|0
expr_stmt|;
name|txpciq
operator|.
name|s
operator|.
name|q_no
operator|=
name|iq_no
expr_stmt|;
name|txpciq
operator|.
name|s
operator|.
name|pkind
operator|=
name|oct
operator|->
name|pfvf_hsword
operator|.
name|pkind
expr_stmt|;
name|txpciq
operator|.
name|s
operator|.
name|use_qpg
operator|=
literal|0
expr_stmt|;
name|txpciq
operator|.
name|s
operator|.
name|qpg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lio_init_instr_queue
argument_list|(
name|oct
argument_list|,
name|txpciq
argument_list|,
name|num_descs
argument_list|)
condition|)
block|{
comment|/* prevent memory leak */
name|lio_delete_instr_queue
argument_list|(
name|oct
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|oct
operator|->
name|num_iqs
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lio_setup_output_queue0
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
name|uint32_t
name|desc_size
init|=
literal|0
decl_stmt|,
name|num_descs
init|=
literal|0
decl_stmt|,
name|oq_no
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|LIO_CN23XX_PF
argument_list|(
name|oct
argument_list|)
condition|)
block|{
name|num_descs
operator|=
name|LIO_GET_NUM_DEF_RX_DESCS_CFG
argument_list|(
name|LIO_CHIP_CONF
argument_list|(
name|oct
argument_list|,
name|cn23xx_pf
argument_list|)
argument_list|)
expr_stmt|;
name|desc_size
operator|=
name|LIO_GET_DEF_RX_BUF_SIZE_CFG
argument_list|(
name|LIO_CHIP_CONF
argument_list|(
name|oct
argument_list|,
name|cn23xx_pf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|oct
operator|->
name|num_oqs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lio_init_droq
argument_list|(
name|oct
argument_list|,
name|oq_no
argument_list|,
name|num_descs
argument_list|,
name|desc_size
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|oct
operator|->
name|num_oqs
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lio_init_dispatch_list
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|oct
operator|->
name|dispatch
operator|.
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LIO_DISPATCH_LIST_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|oct
operator|->
name|dispatch
operator|.
name|dlist
index|[
name|i
index|]
operator|.
name|opcode
operator|=
literal|0
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|oct
operator|->
name|dispatch
operator|.
name|dlist
index|[
name|i
index|]
operator|.
name|head
argument_list|)
expr_stmt|;
block|}
name|mtx_init
argument_list|(
operator|&
name|oct
operator|->
name|dispatch
operator|.
name|lock
argument_list|,
literal|"dispatch_lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|lio_delete_dispatch_list
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
name|struct
name|lio_stailq_head
name|freelist
decl_stmt|;
name|struct
name|lio_stailq_node
modifier|*
name|temp
decl_stmt|,
modifier|*
name|tmp2
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|freelist
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|oct
operator|->
name|dispatch
operator|.
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LIO_DISPATCH_LIST_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|lio_stailq_head
modifier|*
name|dispatch
decl_stmt|;
name|dispatch
operator|=
operator|&
name|oct
operator|->
name|dispatch
operator|.
name|dlist
index|[
name|i
index|]
operator|.
name|head
expr_stmt|;
while|while
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
name|dispatch
argument_list|)
condition|)
block|{
name|temp
operator|=
name|STAILQ_FIRST
argument_list|(
name|dispatch
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|oct
operator|->
name|dispatch
operator|.
name|dlist
index|[
name|i
index|]
operator|.
name|head
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|freelist
argument_list|,
name|temp
argument_list|,
name|entries
argument_list|)
expr_stmt|;
block|}
name|oct
operator|->
name|dispatch
operator|.
name|dlist
index|[
name|i
index|]
operator|.
name|opcode
operator|=
literal|0
expr_stmt|;
block|}
name|oct
operator|->
name|dispatch
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|oct
operator|->
name|dispatch
operator|.
name|lock
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|temp
argument_list|,
argument|&freelist
argument_list|,
argument|entries
argument_list|,
argument|tmp2
argument_list|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|freelist
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|lio_dispatch_fn_t
name|lio_get_dispatch
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|octeon_dev
parameter_list|,
name|uint16_t
name|opcode
parameter_list|,
name|uint16_t
name|subcode
parameter_list|)
block|{
name|struct
name|lio_stailq_node
modifier|*
name|dispatch
decl_stmt|;
name|lio_dispatch_fn_t
name|fn
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|idx
decl_stmt|;
name|uint16_t
name|combined_opcode
init|=
name|LIO_OPCODE_SUBCODE
argument_list|(
name|opcode
argument_list|,
name|subcode
argument_list|)
decl_stmt|;
name|idx
operator|=
name|combined_opcode
operator|&
name|LIO_OPCODE_MASK
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|octeon_dev
operator|->
name|dispatch
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|octeon_dev
operator|->
name|dispatch
operator|.
name|count
operator|==
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|octeon_dev
operator|->
name|dispatch
operator|.
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|octeon_dev
operator|->
name|dispatch
operator|.
name|dlist
index|[
name|idx
index|]
operator|.
name|opcode
operator|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|octeon_dev
operator|->
name|dispatch
operator|.
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|octeon_dev
operator|->
name|dispatch
operator|.
name|dlist
index|[
name|idx
index|]
operator|.
name|opcode
operator|==
name|combined_opcode
condition|)
block|{
name|fn
operator|=
name|octeon_dev
operator|->
name|dispatch
operator|.
name|dlist
index|[
name|idx
index|]
operator|.
name|dispatch_fn
expr_stmt|;
block|}
else|else
block|{
name|STAILQ_FOREACH
argument_list|(
argument|dispatch
argument_list|,
argument|&octeon_dev->dispatch.dlist[idx].head
argument_list|,
argument|entries
argument_list|)
block|{
if|if
condition|(
operator|(
operator|(
expr|struct
name|lio_dispatch
operator|*
operator|)
name|dispatch
operator|)
operator|->
name|opcode
operator|==
name|combined_opcode
condition|)
block|{
name|fn
operator|=
operator|(
operator|(
expr|struct
name|lio_dispatch
operator|*
operator|)
name|dispatch
operator|)
operator|->
name|dispatch_fn
expr_stmt|;
break|break;
block|}
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|octeon_dev
operator|->
name|dispatch
operator|.
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|fn
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * lio_register_dispatch_fn  * Parameters:  *   octeon_id - id of the octeon device.  *   opcode    - opcode for which driver should call the registered function  *   subcode   - subcode for which driver should call the registered function  *   fn        - The function to call when a packet with "opcode" arrives in  *               octeon output queues.  *   fn_arg    - The argument to be passed when calling function "fn".  * Description:  *   Registers a function and its argument to be called when a packet  *   arrives in Octeon output queues with "opcode".  * Returns:  *   Success: 0  *   Failure: 1  * Locks:  *   No locks are held.  */
end_comment

begin_function
name|int
name|lio_register_dispatch_fn
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|uint16_t
name|opcode
parameter_list|,
name|uint16_t
name|subcode
parameter_list|,
name|lio_dispatch_fn_t
name|fn
parameter_list|,
name|void
modifier|*
name|fn_arg
parameter_list|)
block|{
name|lio_dispatch_fn_t
name|pfn
decl_stmt|;
name|uint32_t
name|idx
decl_stmt|;
name|uint16_t
name|combined_opcode
init|=
name|LIO_OPCODE_SUBCODE
argument_list|(
name|opcode
argument_list|,
name|subcode
argument_list|)
decl_stmt|;
name|idx
operator|=
name|combined_opcode
operator|&
name|LIO_OPCODE_MASK
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|oct
operator|->
name|dispatch
operator|.
name|lock
argument_list|)
expr_stmt|;
comment|/* Add dispatch function to first level of lookup table */
if|if
condition|(
name|oct
operator|->
name|dispatch
operator|.
name|dlist
index|[
name|idx
index|]
operator|.
name|opcode
operator|==
literal|0
condition|)
block|{
name|oct
operator|->
name|dispatch
operator|.
name|dlist
index|[
name|idx
index|]
operator|.
name|opcode
operator|=
name|combined_opcode
expr_stmt|;
name|oct
operator|->
name|dispatch
operator|.
name|dlist
index|[
name|idx
index|]
operator|.
name|dispatch_fn
operator|=
name|fn
expr_stmt|;
name|oct
operator|->
name|dispatch
operator|.
name|dlist
index|[
name|idx
index|]
operator|.
name|arg
operator|=
name|fn_arg
expr_stmt|;
name|oct
operator|->
name|dispatch
operator|.
name|count
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|oct
operator|->
name|dispatch
operator|.
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|oct
operator|->
name|dispatch
operator|.
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * Check if there was a function already registered for this 	 * opcode/subcode. 	 */
name|pfn
operator|=
name|lio_get_dispatch
argument_list|(
name|oct
argument_list|,
name|opcode
argument_list|,
name|subcode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pfn
condition|)
block|{
name|struct
name|lio_dispatch
modifier|*
name|dispatch
decl_stmt|;
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"Adding opcode to dispatch list linked list\n"
argument_list|)
expr_stmt|;
name|dispatch
operator|=
operator|(
expr|struct
name|lio_dispatch
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lio_dispatch
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|dispatch
operator|==
name|NULL
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"No memory to add dispatch function\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|dispatch
operator|->
name|opcode
operator|=
name|combined_opcode
expr_stmt|;
name|dispatch
operator|->
name|dispatch_fn
operator|=
name|fn
expr_stmt|;
name|dispatch
operator|->
name|arg
operator|=
name|fn_arg
expr_stmt|;
comment|/* 		 * Add dispatch function to linked list of fn ptrs 		 * at the hashed index. 		 */
name|mtx_lock
argument_list|(
operator|&
name|oct
operator|->
name|dispatch
operator|.
name|lock
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|oct
operator|->
name|dispatch
operator|.
name|dlist
index|[
name|idx
index|]
operator|.
name|head
argument_list|,
operator|&
name|dispatch
operator|->
name|node
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|oct
operator|->
name|dispatch
operator|.
name|count
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|oct
operator|->
name|dispatch
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Found previously registered dispatch fn for opcode/subcode: %x/%x\n"
argument_list|,
name|opcode
argument_list|,
name|subcode
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * lio_unregister_dispatch_fn  * Parameters:  *   oct       - octeon device  *   opcode    - driver should unregister the function for this opcode  *   subcode   - driver should unregister the function for this subcode  * Description:  *   Unregister the function set for this opcode+subcode.  * Returns:  *   Success: 0  *   Failure: 1  * Locks:  *   No locks are held.  */
end_comment

begin_function
name|int
name|lio_unregister_dispatch_fn
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|uint16_t
name|opcode
parameter_list|,
name|uint16_t
name|subcode
parameter_list|)
block|{
name|struct
name|lio_stailq_head
modifier|*
name|dispatch_head
decl_stmt|;
name|struct
name|lio_stailq_node
modifier|*
name|dispatch
decl_stmt|,
modifier|*
name|dfree
init|=
name|NULL
decl_stmt|,
modifier|*
name|tmp2
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|uint32_t
name|idx
decl_stmt|;
name|uint16_t
name|combined_opcode
init|=
name|LIO_OPCODE_SUBCODE
argument_list|(
name|opcode
argument_list|,
name|subcode
argument_list|)
decl_stmt|;
name|idx
operator|=
name|combined_opcode
operator|&
name|LIO_OPCODE_MASK
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|oct
operator|->
name|dispatch
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|oct
operator|->
name|dispatch
operator|.
name|count
operator|==
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|oct
operator|->
name|dispatch
operator|.
name|lock
argument_list|)
expr_stmt|;
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"No dispatch functions registered for this device\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|oct
operator|->
name|dispatch
operator|.
name|dlist
index|[
name|idx
index|]
operator|.
name|opcode
operator|==
name|combined_opcode
condition|)
block|{
name|dispatch_head
operator|=
operator|&
name|oct
operator|->
name|dispatch
operator|.
name|dlist
index|[
name|idx
index|]
operator|.
name|head
expr_stmt|;
if|if
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
name|dispatch_head
argument_list|)
condition|)
block|{
name|dispatch
operator|=
name|STAILQ_FIRST
argument_list|(
name|dispatch_head
argument_list|)
expr_stmt|;
name|oct
operator|->
name|dispatch
operator|.
name|dlist
index|[
name|idx
index|]
operator|.
name|opcode
operator|=
operator|(
operator|(
expr|struct
name|lio_dispatch
operator|*
operator|)
name|dispatch
operator|)
operator|->
name|opcode
expr_stmt|;
name|oct
operator|->
name|dispatch
operator|.
name|dlist
index|[
name|idx
index|]
operator|.
name|dispatch_fn
operator|=
operator|(
operator|(
expr|struct
name|lio_dispatch
operator|*
operator|)
name|dispatch
operator|)
operator|->
name|dispatch_fn
expr_stmt|;
name|oct
operator|->
name|dispatch
operator|.
name|dlist
index|[
name|idx
index|]
operator|.
name|arg
operator|=
operator|(
operator|(
expr|struct
name|lio_dispatch
operator|*
operator|)
name|dispatch
operator|)
operator|->
name|arg
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
name|dispatch_head
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|dfree
operator|=
name|dispatch
expr_stmt|;
block|}
else|else
block|{
name|oct
operator|->
name|dispatch
operator|.
name|dlist
index|[
name|idx
index|]
operator|.
name|opcode
operator|=
literal|0
expr_stmt|;
name|oct
operator|->
name|dispatch
operator|.
name|dlist
index|[
name|idx
index|]
operator|.
name|dispatch_fn
operator|=
name|NULL
expr_stmt|;
name|oct
operator|->
name|dispatch
operator|.
name|dlist
index|[
name|idx
index|]
operator|.
name|arg
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|retval
operator|=
literal|1
expr_stmt|;
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|dispatch
argument_list|,
argument|&oct->dispatch.dlist[idx].head
argument_list|,
argument|entries
argument_list|,
argument|tmp2
argument_list|)
block|{
if|if
condition|(
operator|(
operator|(
expr|struct
name|lio_dispatch
operator|*
operator|)
name|dispatch
operator|)
operator|->
name|opcode
operator|==
name|combined_opcode
condition|)
block|{
name|STAILQ_REMOVE
argument_list|(
operator|&
name|oct
operator|->
name|dispatch
operator|.
name|dlist
index|[
name|idx
index|]
operator|.
name|head
argument_list|,
name|dispatch
argument_list|,
name|lio_stailq_node
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|dfree
operator|=
name|dispatch
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|retval
condition|)
name|oct
operator|->
name|dispatch
operator|.
name|count
operator|--
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|oct
operator|->
name|dispatch
operator|.
name|lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dfree
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lio_core_drv_init
parameter_list|(
name|struct
name|lio_recv_info
modifier|*
name|recv_info
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|octeon_device
modifier|*
name|oct
init|=
operator|(
expr|struct
name|octeon_device
operator|*
operator|)
name|buf
decl_stmt|;
name|struct
name|lio_recv_pkt
modifier|*
name|recv_pkt
init|=
name|recv_info
operator|->
name|recv_pkt
decl_stmt|;
name|struct
name|lio_core_setup
modifier|*
name|cs
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|num_nic_ports
init|=
literal|0
decl_stmt|;
name|char
name|app_name
index|[
literal|16
index|]
decl_stmt|;
if|if
condition|(
name|LIO_CN23XX_PF
argument_list|(
name|oct
argument_list|)
condition|)
name|num_nic_ports
operator|=
name|LIO_GET_NUM_NIC_PORTS_CFG
argument_list|(
name|LIO_CHIP_CONF
argument_list|(
name|oct
argument_list|,
name|cn23xx_pf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|oct
operator|->
name|status
argument_list|)
operator|>=
name|LIO_DEV_RUNNING
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Received CORE OK when device state is 0x%x\n"
argument_list|,
name|atomic_load_acq_int
argument_list|(
operator|&
name|oct
operator|->
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|core_drv_init_err
goto|;
block|}
name|strncpy
argument_list|(
name|app_name
argument_list|,
name|lio_get_app_string
argument_list|(
operator|(
name|uint32_t
operator|)
name|recv_pkt
operator|->
name|rh
operator|.
name|r_core_drv_init
operator|.
name|app_mode
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|app_name
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|oct
operator|->
name|app_mode
operator|=
operator|(
name|uint32_t
operator|)
name|recv_pkt
operator|->
name|rh
operator|.
name|r_core_drv_init
operator|.
name|app_mode
expr_stmt|;
if|if
condition|(
name|recv_pkt
operator|->
name|rh
operator|.
name|r_core_drv_init
operator|.
name|app_mode
operator|==
name|LIO_DRV_NIC_APP
condition|)
block|{
name|oct
operator|->
name|fw_info
operator|.
name|max_nic_ports
operator|=
operator|(
name|uint32_t
operator|)
name|recv_pkt
operator|->
name|rh
operator|.
name|r_core_drv_init
operator|.
name|max_nic_ports
expr_stmt|;
name|oct
operator|->
name|fw_info
operator|.
name|num_gmx_ports
operator|=
operator|(
name|uint32_t
operator|)
name|recv_pkt
operator|->
name|rh
operator|.
name|r_core_drv_init
operator|.
name|num_gmx_ports
expr_stmt|;
block|}
if|if
condition|(
name|oct
operator|->
name|fw_info
operator|.
name|max_nic_ports
operator|<
name|num_nic_ports
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Config has more ports than firmware allows (%d> %d).\n"
argument_list|,
name|num_nic_ports
argument_list|,
name|oct
operator|->
name|fw_info
operator|.
name|max_nic_ports
argument_list|)
expr_stmt|;
goto|goto
name|core_drv_init_err
goto|;
block|}
name|oct
operator|->
name|fw_info
operator|.
name|app_cap_flags
operator|=
name|recv_pkt
operator|->
name|rh
operator|.
name|r_core_drv_init
operator|.
name|app_cap_flags
expr_stmt|;
name|oct
operator|->
name|fw_info
operator|.
name|app_mode
operator|=
operator|(
name|uint32_t
operator|)
name|recv_pkt
operator|->
name|rh
operator|.
name|r_core_drv_init
operator|.
name|app_mode
expr_stmt|;
name|oct
operator|->
name|pfvf_hsword
operator|.
name|app_mode
operator|=
operator|(
name|uint32_t
operator|)
name|recv_pkt
operator|->
name|rh
operator|.
name|r_core_drv_init
operator|.
name|app_mode
expr_stmt|;
name|oct
operator|->
name|pfvf_hsword
operator|.
name|pkind
operator|=
name|recv_pkt
operator|->
name|rh
operator|.
name|r_core_drv_init
operator|.
name|pkind
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oct
operator|->
name|num_iqs
condition|;
name|i
operator|++
control|)
name|oct
operator|->
name|instr_queue
index|[
name|i
index|]
operator|->
name|txpciq
operator|.
name|s
operator|.
name|pkind
operator|=
name|oct
operator|->
name|pfvf_hsword
operator|.
name|pkind
expr_stmt|;
name|atomic_store_rel_int
argument_list|(
operator|&
name|oct
operator|->
name|status
argument_list|,
name|LIO_DEV_CORE_OK
argument_list|)
expr_stmt|;
name|cs
operator|=
operator|&
name|core_setup
index|[
name|oct
operator|->
name|octeon_id
index|]
expr_stmt|;
if|if
condition|(
name|recv_pkt
operator|->
name|buffer_size
index|[
literal|0
index|]
operator|!=
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|cs
argument_list|)
operator|+
name|LIO_DROQ_INFO_SIZE
operator|)
condition|)
block|{
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"Core setup bytes expected %llu found %d\n"
argument_list|,
name|LIO_CAST64
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cs
argument_list|)
operator|+
name|LIO_DROQ_INFO_SIZE
argument_list|)
argument_list|,
name|recv_pkt
operator|->
name|buffer_size
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|cs
argument_list|,
name|recv_pkt
operator|->
name|buffer_ptr
index|[
literal|0
index|]
operator|->
name|m_data
operator|+
name|LIO_DROQ_INFO_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cs
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|oct
operator|->
name|boardinfo
operator|.
name|name
argument_list|,
name|cs
operator|->
name|boardname
argument_list|,
name|LIO_BOARD_NAME
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|oct
operator|->
name|boardinfo
operator|.
name|serial_number
argument_list|,
name|cs
operator|->
name|board_serial_number
argument_list|,
name|LIO_SERIAL_NUM_LEN
argument_list|)
expr_stmt|;
name|lio_swap_8B_data
argument_list|(
operator|(
name|uint64_t
operator|*
operator|)
name|cs
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|cs
argument_list|)
operator|>>
literal|3
operator|)
argument_list|)
expr_stmt|;
name|oct
operator|->
name|boardinfo
operator|.
name|major
operator|=
name|cs
operator|->
name|board_rev_major
expr_stmt|;
name|oct
operator|->
name|boardinfo
operator|.
name|minor
operator|=
name|cs
operator|->
name|board_rev_minor
expr_stmt|;
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"Running %s (%llu Hz)\n"
argument_list|,
name|app_name
argument_list|,
name|LIO_CAST64
argument_list|(
name|cs
operator|->
name|corefreq
argument_list|)
argument_list|)
expr_stmt|;
name|core_drv_init_err
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recv_pkt
operator|->
name|buffer_count
condition|;
name|i
operator|++
control|)
name|lio_recv_buffer_free
argument_list|(
name|recv_pkt
operator|->
name|buffer_ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|lio_free_recv_info
argument_list|(
name|recv_info
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lio_get_tx_qsize
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|uint32_t
name|q_no
parameter_list|)
block|{
if|if
condition|(
operator|(
name|oct
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|q_no
operator|<
operator|(
name|uint32_t
operator|)
name|LIO_MAX_INSTR_QUEUES
argument_list|(
name|oct
argument_list|)
operator|)
operator|&&
operator|(
name|oct
operator|->
name|io_qmask
operator|.
name|iq
operator|&
name|BIT_ULL
argument_list|(
name|q_no
argument_list|)
operator|)
condition|)
return|return
operator|(
name|oct
operator|->
name|instr_queue
index|[
name|q_no
index|]
operator|->
name|max_count
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lio_get_rx_qsize
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|uint32_t
name|q_no
parameter_list|)
block|{
if|if
condition|(
operator|(
name|oct
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|q_no
operator|<
operator|(
name|uint32_t
operator|)
name|LIO_MAX_OUTPUT_QUEUES
argument_list|(
name|oct
argument_list|)
operator|)
operator|&&
operator|(
name|oct
operator|->
name|io_qmask
operator|.
name|oq
operator|&
name|BIT_ULL
argument_list|(
name|q_no
argument_list|)
operator|)
condition|)
return|return
operator|(
name|oct
operator|->
name|droq
index|[
name|q_no
index|]
operator|->
name|max_count
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns the host firmware handshake OCTEON specific configuration */
end_comment

begin_function
name|struct
name|lio_config
modifier|*
name|lio_get_conf
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
name|struct
name|lio_config
modifier|*
name|default_oct_conf
init|=
name|NULL
decl_stmt|;
comment|/* 	 * check the OCTEON Device model& return the corresponding octeon 	 * configuration 	 */
if|if
condition|(
name|LIO_CN23XX_PF
argument_list|(
name|oct
argument_list|)
condition|)
block|{
name|default_oct_conf
operator|=
operator|(
expr|struct
name|lio_config
operator|*
operator|)
operator|(
name|LIO_CHIP_CONF
argument_list|(
name|oct
argument_list|,
name|cn23xx_pf
argument_list|)
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|default_oct_conf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Get the octeon device pointer.  *  @param octeon_id  - The id for which the octeon device pointer is required.  *  @return Success: Octeon device pointer.  *  @return Failure: NULL.  */
end_comment

begin_function
name|struct
name|octeon_device
modifier|*
name|lio_get_device
parameter_list|(
name|uint32_t
name|octeon_id
parameter_list|)
block|{
if|if
condition|(
name|octeon_id
operator|>=
name|LIO_MAX_DEVICES
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|octeon_device
index|[
name|octeon_id
index|]
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|lio_pci_readq
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|uint64_t
name|addr
parameter_list|)
block|{
name|uint64_t
name|val64
decl_stmt|;
specifier|volatile
name|uint32_t
name|val32
decl_stmt|,
name|addrhi
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|oct
operator|->
name|pci_win_lock
argument_list|)
expr_stmt|;
comment|/* 	 * The windowed read happens when the LSB of the addr is written. 	 * So write MSB first 	 */
name|addrhi
operator|=
operator|(
name|addr
operator|>>
literal|32
operator|)
expr_stmt|;
if|if
condition|(
name|oct
operator|->
name|chip_id
operator|==
name|LIO_CN23XX_PF_VID
condition|)
name|addrhi
operator||=
literal|0x00060000
expr_stmt|;
name|lio_write_csr32
argument_list|(
name|oct
argument_list|,
name|oct
operator|->
name|reg_list
operator|.
name|pci_win_rd_addr_hi
argument_list|,
name|addrhi
argument_list|)
expr_stmt|;
comment|/* Read back to preserve ordering of writes */
name|val32
operator|=
name|lio_read_csr32
argument_list|(
name|oct
argument_list|,
name|oct
operator|->
name|reg_list
operator|.
name|pci_win_rd_addr_hi
argument_list|)
expr_stmt|;
name|lio_write_csr32
argument_list|(
name|oct
argument_list|,
name|oct
operator|->
name|reg_list
operator|.
name|pci_win_rd_addr_lo
argument_list|,
name|addr
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|val32
operator|=
name|lio_read_csr32
argument_list|(
name|oct
argument_list|,
name|oct
operator|->
name|reg_list
operator|.
name|pci_win_rd_addr_lo
argument_list|)
expr_stmt|;
name|val64
operator|=
name|lio_read_csr64
argument_list|(
name|oct
argument_list|,
name|oct
operator|->
name|reg_list
operator|.
name|pci_win_rd_data
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|oct
operator|->
name|pci_win_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|val64
operator|)
return|;
block|}
end_function

begin_function
name|void
name|lio_pci_writeq
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|uint64_t
name|val
parameter_list|,
name|uint64_t
name|addr
parameter_list|)
block|{
specifier|volatile
name|uint32_t
name|val32
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|oct
operator|->
name|pci_win_lock
argument_list|)
expr_stmt|;
name|lio_write_csr64
argument_list|(
name|oct
argument_list|,
name|oct
operator|->
name|reg_list
operator|.
name|pci_win_wr_addr
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* The write happens when the LSB is written. So write MSB first. */
name|lio_write_csr32
argument_list|(
name|oct
argument_list|,
name|oct
operator|->
name|reg_list
operator|.
name|pci_win_wr_data_hi
argument_list|,
name|val
operator|>>
literal|32
argument_list|)
expr_stmt|;
comment|/* Read the MSB to ensure ordering of writes. */
name|val32
operator|=
name|lio_read_csr32
argument_list|(
name|oct
argument_list|,
name|oct
operator|->
name|reg_list
operator|.
name|pci_win_wr_data_hi
argument_list|)
expr_stmt|;
name|lio_write_csr32
argument_list|(
name|oct
argument_list|,
name|oct
operator|->
name|reg_list
operator|.
name|pci_win_wr_data_lo
argument_list|,
name|val
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|oct
operator|->
name|pci_win_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|lio_mem_access_ok
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
name|uint64_t
name|access_okay
init|=
literal|0
decl_stmt|;
name|uint64_t
name|lmc0_reset_ctl
decl_stmt|;
comment|/* Check to make sure a DDR interface is enabled */
if|if
condition|(
name|LIO_CN23XX_PF
argument_list|(
name|oct
argument_list|)
condition|)
block|{
name|lmc0_reset_ctl
operator|=
name|lio_pci_readq
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_LMC0_RESET_CTL
argument_list|)
expr_stmt|;
name|access_okay
operator|=
operator|(
name|lmc0_reset_ctl
operator|&
name|LIO_CN23XX_LMC0_RESET_CTL_DDR3RST_MASK
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|access_okay
condition|?
literal|0
else|:
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lio_wait_for_ddr_init
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|unsigned
name|long
modifier|*
name|timeout
parameter_list|)
block|{
name|int
name|ret
init|=
literal|1
decl_stmt|;
name|uint32_t
name|ms
decl_stmt|;
if|if
condition|(
name|timeout
operator|==
name|NULL
condition|)
return|return
operator|(
name|ret
operator|)
return|;
for|for
control|(
name|ms
operator|=
literal|0
init|;
name|ret
operator|&&
operator|(
operator|(
operator|*
name|timeout
operator|==
literal|0
operator|)
operator|||
operator|(
name|ms
operator|<=
operator|*
name|timeout
operator|)
operator|)
condition|;
name|ms
operator|+=
literal|100
control|)
block|{
name|ret
operator|=
name|lio_mem_access_ok
argument_list|(
name|oct
argument_list|)
expr_stmt|;
comment|/* wait 100 ms */
if|if
condition|(
name|ret
condition|)
name|lio_sleep_timeout
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Get the octeon id assigned to the octeon device passed as argument.  *  This function is exported to other modules.  *  @param dev - octeon device pointer passed as a void *.  *  @return octeon device id  */
end_comment

begin_function
name|int
name|lio_get_device_id
parameter_list|(
name|void
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|octeon_device
modifier|*
name|octeon_dev
init|=
operator|(
expr|struct
name|octeon_device
operator|*
operator|)
name|dev
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LIO_MAX_DEVICES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|octeon_device
index|[
name|i
index|]
operator|==
name|octeon_dev
condition|)
return|return
operator|(
name|octeon_dev
operator|->
name|octeon_id
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|lio_enable_irq
parameter_list|(
name|struct
name|lio_droq
modifier|*
name|droq
parameter_list|,
name|struct
name|lio_instr_queue
modifier|*
name|iq
parameter_list|)
block|{
name|struct
name|octeon_device
modifier|*
name|oct
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|instr_cnt
decl_stmt|;
name|uint32_t
name|pkts_pend
decl_stmt|;
comment|/* the whole thing needs to be atomic, ideally */
if|if
condition|(
name|droq
operator|!=
name|NULL
condition|)
block|{
name|oct
operator|=
name|droq
operator|->
name|oct_dev
expr_stmt|;
name|pkts_pend
operator|=
name|atomic_load_acq_int
argument_list|(
operator|&
name|droq
operator|->
name|pkts_pending
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|droq
operator|->
name|lock
argument_list|)
expr_stmt|;
name|lio_write_csr32
argument_list|(
name|oct
argument_list|,
name|droq
operator|->
name|pkts_sent_reg
argument_list|,
name|droq
operator|->
name|pkt_count
operator|-
name|pkts_pend
argument_list|)
expr_stmt|;
name|droq
operator|->
name|pkt_count
operator|=
name|pkts_pend
expr_stmt|;
comment|/* this write needs to be flushed before we release the lock */
name|__compiler_membar
argument_list|()
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|droq
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iq
operator|!=
name|NULL
condition|)
block|{
name|oct
operator|=
name|iq
operator|->
name|oct_dev
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|iq
operator|->
name|lock
argument_list|)
expr_stmt|;
name|lio_write_csr32
argument_list|(
name|oct
argument_list|,
name|iq
operator|->
name|inst_cnt_reg
argument_list|,
name|iq
operator|->
name|pkt_in_done
argument_list|)
expr_stmt|;
name|iq
operator|->
name|pkt_in_done
operator|=
literal|0
expr_stmt|;
comment|/* this write needs to be flushed before we release the lock */
name|__compiler_membar
argument_list|()
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|iq
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Implementation note: 	 * 	 * SLI_PKT(x)_CNTS[RESEND] is written separately so that if an interrupt 	 * DOES occur as a result of RESEND, the DROQ lock will NOT be held. 	 * 	 * Write resend. Writing RESEND in SLI_PKTX_CNTS should be enough 	 * to trigger tx interrupts as well, if they are pending. 	 */
if|if
condition|(
operator|(
name|oct
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|LIO_CN23XX_PF
argument_list|(
name|oct
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|droq
operator|!=
name|NULL
condition|)
name|lio_write_csr64
argument_list|(
name|oct
argument_list|,
name|droq
operator|->
name|pkts_sent_reg
argument_list|,
name|LIO_CN23XX_INTR_RESEND
argument_list|)
expr_stmt|;
comment|/* we race with firmrware here. */
comment|/* read and write the IN_DONE_CNTS */
elseif|else
if|if
condition|(
name|iq
operator|!=
name|NULL
condition|)
block|{
name|instr_cnt
operator|=
name|lio_read_csr64
argument_list|(
name|oct
argument_list|,
name|iq
operator|->
name|inst_cnt_reg
argument_list|)
expr_stmt|;
name|lio_write_csr64
argument_list|(
name|oct
argument_list|,
name|iq
operator|->
name|inst_cnt_reg
argument_list|,
operator|(
operator|(
name|instr_cnt
operator|&
literal|0xFFFFFFFF00000000ULL
operator|)
operator||
name|LIO_CN23XX_INTR_RESEND
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

