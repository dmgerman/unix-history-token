begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *   BSD LICENSE  *  *   Copyright(c) 2017 Cavium, Inc.. All rights reserved.  *   All rights reserved.  *  *   Redistribution and use in source and binary forms, with or without  *   modification, are permitted provided that the following conditions  *   are met:  *  *     * Redistributions of source code must retain the above copyright  *       notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above copyright  *       notice, this list of conditions and the following disclaimer in  *       the documentation and/or other materials provided with the  *       distribution.  *     * Neither the name of Cavium, Inc. nor the names of its  *       contributors may be used to endorse or promote products derived  *       from this software without specific prior written permission.  *  *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  *   OWNER(S) OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_comment
comment|/*  * @file lio_console.c  */
end_comment

begin_include
include|#
directive|include
file|"lio_bsd.h"
end_include

begin_include
include|#
directive|include
file|"lio_common.h"
end_include

begin_include
include|#
directive|include
file|"lio_droq.h"
end_include

begin_include
include|#
directive|include
file|"lio_iq.h"
end_include

begin_include
include|#
directive|include
file|"lio_response_manager.h"
end_include

begin_include
include|#
directive|include
file|"lio_device.h"
end_include

begin_include
include|#
directive|include
file|"lio_image.h"
end_include

begin_include
include|#
directive|include
file|"lio_mem_ops.h"
end_include

begin_include
include|#
directive|include
file|"lio_main.h"
end_include

begin_function_decl
specifier|static
name|void
name|lio_get_uboot_version
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lio_remote_lock
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lio_remote_unlock
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|cvmx_bootmem_phy_named_block_find
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lio_console_read
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|uint32_t
name|console_num
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|uint32_t
name|buf_size
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|CAST_ULL
parameter_list|(
name|v
parameter_list|)
value|((unsigned long long)(v))
end_define

begin_define
define|#
directive|define
name|LIO_BOOTLOADER_PCI_READ_BUFFER_DATA_ADDR
value|0x0006c008
end_define

begin_define
define|#
directive|define
name|LIO_BOOTLOADER_PCI_READ_BUFFER_LEN_ADDR
value|0x0006c004
end_define

begin_define
define|#
directive|define
name|LIO_BOOTLOADER_PCI_READ_BUFFER_OWNER_ADDR
value|0x0006c000
end_define

begin_define
define|#
directive|define
name|LIO_BOOTLOADER_PCI_READ_DESC_ADDR
value|0x0006c100
end_define

begin_define
define|#
directive|define
name|LIO_BOOTLOADER_PCI_WRITE_BUFFER_STR_LEN
value|248
end_define

begin_define
define|#
directive|define
name|LIO_PCI_IO_BUF_OWNER_OCTEON
value|0x00000001
end_define

begin_define
define|#
directive|define
name|LIO_PCI_IO_BUF_OWNER_HOST
value|0x00000002
end_define

begin_define
define|#
directive|define
name|LIO_PCI_CONSOLE_BLOCK_NAME
value|"__pci_console"
end_define

begin_define
define|#
directive|define
name|LIO_CONSOLE_POLL_INTERVAL_MS
value|100
end_define

begin_comment
comment|/* 10 times per second */
end_comment

begin_comment
comment|/*  * First three members of cvmx_bootmem_desc are left in original positions  * for backwards compatibility. Assumes big endian target  */
end_comment

begin_struct
struct|struct
name|cvmx_bootmem_desc
block|{
comment|/* lock to control access to list */
name|uint32_t
name|lock
decl_stmt|;
comment|/* flags for indicating various conditions */
name|uint32_t
name|flags
decl_stmt|;
name|uint64_t
name|head_addr
decl_stmt|;
comment|/* incremented changed when incompatible changes made */
name|uint32_t
name|major_version
decl_stmt|;
comment|/* 	 * incremented changed when compatible changes made, reset to zero 	 * when major incremented 	 */
name|uint32_t
name|minor_version
decl_stmt|;
name|uint64_t
name|app_data_addr
decl_stmt|;
name|uint64_t
name|app_data_size
decl_stmt|;
comment|/* number of elements in named blocks array */
name|uint32_t
name|nb_num_blocks
decl_stmt|;
comment|/* length of name array in bootmem blocks */
name|uint32_t
name|named_block_name_len
decl_stmt|;
comment|/* address of named memory block descriptors */
name|uint64_t
name|named_block_array_addr
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Structure that defines a single console.  *  * Note: when read_index == write_index, the buffer is empty. The actual usable  * size of each console is console_buf_size -1;  */
end_comment

begin_struct
struct|struct
name|lio_pci_console
block|{
name|uint64_t
name|input_base_addr
decl_stmt|;
name|uint32_t
name|input_read_index
decl_stmt|;
name|uint32_t
name|input_write_index
decl_stmt|;
name|uint64_t
name|output_base_addr
decl_stmt|;
name|uint32_t
name|output_read_index
decl_stmt|;
name|uint32_t
name|output_write_index
decl_stmt|;
name|uint32_t
name|lock
decl_stmt|;
name|uint32_t
name|buf_size
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * This is the main container structure that contains all the information  * about all PCI consoles.  The address of this structure is passed to  * various routines that operation on PCI consoles.  */
end_comment

begin_struct
struct|struct
name|lio_pci_console_desc
block|{
name|uint32_t
name|major_version
decl_stmt|;
name|uint32_t
name|minor_version
decl_stmt|;
name|uint32_t
name|lock
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|uint32_t
name|num_consoles
decl_stmt|;
name|uint32_t
name|pad
decl_stmt|;
comment|/* must be 64 bit aligned here... */
comment|/* Array of addresses of octeon_pci_console structures */
name|uint64_t
name|console_addr_array
index|[
literal|1
index|]
decl_stmt|;
comment|/* Implicit storage for console_addr_array */
block|}
struct|;
end_struct

begin_comment
comment|/*  * This macro returns the size of a member of a structure. Logically it is  * the same as "sizeof(s::field)" in C++, but C lacks the "::" operator.  */
end_comment

begin_define
define|#
directive|define
name|SIZEOF_FIELD
parameter_list|(
name|s
parameter_list|,
name|field
parameter_list|)
value|sizeof(((s *)NULL)->field)
end_define

begin_comment
comment|/*  * This function is the implementation of the get macros defined  * for individual structure members. The argument are generated  * by the macros inorder to read only the needed memory.  *  * @param oct    Pointer to current octeon device  * @param base   64bit physical address of the complete structure  * @param offset Offset from the beginning of the structure to the member being  *		 accessed.  * @param size   Size of the structure member.  *  * @return Value of the structure member promoted into a uint64_t.  */
end_comment

begin_function
specifier|static
specifier|inline
name|uint64_t
name|__cvmx_bootmem_desc_get
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|uint64_t
name|base
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint32_t
name|size
parameter_list|)
block|{
name|base
operator|=
operator|(
literal|1ull
operator|<<
literal|63
operator|)
operator||
operator|(
name|base
operator|+
name|offset
operator|)
expr_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|4
case|:
return|return
operator|(
name|lio_read_device_mem32
argument_list|(
name|oct
argument_list|,
name|base
argument_list|)
operator|)
return|;
case|case
literal|8
case|:
return|return
operator|(
name|lio_read_device_mem64
argument_list|(
name|oct
argument_list|,
name|base
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * This function retrieves the string name of a named block. It is  * more complicated than a simple memcpy() since the named block  * descriptor may not be directly accessible.  *  * @param oct    Pointer to current octeon device  * @param addr   Physical address of the named block descriptor  * @param str    String to receive the named block string name  * @param len    Length of the string buffer, which must match the length  *		 stored in the bootmem descriptor.  */
end_comment

begin_function
specifier|static
name|void
name|lio_bootmem_named_get_name
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|uint64_t
name|addr
parameter_list|,
name|char
modifier|*
name|str
parameter_list|,
name|uint32_t
name|len
parameter_list|)
block|{
name|addr
operator|+=
name|offsetof
argument_list|(
expr|struct
name|cvmx_bootmem_named_block_desc
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|lio_pci_read_core_mem
argument_list|(
name|oct
argument_list|,
name|addr
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|str
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* See header file for descriptions of functions */
end_comment

begin_comment
comment|/*  * Check the version information on the bootmem descriptor  *  * @param oct    Pointer to current octeon device  * @param exact_match  *		Exact major version to check against. A zero means  *		check that the version supports named blocks.  *  * @return Zero if the version is correct. Negative if the version is  *	   incorrect. Failures also cause a message to be displayed.  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_bootmem_check_version
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|uint32_t
name|exact_match
parameter_list|)
block|{
name|uint32_t
name|major_version
decl_stmt|;
name|uint32_t
name|minor_version
decl_stmt|;
if|if
condition|(
operator|!
name|oct
operator|->
name|bootmem_desc_addr
condition|)
name|oct
operator|->
name|bootmem_desc_addr
operator|=
name|lio_read_device_mem64
argument_list|(
name|oct
argument_list|,
name|LIO_BOOTLOADER_PCI_READ_DESC_ADDR
argument_list|)
expr_stmt|;
name|major_version
operator|=
operator|(
name|uint32_t
operator|)
name|__cvmx_bootmem_desc_get
argument_list|(
name|oct
argument_list|,
name|oct
operator|->
name|bootmem_desc_addr
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|cvmx_bootmem_desc
argument_list|,
name|major_version
argument_list|)
argument_list|,
name|SIZEOF_FIELD
argument_list|(
expr|struct
name|cvmx_bootmem_desc
argument_list|,
name|major_version
argument_list|)
argument_list|)
expr_stmt|;
name|minor_version
operator|=
operator|(
name|uint32_t
operator|)
name|__cvmx_bootmem_desc_get
argument_list|(
name|oct
argument_list|,
name|oct
operator|->
name|bootmem_desc_addr
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|cvmx_bootmem_desc
argument_list|,
name|minor_version
argument_list|)
argument_list|,
name|SIZEOF_FIELD
argument_list|(
expr|struct
name|cvmx_bootmem_desc
argument_list|,
name|minor_version
argument_list|)
argument_list|)
expr_stmt|;
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"%s: major_version=%d\n"
argument_list|,
name|__func__
argument_list|,
name|major_version
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|major_version
operator|>
literal|3
operator|)
operator|||
operator|(
name|exact_match
operator|&&
name|major_version
operator|!=
name|exact_match
operator|)
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"bootmem ver mismatch %d.%d addr:0x%llx\n"
argument_list|,
name|major_version
argument_list|,
name|minor_version
argument_list|,
name|CAST_ULL
argument_list|(
name|oct
operator|->
name|bootmem_desc_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|struct
name|cvmx_bootmem_named_block_desc
modifier|*
name|__cvmx_bootmem_find_named_block_flags
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|struct
name|cvmx_bootmem_named_block_desc
modifier|*
name|desc
init|=
operator|&
name|oct
operator|->
name|bootmem_named_block_desc
decl_stmt|;
name|uint64_t
name|named_addr
decl_stmt|;
name|named_addr
operator|=
name|cvmx_bootmem_phy_named_block_find
argument_list|(
name|oct
argument_list|,
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|named_addr
condition|)
block|{
name|desc
operator|->
name|base_addr
operator|=
name|__cvmx_bootmem_desc_get
argument_list|(
name|oct
argument_list|,
name|named_addr
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|cvmx_bootmem_named_block_desc
argument_list|,
name|base_addr
argument_list|)
argument_list|,
name|SIZEOF_FIELD
argument_list|(
expr|struct
name|cvmx_bootmem_named_block_desc
argument_list|,
name|base_addr
argument_list|)
argument_list|)
expr_stmt|;
name|desc
operator|->
name|size
operator|=
name|__cvmx_bootmem_desc_get
argument_list|(
name|oct
argument_list|,
name|named_addr
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|cvmx_bootmem_named_block_desc
argument_list|,
name|size
argument_list|)
argument_list|,
name|SIZEOF_FIELD
argument_list|(
expr|struct
name|cvmx_bootmem_named_block_desc
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|desc
operator|->
name|name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|desc
operator|->
name|name
index|[
sizeof|sizeof
argument_list|(
name|desc
operator|->
name|name
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|&
name|oct
operator|->
name|bootmem_named_block_desc
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|cvmx_bootmem_phy_named_block_find
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|uint64_t
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|__cvmx_bootmem_check_version
argument_list|(
name|oct
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|uint64_t
name|named_block_array_addr
init|=
name|__cvmx_bootmem_desc_get
argument_list|(
name|oct
argument_list|,
name|oct
operator|->
name|bootmem_desc_addr
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|cvmx_bootmem_desc
argument_list|,
name|named_block_array_addr
argument_list|)
argument_list|,
name|SIZEOF_FIELD
argument_list|(
expr|struct
name|cvmx_bootmem_desc
argument_list|,
name|named_block_array_addr
argument_list|)
argument_list|)
decl_stmt|;
name|uint32_t
name|num_blocks
init|=
operator|(
name|uint32_t
operator|)
name|__cvmx_bootmem_desc_get
argument_list|(
name|oct
argument_list|,
name|oct
operator|->
name|bootmem_desc_addr
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|cvmx_bootmem_desc
argument_list|,
name|nb_num_blocks
argument_list|)
argument_list|,
name|SIZEOF_FIELD
argument_list|(
expr|struct
name|cvmx_bootmem_desc
argument_list|,
name|nb_num_blocks
argument_list|)
argument_list|)
decl_stmt|;
name|uint32_t
name|name_length
init|=
operator|(
name|uint32_t
operator|)
name|__cvmx_bootmem_desc_get
argument_list|(
name|oct
argument_list|,
name|oct
operator|->
name|bootmem_desc_addr
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|cvmx_bootmem_desc
argument_list|,
name|named_block_name_len
argument_list|)
argument_list|,
name|SIZEOF_FIELD
argument_list|(
expr|struct
name|cvmx_bootmem_desc
argument_list|,
name|named_block_name_len
argument_list|)
argument_list|)
decl_stmt|;
name|uint64_t
name|named_addr
init|=
name|named_block_array_addr
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_blocks
condition|;
name|i
operator|++
control|)
block|{
name|uint64_t
name|named_size
init|=
name|__cvmx_bootmem_desc_get
argument_list|(
name|oct
argument_list|,
name|named_addr
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|cvmx_bootmem_named_block_desc
argument_list|,
name|size
argument_list|)
argument_list|,
name|SIZEOF_FIELD
argument_list|(
expr|struct
name|cvmx_bootmem_named_block_desc
argument_list|,
name|size
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|&&
name|named_size
condition|)
block|{
name|char
modifier|*
name|name_tmp
init|=
name|malloc
argument_list|(
name|name_length
operator|+
literal|1
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|name_tmp
condition|)
break|break;
name|lio_bootmem_named_get_name
argument_list|(
name|oct
argument_list|,
name|named_addr
argument_list|,
name|name_tmp
argument_list|,
name|name_length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
name|name_tmp
argument_list|,
name|name_length
argument_list|)
condition|)
block|{
name|result
operator|=
name|named_addr
expr_stmt|;
name|free
argument_list|(
name|name_tmp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
block|}
name|free
argument_list|(
name|name_tmp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|name
operator|&&
operator|!
name|named_size
condition|)
block|{
name|result
operator|=
name|named_addr
expr_stmt|;
break|break;
block|}
name|named_addr
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|cvmx_bootmem_named_block_desc
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find a named block on the remote Octeon  *  * @param oct       Pointer to current octeon device  * @param name      Name of block to find  * @param base_addr Address the block is at (OUTPUT)  * @param size      The size of the block (OUTPUT)  *  * @return Zero on success, One on failure.  */
end_comment

begin_function
specifier|static
name|int
name|lio_named_block_find
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
modifier|*
name|base_addr
parameter_list|,
name|uint64_t
modifier|*
name|size
parameter_list|)
block|{
specifier|const
name|struct
name|cvmx_bootmem_named_block_desc
modifier|*
name|named_block
decl_stmt|;
name|lio_remote_lock
argument_list|()
expr_stmt|;
name|named_block
operator|=
name|__cvmx_bootmem_find_named_block_flags
argument_list|(
name|oct
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lio_remote_unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|named_block
operator|!=
name|NULL
condition|)
block|{
operator|*
name|base_addr
operator|=
name|named_block
operator|->
name|base_addr
expr_stmt|;
operator|*
name|size
operator|=
name|named_block
operator|->
name|size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lio_remote_lock
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* fill this in if any sharing is needed */
block|}
end_function

begin_function
specifier|static
name|void
name|lio_remote_unlock
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* fill this in if any sharing is needed */
block|}
end_function

begin_function
name|int
name|lio_console_send_cmd
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|char
modifier|*
name|cmd_str
parameter_list|,
name|uint32_t
name|wait_hundredths
parameter_list|)
block|{
name|uint32_t
name|len
init|=
operator|(
name|uint32_t
operator|)
name|strlen
argument_list|(
name|cmd_str
argument_list|)
decl_stmt|;
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"sending \"%s\" to bootloader\n"
argument_list|,
name|cmd_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|LIO_BOOTLOADER_PCI_WRITE_BUFFER_STR_LEN
operator|-
literal|1
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Command string too long, max length is: %d\n"
argument_list|,
name|LIO_BOOTLOADER_PCI_WRITE_BUFFER_STR_LEN
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|lio_wait_for_bootloader
argument_list|(
name|oct
argument_list|,
name|wait_hundredths
argument_list|)
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Bootloader not ready for command.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Write command to bootloader */
name|lio_remote_lock
argument_list|()
expr_stmt|;
name|lio_pci_write_core_mem
argument_list|(
name|oct
argument_list|,
name|LIO_BOOTLOADER_PCI_READ_BUFFER_DATA_ADDR
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|cmd_str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|lio_write_device_mem32
argument_list|(
name|oct
argument_list|,
name|LIO_BOOTLOADER_PCI_READ_BUFFER_LEN_ADDR
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|lio_write_device_mem32
argument_list|(
name|oct
argument_list|,
name|LIO_BOOTLOADER_PCI_READ_BUFFER_OWNER_ADDR
argument_list|,
name|LIO_PCI_IO_BUF_OWNER_OCTEON
argument_list|)
expr_stmt|;
comment|/* 	 * Bootloader should accept command very quickly if it really was 	 * ready 	 */
if|if
condition|(
name|lio_wait_for_bootloader
argument_list|(
name|oct
argument_list|,
literal|200
argument_list|)
condition|)
block|{
name|lio_remote_unlock
argument_list|()
expr_stmt|;
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Bootloader did not accept command.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|lio_remote_unlock
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lio_wait_for_bootloader
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|uint32_t
name|wait_time_hundredths
parameter_list|)
block|{
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"waiting %d0 ms for bootloader\n"
argument_list|,
name|wait_time_hundredths
argument_list|)
expr_stmt|;
if|if
condition|(
name|lio_mem_access_ok
argument_list|(
name|oct
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
while|while
condition|(
name|wait_time_hundredths
operator|>
literal|0
operator|&&
name|lio_read_device_mem32
argument_list|(
name|oct
argument_list|,
name|LIO_BOOTLOADER_PCI_READ_BUFFER_OWNER_ADDR
argument_list|)
operator|!=
name|LIO_PCI_IO_BUF_OWNER_HOST
condition|)
block|{
if|if
condition|(
operator|--
name|wait_time_hundredths
operator|<=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|lio_sleep_timeout
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lio_console_handle_result
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|size_t
name|console_num
parameter_list|)
block|{
name|struct
name|lio_console
modifier|*
name|console
decl_stmt|;
name|console
operator|=
operator|&
name|oct
operator|->
name|console
index|[
name|console_num
index|]
expr_stmt|;
name|console
operator|->
name|waiting
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|console_buffer
index|[
name|LIO_MAX_CONSOLE_READ_BYTES
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|lio_output_console_line
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|struct
name|lio_console
modifier|*
name|console
parameter_list|,
name|size_t
name|console_num
parameter_list|,
name|char
modifier|*
name|console_buffer
parameter_list|,
name|int32_t
name|bytes_read
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
name|int32_t
name|i
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|line
operator|=
name|console_buffer
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bytes_read
condition|;
name|i
operator|++
control|)
block|{
comment|/* Output a line at a time, prefixed */
if|if
condition|(
name|console_buffer
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
block|{
name|console_buffer
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* We need to output 'line', prefaced by 'leftover'. 			 * However, it is possible we're being called to 			 * output 'leftover' by itself (in the case of nothing 			 * having been read from the console). 			 * 			 * To avoid duplication, check for this condition. 			 */
if|if
condition|(
name|console
operator|->
name|leftover
index|[
literal|0
index|]
operator|&&
operator|(
name|line
operator|!=
name|console
operator|->
name|leftover
operator|)
condition|)
block|{
if|if
condition|(
name|console
operator|->
name|print
condition|)
call|(
modifier|*
name|console
operator|->
name|print
call|)
argument_list|(
name|oct
argument_list|,
operator|(
name|uint32_t
operator|)
name|console_num
argument_list|,
name|console
operator|->
name|leftover
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|console
operator|->
name|leftover
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|console
operator|->
name|print
condition|)
call|(
modifier|*
name|console
operator|->
name|print
call|)
argument_list|(
name|oct
argument_list|,
operator|(
name|uint32_t
operator|)
name|console_num
argument_list|,
name|line
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|line
operator|=
operator|&
name|console_buffer
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
block|}
comment|/* Save off any leftovers */
if|if
condition|(
name|line
operator|!=
operator|&
name|console_buffer
index|[
name|bytes_read
index|]
condition|)
block|{
name|console_buffer
index|[
name|bytes_read
index|]
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|console
operator|->
name|leftover
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|&
name|console
operator|->
name|leftover
index|[
name|len
index|]
argument_list|,
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|console
operator|->
name|leftover
argument_list|)
operator|-
name|len
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|lio_check_console
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|lio_console
modifier|*
name|console
decl_stmt|;
name|struct
name|lio_callout
modifier|*
name|console_callout
init|=
name|arg
decl_stmt|;
name|struct
name|octeon_device
modifier|*
name|oct
init|=
operator|(
expr|struct
name|octeon_device
operator|*
operator|)
name|console_callout
operator|->
name|ctxptr
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|uint32_t
name|console_num
init|=
operator|(
name|uint32_t
operator|)
name|console_callout
operator|->
name|ctxul
decl_stmt|;
name|int32_t
name|bytes_read
decl_stmt|,
name|total_read
decl_stmt|,
name|tries
decl_stmt|;
name|console
operator|=
operator|&
name|oct
operator|->
name|console
index|[
name|console_num
index|]
expr_stmt|;
name|tries
operator|=
literal|0
expr_stmt|;
name|total_read
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|callout_pending
argument_list|(
operator|&
name|console_callout
operator|->
name|timer
argument_list|)
operator|||
operator|(
name|callout_active
argument_list|(
operator|&
name|console_callout
operator|->
name|timer
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return;
do|do
block|{
comment|/* 		 * Take console output regardless of whether it will be 		 * logged 		 */
name|bytes_read
operator|=
name|lio_console_read
argument_list|(
name|oct
argument_list|,
name|console_num
argument_list|,
name|console_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|console_buffer
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|>
literal|0
condition|)
block|{
name|total_read
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
name|console
operator|->
name|waiting
condition|)
name|lio_console_handle_result
argument_list|(
name|oct
argument_list|,
name|console_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|console
operator|->
name|print
condition|)
block|{
name|lio_output_console_line
argument_list|(
name|oct
argument_list|,
name|console
argument_list|,
name|console_num
argument_list|,
name|console_buffer
argument_list|,
name|bytes_read
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|bytes_read
operator|<
literal|0
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Error reading console %u, ret=%d\n"
argument_list|,
name|console_num
argument_list|,
name|bytes_read
argument_list|)
expr_stmt|;
block|}
name|tries
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|bytes_read
operator|>
literal|0
operator|)
operator|&&
operator|(
name|tries
operator|<
literal|16
operator|)
condition|)
do|;
comment|/* 	 * If nothing is read after polling the console, output any leftovers 	 * if any 	 */
if|if
condition|(
name|console
operator|->
name|print
operator|&&
operator|(
name|total_read
operator|==
literal|0
operator|)
operator|&&
operator|(
name|console
operator|->
name|leftover
index|[
literal|0
index|]
operator|)
condition|)
block|{
comment|/* append '\n' as terminator for 'output_console_line' */
name|len
operator|=
name|strlen
argument_list|(
name|console
operator|->
name|leftover
argument_list|)
expr_stmt|;
name|console
operator|->
name|leftover
index|[
name|len
index|]
operator|=
literal|'\n'
expr_stmt|;
name|lio_output_console_line
argument_list|(
name|oct
argument_list|,
name|console
argument_list|,
name|console_num
argument_list|,
name|console
operator|->
name|leftover
argument_list|,
call|(
name|int32_t
call|)
argument_list|(
name|len
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|console
operator|->
name|leftover
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|callout_schedule
argument_list|(
operator|&
name|oct
operator|->
name|console_timer
index|[
name|console_num
index|]
operator|.
name|timer
argument_list|,
name|lio_ms_to_ticks
argument_list|(
name|LIO_CONSOLE_POLL_INTERVAL_MS
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|lio_init_consoles
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
name|uint64_t
name|addr
decl_stmt|,
name|size
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|ret
operator|=
name|lio_mem_access_ok
argument_list|(
name|oct
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Memory access not okay'\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|ret
operator|=
name|lio_named_block_find
argument_list|(
name|oct
argument_list|,
name|LIO_PCI_CONSOLE_BLOCK_NAME
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Could not find console '%s'\n"
argument_list|,
name|LIO_PCI_CONSOLE_BLOCK_NAME
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* 	 * Use BAR1_INDEX15 to create a static mapping to a region of 	 * Octeon's DRAM that contains the PCI console named block. 	 */
name|oct
operator|->
name|console_nb_info
operator|.
name|bar1_index
operator|=
literal|15
expr_stmt|;
name|oct
operator|->
name|fn_list
operator|.
name|bar1_idx_setup
argument_list|(
name|oct
argument_list|,
name|addr
argument_list|,
name|oct
operator|->
name|console_nb_info
operator|.
name|bar1_index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|oct
operator|->
name|console_nb_info
operator|.
name|dram_region_base
operator|=
name|addr
operator|&
literal|0xFFFFFFFFFFC00000ULL
expr_stmt|;
comment|/* 	 * num_consoles> 0, is an indication that the consoles are 	 * accessible 	 */
name|oct
operator|->
name|num_consoles
operator|=
name|lio_read_device_mem32
argument_list|(
name|oct
argument_list|,
name|addr
operator|+
name|offsetof
argument_list|(
expr|struct
name|lio_pci_console_desc
argument_list|,
name|num_consoles
argument_list|)
argument_list|)
expr_stmt|;
name|oct
operator|->
name|console_desc_addr
operator|=
name|addr
expr_stmt|;
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"Initialized consoles. %d available\n"
argument_list|,
name|oct
operator|->
name|num_consoles
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lio_add_console
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|uint32_t
name|console_num
parameter_list|,
name|char
modifier|*
name|dbg_enb
parameter_list|)
block|{
name|struct
name|callout
modifier|*
name|timer
decl_stmt|;
name|struct
name|lio_console
modifier|*
name|console
decl_stmt|;
name|uint64_t
name|coreaddr
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|console_num
operator|>=
name|oct
operator|->
name|num_consoles
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"trying to read from console number %d when only 0 to %d exist\n"
argument_list|,
name|console_num
argument_list|,
name|oct
operator|->
name|num_consoles
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|console
operator|=
operator|&
name|oct
operator|->
name|console
index|[
name|console_num
index|]
expr_stmt|;
name|console
operator|->
name|waiting
operator|=
literal|0
expr_stmt|;
name|coreaddr
operator|=
name|oct
operator|->
name|console_desc_addr
operator|+
name|console_num
operator|*
literal|8
operator|+
name|offsetof
argument_list|(
expr|struct
name|lio_pci_console_desc
argument_list|,
name|console_addr_array
argument_list|)
expr_stmt|;
name|console
operator|->
name|addr
operator|=
name|lio_read_device_mem64
argument_list|(
name|oct
argument_list|,
name|coreaddr
argument_list|)
expr_stmt|;
name|coreaddr
operator|=
name|console
operator|->
name|addr
operator|+
name|offsetof
argument_list|(
expr|struct
name|lio_pci_console
argument_list|,
name|buf_size
argument_list|)
expr_stmt|;
name|console
operator|->
name|buffer_size
operator|=
name|lio_read_device_mem32
argument_list|(
name|oct
argument_list|,
name|coreaddr
argument_list|)
expr_stmt|;
name|coreaddr
operator|=
name|console
operator|->
name|addr
operator|+
name|offsetof
argument_list|(
expr|struct
name|lio_pci_console
argument_list|,
name|input_base_addr
argument_list|)
expr_stmt|;
name|console
operator|->
name|input_base_addr
operator|=
name|lio_read_device_mem64
argument_list|(
name|oct
argument_list|,
name|coreaddr
argument_list|)
expr_stmt|;
name|coreaddr
operator|=
name|console
operator|->
name|addr
operator|+
name|offsetof
argument_list|(
expr|struct
name|lio_pci_console
argument_list|,
name|output_base_addr
argument_list|)
expr_stmt|;
name|console
operator|->
name|output_base_addr
operator|=
name|lio_read_device_mem64
argument_list|(
name|oct
argument_list|,
name|coreaddr
argument_list|)
expr_stmt|;
name|console
operator|->
name|leftover
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|timer
operator|=
operator|&
name|oct
operator|->
name|console_timer
index|[
name|console_num
index|]
operator|.
name|timer
expr_stmt|;
if|if
condition|(
name|oct
operator|->
name|uboot_len
operator|==
literal|0
condition|)
name|lio_get_uboot_version
argument_list|(
name|oct
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
name|timer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|oct
operator|->
name|console_timer
index|[
name|console_num
index|]
operator|.
name|ctxptr
operator|=
operator|(
name|void
operator|*
operator|)
name|oct
expr_stmt|;
name|oct
operator|->
name|console_timer
index|[
name|console_num
index|]
operator|.
name|ctxul
operator|=
name|console_num
expr_stmt|;
name|callout_reset
argument_list|(
name|timer
argument_list|,
name|lio_ms_to_ticks
argument_list|(
name|LIO_CONSOLE_POLL_INTERVAL_MS
argument_list|)
argument_list|,
name|lio_check_console
argument_list|,
name|timer
argument_list|)
expr_stmt|;
comment|/* an empty string means use default debug console enablement */
if|if
condition|(
name|dbg_enb
operator|&&
operator|!
name|dbg_enb
index|[
literal|0
index|]
condition|)
name|dbg_enb
operator|=
literal|"setenv pci_console_active 1"
expr_stmt|;
if|if
condition|(
name|dbg_enb
condition|)
name|ret
operator|=
name|lio_console_send_cmd
argument_list|(
name|oct
argument_list|,
name|dbg_enb
argument_list|,
literal|2000
argument_list|)
expr_stmt|;
name|console
operator|->
name|active
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Removes all consoles  *  * @param oct         octeon device  */
end_comment

begin_function
name|void
name|lio_remove_consoles
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
name|struct
name|lio_console
modifier|*
name|console
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oct
operator|->
name|num_consoles
condition|;
name|i
operator|++
control|)
block|{
name|console
operator|=
operator|&
name|oct
operator|->
name|console
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|console
operator|->
name|active
condition|)
continue|continue;
name|callout_stop
argument_list|(
operator|&
name|oct
operator|->
name|console_timer
index|[
name|i
index|]
operator|.
name|timer
argument_list|)
expr_stmt|;
name|console
operator|->
name|addr
operator|=
literal|0
expr_stmt|;
name|console
operator|->
name|buffer_size
operator|=
literal|0
expr_stmt|;
name|console
operator|->
name|input_base_addr
operator|=
literal|0
expr_stmt|;
name|console
operator|->
name|output_base_addr
operator|=
literal|0
expr_stmt|;
block|}
name|oct
operator|->
name|num_consoles
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|lio_console_free_bytes
parameter_list|(
name|uint32_t
name|buffer_size
parameter_list|,
name|uint32_t
name|wr_idx
parameter_list|,
name|uint32_t
name|rd_idx
parameter_list|)
block|{
if|if
condition|(
name|rd_idx
operator|>=
name|buffer_size
operator|||
name|wr_idx
operator|>=
name|buffer_size
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
operator|(
operator|(
name|buffer_size
operator|-
literal|1
operator|)
operator|-
operator|(
name|wr_idx
operator|-
name|rd_idx
operator|)
operator|)
operator|%
name|buffer_size
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|lio_console_avail_bytes
parameter_list|(
name|uint32_t
name|buffer_size
parameter_list|,
name|uint32_t
name|wr_idx
parameter_list|,
name|uint32_t
name|rd_idx
parameter_list|)
block|{
if|if
condition|(
name|rd_idx
operator|>=
name|buffer_size
operator|||
name|wr_idx
operator|>=
name|buffer_size
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|buffer_size
operator|-
literal|1
operator|-
name|lio_console_free_bytes
argument_list|(
name|buffer_size
argument_list|,
name|wr_idx
argument_list|,
name|rd_idx
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lio_console_read
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|uint32_t
name|console_num
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|uint32_t
name|buf_size
parameter_list|)
block|{
name|struct
name|lio_console
modifier|*
name|console
decl_stmt|;
name|int
name|bytes_to_read
decl_stmt|;
name|uint32_t
name|rd_idx
decl_stmt|,
name|wr_idx
decl_stmt|;
if|if
condition|(
name|console_num
operator|>=
name|oct
operator|->
name|num_consoles
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Attempted to read from disabled console %d\n"
argument_list|,
name|console_num
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|console
operator|=
operator|&
name|oct
operator|->
name|console
index|[
name|console_num
index|]
expr_stmt|;
comment|/* 	 * Check to see if any data is available. Maybe optimize this with 	 * 64-bit read. 	 */
name|rd_idx
operator|=
name|lio_read_device_mem32
argument_list|(
name|oct
argument_list|,
name|console
operator|->
name|addr
operator|+
name|offsetof
argument_list|(
expr|struct
name|lio_pci_console
argument_list|,
name|output_read_index
argument_list|)
argument_list|)
expr_stmt|;
name|wr_idx
operator|=
name|lio_read_device_mem32
argument_list|(
name|oct
argument_list|,
name|console
operator|->
name|addr
operator|+
name|offsetof
argument_list|(
expr|struct
name|lio_pci_console
argument_list|,
name|output_write_index
argument_list|)
argument_list|)
expr_stmt|;
name|bytes_to_read
operator|=
name|lio_console_avail_bytes
argument_list|(
name|console
operator|->
name|buffer_size
argument_list|,
name|wr_idx
argument_list|,
name|rd_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_to_read
operator|<=
literal|0
condition|)
return|return
operator|(
name|bytes_to_read
operator|)
return|;
name|bytes_to_read
operator|=
name|min
argument_list|(
name|bytes_to_read
argument_list|,
name|buf_size
argument_list|)
expr_stmt|;
comment|/* 	 * Check to see if what we want to read is not contiguous, and limit 	 * ourselves to the contiguous block 	 */
if|if
condition|(
name|rd_idx
operator|+
name|bytes_to_read
operator|>=
name|console
operator|->
name|buffer_size
condition|)
name|bytes_to_read
operator|=
name|console
operator|->
name|buffer_size
operator|-
name|rd_idx
expr_stmt|;
name|lio_pci_read_core_mem
argument_list|(
name|oct
argument_list|,
name|console
operator|->
name|output_base_addr
operator|+
name|rd_idx
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|buffer
argument_list|,
name|bytes_to_read
argument_list|)
expr_stmt|;
name|lio_write_device_mem32
argument_list|(
name|oct
argument_list|,
name|console
operator|->
name|addr
operator|+
name|offsetof
argument_list|(
expr|struct
name|lio_pci_console
argument_list|,
name|output_read_index
argument_list|)
argument_list|,
operator|(
name|rd_idx
operator|+
name|bytes_to_read
operator|)
operator|%
name|console
operator|->
name|buffer_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|bytes_to_read
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lio_get_uboot_version
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
name|struct
name|lio_console
modifier|*
name|console
decl_stmt|;
name|int32_t
name|bytes_read
decl_stmt|,
name|total_read
decl_stmt|,
name|tries
decl_stmt|;
name|uint32_t
name|console_num
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|ret
operator|=
name|lio_console_send_cmd
argument_list|(
name|oct
argument_list|,
literal|"setenv stdout pci"
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|console
operator|=
operator|&
name|oct
operator|->
name|console
index|[
name|console_num
index|]
expr_stmt|;
name|tries
operator|=
literal|0
expr_stmt|;
name|total_read
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|lio_console_send_cmd
argument_list|(
name|oct
argument_list|,
literal|"version"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
comment|/* 		 * Take console output regardless of whether it will be 		 * logged 		 */
name|bytes_read
operator|=
name|lio_console_read
argument_list|(
name|oct
argument_list|,
name|console_num
argument_list|,
name|oct
operator|->
name|uboot_version
operator|+
name|total_read
argument_list|,
name|OCTEON_UBOOT_BUFFER_SIZE
operator|-
literal|1
operator|-
name|total_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|>
literal|0
condition|)
block|{
name|oct
operator|->
name|uboot_version
index|[
name|bytes_read
index|]
operator|=
literal|0x0
expr_stmt|;
name|total_read
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
name|console
operator|->
name|waiting
condition|)
name|lio_console_handle_result
argument_list|(
name|oct
argument_list|,
name|console_num
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bytes_read
operator|<
literal|0
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Error reading console %u, ret=%d\n"
argument_list|,
name|console_num
argument_list|,
name|bytes_read
argument_list|)
expr_stmt|;
block|}
name|tries
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|bytes_read
operator|>
literal|0
operator|)
operator|&&
operator|(
name|tries
operator|<
literal|16
operator|)
condition|)
do|;
comment|/* 	 * If nothing is read after polling the console, output any leftovers 	 * if any 	 */
if|if
condition|(
operator|(
name|total_read
operator|==
literal|0
operator|)
operator|&&
operator|(
name|console
operator|->
name|leftover
index|[
literal|0
index|]
operator|)
condition|)
block|{
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"%u: %s\n"
argument_list|,
name|console_num
argument_list|,
name|console
operator|->
name|leftover
argument_list|)
expr_stmt|;
name|console
operator|->
name|leftover
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|ret
operator|=
name|lio_console_send_cmd
argument_list|(
name|oct
argument_list|,
literal|"setenv stdout serial"
argument_list|,
literal|50
argument_list|)
expr_stmt|;
comment|/* U-Boot */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|OCTEON_UBOOT_BUFFER_SIZE
operator|-
literal|9
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|oct
operator|->
name|uboot_version
index|[
name|i
index|]
operator|==
literal|'U'
operator|&&
name|oct
operator|->
name|uboot_version
index|[
name|i
operator|+
literal|2
index|]
operator|==
literal|'B'
operator|&&
name|oct
operator|->
name|uboot_version
index|[
name|i
operator|+
literal|3
index|]
operator|==
literal|'o'
operator|&&
name|oct
operator|->
name|uboot_version
index|[
name|i
operator|+
literal|4
index|]
operator|==
literal|'o'
operator|&&
name|oct
operator|->
name|uboot_version
index|[
name|i
operator|+
literal|5
index|]
operator|==
literal|'t'
condition|)
block|{
name|oct
operator|->
name|uboot_sidx
operator|=
name|i
expr_stmt|;
name|i
operator|++
expr_stmt|;
for|for
control|(
init|;
name|oct
operator|->
name|uboot_version
index|[
name|i
index|]
operator|!=
literal|0x0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|oct
operator|->
name|uboot_version
index|[
name|i
index|]
operator|==
literal|'m'
operator|&&
name|oct
operator|->
name|uboot_version
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'i'
operator|&&
name|oct
operator|->
name|uboot_version
index|[
name|i
operator|+
literal|2
index|]
operator|==
literal|'p'
operator|&&
name|oct
operator|->
name|uboot_version
index|[
name|i
operator|+
literal|3
index|]
operator|==
literal|'s'
condition|)
block|{
name|oct
operator|->
name|uboot_eidx
operator|=
name|i
operator|-
literal|1
expr_stmt|;
name|oct
operator|->
name|uboot_version
index|[
name|i
operator|-
literal|1
index|]
operator|=
literal|0x0
expr_stmt|;
name|oct
operator|->
name|uboot_len
operator|=
name|oct
operator|->
name|uboot_eidx
operator|-
name|oct
operator|->
name|uboot_sidx
operator|+
literal|1
expr_stmt|;
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"%s\n"
argument_list|,
operator|&
name|oct
operator|->
name|uboot_version
index|[
name|oct
operator|->
name|uboot_sidx
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
block|}
end_function

begin_define
define|#
directive|define
name|FBUF_SIZE
value|(4 * 1024 * 1024)
end_define

begin_function
name|int
name|lio_download_firmware
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|data
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|struct
name|lio_firmware_file_header
modifier|*
name|h
decl_stmt|;
name|uint64_t
name|load_addr
decl_stmt|;
name|uint32_t
name|crc32_result
decl_stmt|,
name|i
decl_stmt|,
name|image_len
decl_stmt|,
name|rem
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|size
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|lio_firmware_file_header
argument_list|)
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Firmware file too small (%d< %d).\n"
argument_list|,
operator|(
name|uint32_t
operator|)
name|size
argument_list|,
operator|(
name|uint32_t
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|lio_firmware_file_header
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|EINVAL
operator|)
return|;
block|}
name|h
operator|=
name|__DECONST
argument_list|(
expr|struct
name|lio_firmware_file_header
operator|*
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|be32toh
argument_list|(
name|h
operator|->
name|magic
argument_list|)
operator|!=
name|LIO_NIC_MAGIC
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Unrecognized firmware file.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|EINVAL
operator|)
return|;
block|}
name|crc32_result
operator|=
name|crc32
argument_list|(
name|data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lio_firmware_file_header
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|crc32_result
operator|!=
name|be32toh
argument_list|(
name|h
operator|->
name|crc32
argument_list|)
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Firmware CRC mismatch (0x%08x != 0x%08x).\n"
argument_list|,
name|crc32_result
argument_list|,
name|be32toh
argument_list|(
name|h
operator|->
name|crc32
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|memcmp
argument_list|(
name|LIO_BASE_VERSION
argument_list|,
name|h
operator|->
name|version
argument_list|,
name|strlen
argument_list|(
name|LIO_BASE_VERSION
argument_list|)
argument_list|)
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Unmatched firmware version. Expected %s.x, got %s.\n"
argument_list|,
name|LIO_BASE_VERSION
argument_list|,
name|h
operator|->
name|version
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|be32toh
argument_list|(
name|h
operator|->
name|num_images
argument_list|)
operator|>
name|LIO_MAX_IMAGES
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Too many images in firmware file (%d).\n"
argument_list|,
name|be32toh
argument_list|(
name|h
operator|->
name|num_images
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|EINVAL
operator|)
return|;
block|}
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"Firmware version: %s\n"
argument_list|,
name|h
operator|->
name|version
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|oct
operator|->
name|fw_info
operator|.
name|lio_firmware_version
argument_list|,
literal|32
argument_list|,
literal|"LIQUIDIO: %s"
argument_list|,
name|h
operator|->
name|version
argument_list|)
expr_stmt|;
name|data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|lio_firmware_file_header
argument_list|)
expr_stmt|;
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"Loading %d image(s)\n"
argument_list|,
name|be32toh
argument_list|(
name|h
operator|->
name|num_images
argument_list|)
argument_list|)
expr_stmt|;
comment|/* load all images */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|be32toh
argument_list|(
name|h
operator|->
name|num_images
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|load_addr
operator|=
name|be64toh
argument_list|(
name|h
operator|->
name|desc
index|[
name|i
index|]
operator|.
name|addr
argument_list|)
expr_stmt|;
name|image_len
operator|=
name|be32toh
argument_list|(
name|h
operator|->
name|desc
index|[
name|i
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"Loading firmware %d at %llx\n"
argument_list|,
name|image_len
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|load_addr
argument_list|)
expr_stmt|;
comment|/* Write in 4MB chunks */
name|rem
operator|=
name|image_len
expr_stmt|;
while|while
condition|(
name|rem
condition|)
block|{
if|if
condition|(
name|rem
operator|<
name|FBUF_SIZE
condition|)
name|size
operator|=
name|rem
expr_stmt|;
else|else
name|size
operator|=
name|FBUF_SIZE
expr_stmt|;
comment|/* download the image */
name|lio_pci_write_core_mem
argument_list|(
name|oct
argument_list|,
name|load_addr
argument_list|,
name|__DECONST
argument_list|(
name|uint8_t
operator|*
argument_list|,
name|data
argument_list|)
argument_list|,
operator|(
name|uint32_t
operator|)
name|size
argument_list|)
expr_stmt|;
name|data
operator|+=
name|size
expr_stmt|;
name|rem
operator|-=
operator|(
name|uint32_t
operator|)
name|size
expr_stmt|;
name|load_addr
operator|+=
name|size
expr_stmt|;
block|}
block|}
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"Writing boot command: %s\n"
argument_list|,
name|h
operator|->
name|bootcmd
argument_list|)
expr_stmt|;
comment|/* Invoke the bootcmd */
name|ret
operator|=
name|lio_console_send_cmd
argument_list|(
name|oct
argument_list|,
name|h
operator|->
name|bootcmd
argument_list|,
literal|50
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

