begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *   BSD LICENSE  *  *   Copyright(c) 2017 Cavium, Inc.. All rights reserved.  *   All rights reserved.  *  *   Redistribution and use in source and binary forms, with or without  *   modification, are permitted provided that the following conditions  *   are met:  *  *     * Redistributions of source code must retain the above copyright  *       notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above copyright  *       notice, this list of conditions and the following disclaimer in  *       the documentation and/or other materials provided with the  *       distribution.  *     * Neither the name of Cavium, Inc. nor the names of its  *       contributors may be used to endorse or promote products derived  *       from this software without specific prior written permission.  *  *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  *   OWNER(S) OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"lio_bsd.h"
end_include

begin_include
include|#
directive|include
file|"lio_common.h"
end_include

begin_include
include|#
directive|include
file|"lio_droq.h"
end_include

begin_include
include|#
directive|include
file|"lio_iq.h"
end_include

begin_include
include|#
directive|include
file|"lio_response_manager.h"
end_include

begin_include
include|#
directive|include
file|"lio_device.h"
end_include

begin_include
include|#
directive|include
file|"cn23xx_pf_device.h"
end_include

begin_include
include|#
directive|include
file|"lio_main.h"
end_include

begin_include
include|#
directive|include
file|"lio_rss.h"
end_include

begin_function
specifier|static
name|int
name|lio_cn23xx_pf_soft_reset
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
name|lio_write_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_WIN_WR_MASK_REG
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"BIST enabled for CN23XX soft reset\n"
argument_list|)
expr_stmt|;
name|lio_write_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_SCRATCH1
argument_list|,
literal|0x1234ULL
argument_list|)
expr_stmt|;
comment|/* Initiate chip-wide soft reset */
name|lio_pci_readq
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_RST_SOFT_RST
argument_list|)
expr_stmt|;
name|lio_pci_writeq
argument_list|(
name|oct
argument_list|,
literal|1
argument_list|,
name|LIO_CN23XX_RST_SOFT_RST
argument_list|)
expr_stmt|;
comment|/* Wait for 100ms as Octeon resets. */
name|lio_mdelay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|lio_read_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_SCRATCH1
argument_list|)
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Soft reset failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"Reset completed\n"
argument_list|)
expr_stmt|;
comment|/* restore the  reset value */
name|lio_write_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_WIN_WR_MASK_REG
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lio_cn23xx_pf_enable_error_reporting
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
name|uint32_t
name|corrtable_err_status
decl_stmt|,
name|uncorrectable_err_mask
decl_stmt|,
name|regval
decl_stmt|;
name|regval
operator|=
name|lio_read_pci_cfg
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_CFG_PCIE_DEVCTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|regval
operator|&
name|LIO_CN23XX_CFG_PCIE_DEVCTL_MASK
condition|)
block|{
name|uncorrectable_err_mask
operator|=
literal|0
expr_stmt|;
name|corrtable_err_status
operator|=
literal|0
expr_stmt|;
name|uncorrectable_err_mask
operator|=
name|lio_read_pci_cfg
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_CFG_PCIE_UNCORRECT_ERR_MASK
argument_list|)
expr_stmt|;
name|corrtable_err_status
operator|=
name|lio_read_pci_cfg
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_CFG_PCIE_CORRECT_ERR_STATUS
argument_list|)
expr_stmt|;
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"PCI-E Fatal error detected;\n"
literal|"\tdev_ctl_status_reg = 0x%08x\n"
literal|"\tuncorrectable_error_mask_reg = 0x%08x\n"
literal|"\tcorrectable_error_status_reg = 0x%08x\n"
argument_list|,
name|regval
argument_list|,
name|uncorrectable_err_mask
argument_list|,
name|corrtable_err_status
argument_list|)
expr_stmt|;
block|}
name|regval
operator||=
literal|0xf
expr_stmt|;
comment|/* Enable Link error reporting */
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"Enabling PCI-E error reporting..\n"
argument_list|)
expr_stmt|;
name|lio_write_pci_cfg
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_CFG_PCIE_DEVCTL
argument_list|,
name|regval
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|lio_cn23xx_pf_coprocessor_clock
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
comment|/* 	 * Bits 29:24 of RST_BOOT[PNR_MUL] holds the ref.clock MULTIPLIER 	 * for SLI. 	 */
comment|/* TBD: get the info in Hand-shake */
return|return
operator|(
operator|(
operator|(
name|lio_pci_readq
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_RST_BOOT
argument_list|)
operator|>>
literal|24
operator|)
operator|&
literal|0x3f
operator|)
operator|*
literal|50
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|lio_cn23xx_pf_get_oq_ticks
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|uint32_t
name|time_intr_in_us
parameter_list|)
block|{
comment|/* This gives the SLI clock per microsec */
name|uint32_t
name|oqticks_per_us
init|=
name|lio_cn23xx_pf_coprocessor_clock
argument_list|(
name|oct
argument_list|)
decl_stmt|;
name|oct
operator|->
name|pfvf_hsword
operator|.
name|coproc_tics_per_us
operator|=
name|oqticks_per_us
expr_stmt|;
comment|/* This gives the clock cycles per millisecond */
name|oqticks_per_us
operator|*=
literal|1000
expr_stmt|;
comment|/* This gives the oq ticks (1024 core clock cycles) per millisecond */
name|oqticks_per_us
operator|/=
literal|1024
expr_stmt|;
comment|/* 	 * time_intr is in microseconds. The next 2 steps gives the oq ticks 	 * corresponding to time_intr. 	 */
name|oqticks_per_us
operator|*=
name|time_intr_in_us
expr_stmt|;
name|oqticks_per_us
operator|/=
literal|1000
expr_stmt|;
return|return
operator|(
name|oqticks_per_us
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lio_cn23xx_pf_setup_global_mac_regs
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
name|uint64_t
name|reg_val
decl_stmt|;
name|uint16_t
name|mac_no
init|=
name|oct
operator|->
name|pcie_port
decl_stmt|;
name|uint16_t
name|pf_num
init|=
name|oct
operator|->
name|pf_num
decl_stmt|;
comment|/* programming SRN and TRS for each MAC(0..3)  */
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"%s: Using pcie port %d\n"
argument_list|,
name|__func__
argument_list|,
name|mac_no
argument_list|)
expr_stmt|;
comment|/* By default, mapping all 64 IOQs to  a single MACs */
name|reg_val
operator|=
name|lio_read_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_PKT_MAC_RINFO64
argument_list|(
name|mac_no
argument_list|,
name|pf_num
argument_list|)
argument_list|)
expr_stmt|;
comment|/* setting SRN<6:0>  */
name|reg_val
operator|=
name|pf_num
operator|*
name|LIO_CN23XX_PF_MAX_RINGS
expr_stmt|;
comment|/* setting TRS<23:16> */
name|reg_val
operator|=
name|reg_val
operator||
operator|(
name|oct
operator|->
name|sriov_info
operator|.
name|trs
operator|<<
name|LIO_CN23XX_PKT_MAC_CTL_RINFO_TRS_BIT_POS
operator|)
expr_stmt|;
comment|/* write these settings to MAC register */
name|lio_write_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_PKT_MAC_RINFO64
argument_list|(
name|mac_no
argument_list|,
name|pf_num
argument_list|)
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"SLI_PKT_MAC(%d)_PF(%d)_RINFO : 0x%016llx\n"
argument_list|,
name|mac_no
argument_list|,
name|pf_num
argument_list|,
name|LIO_CAST64
argument_list|(
name|lio_read_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_PKT_MAC_RINFO64
argument_list|(
name|mac_no
argument_list|,
name|pf_num
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lio_cn23xx_pf_reset_io_queues
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
name|uint64_t
name|d64
decl_stmt|;
name|uint32_t
name|ern
decl_stmt|,
name|loop
init|=
name|BUSY_READING_REG_PF_LOOP_COUNT
decl_stmt|;
name|uint32_t
name|q_no
decl_stmt|,
name|srn
decl_stmt|;
name|int
name|ret_val
init|=
literal|0
decl_stmt|;
name|srn
operator|=
name|oct
operator|->
name|sriov_info
operator|.
name|pf_srn
expr_stmt|;
name|ern
operator|=
name|srn
operator|+
name|oct
operator|->
name|sriov_info
operator|.
name|num_pf_rings
expr_stmt|;
comment|/* As per HRM reg description, s/w cant write 0 to ENB. */
comment|/* to make the queue off, need to set the RST bit. */
comment|/* Reset the Enable bit for all the 64 IQs.  */
for|for
control|(
name|q_no
operator|=
name|srn
init|;
name|q_no
operator|<
name|ern
condition|;
name|q_no
operator|++
control|)
block|{
comment|/* set RST bit to 1. This bit applies to both IQ and OQ */
name|d64
operator|=
name|lio_read_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_IQ_PKT_CONTROL64
argument_list|(
name|q_no
argument_list|)
argument_list|)
expr_stmt|;
name|d64
operator|=
name|d64
operator||
name|LIO_CN23XX_PKT_INPUT_CTL_RST
expr_stmt|;
name|lio_write_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_IQ_PKT_CONTROL64
argument_list|(
name|q_no
argument_list|)
argument_list|,
name|d64
argument_list|)
expr_stmt|;
block|}
comment|/* wait until the RST bit is clear or the RST and quiet bits are set */
for|for
control|(
name|q_no
operator|=
name|srn
init|;
name|q_no
operator|<
name|ern
condition|;
name|q_no
operator|++
control|)
block|{
specifier|volatile
name|uint64_t
name|reg_val
init|=
name|lio_read_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_IQ_PKT_CONTROL64
argument_list|(
name|q_no
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|reg_val
operator|&
name|LIO_CN23XX_PKT_INPUT_CTL_RST
operator|)
operator|&&
operator|!
operator|(
name|reg_val
operator|&
name|LIO_CN23XX_PKT_INPUT_CTL_QUIET
operator|)
operator|&&
name|loop
condition|)
block|{
name|reg_val
operator|=
name|lio_read_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_IQ_PKT_CONTROL64
argument_list|(
name|q_no
argument_list|)
argument_list|)
expr_stmt|;
name|loop
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|loop
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"clearing the reset reg failed or setting the quiet reg failed for qno: %u\n"
argument_list|,
name|q_no
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|reg_val
operator|&=
operator|~
name|LIO_CN23XX_PKT_INPUT_CTL_RST
expr_stmt|;
name|lio_write_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_IQ_PKT_CONTROL64
argument_list|(
name|q_no
argument_list|)
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
name|reg_val
operator|=
name|lio_read_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_IQ_PKT_CONTROL64
argument_list|(
name|q_no
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_val
operator|&
name|LIO_CN23XX_PKT_INPUT_CTL_RST
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"clearing the reset failed for qno: %u\n"
argument_list|,
name|q_no
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ret_val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lio_cn23xx_pf_setup_global_input_regs
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
name|struct
name|lio_cn23xx_pf
modifier|*
name|cn23xx
init|=
operator|(
expr|struct
name|lio_cn23xx_pf
operator|*
operator|)
name|oct
operator|->
name|chip
decl_stmt|;
name|struct
name|lio_instr_queue
modifier|*
name|iq
decl_stmt|;
name|uint64_t
name|intr_threshold
decl_stmt|;
name|uint64_t
name|pf_num
decl_stmt|,
name|reg_val
decl_stmt|;
name|uint32_t
name|q_no
decl_stmt|,
name|ern
decl_stmt|,
name|srn
decl_stmt|;
name|pf_num
operator|=
name|oct
operator|->
name|pf_num
expr_stmt|;
name|srn
operator|=
name|oct
operator|->
name|sriov_info
operator|.
name|pf_srn
expr_stmt|;
name|ern
operator|=
name|srn
operator|+
name|oct
operator|->
name|sriov_info
operator|.
name|num_pf_rings
expr_stmt|;
if|if
condition|(
name|lio_cn23xx_pf_reset_io_queues
argument_list|(
name|oct
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Set the MAC_NUM and PVF_NUM in IQ_PKT_CONTROL reg 	 * for all queues.Only PF can set these bits. 	 * bits 29:30 indicate the MAC num. 	 * bits 32:47 indicate the PVF num. 	 */
for|for
control|(
name|q_no
operator|=
literal|0
init|;
name|q_no
operator|<
name|ern
condition|;
name|q_no
operator|++
control|)
block|{
name|reg_val
operator|=
name|oct
operator|->
name|pcie_port
operator|<<
name|LIO_CN23XX_PKT_INPUT_CTL_MAC_NUM_POS
expr_stmt|;
name|reg_val
operator||=
name|pf_num
operator|<<
name|LIO_CN23XX_PKT_INPUT_CTL_PF_NUM_POS
expr_stmt|;
name|lio_write_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_IQ_PKT_CONTROL64
argument_list|(
name|q_no
argument_list|)
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Select ES, RO, NS, RDSIZE,DPTR Fomat#0 for 	 * pf queues 	 */
for|for
control|(
name|q_no
operator|=
name|srn
init|;
name|q_no
operator|<
name|ern
condition|;
name|q_no
operator|++
control|)
block|{
name|uint32_t
name|inst_cnt_reg
decl_stmt|;
name|iq
operator|=
name|oct
operator|->
name|instr_queue
index|[
name|q_no
index|]
expr_stmt|;
if|if
condition|(
name|iq
operator|!=
name|NULL
condition|)
name|inst_cnt_reg
operator|=
name|iq
operator|->
name|inst_cnt_reg
expr_stmt|;
else|else
name|inst_cnt_reg
operator|=
name|LIO_CN23XX_SLI_IQ_INSTR_COUNT64
argument_list|(
name|q_no
argument_list|)
expr_stmt|;
name|reg_val
operator|=
name|lio_read_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_IQ_PKT_CONTROL64
argument_list|(
name|q_no
argument_list|)
argument_list|)
expr_stmt|;
name|reg_val
operator||=
name|LIO_CN23XX_PKT_INPUT_CTL_MASK
expr_stmt|;
name|lio_write_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_IQ_PKT_CONTROL64
argument_list|(
name|q_no
argument_list|)
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
comment|/* Set WMARK level for triggering PI_INT */
comment|/* intr_threshold = LIO_CN23XX_DEF_IQ_INTR_THRESHOLD& */
name|intr_threshold
operator|=
name|LIO_GET_IQ_INTR_PKT_CFG
argument_list|(
name|cn23xx
operator|->
name|conf
argument_list|)
operator|&
name|LIO_CN23XX_PKT_IN_DONE_WMARK_MASK
expr_stmt|;
name|lio_write_csr64
argument_list|(
name|oct
argument_list|,
name|inst_cnt_reg
argument_list|,
operator|(
name|lio_read_csr64
argument_list|(
name|oct
argument_list|,
name|inst_cnt_reg
argument_list|)
operator|&
operator|~
operator|(
name|LIO_CN23XX_PKT_IN_DONE_WMARK_MASK
operator|<<
name|LIO_CN23XX_PKT_IN_DONE_WMARK_BIT_POS
operator|)
operator|)
operator||
operator|(
name|intr_threshold
operator|<<
name|LIO_CN23XX_PKT_IN_DONE_WMARK_BIT_POS
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lio_cn23xx_pf_setup_global_output_regs
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
name|struct
name|lio_cn23xx_pf
modifier|*
name|cn23xx
init|=
operator|(
expr|struct
name|lio_cn23xx_pf
operator|*
operator|)
name|oct
operator|->
name|chip
decl_stmt|;
name|uint64_t
name|time_threshold
decl_stmt|;
name|uint32_t
name|ern
decl_stmt|,
name|q_no
decl_stmt|,
name|reg_val
decl_stmt|,
name|srn
decl_stmt|;
name|srn
operator|=
name|oct
operator|->
name|sriov_info
operator|.
name|pf_srn
expr_stmt|;
name|ern
operator|=
name|srn
operator|+
name|oct
operator|->
name|sriov_info
operator|.
name|num_pf_rings
expr_stmt|;
if|if
condition|(
name|LIO_GET_IS_SLI_BP_ON_CFG
argument_list|(
name|cn23xx
operator|->
name|conf
argument_list|)
condition|)
block|{
name|lio_write_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_OQ_WMARK
argument_list|,
literal|32
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Set Output queue watermark to 0 to disable backpressure */
name|lio_write_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_OQ_WMARK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|q_no
operator|=
name|srn
init|;
name|q_no
operator|<
name|ern
condition|;
name|q_no
operator|++
control|)
block|{
name|reg_val
operator|=
name|lio_read_csr32
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_OQ_PKT_CONTROL
argument_list|(
name|q_no
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set IPTR& DPTR */
name|reg_val
operator||=
name|LIO_CN23XX_PKT_OUTPUT_CTL_DPTR
expr_stmt|;
comment|/* reset BMODE */
name|reg_val
operator|&=
operator|~
operator|(
name|LIO_CN23XX_PKT_OUTPUT_CTL_BMODE
operator|)
expr_stmt|;
comment|/* 		 * No Relaxed Ordering, No Snoop, 64-bit Byte swap for 		 * Output Queue ScatterList reset ROR_P, NSR_P 		 */
name|reg_val
operator|&=
operator|~
operator|(
name|LIO_CN23XX_PKT_OUTPUT_CTL_ROR_P
operator|)
expr_stmt|;
name|reg_val
operator|&=
operator|~
operator|(
name|LIO_CN23XX_PKT_OUTPUT_CTL_NSR_P
operator|)
expr_stmt|;
if|#
directive|if
name|BYTE_ORDER
operator|==
name|LITTLE_ENDIAN
name|reg_val
operator|&=
operator|~
operator|(
name|LIO_CN23XX_PKT_OUTPUT_CTL_ES_P
operator|)
expr_stmt|;
else|#
directive|else
comment|/* BYTE_ORDER != LITTLE_ENDIAN  */
name|reg_val
operator||=
operator|(
name|LIO_CN23XX_PKT_OUTPUT_CTL_ES_P
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* BYTE_ORDER == LITTLE_ENDIAN */
comment|/* 		 * No Relaxed Ordering, No Snoop, 64-bit Byte swap for 		 * Output Queue Data reset ROR, NSR 		 */
name|reg_val
operator|&=
operator|~
operator|(
name|LIO_CN23XX_PKT_OUTPUT_CTL_ROR
operator|)
expr_stmt|;
name|reg_val
operator|&=
operator|~
operator|(
name|LIO_CN23XX_PKT_OUTPUT_CTL_NSR
operator|)
expr_stmt|;
comment|/* set the ES bit */
name|reg_val
operator||=
operator|(
name|LIO_CN23XX_PKT_OUTPUT_CTL_ES
operator|)
expr_stmt|;
comment|/* write all the selected settings */
name|lio_write_csr32
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_OQ_PKT_CONTROL
argument_list|(
name|q_no
argument_list|)
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
comment|/* 		 * Enabling these interrupt in oct->fn_list.enable_interrupt() 		 * routine which called after IOQ init. 		 * Set up interrupt packet and time thresholds 		 * for all the OQs 		 */
name|time_threshold
operator|=
name|lio_cn23xx_pf_get_oq_ticks
argument_list|(
name|oct
argument_list|,
operator|(
name|uint32_t
operator|)
name|LIO_GET_OQ_INTR_TIME_CFG
argument_list|(
name|cn23xx
operator|->
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|lio_write_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_OQ_PKT_INT_LEVELS
argument_list|(
name|q_no
argument_list|)
argument_list|,
operator|(
name|LIO_GET_OQ_INTR_PKT_CFG
argument_list|(
name|cn23xx
operator|->
name|conf
argument_list|)
operator||
operator|(
name|time_threshold
operator|<<
literal|32
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Setting the water mark level for pko back pressure * */
name|lio_write_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_OQ_WMARK
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
comment|/* Enable channel-level backpressure */
if|if
condition|(
name|oct
operator|->
name|pf_num
condition|)
name|lio_write_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_OUT_BP_EN2_W1S
argument_list|,
literal|0xffffffffffffffffULL
argument_list|)
expr_stmt|;
else|else
name|lio_write_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_OUT_BP_EN_W1S
argument_list|,
literal|0xffffffffffffffffULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lio_cn23xx_pf_setup_device_regs
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
name|lio_cn23xx_pf_enable_error_reporting
argument_list|(
name|oct
argument_list|)
expr_stmt|;
comment|/* program the MAC(0..3)_RINFO before setting up input/output regs */
name|lio_cn23xx_pf_setup_global_mac_regs
argument_list|(
name|oct
argument_list|)
expr_stmt|;
if|if
condition|(
name|lio_cn23xx_pf_setup_global_input_regs
argument_list|(
name|oct
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|lio_cn23xx_pf_setup_global_output_regs
argument_list|(
name|oct
argument_list|)
expr_stmt|;
comment|/* 	 * Default error timeout value should be 0x200000 to avoid host hang 	 * when reads invalid register 	 */
name|lio_write_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_WINDOW_CTL
argument_list|,
name|LIO_CN23XX_SLI_WINDOW_CTL_DEFAULT
argument_list|)
expr_stmt|;
comment|/* set SLI_PKT_IN_JABBER to handle large VXLAN packets */
name|lio_write_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_PKT_IN_JABBER
argument_list|,
name|LIO_CN23XX_MAX_INPUT_JABBER
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lio_cn23xx_pf_setup_iq_regs
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|uint32_t
name|iq_no
parameter_list|)
block|{
name|struct
name|lio_instr_queue
modifier|*
name|iq
init|=
name|oct
operator|->
name|instr_queue
index|[
name|iq_no
index|]
decl_stmt|;
name|uint64_t
name|pkt_in_done
decl_stmt|;
name|iq_no
operator|+=
name|oct
operator|->
name|sriov_info
operator|.
name|pf_srn
expr_stmt|;
comment|/* Write the start of the input queue's ring and its size  */
name|lio_write_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_IQ_BASE_ADDR64
argument_list|(
name|iq_no
argument_list|)
argument_list|,
name|iq
operator|->
name|base_addr_dma
argument_list|)
expr_stmt|;
name|lio_write_csr32
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_IQ_SIZE
argument_list|(
name|iq_no
argument_list|)
argument_list|,
name|iq
operator|->
name|max_count
argument_list|)
expr_stmt|;
comment|/* 	 * Remember the doorbell& instruction count register addr 	 * for this queue 	 */
name|iq
operator|->
name|doorbell_reg
operator|=
name|LIO_CN23XX_SLI_IQ_DOORBELL
argument_list|(
name|iq_no
argument_list|)
expr_stmt|;
name|iq
operator|->
name|inst_cnt_reg
operator|=
name|LIO_CN23XX_SLI_IQ_INSTR_COUNT64
argument_list|(
name|iq_no
argument_list|)
expr_stmt|;
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"InstQ[%d]:dbell reg @ 0x%x instcnt_reg @ 0x%x\n"
argument_list|,
name|iq_no
argument_list|,
name|iq
operator|->
name|doorbell_reg
argument_list|,
name|iq
operator|->
name|inst_cnt_reg
argument_list|)
expr_stmt|;
comment|/* 	 * Store the current instruction counter (used in flush_iq 	 * calculation) 	 */
name|pkt_in_done
operator|=
name|lio_read_csr64
argument_list|(
name|oct
argument_list|,
name|iq
operator|->
name|inst_cnt_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|oct
operator|->
name|msix_on
condition|)
block|{
comment|/* Set CINT_ENB to enable IQ interrupt   */
name|lio_write_csr64
argument_list|(
name|oct
argument_list|,
name|iq
operator|->
name|inst_cnt_reg
argument_list|,
operator|(
name|pkt_in_done
operator||
name|LIO_CN23XX_INTR_CINT_ENB
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Clear the count by writing back what we read, but don't 		 * enable interrupts 		 */
name|lio_write_csr64
argument_list|(
name|oct
argument_list|,
name|iq
operator|->
name|inst_cnt_reg
argument_list|,
name|pkt_in_done
argument_list|)
expr_stmt|;
block|}
name|iq
operator|->
name|reset_instr_cnt
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lio_cn23xx_pf_setup_oq_regs
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|uint32_t
name|oq_no
parameter_list|)
block|{
name|struct
name|lio_droq
modifier|*
name|droq
init|=
name|oct
operator|->
name|droq
index|[
name|oq_no
index|]
decl_stmt|;
name|struct
name|lio_cn23xx_pf
modifier|*
name|cn23xx
init|=
operator|(
expr|struct
name|lio_cn23xx_pf
operator|*
operator|)
name|oct
operator|->
name|chip
decl_stmt|;
name|uint64_t
name|cnt_threshold
decl_stmt|;
name|uint64_t
name|time_threshold
decl_stmt|;
name|uint32_t
name|reg_val
decl_stmt|;
name|oq_no
operator|+=
name|oct
operator|->
name|sriov_info
operator|.
name|pf_srn
expr_stmt|;
name|lio_write_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_OQ_BASE_ADDR64
argument_list|(
name|oq_no
argument_list|)
argument_list|,
name|droq
operator|->
name|desc_ring_dma
argument_list|)
expr_stmt|;
name|lio_write_csr32
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_OQ_SIZE
argument_list|(
name|oq_no
argument_list|)
argument_list|,
name|droq
operator|->
name|max_count
argument_list|)
expr_stmt|;
name|lio_write_csr32
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_OQ_BUFF_INFO_SIZE
argument_list|(
name|oq_no
argument_list|)
argument_list|,
name|droq
operator|->
name|buffer_size
argument_list|)
expr_stmt|;
comment|/* pkt_sent and pkts_credit regs */
name|droq
operator|->
name|pkts_sent_reg
operator|=
name|LIO_CN23XX_SLI_OQ_PKTS_SENT
argument_list|(
name|oq_no
argument_list|)
expr_stmt|;
name|droq
operator|->
name|pkts_credit_reg
operator|=
name|LIO_CN23XX_SLI_OQ_PKTS_CREDIT
argument_list|(
name|oq_no
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|oct
operator|->
name|msix_on
condition|)
block|{
comment|/* 		 * Enable this output queue to generate Packet Timer 		 * Interrupt 		 */
name|reg_val
operator|=
name|lio_read_csr32
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_OQ_PKT_CONTROL
argument_list|(
name|oq_no
argument_list|)
argument_list|)
expr_stmt|;
name|reg_val
operator||=
name|LIO_CN23XX_PKT_OUTPUT_CTL_TENB
expr_stmt|;
name|lio_write_csr32
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_OQ_PKT_CONTROL
argument_list|(
name|oq_no
argument_list|)
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
comment|/* 		 * Enable this output queue to generate Packet Count 		 * Interrupt 		 */
name|reg_val
operator|=
name|lio_read_csr32
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_OQ_PKT_CONTROL
argument_list|(
name|oq_no
argument_list|)
argument_list|)
expr_stmt|;
name|reg_val
operator||=
name|LIO_CN23XX_PKT_OUTPUT_CTL_CENB
expr_stmt|;
name|lio_write_csr32
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_OQ_PKT_CONTROL
argument_list|(
name|oq_no
argument_list|)
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|time_threshold
operator|=
name|lio_cn23xx_pf_get_oq_ticks
argument_list|(
name|oct
argument_list|,
operator|(
name|uint32_t
operator|)
name|LIO_GET_OQ_INTR_TIME_CFG
argument_list|(
name|cn23xx
operator|->
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|cnt_threshold
operator|=
operator|(
name|uint32_t
operator|)
name|LIO_GET_OQ_INTR_PKT_CFG
argument_list|(
name|cn23xx
operator|->
name|conf
argument_list|)
expr_stmt|;
name|lio_write_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_OQ_PKT_INT_LEVELS
argument_list|(
name|oq_no
argument_list|)
argument_list|,
operator|(
operator|(
name|time_threshold
operator|<<
literal|32
operator||
name|cnt_threshold
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|lio_cn23xx_pf_enable_io_queues
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
name|uint64_t
name|reg_val
decl_stmt|;
name|uint32_t
name|ern
decl_stmt|,
name|loop
init|=
name|BUSY_READING_REG_PF_LOOP_COUNT
decl_stmt|;
name|uint32_t
name|q_no
decl_stmt|,
name|srn
decl_stmt|;
name|srn
operator|=
name|oct
operator|->
name|sriov_info
operator|.
name|pf_srn
expr_stmt|;
name|ern
operator|=
name|srn
operator|+
name|oct
operator|->
name|num_iqs
expr_stmt|;
for|for
control|(
name|q_no
operator|=
name|srn
init|;
name|q_no
operator|<
name|ern
condition|;
name|q_no
operator|++
control|)
block|{
comment|/* set the corresponding IQ IS_64B bit */
if|if
condition|(
name|oct
operator|->
name|io_qmask
operator|.
name|iq64B
operator|&
name|BIT_ULL
argument_list|(
name|q_no
operator|-
name|srn
argument_list|)
condition|)
block|{
name|reg_val
operator|=
name|lio_read_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_IQ_PKT_CONTROL64
argument_list|(
name|q_no
argument_list|)
argument_list|)
expr_stmt|;
name|reg_val
operator|=
name|reg_val
operator||
name|LIO_CN23XX_PKT_INPUT_CTL_IS_64B
expr_stmt|;
name|lio_write_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_IQ_PKT_CONTROL64
argument_list|(
name|q_no
argument_list|)
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
block|}
comment|/* set the corresponding IQ ENB bit */
if|if
condition|(
name|oct
operator|->
name|io_qmask
operator|.
name|iq
operator|&
name|BIT_ULL
argument_list|(
name|q_no
operator|-
name|srn
argument_list|)
condition|)
block|{
comment|/* 			 * IOQs are in reset by default in PEM2 mode, 			 * clearing reset bit 			 */
name|reg_val
operator|=
name|lio_read_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_IQ_PKT_CONTROL64
argument_list|(
name|q_no
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_val
operator|&
name|LIO_CN23XX_PKT_INPUT_CTL_RST
condition|)
block|{
while|while
condition|(
operator|(
name|reg_val
operator|&
name|LIO_CN23XX_PKT_INPUT_CTL_RST
operator|)
operator|&&
operator|!
operator|(
name|reg_val
operator|&
name|LIO_CN23XX_PKT_INPUT_CTL_QUIET
operator|)
operator|&&
name|loop
condition|)
block|{
name|reg_val
operator|=
name|lio_read_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_IQ_PKT_CONTROL64
argument_list|(
name|q_no
argument_list|)
argument_list|)
expr_stmt|;
name|loop
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|loop
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"clearing the reset reg failed or setting the quiet reg failed for qno: %u\n"
argument_list|,
name|q_no
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|reg_val
operator|=
name|reg_val
operator|&
operator|~
name|LIO_CN23XX_PKT_INPUT_CTL_RST
expr_stmt|;
name|lio_write_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_IQ_PKT_CONTROL64
argument_list|(
name|q_no
argument_list|)
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
name|reg_val
operator|=
name|lio_read_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_IQ_PKT_CONTROL64
argument_list|(
name|q_no
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_val
operator|&
name|LIO_CN23XX_PKT_INPUT_CTL_RST
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"clearing the reset failed for qno: %u\n"
argument_list|,
name|q_no
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|reg_val
operator|=
name|lio_read_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_IQ_PKT_CONTROL64
argument_list|(
name|q_no
argument_list|)
argument_list|)
expr_stmt|;
name|reg_val
operator|=
name|reg_val
operator||
name|LIO_CN23XX_PKT_INPUT_CTL_RING_ENB
expr_stmt|;
name|lio_write_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_IQ_PKT_CONTROL64
argument_list|(
name|q_no
argument_list|)
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|q_no
operator|=
name|srn
init|;
name|q_no
operator|<
name|ern
condition|;
name|q_no
operator|++
control|)
block|{
name|uint32_t
name|reg_val
decl_stmt|;
comment|/* set the corresponding OQ ENB bit */
if|if
condition|(
name|oct
operator|->
name|io_qmask
operator|.
name|oq
operator|&
name|BIT_ULL
argument_list|(
name|q_no
operator|-
name|srn
argument_list|)
condition|)
block|{
name|reg_val
operator|=
name|lio_read_csr32
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_OQ_PKT_CONTROL
argument_list|(
name|q_no
argument_list|)
argument_list|)
expr_stmt|;
name|reg_val
operator|=
name|reg_val
operator||
name|LIO_CN23XX_PKT_OUTPUT_CTL_RING_ENB
expr_stmt|;
name|lio_write_csr32
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_OQ_PKT_CONTROL
argument_list|(
name|q_no
argument_list|)
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lio_cn23xx_pf_disable_io_queues
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
specifier|volatile
name|uint64_t
name|d64
decl_stmt|;
specifier|volatile
name|uint32_t
name|d32
decl_stmt|;
name|int
name|loop
decl_stmt|;
name|unsigned
name|int
name|q_no
decl_stmt|;
name|uint32_t
name|ern
decl_stmt|,
name|srn
decl_stmt|;
name|srn
operator|=
name|oct
operator|->
name|sriov_info
operator|.
name|pf_srn
expr_stmt|;
name|ern
operator|=
name|srn
operator|+
name|oct
operator|->
name|num_iqs
expr_stmt|;
comment|/* Disable Input Queues. */
for|for
control|(
name|q_no
operator|=
name|srn
init|;
name|q_no
operator|<
name|ern
condition|;
name|q_no
operator|++
control|)
block|{
name|loop
operator|=
name|lio_ms_to_ticks
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* start the Reset for a particular ring */
name|d64
operator|=
name|lio_read_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_IQ_PKT_CONTROL64
argument_list|(
name|q_no
argument_list|)
argument_list|)
expr_stmt|;
name|d64
operator|&=
operator|~
name|LIO_CN23XX_PKT_INPUT_CTL_RING_ENB
expr_stmt|;
name|d64
operator||=
name|LIO_CN23XX_PKT_INPUT_CTL_RST
expr_stmt|;
name|lio_write_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_IQ_PKT_CONTROL64
argument_list|(
name|q_no
argument_list|)
argument_list|,
name|d64
argument_list|)
expr_stmt|;
comment|/* 		 * Wait until hardware indicates that the particular IQ 		 * is out of reset. 		 */
name|d64
operator|=
name|lio_read_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_PKT_IOQ_RING_RST
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|d64
operator|&
name|BIT_ULL
argument_list|(
name|q_no
argument_list|)
operator|)
operator|&&
name|loop
operator|--
condition|)
block|{
name|d64
operator|=
name|lio_read_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_PKT_IOQ_RING_RST
argument_list|)
expr_stmt|;
name|lio_sleep_timeout
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|loop
operator|--
expr_stmt|;
block|}
comment|/* Reset the doorbell register for this Input Queue. */
name|lio_write_csr32
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_IQ_DOORBELL
argument_list|(
name|q_no
argument_list|)
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|lio_read_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_IQ_DOORBELL
argument_list|(
name|q_no
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0ULL
operator|)
operator|&&
name|loop
operator|--
condition|)
block|{
name|lio_sleep_timeout
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Disable Output Queues. */
for|for
control|(
name|q_no
operator|=
name|srn
init|;
name|q_no
operator|<
name|ern
condition|;
name|q_no
operator|++
control|)
block|{
name|loop
operator|=
name|lio_ms_to_ticks
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* 		 * Wait until hardware indicates that the particular IQ 		 * is out of reset.It given that SLI_PKT_RING_RST is 		 * common for both IQs and OQs 		 */
name|d64
operator|=
name|lio_read_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_PKT_IOQ_RING_RST
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|d64
operator|&
name|BIT_ULL
argument_list|(
name|q_no
argument_list|)
operator|)
operator|&&
name|loop
operator|--
condition|)
block|{
name|d64
operator|=
name|lio_read_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_PKT_IOQ_RING_RST
argument_list|)
expr_stmt|;
name|lio_sleep_timeout
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|loop
operator|--
expr_stmt|;
block|}
comment|/* Reset the doorbell register for this Output Queue. */
name|lio_write_csr32
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_OQ_PKTS_CREDIT
argument_list|(
name|q_no
argument_list|)
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|lio_read_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_OQ_PKTS_CREDIT
argument_list|(
name|q_no
argument_list|)
argument_list|)
operator|!=
literal|0ULL
operator|)
operator|&&
name|loop
operator|--
condition|)
block|{
name|lio_sleep_timeout
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* clear the SLI_PKT(0..63)_CNTS[CNT] reg value */
name|d32
operator|=
name|lio_read_csr32
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_OQ_PKTS_SENT
argument_list|(
name|q_no
argument_list|)
argument_list|)
expr_stmt|;
name|lio_write_csr32
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_OQ_PKTS_SENT
argument_list|(
name|q_no
argument_list|)
argument_list|,
name|d32
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|lio_cn23xx_pf_msix_interrupt_handler
parameter_list|(
name|void
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|lio_ioq_vector
modifier|*
name|ioq_vector
init|=
operator|(
expr|struct
name|lio_ioq_vector
operator|*
operator|)
name|dev
decl_stmt|;
name|struct
name|octeon_device
modifier|*
name|oct
init|=
name|ioq_vector
operator|->
name|oct_dev
decl_stmt|;
name|struct
name|lio_droq
modifier|*
name|droq
init|=
name|oct
operator|->
name|droq
index|[
name|ioq_vector
operator|->
name|droq_index
index|]
decl_stmt|;
name|uint64_t
name|pkts_sent
decl_stmt|;
name|uint64_t
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|droq
operator|==
name|NULL
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"23XX bringup FIXME: oct pfnum:%d ioq_vector->ioq_num :%d droq is NULL\n"
argument_list|,
name|oct
operator|->
name|pf_num
argument_list|,
name|ioq_vector
operator|->
name|ioq_num
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pkts_sent
operator|=
name|lio_read_csr64
argument_list|(
name|oct
argument_list|,
name|droq
operator|->
name|pkts_sent_reg
argument_list|)
expr_stmt|;
comment|/* 	 * If our device has interrupted, then proceed. Also check 	 * for all f's if interrupt was triggered on an error 	 * and the PCI read fails. 	 */
if|if
condition|(
operator|!
name|pkts_sent
operator|||
operator|(
name|pkts_sent
operator|==
literal|0xFFFFFFFFFFFFFFFFULL
operator|)
condition|)
return|return
operator|(
name|ret
operator|)
return|;
comment|/* Write count reg in sli_pkt_cnts to clear these int. */
if|if
condition|(
name|pkts_sent
operator|&
name|LIO_CN23XX_INTR_PO_INT
condition|)
name|ret
operator||=
name|LIO_MSIX_PO_INT
expr_stmt|;
if|if
condition|(
name|pkts_sent
operator|&
name|LIO_CN23XX_INTR_PI_INT
condition|)
comment|/* We will clear the count when we update the read_index. */
name|ret
operator||=
name|LIO_MSIX_PI_INT
expr_stmt|;
comment|/* 	 * Never need to handle msix mbox intr for pf. They arrive on the last 	 * msix 	 */
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lio_cn23xx_pf_interrupt_handler
parameter_list|(
name|void
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|octeon_device
modifier|*
name|oct
init|=
operator|(
expr|struct
name|octeon_device
operator|*
operator|)
name|dev
decl_stmt|;
name|struct
name|lio_cn23xx_pf
modifier|*
name|cn23xx
init|=
operator|(
expr|struct
name|lio_cn23xx_pf
operator|*
operator|)
name|oct
operator|->
name|chip
decl_stmt|;
name|uint64_t
name|intr64
decl_stmt|;
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"In %s octeon_dev @ %p\n"
argument_list|,
name|__func__
argument_list|,
name|oct
argument_list|)
expr_stmt|;
name|intr64
operator|=
name|lio_read_csr64
argument_list|(
name|oct
argument_list|,
name|cn23xx
operator|->
name|intr_sum_reg64
argument_list|)
expr_stmt|;
name|oct
operator|->
name|int_status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|intr64
operator|&
name|LIO_CN23XX_INTR_ERR
condition|)
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Error Intr: 0x%016llx\n"
argument_list|,
name|LIO_CAST64
argument_list|(
name|intr64
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|oct
operator|->
name|msix_on
operator|!=
name|LIO_FLAG_MSIX_ENABLED
condition|)
block|{
if|if
condition|(
name|intr64
operator|&
name|LIO_CN23XX_INTR_PKT_DATA
condition|)
name|oct
operator|->
name|int_status
operator||=
name|LIO_DEV_INTR_PKT_DATA
expr_stmt|;
block|}
if|if
condition|(
name|intr64
operator|&
operator|(
name|LIO_CN23XX_INTR_DMA0_FORCE
operator|)
condition|)
name|oct
operator|->
name|int_status
operator||=
name|LIO_DEV_INTR_DMA0_FORCE
expr_stmt|;
if|if
condition|(
name|intr64
operator|&
operator|(
name|LIO_CN23XX_INTR_DMA1_FORCE
operator|)
condition|)
name|oct
operator|->
name|int_status
operator||=
name|LIO_DEV_INTR_DMA1_FORCE
expr_stmt|;
comment|/* Clear the current interrupts */
name|lio_write_csr64
argument_list|(
name|oct
argument_list|,
name|cn23xx
operator|->
name|intr_sum_reg64
argument_list|,
name|intr64
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lio_cn23xx_pf_bar1_idx_setup
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|uint64_t
name|core_addr
parameter_list|,
name|uint32_t
name|idx
parameter_list|,
name|int
name|valid
parameter_list|)
block|{
specifier|volatile
name|uint64_t
name|bar1
decl_stmt|;
name|uint64_t
name|reg_adr
decl_stmt|;
if|if
condition|(
operator|!
name|valid
condition|)
block|{
name|reg_adr
operator|=
name|lio_pci_readq
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_PEM_BAR1_INDEX_REG
argument_list|(
name|oct
operator|->
name|pcie_port
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|bar1
operator|=
name|reg_adr
expr_stmt|;
name|lio_pci_writeq
argument_list|(
name|oct
argument_list|,
operator|(
name|bar1
operator|&
literal|0xFFFFFFFEULL
operator|)
argument_list|,
name|LIO_CN23XX_PEM_BAR1_INDEX_REG
argument_list|(
name|oct
operator|->
name|pcie_port
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|reg_adr
operator|=
name|lio_pci_readq
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_PEM_BAR1_INDEX_REG
argument_list|(
name|oct
operator|->
name|pcie_port
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|bar1
operator|=
name|reg_adr
expr_stmt|;
return|return;
block|}
comment|/* 	 *  The PEM(0..3)_BAR1_INDEX(0..15)[ADDR_IDX]<23:4> stores 	 *  bits<41:22> of the Core Addr 	 */
name|lio_pci_writeq
argument_list|(
name|oct
argument_list|,
operator|(
operator|(
operator|(
name|core_addr
operator|>>
literal|22
operator|)
operator|<<
literal|4
operator|)
operator||
name|LIO_PCI_BAR1_MASK
operator|)
argument_list|,
name|LIO_CN23XX_PEM_BAR1_INDEX_REG
argument_list|(
name|oct
operator|->
name|pcie_port
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|bar1
operator|=
name|lio_pci_readq
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_PEM_BAR1_INDEX_REG
argument_list|(
name|oct
operator|->
name|pcie_port
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lio_cn23xx_pf_bar1_idx_write
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|uint32_t
name|idx
parameter_list|,
name|uint32_t
name|mask
parameter_list|)
block|{
name|lio_pci_writeq
argument_list|(
name|oct
argument_list|,
name|mask
argument_list|,
name|LIO_CN23XX_PEM_BAR1_INDEX_REG
argument_list|(
name|oct
operator|->
name|pcie_port
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|lio_cn23xx_pf_bar1_idx_read
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|uint32_t
name|idx
parameter_list|)
block|{
return|return
operator|(
operator|(
name|uint32_t
operator|)
name|lio_pci_readq
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_PEM_BAR1_INDEX_REG
argument_list|(
name|oct
operator|->
name|pcie_port
argument_list|,
name|idx
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* always call with lock held */
end_comment

begin_function
specifier|static
name|uint32_t
name|lio_cn23xx_pf_update_read_index
parameter_list|(
name|struct
name|lio_instr_queue
modifier|*
name|iq
parameter_list|)
block|{
name|struct
name|octeon_device
modifier|*
name|oct
init|=
name|iq
operator|->
name|oct_dev
decl_stmt|;
name|uint32_t
name|new_idx
decl_stmt|;
name|uint32_t
name|last_done
decl_stmt|;
name|uint32_t
name|pkt_in_done
init|=
name|lio_read_csr32
argument_list|(
name|oct
argument_list|,
name|iq
operator|->
name|inst_cnt_reg
argument_list|)
decl_stmt|;
name|last_done
operator|=
name|pkt_in_done
operator|-
name|iq
operator|->
name|pkt_in_done
expr_stmt|;
name|iq
operator|->
name|pkt_in_done
operator|=
name|pkt_in_done
expr_stmt|;
comment|/* 	 * Modulo of the new index with the IQ size will give us 	 * the new index.  The iq->reset_instr_cnt is always zero for 	 * cn23xx, so no extra adjustments are needed. 	 */
name|new_idx
operator|=
operator|(
name|iq
operator|->
name|octeon_read_index
operator|+
operator|(
call|(
name|uint32_t
call|)
argument_list|(
name|last_done
operator|&
name|LIO_CN23XX_PKT_IN_DONE_CNT_MASK
argument_list|)
operator|)
operator|)
operator|%
name|iq
operator|->
name|max_count
expr_stmt|;
return|return
operator|(
name|new_idx
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lio_cn23xx_pf_enable_interrupt
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|uint8_t
name|intr_flag
parameter_list|)
block|{
name|struct
name|lio_cn23xx_pf
modifier|*
name|cn23xx
init|=
operator|(
expr|struct
name|lio_cn23xx_pf
operator|*
operator|)
name|oct
operator|->
name|chip
decl_stmt|;
name|uint64_t
name|intr_val
init|=
literal|0
decl_stmt|;
comment|/* Divide the single write to multiple writes based on the flag. */
comment|/* Enable Interrupt */
if|if
condition|(
name|intr_flag
operator|==
name|OCTEON_ALL_INTR
condition|)
block|{
name|lio_write_csr64
argument_list|(
name|oct
argument_list|,
name|cn23xx
operator|->
name|intr_enb_reg64
argument_list|,
name|cn23xx
operator|->
name|intr_mask64
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|intr_flag
operator|&
name|OCTEON_OUTPUT_INTR
condition|)
block|{
name|intr_val
operator|=
name|lio_read_csr64
argument_list|(
name|oct
argument_list|,
name|cn23xx
operator|->
name|intr_enb_reg64
argument_list|)
expr_stmt|;
name|intr_val
operator||=
name|LIO_CN23XX_INTR_PKT_DATA
expr_stmt|;
name|lio_write_csr64
argument_list|(
name|oct
argument_list|,
name|cn23xx
operator|->
name|intr_enb_reg64
argument_list|,
name|intr_val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|lio_cn23xx_pf_disable_interrupt
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|uint8_t
name|intr_flag
parameter_list|)
block|{
name|struct
name|lio_cn23xx_pf
modifier|*
name|cn23xx
init|=
operator|(
expr|struct
name|lio_cn23xx_pf
operator|*
operator|)
name|oct
operator|->
name|chip
decl_stmt|;
name|uint64_t
name|intr_val
init|=
literal|0
decl_stmt|;
comment|/* Disable Interrupts */
if|if
condition|(
name|intr_flag
operator|==
name|OCTEON_ALL_INTR
condition|)
block|{
name|lio_write_csr64
argument_list|(
name|oct
argument_list|,
name|cn23xx
operator|->
name|intr_enb_reg64
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|intr_flag
operator|&
name|OCTEON_OUTPUT_INTR
condition|)
block|{
name|intr_val
operator|=
name|lio_read_csr64
argument_list|(
name|oct
argument_list|,
name|cn23xx
operator|->
name|intr_enb_reg64
argument_list|)
expr_stmt|;
name|intr_val
operator|&=
operator|~
name|LIO_CN23XX_INTR_PKT_DATA
expr_stmt|;
name|lio_write_csr64
argument_list|(
name|oct
argument_list|,
name|cn23xx
operator|->
name|intr_enb_reg64
argument_list|,
name|intr_val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|lio_cn23xx_pf_get_pcie_qlmport
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
name|oct
operator|->
name|pcie_port
operator|=
operator|(
name|lio_read_csr32
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_MAC_NUMBER
argument_list|)
operator|)
operator|&
literal|0xff
expr_stmt|;
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"CN23xx uses PCIE Port %d\n"
argument_list|,
name|oct
operator|->
name|pcie_port
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lio_cn23xx_pf_get_pf_num
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
name|uint32_t
name|fdl_bit
decl_stmt|;
comment|/* Read Function Dependency Link reg to get the function number */
name|fdl_bit
operator|=
name|lio_read_pci_cfg
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_PCIE_SRIOV_FDL
argument_list|)
expr_stmt|;
name|oct
operator|->
name|pf_num
operator|=
operator|(
operator|(
name|fdl_bit
operator|>>
name|LIO_CN23XX_PCIE_SRIOV_FDL_BIT_POS
operator|)
operator|&
name|LIO_CN23XX_PCIE_SRIOV_FDL_MASK
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lio_cn23xx_pf_setup_reg_address
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
name|struct
name|lio_cn23xx_pf
modifier|*
name|cn23xx
init|=
operator|(
expr|struct
name|lio_cn23xx_pf
operator|*
operator|)
name|oct
operator|->
name|chip
decl_stmt|;
name|oct
operator|->
name|reg_list
operator|.
name|pci_win_wr_addr
operator|=
name|LIO_CN23XX_SLI_WIN_WR_ADDR64
expr_stmt|;
name|oct
operator|->
name|reg_list
operator|.
name|pci_win_rd_addr_hi
operator|=
name|LIO_CN23XX_SLI_WIN_RD_ADDR_HI
expr_stmt|;
name|oct
operator|->
name|reg_list
operator|.
name|pci_win_rd_addr_lo
operator|=
name|LIO_CN23XX_SLI_WIN_RD_ADDR64
expr_stmt|;
name|oct
operator|->
name|reg_list
operator|.
name|pci_win_rd_addr
operator|=
name|LIO_CN23XX_SLI_WIN_RD_ADDR64
expr_stmt|;
name|oct
operator|->
name|reg_list
operator|.
name|pci_win_wr_data_hi
operator|=
name|LIO_CN23XX_SLI_WIN_WR_DATA_HI
expr_stmt|;
name|oct
operator|->
name|reg_list
operator|.
name|pci_win_wr_data_lo
operator|=
name|LIO_CN23XX_SLI_WIN_WR_DATA_LO
expr_stmt|;
name|oct
operator|->
name|reg_list
operator|.
name|pci_win_wr_data
operator|=
name|LIO_CN23XX_SLI_WIN_WR_DATA64
expr_stmt|;
name|oct
operator|->
name|reg_list
operator|.
name|pci_win_rd_data
operator|=
name|LIO_CN23XX_SLI_WIN_RD_DATA64
expr_stmt|;
name|lio_cn23xx_pf_get_pcie_qlmport
argument_list|(
name|oct
argument_list|)
expr_stmt|;
name|cn23xx
operator|->
name|intr_mask64
operator|=
name|LIO_CN23XX_INTR_MASK
expr_stmt|;
if|if
condition|(
operator|!
name|oct
operator|->
name|msix_on
condition|)
name|cn23xx
operator|->
name|intr_mask64
operator||=
name|LIO_CN23XX_INTR_PKT_TIME
expr_stmt|;
name|cn23xx
operator|->
name|intr_sum_reg64
operator|=
name|LIO_CN23XX_SLI_MAC_PF_INT_SUM64
argument_list|(
name|oct
operator|->
name|pcie_port
argument_list|,
name|oct
operator|->
name|pf_num
argument_list|)
expr_stmt|;
name|cn23xx
operator|->
name|intr_enb_reg64
operator|=
name|LIO_CN23XX_SLI_MAC_PF_INT_ENB64
argument_list|(
name|oct
operator|->
name|pcie_port
argument_list|,
name|oct
operator|->
name|pf_num
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lio_cn23xx_pf_sriov_config
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
name|struct
name|lio_cn23xx_pf
modifier|*
name|cn23xx
init|=
operator|(
expr|struct
name|lio_cn23xx_pf
operator|*
operator|)
name|oct
operator|->
name|chip
decl_stmt|;
name|uint32_t
name|num_pf_rings
decl_stmt|,
name|total_rings
decl_stmt|,
name|max_rings
decl_stmt|;
name|cn23xx
operator|->
name|conf
operator|=
operator|(
expr|struct
name|lio_config
operator|*
operator|)
name|lio_get_config_info
argument_list|(
name|oct
argument_list|,
name|LIO_23XX
argument_list|)
expr_stmt|;
name|max_rings
operator|=
name|LIO_CN23XX_PF_MAX_RINGS
expr_stmt|;
if|if
condition|(
name|oct
operator|->
name|sriov_info
operator|.
name|num_pf_rings
condition|)
block|{
name|num_pf_rings
operator|=
name|oct
operator|->
name|sriov_info
operator|.
name|num_pf_rings
expr_stmt|;
if|if
condition|(
name|num_pf_rings
operator|>
name|max_rings
condition|)
block|{
name|num_pf_rings
operator|=
name|min
argument_list|(
name|mp_ncpus
argument_list|,
name|max_rings
argument_list|)
expr_stmt|;
name|lio_dev_warn
argument_list|(
name|oct
argument_list|,
literal|"num_queues_per_pf requested %u is more than available rings (%u). Reducing to %u\n"
argument_list|,
name|oct
operator|->
name|sriov_info
operator|.
name|num_pf_rings
argument_list|,
name|max_rings
argument_list|,
name|num_pf_rings
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|RSS
name|num_pf_rings
operator|=
name|min
argument_list|(
name|rss_getnumbuckets
argument_list|()
argument_list|,
name|mp_ncpus
argument_list|)
expr_stmt|;
else|#
directive|else
name|num_pf_rings
operator|=
name|min
argument_list|(
name|mp_ncpus
argument_list|,
name|max_rings
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|total_rings
operator|=
name|num_pf_rings
expr_stmt|;
name|oct
operator|->
name|sriov_info
operator|.
name|trs
operator|=
name|total_rings
expr_stmt|;
name|oct
operator|->
name|sriov_info
operator|.
name|pf_srn
operator|=
name|total_rings
operator|-
name|num_pf_rings
expr_stmt|;
name|oct
operator|->
name|sriov_info
operator|.
name|num_pf_rings
operator|=
name|num_pf_rings
expr_stmt|;
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"trs:%d pf_srn:%d num_pf_rings:%d\n"
argument_list|,
name|oct
operator|->
name|sriov_info
operator|.
name|trs
argument_list|,
name|oct
operator|->
name|sriov_info
operator|.
name|pf_srn
argument_list|,
name|oct
operator|->
name|sriov_info
operator|.
name|num_pf_rings
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lio_cn23xx_pf_setup_device
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
name|uint64_t
name|BAR0
decl_stmt|,
name|BAR1
decl_stmt|;
name|uint32_t
name|data32
decl_stmt|;
name|data32
operator|=
name|lio_read_pci_cfg
argument_list|(
name|oct
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
name|BAR0
operator|=
call|(
name|uint64_t
call|)
argument_list|(
name|data32
operator|&
operator|~
literal|0xf
argument_list|)
expr_stmt|;
name|data32
operator|=
name|lio_read_pci_cfg
argument_list|(
name|oct
argument_list|,
literal|0x14
argument_list|)
expr_stmt|;
name|BAR0
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|data32
operator|<<
literal|32
operator|)
expr_stmt|;
name|data32
operator|=
name|lio_read_pci_cfg
argument_list|(
name|oct
argument_list|,
literal|0x18
argument_list|)
expr_stmt|;
name|BAR1
operator|=
call|(
name|uint64_t
call|)
argument_list|(
name|data32
operator|&
operator|~
literal|0xf
argument_list|)
expr_stmt|;
name|data32
operator|=
name|lio_read_pci_cfg
argument_list|(
name|oct
argument_list|,
literal|0x1c
argument_list|)
expr_stmt|;
name|BAR1
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|data32
operator|<<
literal|32
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|BAR0
operator|||
operator|!
name|BAR1
condition|)
block|{
if|if
condition|(
operator|!
name|BAR0
condition|)
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Device BAR0 unassigned\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BAR1
condition|)
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Device BAR1 unassigned\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|lio_map_pci_barx
argument_list|(
name|oct
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|lio_map_pci_barx
argument_list|(
name|oct
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"%s CN23XX BAR1 map failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|lio_unmap_pci_barx
argument_list|(
name|oct
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|lio_cn23xx_pf_get_pf_num
argument_list|(
name|oct
argument_list|)
expr_stmt|;
if|if
condition|(
name|lio_cn23xx_pf_sriov_config
argument_list|(
name|oct
argument_list|)
condition|)
block|{
name|lio_unmap_pci_barx
argument_list|(
name|oct
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lio_unmap_pci_barx
argument_list|(
name|oct
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|lio_write_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_MAC_CREDIT_CNT
argument_list|,
literal|0x3F802080802080ULL
argument_list|)
expr_stmt|;
name|oct
operator|->
name|fn_list
operator|.
name|setup_iq_regs
operator|=
name|lio_cn23xx_pf_setup_iq_regs
expr_stmt|;
name|oct
operator|->
name|fn_list
operator|.
name|setup_oq_regs
operator|=
name|lio_cn23xx_pf_setup_oq_regs
expr_stmt|;
name|oct
operator|->
name|fn_list
operator|.
name|process_interrupt_regs
operator|=
name|lio_cn23xx_pf_interrupt_handler
expr_stmt|;
name|oct
operator|->
name|fn_list
operator|.
name|msix_interrupt_handler
operator|=
name|lio_cn23xx_pf_msix_interrupt_handler
expr_stmt|;
name|oct
operator|->
name|fn_list
operator|.
name|soft_reset
operator|=
name|lio_cn23xx_pf_soft_reset
expr_stmt|;
name|oct
operator|->
name|fn_list
operator|.
name|setup_device_regs
operator|=
name|lio_cn23xx_pf_setup_device_regs
expr_stmt|;
name|oct
operator|->
name|fn_list
operator|.
name|update_iq_read_idx
operator|=
name|lio_cn23xx_pf_update_read_index
expr_stmt|;
name|oct
operator|->
name|fn_list
operator|.
name|bar1_idx_setup
operator|=
name|lio_cn23xx_pf_bar1_idx_setup
expr_stmt|;
name|oct
operator|->
name|fn_list
operator|.
name|bar1_idx_write
operator|=
name|lio_cn23xx_pf_bar1_idx_write
expr_stmt|;
name|oct
operator|->
name|fn_list
operator|.
name|bar1_idx_read
operator|=
name|lio_cn23xx_pf_bar1_idx_read
expr_stmt|;
name|oct
operator|->
name|fn_list
operator|.
name|enable_interrupt
operator|=
name|lio_cn23xx_pf_enable_interrupt
expr_stmt|;
name|oct
operator|->
name|fn_list
operator|.
name|disable_interrupt
operator|=
name|lio_cn23xx_pf_disable_interrupt
expr_stmt|;
name|oct
operator|->
name|fn_list
operator|.
name|enable_io_queues
operator|=
name|lio_cn23xx_pf_enable_io_queues
expr_stmt|;
name|oct
operator|->
name|fn_list
operator|.
name|disable_io_queues
operator|=
name|lio_cn23xx_pf_disable_io_queues
expr_stmt|;
name|lio_cn23xx_pf_setup_reg_address
argument_list|(
name|oct
argument_list|)
expr_stmt|;
name|oct
operator|->
name|coproc_clock_rate
operator|=
literal|1000000ULL
operator|*
name|lio_cn23xx_pf_coprocessor_clock
argument_list|(
name|oct
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lio_cn23xx_pf_fw_loaded
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
name|uint64_t
name|val
decl_stmt|;
name|val
operator|=
name|lio_read_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_SCRATCH2
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|val
operator|>>
name|SCR2_BIT_FW_LOADED
operator|)
operator|&
literal|1ULL
operator|)
return|;
block|}
end_function

end_unit

