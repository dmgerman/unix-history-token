begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *   BSD LICENSE  *  *   Copyright(c) 2017 Cavium, Inc.. All rights reserved.  *   All rights reserved.  *  *   Redistribution and use in source and binary forms, with or without  *   modification, are permitted provided that the following conditions  *   are met:  *  *     * Redistributions of source code must retain the above copyright  *       notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above copyright  *       notice, this list of conditions and the following disclaimer in  *       the documentation and/or other materials provided with the  *       distribution.  *     * Neither the name of Cavium, Inc. nor the names of its  *       contributors may be used to endorse or promote products derived  *       from this software without specific prior written permission.  *  *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  *   OWNER(S) OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"lio_bsd.h"
end_include

begin_include
include|#
directive|include
file|"lio_common.h"
end_include

begin_include
include|#
directive|include
file|"lio_droq.h"
end_include

begin_include
include|#
directive|include
file|"lio_iq.h"
end_include

begin_include
include|#
directive|include
file|"lio_response_manager.h"
end_include

begin_include
include|#
directive|include
file|"lio_device.h"
end_include

begin_include
include|#
directive|include
file|"lio_main.h"
end_include

begin_include
include|#
directive|include
file|"cn23xx_pf_device.h"
end_include

begin_include
include|#
directive|include
file|"lio_network.h"
end_include

begin_struct
struct|struct
name|__dispatch
block|{
name|struct
name|lio_stailq_node
name|node
decl_stmt|;
name|struct
name|lio_recv_info
modifier|*
name|rinfo
decl_stmt|;
name|lio_dispatch_fn_t
name|disp_fn
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
name|void
modifier|*
name|lio_get_dispatch_arg
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|uint16_t
name|opcode
parameter_list|,
name|uint16_t
name|subcode
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  *  Get the argument that the user set when registering dispatch  *  function for a given opcode/subcode.  *  @param  octeon_dev - the octeon device pointer.  *  @param  opcode     - the opcode for which the dispatch argument  *                       is to be checked.  *  @param  subcode    - the subcode for which the dispatch argument  *                       is to be checked.  *  @return  Success: void * (argument to the dispatch function)  *  @return  Failure: NULL  *  */
end_comment

begin_function
name|void
modifier|*
name|lio_get_dispatch_arg
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|octeon_dev
parameter_list|,
name|uint16_t
name|opcode
parameter_list|,
name|uint16_t
name|subcode
parameter_list|)
block|{
name|struct
name|lio_stailq_node
modifier|*
name|dispatch
decl_stmt|;
name|void
modifier|*
name|fn_arg
init|=
name|NULL
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|uint16_t
name|combined_opcode
decl_stmt|;
name|combined_opcode
operator|=
name|LIO_OPCODE_SUBCODE
argument_list|(
name|opcode
argument_list|,
name|subcode
argument_list|)
expr_stmt|;
name|idx
operator|=
name|combined_opcode
operator|&
name|LIO_OPCODE_MASK
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|octeon_dev
operator|->
name|dispatch
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|octeon_dev
operator|->
name|dispatch
operator|.
name|count
operator|==
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|octeon_dev
operator|->
name|dispatch
operator|.
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|octeon_dev
operator|->
name|dispatch
operator|.
name|dlist
index|[
name|idx
index|]
operator|.
name|opcode
operator|==
name|combined_opcode
condition|)
block|{
name|fn_arg
operator|=
name|octeon_dev
operator|->
name|dispatch
operator|.
name|dlist
index|[
name|idx
index|]
operator|.
name|arg
expr_stmt|;
block|}
else|else
block|{
name|STAILQ_FOREACH
argument_list|(
argument|dispatch
argument_list|,
argument|&octeon_dev->dispatch.dlist[idx].head
argument_list|,
argument|entries
argument_list|)
block|{
if|if
condition|(
operator|(
operator|(
expr|struct
name|lio_dispatch
operator|*
operator|)
name|dispatch
operator|)
operator|->
name|opcode
operator|==
name|combined_opcode
condition|)
block|{
name|fn_arg
operator|=
operator|(
operator|(
expr|struct
name|lio_dispatch
operator|*
operator|)
name|dispatch
operator|)
operator|->
name|arg
expr_stmt|;
break|break;
block|}
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|octeon_dev
operator|->
name|dispatch
operator|.
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|fn_arg
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Check for packets on Droq. This function should be called with lock held.  *  @param  droq - Droq on which count is checked.  *  @return Returns packet count.  */
end_comment

begin_function
name|uint32_t
name|lio_droq_check_hw_for_pkts
parameter_list|(
name|struct
name|lio_droq
modifier|*
name|droq
parameter_list|)
block|{
name|struct
name|octeon_device
modifier|*
name|oct
init|=
name|droq
operator|->
name|oct_dev
decl_stmt|;
name|uint32_t
name|last_count
decl_stmt|;
name|uint32_t
name|pkt_count
init|=
literal|0
decl_stmt|;
name|pkt_count
operator|=
name|lio_read_csr32
argument_list|(
name|oct
argument_list|,
name|droq
operator|->
name|pkts_sent_reg
argument_list|)
expr_stmt|;
name|last_count
operator|=
name|pkt_count
operator|-
name|droq
operator|->
name|pkt_count
expr_stmt|;
name|droq
operator|->
name|pkt_count
operator|=
name|pkt_count
expr_stmt|;
comment|/* we shall write to cnts at the end of processing */
if|if
condition|(
name|last_count
condition|)
name|atomic_add_int
argument_list|(
operator|&
name|droq
operator|->
name|pkts_pending
argument_list|,
name|last_count
argument_list|)
expr_stmt|;
return|return
operator|(
name|last_count
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lio_droq_compute_max_packet_bufs
parameter_list|(
name|struct
name|lio_droq
modifier|*
name|droq
parameter_list|)
block|{
name|uint32_t
name|count
init|=
literal|0
decl_stmt|;
comment|/* 	 * max_empty_descs is the max. no. of descs that can have no buffers. 	 * If the empty desc count goes beyond this value, we cannot safely 	 * read in a 64K packet sent by Octeon 	 * (64K is max pkt size from Octeon) 	 */
name|droq
operator|->
name|max_empty_descs
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|droq
operator|->
name|max_empty_descs
operator|++
expr_stmt|;
name|count
operator|+=
name|droq
operator|->
name|buffer_size
expr_stmt|;
block|}
do|while
condition|(
name|count
operator|<
operator|(
literal|64
operator|*
literal|1024
operator|)
condition|)
do|;
name|droq
operator|->
name|max_empty_descs
operator|=
name|droq
operator|->
name|max_count
operator|-
name|droq
operator|->
name|max_empty_descs
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lio_droq_reset_indices
parameter_list|(
name|struct
name|lio_droq
modifier|*
name|droq
parameter_list|)
block|{
name|droq
operator|->
name|read_idx
operator|=
literal|0
expr_stmt|;
name|droq
operator|->
name|refill_idx
operator|=
literal|0
expr_stmt|;
name|droq
operator|->
name|refill_count
operator|=
literal|0
expr_stmt|;
name|atomic_store_rel_int
argument_list|(
operator|&
name|droq
operator|->
name|pkts_pending
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lio_droq_destroy_ring_buffers
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|struct
name|lio_droq
modifier|*
name|droq
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|droq
operator|->
name|max_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|droq
operator|->
name|recv_buf_list
index|[
name|i
index|]
operator|.
name|buffer
operator|!=
name|NULL
condition|)
block|{
name|lio_recv_buffer_free
argument_list|(
name|droq
operator|->
name|recv_buf_list
index|[
name|i
index|]
operator|.
name|buffer
argument_list|)
expr_stmt|;
name|droq
operator|->
name|recv_buf_list
index|[
name|i
index|]
operator|.
name|buffer
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|lio_droq_reset_indices
argument_list|(
name|droq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lio_droq_setup_ring_buffers
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|struct
name|lio_droq
modifier|*
name|droq
parameter_list|)
block|{
name|struct
name|lio_droq_desc
modifier|*
name|desc_ring
init|=
name|droq
operator|->
name|desc_ring
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|droq
operator|->
name|max_count
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|=
name|lio_recv_buffer_alloc
argument_list|(
name|droq
operator|->
name|buffer_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"%s buffer alloc failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|droq
operator|->
name|stats
operator|.
name|rx_alloc_failure
operator|++
expr_stmt|;
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
block|}
name|droq
operator|->
name|recv_buf_list
index|[
name|i
index|]
operator|.
name|buffer
operator|=
name|buf
expr_stmt|;
name|droq
operator|->
name|recv_buf_list
index|[
name|i
index|]
operator|.
name|data
operator|=
operator|(
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|buf
operator|)
operator|->
name|m_data
expr_stmt|;
name|desc_ring
index|[
name|i
index|]
operator|.
name|info_ptr
operator|=
literal|0
expr_stmt|;
name|desc_ring
index|[
name|i
index|]
operator|.
name|buffer_ptr
operator|=
name|lio_map_ring
argument_list|(
name|oct
operator|->
name|device
argument_list|,
name|droq
operator|->
name|recv_buf_list
index|[
name|i
index|]
operator|.
name|buffer
argument_list|,
name|droq
operator|->
name|buffer_size
argument_list|)
expr_stmt|;
block|}
name|lio_droq_reset_indices
argument_list|(
name|droq
argument_list|)
expr_stmt|;
name|lio_droq_compute_max_packet_bufs
argument_list|(
name|droq
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lio_delete_droq
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|uint32_t
name|q_no
parameter_list|)
block|{
name|struct
name|lio_droq
modifier|*
name|droq
init|=
name|oct
operator|->
name|droq
index|[
name|q_no
index|]
decl_stmt|;
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"%s[%d]\n"
argument_list|,
name|__func__
argument_list|,
name|q_no
argument_list|)
expr_stmt|;
while|while
condition|(
name|taskqueue_cancel
argument_list|(
name|droq
operator|->
name|droq_taskqueue
argument_list|,
operator|&
name|droq
operator|->
name|droq_task
argument_list|,
name|NULL
argument_list|)
condition|)
name|taskqueue_drain
argument_list|(
name|droq
operator|->
name|droq_taskqueue
argument_list|,
operator|&
name|droq
operator|->
name|droq_task
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|droq
operator|->
name|droq_taskqueue
argument_list|)
expr_stmt|;
name|droq
operator|->
name|droq_taskqueue
operator|=
name|NULL
expr_stmt|;
name|lio_droq_destroy_ring_buffers
argument_list|(
name|oct
argument_list|,
name|droq
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|droq
operator|->
name|recv_buf_list
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|droq
operator|->
name|desc_ring
operator|!=
name|NULL
condition|)
name|lio_dma_free
argument_list|(
operator|(
name|droq
operator|->
name|max_count
operator|*
name|LIO_DROQ_DESC_SIZE
operator|)
argument_list|,
name|droq
operator|->
name|desc_ring
argument_list|)
expr_stmt|;
name|oct
operator|->
name|io_qmask
operator|.
name|oq
operator|&=
operator|~
operator|(
literal|1ULL
operator|<<
name|q_no
operator|)
expr_stmt|;
name|bzero
argument_list|(
name|oct
operator|->
name|droq
index|[
name|q_no
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lio_droq
argument_list|)
argument_list|)
expr_stmt|;
name|oct
operator|->
name|num_oqs
operator|--
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|lio_droq_bh
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|int
name|pending
name|__unused
parameter_list|)
block|{
name|struct
name|lio_droq
modifier|*
name|droq
init|=
name|ptr
decl_stmt|;
name|struct
name|octeon_device
modifier|*
name|oct
init|=
name|droq
operator|->
name|oct_dev
decl_stmt|;
name|struct
name|lio_instr_queue
modifier|*
name|iq
init|=
name|oct
operator|->
name|instr_queue
index|[
name|droq
operator|->
name|q_no
index|]
decl_stmt|;
name|int
name|reschedule
decl_stmt|,
name|tx_done
init|=
literal|1
decl_stmt|;
name|reschedule
operator|=
name|lio_droq_process_packets
argument_list|(
name|oct
argument_list|,
name|droq
argument_list|,
name|oct
operator|->
name|rx_budget
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|iq
operator|->
name|instr_pending
argument_list|)
condition|)
name|tx_done
operator|=
name|lio_flush_iq
argument_list|(
name|oct
argument_list|,
name|iq
argument_list|,
name|oct
operator|->
name|tx_budget
argument_list|)
expr_stmt|;
if|if
condition|(
name|reschedule
operator|||
operator|!
name|tx_done
condition|)
name|taskqueue_enqueue
argument_list|(
name|droq
operator|->
name|droq_taskqueue
argument_list|,
operator|&
name|droq
operator|->
name|droq_task
argument_list|)
expr_stmt|;
else|else
name|lio_enable_irq
argument_list|(
name|droq
argument_list|,
name|iq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|lio_init_droq
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|uint32_t
name|q_no
parameter_list|,
name|uint32_t
name|num_descs
parameter_list|,
name|uint32_t
name|desc_size
parameter_list|,
name|void
modifier|*
name|app_ctx
parameter_list|)
block|{
name|struct
name|lio_droq
modifier|*
name|droq
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|uint32_t
name|c_buf_size
init|=
literal|0
decl_stmt|,
name|c_num_descs
init|=
literal|0
decl_stmt|,
name|c_pkts_per_intr
init|=
literal|0
decl_stmt|;
name|uint32_t
name|c_refill_threshold
init|=
literal|0
decl_stmt|,
name|desc_ring_size
init|=
literal|0
decl_stmt|;
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"%s[%d]\n"
argument_list|,
name|__func__
argument_list|,
name|q_no
argument_list|)
expr_stmt|;
name|droq
operator|=
name|oct
operator|->
name|droq
index|[
name|q_no
index|]
expr_stmt|;
name|bzero
argument_list|(
name|droq
argument_list|,
name|LIO_DROQ_SIZE
argument_list|)
expr_stmt|;
name|droq
operator|->
name|oct_dev
operator|=
name|oct
expr_stmt|;
name|droq
operator|->
name|q_no
operator|=
name|q_no
expr_stmt|;
if|if
condition|(
name|app_ctx
operator|!=
name|NULL
condition|)
name|droq
operator|->
name|app_ctx
operator|=
name|app_ctx
expr_stmt|;
else|else
name|droq
operator|->
name|app_ctx
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|size_t
operator|)
name|q_no
expr_stmt|;
name|c_num_descs
operator|=
name|num_descs
expr_stmt|;
name|c_buf_size
operator|=
name|desc_size
expr_stmt|;
if|if
condition|(
name|LIO_CN23XX_PF
argument_list|(
name|oct
argument_list|)
condition|)
block|{
name|struct
name|lio_config
modifier|*
name|conf23
init|=
name|LIO_CHIP_CONF
argument_list|(
name|oct
argument_list|,
name|cn23xx_pf
argument_list|)
decl_stmt|;
name|c_pkts_per_intr
operator|=
operator|(
name|uint32_t
operator|)
name|LIO_GET_OQ_PKTS_PER_INTR_CFG
argument_list|(
name|conf23
argument_list|)
expr_stmt|;
name|c_refill_threshold
operator|=
operator|(
name|uint32_t
operator|)
name|LIO_GET_OQ_REFILL_THRESHOLD_CFG
argument_list|(
name|conf23
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|droq
operator|->
name|max_count
operator|=
name|c_num_descs
expr_stmt|;
name|droq
operator|->
name|buffer_size
operator|=
name|c_buf_size
expr_stmt|;
name|desc_ring_size
operator|=
name|droq
operator|->
name|max_count
operator|*
name|LIO_DROQ_DESC_SIZE
expr_stmt|;
name|droq
operator|->
name|desc_ring
operator|=
name|lio_dma_alloc
argument_list|(
name|desc_ring_size
argument_list|,
operator|&
name|droq
operator|->
name|desc_ring_dma
argument_list|)
expr_stmt|;
if|if
condition|(
name|droq
operator|->
name|desc_ring
operator|==
name|NULL
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Output queue %d ring alloc failed\n"
argument_list|,
name|q_no
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"droq[%d]: desc_ring: virt: 0x%p, dma: %lx\n"
argument_list|,
name|q_no
argument_list|,
name|droq
operator|->
name|desc_ring
argument_list|,
name|droq
operator|->
name|desc_ring_dma
argument_list|)
expr_stmt|;
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"droq[%d]: num_desc: %d\n"
argument_list|,
name|q_no
argument_list|,
name|droq
operator|->
name|max_count
argument_list|)
expr_stmt|;
name|size
operator|=
name|droq
operator|->
name|max_count
operator|*
name|LIO_DROQ_RECVBUF_SIZE
expr_stmt|;
name|droq
operator|->
name|recv_buf_list
operator|=
operator|(
expr|struct
name|lio_recv_buffer
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|droq
operator|->
name|recv_buf_list
operator|==
name|NULL
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Output queue recv buf list alloc failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|init_droq_fail
goto|;
block|}
if|if
condition|(
name|lio_droq_setup_ring_buffers
argument_list|(
name|oct
argument_list|,
name|droq
argument_list|)
condition|)
goto|goto
name|init_droq_fail
goto|;
name|droq
operator|->
name|pkts_per_intr
operator|=
name|c_pkts_per_intr
expr_stmt|;
name|droq
operator|->
name|refill_threshold
operator|=
name|c_refill_threshold
expr_stmt|;
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"DROQ INIT: max_empty_descs: %d\n"
argument_list|,
name|droq
operator|->
name|max_empty_descs
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|droq
operator|->
name|lock
argument_list|,
literal|"droq_lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|droq
operator|->
name|dispatch_stq_head
argument_list|)
expr_stmt|;
name|oct
operator|->
name|fn_list
operator|.
name|setup_oq_regs
argument_list|(
name|oct
argument_list|,
name|q_no
argument_list|)
expr_stmt|;
name|oct
operator|->
name|io_qmask
operator|.
name|oq
operator||=
name|BIT_ULL
argument_list|(
name|q_no
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the taskqueue that handles 	 * output queue packet processing. 	 */
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"Initializing droq%d taskqueue\n"
argument_list|,
name|q_no
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|droq
operator|->
name|droq_task
argument_list|,
literal|0
argument_list|,
name|lio_droq_bh
argument_list|,
operator|(
name|void
operator|*
operator|)
name|droq
argument_list|)
expr_stmt|;
name|droq
operator|->
name|droq_taskqueue
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"lio_droq_task"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|droq
operator|->
name|droq_taskqueue
argument_list|)
expr_stmt|;
name|taskqueue_start_threads_cpuset
argument_list|(
operator|&
name|droq
operator|->
name|droq_taskqueue
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
operator|&
name|oct
operator|->
name|ioq_vector
index|[
name|q_no
index|]
operator|.
name|affinity_mask
argument_list|,
literal|"lio%d_droq%d_task"
argument_list|,
name|oct
operator|->
name|octeon_id
argument_list|,
name|q_no
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|init_droq_fail
label|:
name|lio_delete_droq
argument_list|(
name|oct
argument_list|,
name|q_no
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * lio_create_recv_info  * Parameters:  *  octeon_dev - pointer to the octeon device structure  *  droq       - droq in which the packet arrived.  *  buf_cnt    - no. of buffers used by the packet.  *  idx        - index in the descriptor for the first buffer in the packet.  * Description:  *  Allocates a recv_info_t and copies the buffer addresses for packet data  *  into the recv_pkt space which starts at an 8B offset from recv_info_t.  *  Flags the descriptors for refill later. If available descriptors go  *  below the threshold to receive a 64K pkt, new buffers are first allocated  *  before the recv_pkt_t is created.  *  This routine will be called in interrupt context.  * Returns:  *  Success: Pointer to recv_info_t  *  Failure: NULL.  * Locks:  *  The droq->lock is held when this routine is called.  */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|lio_recv_info
modifier|*
name|lio_create_recv_info
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|octeon_dev
parameter_list|,
name|struct
name|lio_droq
modifier|*
name|droq
parameter_list|,
name|uint32_t
name|buf_cnt
parameter_list|,
name|uint32_t
name|idx
parameter_list|)
block|{
name|struct
name|lio_droq_info
modifier|*
name|info
decl_stmt|;
name|struct
name|lio_recv_pkt
modifier|*
name|recv_pkt
decl_stmt|;
name|struct
name|lio_recv_info
modifier|*
name|recv_info
decl_stmt|;
name|uint32_t
name|bytes_left
decl_stmt|,
name|i
decl_stmt|;
name|info
operator|=
operator|(
expr|struct
name|lio_droq_info
operator|*
operator|)
name|droq
operator|->
name|recv_buf_list
index|[
name|idx
index|]
operator|.
name|data
expr_stmt|;
name|recv_info
operator|=
name|lio_alloc_recv_info
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|__dispatch
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|recv_info
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|recv_pkt
operator|=
name|recv_info
operator|->
name|recv_pkt
expr_stmt|;
name|recv_pkt
operator|->
name|rh
operator|=
name|info
operator|->
name|rh
expr_stmt|;
name|recv_pkt
operator|->
name|length
operator|=
operator|(
name|uint32_t
operator|)
name|info
operator|->
name|length
expr_stmt|;
name|recv_pkt
operator|->
name|buffer_count
operator|=
operator|(
name|uint16_t
operator|)
name|buf_cnt
expr_stmt|;
name|recv_pkt
operator|->
name|octeon_id
operator|=
operator|(
name|uint16_t
operator|)
name|octeon_dev
operator|->
name|octeon_id
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|bytes_left
operator|=
operator|(
name|uint32_t
operator|)
name|info
operator|->
name|length
expr_stmt|;
while|while
condition|(
name|buf_cnt
condition|)
block|{
name|recv_pkt
operator|->
name|buffer_size
index|[
name|i
index|]
operator|=
operator|(
name|bytes_left
operator|>=
name|droq
operator|->
name|buffer_size
operator|)
condition|?
name|droq
operator|->
name|buffer_size
else|:
name|bytes_left
expr_stmt|;
name|recv_pkt
operator|->
name|buffer_ptr
index|[
name|i
index|]
operator|=
name|droq
operator|->
name|recv_buf_list
index|[
name|idx
index|]
operator|.
name|buffer
expr_stmt|;
name|droq
operator|->
name|recv_buf_list
index|[
name|idx
index|]
operator|.
name|buffer
operator|=
name|NULL
expr_stmt|;
name|idx
operator|=
name|lio_incr_index
argument_list|(
name|idx
argument_list|,
literal|1
argument_list|,
name|droq
operator|->
name|max_count
argument_list|)
expr_stmt|;
name|bytes_left
operator|-=
name|droq
operator|->
name|buffer_size
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|buf_cnt
operator|--
expr_stmt|;
block|}
return|return
operator|(
name|recv_info
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If we were not able to refill all buffers, try to move around  * the buffers that were not dispatched.  */
end_comment

begin_function
specifier|static
specifier|inline
name|uint32_t
name|lio_droq_refill_pullup_descs
parameter_list|(
name|struct
name|lio_droq
modifier|*
name|droq
parameter_list|,
name|struct
name|lio_droq_desc
modifier|*
name|desc_ring
parameter_list|)
block|{
name|uint32_t
name|desc_refilled
init|=
literal|0
decl_stmt|;
name|uint32_t
name|refill_index
init|=
name|droq
operator|->
name|refill_idx
decl_stmt|;
while|while
condition|(
name|refill_index
operator|!=
name|droq
operator|->
name|read_idx
condition|)
block|{
if|if
condition|(
name|droq
operator|->
name|recv_buf_list
index|[
name|refill_index
index|]
operator|.
name|buffer
operator|!=
name|NULL
condition|)
block|{
name|droq
operator|->
name|recv_buf_list
index|[
name|droq
operator|->
name|refill_idx
index|]
operator|.
name|buffer
operator|=
name|droq
operator|->
name|recv_buf_list
index|[
name|refill_index
index|]
operator|.
name|buffer
expr_stmt|;
name|droq
operator|->
name|recv_buf_list
index|[
name|droq
operator|->
name|refill_idx
index|]
operator|.
name|data
operator|=
name|droq
operator|->
name|recv_buf_list
index|[
name|refill_index
index|]
operator|.
name|data
expr_stmt|;
name|desc_ring
index|[
name|droq
operator|->
name|refill_idx
index|]
operator|.
name|buffer_ptr
operator|=
name|desc_ring
index|[
name|refill_index
index|]
operator|.
name|buffer_ptr
expr_stmt|;
name|droq
operator|->
name|recv_buf_list
index|[
name|refill_index
index|]
operator|.
name|buffer
operator|=
name|NULL
expr_stmt|;
name|desc_ring
index|[
name|refill_index
index|]
operator|.
name|buffer_ptr
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|droq
operator|->
name|refill_idx
operator|=
name|lio_incr_index
argument_list|(
name|droq
operator|->
name|refill_idx
argument_list|,
literal|1
argument_list|,
name|droq
operator|->
name|max_count
argument_list|)
expr_stmt|;
name|desc_refilled
operator|++
expr_stmt|;
name|droq
operator|->
name|refill_count
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|droq
operator|->
name|recv_buf_list
index|[
name|droq
operator|->
name|refill_idx
index|]
operator|.
name|buffer
operator|!=
name|NULL
condition|)
do|;
block|}
name|refill_index
operator|=
name|lio_incr_index
argument_list|(
name|refill_index
argument_list|,
literal|1
argument_list|,
name|droq
operator|->
name|max_count
argument_list|)
expr_stmt|;
block|}
comment|/* while */
return|return
operator|(
name|desc_refilled
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * lio_droq_refill  * Parameters:  *  droq       - droq in which descriptors require new buffers.  * Description:  *  Called during normal DROQ processing in interrupt mode or by the poll  *  thread to refill the descriptors from which buffers were dispatched  *  to upper layers. Attempts to allocate new buffers. If that fails, moves  *  up buffers (that were not dispatched) to form a contiguous ring.  * Returns:  *  No of descriptors refilled.  * Locks:  *  This routine is called with droq->lock held.  */
end_comment

begin_function
name|uint32_t
name|lio_droq_refill
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|octeon_dev
parameter_list|,
name|struct
name|lio_droq
modifier|*
name|droq
parameter_list|)
block|{
name|struct
name|lio_droq_desc
modifier|*
name|desc_ring
decl_stmt|;
name|void
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|desc_refilled
init|=
literal|0
decl_stmt|;
name|uint8_t
modifier|*
name|data
decl_stmt|;
name|desc_ring
operator|=
name|droq
operator|->
name|desc_ring
expr_stmt|;
while|while
condition|(
name|droq
operator|->
name|refill_count
operator|&&
operator|(
name|desc_refilled
operator|<
name|droq
operator|->
name|max_count
operator|)
condition|)
block|{
comment|/* 		 * If a valid buffer exists (happens if there is no dispatch), 		 * reuse 		 * the buffer, else allocate. 		 */
if|if
condition|(
name|droq
operator|->
name|recv_buf_list
index|[
name|droq
operator|->
name|refill_idx
index|]
operator|.
name|buffer
operator|==
name|NULL
condition|)
block|{
name|buf
operator|=
name|lio_recv_buffer_alloc
argument_list|(
name|droq
operator|->
name|buffer_size
argument_list|)
expr_stmt|;
comment|/* 			 * If a buffer could not be allocated, no point in 			 * continuing 			 */
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|droq
operator|->
name|stats
operator|.
name|rx_alloc_failure
operator|++
expr_stmt|;
break|break;
block|}
name|droq
operator|->
name|recv_buf_list
index|[
name|droq
operator|->
name|refill_idx
index|]
operator|.
name|buffer
operator|=
name|buf
expr_stmt|;
name|data
operator|=
operator|(
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|buf
operator|)
operator|->
name|m_data
expr_stmt|;
block|}
else|else
block|{
name|data
operator|=
operator|(
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|droq
operator|->
name|recv_buf_list
index|[
name|droq
operator|->
name|refill_idx
index|]
operator|.
name|buffer
operator|)
operator|->
name|m_data
expr_stmt|;
block|}
name|droq
operator|->
name|recv_buf_list
index|[
name|droq
operator|->
name|refill_idx
index|]
operator|.
name|data
operator|=
name|data
expr_stmt|;
name|desc_ring
index|[
name|droq
operator|->
name|refill_idx
index|]
operator|.
name|buffer_ptr
operator|=
name|lio_map_ring
argument_list|(
name|octeon_dev
operator|->
name|device
argument_list|,
name|droq
operator|->
name|recv_buf_list
index|[
name|droq
operator|->
name|refill_idx
index|]
operator|.
name|buffer
argument_list|,
name|droq
operator|->
name|buffer_size
argument_list|)
expr_stmt|;
name|droq
operator|->
name|refill_idx
operator|=
name|lio_incr_index
argument_list|(
name|droq
operator|->
name|refill_idx
argument_list|,
literal|1
argument_list|,
name|droq
operator|->
name|max_count
argument_list|)
expr_stmt|;
name|desc_refilled
operator|++
expr_stmt|;
name|droq
operator|->
name|refill_count
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|droq
operator|->
name|refill_count
condition|)
name|desc_refilled
operator|+=
name|lio_droq_refill_pullup_descs
argument_list|(
name|droq
argument_list|,
name|desc_ring
argument_list|)
expr_stmt|;
comment|/* 	 * if droq->refill_count 	 * The refill count would not change in pass two. We only moved buffers 	 * to close the gap in the ring, but we would still have the same no. of 	 * buffers to refill. 	 */
return|return
operator|(
name|desc_refilled
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint32_t
name|lio_droq_get_bufcount
parameter_list|(
name|uint32_t
name|buf_size
parameter_list|,
name|uint32_t
name|total_len
parameter_list|)
block|{
return|return
operator|(
operator|(
name|total_len
operator|+
name|buf_size
operator|-
literal|1
operator|)
operator|/
name|buf_size
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lio_droq_dispatch_pkt
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|struct
name|lio_droq
modifier|*
name|droq
parameter_list|,
name|union
name|octeon_rh
modifier|*
name|rh
parameter_list|,
name|struct
name|lio_droq_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|lio_recv_info
modifier|*
name|rinfo
decl_stmt|;
name|lio_dispatch_fn_t
name|disp_fn
decl_stmt|;
name|uint32_t
name|cnt
decl_stmt|;
name|cnt
operator|=
name|lio_droq_get_bufcount
argument_list|(
name|droq
operator|->
name|buffer_size
argument_list|,
operator|(
name|uint32_t
operator|)
name|info
operator|->
name|length
argument_list|)
expr_stmt|;
name|disp_fn
operator|=
name|lio_get_dispatch
argument_list|(
name|oct
argument_list|,
operator|(
name|uint16_t
operator|)
name|rh
operator|->
name|r
operator|.
name|opcode
argument_list|,
operator|(
name|uint16_t
operator|)
name|rh
operator|->
name|r
operator|.
name|subcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|disp_fn
condition|)
block|{
name|rinfo
operator|=
name|lio_create_recv_info
argument_list|(
name|oct
argument_list|,
name|droq
argument_list|,
name|cnt
argument_list|,
name|droq
operator|->
name|read_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|rinfo
operator|!=
name|NULL
condition|)
block|{
name|struct
name|__dispatch
modifier|*
name|rdisp
init|=
name|rinfo
operator|->
name|rsvd
decl_stmt|;
name|rdisp
operator|->
name|rinfo
operator|=
name|rinfo
expr_stmt|;
name|rdisp
operator|->
name|disp_fn
operator|=
name|disp_fn
expr_stmt|;
name|rinfo
operator|->
name|recv_pkt
operator|->
name|rh
operator|=
operator|*
name|rh
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|droq
operator|->
name|dispatch_stq_head
argument_list|,
operator|&
name|rdisp
operator|->
name|node
argument_list|,
name|entries
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|droq
operator|->
name|stats
operator|.
name|dropped_nomem
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"DROQ: No dispatch function (opcode %u/%u)\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|rh
operator|->
name|r
operator|.
name|opcode
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|rh
operator|->
name|r
operator|.
name|subcode
argument_list|)
expr_stmt|;
name|droq
operator|->
name|stats
operator|.
name|dropped_nodispatch
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|cnt
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|lio_droq_drop_packets
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|struct
name|lio_droq
modifier|*
name|droq
parameter_list|,
name|uint32_t
name|cnt
parameter_list|)
block|{
name|struct
name|lio_droq_info
modifier|*
name|info
decl_stmt|;
name|uint32_t
name|i
init|=
literal|0
decl_stmt|,
name|buf_cnt
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|info
operator|=
operator|(
expr|struct
name|lio_droq_info
operator|*
operator|)
name|droq
operator|->
name|recv_buf_list
index|[
name|droq
operator|->
name|read_idx
index|]
operator|.
name|data
expr_stmt|;
name|lio_swap_8B_data
argument_list|(
operator|(
name|uint64_t
operator|*
operator|)
name|info
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|length
condition|)
block|{
name|info
operator|->
name|length
operator|+=
literal|8
expr_stmt|;
name|droq
operator|->
name|stats
operator|.
name|bytes_received
operator|+=
name|info
operator|->
name|length
expr_stmt|;
name|buf_cnt
operator|=
name|lio_droq_get_bufcount
argument_list|(
name|droq
operator|->
name|buffer_size
argument_list|,
operator|(
name|uint32_t
operator|)
name|info
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"DROQ: In drop: pkt with len 0\n"
argument_list|)
expr_stmt|;
name|buf_cnt
operator|=
literal|1
expr_stmt|;
block|}
name|droq
operator|->
name|read_idx
operator|=
name|lio_incr_index
argument_list|(
name|droq
operator|->
name|read_idx
argument_list|,
name|buf_cnt
argument_list|,
name|droq
operator|->
name|max_count
argument_list|)
expr_stmt|;
name|droq
operator|->
name|refill_count
operator|+=
name|buf_cnt
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|lio_droq_fast_process_packets
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|struct
name|lio_droq
modifier|*
name|droq
parameter_list|,
name|uint32_t
name|pkts_to_process
parameter_list|)
block|{
name|struct
name|lio_droq_info
modifier|*
name|info
decl_stmt|;
name|union
name|octeon_rh
modifier|*
name|rh
decl_stmt|;
name|uint32_t
name|pkt
decl_stmt|,
name|pkt_count
decl_stmt|,
name|total_len
init|=
literal|0
decl_stmt|;
name|pkt_count
operator|=
name|pkts_to_process
expr_stmt|;
for|for
control|(
name|pkt
operator|=
literal|0
init|;
name|pkt
operator|<
name|pkt_count
condition|;
name|pkt
operator|++
control|)
block|{
name|struct
name|mbuf
modifier|*
name|nicbuf
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|pkt_len
init|=
literal|0
decl_stmt|;
name|info
operator|=
operator|(
expr|struct
name|lio_droq_info
operator|*
operator|)
name|droq
operator|->
name|recv_buf_list
index|[
name|droq
operator|->
name|read_idx
index|]
operator|.
name|data
expr_stmt|;
name|lio_swap_8B_data
argument_list|(
operator|(
name|uint64_t
operator|*
operator|)
name|info
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|length
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"DROQ[%d] idx: %d len:0, pkt_cnt: %d\n"
argument_list|,
name|droq
operator|->
name|q_no
argument_list|,
name|droq
operator|->
name|read_idx
argument_list|,
name|pkt_count
argument_list|)
expr_stmt|;
name|hexdump
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|info
argument_list|,
name|LIO_DROQ_INFO_SIZE
argument_list|,
name|NULL
argument_list|,
name|HD_OMIT_CHARS
argument_list|)
expr_stmt|;
name|pkt
operator|++
expr_stmt|;
name|lio_incr_index
argument_list|(
name|droq
operator|->
name|read_idx
argument_list|,
literal|1
argument_list|,
name|droq
operator|->
name|max_count
argument_list|)
expr_stmt|;
name|droq
operator|->
name|refill_count
operator|++
expr_stmt|;
break|break;
block|}
name|rh
operator|=
operator|&
name|info
operator|->
name|rh
expr_stmt|;
name|info
operator|->
name|length
operator|+=
literal|8
expr_stmt|;
name|rh
operator|->
name|r_dh
operator|.
name|len
operator|+=
operator|(
name|LIO_DROQ_INFO_SIZE
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
name|total_len
operator|+=
operator|(
name|uint32_t
operator|)
name|info
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|lio_opcode_slow_path
argument_list|(
name|rh
argument_list|)
condition|)
block|{
name|uint32_t
name|buf_cnt
decl_stmt|;
name|buf_cnt
operator|=
name|lio_droq_dispatch_pkt
argument_list|(
name|oct
argument_list|,
name|droq
argument_list|,
name|rh
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|droq
operator|->
name|read_idx
operator|=
name|lio_incr_index
argument_list|(
name|droq
operator|->
name|read_idx
argument_list|,
name|buf_cnt
argument_list|,
name|droq
operator|->
name|max_count
argument_list|)
expr_stmt|;
name|droq
operator|->
name|refill_count
operator|+=
name|buf_cnt
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|info
operator|->
name|length
operator|<=
name|droq
operator|->
name|buffer_size
condition|)
block|{
name|pkt_len
operator|=
operator|(
name|uint32_t
operator|)
name|info
operator|->
name|length
expr_stmt|;
name|nicbuf
operator|=
name|droq
operator|->
name|recv_buf_list
index|[
name|droq
operator|->
name|read_idx
index|]
operator|.
name|buffer
expr_stmt|;
name|nicbuf
operator|->
name|m_len
operator|=
name|pkt_len
expr_stmt|;
name|droq
operator|->
name|recv_buf_list
index|[
name|droq
operator|->
name|read_idx
index|]
operator|.
name|buffer
operator|=
name|NULL
expr_stmt|;
name|droq
operator|->
name|read_idx
operator|=
name|lio_incr_index
argument_list|(
name|droq
operator|->
name|read_idx
argument_list|,
literal|1
argument_list|,
name|droq
operator|->
name|max_count
argument_list|)
expr_stmt|;
name|droq
operator|->
name|refill_count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|bool
name|secondary_frag
init|=
name|false
decl_stmt|;
name|pkt_len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|pkt_len
operator|<
name|info
operator|->
name|length
condition|)
block|{
name|int
name|frag_len
decl_stmt|,
name|idx
init|=
name|droq
operator|->
name|read_idx
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|buffer
decl_stmt|;
name|frag_len
operator|=
operator|(
operator|(
name|pkt_len
operator|+
name|droq
operator|->
name|buffer_size
operator|)
operator|>
name|info
operator|->
name|length
operator|)
condition|?
operator|(
operator|(
name|uint32_t
operator|)
name|info
operator|->
name|length
operator|-
name|pkt_len
operator|)
else|:
name|droq
operator|->
name|buffer_size
expr_stmt|;
name|buffer
operator|=
operator|(
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|droq
operator|->
name|recv_buf_list
index|[
name|idx
index|]
operator|.
name|buffer
operator|)
expr_stmt|;
name|buffer
operator|->
name|m_len
operator|=
name|frag_len
expr_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
name|secondary_frag
argument_list|)
condition|)
block|{
name|m_cat
argument_list|(
name|nicbuf
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nicbuf
operator|=
name|buffer
expr_stmt|;
name|secondary_frag
operator|=
name|true
expr_stmt|;
block|}
name|droq
operator|->
name|recv_buf_list
index|[
name|droq
operator|->
name|read_idx
index|]
operator|.
name|buffer
operator|=
name|NULL
expr_stmt|;
name|pkt_len
operator|+=
name|frag_len
expr_stmt|;
name|droq
operator|->
name|read_idx
operator|=
name|lio_incr_index
argument_list|(
name|droq
operator|->
name|read_idx
argument_list|,
literal|1
argument_list|,
name|droq
operator|->
name|max_count
argument_list|)
expr_stmt|;
name|droq
operator|->
name|refill_count
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nicbuf
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|droq
operator|->
name|ops
operator|.
name|fptr
operator|!=
name|NULL
condition|)
block|{
name|droq
operator|->
name|ops
operator|.
name|fptr
argument_list|(
name|nicbuf
argument_list|,
name|pkt_len
argument_list|,
name|rh
argument_list|,
name|droq
argument_list|,
name|droq
operator|->
name|ops
operator|.
name|farg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lio_recv_buffer_free
argument_list|(
name|nicbuf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|droq
operator|->
name|refill_count
operator|>=
name|droq
operator|->
name|refill_threshold
condition|)
block|{
name|int
name|desc_refilled
init|=
name|lio_droq_refill
argument_list|(
name|oct
argument_list|,
name|droq
argument_list|)
decl_stmt|;
comment|/* 			 * Flush the droq descriptor data to memory to be sure 			 * that when we update the credits the data in memory 			 * is accurate. 			 */
name|wmb
argument_list|()
expr_stmt|;
name|lio_write_csr32
argument_list|(
name|oct
argument_list|,
name|droq
operator|->
name|pkts_credit_reg
argument_list|,
name|desc_refilled
argument_list|)
expr_stmt|;
comment|/* make sure mmio write completes */
name|__compiler_membar
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* for (each packet)... */
comment|/* Increment refill_count by the number of buffers processed. */
name|droq
operator|->
name|stats
operator|.
name|pkts_received
operator|+=
name|pkt
expr_stmt|;
name|droq
operator|->
name|stats
operator|.
name|bytes_received
operator|+=
name|total_len
expr_stmt|;
name|tcp_lro_flush_all
argument_list|(
operator|&
name|droq
operator|->
name|lro
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|droq
operator|->
name|ops
operator|.
name|drop_on_max
operator|)
operator|&&
operator|(
name|pkts_to_process
operator|-
name|pkt
operator|)
condition|)
block|{
name|lio_droq_drop_packets
argument_list|(
name|oct
argument_list|,
name|droq
argument_list|,
operator|(
name|pkts_to_process
operator|-
name|pkt
operator|)
argument_list|)
expr_stmt|;
name|droq
operator|->
name|stats
operator|.
name|dropped_toomany
operator|+=
operator|(
name|pkts_to_process
operator|-
name|pkt
operator|)
expr_stmt|;
return|return
operator|(
name|pkts_to_process
operator|)
return|;
block|}
return|return
operator|(
name|pkt
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lio_droq_process_packets
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|struct
name|lio_droq
modifier|*
name|droq
parameter_list|,
name|uint32_t
name|budget
parameter_list|)
block|{
name|struct
name|lio_stailq_node
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|tmp2
decl_stmt|;
name|uint32_t
name|pkt_count
init|=
literal|0
decl_stmt|,
name|pkts_processed
init|=
literal|0
decl_stmt|;
comment|/* Grab the droq lock */
name|mtx_lock
argument_list|(
operator|&
name|droq
operator|->
name|lock
argument_list|)
expr_stmt|;
name|lio_droq_check_hw_for_pkts
argument_list|(
name|droq
argument_list|)
expr_stmt|;
name|pkt_count
operator|=
name|atomic_load_acq_int
argument_list|(
operator|&
name|droq
operator|->
name|pkts_pending
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pkt_count
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|droq
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|pkt_count
operator|>
name|budget
condition|)
name|pkt_count
operator|=
name|budget
expr_stmt|;
name|pkts_processed
operator|=
name|lio_droq_fast_process_packets
argument_list|(
name|oct
argument_list|,
name|droq
argument_list|,
name|pkt_count
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|droq
operator|->
name|pkts_pending
argument_list|,
name|pkts_processed
argument_list|)
expr_stmt|;
comment|/* Release the lock */
name|mtx_unlock
argument_list|(
operator|&
name|droq
operator|->
name|lock
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|tmp
argument_list|,
argument|&droq->dispatch_stq_head
argument_list|,
argument|entries
argument_list|,
argument|tmp2
argument_list|)
block|{
name|struct
name|__dispatch
modifier|*
name|rdisp
init|=
operator|(
expr|struct
name|__dispatch
operator|*
operator|)
name|tmp
decl_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|droq
operator|->
name|dispatch_stq_head
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|rdisp
operator|->
name|disp_fn
argument_list|(
name|rdisp
operator|->
name|rinfo
argument_list|,
name|lio_get_dispatch_arg
argument_list|(
name|oct
argument_list|,
operator|(
name|uint16_t
operator|)
name|rdisp
operator|->
name|rinfo
operator|->
name|recv_pkt
operator|->
name|rh
operator|.
name|r
operator|.
name|opcode
argument_list|,
operator|(
name|uint16_t
operator|)
name|rdisp
operator|->
name|rinfo
operator|->
name|recv_pkt
operator|->
name|rh
operator|.
name|r
operator|.
name|subcode
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If there are packets pending. schedule tasklet again */
if|if
condition|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|droq
operator|->
name|pkts_pending
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lio_register_droq_ops
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|uint32_t
name|q_no
parameter_list|,
name|struct
name|lio_droq_ops
modifier|*
name|ops
parameter_list|)
block|{
name|struct
name|lio_droq
modifier|*
name|droq
decl_stmt|;
name|struct
name|lio_config
modifier|*
name|lio_cfg
init|=
name|NULL
decl_stmt|;
name|lio_cfg
operator|=
name|lio_get_conf
argument_list|(
name|oct
argument_list|)
expr_stmt|;
if|if
condition|(
name|lio_cfg
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
name|EINVAL
operator|)
return|;
if|if
condition|(
name|ops
operator|==
name|NULL
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"%s: droq_ops pointer is NULL\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|q_no
operator|>=
name|LIO_GET_OQ_MAX_Q_CFG
argument_list|(
name|lio_cfg
argument_list|)
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"%s: droq id (%d) exceeds MAX (%d)\n"
argument_list|,
name|__func__
argument_list|,
name|q_no
argument_list|,
operator|(
name|oct
operator|->
name|num_oqs
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|EINVAL
operator|)
return|;
block|}
name|droq
operator|=
name|oct
operator|->
name|droq
index|[
name|q_no
index|]
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|droq
operator|->
name|lock
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|droq
operator|->
name|ops
argument_list|,
name|ops
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lio_droq_ops
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|droq
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lio_unregister_droq_ops
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|uint32_t
name|q_no
parameter_list|)
block|{
name|struct
name|lio_droq
modifier|*
name|droq
decl_stmt|;
name|struct
name|lio_config
modifier|*
name|lio_cfg
init|=
name|NULL
decl_stmt|;
name|lio_cfg
operator|=
name|lio_get_conf
argument_list|(
name|oct
argument_list|)
expr_stmt|;
if|if
condition|(
name|lio_cfg
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
name|EINVAL
operator|)
return|;
if|if
condition|(
name|q_no
operator|>=
name|LIO_GET_OQ_MAX_Q_CFG
argument_list|(
name|lio_cfg
argument_list|)
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"%s: droq id (%d) exceeds MAX (%d)\n"
argument_list|,
name|__func__
argument_list|,
name|q_no
argument_list|,
name|oct
operator|->
name|num_oqs
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|EINVAL
operator|)
return|;
block|}
name|droq
operator|=
name|oct
operator|->
name|droq
index|[
name|q_no
index|]
expr_stmt|;
if|if
condition|(
name|droq
operator|==
name|NULL
condition|)
block|{
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"Droq id (%d) not available.\n"
argument_list|,
name|q_no
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|droq
operator|->
name|lock
argument_list|)
expr_stmt|;
name|droq
operator|->
name|ops
operator|.
name|fptr
operator|=
name|NULL
expr_stmt|;
name|droq
operator|->
name|ops
operator|.
name|farg
operator|=
name|NULL
expr_stmt|;
name|droq
operator|->
name|ops
operator|.
name|drop_on_max
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|droq
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lio_create_droq
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|uint32_t
name|q_no
parameter_list|,
name|uint32_t
name|num_descs
parameter_list|,
name|uint32_t
name|desc_size
parameter_list|,
name|void
modifier|*
name|app_ctx
parameter_list|)
block|{
if|if
condition|(
name|oct
operator|->
name|droq
index|[
name|q_no
index|]
operator|->
name|oct_dev
operator|!=
name|NULL
condition|)
block|{
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"Droq already in use. Cannot create droq %d again\n"
argument_list|,
name|q_no
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Initialize the Droq */
if|if
condition|(
name|lio_init_droq
argument_list|(
name|oct
argument_list|,
name|q_no
argument_list|,
name|num_descs
argument_list|,
name|desc_size
argument_list|,
name|app_ctx
argument_list|)
condition|)
block|{
name|bzero
argument_list|(
name|oct
operator|->
name|droq
index|[
name|q_no
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lio_droq
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|create_droq_fail
goto|;
block|}
name|oct
operator|->
name|num_oqs
operator|++
expr_stmt|;
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"%s: Total number of OQ: %d\n"
argument_list|,
name|__func__
argument_list|,
name|oct
operator|->
name|num_oqs
argument_list|)
expr_stmt|;
comment|/* Global Droq register settings */
comment|/* 	 * As of now not required, as setting are done for all 32 Droqs at 	 * the same time. 	 */
return|return
operator|(
literal|0
operator|)
return|;
name|create_droq_fail
label|:
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
block|}
end_function

end_unit

