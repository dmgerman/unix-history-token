begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *   BSD LICENSE  *  *   Copyright(c) 2017 Cavium, Inc.. All rights reserved.  *   All rights reserved.  *  *   Redistribution and use in source and binary forms, with or without  *   modification, are permitted provided that the following conditions  *   are met:  *  *     * Redistributions of source code must retain the above copyright  *       notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above copyright  *       notice, this list of conditions and the following disclaimer in  *       the documentation and/or other materials provided with the  *       distribution.  *     * Neither the name of Cavium, Inc. nor the names of its  *       contributors may be used to endorse or promote products derived  *       from this software without specific prior written permission.  *  *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  *   OWNER(S) OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_comment
comment|/* \file  lio_network.h  * \brief Host NIC Driver: Structure and Macro definitions used by NIC Module.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__LIO_NETWORK_H__
end_ifndef

begin_define
define|#
directive|define
name|__LIO_NETWORK_H__
end_define

begin_include
include|#
directive|include
file|"lio_rss.h"
end_include

begin_define
define|#
directive|define
name|LIO_MIN_MTU_SIZE
value|72
end_define

begin_define
define|#
directive|define
name|LIO_MAX_MTU_SIZE
value|(LIO_MAX_FRM_SIZE - LIO_FRM_HEADER_SIZE)
end_define

begin_define
define|#
directive|define
name|LIO_MAX_SG
value|64
end_define

begin_define
define|#
directive|define
name|LIO_MAX_FRAME_SIZE
value|60000
end_define

begin_struct
struct|struct
name|lio_fw_stats_resp
block|{
name|uint64_t
name|rh
decl_stmt|;
name|struct
name|octeon_link_stats
name|stats
decl_stmt|;
name|uint64_t
name|status
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* LiquidIO per-interface network private data */
end_comment

begin_struct
struct|struct
name|lio
block|{
comment|/* State of the interface. Rx/Tx happens only in the RUNNING state.  */
name|int
name|ifstate
decl_stmt|;
comment|/* 	 * Octeon Interface index number. This device will be represented as 	 * oct<ifidx> in the system. 	 */
name|int
name|ifidx
decl_stmt|;
comment|/* Octeon Input queue to use to transmit for this network interface. */
name|int
name|txq
decl_stmt|;
comment|/* 	 * Octeon Output queue from which pkts arrive 	 * for this network interface. 	 */
name|int
name|rxq
decl_stmt|;
comment|/* Guards each glist */
name|struct
name|mtx
modifier|*
name|glist_lock
decl_stmt|;
define|#
directive|define
name|LIO_DEFAULT_STATS_INTERVAL
value|10000
comment|/* callout timer for stats */
name|struct
name|callout
name|stats_timer
decl_stmt|;
comment|/* Stats Update Interval in milli Seconds */
name|uint16_t
name|stats_interval
decl_stmt|;
comment|/* IRQ coalescing driver stats */
name|struct
name|octeon_intrmod_cfg
name|intrmod_cfg
decl_stmt|;
comment|/* Array of gather component linked lists */
name|struct
name|lio_stailq_head
modifier|*
name|ghead
decl_stmt|;
name|void
modifier|*
modifier|*
name|glists_virt_base
decl_stmt|;
name|vm_paddr_t
modifier|*
name|glists_dma_base
decl_stmt|;
name|uint32_t
name|glist_entry_size
decl_stmt|;
comment|/* Pointer to the octeon device structure. */
name|struct
name|octeon_device
modifier|*
name|oct_dev
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifmedia
name|ifmedia
decl_stmt|;
name|int
name|if_flags
decl_stmt|;
comment|/* Link information sent by the core application for this interface. */
name|struct
name|octeon_link_info
name|linfo
decl_stmt|;
comment|/* counter of link changes */
name|uint64_t
name|link_changes
decl_stmt|;
comment|/* Size of Tx queue for this octeon device. */
name|uint32_t
name|tx_qsize
decl_stmt|;
comment|/* Size of Rx queue for this octeon device. */
name|uint32_t
name|rx_qsize
decl_stmt|;
comment|/* Size of MTU this octeon device. */
name|uint32_t
name|mtu
decl_stmt|;
comment|/* msg level flag per interface. */
name|uint32_t
name|msg_enable
decl_stmt|;
comment|/* Interface info */
name|uint32_t
name|intf_open
decl_stmt|;
comment|/* task queue for  rx oom status */
name|struct
name|lio_tq
name|rx_status_tq
decl_stmt|;
comment|/* VLAN Filtering related */
name|eventhandler_tag
name|vlan_attach
decl_stmt|;
name|eventhandler_tag
name|vlan_detach
decl_stmt|;
ifdef|#
directive|ifdef
name|RSS
name|struct
name|lio_rss_params_set
name|rss_set
decl_stmt|;
endif|#
directive|endif
comment|/* RSS */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|LIO_MAX_CORES
value|12
end_define

begin_comment
comment|/*  * \brief Enable or disable feature  * @param ifp       pointer to network device  * @param cmd       Command that just requires acknowledgment  * @param param1    Parameter to command  */
end_comment

begin_function_decl
name|int
name|lio_set_feature
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|cmd
parameter_list|,
name|uint16_t
name|param1
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * \brief Link control command completion callback  * @param nctrl_ptr pointer to control packet structure  *  * This routine is called by the callback function when a ctrl pkt sent to  * core app completes. The nctrl_ptr contains a copy of the command type  * and data sent to the core app. This routine is only called if the ctrl  * pkt was sent successfully to the core app.  */
end_comment

begin_function_decl
name|void
name|lio_ctrl_cmd_completion
parameter_list|(
name|void
modifier|*
name|nctrl_ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|lio_setup_io_queues
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|octeon_dev
parameter_list|,
name|int
name|ifidx
parameter_list|,
name|uint32_t
name|num_iqs
parameter_list|,
name|uint32_t
name|num_oqs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|lio_setup_interrupt
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|uint32_t
name|num_ioqs
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|lio_recv_buffer_alloc
parameter_list|(
name|uint32_t
name|size
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mb
init|=
name|NULL
decl_stmt|;
name|mb
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb
operator|!=
name|NULL
condition|)
name|mb
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|mb
operator|->
name|m_len
operator|=
name|size
expr_stmt|;
return|return
operator|(
operator|(
name|void
operator|*
operator|)
name|mb
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|lio_recv_buffer_free
parameter_list|(
name|void
modifier|*
name|buffer
parameter_list|)
block|{
name|m_freem
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|lio_get_order
parameter_list|(
name|unsigned
name|long
name|size
parameter_list|)
block|{
name|int
name|order
decl_stmt|;
name|size
operator|=
operator|(
name|size
operator|-
literal|1
operator|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|order
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|size
condition|)
block|{
name|order
operator|++
expr_stmt|;
name|size
operator|>>=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|order
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|lio_dma_alloc
parameter_list|(
name|size_t
name|size
parameter_list|,
name|vm_paddr_t
modifier|*
name|dma_handle
parameter_list|)
block|{
name|size_t
name|align
decl_stmt|;
name|void
modifier|*
name|mem
decl_stmt|;
name|align
operator|=
name|PAGE_SIZE
operator|<<
name|lio_get_order
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|mem
operator|=
operator|(
name|void
operator|*
operator|)
name|kmem_alloc_contig
argument_list|(
name|kmem_arena
argument_list|,
name|size
argument_list|,
name|M_WAITOK
argument_list|,
literal|0
argument_list|,
operator|~
literal|0ul
argument_list|,
name|align
argument_list|,
literal|0
argument_list|,
name|VM_MEMATTR_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|!=
name|NULL
condition|)
operator|*
name|dma_handle
operator|=
name|vtophys
argument_list|(
name|mem
argument_list|)
expr_stmt|;
else|else
operator|*
name|dma_handle
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|mem
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|lio_dma_free
parameter_list|(
name|size_t
name|size
parameter_list|,
name|void
modifier|*
name|cpu_addr
parameter_list|)
block|{
name|kmem_free
argument_list|(
name|kmem_arena
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|cpu_addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|lio_map_ring
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|uint32_t
name|size
parameter_list|)
block|{
name|vm_paddr_t
name|dma_addr
decl_stmt|;
name|dma_addr
operator|=
name|vtophys
argument_list|(
operator|(
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|buf
operator|)
operator|->
name|m_data
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|uint64_t
operator|)
name|dma_addr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * \brief check interface state  * @param lio per-network private data  * @param state_flag flag state to check  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|lio_ifstate_check
parameter_list|(
name|struct
name|lio
modifier|*
name|lio
parameter_list|,
name|int
name|state_flag
parameter_list|)
block|{
return|return
operator|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|lio
operator|->
name|ifstate
argument_list|)
operator|&
name|state_flag
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * \brief set interface state  * @param lio per-network private data  * @param state_flag flag state to set  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|lio_ifstate_set
parameter_list|(
name|struct
name|lio
modifier|*
name|lio
parameter_list|,
name|int
name|state_flag
parameter_list|)
block|{
name|atomic_store_rel_int
argument_list|(
operator|&
name|lio
operator|->
name|ifstate
argument_list|,
operator|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|lio
operator|->
name|ifstate
argument_list|)
operator||
name|state_flag
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * \brief clear interface state  * @param lio per-network private data  * @param state_flag flag state to clear  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|lio_ifstate_reset
parameter_list|(
name|struct
name|lio
modifier|*
name|lio
parameter_list|,
name|int
name|state_flag
parameter_list|)
block|{
name|atomic_store_rel_int
argument_list|(
operator|&
name|lio
operator|->
name|ifstate
argument_list|,
operator|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|lio
operator|->
name|ifstate
argument_list|)
operator|&
operator|~
operator|(
name|state_flag
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * \brief wait for all pending requests to complete  * @param oct Pointer to Octeon device  *  * Called during shutdown sequence  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|lio_wait_for_pending_requests
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|pcount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|pcount
operator|=
name|atomic_load_acq_int
argument_list|(
operator|&
name|oct
operator|->
name|response_list
index|[
name|LIO_ORDERED_SC_LIST
index|]
operator|.
name|pending_req_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcount
condition|)
name|lio_sleep_timeout
argument_list|(
literal|100
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|pcount
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __LIO_NETWORK_H__ */
end_comment

end_unit

