begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *   BSD LICENSE  *  *   Copyright(c) 2017 Cavium, Inc.. All rights reserved.  *   All rights reserved.  *  *   Redistribution and use in source and binary forms, with or without  *   modification, are permitted provided that the following conditions  *   are met:  *  *     * Redistributions of source code must retain the above copyright  *       notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above copyright  *       notice, this list of conditions and the following disclaimer in  *       the documentation and/or other materials provided with the  *       distribution.  *     * Neither the name of Cavium, Inc. nor the names of its  *       contributors may be used to endorse or promote products derived  *       from this software without specific prior written permission.  *  *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  *   OWNER(S) OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"lio_bsd.h"
end_include

begin_include
include|#
directive|include
file|"lio_common.h"
end_include

begin_include
include|#
directive|include
file|"lio_droq.h"
end_include

begin_include
include|#
directive|include
file|"lio_iq.h"
end_include

begin_include
include|#
directive|include
file|"lio_response_manager.h"
end_include

begin_include
include|#
directive|include
file|"lio_device.h"
end_include

begin_include
include|#
directive|include
file|"lio_ctrl.h"
end_include

begin_include
include|#
directive|include
file|"lio_main.h"
end_include

begin_include
include|#
directive|include
file|"lio_network.h"
end_include

begin_include
include|#
directive|include
file|"cn23xx_pf_device.h"
end_include

begin_include
include|#
directive|include
file|"lio_image.h"
end_include

begin_include
include|#
directive|include
file|"lio_ioctl.h"
end_include

begin_include
include|#
directive|include
file|"lio_rxtx.h"
end_include

begin_include
include|#
directive|include
file|"lio_rss.h"
end_include

begin_comment
comment|/* Number of milliseconds to wait for DDR initialization */
end_comment

begin_define
define|#
directive|define
name|LIO_DDR_TIMEOUT
value|10000
end_define

begin_define
define|#
directive|define
name|LIO_MAX_FW_TYPE_LEN
value|8
end_define

begin_decl_stmt
specifier|static
name|char
name|fw_type
index|[
name|LIO_MAX_FW_TYPE_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_STR
argument_list|(
literal|"hw.lio.fw_type"
argument_list|,
name|fw_type
argument_list|,
sizeof|sizeof
argument_list|(
name|fw_type
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Integers that specify number of queues per PF.  * Valid range is 0 to 64.  * Use 0 to derive from CPU count.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_queues_per_pf0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_queues_per_pf1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.lio.num_queues_per_pf0"
argument_list|,
operator|&
name|num_queues_per_pf0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.lio.num_queues_per_pf1"
argument_list|,
operator|&
name|num_queues_per_pf1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|RSS
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|lio_rss
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.lio.rss"
argument_list|,
operator|&
name|lio_rss
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RSS */
end_comment

begin_comment
comment|/* Hardware LRO */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|lio_hwlro
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.lio.hwlro"
argument_list|,
operator|&
name|lio_hwlro
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Bitmask indicating which consoles have debug  * output redirected to syslog.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|console_bitmask
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_ULONG
argument_list|(
literal|"hw.lio.console_bitmask"
argument_list|,
operator|&
name|console_bitmask
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * \brief determines if a given console has debug enabled.  * @param console console to check  * @returns  1 = enabled. 0 otherwise  */
end_comment

begin_function
name|int
name|lio_console_debug_enabled
parameter_list|(
name|uint32_t
name|console
parameter_list|)
block|{
return|return
operator|(
name|console_bitmask
operator|>>
operator|(
name|console
operator|)
operator|)
operator|&
literal|0x1
return|;
block|}
end_function

begin_function_decl
specifier|static
name|int
name|lio_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lio_device_init
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|octeon_dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lio_chip_specific_setup
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lio_watchdog
parameter_list|(
name|void
modifier|*
name|param
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lio_load_firmware
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lio_nic_starter
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lio_init_nic_module
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lio_setup_nic_devices
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|octeon_dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lio_link_info
parameter_list|(
name|struct
name|lio_recv_info
modifier|*
name|recv_info
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lio_if_cfg_callback
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|uint32_t
name|status
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lio_set_rxcsum_command
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|command
parameter_list|,
name|uint8_t
name|rx_cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lio_setup_glists
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|struct
name|lio
modifier|*
name|lio
parameter_list|,
name|int
name|num_iqs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lio_destroy_nic_device
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|int
name|ifidx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|lio_update_link_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|union
name|octeon_link_status
modifier|*
name|ls
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lio_send_rx_ctrl_cmd
parameter_list|(
name|struct
name|lio
modifier|*
name|lio
parameter_list|,
name|int
name|start_stop
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lio_stop_nic_module
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lio_destroy_resources
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lio_setup_rx_oom_poll_fn
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lio_vlan_rx_add_vid
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|uint16_t
name|vid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lio_vlan_rx_kill_vid
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|uint16_t
name|vid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|octeon_device
modifier|*
name|lio_get_other_octeon_device
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lio_wait_for_oq_pkts
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|lio_send_rss_param
parameter_list|(
name|struct
name|lio
modifier|*
name|lio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lio_dbg_console_print
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|uint32_t
name|console_num
parameter_list|,
name|char
modifier|*
name|prefix
parameter_list|,
name|char
modifier|*
name|suffix
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Polling interval for determining when NIC application is alive */
end_comment

begin_define
define|#
directive|define
name|LIO_STARTER_POLL_INTERVAL_MS
value|100
end_define

begin_comment
comment|/*  * vendor_info_array.  * This array contains the list of IDs on which the driver should load.  */
end_comment

begin_struct
struct|struct
name|lio_vendor_info
block|{
name|uint16_t
name|vendor_id
decl_stmt|;
name|uint16_t
name|device_id
decl_stmt|;
name|uint16_t
name|subdevice_id
decl_stmt|;
name|uint8_t
name|revision_id
decl_stmt|;
name|uint8_t
name|index
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|lio_vendor_info
name|lio_pci_tbl
index|[]
init|=
block|{
comment|/* CN2350 10G */
block|{
name|PCI_VENDOR_ID_CAVIUM
block|,
name|LIO_CN23XX_PF_VID
block|,
name|LIO_CN2350_10G_SUBDEVICE
block|,
literal|0x02
block|,
literal|0
block|}
block|,
comment|/* CN2350 10G */
block|{
name|PCI_VENDOR_ID_CAVIUM
block|,
name|LIO_CN23XX_PF_VID
block|,
name|LIO_CN2350_10G_SUBDEVICE1
block|,
literal|0x02
block|,
literal|0
block|}
block|,
comment|/* CN2360 10G */
block|{
name|PCI_VENDOR_ID_CAVIUM
block|,
name|LIO_CN23XX_PF_VID
block|,
name|LIO_CN2360_10G_SUBDEVICE
block|,
literal|0x02
block|,
literal|1
block|}
block|,
comment|/* CN2350 25G */
block|{
name|PCI_VENDOR_ID_CAVIUM
block|,
name|LIO_CN23XX_PF_VID
block|,
name|LIO_CN2350_25G_SUBDEVICE
block|,
literal|0x02
block|,
literal|2
block|}
block|,
comment|/* CN2360 25G */
block|{
name|PCI_VENDOR_ID_CAVIUM
block|,
name|LIO_CN23XX_PF_VID
block|,
name|LIO_CN2360_25G_SUBDEVICE
block|,
literal|0x02
block|,
literal|3
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lio_strings
index|[]
init|=
block|{
literal|"LiquidIO 2350 10GbE Server Adapter"
block|,
literal|"LiquidIO 2360 10GbE Server Adapter"
block|,
literal|"LiquidIO 2350 25GbE Server Adapter"
block|,
literal|"LiquidIO 2360 25GbE Server Adapter"
block|, }
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|lio_if_cfg_resp
block|{
name|uint64_t
name|rh
decl_stmt|;
name|struct
name|octeon_if_cfg_info
name|cfg_info
decl_stmt|;
name|uint64_t
name|status
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|lio_if_cfg_context
block|{
name|int
name|octeon_id
decl_stmt|;
specifier|volatile
name|int
name|cond
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|lio_rx_ctl_context
block|{
name|int
name|octeon_id
decl_stmt|;
specifier|volatile
name|int
name|cond
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|lio_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|lio_vendor_info
modifier|*
name|tbl
decl_stmt|;
name|uint16_t
name|vendor_id
decl_stmt|;
name|uint16_t
name|device_id
decl_stmt|;
name|uint16_t
name|subdevice_id
decl_stmt|;
name|uint8_t
name|revision_id
decl_stmt|;
name|char
name|device_ver
index|[
literal|256
index|]
decl_stmt|;
name|vendor_id
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|vendor_id
operator|!=
name|PCI_VENDOR_ID_CAVIUM
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_id
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|subdevice_id
operator|=
name|pci_get_subdevice
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|revision_id
operator|=
name|pci_get_revid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|tbl
operator|=
name|lio_pci_tbl
expr_stmt|;
while|while
condition|(
name|tbl
operator|->
name|vendor_id
condition|)
block|{
if|if
condition|(
operator|(
name|vendor_id
operator|==
name|tbl
operator|->
name|vendor_id
operator|)
operator|&&
operator|(
name|device_id
operator|==
name|tbl
operator|->
name|device_id
operator|)
operator|&&
operator|(
name|subdevice_id
operator|==
name|tbl
operator|->
name|subdevice_id
operator|)
operator|&&
operator|(
name|revision_id
operator|==
name|tbl
operator|->
name|revision_id
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|device_ver
argument_list|,
literal|"%s, Version - %s"
argument_list|,
name|lio_strings
index|[
name|tbl
operator|->
name|index
index|]
argument_list|,
name|LIO_VERSION
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|device_ver
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
name|tbl
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lio_attach
parameter_list|(
name|device_t
name|device
parameter_list|)
block|{
name|struct
name|octeon_device
modifier|*
name|oct_dev
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|scratch1
decl_stmt|;
name|uint32_t
name|error
decl_stmt|;
name|int
name|timeout
decl_stmt|,
name|ret
init|=
literal|1
decl_stmt|;
name|uint8_t
name|bus
decl_stmt|,
name|dev
decl_stmt|,
name|function
decl_stmt|;
name|oct_dev
operator|=
name|lio_allocate_device
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|oct_dev
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|device
argument_list|,
literal|"Error: Unable to allocate device\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
block|}
name|oct_dev
operator|->
name|tx_budget
operator|=
name|LIO_DEFAULT_TX_PKTS_PROCESS_BUDGET
expr_stmt|;
name|oct_dev
operator|->
name|rx_budget
operator|=
name|LIO_DEFAULT_RX_PKTS_PROCESS_BUDGET
expr_stmt|;
name|oct_dev
operator|->
name|msix_on
operator|=
name|LIO_FLAG_MSIX_ENABLED
expr_stmt|;
name|oct_dev
operator|->
name|device
operator|=
name|device
expr_stmt|;
name|bus
operator|=
name|pci_get_bus
argument_list|(
name|device
argument_list|)
expr_stmt|;
name|dev
operator|=
name|pci_get_slot
argument_list|(
name|device
argument_list|)
expr_stmt|;
name|function
operator|=
name|pci_get_function
argument_list|(
name|device
argument_list|)
expr_stmt|;
name|lio_dev_info
argument_list|(
name|oct_dev
argument_list|,
literal|"Initializing device %x:%x %02x:%02x.%01x\n"
argument_list|,
name|pci_get_vendor
argument_list|(
name|device
argument_list|)
argument_list|,
name|pci_get_device
argument_list|(
name|device
argument_list|)
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|lio_device_init
argument_list|(
name|oct_dev
argument_list|)
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct_dev
argument_list|,
literal|"Failed to init device\n"
argument_list|)
expr_stmt|;
name|lio_detach
argument_list|(
name|device
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
block|}
name|scratch1
operator|=
name|lio_read_csr64
argument_list|(
name|oct_dev
argument_list|,
name|LIO_CN23XX_SLI_SCRATCH1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|scratch1
operator|&
literal|4ULL
operator|)
condition|)
block|{
comment|/* 		 * Bit 2 of SLI_SCRATCH_1 is a flag that indicates that 		 * the lio watchdog kernel thread is running for this 		 * NIC.  Each NIC gets one watchdog kernel thread. 		 */
name|scratch1
operator||=
literal|4ULL
expr_stmt|;
name|lio_write_csr64
argument_list|(
name|oct_dev
argument_list|,
name|LIO_CN23XX_SLI_SCRATCH1
argument_list|,
name|scratch1
argument_list|)
expr_stmt|;
name|error
operator|=
name|kproc_create
argument_list|(
name|lio_watchdog
argument_list|,
name|oct_dev
argument_list|,
operator|&
name|oct_dev
operator|->
name|watchdog_task
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"liowd/%02hhx:%02hhx.%hhx"
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|kproc_resume
argument_list|(
name|oct_dev
operator|->
name|watchdog_task
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|oct_dev
operator|->
name|watchdog_task
operator|=
name|NULL
expr_stmt|;
name|lio_dev_err
argument_list|(
name|oct_dev
argument_list|,
literal|"failed to create kernel_thread\n"
argument_list|)
expr_stmt|;
name|lio_detach
argument_list|(
name|device
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|oct_dev
operator|->
name|rx_pause
operator|=
literal|1
expr_stmt|;
name|oct_dev
operator|->
name|tx_pause
operator|=
literal|1
expr_stmt|;
name|timeout
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|timeout
operator|<
name|LIO_NIC_STARTER_TIMEOUT
condition|)
block|{
name|lio_mdelay
argument_list|(
name|LIO_STARTER_POLL_INTERVAL_MS
argument_list|)
expr_stmt|;
name|timeout
operator|+=
name|LIO_STARTER_POLL_INTERVAL_MS
expr_stmt|;
comment|/* 		 * During the boot process interrupts are not available. 		 * So polling for first control message from FW. 		 */
if|if
condition|(
name|cold
condition|)
name|lio_droq_bh
argument_list|(
name|oct_dev
operator|->
name|droq
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|oct_dev
operator|->
name|status
argument_list|)
operator|==
name|LIO_DEV_CORE_OK
condition|)
block|{
name|ret
operator|=
name|lio_nic_starter
argument_list|(
name|oct_dev
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ret
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct_dev
argument_list|,
literal|"Firmware failed to start\n"
argument_list|)
expr_stmt|;
name|lio_detach
argument_list|(
name|device
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|EIO
operator|)
return|;
block|}
name|lio_dev_dbg
argument_list|(
name|oct_dev
argument_list|,
literal|"Device is ready\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lio_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|octeon_device
modifier|*
name|oct_dev
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|lio_dev_dbg
argument_list|(
name|oct_dev
argument_list|,
literal|"Stopping device\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|oct_dev
operator|->
name|watchdog_task
condition|)
block|{
name|uint64_t
name|scratch1
decl_stmt|;
name|kproc_suspend
argument_list|(
name|oct_dev
operator|->
name|watchdog_task
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|scratch1
operator|=
name|lio_read_csr64
argument_list|(
name|oct_dev
argument_list|,
name|LIO_CN23XX_SLI_SCRATCH1
argument_list|)
expr_stmt|;
name|scratch1
operator|&=
operator|~
literal|4ULL
expr_stmt|;
name|lio_write_csr64
argument_list|(
name|oct_dev
argument_list|,
name|LIO_CN23XX_SLI_SCRATCH1
argument_list|,
name|scratch1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oct_dev
operator|->
name|app_mode
operator|&&
operator|(
name|oct_dev
operator|->
name|app_mode
operator|==
name|LIO_DRV_NIC_APP
operator|)
condition|)
name|lio_stop_nic_module
argument_list|(
name|oct_dev
argument_list|)
expr_stmt|;
comment|/* 	 * Reset the octeon device and cleanup all memory allocated for 	 * the octeon device by  driver. 	 */
name|lio_destroy_resources
argument_list|(
name|oct_dev
argument_list|)
expr_stmt|;
name|lio_dev_info
argument_list|(
name|oct_dev
argument_list|,
literal|"Device removed\n"
argument_list|)
expr_stmt|;
comment|/* 	 * This octeon device has been removed. Update the global 	 * data structure to reflect this. Free the device structure. 	 */
name|lio_free_device_mem
argument_list|(
name|oct_dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lio_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|octeon_device
modifier|*
name|oct_dev
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|lio
modifier|*
name|lio
init|=
name|if_getsoftc
argument_list|(
name|oct_dev
operator|->
name|props
operator|.
name|ifp
argument_list|)
decl_stmt|;
name|lio_send_rx_ctrl_cmd
argument_list|(
name|lio
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lio_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lio_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lio_event
parameter_list|(
name|struct
name|module
modifier|*
name|mod
parameter_list|,
name|int
name|event
parameter_list|,
name|void
modifier|*
name|junk
parameter_list|)
block|{
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|lio_init_device_list
argument_list|(
name|LIO_CFG_TYPE_DEFAULT
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  FreeBSD Device Interface Entry Points  * *******************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|lio_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|lio_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|lio_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|lio_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|lio_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|lio_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|lio_resume
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|lio_driver
init|=
block|{
name|LIO_DRV_NAME
block|,
name|lio_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|octeon_device
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|devclass_t
name|lio_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|lio
argument_list|,
name|pci
argument_list|,
name|lio_driver
argument_list|,
name|lio_devclass
argument_list|,
name|lio_event
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|lio
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|lio
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|lio
argument_list|,
name|firmware
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|bool
name|fw_type_is_none
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|strncmp
argument_list|(
name|fw_type
argument_list|,
name|LIO_FW_NAME_TYPE_NONE
argument_list|,
sizeof|sizeof
argument_list|(
name|LIO_FW_NAME_TYPE_NONE
argument_list|)
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * \brief Device initialization for each Octeon device that is probed  * @param octeon_dev  octeon device  */
end_comment

begin_function
specifier|static
name|int
name|lio_device_init
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|octeon_dev
parameter_list|)
block|{
name|unsigned
name|long
name|ddr_timeout
init|=
name|LIO_DDR_TIMEOUT
decl_stmt|;
name|char
modifier|*
name|dbg_enb
init|=
name|NULL
decl_stmt|;
name|int
name|fw_loaded
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|ret
decl_stmt|;
name|uint8_t
name|bus
decl_stmt|,
name|dev
decl_stmt|,
name|function
decl_stmt|;
name|char
name|bootcmd
index|[]
init|=
literal|"\n"
decl_stmt|;
name|bus
operator|=
name|pci_get_bus
argument_list|(
name|octeon_dev
operator|->
name|device
argument_list|)
expr_stmt|;
name|dev
operator|=
name|pci_get_slot
argument_list|(
name|octeon_dev
operator|->
name|device
argument_list|)
expr_stmt|;
name|function
operator|=
name|pci_get_function
argument_list|(
name|octeon_dev
operator|->
name|device
argument_list|)
expr_stmt|;
name|atomic_store_rel_int
argument_list|(
operator|&
name|octeon_dev
operator|->
name|status
argument_list|,
name|LIO_DEV_BEGIN_STATE
argument_list|)
expr_stmt|;
comment|/* Enable access to the octeon device */
if|if
condition|(
name|pci_enable_busmaster
argument_list|(
name|octeon_dev
operator|->
name|device
argument_list|)
condition|)
block|{
name|lio_dev_err
argument_list|(
name|octeon_dev
argument_list|,
literal|"pci_enable_device failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|atomic_store_rel_int
argument_list|(
operator|&
name|octeon_dev
operator|->
name|status
argument_list|,
name|LIO_DEV_PCI_ENABLE_DONE
argument_list|)
expr_stmt|;
comment|/* Identify the Octeon type and map the BAR address space. */
if|if
condition|(
name|lio_chip_specific_setup
argument_list|(
name|octeon_dev
argument_list|)
condition|)
block|{
name|lio_dev_err
argument_list|(
name|octeon_dev
argument_list|,
literal|"Chip specific setup failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|atomic_store_rel_int
argument_list|(
operator|&
name|octeon_dev
operator|->
name|status
argument_list|,
name|LIO_DEV_PCI_MAP_DONE
argument_list|)
expr_stmt|;
comment|/* 	 * Only add a reference after setting status 'OCT_DEV_PCI_MAP_DONE', 	 * since that is what is required for the reference to be removed 	 * during de-initialization (see 'octeon_destroy_resources'). 	 */
name|lio_register_device
argument_list|(
name|octeon_dev
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|function
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|octeon_dev
operator|->
name|app_mode
operator|=
name|LIO_DRV_INVALID_APP
expr_stmt|;
if|if
condition|(
operator|!
name|lio_cn23xx_pf_fw_loaded
argument_list|(
name|octeon_dev
argument_list|)
operator|&&
operator|!
name|fw_type_is_none
argument_list|()
condition|)
block|{
name|fw_loaded
operator|=
literal|0
expr_stmt|;
comment|/* Do a soft reset of the Octeon device. */
if|if
condition|(
name|octeon_dev
operator|->
name|fn_list
operator|.
name|soft_reset
argument_list|(
name|octeon_dev
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* things might have changed */
if|if
condition|(
operator|!
name|lio_cn23xx_pf_fw_loaded
argument_list|(
name|octeon_dev
argument_list|)
condition|)
name|fw_loaded
operator|=
literal|0
expr_stmt|;
else|else
name|fw_loaded
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fw_loaded
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Initialize the dispatch mechanism used to push packets arriving on 	 * Octeon Output queues. 	 */
if|if
condition|(
name|lio_init_dispatch_list
argument_list|(
name|octeon_dev
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|lio_register_dispatch_fn
argument_list|(
name|octeon_dev
argument_list|,
name|LIO_OPCODE_NIC
argument_list|,
name|LIO_OPCODE_NIC_CORE_DRV_ACTIVE
argument_list|,
name|lio_core_drv_init
argument_list|,
name|octeon_dev
argument_list|)
expr_stmt|;
name|atomic_store_rel_int
argument_list|(
operator|&
name|octeon_dev
operator|->
name|status
argument_list|,
name|LIO_DEV_DISPATCH_INIT_DONE
argument_list|)
expr_stmt|;
name|ret
operator|=
name|octeon_dev
operator|->
name|fn_list
operator|.
name|setup_device_regs
argument_list|(
name|octeon_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|lio_dev_err
argument_list|(
name|octeon_dev
argument_list|,
literal|"Failed to configure device registers\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* Initialize soft command buffer pool */
if|if
condition|(
name|lio_setup_sc_buffer_pool
argument_list|(
name|octeon_dev
argument_list|)
condition|)
block|{
name|lio_dev_err
argument_list|(
name|octeon_dev
argument_list|,
literal|"sc buffer pool allocation failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|atomic_store_rel_int
argument_list|(
operator|&
name|octeon_dev
operator|->
name|status
argument_list|,
name|LIO_DEV_SC_BUFF_POOL_INIT_DONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|lio_allocate_ioq_vector
argument_list|(
name|octeon_dev
argument_list|)
condition|)
block|{
name|lio_dev_err
argument_list|(
name|octeon_dev
argument_list|,
literal|"IOQ vector allocation failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|atomic_store_rel_int
argument_list|(
operator|&
name|octeon_dev
operator|->
name|status
argument_list|,
name|LIO_DEV_MSIX_ALLOC_VECTOR_DONE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LIO_MAX_POSSIBLE_INSTR_QUEUES
condition|;
name|i
operator|++
control|)
block|{
name|octeon_dev
operator|->
name|instr_queue
index|[
name|i
index|]
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lio_instr_queue
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|octeon_dev
operator|->
name|instr_queue
index|[
name|i
index|]
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Setup the data structures that manage this Octeon's Input queues. */
if|if
condition|(
name|lio_setup_instr_queue0
argument_list|(
name|octeon_dev
argument_list|)
condition|)
block|{
name|lio_dev_err
argument_list|(
name|octeon_dev
argument_list|,
literal|"Instruction queue initialization failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|atomic_store_rel_int
argument_list|(
operator|&
name|octeon_dev
operator|->
name|status
argument_list|,
name|LIO_DEV_INSTR_QUEUE_INIT_DONE
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize lists to manage the requests of different types that 	 * arrive from user& kernel applications for this octeon device. 	 */
if|if
condition|(
name|lio_setup_response_list
argument_list|(
name|octeon_dev
argument_list|)
condition|)
block|{
name|lio_dev_err
argument_list|(
name|octeon_dev
argument_list|,
literal|"Response list allocation failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|atomic_store_rel_int
argument_list|(
operator|&
name|octeon_dev
operator|->
name|status
argument_list|,
name|LIO_DEV_RESP_LIST_INIT_DONE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LIO_MAX_POSSIBLE_OUTPUT_QUEUES
condition|;
name|i
operator|++
control|)
block|{
name|octeon_dev
operator|->
name|droq
index|[
name|i
index|]
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|octeon_dev
operator|->
name|droq
index|[
name|i
index|]
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|octeon_dev
operator|->
name|droq
index|[
name|i
index|]
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|lio_setup_output_queue0
argument_list|(
name|octeon_dev
argument_list|)
condition|)
block|{
name|lio_dev_err
argument_list|(
name|octeon_dev
argument_list|,
literal|"Output queue initialization failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|atomic_store_rel_int
argument_list|(
operator|&
name|octeon_dev
operator|->
name|status
argument_list|,
name|LIO_DEV_DROQ_INIT_DONE
argument_list|)
expr_stmt|;
comment|/* 	 * Setup the interrupt handler and record the INT SUM register address 	 */
if|if
condition|(
name|lio_setup_interrupt
argument_list|(
name|octeon_dev
argument_list|,
name|octeon_dev
operator|->
name|sriov_info
operator|.
name|num_pf_rings
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Enable Octeon device interrupts */
name|octeon_dev
operator|->
name|fn_list
operator|.
name|enable_interrupt
argument_list|(
name|octeon_dev
argument_list|,
name|OCTEON_ALL_INTR
argument_list|)
expr_stmt|;
name|atomic_store_rel_int
argument_list|(
operator|&
name|octeon_dev
operator|->
name|status
argument_list|,
name|LIO_DEV_INTR_SET_DONE
argument_list|)
expr_stmt|;
comment|/* 	 * Send Credit for Octeon Output queues. Credits are always sent BEFORE 	 * the output queue is enabled. 	 * This ensures that we'll receive the f/w CORE DRV_ACTIVE message in 	 * case we've configured CN23XX_SLI_GBL_CONTROL[NOPTR_D] = 0. 	 * Otherwise, it is possible that the DRV_ACTIVE message will be sent 	 * before any credits have been issued, causing the ring to be reset 	 * (and the f/w appear to never have started). 	 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|octeon_dev
operator|->
name|num_oqs
condition|;
name|j
operator|++
control|)
name|lio_write_csr32
argument_list|(
name|octeon_dev
argument_list|,
name|octeon_dev
operator|->
name|droq
index|[
name|j
index|]
operator|->
name|pkts_credit_reg
argument_list|,
name|octeon_dev
operator|->
name|droq
index|[
name|j
index|]
operator|->
name|max_count
argument_list|)
expr_stmt|;
comment|/* Enable the input and output queues for this Octeon device */
name|ret
operator|=
name|octeon_dev
operator|->
name|fn_list
operator|.
name|enable_io_queues
argument_list|(
name|octeon_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|lio_dev_err
argument_list|(
name|octeon_dev
argument_list|,
literal|"Failed to enable input/output queues"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|atomic_store_rel_int
argument_list|(
operator|&
name|octeon_dev
operator|->
name|status
argument_list|,
name|LIO_DEV_IO_QUEUES_DONE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fw_loaded
condition|)
block|{
name|lio_dev_dbg
argument_list|(
name|octeon_dev
argument_list|,
literal|"Waiting for DDR initialization...\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ddr_timeout
condition|)
block|{
name|lio_dev_info
argument_list|(
name|octeon_dev
argument_list|,
literal|"WAITING. Set ddr_timeout to non-zero value to proceed with initialization.\n"
argument_list|)
expr_stmt|;
block|}
name|lio_sleep_timeout
argument_list|(
name|LIO_RESET_MSECS
argument_list|)
expr_stmt|;
comment|/* 		 * Wait for the octeon to initialize DDR after the 		 * soft-reset. 		 */
while|while
condition|(
operator|!
name|ddr_timeout
condition|)
block|{
if|if
condition|(
name|pause
argument_list|(
literal|"-"
argument_list|,
name|lio_ms_to_ticks
argument_list|(
literal|100
argument_list|)
argument_list|)
condition|)
block|{
comment|/* user probably pressed Control-C */
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|ret
operator|=
name|lio_wait_for_ddr_init
argument_list|(
name|octeon_dev
argument_list|,
operator|&
name|ddr_timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|lio_dev_err
argument_list|(
name|octeon_dev
argument_list|,
literal|"DDR not initialized. Please confirm that board is configured to boot from Flash, ret: %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|lio_wait_for_bootloader
argument_list|(
name|octeon_dev
argument_list|,
literal|1100
argument_list|)
condition|)
block|{
name|lio_dev_err
argument_list|(
name|octeon_dev
argument_list|,
literal|"Board not responding\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Divert uboot to take commands from host instead. */
name|ret
operator|=
name|lio_console_send_cmd
argument_list|(
name|octeon_dev
argument_list|,
name|bootcmd
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|lio_dev_dbg
argument_list|(
name|octeon_dev
argument_list|,
literal|"Initializing consoles\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|lio_init_consoles
argument_list|(
name|octeon_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|lio_dev_err
argument_list|(
name|octeon_dev
argument_list|,
literal|"Could not access board consoles\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 		 * If console debug enabled, specify empty string to 		 * use default enablement ELSE specify NULL string for 		 * 'disabled'. 		 */
name|dbg_enb
operator|=
name|lio_console_debug_enabled
argument_list|(
literal|0
argument_list|)
condition|?
literal|""
else|:
name|NULL
expr_stmt|;
name|ret
operator|=
name|lio_add_console
argument_list|(
name|octeon_dev
argument_list|,
literal|0
argument_list|,
name|dbg_enb
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|lio_dev_err
argument_list|(
name|octeon_dev
argument_list|,
literal|"Could not access board console\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|lio_console_debug_enabled
argument_list|(
literal|0
argument_list|)
condition|)
block|{
comment|/* 			 * If console was added AND we're logging console output 			 * then set our console print function. 			 */
name|octeon_dev
operator|->
name|console
index|[
literal|0
index|]
operator|.
name|print
operator|=
name|lio_dbg_console_print
expr_stmt|;
block|}
name|atomic_store_rel_int
argument_list|(
operator|&
name|octeon_dev
operator|->
name|status
argument_list|,
name|LIO_DEV_CONSOLE_INIT_DONE
argument_list|)
expr_stmt|;
name|lio_dev_dbg
argument_list|(
name|octeon_dev
argument_list|,
literal|"Loading firmware\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|lio_load_firmware
argument_list|(
name|octeon_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|lio_dev_err
argument_list|(
name|octeon_dev
argument_list|,
literal|"Could not load firmware to board\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|atomic_store_rel_int
argument_list|(
operator|&
name|octeon_dev
operator|->
name|status
argument_list|,
name|LIO_DEV_HOST_OK
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * \brief PCI FLR for each Octeon device.  * @param oct octeon device  */
end_comment

begin_function
specifier|static
name|void
name|lio_pci_flr
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
name|uint32_t
name|exppos
decl_stmt|,
name|status
decl_stmt|;
name|pci_find_cap
argument_list|(
name|oct
operator|->
name|device
argument_list|,
name|PCIY_EXPRESS
argument_list|,
operator|&
name|exppos
argument_list|)
expr_stmt|;
name|pci_save_state
argument_list|(
name|oct
operator|->
name|device
argument_list|)
expr_stmt|;
comment|/* Quiesce the device completely */
name|pci_write_config
argument_list|(
name|oct
operator|->
name|device
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|PCIM_CMD_INTxDIS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Wait for Transaction Pending bit clean */
name|lio_mdelay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|status
operator|=
name|pci_read_config
argument_list|(
name|oct
operator|->
name|device
argument_list|,
name|exppos
operator|+
name|PCIER_DEVICE_STA
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|PCIEM_STA_TRANSACTION_PND
condition|)
block|{
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"Function reset incomplete after 100ms, sleeping for 5 seconds\n"
argument_list|)
expr_stmt|;
name|lio_mdelay
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|status
operator|=
name|pci_read_config
argument_list|(
name|oct
operator|->
name|device
argument_list|,
name|exppos
operator|+
name|PCIER_DEVICE_STA
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|PCIEM_STA_TRANSACTION_PND
condition|)
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"Function reset still incomplete after 5s, reset anyway\n"
argument_list|)
expr_stmt|;
block|}
name|pci_write_config
argument_list|(
name|oct
operator|->
name|device
argument_list|,
name|exppos
operator|+
name|PCIER_DEVICE_CTL
argument_list|,
name|PCIEM_CTL_INITIATE_FLR
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|lio_mdelay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|pci_restore_state
argument_list|(
name|oct
operator|->
name|device
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * \brief Debug console print function  * @param octeon_dev  octeon device  * @param console_num console number  * @param prefix      first portion of line to display  * @param suffix      second portion of line to display  *  * The OCTEON debug console outputs entire lines (excluding '\n').  * Normally, the line will be passed in the 'prefix' parameter.  * However, due to buffering, it is possible for a line to be split into two  * parts, in which case they will be passed as the 'prefix' parameter and  * 'suffix' parameter.  */
end_comment

begin_function
specifier|static
name|int
name|lio_dbg_console_print
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|uint32_t
name|console_num
parameter_list|,
name|char
modifier|*
name|prefix
parameter_list|,
name|char
modifier|*
name|suffix
parameter_list|)
block|{
if|if
condition|(
name|prefix
operator|!=
name|NULL
operator|&&
name|suffix
operator|!=
name|NULL
condition|)
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"%u: %s%s\n"
argument_list|,
name|console_num
argument_list|,
name|prefix
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|prefix
operator|!=
name|NULL
condition|)
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"%u: %s\n"
argument_list|,
name|console_num
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|suffix
operator|!=
name|NULL
condition|)
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"%u: %s\n"
argument_list|,
name|console_num
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lio_watchdog
parameter_list|(
name|void
modifier|*
name|param
parameter_list|)
block|{
name|int
name|core_num
decl_stmt|;
name|uint16_t
name|mask_of_crashed_or_stuck_cores
init|=
literal|0
decl_stmt|;
name|struct
name|octeon_device
modifier|*
name|oct
init|=
name|param
decl_stmt|;
name|bool
name|err_msg_was_printed
index|[
literal|12
index|]
decl_stmt|;
name|bzero
argument_list|(
name|err_msg_was_printed
argument_list|,
sizeof|sizeof
argument_list|(
name|err_msg_was_printed
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|kproc_suspend_check
argument_list|(
name|oct
operator|->
name|watchdog_task
argument_list|)
expr_stmt|;
name|mask_of_crashed_or_stuck_cores
operator|=
operator|(
name|uint16_t
operator|)
name|lio_read_csr64
argument_list|(
name|oct
argument_list|,
name|LIO_CN23XX_SLI_SCRATCH2
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask_of_crashed_or_stuck_cores
condition|)
block|{
name|struct
name|octeon_device
modifier|*
name|other_oct
decl_stmt|;
name|oct
operator|->
name|cores_crashed
operator|=
name|true
expr_stmt|;
name|other_oct
operator|=
name|lio_get_other_octeon_device
argument_list|(
name|oct
argument_list|)
expr_stmt|;
if|if
condition|(
name|other_oct
operator|!=
name|NULL
condition|)
name|other_oct
operator|->
name|cores_crashed
operator|=
name|true
expr_stmt|;
for|for
control|(
name|core_num
operator|=
literal|0
init|;
name|core_num
operator|<
name|LIO_MAX_CORES
condition|;
name|core_num
operator|++
control|)
block|{
name|bool
name|core_crashed_or_got_stuck
decl_stmt|;
name|core_crashed_or_got_stuck
operator|=
operator|(
name|mask_of_crashed_or_stuck_cores
operator|>>
name|core_num
operator|)
operator|&
literal|1
expr_stmt|;
if|if
condition|(
name|core_crashed_or_got_stuck
operator|&&
operator|!
name|err_msg_was_printed
index|[
name|core_num
index|]
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"ERROR: Octeon core %d crashed or got stuck! See oct-fwdump for details.\n"
argument_list|,
name|core_num
argument_list|)
expr_stmt|;
name|err_msg_was_printed
index|[
name|core_num
index|]
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
comment|/* sleep for two seconds */
name|pause
argument_list|(
literal|"-"
argument_list|,
name|lio_ms_to_ticks
argument_list|(
literal|2000
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|lio_chip_specific_setup
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|uint32_t
name|dev_id
decl_stmt|,
name|rev_id
decl_stmt|;
name|int
name|ret
init|=
literal|1
decl_stmt|;
name|dev_id
operator|=
name|lio_read_pci_cfg
argument_list|(
name|oct
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rev_id
operator|=
name|pci_get_revid
argument_list|(
name|oct
operator|->
name|device
argument_list|)
expr_stmt|;
name|oct
operator|->
name|subdevice_id
operator|=
name|pci_get_subdevice
argument_list|(
name|oct
operator|->
name|device
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dev_id
condition|)
block|{
case|case
name|LIO_CN23XX_PF_PCIID
case|:
name|oct
operator|->
name|chip_id
operator|=
name|LIO_CN23XX_PF_VID
expr_stmt|;
if|if
condition|(
name|pci_get_function
argument_list|(
name|oct
operator|->
name|device
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|num_queues_per_pf0
operator|<
literal|0
condition|)
block|{
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"Invalid num_queues_per_pf0: %d, Setting it to default\n"
argument_list|,
name|num_queues_per_pf0
argument_list|)
expr_stmt|;
name|num_queues_per_pf0
operator|=
literal|0
expr_stmt|;
block|}
name|oct
operator|->
name|sriov_info
operator|.
name|num_pf_rings
operator|=
name|num_queues_per_pf0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|num_queues_per_pf1
operator|<
literal|0
condition|)
block|{
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"Invalid num_queues_per_pf1: %d, Setting it to default\n"
argument_list|,
name|num_queues_per_pf1
argument_list|)
expr_stmt|;
name|num_queues_per_pf1
operator|=
literal|0
expr_stmt|;
block|}
name|oct
operator|->
name|sriov_info
operator|.
name|num_pf_rings
operator|=
name|num_queues_per_pf1
expr_stmt|;
block|}
name|ret
operator|=
name|lio_cn23xx_pf_setup_device
argument_list|(
name|oct
argument_list|)
expr_stmt|;
name|s
operator|=
literal|"CN23XX"
expr_stmt|;
break|break;
default|default:
name|s
operator|=
literal|"?"
expr_stmt|;
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Unknown device found (dev_id: %x)\n"
argument_list|,
name|dev_id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ret
condition|)
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"%s PASS%d.%d %s Version: %s\n"
argument_list|,
name|s
argument_list|,
name|OCTEON_MAJOR_REV
argument_list|(
name|oct
argument_list|)
argument_list|,
name|OCTEON_MINOR_REV
argument_list|(
name|oct
argument_list|)
argument_list|,
name|lio_get_conf
argument_list|(
name|oct
argument_list|)
operator|->
name|card_name
argument_list|,
name|LIO_VERSION
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|octeon_device
modifier|*
name|lio_get_other_octeon_device
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
name|struct
name|octeon_device
modifier|*
name|other_oct
decl_stmt|;
name|other_oct
operator|=
name|lio_get_device
argument_list|(
name|oct
operator|->
name|octeon_id
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|other_oct
operator|!=
name|NULL
operator|)
operator|&&
name|other_oct
operator|->
name|device
condition|)
block|{
name|int
name|oct_busnum
decl_stmt|,
name|other_oct_busnum
decl_stmt|;
name|oct_busnum
operator|=
name|pci_get_bus
argument_list|(
name|oct
operator|->
name|device
argument_list|)
expr_stmt|;
name|other_oct_busnum
operator|=
name|pci_get_bus
argument_list|(
name|other_oct
operator|->
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|oct_busnum
operator|==
name|other_oct_busnum
condition|)
block|{
name|int
name|oct_slot
decl_stmt|,
name|other_oct_slot
decl_stmt|;
name|oct_slot
operator|=
name|pci_get_slot
argument_list|(
name|oct
operator|->
name|device
argument_list|)
expr_stmt|;
name|other_oct_slot
operator|=
name|pci_get_slot
argument_list|(
name|other_oct
operator|->
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|oct_slot
operator|==
name|other_oct_slot
condition|)
return|return
operator|(
name|other_oct
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * \brief Load firmware to device  * @param oct octeon device  *  * Maps device to firmware filename, requests firmware, and downloads it  */
end_comment

begin_function
specifier|static
name|int
name|lio_load_firmware
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
specifier|const
name|struct
name|firmware
modifier|*
name|fw
decl_stmt|;
name|char
modifier|*
name|tmp_fw_type
init|=
name|NULL
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|char
name|fw_name
index|[
name|LIO_MAX_FW_FILENAME_LEN
index|]
decl_stmt|;
if|if
condition|(
name|fw_type
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|tmp_fw_type
operator|=
name|LIO_FW_NAME_TYPE_NIC
expr_stmt|;
else|else
name|tmp_fw_type
operator|=
name|fw_type
expr_stmt|;
name|sprintf
argument_list|(
name|fw_name
argument_list|,
literal|"%s%s_%s%s"
argument_list|,
name|LIO_FW_BASE_NAME
argument_list|,
name|lio_get_conf
argument_list|(
name|oct
argument_list|)
operator|->
name|card_name
argument_list|,
name|tmp_fw_type
argument_list|,
name|LIO_FW_NAME_SUFFIX
argument_list|)
expr_stmt|;
name|fw
operator|=
name|firmware_get
argument_list|(
name|fw_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw
operator|==
name|NULL
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Request firmware failed. Could not find file %s.\n"
argument_list|,
name|fw_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|ret
operator|=
name|lio_download_firmware
argument_list|(
name|oct
argument_list|,
name|fw
operator|->
name|data
argument_list|,
name|fw
operator|->
name|datasize
argument_list|)
expr_stmt|;
name|firmware_put
argument_list|(
name|fw
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lio_nic_starter
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|atomic_store_rel_int
argument_list|(
operator|&
name|oct
operator|->
name|status
argument_list|,
name|LIO_DEV_RUNNING
argument_list|)
expr_stmt|;
if|if
condition|(
name|oct
operator|->
name|app_mode
operator|&&
name|oct
operator|->
name|app_mode
operator|==
name|LIO_DRV_NIC_APP
condition|)
block|{
if|if
condition|(
name|lio_init_nic_module
argument_list|(
name|oct
argument_list|)
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"NIC initialization failed\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|CAVIUM_ONiLY_23XX_VF
block|}
else|else
block|{
if|if
condition|(
name|octeon_enable_sriov
argument_list|(
name|oct
argument_list|)
operator|<
literal|0
condition|)
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Unexpected application running on NIC (%d). Check firmware.\n"
argument_list|,
name|oct
operator|->
name|app_mode
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lio_init_nic_module
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
name|int
name|num_nic_ports
init|=
name|LIO_GET_NUM_NIC_PORTS_CFG
argument_list|(
name|lio_get_conf
argument_list|(
name|oct
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"Initializing network interfaces\n"
argument_list|)
expr_stmt|;
comment|/* 	 * only default iq and oq were initialized 	 * initialize the rest as well 	 */
comment|/* run port_config command for each port */
name|oct
operator|->
name|ifcount
operator|=
name|num_nic_ports
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|oct
operator|->
name|props
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lio_if_props
argument_list|)
argument_list|)
expr_stmt|;
name|oct
operator|->
name|props
operator|.
name|gmxport
operator|=
operator|-
literal|1
expr_stmt|;
name|retval
operator|=
name|lio_setup_nic_devices
argument_list|(
name|oct
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Setup NIC devices failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|lio_init_failure
goto|;
block|}
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"Network interfaces ready\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
name|lio_init_failure
label|:
name|oct
operator|->
name|ifcount
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lio_ifmedia_update
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|lio
modifier|*
name|lio
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|ifmedia
modifier|*
name|ifm
decl_stmt|;
name|ifm
operator|=
operator|&
name|lio
operator|->
name|ifmedia
expr_stmt|;
comment|/* We only support Ethernet media type. */
if|if
condition|(
name|IFM_TYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
operator|!=
name|IFM_ETHER
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
switch|switch
condition|(
name|IFM_SUBTYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
condition|)
block|{
case|case
name|IFM_AUTO
case|:
break|break;
case|case
name|IFM_10G_CX4
case|:
case|case
name|IFM_10G_SR
case|:
case|case
name|IFM_10G_T
case|:
case|case
name|IFM_10G_TWINAX
case|:
default|default:
comment|/* We don't support changing the media type. */
name|lio_dev_err
argument_list|(
name|lio
operator|->
name|oct_dev
argument_list|,
literal|"Invalid media type (%d)\n"
argument_list|,
name|IFM_SUBTYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lio_get_media_subtype
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
switch|switch
condition|(
name|oct
operator|->
name|subdevice_id
condition|)
block|{
case|case
name|LIO_CN2350_10G_SUBDEVICE
case|:
case|case
name|LIO_CN2350_10G_SUBDEVICE1
case|:
case|case
name|LIO_CN2360_10G_SUBDEVICE
case|:
return|return
operator|(
name|IFM_10G_SR
operator|)
return|;
case|case
name|LIO_CN2350_25G_SUBDEVICE
case|:
case|case
name|LIO_CN2360_25G_SUBDEVICE
case|:
return|return
operator|(
name|IFM_25G_SR
operator|)
return|;
block|}
return|return
operator|(
name|IFM_10G_SR
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|long
name|lio_get_baudrate
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
switch|switch
condition|(
name|oct
operator|->
name|subdevice_id
condition|)
block|{
case|case
name|LIO_CN2350_10G_SUBDEVICE
case|:
case|case
name|LIO_CN2350_10G_SUBDEVICE1
case|:
case|case
name|LIO_CN2360_10G_SUBDEVICE
case|:
return|return
operator|(
name|IF_Gbps
argument_list|(
literal|10
argument_list|)
operator|)
return|;
case|case
name|LIO_CN2350_25G_SUBDEVICE
case|:
case|case
name|LIO_CN2360_25G_SUBDEVICE
case|:
return|return
operator|(
name|IF_Gbps
argument_list|(
literal|25
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|IF_Gbps
argument_list|(
literal|10
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lio_ifmedia_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|lio
modifier|*
name|lio
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
comment|/* Report link down if the driver isn't running. */
if|if
condition|(
operator|!
name|lio_ifstate_check
argument_list|(
name|lio
argument_list|,
name|LIO_IFSTATE_RUNNING
argument_list|)
condition|)
block|{
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_NONE
expr_stmt|;
return|return;
block|}
comment|/* Setup the default interface info. */
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
expr_stmt|;
if|if
condition|(
name|lio
operator|->
name|linfo
operator|.
name|link
operator|.
name|s
operator|.
name|link_up
condition|)
block|{
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
block|}
else|else
block|{
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_NONE
expr_stmt|;
return|return;
block|}
name|ifmr
operator|->
name|ifm_active
operator||=
name|lio_get_media_subtype
argument_list|(
name|lio
operator|->
name|oct_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|lio
operator|->
name|linfo
operator|.
name|link
operator|.
name|s
operator|.
name|duplex
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_FDX
expr_stmt|;
else|else
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_HDX
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|lio_get_counter
parameter_list|(
name|if_t
name|ifp
parameter_list|,
name|ift_counter
name|cnt
parameter_list|)
block|{
name|struct
name|lio
modifier|*
name|lio
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|octeon_device
modifier|*
name|oct
init|=
name|lio
operator|->
name|oct_dev
decl_stmt|;
name|uint64_t
name|counter
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|q_no
decl_stmt|;
switch|switch
condition|(
name|cnt
condition|)
block|{
case|case
name|IFCOUNTER_IPACKETS
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oct
operator|->
name|num_oqs
condition|;
name|i
operator|++
control|)
block|{
name|q_no
operator|=
name|lio
operator|->
name|linfo
operator|.
name|rxpciq
index|[
name|i
index|]
operator|.
name|s
operator|.
name|q_no
expr_stmt|;
name|counter
operator|+=
name|oct
operator|->
name|droq
index|[
name|q_no
index|]
operator|->
name|stats
operator|.
name|rx_pkts_received
expr_stmt|;
block|}
break|break;
case|case
name|IFCOUNTER_OPACKETS
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oct
operator|->
name|num_iqs
condition|;
name|i
operator|++
control|)
block|{
name|q_no
operator|=
name|lio
operator|->
name|linfo
operator|.
name|txpciq
index|[
name|i
index|]
operator|.
name|s
operator|.
name|q_no
expr_stmt|;
name|counter
operator|+=
name|oct
operator|->
name|instr_queue
index|[
name|q_no
index|]
operator|->
name|stats
operator|.
name|tx_done
expr_stmt|;
block|}
break|break;
case|case
name|IFCOUNTER_IBYTES
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oct
operator|->
name|num_oqs
condition|;
name|i
operator|++
control|)
block|{
name|q_no
operator|=
name|lio
operator|->
name|linfo
operator|.
name|rxpciq
index|[
name|i
index|]
operator|.
name|s
operator|.
name|q_no
expr_stmt|;
name|counter
operator|+=
name|oct
operator|->
name|droq
index|[
name|q_no
index|]
operator|->
name|stats
operator|.
name|rx_bytes_received
expr_stmt|;
block|}
break|break;
case|case
name|IFCOUNTER_OBYTES
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oct
operator|->
name|num_iqs
condition|;
name|i
operator|++
control|)
block|{
name|q_no
operator|=
name|lio
operator|->
name|linfo
operator|.
name|txpciq
index|[
name|i
index|]
operator|.
name|s
operator|.
name|q_no
expr_stmt|;
name|counter
operator|+=
name|oct
operator|->
name|instr_queue
index|[
name|q_no
index|]
operator|->
name|stats
operator|.
name|tx_tot_bytes
expr_stmt|;
block|}
break|break;
case|case
name|IFCOUNTER_IQDROPS
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oct
operator|->
name|num_oqs
condition|;
name|i
operator|++
control|)
block|{
name|q_no
operator|=
name|lio
operator|->
name|linfo
operator|.
name|rxpciq
index|[
name|i
index|]
operator|.
name|s
operator|.
name|q_no
expr_stmt|;
name|counter
operator|+=
name|oct
operator|->
name|droq
index|[
name|q_no
index|]
operator|->
name|stats
operator|.
name|rx_dropped
expr_stmt|;
block|}
break|break;
case|case
name|IFCOUNTER_OQDROPS
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oct
operator|->
name|num_iqs
condition|;
name|i
operator|++
control|)
block|{
name|q_no
operator|=
name|lio
operator|->
name|linfo
operator|.
name|txpciq
index|[
name|i
index|]
operator|.
name|s
operator|.
name|q_no
expr_stmt|;
name|counter
operator|+=
name|oct
operator|->
name|instr_queue
index|[
name|q_no
index|]
operator|->
name|stats
operator|.
name|tx_dropped
expr_stmt|;
block|}
break|break;
case|case
name|IFCOUNTER_IMCASTS
case|:
name|counter
operator|=
name|oct
operator|->
name|link_stats
operator|.
name|fromwire
operator|.
name|total_mcst
expr_stmt|;
break|break;
case|case
name|IFCOUNTER_OMCASTS
case|:
name|counter
operator|=
name|oct
operator|->
name|link_stats
operator|.
name|fromhost
operator|.
name|mcast_pkts_sent
expr_stmt|;
break|break;
case|case
name|IFCOUNTER_COLLISIONS
case|:
name|counter
operator|=
name|oct
operator|->
name|link_stats
operator|.
name|fromhost
operator|.
name|total_collisions
expr_stmt|;
break|break;
case|case
name|IFCOUNTER_IERRORS
case|:
name|counter
operator|=
name|oct
operator|->
name|link_stats
operator|.
name|fromwire
operator|.
name|fcs_err
operator|+
name|oct
operator|->
name|link_stats
operator|.
name|fromwire
operator|.
name|l2_err
operator|+
name|oct
operator|->
name|link_stats
operator|.
name|fromwire
operator|.
name|frame_err
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|if_get_counter_default
argument_list|(
name|ifp
argument_list|,
name|cnt
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|counter
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lio_init_ifnet
parameter_list|(
name|struct
name|lio
modifier|*
name|lio
parameter_list|)
block|{
name|struct
name|octeon_device
modifier|*
name|oct
init|=
name|lio
operator|->
name|oct_dev
decl_stmt|;
name|if_t
name|ifp
init|=
name|lio
operator|->
name|ifp
decl_stmt|;
comment|/* ifconfig entrypoint for media type/status reporting */
name|ifmedia_init
argument_list|(
operator|&
name|lio
operator|->
name|ifmedia
argument_list|,
name|IFM_IMASK
argument_list|,
name|lio_ifmedia_update
argument_list|,
name|lio_ifmedia_status
argument_list|)
expr_stmt|;
comment|/* set the default interface values */
name|ifmedia_add
argument_list|(
operator|&
name|lio
operator|->
name|ifmedia
argument_list|,
operator|(
name|IFM_ETHER
operator||
name|IFM_FDX
operator||
name|lio_get_media_subtype
argument_list|(
name|oct
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|lio
operator|->
name|ifmedia
argument_list|,
operator|(
name|IFM_ETHER
operator||
name|IFM_AUTO
operator|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|lio
operator|->
name|ifmedia
argument_list|,
operator|(
name|IFM_ETHER
operator||
name|IFM_AUTO
operator|)
argument_list|)
expr_stmt|;
name|lio
operator|->
name|ifmedia
operator|.
name|ifm_media
operator|=
name|lio
operator|->
name|ifmedia
operator|.
name|ifm_cur
operator|->
name|ifm_media
expr_stmt|;
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"IFMEDIA flags : %x\n"
argument_list|,
name|lio
operator|->
name|ifmedia
operator|.
name|ifm_media
argument_list|)
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|oct
operator|->
name|device
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|oct
operator|->
name|device
argument_list|)
argument_list|)
expr_stmt|;
name|if_setflags
argument_list|(
name|ifp
argument_list|,
operator|(
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
operator|)
argument_list|)
expr_stmt|;
name|if_setioctlfn
argument_list|(
name|ifp
argument_list|,
name|lio_ioctl
argument_list|)
expr_stmt|;
name|if_setgetcounterfn
argument_list|(
name|ifp
argument_list|,
name|lio_get_counter
argument_list|)
expr_stmt|;
name|if_settransmitfn
argument_list|(
name|ifp
argument_list|,
name|lio_mq_start
argument_list|)
expr_stmt|;
name|if_setqflushfn
argument_list|(
name|ifp
argument_list|,
name|lio_qflush
argument_list|)
expr_stmt|;
name|if_setinitfn
argument_list|(
name|ifp
argument_list|,
name|lio_open
argument_list|)
expr_stmt|;
name|if_setmtu
argument_list|(
name|ifp
argument_list|,
name|lio
operator|->
name|linfo
operator|.
name|link
operator|.
name|s
operator|.
name|mtu
argument_list|)
expr_stmt|;
name|lio
operator|->
name|mtu
operator|=
name|lio
operator|->
name|linfo
operator|.
name|link
operator|.
name|s
operator|.
name|mtu
expr_stmt|;
name|if_sethwassist
argument_list|(
name|ifp
argument_list|,
operator|(
name|CSUM_IP
operator||
name|CSUM_TCP
operator||
name|CSUM_UDP
operator||
name|CSUM_TSO
operator||
name|CSUM_TCP_IPV6
operator||
name|CSUM_UDP_IPV6
operator|)
argument_list|)
expr_stmt|;
name|if_setcapabilitiesbit
argument_list|(
name|ifp
argument_list|,
operator|(
name|IFCAP_HWCSUM
operator||
name|IFCAP_HWCSUM_IPV6
operator||
name|IFCAP_TSO
operator||
name|IFCAP_LRO
operator||
name|IFCAP_JUMBO_MTU
operator||
name|IFCAP_HWSTATS
operator||
name|IFCAP_LINKSTATE
operator||
name|IFCAP_VLAN_HWFILTER
operator||
name|IFCAP_VLAN_HWCSUM
operator||
name|IFCAP_VLAN_HWTAGGING
operator||
name|IFCAP_VLAN_HWTSO
operator||
name|IFCAP_VLAN_MTU
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|if_setcapenable
argument_list|(
name|ifp
argument_list|,
name|if_getcapabilities
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
name|if_setbaudrate
argument_list|(
name|ifp
argument_list|,
name|lio_get_baudrate
argument_list|(
name|oct
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lio_tcp_lro_free
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|octeon_dev
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|lio
modifier|*
name|lio
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|lio_droq
modifier|*
name|droq
decl_stmt|;
name|int
name|q_no
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|octeon_dev
operator|->
name|num_oqs
condition|;
name|i
operator|++
control|)
block|{
name|q_no
operator|=
name|lio
operator|->
name|linfo
operator|.
name|rxpciq
index|[
name|i
index|]
operator|.
name|s
operator|.
name|q_no
expr_stmt|;
name|droq
operator|=
name|octeon_dev
operator|->
name|droq
index|[
name|q_no
index|]
expr_stmt|;
if|if
condition|(
name|droq
operator|->
name|lro
operator|.
name|ifp
condition|)
block|{
name|tcp_lro_free
argument_list|(
operator|&
name|droq
operator|->
name|lro
argument_list|)
expr_stmt|;
name|droq
operator|->
name|lro
operator|.
name|ifp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|lio_tcp_lro_init
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|octeon_dev
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|lio
modifier|*
name|lio
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|lio_droq
modifier|*
name|droq
decl_stmt|;
name|struct
name|lro_ctrl
modifier|*
name|lro
decl_stmt|;
name|int
name|i
decl_stmt|,
name|q_no
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|octeon_dev
operator|->
name|num_oqs
condition|;
name|i
operator|++
control|)
block|{
name|q_no
operator|=
name|lio
operator|->
name|linfo
operator|.
name|rxpciq
index|[
name|i
index|]
operator|.
name|s
operator|.
name|q_no
expr_stmt|;
name|droq
operator|=
name|octeon_dev
operator|->
name|droq
index|[
name|q_no
index|]
expr_stmt|;
name|lro
operator|=
operator|&
name|droq
operator|->
name|lro
expr_stmt|;
name|ret
operator|=
name|tcp_lro_init
argument_list|(
name|lro
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|lio_dev_err
argument_list|(
name|octeon_dev
argument_list|,
literal|"LRO Initialization failed ret %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
goto|goto
name|lro_init_failed
goto|;
block|}
name|lro
operator|->
name|ifp
operator|=
name|ifp
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
name|lro_init_failed
label|:
name|lio_tcp_lro_free
argument_list|(
name|octeon_dev
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lio_setup_nic_devices
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|octeon_dev
parameter_list|)
block|{
name|union
name|octeon_if_cfg
name|if_cfg
decl_stmt|;
name|struct
name|lio
modifier|*
name|lio
init|=
name|NULL
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|NULL
decl_stmt|;
name|struct
name|lio_version
modifier|*
name|vdata
decl_stmt|;
name|struct
name|lio_soft_command
modifier|*
name|sc
decl_stmt|;
name|struct
name|lio_if_cfg_context
modifier|*
name|ctx
decl_stmt|;
name|struct
name|lio_if_cfg_resp
modifier|*
name|resp
decl_stmt|;
name|struct
name|lio_if_props
modifier|*
name|props
decl_stmt|;
name|int
name|num_iqueues
decl_stmt|,
name|num_oqueues
decl_stmt|,
name|retval
decl_stmt|;
name|unsigned
name|int
name|base_queue
decl_stmt|;
name|unsigned
name|int
name|gmx_port_id
decl_stmt|;
name|uint32_t
name|ctx_size
decl_stmt|,
name|data_size
decl_stmt|;
name|uint32_t
name|ifidx_or_pfnum
decl_stmt|,
name|resp_size
decl_stmt|;
name|uint8_t
name|mac
index|[
name|ETHER_HDR_LEN
index|]
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* This is to handle link status changes */
name|lio_register_dispatch_fn
argument_list|(
name|octeon_dev
argument_list|,
name|LIO_OPCODE_NIC
argument_list|,
name|LIO_OPCODE_NIC_INFO
argument_list|,
name|lio_link_info
argument_list|,
name|octeon_dev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|octeon_dev
operator|->
name|ifcount
condition|;
name|i
operator|++
control|)
block|{
name|resp_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|lio_if_cfg_resp
argument_list|)
expr_stmt|;
name|ctx_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|lio_if_cfg_context
argument_list|)
expr_stmt|;
name|data_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|lio_version
argument_list|)
expr_stmt|;
name|sc
operator|=
name|lio_alloc_soft_command
argument_list|(
name|octeon_dev
argument_list|,
name|data_size
argument_list|,
name|resp_size
argument_list|,
name|ctx_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|resp
operator|=
operator|(
expr|struct
name|lio_if_cfg_resp
operator|*
operator|)
name|sc
operator|->
name|virtrptr
expr_stmt|;
name|ctx
operator|=
operator|(
expr|struct
name|lio_if_cfg_context
operator|*
operator|)
name|sc
operator|->
name|ctxptr
expr_stmt|;
name|vdata
operator|=
operator|(
expr|struct
name|lio_version
operator|*
operator|)
name|sc
operator|->
name|virtdptr
expr_stmt|;
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|vdata
operator|)
operator|=
literal|0
expr_stmt|;
name|vdata
operator|->
name|major
operator|=
name|htobe16
argument_list|(
name|LIO_BASE_MAJOR_VERSION
argument_list|)
expr_stmt|;
name|vdata
operator|->
name|minor
operator|=
name|htobe16
argument_list|(
name|LIO_BASE_MINOR_VERSION
argument_list|)
expr_stmt|;
name|vdata
operator|->
name|micro
operator|=
name|htobe16
argument_list|(
name|LIO_BASE_MICRO_VERSION
argument_list|)
expr_stmt|;
name|num_iqueues
operator|=
name|octeon_dev
operator|->
name|sriov_info
operator|.
name|num_pf_rings
expr_stmt|;
name|num_oqueues
operator|=
name|octeon_dev
operator|->
name|sriov_info
operator|.
name|num_pf_rings
expr_stmt|;
name|base_queue
operator|=
name|octeon_dev
operator|->
name|sriov_info
operator|.
name|pf_srn
expr_stmt|;
name|gmx_port_id
operator|=
name|octeon_dev
operator|->
name|pf_num
expr_stmt|;
name|ifidx_or_pfnum
operator|=
name|octeon_dev
operator|->
name|pf_num
expr_stmt|;
name|lio_dev_dbg
argument_list|(
name|octeon_dev
argument_list|,
literal|"requesting config for interface %d, iqs %d, oqs %d\n"
argument_list|,
name|ifidx_or_pfnum
argument_list|,
name|num_iqueues
argument_list|,
name|num_oqueues
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|cond
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|octeon_id
operator|=
name|lio_get_device_id
argument_list|(
name|octeon_dev
argument_list|)
expr_stmt|;
name|if_cfg
operator|.
name|if_cfg64
operator|=
literal|0
expr_stmt|;
name|if_cfg
operator|.
name|s
operator|.
name|num_iqueues
operator|=
name|num_iqueues
expr_stmt|;
name|if_cfg
operator|.
name|s
operator|.
name|num_oqueues
operator|=
name|num_oqueues
expr_stmt|;
name|if_cfg
operator|.
name|s
operator|.
name|base_queue
operator|=
name|base_queue
expr_stmt|;
name|if_cfg
operator|.
name|s
operator|.
name|gmx_port_id
operator|=
name|gmx_port_id
expr_stmt|;
name|sc
operator|->
name|iq_no
operator|=
literal|0
expr_stmt|;
name|lio_prepare_soft_command
argument_list|(
name|octeon_dev
argument_list|,
name|sc
argument_list|,
name|LIO_OPCODE_NIC
argument_list|,
name|LIO_OPCODE_NIC_IF_CFG
argument_list|,
literal|0
argument_list|,
name|if_cfg
operator|.
name|if_cfg64
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|callback
operator|=
name|lio_if_cfg_callback
expr_stmt|;
name|sc
operator|->
name|callback_arg
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|wait_time
operator|=
literal|3000
expr_stmt|;
name|retval
operator|=
name|lio_send_soft_command
argument_list|(
name|octeon_dev
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|LIO_IQ_SEND_FAILED
condition|)
block|{
name|lio_dev_err
argument_list|(
name|octeon_dev
argument_list|,
literal|"iq/oq config failed status: %x\n"
argument_list|,
name|retval
argument_list|)
expr_stmt|;
comment|/* Soft instr is freed by driver in case of failure. */
goto|goto
name|setup_nic_dev_fail
goto|;
block|}
comment|/* 		 * Sleep on a wait queue till the cond flag indicates that the 		 * response arrived or timed-out. 		 */
name|lio_sleep_cond
argument_list|(
name|octeon_dev
argument_list|,
operator|&
name|ctx
operator|->
name|cond
argument_list|)
expr_stmt|;
name|retval
operator|=
name|resp
operator|->
name|status
expr_stmt|;
if|if
condition|(
name|retval
condition|)
block|{
name|lio_dev_err
argument_list|(
name|octeon_dev
argument_list|,
literal|"iq/oq config failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|setup_nic_dev_fail
goto|;
block|}
name|lio_swap_8B_data
argument_list|(
operator|(
name|uint64_t
operator|*
operator|)
operator|(
operator|&
name|resp
operator|->
name|cfg_info
operator|)
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|octeon_if_cfg_info
argument_list|)
operator|)
operator|>>
literal|3
argument_list|)
expr_stmt|;
name|num_iqueues
operator|=
name|bitcount64
argument_list|(
name|resp
operator|->
name|cfg_info
operator|.
name|iqmask
argument_list|)
expr_stmt|;
name|num_oqueues
operator|=
name|bitcount64
argument_list|(
name|resp
operator|->
name|cfg_info
operator|.
name|oqmask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|num_iqueues
operator|)
operator|||
operator|!
operator|(
name|num_oqueues
operator|)
condition|)
block|{
name|lio_dev_err
argument_list|(
name|octeon_dev
argument_list|,
literal|"Got bad iqueues (%016lX) or oqueues (%016lX) from firmware.\n"
argument_list|,
name|resp
operator|->
name|cfg_info
operator|.
name|iqmask
argument_list|,
name|resp
operator|->
name|cfg_info
operator|.
name|oqmask
argument_list|)
expr_stmt|;
goto|goto
name|setup_nic_dev_fail
goto|;
block|}
name|lio_dev_dbg
argument_list|(
name|octeon_dev
argument_list|,
literal|"interface %d, iqmask %016lx, oqmask %016lx, numiqueues %d, numoqueues %d\n"
argument_list|,
name|i
argument_list|,
name|resp
operator|->
name|cfg_info
operator|.
name|iqmask
argument_list|,
name|resp
operator|->
name|cfg_info
operator|.
name|oqmask
argument_list|,
name|num_iqueues
argument_list|,
name|num_oqueues
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|lio_dev_err
argument_list|(
name|octeon_dev
argument_list|,
literal|"Device allocation failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|setup_nic_dev_fail
goto|;
block|}
name|lio
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lio
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|lio
operator|==
name|NULL
condition|)
block|{
name|lio_dev_err
argument_list|(
name|octeon_dev
argument_list|,
literal|"Lio allocation failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|setup_nic_dev_fail
goto|;
block|}
name|if_setsoftc
argument_list|(
name|ifp
argument_list|,
name|lio
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_hw_tsomax
operator|=
name|LIO_MAX_FRAME_SIZE
expr_stmt|;
name|ifp
operator|->
name|if_hw_tsomaxsegcount
operator|=
name|LIO_MAX_SG
expr_stmt|;
name|ifp
operator|->
name|if_hw_tsomaxsegsize
operator|=
name|PAGE_SIZE
expr_stmt|;
name|lio
operator|->
name|ifidx
operator|=
name|ifidx_or_pfnum
expr_stmt|;
name|props
operator|=
operator|&
name|octeon_dev
operator|->
name|props
expr_stmt|;
name|props
operator|->
name|gmxport
operator|=
name|resp
operator|->
name|cfg_info
operator|.
name|linfo
operator|.
name|gmxport
expr_stmt|;
name|props
operator|->
name|ifp
operator|=
name|ifp
expr_stmt|;
name|lio
operator|->
name|linfo
operator|.
name|num_rxpciq
operator|=
name|num_oqueues
expr_stmt|;
name|lio
operator|->
name|linfo
operator|.
name|num_txpciq
operator|=
name|num_iqueues
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_oqueues
condition|;
name|j
operator|++
control|)
block|{
name|lio
operator|->
name|linfo
operator|.
name|rxpciq
index|[
name|j
index|]
operator|.
name|rxpciq64
operator|=
name|resp
operator|->
name|cfg_info
operator|.
name|linfo
operator|.
name|rxpciq
index|[
name|j
index|]
operator|.
name|rxpciq64
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_iqueues
condition|;
name|j
operator|++
control|)
block|{
name|lio
operator|->
name|linfo
operator|.
name|txpciq
index|[
name|j
index|]
operator|.
name|txpciq64
operator|=
name|resp
operator|->
name|cfg_info
operator|.
name|linfo
operator|.
name|txpciq
index|[
name|j
index|]
operator|.
name|txpciq64
expr_stmt|;
block|}
name|lio
operator|->
name|linfo
operator|.
name|hw_addr
operator|=
name|resp
operator|->
name|cfg_info
operator|.
name|linfo
operator|.
name|hw_addr
expr_stmt|;
name|lio
operator|->
name|linfo
operator|.
name|gmxport
operator|=
name|resp
operator|->
name|cfg_info
operator|.
name|linfo
operator|.
name|gmxport
expr_stmt|;
name|lio
operator|->
name|linfo
operator|.
name|link
operator|.
name|link_status64
operator|=
name|resp
operator|->
name|cfg_info
operator|.
name|linfo
operator|.
name|link
operator|.
name|link_status64
expr_stmt|;
comment|/* 		 * Point to the properties for octeon device to which this 		 * interface belongs. 		 */
name|lio
operator|->
name|oct_dev
operator|=
name|octeon_dev
expr_stmt|;
name|lio
operator|->
name|ifp
operator|=
name|ifp
expr_stmt|;
name|lio_dev_dbg
argument_list|(
name|octeon_dev
argument_list|,
literal|"if%d gmx: %d hw_addr: 0x%llx\n"
argument_list|,
name|i
argument_list|,
name|lio
operator|->
name|linfo
operator|.
name|gmxport
argument_list|,
name|LIO_CAST64
argument_list|(
name|lio
operator|->
name|linfo
operator|.
name|hw_addr
argument_list|)
argument_list|)
expr_stmt|;
name|lio_init_ifnet
argument_list|(
name|lio
argument_list|)
expr_stmt|;
comment|/* 64-bit swap required on LE machines */
name|lio_swap_8B_data
argument_list|(
operator|&
name|lio
operator|->
name|linfo
operator|.
name|hw_addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|6
condition|;
name|j
operator|++
control|)
name|mac
index|[
name|j
index|]
operator|=
operator|*
operator|(
operator|(
name|uint8_t
operator|*
operator|)
operator|(
operator|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|lio
operator|->
name|linfo
operator|.
name|hw_addr
operator|)
operator|+
literal|2
operator|+
name|j
operator|)
operator|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|mac
argument_list|)
expr_stmt|;
comment|/* 		 * By default all interfaces on a single Octeon uses the same 		 * tx and rx queues 		 */
name|lio
operator|->
name|txq
operator|=
name|lio
operator|->
name|linfo
operator|.
name|txpciq
index|[
literal|0
index|]
operator|.
name|s
operator|.
name|q_no
expr_stmt|;
name|lio
operator|->
name|rxq
operator|=
name|lio
operator|->
name|linfo
operator|.
name|rxpciq
index|[
literal|0
index|]
operator|.
name|s
operator|.
name|q_no
expr_stmt|;
if|if
condition|(
name|lio_setup_io_queues
argument_list|(
name|octeon_dev
argument_list|,
name|i
argument_list|,
name|lio
operator|->
name|linfo
operator|.
name|num_txpciq
argument_list|,
name|lio
operator|->
name|linfo
operator|.
name|num_rxpciq
argument_list|)
condition|)
block|{
name|lio_dev_err
argument_list|(
name|octeon_dev
argument_list|,
literal|"I/O queues creation failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|setup_nic_dev_fail
goto|;
block|}
name|lio_ifstate_set
argument_list|(
name|lio
argument_list|,
name|LIO_IFSTATE_DROQ_OPS
argument_list|)
expr_stmt|;
name|lio
operator|->
name|tx_qsize
operator|=
name|lio_get_tx_qsize
argument_list|(
name|octeon_dev
argument_list|,
name|lio
operator|->
name|txq
argument_list|)
expr_stmt|;
name|lio
operator|->
name|rx_qsize
operator|=
name|lio_get_rx_qsize
argument_list|(
name|octeon_dev
argument_list|,
name|lio
operator|->
name|rxq
argument_list|)
expr_stmt|;
if|if
condition|(
name|lio_setup_glists
argument_list|(
name|octeon_dev
argument_list|,
name|lio
argument_list|,
name|num_iqueues
argument_list|)
condition|)
block|{
name|lio_dev_err
argument_list|(
name|octeon_dev
argument_list|,
literal|"Gather list allocation failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|setup_nic_dev_fail
goto|;
block|}
if|if
condition|(
operator|(
name|lio_hwlro
operator|==
literal|0
operator|)
operator|&&
name|lio_tcp_lro_init
argument_list|(
name|octeon_dev
argument_list|,
name|ifp
argument_list|)
condition|)
goto|goto
name|setup_nic_dev_fail
goto|;
if|if
condition|(
name|lio_hwlro
operator|&&
operator|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_LRO
operator|)
operator|&&
operator|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_RXCSUM
operator|)
operator|&&
operator|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_RXCSUM_IPV6
operator|)
condition|)
name|lio_set_feature
argument_list|(
name|ifp
argument_list|,
name|LIO_CMD_LRO_ENABLE
argument_list|,
name|LIO_LROIPV4
operator||
name|LIO_LROIPV6
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_VLAN_HWFILTER
operator|)
condition|)
name|lio_set_feature
argument_list|(
name|ifp
argument_list|,
name|LIO_CMD_VLAN_FILTER_CTL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|lio_set_feature
argument_list|(
name|ifp
argument_list|,
name|LIO_CMD_VLAN_FILTER_CTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lio_setup_rx_oom_poll_fn
argument_list|(
name|ifp
argument_list|)
condition|)
goto|goto
name|setup_nic_dev_fail
goto|;
name|lio_dev_dbg
argument_list|(
name|octeon_dev
argument_list|,
literal|"Setup NIC ifidx:%d mac:%02x%02x%02x%02x%02x%02x\n"
argument_list|,
name|i
argument_list|,
name|mac
index|[
literal|0
index|]
argument_list|,
name|mac
index|[
literal|1
index|]
argument_list|,
name|mac
index|[
literal|2
index|]
argument_list|,
name|mac
index|[
literal|3
index|]
argument_list|,
name|mac
index|[
literal|4
index|]
argument_list|,
name|mac
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|lio
operator|->
name|link_changes
operator|++
expr_stmt|;
name|lio_ifstate_set
argument_list|(
name|lio
argument_list|,
name|LIO_IFSTATE_REGISTERED
argument_list|)
expr_stmt|;
comment|/* 		 * Sending command to firmware to enable Rx checksum offload 		 * by default at the time of setup of Liquidio driver for 		 * this device 		 */
name|lio_set_rxcsum_command
argument_list|(
name|ifp
argument_list|,
name|LIO_CMD_TNL_RX_CSUM_CTL
argument_list|,
name|LIO_CMD_RXCSUM_ENABLE
argument_list|)
expr_stmt|;
name|lio_set_feature
argument_list|(
name|ifp
argument_list|,
name|LIO_CMD_TNL_TX_CSUM_CTL
argument_list|,
name|LIO_CMD_TXCSUM_ENABLE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RSS
if|if
condition|(
name|lio_rss
condition|)
block|{
if|if
condition|(
name|lio_send_rss_param
argument_list|(
name|lio
argument_list|)
condition|)
goto|goto
name|setup_nic_dev_fail
goto|;
block|}
else|else
endif|#
directive|endif
comment|/* RSS */
name|lio_set_feature
argument_list|(
name|ifp
argument_list|,
name|LIO_CMD_SET_FNV
argument_list|,
name|LIO_CMD_FNV_ENABLE
argument_list|)
expr_stmt|;
name|lio_dev_dbg
argument_list|(
name|octeon_dev
argument_list|,
literal|"NIC ifidx:%d Setup successful\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|lio_free_soft_command
argument_list|(
name|octeon_dev
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|lio
operator|->
name|vlan_attach
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vlan_config
argument_list|,
name|lio_vlan_rx_add_vid
argument_list|,
name|lio
argument_list|,
name|EVENTHANDLER_PRI_FIRST
argument_list|)
expr_stmt|;
name|lio
operator|->
name|vlan_detach
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vlan_unconfig
argument_list|,
name|lio_vlan_rx_kill_vid
argument_list|,
name|lio
argument_list|,
name|EVENTHANDLER_PRI_FIRST
argument_list|)
expr_stmt|;
comment|/* Update stats periodically */
name|callout_init
argument_list|(
operator|&
name|lio
operator|->
name|stats_timer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lio
operator|->
name|stats_interval
operator|=
name|LIO_DEFAULT_STATS_INTERVAL
expr_stmt|;
name|lio_add_hw_stats
argument_list|(
name|lio
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|setup_nic_dev_fail
label|:
name|lio_free_soft_command
argument_list|(
name|octeon_dev
argument_list|,
name|sc
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
name|lio_dev_err
argument_list|(
name|octeon_dev
argument_list|,
literal|"NIC ifidx:%d Setup failed\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|lio_destroy_nic_device
argument_list|(
name|octeon_dev
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lio_link_info
parameter_list|(
name|struct
name|lio_recv_info
modifier|*
name|recv_info
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|octeon_device
modifier|*
name|oct
init|=
operator|(
expr|struct
name|octeon_device
operator|*
operator|)
name|ptr
decl_stmt|;
name|struct
name|lio_recv_pkt
modifier|*
name|recv_pkt
init|=
name|recv_info
operator|->
name|recv_pkt
decl_stmt|;
name|union
name|octeon_link_status
modifier|*
name|ls
decl_stmt|;
name|int
name|gmxport
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"%s Called\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|recv_pkt
operator|->
name|buffer_size
index|[
literal|0
index|]
operator|!=
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|ls
argument_list|)
operator|+
name|LIO_DROQ_INFO_SIZE
operator|)
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Malformed NIC_INFO, len=%d, ifidx=%d\n"
argument_list|,
name|recv_pkt
operator|->
name|buffer_size
index|[
literal|0
index|]
argument_list|,
name|recv_pkt
operator|->
name|rh
operator|.
name|r_nic_info
operator|.
name|gmxport
argument_list|)
expr_stmt|;
goto|goto
name|nic_info_err
goto|;
block|}
name|gmxport
operator|=
name|recv_pkt
operator|->
name|rh
operator|.
name|r_nic_info
operator|.
name|gmxport
expr_stmt|;
name|ls
operator|=
operator|(
expr|union
name|octeon_link_status
operator|*
operator|)
operator|(
name|recv_pkt
operator|->
name|buffer_ptr
index|[
literal|0
index|]
operator|->
name|m_data
operator|+
name|LIO_DROQ_INFO_SIZE
operator|)
expr_stmt|;
name|lio_swap_8B_data
argument_list|(
operator|(
name|uint64_t
operator|*
operator|)
name|ls
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|union
name|octeon_link_status
argument_list|)
operator|)
operator|>>
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|oct
operator|->
name|props
operator|.
name|gmxport
operator|==
name|gmxport
condition|)
name|lio_update_link_status
argument_list|(
name|oct
operator|->
name|props
operator|.
name|ifp
argument_list|,
name|ls
argument_list|)
expr_stmt|;
name|nic_info_err
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recv_pkt
operator|->
name|buffer_count
condition|;
name|i
operator|++
control|)
name|lio_recv_buffer_free
argument_list|(
name|recv_pkt
operator|->
name|buffer_ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|lio_free_recv_info
argument_list|(
name|recv_info
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|lio_free_mbuf
parameter_list|(
name|struct
name|lio_instr_queue
modifier|*
name|iq
parameter_list|,
name|struct
name|lio_mbuf_free_info
modifier|*
name|finfo
parameter_list|)
block|{
name|bus_dmamap_sync
argument_list|(
name|iq
operator|->
name|txtag
argument_list|,
name|finfo
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|iq
operator|->
name|txtag
argument_list|,
name|finfo
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|finfo
operator|->
name|mb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lio_free_sgmbuf
parameter_list|(
name|struct
name|lio_instr_queue
modifier|*
name|iq
parameter_list|,
name|struct
name|lio_mbuf_free_info
modifier|*
name|finfo
parameter_list|)
block|{
name|struct
name|lio_gather
modifier|*
name|g
decl_stmt|;
name|struct
name|octeon_device
modifier|*
name|oct
decl_stmt|;
name|struct
name|lio
modifier|*
name|lio
decl_stmt|;
name|int
name|iq_no
decl_stmt|;
name|g
operator|=
name|finfo
operator|->
name|g
expr_stmt|;
name|iq_no
operator|=
name|iq
operator|->
name|txpciq
operator|.
name|s
operator|.
name|q_no
expr_stmt|;
name|oct
operator|=
name|iq
operator|->
name|oct_dev
expr_stmt|;
name|lio
operator|=
name|if_getsoftc
argument_list|(
name|oct
operator|->
name|props
operator|.
name|ifp
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lio
operator|->
name|glist_lock
index|[
name|iq_no
index|]
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|lio
operator|->
name|ghead
index|[
name|iq_no
index|]
argument_list|,
operator|&
name|g
operator|->
name|node
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lio
operator|->
name|glist_lock
index|[
name|iq_no
index|]
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|iq
operator|->
name|txtag
argument_list|,
name|finfo
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|iq
operator|->
name|txtag
argument_list|,
name|finfo
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|finfo
operator|->
name|mb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lio_if_cfg_callback
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|uint32_t
name|status
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|lio_soft_command
modifier|*
name|sc
init|=
operator|(
expr|struct
name|lio_soft_command
operator|*
operator|)
name|buf
decl_stmt|;
name|struct
name|lio_if_cfg_resp
modifier|*
name|resp
decl_stmt|;
name|struct
name|lio_if_cfg_context
modifier|*
name|ctx
decl_stmt|;
name|resp
operator|=
operator|(
expr|struct
name|lio_if_cfg_resp
operator|*
operator|)
name|sc
operator|->
name|virtrptr
expr_stmt|;
name|ctx
operator|=
operator|(
expr|struct
name|lio_if_cfg_context
operator|*
operator|)
name|sc
operator|->
name|ctxptr
expr_stmt|;
name|oct
operator|=
name|lio_get_device
argument_list|(
name|ctx
operator|->
name|octeon_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|->
name|status
condition|)
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"nic if cfg instruction failed. Status: %llx (0x%08x)\n"
argument_list|,
name|LIO_CAST64
argument_list|(
name|resp
operator|->
name|status
argument_list|)
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|cond
operator|=
literal|1
expr_stmt|;
name|snprintf
argument_list|(
name|oct
operator|->
name|fw_info
operator|.
name|lio_firmware_version
argument_list|,
literal|32
argument_list|,
literal|"%s"
argument_list|,
name|resp
operator|->
name|cfg_info
operator|.
name|lio_firmware_version
argument_list|)
expr_stmt|;
comment|/* 	 * This barrier is required to be sure that the response has been 	 * written fully before waking up the handler 	 */
name|wmb
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lio_is_mac_changed
parameter_list|(
name|uint8_t
modifier|*
name|new
parameter_list|,
name|uint8_t
modifier|*
name|old
parameter_list|)
block|{
return|return
operator|(
operator|(
name|new
index|[
literal|0
index|]
operator|!=
name|old
index|[
literal|0
index|]
operator|)
operator|||
operator|(
name|new
index|[
literal|1
index|]
operator|!=
name|old
index|[
literal|1
index|]
operator|)
operator|||
operator|(
name|new
index|[
literal|2
index|]
operator|!=
name|old
index|[
literal|2
index|]
operator|)
operator|||
operator|(
name|new
index|[
literal|3
index|]
operator|!=
name|old
index|[
literal|3
index|]
operator|)
operator|||
operator|(
name|new
index|[
literal|4
index|]
operator|!=
name|old
index|[
literal|4
index|]
operator|)
operator|||
operator|(
name|new
index|[
literal|5
index|]
operator|!=
name|old
index|[
literal|5
index|]
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|lio_open
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|lio
modifier|*
name|lio
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|lio
operator|->
name|ifp
decl_stmt|;
name|struct
name|octeon_device
modifier|*
name|oct
init|=
name|lio
operator|->
name|oct_dev
decl_stmt|;
name|uint8_t
modifier|*
name|mac_new
decl_stmt|,
name|mac_old
index|[
name|ETHER_HDR_LEN
index|]
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|lio_ifstate_set
argument_list|(
name|lio
argument_list|,
name|LIO_IFSTATE_RUNNING
argument_list|)
expr_stmt|;
comment|/* Ready for link status updates */
name|lio
operator|->
name|intf_open
operator|=
literal|1
expr_stmt|;
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"Interface Open, ready for traffic\n"
argument_list|)
expr_stmt|;
comment|/* tell Octeon to start forwarding packets to host */
name|lio_send_rx_ctrl_cmd
argument_list|(
name|lio
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mac_new
operator|=
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|mac_old
argument_list|,
operator|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|lio
operator|->
name|linfo
operator|.
name|hw_addr
operator|)
operator|+
literal|2
argument_list|,
name|ETHER_HDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|lio_is_mac_changed
argument_list|(
name|mac_new
argument_list|,
name|mac_old
argument_list|)
condition|)
block|{
name|ret
operator|=
name|lio_set_mac
argument_list|(
name|ifp
argument_list|,
name|mac_new
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"MAC change failed, error: %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
comment|/* Now inform the stack we're ready */
name|if_setdrvflagbits
argument_list|(
name|ifp
argument_list|,
name|IFF_DRV_RUNNING
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"Interface is opened\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lio_set_rxcsum_command
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|command
parameter_list|,
name|uint8_t
name|rx_cmd
parameter_list|)
block|{
name|struct
name|lio_ctrl_pkt
name|nctrl
decl_stmt|;
name|struct
name|lio
modifier|*
name|lio
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|octeon_device
modifier|*
name|oct
init|=
name|lio
operator|->
name|oct_dev
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|nctrl
operator|.
name|ncmd
operator|.
name|cmd64
operator|=
literal|0
expr_stmt|;
name|nctrl
operator|.
name|ncmd
operator|.
name|s
operator|.
name|cmd
operator|=
name|command
expr_stmt|;
name|nctrl
operator|.
name|ncmd
operator|.
name|s
operator|.
name|param1
operator|=
name|rx_cmd
expr_stmt|;
name|nctrl
operator|.
name|iq_no
operator|=
name|lio
operator|->
name|linfo
operator|.
name|txpciq
index|[
literal|0
index|]
operator|.
name|s
operator|.
name|q_no
expr_stmt|;
name|nctrl
operator|.
name|wait_time
operator|=
literal|100
expr_stmt|;
name|nctrl
operator|.
name|lio
operator|=
name|lio
expr_stmt|;
name|nctrl
operator|.
name|cb_fn
operator|=
name|lio_ctrl_cmd_completion
expr_stmt|;
name|ret
operator|=
name|lio_send_ctrl_pkt
argument_list|(
name|lio
operator|->
name|oct_dev
argument_list|,
operator|&
name|nctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"DEVFLAGS RXCSUM change failed in core(ret:0x%x)\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lio_stop_nic_module
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|lio
modifier|*
name|lio
decl_stmt|;
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"Stopping network interfaces\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|oct
operator|->
name|ifcount
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Init for Octeon was not completed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|oct
operator|->
name|cmd_resp_wqlock
argument_list|)
expr_stmt|;
name|oct
operator|->
name|cmd_resp_state
operator|=
name|LIO_DRV_OFFLINE
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|oct
operator|->
name|cmd_resp_wqlock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oct
operator|->
name|ifcount
condition|;
name|i
operator|++
control|)
block|{
name|lio
operator|=
name|if_getsoftc
argument_list|(
name|oct
operator|->
name|props
operator|.
name|ifp
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|oct
operator|->
name|num_oqs
condition|;
name|j
operator|++
control|)
name|lio_unregister_droq_ops
argument_list|(
name|oct
argument_list|,
name|lio
operator|->
name|linfo
operator|.
name|rxpciq
index|[
name|j
index|]
operator|.
name|s
operator|.
name|q_no
argument_list|)
expr_stmt|;
block|}
name|callout_drain
argument_list|(
operator|&
name|lio
operator|->
name|stats_timer
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oct
operator|->
name|ifcount
condition|;
name|i
operator|++
control|)
name|lio_destroy_nic_device
argument_list|(
name|oct
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"Network interface stopped\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lio_delete_glists
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|struct
name|lio
modifier|*
name|lio
parameter_list|)
block|{
name|struct
name|lio_gather
modifier|*
name|g
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|lio
operator|->
name|glist_lock
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|lio
operator|->
name|glist_lock
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|lio
operator|->
name|glist_lock
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|lio
operator|->
name|ghead
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lio
operator|->
name|linfo
operator|.
name|num_txpciq
condition|;
name|i
operator|++
control|)
block|{
do|do
block|{
name|g
operator|=
operator|(
expr|struct
name|lio_gather
operator|*
operator|)
name|lio_delete_first_node
argument_list|(
operator|&
name|lio
operator|->
name|ghead
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|g
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|g
condition|)
do|;
if|if
condition|(
operator|(
name|lio
operator|->
name|glists_virt_base
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|lio
operator|->
name|glists_virt_base
index|[
name|i
index|]
operator|!=
name|NULL
operator|)
condition|)
block|{
name|lio_dma_free
argument_list|(
name|lio
operator|->
name|glist_entry_size
operator|*
name|lio
operator|->
name|tx_qsize
argument_list|,
name|lio
operator|->
name|glists_virt_base
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|lio
operator|->
name|glists_virt_base
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|lio
operator|->
name|glists_virt_base
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|lio
operator|->
name|glists_dma_base
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|lio
operator|->
name|glists_dma_base
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|lio
operator|->
name|ghead
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|lio
operator|->
name|ghead
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lio_setup_glists
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|struct
name|lio
modifier|*
name|lio
parameter_list|,
name|int
name|num_iqs
parameter_list|)
block|{
name|struct
name|lio_gather
modifier|*
name|g
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|lio
operator|->
name|glist_lock
operator|=
name|malloc
argument_list|(
name|num_iqs
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|lio
operator|->
name|glist_lock
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|lio
operator|->
name|glist_lock
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|lio
operator|->
name|ghead
operator|=
name|malloc
argument_list|(
name|num_iqs
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|lio
operator|->
name|ghead
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|lio
operator|->
name|ghead
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|lio
operator|->
name|glist_lock
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|lio
operator|->
name|glist_lock
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|lio
operator|->
name|glist_entry_size
operator|=
name|ROUNDUP8
argument_list|(
operator|(
name|ROUNDUP4
argument_list|(
name|LIO_MAX_SG
argument_list|)
operator|>>
literal|2
operator|)
operator|*
name|LIO_SG_ENTRY_SIZE
argument_list|)
expr_stmt|;
comment|/* 	 * allocate memory to store virtual and dma base address of 	 * per glist consistent memory 	 */
name|lio
operator|->
name|glists_virt_base
operator|=
name|malloc
argument_list|(
name|num_iqs
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|lio
operator|->
name|glists_dma_base
operator|=
name|malloc
argument_list|(
name|num_iqs
operator|*
sizeof|sizeof
argument_list|(
name|vm_paddr_t
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lio
operator|->
name|glists_virt_base
operator|==
name|NULL
operator|)
operator|||
operator|(
name|lio
operator|->
name|glists_dma_base
operator|==
name|NULL
operator|)
condition|)
block|{
name|lio_delete_glists
argument_list|(
name|oct
argument_list|,
name|lio
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_iqs
condition|;
name|i
operator|++
control|)
block|{
name|mtx_init
argument_list|(
operator|&
name|lio
operator|->
name|glist_lock
index|[
name|i
index|]
argument_list|,
literal|"glist_lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|lio
operator|->
name|ghead
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|lio
operator|->
name|glists_virt_base
index|[
name|i
index|]
operator|=
name|lio_dma_alloc
argument_list|(
name|lio
operator|->
name|glist_entry_size
operator|*
name|lio
operator|->
name|tx_qsize
argument_list|,
operator|(
name|vm_paddr_t
operator|*
operator|)
operator|&
name|lio
operator|->
name|glists_dma_base
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|lio
operator|->
name|glists_virt_base
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|lio_delete_glists
argument_list|(
name|oct
argument_list|,
name|lio
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|lio
operator|->
name|tx_qsize
condition|;
name|j
operator|++
control|)
block|{
name|g
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|g
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
break|break;
name|g
operator|->
name|sg
operator|=
operator|(
expr|struct
name|lio_sg_entry
operator|*
operator|)
operator|(
operator|(
name|uint64_t
operator|)
name|lio
operator|->
name|glists_virt_base
index|[
name|i
index|]
operator|+
operator|(
name|j
operator|*
name|lio
operator|->
name|glist_entry_size
operator|)
operator|)
expr_stmt|;
name|g
operator|->
name|sg_dma_ptr
operator|=
operator|(
name|uint64_t
operator|)
name|lio
operator|->
name|glists_dma_base
index|[
name|i
index|]
operator|+
operator|(
name|j
operator|*
name|lio
operator|->
name|glist_entry_size
operator|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|lio
operator|->
name|ghead
index|[
name|i
index|]
argument_list|,
operator|&
name|g
operator|->
name|node
argument_list|,
name|entries
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|!=
name|lio
operator|->
name|tx_qsize
condition|)
block|{
name|lio_delete_glists
argument_list|(
name|oct
argument_list|,
name|lio
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|lio_stop
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|lio
modifier|*
name|lio
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|octeon_device
modifier|*
name|oct
init|=
name|lio
operator|->
name|oct_dev
decl_stmt|;
name|lio_ifstate_reset
argument_list|(
name|lio
argument_list|,
name|LIO_IFSTATE_RUNNING
argument_list|)
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
name|lio
operator|->
name|intf_open
operator|=
literal|0
expr_stmt|;
name|lio
operator|->
name|linfo
operator|.
name|link
operator|.
name|s
operator|.
name|link_up
operator|=
literal|0
expr_stmt|;
name|lio
operator|->
name|link_changes
operator|++
expr_stmt|;
name|lio_send_rx_ctrl_cmd
argument_list|(
name|lio
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Tell the stack that the interface is no longer active */
name|if_setdrvflagbits
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|,
name|IFF_DRV_RUNNING
argument_list|)
expr_stmt|;
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"Interface is stopped\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lio_check_rx_oom_status
parameter_list|(
name|struct
name|lio
modifier|*
name|lio
parameter_list|)
block|{
name|struct
name|lio_droq
modifier|*
name|droq
decl_stmt|;
name|struct
name|octeon_device
modifier|*
name|oct
init|=
name|lio
operator|->
name|oct_dev
decl_stmt|;
name|int
name|desc_refilled
decl_stmt|;
name|int
name|q
decl_stmt|,
name|q_no
init|=
literal|0
decl_stmt|;
for|for
control|(
name|q
operator|=
literal|0
init|;
name|q
operator|<
name|oct
operator|->
name|num_oqs
condition|;
name|q
operator|++
control|)
block|{
name|q_no
operator|=
name|lio
operator|->
name|linfo
operator|.
name|rxpciq
index|[
name|q
index|]
operator|.
name|s
operator|.
name|q_no
expr_stmt|;
name|droq
operator|=
name|oct
operator|->
name|droq
index|[
name|q_no
index|]
expr_stmt|;
if|if
condition|(
name|droq
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|lio_read_csr32
argument_list|(
name|oct
argument_list|,
name|droq
operator|->
name|pkts_credit_reg
argument_list|)
operator|<=
literal|0x40
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|droq
operator|->
name|lock
argument_list|)
expr_stmt|;
name|desc_refilled
operator|=
name|lio_droq_refill
argument_list|(
name|oct
argument_list|,
name|droq
argument_list|)
expr_stmt|;
comment|/* 			 * Flush the droq descriptor data to memory to be sure 			 * that when we update the credits the data in memory 			 * is accurate. 			 */
name|wmb
argument_list|()
expr_stmt|;
name|lio_write_csr32
argument_list|(
name|oct
argument_list|,
name|droq
operator|->
name|pkts_credit_reg
argument_list|,
name|desc_refilled
argument_list|)
expr_stmt|;
comment|/* make sure mmio write completes */
name|__compiler_membar
argument_list|()
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|droq
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|lio_poll_check_rx_oom_status
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
name|__unused
parameter_list|)
block|{
name|struct
name|lio_tq
modifier|*
name|rx_status_tq
init|=
name|arg
decl_stmt|;
name|struct
name|lio
modifier|*
name|lio
init|=
name|rx_status_tq
operator|->
name|ctxptr
decl_stmt|;
if|if
condition|(
name|lio_ifstate_check
argument_list|(
name|lio
argument_list|,
name|LIO_IFSTATE_RUNNING
argument_list|)
condition|)
name|lio_check_rx_oom_status
argument_list|(
name|lio
argument_list|)
expr_stmt|;
name|taskqueue_enqueue_timeout
argument_list|(
name|rx_status_tq
operator|->
name|tq
argument_list|,
operator|&
name|rx_status_tq
operator|->
name|work
argument_list|,
name|lio_ms_to_ticks
argument_list|(
literal|50
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lio_setup_rx_oom_poll_fn
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|lio
modifier|*
name|lio
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|octeon_device
modifier|*
name|oct
init|=
name|lio
operator|->
name|oct_dev
decl_stmt|;
name|struct
name|lio_tq
modifier|*
name|rx_status_tq
decl_stmt|;
name|rx_status_tq
operator|=
operator|&
name|lio
operator|->
name|rx_status_tq
expr_stmt|;
name|rx_status_tq
operator|->
name|tq
operator|=
name|taskqueue_create
argument_list|(
literal|"lio_rx_oom_status"
argument_list|,
name|M_WAITOK
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|rx_status_tq
operator|->
name|tq
argument_list|)
expr_stmt|;
if|if
condition|(
name|rx_status_tq
operator|->
name|tq
operator|==
name|NULL
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"unable to create lio rx oom status tq\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|TIMEOUT_TASK_INIT
argument_list|(
name|rx_status_tq
operator|->
name|tq
argument_list|,
operator|&
name|rx_status_tq
operator|->
name|work
argument_list|,
literal|0
argument_list|,
name|lio_poll_check_rx_oom_status
argument_list|,
operator|(
name|void
operator|*
operator|)
name|rx_status_tq
argument_list|)
expr_stmt|;
name|rx_status_tq
operator|->
name|ctxptr
operator|=
name|lio
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|rx_status_tq
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"lio%d_rx_oom_status"
argument_list|,
name|oct
operator|->
name|octeon_id
argument_list|)
expr_stmt|;
name|taskqueue_enqueue_timeout
argument_list|(
name|rx_status_tq
operator|->
name|tq
argument_list|,
operator|&
name|rx_status_tq
operator|->
name|work
argument_list|,
name|lio_ms_to_ticks
argument_list|(
literal|50
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lio_cleanup_rx_oom_poll_fn
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|lio
modifier|*
name|lio
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
if|if
condition|(
name|lio
operator|->
name|rx_status_tq
operator|.
name|tq
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|taskqueue_cancel_timeout
argument_list|(
name|lio
operator|->
name|rx_status_tq
operator|.
name|tq
argument_list|,
operator|&
name|lio
operator|->
name|rx_status_tq
operator|.
name|work
argument_list|,
name|NULL
argument_list|)
condition|)
name|taskqueue_drain_timeout
argument_list|(
name|lio
operator|->
name|rx_status_tq
operator|.
name|tq
argument_list|,
operator|&
name|lio
operator|->
name|rx_status_tq
operator|.
name|work
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|lio
operator|->
name|rx_status_tq
operator|.
name|tq
argument_list|)
expr_stmt|;
name|lio
operator|->
name|rx_status_tq
operator|.
name|tq
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|lio_destroy_nic_device
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|int
name|ifidx
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|oct
operator|->
name|props
operator|.
name|ifp
decl_stmt|;
name|struct
name|lio
modifier|*
name|lio
decl_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"%s No ifp ptr for index %d\n"
argument_list|,
name|__func__
argument_list|,
name|ifidx
argument_list|)
expr_stmt|;
return|return;
block|}
name|lio
operator|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|lio_ifstate_set
argument_list|(
name|lio
argument_list|,
name|LIO_IFSTATE_DETACH
argument_list|)
expr_stmt|;
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"NIC device cleanup\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|lio
operator|->
name|ifstate
argument_list|)
operator|&
name|LIO_IFSTATE_RUNNING
condition|)
name|lio_stop
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lio_wait_for_pending_requests
argument_list|(
name|oct
argument_list|)
condition|)
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"There were pending requests\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lio_wait_for_instr_fetch
argument_list|(
name|oct
argument_list|)
condition|)
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"IQ had pending instructions\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lio_wait_for_oq_pkts
argument_list|(
name|oct
argument_list|)
condition|)
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"OQ had pending packets\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|lio
operator|->
name|ifstate
argument_list|)
operator|&
name|LIO_IFSTATE_REGISTERED
condition|)
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|lio_tcp_lro_free
argument_list|(
name|oct
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|lio_cleanup_rx_oom_poll_fn
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|lio_delete_glists
argument_list|(
name|oct
argument_list|,
name|lio
argument_list|)
expr_stmt|;
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vlan_config
argument_list|,
name|lio
operator|->
name|vlan_attach
argument_list|)
expr_stmt|;
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vlan_unconfig
argument_list|,
name|lio
operator|->
name|vlan_detach
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lio
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|oct
operator|->
name|props
operator|.
name|gmxport
operator|=
operator|-
literal|1
expr_stmt|;
name|oct
operator|->
name|props
operator|.
name|ifp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_link_info
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|lio
modifier|*
name|lio
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|lio_ifstate_check
argument_list|(
name|lio
argument_list|,
name|LIO_IFSTATE_RESETTING
argument_list|)
operator|&&
name|lio_ifstate_check
argument_list|(
name|lio
argument_list|,
name|LIO_IFSTATE_REGISTERED
argument_list|)
condition|)
block|{
name|struct
name|octeon_link_info
modifier|*
name|linfo
init|=
operator|&
name|lio
operator|->
name|linfo
decl_stmt|;
if|if
condition|(
name|linfo
operator|->
name|link
operator|.
name|s
operator|.
name|link_up
condition|)
block|{
name|lio_dev_info
argument_list|(
name|lio
operator|->
name|oct_dev
argument_list|,
literal|"%d Mbps %s Duplex UP\n"
argument_list|,
name|linfo
operator|->
name|link
operator|.
name|s
operator|.
name|speed
argument_list|,
operator|(
name|linfo
operator|->
name|link
operator|.
name|s
operator|.
name|duplex
operator|)
condition|?
literal|"Full"
else|:
literal|"Half"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lio_dev_info
argument_list|(
name|lio
operator|->
name|oct_dev
argument_list|,
literal|"Link Down\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|lio_update_link_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|union
name|octeon_link_status
modifier|*
name|ls
parameter_list|)
block|{
name|struct
name|lio
modifier|*
name|lio
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|int
name|changed
init|=
operator|(
name|lio
operator|->
name|linfo
operator|.
name|link
operator|.
name|link_status64
operator|!=
name|ls
operator|->
name|link_status64
operator|)
decl_stmt|;
name|lio
operator|->
name|linfo
operator|.
name|link
operator|.
name|link_status64
operator|=
name|ls
operator|->
name|link_status64
expr_stmt|;
if|if
condition|(
operator|(
name|lio
operator|->
name|intf_open
operator|)
operator|&&
operator|(
name|changed
operator|)
condition|)
block|{
name|print_link_info
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|lio
operator|->
name|link_changes
operator|++
expr_stmt|;
if|if
condition|(
name|lio
operator|->
name|linfo
operator|.
name|link
operator|.
name|s
operator|.
name|link_up
condition|)
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
else|else
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * \brief Callback for rx ctrl  * @param status status of request  * @param buf pointer to resp structure  */
end_comment

begin_function
specifier|static
name|void
name|lio_rx_ctl_callback
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|,
name|uint32_t
name|status
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|lio_soft_command
modifier|*
name|sc
init|=
operator|(
expr|struct
name|lio_soft_command
operator|*
operator|)
name|buf
decl_stmt|;
name|struct
name|lio_rx_ctl_context
modifier|*
name|ctx
decl_stmt|;
name|ctx
operator|=
operator|(
expr|struct
name|lio_rx_ctl_context
operator|*
operator|)
name|sc
operator|->
name|ctxptr
expr_stmt|;
name|oct
operator|=
name|lio_get_device
argument_list|(
name|ctx
operator|->
name|octeon_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"rx ctl instruction failed. Status: %llx\n"
argument_list|,
name|LIO_CAST64
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|cond
operator|=
literal|1
expr_stmt|;
comment|/* 	 * This barrier is required to be sure that the response has been 	 * written fully before waking up the handler 	 */
name|wmb
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lio_send_rx_ctrl_cmd
parameter_list|(
name|struct
name|lio
modifier|*
name|lio
parameter_list|,
name|int
name|start_stop
parameter_list|)
block|{
name|struct
name|lio_soft_command
modifier|*
name|sc
decl_stmt|;
name|struct
name|lio_rx_ctl_context
modifier|*
name|ctx
decl_stmt|;
name|union
name|octeon_cmd
modifier|*
name|ncmd
decl_stmt|;
name|struct
name|octeon_device
modifier|*
name|oct
init|=
operator|(
expr|struct
name|octeon_device
operator|*
operator|)
name|lio
operator|->
name|oct_dev
decl_stmt|;
name|int
name|ctx_size
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|lio_rx_ctl_context
argument_list|)
decl_stmt|;
name|int
name|retval
decl_stmt|;
if|if
condition|(
name|oct
operator|->
name|props
operator|.
name|rx_on
operator|==
name|start_stop
condition|)
return|return;
name|sc
operator|=
name|lio_alloc_soft_command
argument_list|(
name|oct
argument_list|,
name|OCTEON_CMD_SIZE
argument_list|,
literal|16
argument_list|,
name|ctx_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
name|ncmd
operator|=
operator|(
expr|union
name|octeon_cmd
operator|*
operator|)
name|sc
operator|->
name|virtdptr
expr_stmt|;
name|ctx
operator|=
operator|(
expr|struct
name|lio_rx_ctl_context
operator|*
operator|)
name|sc
operator|->
name|ctxptr
expr_stmt|;
name|ctx
operator|->
name|cond
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|octeon_id
operator|=
name|lio_get_device_id
argument_list|(
name|oct
argument_list|)
expr_stmt|;
name|ncmd
operator|->
name|cmd64
operator|=
literal|0
expr_stmt|;
name|ncmd
operator|->
name|s
operator|.
name|cmd
operator|=
name|LIO_CMD_RX_CTL
expr_stmt|;
name|ncmd
operator|->
name|s
operator|.
name|param1
operator|=
name|start_stop
expr_stmt|;
name|lio_swap_8B_data
argument_list|(
operator|(
name|uint64_t
operator|*
operator|)
name|ncmd
argument_list|,
operator|(
name|OCTEON_CMD_SIZE
operator|>>
literal|3
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|iq_no
operator|=
name|lio
operator|->
name|linfo
operator|.
name|txpciq
index|[
literal|0
index|]
operator|.
name|s
operator|.
name|q_no
expr_stmt|;
name|lio_prepare_soft_command
argument_list|(
name|oct
argument_list|,
name|sc
argument_list|,
name|LIO_OPCODE_NIC
argument_list|,
name|LIO_OPCODE_NIC_CMD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|callback
operator|=
name|lio_rx_ctl_callback
expr_stmt|;
name|sc
operator|->
name|callback_arg
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|wait_time
operator|=
literal|5000
expr_stmt|;
name|retval
operator|=
name|lio_send_soft_command
argument_list|(
name|oct
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|LIO_IQ_SEND_FAILED
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Failed to send RX Control message\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Sleep on a wait queue till the cond flag indicates that the 		 * response arrived or timed-out. 		 */
name|lio_sleep_cond
argument_list|(
name|oct
argument_list|,
operator|&
name|ctx
operator|->
name|cond
argument_list|)
expr_stmt|;
name|oct
operator|->
name|props
operator|.
name|rx_on
operator|=
name|start_stop
expr_stmt|;
block|}
name|lio_free_soft_command
argument_list|(
name|oct
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lio_vlan_rx_add_vid
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|uint16_t
name|vid
parameter_list|)
block|{
name|struct
name|lio_ctrl_pkt
name|nctrl
decl_stmt|;
name|struct
name|lio
modifier|*
name|lio
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|octeon_device
modifier|*
name|oct
init|=
name|lio
operator|->
name|oct_dev
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
operator|!=
name|arg
condition|)
comment|/* Not our event */
return|return;
if|if
condition|(
operator|(
name|vid
operator|==
literal|0
operator|)
operator|||
operator|(
name|vid
operator|>
literal|4095
operator|)
condition|)
comment|/* Invalid */
return|return;
name|bzero
argument_list|(
operator|&
name|nctrl
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lio_ctrl_pkt
argument_list|)
argument_list|)
expr_stmt|;
name|nctrl
operator|.
name|ncmd
operator|.
name|cmd64
operator|=
literal|0
expr_stmt|;
name|nctrl
operator|.
name|ncmd
operator|.
name|s
operator|.
name|cmd
operator|=
name|LIO_CMD_ADD_VLAN_FILTER
expr_stmt|;
name|nctrl
operator|.
name|ncmd
operator|.
name|s
operator|.
name|param1
operator|=
name|vid
expr_stmt|;
name|nctrl
operator|.
name|iq_no
operator|=
name|lio
operator|->
name|linfo
operator|.
name|txpciq
index|[
literal|0
index|]
operator|.
name|s
operator|.
name|q_no
expr_stmt|;
name|nctrl
operator|.
name|wait_time
operator|=
literal|100
expr_stmt|;
name|nctrl
operator|.
name|lio
operator|=
name|lio
expr_stmt|;
name|nctrl
operator|.
name|cb_fn
operator|=
name|lio_ctrl_cmd_completion
expr_stmt|;
name|ret
operator|=
name|lio_send_ctrl_pkt
argument_list|(
name|lio
operator|->
name|oct_dev
argument_list|,
operator|&
name|nctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Add VLAN filter failed in core (ret: 0x%x)\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|lio_vlan_rx_kill_vid
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|uint16_t
name|vid
parameter_list|)
block|{
name|struct
name|lio_ctrl_pkt
name|nctrl
decl_stmt|;
name|struct
name|lio
modifier|*
name|lio
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|octeon_device
modifier|*
name|oct
init|=
name|lio
operator|->
name|oct_dev
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
operator|!=
name|arg
condition|)
comment|/* Not our event */
return|return;
if|if
condition|(
operator|(
name|vid
operator|==
literal|0
operator|)
operator|||
operator|(
name|vid
operator|>
literal|4095
operator|)
condition|)
comment|/* Invalid */
return|return;
name|bzero
argument_list|(
operator|&
name|nctrl
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lio_ctrl_pkt
argument_list|)
argument_list|)
expr_stmt|;
name|nctrl
operator|.
name|ncmd
operator|.
name|cmd64
operator|=
literal|0
expr_stmt|;
name|nctrl
operator|.
name|ncmd
operator|.
name|s
operator|.
name|cmd
operator|=
name|LIO_CMD_DEL_VLAN_FILTER
expr_stmt|;
name|nctrl
operator|.
name|ncmd
operator|.
name|s
operator|.
name|param1
operator|=
name|vid
expr_stmt|;
name|nctrl
operator|.
name|iq_no
operator|=
name|lio
operator|->
name|linfo
operator|.
name|txpciq
index|[
literal|0
index|]
operator|.
name|s
operator|.
name|q_no
expr_stmt|;
name|nctrl
operator|.
name|wait_time
operator|=
literal|100
expr_stmt|;
name|nctrl
operator|.
name|lio
operator|=
name|lio
expr_stmt|;
name|nctrl
operator|.
name|cb_fn
operator|=
name|lio_ctrl_cmd_completion
expr_stmt|;
name|ret
operator|=
name|lio_send_ctrl_pkt
argument_list|(
name|lio
operator|->
name|oct_dev
argument_list|,
operator|&
name|nctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Kill VLAN filter failed in core (ret: 0x%x)\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|lio_wait_for_oq_pkts
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|pending_pkts
decl_stmt|,
name|pkt_cnt
init|=
literal|0
decl_stmt|,
name|retry
init|=
literal|100
decl_stmt|;
do|do
block|{
name|pending_pkts
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LIO_MAX_OUTPUT_QUEUES
argument_list|(
name|oct
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|oct
operator|->
name|io_qmask
operator|.
name|oq
operator|&
name|BIT_ULL
argument_list|(
name|i
argument_list|)
operator|)
condition|)
continue|continue;
name|pkt_cnt
operator|=
name|lio_droq_check_hw_for_pkts
argument_list|(
name|oct
operator|->
name|droq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkt_cnt
operator|>
literal|0
condition|)
block|{
name|pending_pkts
operator|+=
name|pkt_cnt
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|oct
operator|->
name|droq
index|[
name|i
index|]
operator|->
name|droq_taskqueue
argument_list|,
operator|&
name|oct
operator|->
name|droq
index|[
name|i
index|]
operator|->
name|droq_task
argument_list|)
expr_stmt|;
block|}
block|}
name|pkt_cnt
operator|=
literal|0
expr_stmt|;
name|lio_sleep_timeout
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|retry
operator|--
operator|&&
name|pending_pkts
condition|)
do|;
return|return
operator|(
name|pkt_cnt
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lio_destroy_resources
parameter_list|(
name|struct
name|octeon_device
modifier|*
name|oct
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|refcount
decl_stmt|;
switch|switch
condition|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|oct
operator|->
name|status
argument_list|)
condition|)
block|{
case|case
name|LIO_DEV_RUNNING
case|:
case|case
name|LIO_DEV_CORE_OK
case|:
comment|/* No more instructions will be forwarded. */
name|atomic_store_rel_int
argument_list|(
operator|&
name|oct
operator|->
name|status
argument_list|,
name|LIO_DEV_IN_RESET
argument_list|)
expr_stmt|;
name|oct
operator|->
name|app_mode
operator|=
name|LIO_DRV_INVALID_APP
expr_stmt|;
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"Device state is now %s\n"
argument_list|,
name|lio_get_state_string
argument_list|(
operator|&
name|oct
operator|->
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|lio_sleep_timeout
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* fallthrough */
case|case
name|LIO_DEV_HOST_OK
case|:
comment|/* fallthrough */
case|case
name|LIO_DEV_CONSOLE_INIT_DONE
case|:
comment|/* Remove any consoles */
name|lio_remove_consoles
argument_list|(
name|oct
argument_list|)
expr_stmt|;
comment|/* fallthrough */
case|case
name|LIO_DEV_IO_QUEUES_DONE
case|:
if|if
condition|(
name|lio_wait_for_pending_requests
argument_list|(
name|oct
argument_list|)
condition|)
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"There were pending requests\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lio_wait_for_instr_fetch
argument_list|(
name|oct
argument_list|)
condition|)
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"IQ had pending instructions\n"
argument_list|)
expr_stmt|;
comment|/* 		 * Disable the input and output queues now. No more packets will 		 * arrive from Octeon, but we should wait for all packet 		 * processing to finish. 		 */
name|oct
operator|->
name|fn_list
operator|.
name|disable_io_queues
argument_list|(
name|oct
argument_list|)
expr_stmt|;
if|if
condition|(
name|lio_wait_for_oq_pkts
argument_list|(
name|oct
argument_list|)
condition|)
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"OQ had pending packets\n"
argument_list|)
expr_stmt|;
comment|/* fallthrough */
case|case
name|LIO_DEV_INTR_SET_DONE
case|:
comment|/* Disable interrupts  */
name|oct
operator|->
name|fn_list
operator|.
name|disable_interrupt
argument_list|(
name|oct
argument_list|,
name|OCTEON_ALL_INTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|oct
operator|->
name|msix_on
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oct
operator|->
name|num_msix_irqs
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|oct
operator|->
name|ioq_vector
index|[
name|i
index|]
operator|.
name|tag
operator|!=
name|NULL
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|oct
operator|->
name|device
argument_list|,
name|oct
operator|->
name|ioq_vector
index|[
name|i
index|]
operator|.
name|msix_res
argument_list|,
name|oct
operator|->
name|ioq_vector
index|[
name|i
index|]
operator|.
name|tag
argument_list|)
expr_stmt|;
name|oct
operator|->
name|ioq_vector
index|[
name|i
index|]
operator|.
name|tag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|oct
operator|->
name|ioq_vector
index|[
name|i
index|]
operator|.
name|msix_res
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|oct
operator|->
name|device
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|oct
operator|->
name|ioq_vector
index|[
name|i
index|]
operator|.
name|vector
argument_list|,
name|oct
operator|->
name|ioq_vector
index|[
name|i
index|]
operator|.
name|msix_res
argument_list|)
expr_stmt|;
name|oct
operator|->
name|ioq_vector
index|[
name|i
index|]
operator|.
name|msix_res
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* non-iov vector's argument is oct struct */
if|if
condition|(
name|oct
operator|->
name|tag
operator|!=
name|NULL
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|oct
operator|->
name|device
argument_list|,
name|oct
operator|->
name|msix_res
argument_list|,
name|oct
operator|->
name|tag
argument_list|)
expr_stmt|;
name|oct
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|oct
operator|->
name|msix_res
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|oct
operator|->
name|device
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|oct
operator|->
name|aux_vector
argument_list|,
name|oct
operator|->
name|msix_res
argument_list|)
expr_stmt|;
name|oct
operator|->
name|msix_res
operator|=
name|NULL
expr_stmt|;
block|}
name|pci_release_msi
argument_list|(
name|oct
operator|->
name|device
argument_list|)
expr_stmt|;
block|}
comment|/* fallthrough */
case|case
name|LIO_DEV_IN_RESET
case|:
case|case
name|LIO_DEV_DROQ_INIT_DONE
case|:
comment|/* Wait for any pending operations */
name|lio_mdelay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LIO_MAX_OUTPUT_QUEUES
argument_list|(
name|oct
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|oct
operator|->
name|io_qmask
operator|.
name|oq
operator|&
name|BIT_ULL
argument_list|(
name|i
argument_list|)
operator|)
condition|)
continue|continue;
name|lio_delete_droq
argument_list|(
name|oct
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* fallthrough */
case|case
name|LIO_DEV_RESP_LIST_INIT_DONE
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LIO_MAX_POSSIBLE_OUTPUT_QUEUES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|oct
operator|->
name|droq
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|oct
operator|->
name|droq
index|[
name|i
index|]
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|oct
operator|->
name|droq
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|lio_delete_response_list
argument_list|(
name|oct
argument_list|)
expr_stmt|;
comment|/* fallthrough */
case|case
name|LIO_DEV_INSTR_QUEUE_INIT_DONE
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LIO_MAX_INSTR_QUEUES
argument_list|(
name|oct
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|oct
operator|->
name|io_qmask
operator|.
name|iq
operator|&
name|BIT_ULL
argument_list|(
name|i
argument_list|)
operator|)
condition|)
continue|continue;
name|lio_delete_instr_queue
argument_list|(
name|oct
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* fallthrough */
case|case
name|LIO_DEV_MSIX_ALLOC_VECTOR_DONE
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LIO_MAX_POSSIBLE_INSTR_QUEUES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|oct
operator|->
name|instr_queue
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|oct
operator|->
name|instr_queue
index|[
name|i
index|]
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|oct
operator|->
name|instr_queue
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|lio_free_ioq_vector
argument_list|(
name|oct
argument_list|)
expr_stmt|;
comment|/* fallthrough */
case|case
name|LIO_DEV_SC_BUFF_POOL_INIT_DONE
case|:
name|lio_free_sc_buffer_pool
argument_list|(
name|oct
argument_list|)
expr_stmt|;
comment|/* fallthrough */
case|case
name|LIO_DEV_DISPATCH_INIT_DONE
case|:
name|lio_delete_dispatch_list
argument_list|(
name|oct
argument_list|)
expr_stmt|;
comment|/* fallthrough */
case|case
name|LIO_DEV_PCI_MAP_DONE
case|:
name|refcount
operator|=
name|lio_deregister_device
argument_list|(
name|oct
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw_type_is_none
argument_list|()
condition|)
name|lio_pci_flr
argument_list|(
name|oct
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|refcount
condition|)
name|oct
operator|->
name|fn_list
operator|.
name|soft_reset
argument_list|(
name|oct
argument_list|)
expr_stmt|;
name|lio_unmap_pci_barx
argument_list|(
name|oct
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lio_unmap_pci_barx
argument_list|(
name|oct
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* fallthrough */
case|case
name|LIO_DEV_PCI_ENABLE_DONE
case|:
comment|/* Disable the device, releasing the PCI INT */
name|pci_disable_busmaster
argument_list|(
name|oct
operator|->
name|device
argument_list|)
expr_stmt|;
comment|/* fallthrough */
case|case
name|LIO_DEV_BEGIN_STATE
case|:
break|break;
block|}
comment|/* end switch (oct->status) */
block|}
end_function

end_unit

