begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *   BSD LICENSE  *  *   Copyright(c) 2017 Cavium, Inc.. All rights reserved.  *   All rights reserved.  *  *   Redistribution and use in source and binary forms, with or without  *   modification, are permitted provided that the following conditions  *   are met:  *  *     * Redistributions of source code must retain the above copyright  *       notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above copyright  *       notice, this list of conditions and the following disclaimer in  *       the documentation and/or other materials provided with the  *       distribution.  *     * Neither the name of Cavium, Inc. nor the names of its  *       contributors may be used to endorse or promote products derived  *       from this software without specific prior written permission.  *  *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  *   OWNER(S) OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*$FreeBSD$*/
end_comment

begin_include
include|#
directive|include
file|"lio_bsd.h"
end_include

begin_include
include|#
directive|include
file|"lio_common.h"
end_include

begin_include
include|#
directive|include
file|"lio_droq.h"
end_include

begin_include
include|#
directive|include
file|"lio_iq.h"
end_include

begin_include
include|#
directive|include
file|"lio_response_manager.h"
end_include

begin_include
include|#
directive|include
file|"lio_device.h"
end_include

begin_include
include|#
directive|include
file|"lio_ctrl.h"
end_include

begin_include
include|#
directive|include
file|"lio_main.h"
end_include

begin_include
include|#
directive|include
file|"lio_network.h"
end_include

begin_include
include|#
directive|include
file|"lio_rxtx.h"
end_include

begin_function
name|int
name|lio_xmit
parameter_list|(
name|struct
name|lio
modifier|*
name|lio
parameter_list|,
name|struct
name|lio_instr_queue
modifier|*
name|iq
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m_headp
parameter_list|)
block|{
name|struct
name|lio_data_pkt
name|ndata
decl_stmt|;
name|union
name|lio_cmd_setup
name|cmdsetup
decl_stmt|;
name|struct
name|lio_mbuf_free_info
modifier|*
name|finfo
init|=
name|NULL
decl_stmt|;
name|struct
name|octeon_device
modifier|*
name|oct
init|=
name|iq
operator|->
name|oct_dev
decl_stmt|;
name|struct
name|lio_iq_stats
modifier|*
name|stats
decl_stmt|;
name|struct
name|octeon_instr_irh
modifier|*
name|irh
decl_stmt|;
name|struct
name|lio_request_list
modifier|*
name|tx_buf
decl_stmt|;
name|union
name|lio_tx_info
modifier|*
name|tx_info
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_head
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
name|LIO_MAX_SG
index|]
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|uint64_t
name|dptr
init|=
literal|0
decl_stmt|;
name|uint32_t
name|tag
init|=
literal|0
decl_stmt|;
name|int
name|iq_no
init|=
literal|0
decl_stmt|;
name|int
name|nsegs
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|;
name|iq_no
operator|=
name|iq
operator|->
name|txpciq
operator|.
name|s
operator|.
name|q_no
expr_stmt|;
name|tag
operator|=
name|iq_no
expr_stmt|;
name|stats
operator|=
operator|&
name|oct
operator|->
name|instr_queue
index|[
name|iq_no
index|]
operator|->
name|stats
expr_stmt|;
name|tx_buf
operator|=
name|iq
operator|->
name|request_list
operator|+
name|iq
operator|->
name|host_write_index
expr_stmt|;
comment|/* 	 * Check for all conditions in which the current packet cannot be 	 * transmitted. 	 */
if|if
condition|(
operator|!
operator|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|lio
operator|->
name|ifstate
argument_list|)
operator|&
name|LIO_IFSTATE_RUNNING
operator|)
operator|||
operator|(
operator|!
name|lio
operator|->
name|linfo
operator|.
name|link
operator|.
name|s
operator|.
name|link_up
operator|)
condition|)
block|{
name|lio_dev_info
argument_list|(
name|oct
argument_list|,
literal|"Transmit failed link_status : %d\n"
argument_list|,
name|lio
operator|->
name|linfo
operator|.
name|link
operator|.
name|s
operator|.
name|link_up
argument_list|)
expr_stmt|;
name|status
operator|=
name|ENETDOWN
expr_stmt|;
goto|goto
name|drop_packet
goto|;
block|}
if|if
condition|(
name|lio_iq_is_full
argument_list|(
name|oct
argument_list|,
name|iq_no
argument_list|)
condition|)
block|{
comment|/* Defer sending if queue is full */
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"Transmit failed iq:%d full\n"
argument_list|,
name|iq_no
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tx_iq_busy
operator|++
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|map
operator|=
name|tx_buf
operator|->
name|map
expr_stmt|;
name|status
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|iq
operator|->
name|txtag
argument_list|,
name|map
argument_list|,
operator|*
name|m_headp
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|EFBIG
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|m_defrag
argument_list|(
operator|*
name|m_headp
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|stats
operator|->
name|mbuf_defrag_failed
operator|++
expr_stmt|;
goto|goto
name|drop_packet
goto|;
block|}
operator|*
name|m_headp
operator|=
name|m
expr_stmt|;
name|status
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|iq
operator|->
name|txtag
argument_list|,
name|map
argument_list|,
operator|*
name|m_headp
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|==
name|ENOMEM
condition|)
block|{
goto|goto
name|retry
goto|;
block|}
elseif|else
if|if
condition|(
name|status
condition|)
block|{
name|stats
operator|->
name|tx_dmamap_fail
operator|++
expr_stmt|;
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"bus_dmamap_load_mbuf_sg failed with error %d. iq:%d"
argument_list|,
name|status
argument_list|,
name|iq_no
argument_list|)
expr_stmt|;
goto|goto
name|drop_packet
goto|;
block|}
name|m_head
operator|=
operator|*
name|m_headp
expr_stmt|;
comment|/* Info used to unmap and free the buffers. */
name|finfo
operator|=
operator|&
name|tx_buf
operator|->
name|finfo
expr_stmt|;
name|finfo
operator|->
name|map
operator|=
name|map
expr_stmt|;
name|finfo
operator|->
name|mb
operator|=
name|m_head
expr_stmt|;
comment|/* Prepare the attributes for the data to be passed to OSI. */
name|bzero
argument_list|(
operator|&
name|ndata
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lio_data_pkt
argument_list|)
argument_list|)
expr_stmt|;
name|ndata
operator|.
name|buf
operator|=
operator|(
name|void
operator|*
operator|)
name|finfo
expr_stmt|;
name|ndata
operator|.
name|q_no
operator|=
name|iq_no
expr_stmt|;
name|ndata
operator|.
name|datasize
operator|=
name|m_head
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|cmdsetup
operator|.
name|cmd_setup64
operator|=
literal|0
expr_stmt|;
name|cmdsetup
operator|.
name|s
operator|.
name|iq_no
operator|=
name|iq_no
expr_stmt|;
if|if
condition|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_IP
condition|)
name|cmdsetup
operator|.
name|s
operator|.
name|ip_csum
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_IP_TCP
operator||
name|CSUM_IP6_TCP
operator|)
operator|)
operator|||
operator|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_IP_UDP
operator||
name|CSUM_IP6_UDP
operator|)
operator|)
condition|)
name|cmdsetup
operator|.
name|s
operator|.
name|transport_csum
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|nsegs
operator|==
literal|1
condition|)
block|{
name|cmdsetup
operator|.
name|s
operator|.
name|u
operator|.
name|datasize
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_len
expr_stmt|;
name|lio_prepare_pci_cmd
argument_list|(
name|oct
argument_list|,
operator|&
name|ndata
operator|.
name|cmd
argument_list|,
operator|&
name|cmdsetup
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|dptr
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
name|ndata
operator|.
name|cmd
operator|.
name|cmd3
operator|.
name|dptr
operator|=
name|dptr
expr_stmt|;
name|ndata
operator|.
name|reqtype
operator|=
name|LIO_REQTYPE_NORESP_NET
expr_stmt|;
block|}
else|else
block|{
name|struct
name|lio_gather
modifier|*
name|g
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lio
operator|->
name|glist_lock
index|[
name|iq_no
index|]
argument_list|)
expr_stmt|;
name|g
operator|=
operator|(
expr|struct
name|lio_gather
operator|*
operator|)
name|lio_delete_first_node
argument_list|(
operator|&
name|lio
operator|->
name|ghead
index|[
name|iq_no
index|]
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lio
operator|->
name|glist_lock
index|[
name|iq_no
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
block|{
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"Transmit scatter gather: glist null!\n"
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|cmdsetup
operator|.
name|s
operator|.
name|gather
operator|=
literal|1
expr_stmt|;
name|cmdsetup
operator|.
name|s
operator|.
name|u
operator|.
name|gatherptrs
operator|=
name|nsegs
expr_stmt|;
name|lio_prepare_pci_cmd
argument_list|(
name|oct
argument_list|,
operator|&
name|ndata
operator|.
name|cmd
argument_list|,
operator|&
name|cmdsetup
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|g
operator|->
name|sg
argument_list|,
name|g
operator|->
name|sg_size
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|nsegs
operator|--
condition|)
block|{
name|g
operator|->
name|sg
index|[
operator|(
name|i
operator|>>
literal|2
operator|)
index|]
operator|.
name|ptr
index|[
operator|(
name|i
operator|&
literal|3
operator|)
index|]
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
expr_stmt|;
name|lio_add_sg_size
argument_list|(
operator|&
name|g
operator|->
name|sg
index|[
operator|(
name|i
operator|>>
literal|2
operator|)
index|]
argument_list|,
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
argument_list|,
operator|(
name|i
operator|&
literal|3
operator|)
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|dptr
operator|=
name|g
operator|->
name|sg_dma_ptr
expr_stmt|;
name|ndata
operator|.
name|cmd
operator|.
name|cmd3
operator|.
name|dptr
operator|=
name|dptr
expr_stmt|;
name|finfo
operator|->
name|g
operator|=
name|g
expr_stmt|;
name|ndata
operator|.
name|reqtype
operator|=
name|LIO_REQTYPE_NORESP_NET_SG
expr_stmt|;
block|}
name|irh
operator|=
operator|(
expr|struct
name|octeon_instr_irh
operator|*
operator|)
operator|&
name|ndata
operator|.
name|cmd
operator|.
name|cmd3
operator|.
name|irh
expr_stmt|;
name|tx_info
operator|=
operator|(
expr|union
name|lio_tx_info
operator|*
operator|)
operator|&
name|ndata
operator|.
name|cmd
operator|.
name|cmd3
operator|.
name|ossp
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_IP_TSO
operator||
name|CSUM_IP6_TSO
operator|)
condition|)
block|{
name|tx_info
operator|->
name|s
operator|.
name|gso_size
operator|=
name|m_head
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
expr_stmt|;
name|tx_info
operator|->
name|s
operator|.
name|gso_segs
operator|=
name|howmany
argument_list|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|m_head
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
argument_list|)
expr_stmt|;
name|stats
operator|->
name|tx_gso
operator|++
expr_stmt|;
block|}
comment|/* HW insert VLAN tag */
if|if
condition|(
name|m_head
operator|->
name|m_flags
operator|&
name|M_VLANTAG
condition|)
block|{
name|irh
operator|->
name|priority
operator|=
name|m_head
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|>>
literal|13
expr_stmt|;
name|irh
operator|->
name|vlan
operator|=
name|m_head
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|&
literal|0xfff
expr_stmt|;
block|}
name|status
operator|=
name|lio_send_data_pkt
argument_list|(
name|oct
argument_list|,
operator|&
name|ndata
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|LIO_IQ_SEND_FAILED
condition|)
goto|goto
name|retry
goto|;
if|if
condition|(
name|tx_info
operator|->
name|s
operator|.
name|gso_segs
condition|)
name|stats
operator|->
name|tx_done
operator|+=
name|tx_info
operator|->
name|s
operator|.
name|gso_segs
expr_stmt|;
else|else
name|stats
operator|->
name|tx_done
operator|++
expr_stmt|;
name|stats
operator|->
name|tx_tot_bytes
operator|+=
name|ndata
operator|.
name|datasize
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|retry
label|:
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|drop_packet
label|:
name|stats
operator|->
name|tx_dropped
operator|++
expr_stmt|;
name|lio_dev_err
argument_list|(
name|oct
argument_list|,
literal|"IQ%d Transmit dropped: %lu\n"
argument_list|,
name|iq_no
argument_list|,
name|stats
operator|->
name|tx_dropped
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
operator|*
name|m_headp
argument_list|)
expr_stmt|;
operator|*
name|m_headp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lio_mq_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|lio_instr_queue
modifier|*
name|iq
parameter_list|)
block|{
name|struct
name|lio
modifier|*
name|lio
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|next
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|!
name|lio
operator|->
name|linfo
operator|.
name|link
operator|.
name|s
operator|.
name|link_up
operator|)
condition|)
return|return
operator|(
operator|-
name|ENETDOWN
operator|)
return|;
comment|/* Process the queue */
while|while
condition|(
operator|(
name|next
operator|=
name|drbr_peek
argument_list|(
name|ifp
argument_list|,
name|iq
operator|->
name|br
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|err
operator|=
name|lio_xmit
argument_list|(
name|lio
argument_list|,
name|iq
argument_list|,
operator|&
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
name|drbr_advance
argument_list|(
name|ifp
argument_list|,
name|iq
operator|->
name|br
argument_list|)
expr_stmt|;
else|else
name|drbr_putback
argument_list|(
name|ifp
argument_list|,
name|iq
operator|->
name|br
argument_list|,
name|next
argument_list|)
expr_stmt|;
break|break;
block|}
name|drbr_advance
argument_list|(
name|ifp
argument_list|,
name|iq
operator|->
name|br
argument_list|)
expr_stmt|;
comment|/* Send a copy of the frame to the BPF listener */
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|!
name|lio
operator|->
name|linfo
operator|.
name|link
operator|.
name|s
operator|.
name|link_up
operator|)
condition|)
break|break;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lio_mq_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|lio
modifier|*
name|lio
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|octeon_device
modifier|*
name|oct
init|=
name|lio
operator|->
name|oct_dev
decl_stmt|;
name|struct
name|lio_instr_queue
modifier|*
name|iq
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|RSS
name|uint32_t
name|bucket_id
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|M_HASHTYPE_GET
argument_list|(
name|m
argument_list|)
operator|!=
name|M_HASHTYPE_NONE
condition|)
block|{
ifdef|#
directive|ifdef
name|RSS
if|if
condition|(
name|rss_hash2bucket
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
argument_list|,
name|M_HASHTYPE_GET
argument_list|(
name|m
argument_list|)
argument_list|,
operator|&
name|bucket_id
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|=
name|bucket_id
operator|%
name|oct
operator|->
name|num_iqs
expr_stmt|;
if|if
condition|(
name|bucket_id
operator|>
name|oct
operator|->
name|num_iqs
condition|)
name|lio_dev_dbg
argument_list|(
name|oct
argument_list|,
literal|"bucket_id (%d)> num_iqs (%d)\n"
argument_list|,
name|bucket_id
argument_list|,
name|oct
operator|->
name|num_iqs
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|i
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|%
name|oct
operator|->
name|num_iqs
expr_stmt|;
block|}
else|else
name|i
operator|=
name|curcpu
operator|%
name|oct
operator|->
name|num_iqs
expr_stmt|;
name|iq
operator|=
name|oct
operator|->
name|instr_queue
index|[
name|i
index|]
expr_stmt|;
name|err
operator|=
name|drbr_enqueue
argument_list|(
name|ifp
argument_list|,
name|iq
operator|->
name|br
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|mtx_trylock
argument_list|(
operator|&
name|iq
operator|->
name|enq_lock
argument_list|)
condition|)
block|{
name|lio_mq_start_locked
argument_list|(
name|ifp
argument_list|,
name|iq
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|iq
operator|->
name|enq_lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|void
name|lio_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|lio
modifier|*
name|lio
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|octeon_device
modifier|*
name|oct
init|=
name|lio
operator|->
name|oct_dev
decl_stmt|;
name|struct
name|lio_instr_queue
modifier|*
name|iq
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LIO_MAX_INSTR_QUEUES
argument_list|(
name|oct
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|oct
operator|->
name|io_qmask
operator|.
name|iq
operator|&
name|BIT_ULL
argument_list|(
name|i
argument_list|)
operator|)
condition|)
continue|continue;
name|iq
operator|=
name|oct
operator|->
name|instr_queue
index|[
name|i
index|]
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|iq
operator|->
name|enq_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|buf_ring_dequeue_sc
argument_list|(
name|iq
operator|->
name|br
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|iq
operator|->
name|enq_lock
argument_list|)
expr_stmt|;
block|}
name|if_qflush
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

