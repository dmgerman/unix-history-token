begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2007-2011 Broadcom Corporation. All rights reserved.  *  *    Gary Zambrano<zambrano@broadcom.com>  *    David Christensen<davidch@broadcom.com>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of Broadcom Corporation nor the name of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written consent.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS'  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * The following controllers are supported by this driver:  *   BCM57710  A1+  *   BCM57711  A0+  *   BCM57711E A0+  *  * The following controllers are not supported by this driver:  *   BCM57710  A0 (pre-production)  *  * External PHY References:  * ------------------------  * BCM8073  - Dual Port 10GBase-KR Ethernet PHY  * BCM8705  - 10Gb Ethernet Serial Transceiver  * BCM8706  - 10Gb Ethernet LRM PHY  * BCM8726  - Dual Port 10Gb Ethernet LRM PHY  * BCM8727  - Dual Port 10Gb Ethernet LRM PHY  * BCM8481  - Single Port 10GBase-T Ethernet PHY  * BCM84823 - Dual Port 10GBase-T Ethernet PHY  * SFX7101  - Solarflare 10GBase-T Ethernet PHY  *  */
end_comment

begin_include
include|#
directive|include
file|"opt_bxe.h"
end_include

begin_include
include|#
directive|include
file|"bxe_include.h"
end_include

begin_include
include|#
directive|include
file|"if_bxe.h"
end_include

begin_include
include|#
directive|include
file|"bxe_init.h"
end_include

begin_include
include|#
directive|include
file|"hw_dump_reg_st.h"
end_include

begin_include
include|#
directive|include
file|"dump_e1.h"
end_include

begin_include
include|#
directive|include
file|"dump_e1h.h"
end_include

begin_include
include|#
directive|include
file|"bxe_self_test.h"
end_include

begin_comment
comment|/* BXE Debug Options */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BXE_DEBUG
end_ifdef

begin_decl_stmt
name|uint32_t
name|bxe_debug
init|=
name|BXE_WARN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*          0 = Never              */
end_comment

begin_comment
comment|/*          1 = 1 in 2,147,483,648 */
end_comment

begin_comment
comment|/*        256 = 1 in     8,388,608 */
end_comment

begin_comment
comment|/*       2048 = 1 in     1,048,576 */
end_comment

begin_comment
comment|/*      65536 = 1 in        32,768 */
end_comment

begin_comment
comment|/*    1048576 = 1 in         2,048 */
end_comment

begin_comment
comment|/*  268435456 =	1 in             8 */
end_comment

begin_comment
comment|/*  536870912 = 1 in             4 */
end_comment

begin_comment
comment|/* 1073741824 = 1 in             2 */
end_comment

begin_comment
comment|/* Controls how often to simulate an mbuf allocation failure. */
end_comment

begin_decl_stmt
name|int
name|bxe_debug_mbuf_allocation_failure
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls how often to simulate a DMA mapping failure.  */
end_comment

begin_decl_stmt
name|int
name|bxe_debug_dma_map_addr_failure
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls how often to simulate a bootcode failure. */
end_comment

begin_decl_stmt
name|int
name|bxe_debug_bootcode_running_failure
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MDIO_INDIRECT_REG_ADDR
value|0x1f
end_define

begin_define
define|#
directive|define
name|MDIO_SET_REG_BANK
parameter_list|(
name|sc
parameter_list|,
name|reg_bank
parameter_list|)
define|\
value|bxe_mdio22_write(sc, MDIO_INDIRECT_REG_ADDR, reg_bank)
end_define

begin_define
define|#
directive|define
name|MDIO_ACCESS_TIMEOUT
value|1000
end_define

begin_define
define|#
directive|define
name|BMAC_CONTROL_RX_ENABLE
value|2
end_define

begin_comment
comment|/* BXE Build Time Options */
end_comment

begin_comment
comment|/* #define BXE_NVRAM_WRITE 1 */
end_comment

begin_define
define|#
directive|define
name|BXE_USE_DMAE
value|1
end_define

begin_comment
comment|/*  * PCI Device ID Table  * Used by bxe_probe() to identify the devices supported by this driver.  */
end_comment

begin_define
define|#
directive|define
name|BXE_DEVDESC_MAX
value|64
end_define

begin_decl_stmt
specifier|static
name|struct
name|bxe_type
name|bxe_devs
index|[]
init|=
block|{
comment|/* BCM57710 Controllers and OEM boards. */
block|{
name|BRCM_VENDORID
block|,
name|BRCM_DEVICEID_BCM57710
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|"Broadcom NetXtreme II BCM57710 10GbE"
block|}
block|,
comment|/* BCM57711 Controllers and OEM boards. */
block|{
name|BRCM_VENDORID
block|,
name|BRCM_DEVICEID_BCM57711
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|"Broadcom NetXtreme II BCM57711 10GbE"
block|}
block|,
comment|/* BCM57711E Controllers and OEM boards. */
block|{
name|BRCM_VENDORID
block|,
name|BRCM_DEVICEID_BCM57711E
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|"Broadcom NetXtreme II BCM57711E 10GbE"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * FreeBSD device entry points.  */
end_comment

begin_function_decl
specifier|static
name|int
name|bxe_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_shutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Driver local functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|bxe_tunables_set
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_print_adapter_info
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_probe_pci_caps
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_link_settings_supported
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_link_settings_requested
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_hwinfo_function_get
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_hwinfo_port_get
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_hwinfo_common_get
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_undi_unload
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_setup_leading
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_stop_leading
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_setup_multi
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_stop_multi
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_stop_locked
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_alloc_buf_rings
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_free_buf_rings
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_init_locked
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_wait_ramrod
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_init_str_wr
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
specifier|const
name|uint32_t
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_init_ind_wr
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
specifier|const
name|uint32_t
modifier|*
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_init_wr_64
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
specifier|const
name|uint32_t
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_write_big_buf
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_init_fill
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|int
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_init_block
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_release_resources
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_reg_wr_ind
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|bxe_reg_rd_ind
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_post_dmae
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|struct
name|dmae_command
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_wb_wr
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|uint32_t
name|bxe_reg_poll
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_mc_assert
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_panic_dump
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_int_enable
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_int_disable
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_nvram_acquire_lock
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_nvram_release_lock
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_nvram_enable_access
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_nvram_disable_access
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_nvram_read_dword
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_nvram_read
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint8_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|BXE_NVRAM_WRITE_SUPPORT
end_ifdef

begin_function_decl
specifier|static
name|int
name|bxe_nvram_write_dword
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_nvram_write1
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint8_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_nvram_write
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint8_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|bxe_nvram_test
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|bxe_ack_sb
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|,
name|uint16_t
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|uint16_t
name|bxe_update_fpsb_idx
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint16_t
name|bxe_ack_int
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_sp_event
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
parameter_list|,
name|union
name|eth_rx_cqe
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_acquire_hw_lock
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_release_hw_lock
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_acquire_phy_lock
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_release_phy_lock
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_pmf_update
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_init_port_minmax
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_link_attn
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_sp_post
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_acquire_alr
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_release_alr
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint16_t
name|bxe_update_dsb_idx
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_attn_int_asserted
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|bxe_attn_int_deasserted0
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|bxe_attn_int_deasserted1
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|bxe_attn_int_deasserted2
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|bxe_attn_int_deasserted3
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_attn_int_deasserted
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_attn_int
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_stats_storm_post
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_stats_init
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_stats_hw_post
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_stats_comp
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_stats_pmf_update
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_stats_port_base_init
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_stats_port_init
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_stats_func_base_init
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_stats_func_init
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_stats_start
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_stats_pmf_start
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_stats_restart
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_stats_bmac_update
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_stats_emac_update
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_stats_hw_update
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_stats_storm_update
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_stats_func_base_update
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_stats_update
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_stats_port_stop
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_stats_stop
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_stats_do_nothing
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_stats_handle
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|enum
name|bxe_stats_event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_tx_encap
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_tx_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_tx_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|bxe_fastpath
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_tx_mq_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_tx_mq_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|bxe_fastpath
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_mq_flush
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|int
name|bxe_has_rx_work
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|int
name|bxe_has_tx_work
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_intr_legacy
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_task_sp
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_intr_sp
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_task_fp
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_intr_fp
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_zero_sb
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_init_sb
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|struct
name|host_status_block
modifier|*
parameter_list|,
name|bus_addr_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_zero_def_sb
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_init_def_sb
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|struct
name|host_def_status_block
modifier|*
parameter_list|,
name|bus_addr_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_update_coalesce
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|bxe_update_rx_prod
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|struct
name|bxe_fastpath
modifier|*
parameter_list|,
name|uint16_t
parameter_list|,
name|uint16_t
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_clear_sge_mask_next_elems
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|bxe_init_sge_ring_bit_mask
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_alloc_tpa_mbuf
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_fill_tpa_pool
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_free_tpa_pool
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_alloc_rx_sge_mbuf
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_fill_sg_chain
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_free_sg_chain
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_alloc_rx_bd_mbuf
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_fill_rx_bd_chain
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_free_rx_bd_chain
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_mutexes_alloc
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_mutexes_free
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_clear_rx_chains
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_init_rx_chains
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_clear_tx_chains
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_init_tx_chains
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_init_sp_ring
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_init_context
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_init_ind_table
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_set_client_config
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_set_storm_rx_mode
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_init_internal_common
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_init_internal_port
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_init_internal_func
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_init_internal
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_init_nic
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_lb_pckt
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_int_mem_test
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_enable_blocks_attention
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_init_pxp
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_init_common
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_init_port
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_ilt_wr
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|bus_addr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_init_func
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_init_hw
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_fw_command
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_host_structures_free
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_dma_map_addr
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_dma_segment_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_host_structures_alloc
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_set_mac_addr_e1
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_set_mac_addr_e1h
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_set_rx_mode
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_reset_func
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_reset_port
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_reset_common
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_reset_chip
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_ifmedia_status
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|bxe_update_last_max_sge
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_update_sge_prod
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
parameter_list|,
name|struct
name|eth_fast_path_rx_cqe
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_tpa_start
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
parameter_list|,
name|uint16_t
parameter_list|,
name|uint16_t
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_fill_frag_mbuf
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|struct
name|bxe_fastpath
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|eth_fast_path_rx_cqe
modifier|*
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_tpa_stop
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|struct
name|bxe_fastpath
modifier|*
parameter_list|,
name|uint16_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|union
name|eth_rx_cqe
modifier|*
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_rxeof
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_txeof
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_watchdog
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_tick
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_add_sysctls
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_write_dmae_phys_len
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|bus_addr_t
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|bxe_write_dmae
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|bus_addr_t
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|bxe_read_dmae
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bxe_set_gpio
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uint32_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bxe_get_gpio
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bxe_set_spio
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bxe_set_gpio_int
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uint32_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * BXE Debug Data Structure Dump Routines  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BXE_DEBUG
end_ifdef

begin_function_decl
specifier|static
name|int
name|bxe_sysctl_driver_state
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_sysctl_hw_state
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_sysctl_dump_fw
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_sysctl_dump_rx_cq_chain
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_sysctl_dump_rx_bd_chain
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_sysctl_dump_tx_chain
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_sysctl_reg_read
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_sysctl_breakpoint
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__noinline
name|void
name|bxe_validate_rx_packet
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
parameter_list|,
name|uint16_t
parameter_list|,
name|union
name|eth_rx_cqe
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_grcdump
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__noinline
name|void
name|bxe_dump_enet
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__noinline
name|void
name|bxe_dump_mbuf
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__noinline
name|void
name|bxe_dump_tx_mbuf_chain
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__noinline
name|void
name|bxe_dump_rx_mbuf_chain
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__noinline
name|void
name|bxe_dump_tx_parsing_bd
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|eth_tx_parse_bd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__noinline
name|void
name|bxe_dump_txbd
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
parameter_list|,
name|int
parameter_list|,
name|union
name|eth_tx_bd_types
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__noinline
name|void
name|bxe_dump_rxbd
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|eth_rx_bd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__noinline
name|void
name|bxe_dump_cqe
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
parameter_list|,
name|int
parameter_list|,
name|union
name|eth_rx_cqe
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__noinline
name|void
name|bxe_dump_tx_chain
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__noinline
name|void
name|bxe_dump_rx_cq_chain
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__noinline
name|void
name|bxe_dump_rx_bd_chain
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__noinline
name|void
name|bxe_dump_status_block
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__noinline
name|void
name|bxe_dump_stats_block
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__noinline
name|void
name|bxe_dump_fp_state
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__noinline
name|void
name|bxe_dump_port_state_locked
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__noinline
name|void
name|bxe_dump_link_vars_state_locked
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__noinline
name|void
name|bxe_dump_link_params_state_locked
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__noinline
name|void
name|bxe_dump_driver_state
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__noinline
name|void
name|bxe_dump_hw_state
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__noinline
name|void
name|bxe_dump_fw
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_decode_mb_msgs
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_decode_ramrod_cmd
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_breakpoint
parameter_list|(
name|struct
name|bxe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|BXE_DRIVER_VERSION
value|"1.5.52"
end_define

begin_function_decl
specifier|static
name|void
name|bxe_init_e1_firmware
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_init_e1h_firmware
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * FreeBSD device dispatch table.  */
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|bxe_methods
index|[]
init|=
block|{
comment|/* Device interface (device_if.h) */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|bxe_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|bxe_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|bxe_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bxe_shutdown
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|bxe_driver
init|=
block|{
literal|"bxe"
block|,
name|bxe_methods
block|,
expr|sizeof
operator|(
expr|struct
name|bxe_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|bxe_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|bxe
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|bxe
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|bxe
argument_list|,
name|pci
argument_list|,
name|bxe_driver
argument_list|,
name|bxe_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Tunable device values  */
end_comment

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|bxe
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"bxe driver parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Allowable values are TRUE (1) or FALSE (0). */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bxe_dcc_enable
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.bxe.dcc_enable"
argument_list|,
operator|&
name|bxe_dcc_enable
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_bxe
argument_list|,
name|OID_AUTO
argument_list|,
name|dcc_enable
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|bxe_dcc_enable
argument_list|,
literal|0
argument_list|,
literal|"dcc Enable/Disable"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Allowable values are TRUE (1) or FALSE (0). */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bxe_tso_enable
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.bxe.tso_enable"
argument_list|,
operator|&
name|bxe_tso_enable
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_bxe
argument_list|,
name|OID_AUTO
argument_list|,
name|tso_enable
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|bxe_tso_enable
argument_list|,
literal|0
argument_list|,
literal|"TSO Enable/Disable"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Allowable values are 0 (IRQ), 1 (MSI/IRQ), and 2 (MSI-X/MSI/IRQ). */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bxe_int_mode
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.bxe.int_mode"
argument_list|,
operator|&
name|bxe_int_mode
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_bxe
argument_list|,
name|OID_AUTO
argument_list|,
name|int_mode
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|bxe_int_mode
argument_list|,
literal|0
argument_list|,
literal|"Interrupt (MSI-X|MSI|INTx) mode"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Specifies the number of queues that will be used when a multi-queue  * RSS mode is selected  using bxe_multi_mode below.  *  * Allowable values are 0 (Auto) or 1 to MAX_CONTEXT (fixed queue number).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bxe_queue_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.bxe.queue_count"
argument_list|,
operator|&
name|bxe_queue_count
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_bxe
argument_list|,
name|OID_AUTO
argument_list|,
name|queue_count
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|bxe_queue_count
argument_list|,
literal|0
argument_list|,
literal|"Multi-Queue queue count"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * ETH_RSS_MODE_DISABLED (0)  * Disables all multi-queue/packet sorting algorithms.  All  * received frames are routed to a single receive queue.  *  * ETH_RSS_MODE_REGULAR (1)  * The default mode which assigns incoming frames to receive  * queues according to RSS (i.e a 2-tuple match on the source/  * destination IP address or a 4-tuple match on the source/  * destination IP address and the source/destination TCP port).  *  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bxe_multi_mode
init|=
name|ETH_RSS_MODE_REGULAR
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.bxe.multi_mode"
argument_list|,
operator|&
name|bxe_multi_mode
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_bxe
argument_list|,
name|OID_AUTO
argument_list|,
name|multi_mode
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|bxe_multi_mode
argument_list|,
literal|0
argument_list|,
literal|"Multi-Queue Mode"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Host interrupt coalescing is controller by these values.  * The first frame always causes an interrupt but subsequent  * frames are coalesced until the RX/TX ticks timer value  * expires and another interrupt occurs.  (Ticks are measured  * in microseconds.)  */
end_comment

begin_decl_stmt
specifier|static
name|uint32_t
name|bxe_rx_ticks
init|=
literal|25
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.bxe.rx_ticks"
argument_list|,
operator|&
name|bxe_rx_ticks
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_bxe
argument_list|,
name|OID_AUTO
argument_list|,
name|rx_ticks
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|bxe_rx_ticks
argument_list|,
literal|0
argument_list|,
literal|"Receive ticks"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|bxe_tx_ticks
init|=
literal|50
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.bxe.tx_ticks"
argument_list|,
operator|&
name|bxe_tx_ticks
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_bxe
argument_list|,
name|OID_AUTO
argument_list|,
name|tx_ticks
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|bxe_tx_ticks
argument_list|,
literal|0
argument_list|,
literal|"Transmit ticks"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Allows the PCIe maximum read request size value to be manually  * set during initialization rather than automatically determined  * by the driver.  *  * Allowable values are:  * -1 (Auto), 0 (128B), 1 (256B), 2 (512B), 3 (1KB)  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bxe_mrrs
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.bxe.mrrs"
argument_list|,
operator|&
name|bxe_mrrs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_bxe
argument_list|,
name|OID_AUTO
argument_list|,
name|mrrs
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|bxe_mrrs
argument_list|,
literal|0
argument_list|,
literal|"PCIe maximum read request size."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * Allows setting the maximum number of received frames to process  * during an interrupt.  *  * Allowable values are:  * -1 (Unlimited), 0 (None), otherwise specifies the number of RX frames.  */
end_comment

begin_comment
unit|static int bxe_rx_limit = -1; TUNABLE_INT("hw.bxe.rx_limit",&bxe_rx_limit); SYSCTL_UINT(_hw_bxe, OID_AUTO, rx_limit, CTLFLAG_RDTUN,&bxe_rx_limit,     0, "Maximum received frames processed during an interrupt.");
comment|/*  * Allows setting the maximum number of transmit frames to process  * during an interrupt.  *  * Allowable values are:  * -1 (Unlimited), 0 (None), otherwise specifies the number of TX frames.  */
end_comment

begin_endif
unit|static int bxe_tx_limit = -1; TUNABLE_INT("hw.bxe.tx_limit",&bxe_tx_limit); SYSCTL_UINT(_hw_bxe, OID_AUTO, tx_limit, CTLFLAG_RDTUN,&bxe_tx_limit, 	0, "Maximum transmit frames processed during an interrupt.");
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Global variables  */
end_comment

begin_comment
comment|/* 0 is common, 1 is port 0, 2 is port 1. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|load_count
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tracks whether MCP firmware is running. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nomcp
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|BXE_DEBUG
end_ifdef

begin_comment
comment|/*  * A debug version of the 32 bit OS register write function to  * capture/display values written to the controller.  *  * Returns:  *   None.  */
end_comment

begin_function
name|void
name|bxe_reg_write32
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|offset
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
if|if
condition|(
operator|(
name|offset
operator|%
literal|4
operator|)
operator|!=
literal|0
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): Warning! Unaligned write to 0x%jX!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|uintmax_t
operator|)
name|offset
argument_list|)
expr_stmt|;
block|}
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_INSANE_REGS
argument_list|,
literal|"%s(): offset = 0x%jX, val = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|uintmax_t
operator|)
name|offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|bxe_btag
argument_list|,
name|sc
operator|->
name|bxe_bhandle
argument_list|,
name|offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * A debug version of the 16 bit OS register write function to  * capture/display values written to the controller.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_reg_write16
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|offset
parameter_list|,
name|uint16_t
name|val
parameter_list|)
block|{
if|if
condition|(
operator|(
name|offset
operator|%
literal|2
operator|)
operator|!=
literal|0
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): Warning! Unaligned write to 0x%jX!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|uintmax_t
operator|)
name|offset
argument_list|)
expr_stmt|;
block|}
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_INSANE_REGS
argument_list|,
literal|"%s(): offset = 0x%jX, val = 0x%04X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|uintmax_t
operator|)
name|offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|bus_space_write_2
argument_list|(
name|sc
operator|->
name|bxe_btag
argument_list|,
name|sc
operator|->
name|bxe_bhandle
argument_list|,
name|offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * A debug version of the 8 bit OS register write function to  * capture/display values written to the controller.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_reg_write8
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|offset
parameter_list|,
name|uint8_t
name|val
parameter_list|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_INSANE_REGS
argument_list|,
literal|"%s(): offset = 0x%jX, val = 0x%02X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|uintmax_t
operator|)
name|offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|bxe_btag
argument_list|,
name|sc
operator|->
name|bxe_bhandle
argument_list|,
name|offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * A debug version of the 32 bit OS register read function to  * capture/display values read from the controller.  *  * Returns:  *   32bit value read.  */
end_comment

begin_function
name|uint32_t
name|bxe_reg_read32
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|offset
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
if|if
condition|(
operator|(
name|offset
operator|%
literal|4
operator|)
operator|!=
literal|0
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): Warning! Unaligned read from 0x%jX!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|uintmax_t
operator|)
name|offset
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|bxe_btag
argument_list|,
name|sc
operator|->
name|bxe_bhandle
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_INSANE_REGS
argument_list|,
literal|"%s(): offset = 0x%jX, val = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|uintmax_t
operator|)
name|offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * A debug version of the 16 bit OS register read function to  * capture/display values read from the controller.  *  * Returns:  *   16bit value read.  */
end_comment

begin_function
specifier|static
name|uint16_t
name|bxe_reg_read16
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|offset
parameter_list|)
block|{
name|uint16_t
name|val
decl_stmt|;
if|if
condition|(
operator|(
name|offset
operator|%
literal|2
operator|)
operator|!=
literal|0
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): Warning! Unaligned read from 0x%jX!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|uintmax_t
operator|)
name|offset
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|bus_space_read_2
argument_list|(
name|sc
operator|->
name|bxe_btag
argument_list|,
name|sc
operator|->
name|bxe_bhandle
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_INSANE_REGS
argument_list|,
literal|"%s(): offset = 0x%jX, val = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|uintmax_t
operator|)
name|offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * A debug version of the 8 bit OS register write function to  * capture/display values written to the controller.  *  * Returns:  *   8bit value read.  */
end_comment

begin_function
specifier|static
name|uint8_t
name|bxe_reg_read8
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|offset
parameter_list|)
block|{
name|uint8_t
name|val
init|=
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|bxe_btag
argument_list|,
name|sc
operator|->
name|bxe_bhandle
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_INSANE_REGS
argument_list|,
literal|"%s(): offset = 0x%jX, val = 0x%02X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|uintmax_t
operator|)
name|offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|bxe_read_mf_cfg
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|func
decl_stmt|,
name|vn
decl_stmt|;
for|for
control|(
name|vn
operator|=
name|VN_0
init|;
name|vn
operator|<
name|E1HVN_MAX
condition|;
name|vn
operator|++
control|)
block|{
name|func
operator|=
literal|2
operator|*
name|vn
operator|+
name|BP_PORT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mf_config
index|[
name|vn
index|]
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|mf_cfg
operator|.
name|func_mf_config
index|[
name|func
index|]
operator|.
name|config
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_e1h_disable
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|port
decl_stmt|;
name|port
operator|=
name|BP_PORT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LLH0_FUNC_EN
operator|+
name|port
operator|*
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bxe_ifp
operator|->
name|if_drv_flags
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_e1h_enable
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|port
decl_stmt|;
name|port
operator|=
name|BP_PORT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LLH0_FUNC_EN
operator|+
name|port
operator|*
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bxe_ifp
operator|->
name|if_drv_flags
operator|=
name|IFF_DRV_RUNNING
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Calculates the sum of vn_min_rates.  * It's needed for further normalizing of the min_rates.  * Returns:  *   sum of vn_min_rates.  *     or  *   0 - if all the min_rates are 0. In the later case fainess  * 	 algorithm should be deactivated. If not all min_rates are  * 	 zero then those that are zeroes will be set to 1.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_calc_vn_wsum
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|vn_cfg
decl_stmt|,
name|vn_min_rate
decl_stmt|;
name|int
name|all_zero
decl_stmt|,
name|vn
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
argument_list|)
expr_stmt|;
name|all_zero
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|vn_wsum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|vn
operator|=
name|VN_0
init|;
name|vn
operator|<
name|E1HVN_MAX
condition|;
name|vn
operator|++
control|)
block|{
name|vn_cfg
operator|=
name|sc
operator|->
name|mf_config
index|[
name|vn
index|]
expr_stmt|;
name|vn_min_rate
operator|=
operator|(
operator|(
name|vn_cfg
operator|&
name|FUNC_MF_CFG_MIN_BW_MASK
operator|)
operator|>>
name|FUNC_MF_CFG_MIN_BW_SHIFT
operator|)
operator|*
literal|100
expr_stmt|;
comment|/* Skip hidden vns */
if|if
condition|(
name|vn_cfg
operator|&
name|FUNC_MF_CFG_FUNC_HIDE
condition|)
continue|continue;
comment|/* If min rate is zero - set it to 1. */
if|if
condition|(
operator|!
name|vn_min_rate
condition|)
name|vn_min_rate
operator|=
name|DEF_MIN_RATE
expr_stmt|;
else|else
name|all_zero
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|vn_wsum
operator|+=
name|vn_min_rate
expr_stmt|;
block|}
comment|/* ... only if all min rates are zeros - disable fairness */
if|if
condition|(
name|all_zero
condition|)
name|sc
operator|->
name|cmng
operator|.
name|flags
operator|.
name|cmng_enables
operator|&=
operator|~
name|CMNG_FLAGS_PER_PORT_FAIRNESS_VN
expr_stmt|;
else|else
name|sc
operator|->
name|cmng
operator|.
name|flags
operator|.
name|cmng_enables
operator||=
name|CMNG_FLAGS_PER_PORT_FAIRNESS_VN
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_init_vn_minmax
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|vn
parameter_list|)
block|{
name|struct
name|rate_shaping_vars_per_vn
name|m_rs_vn
decl_stmt|;
name|struct
name|fairness_vars_per_vn
name|m_fair_vn
decl_stmt|;
name|uint32_t
name|vn_cfg
decl_stmt|;
name|uint16_t
name|vn_min_rate
decl_stmt|,
name|vn_max_rate
decl_stmt|;
name|int
name|func
decl_stmt|,
name|i
decl_stmt|;
name|vn_cfg
operator|=
name|sc
operator|->
name|mf_config
index|[
name|vn
index|]
expr_stmt|;
name|func
operator|=
literal|2
operator|*
name|vn
operator|+
name|BP_PORT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
argument_list|)
expr_stmt|;
comment|/* If function is hidden - set min and max to zeroes. */
if|if
condition|(
name|vn_cfg
operator|&
name|FUNC_MF_CFG_FUNC_HIDE
condition|)
block|{
name|vn_min_rate
operator|=
literal|0
expr_stmt|;
name|vn_max_rate
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|vn_min_rate
operator|=
operator|(
operator|(
name|vn_cfg
operator|&
name|FUNC_MF_CFG_MIN_BW_MASK
operator|)
operator|>>
name|FUNC_MF_CFG_MIN_BW_SHIFT
operator|)
operator|*
literal|100
expr_stmt|;
comment|/* 		 * If fairness is enabled (i.e. not all min rates are zero), 		 * and if the current min rate is zero, set it to 1. 		 * This is a requirement of the algorithm. 		 */
if|if
condition|(
name|sc
operator|->
name|vn_wsum
operator|&&
operator|(
name|vn_min_rate
operator|==
literal|0
operator|)
condition|)
name|vn_min_rate
operator|=
name|DEF_MIN_RATE
expr_stmt|;
name|vn_max_rate
operator|=
operator|(
operator|(
name|vn_cfg
operator|&
name|FUNC_MF_CFG_MAX_BW_MASK
operator|)
operator|>>
name|FUNC_MF_CFG_MAX_BW_SHIFT
operator|)
operator|*
literal|100
expr_stmt|;
if|if
condition|(
name|vn_max_rate
operator|==
literal|0
condition|)
return|return;
block|}
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_INFO_LOAD
argument_list|,
literal|"%s(): func %d: vn_min_rate = %d, vn_max_rate = %d, wsum = %d.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|func
argument_list|,
name|vn_min_rate
argument_list|,
name|vn_max_rate
argument_list|,
name|sc
operator|->
name|vn_wsum
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|m_rs_vn
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rate_shaping_vars_per_vn
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|m_fair_vn
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fairness_vars_per_vn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Global VNIC counter - maximal Mbps for this VNIC. */
name|m_rs_vn
operator|.
name|vn_counter
operator|.
name|rate
operator|=
name|vn_max_rate
expr_stmt|;
comment|/* Quota - number of bytes transmitted in this period. */
name|m_rs_vn
operator|.
name|vn_counter
operator|.
name|quota
operator|=
operator|(
name|vn_max_rate
operator|*
name|RS_PERIODIC_TIMEOUT_USEC
operator|)
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vn_wsum
condition|)
block|{
comment|/* 		 * Credit for each period of the fairness algorithm.  The 		 * number of bytes in T_FAIR (the VNIC shares the port rate). 		 * vn_wsum should not be larger than 10000, thus 		 * T_FAIR_COEF / (8 * vn_wsum) will always be grater than zero. 		 */
name|m_fair_vn
operator|.
name|vn_credit_delta
operator|=
name|max
argument_list|(
call|(
name|uint32_t
call|)
argument_list|(
name|vn_min_rate
operator|*
operator|(
name|T_FAIR_COEF
operator|/
operator|(
literal|8
operator|*
name|sc
operator|->
name|vn_wsum
operator|)
operator|)
argument_list|)
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|sc
operator|->
name|cmng
operator|.
name|fair_vars
operator|.
name|fair_threshold
operator|*
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|func
operator|=
name|BP_FUNC
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Store it to internal memory */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|rate_shaping_vars_per_vn
argument_list|)
operator|/
literal|4
condition|;
name|i
operator|++
control|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_XSTORM_INTMEM
operator|+
name|XSTORM_RATE_SHAPING_PER_VN_VARS_OFFSET
argument_list|(
name|func
argument_list|)
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
argument_list|,
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|(
operator|&
name|m_rs_vn
operator|)
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|fairness_vars_per_vn
argument_list|)
operator|/
literal|4
condition|;
name|i
operator|++
control|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_XSTORM_INTMEM
operator|+
name|XSTORM_FAIRNESS_PER_VN_VARS_OFFSET
argument_list|(
name|func
argument_list|)
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
argument_list|,
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|(
operator|&
name|m_fair_vn
operator|)
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_congestionmgmt
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|readshm
parameter_list|)
block|{
name|int
name|vn
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
argument_list|)
expr_stmt|;
comment|/* Read mf conf from shmem. */
if|if
condition|(
name|readshm
condition|)
name|bxe_read_mf_cfg
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Init rate shaping and fairness contexts */
name|bxe_init_port_minmax
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* vn_weight_sum and enable fairness if not 0 */
name|bxe_calc_vn_wsum
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* calculate and set min-max rate for each vn */
for|for
control|(
name|vn
operator|=
literal|0
init|;
name|vn
operator|<
name|E1HVN_MAX
condition|;
name|vn
operator|++
control|)
name|bxe_init_vn_minmax
argument_list|(
name|sc
argument_list|,
name|vn
argument_list|)
expr_stmt|;
comment|/* Always enable rate shaping and fairness. */
name|sc
operator|->
name|cmng
operator|.
name|flags
operator|.
name|cmng_enables
operator||=
name|CMNG_FLAGS_PER_PORT_RATE_SHAPING_VN
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_LOAD
argument_list|,
literal|"%s(): Rate shaping set\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|vn_wsum
condition|)
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_INFO_LOAD
argument_list|,
literal|"%s(): All MIN values "
literal|"are zeroes, fairness is disabled\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_dcc_event
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|dcc_event
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|port
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|dcc_event
operator|&
name|DRV_STATUS_DCC_DISABLE_ENABLE_PF
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|mf_config
index|[
name|BP_E1HVN
argument_list|(
name|sc
argument_list|)
index|]
operator|&
name|FUNC_MF_CFG_FUNC_DISABLED
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_INFO_LOAD
argument_list|,
literal|"%s(): mf_cfg function "
literal|"disabled\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|state
operator|=
name|BXE_STATE_DISABLED
expr_stmt|;
name|bxe_e1h_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_INFO_LOAD
argument_list|,
literal|"%s(): mf_cfg function "
literal|"enabled\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|state
operator|=
name|BXE_STATE_OPEN
expr_stmt|;
name|bxe_e1h_enable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|dcc_event
operator|&=
operator|~
name|DRV_STATUS_DCC_DISABLE_ENABLE_PF
expr_stmt|;
block|}
if|if
condition|(
name|dcc_event
operator|&
name|DRV_STATUS_DCC_BANDWIDTH_ALLOCATION
condition|)
block|{
name|port
operator|=
name|BP_PORT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_congestionmgmt
argument_list|(
name|sc
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|cmng_struct_per_port
argument_list|)
operator|/
literal|4
condition|;
name|i
operator|++
control|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_XSTORM_INTMEM
operator|+
name|XSTORM_CMNG_PER_PORT_VARS_OFFSET
argument_list|(
name|port
argument_list|)
operator|+
name|i
operator|*
literal|4
argument_list|,
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|(
operator|&
name|sc
operator|->
name|cmng
operator|)
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dcc_event
operator|&=
operator|~
name|DRV_STATUS_DCC_BANDWIDTH_ALLOCATION
expr_stmt|;
block|}
comment|/* Report results to MCP */
if|if
condition|(
name|dcc_event
condition|)
name|bxe_fw_command
argument_list|(
name|sc
argument_list|,
name|DRV_MSG_CODE_DCC_FAILURE
argument_list|)
expr_stmt|;
else|else
name|bxe_fw_command
argument_list|(
name|sc
argument_list|,
name|DRV_MSG_CODE_DCC_OK
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Device probe function.  *  * Compares the device to the driver's list of supported devices and  * reports back to the OS whether this is the right driver for the device.  *  * Returns:  *   BUS_PROBE_DEFAULT on success, positive value on failure.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|bxe_type
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|descbuf
decl_stmt|;
name|uint16_t
name|did
decl_stmt|,
name|sdid
decl_stmt|,
name|svid
decl_stmt|,
name|vid
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|t
operator|=
name|bxe_devs
expr_stmt|;
comment|/* Get the data for the device to be probed. */
name|vid
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|did
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|svid
operator|=
name|pci_get_subvendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sdid
operator|=
name|pci_get_subdevice
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_LOAD
argument_list|,
literal|"%s(); VID = 0x%04X, DID = 0x%04X, SVID = 0x%04X, "
literal|"SDID = 0x%04X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|vid
argument_list|,
name|did
argument_list|,
name|svid
argument_list|,
name|sdid
argument_list|)
expr_stmt|;
comment|/* Look through the list of known devices for a match. */
while|while
condition|(
name|t
operator|->
name|bxe_name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|vid
operator|==
name|t
operator|->
name|bxe_vid
operator|)
operator|&&
operator|(
name|did
operator|==
name|t
operator|->
name|bxe_did
operator|)
operator|&&
operator|(
operator|(
name|svid
operator|==
name|t
operator|->
name|bxe_svid
operator|)
operator|||
operator|(
name|t
operator|->
name|bxe_svid
operator|==
name|PCI_ANY_ID
operator|)
operator|)
operator|&&
operator|(
operator|(
name|sdid
operator|==
name|t
operator|->
name|bxe_sdid
operator|)
operator|||
operator|(
name|t
operator|->
name|bxe_sdid
operator|==
name|PCI_ANY_ID
operator|)
operator|)
condition|)
block|{
name|descbuf
operator|=
name|malloc
argument_list|(
name|BXE_DEVDESC_MAX
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|descbuf
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* Print out the device identity. */
name|snprintf
argument_list|(
name|descbuf
argument_list|,
name|BXE_DEVDESC_MAX
argument_list|,
literal|"%s (%c%d) BXE v:%s\n"
argument_list|,
name|t
operator|->
name|bxe_name
argument_list|,
operator|(
operator|(
operator|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_REVID
argument_list|,
literal|4
argument_list|)
operator|&
literal|0xf0
operator|)
operator|>>
literal|4
operator|)
operator|+
literal|'A'
operator|)
argument_list|,
operator|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_REVID
argument_list|,
literal|4
argument_list|)
operator|&
literal|0xf
operator|)
argument_list|,
name|BXE_DRIVER_VERSION
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|descbuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|descbuf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
name|t
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Prints useful adapter info.  *  * Returns:  *   None.  */
end_comment

begin_comment
comment|/* ToDo: Create a sysctl for this info. */
end_comment

begin_function
specifier|static
name|void
name|bxe_print_adapter_info
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_EXTREME_LOAD
argument_list|)
expr_stmt|;
comment|/* Hardware chip info. */
name|BXE_PRINTF
argument_list|(
literal|"ASIC (0x%08X); "
argument_list|,
name|sc
operator|->
name|common
operator|.
name|chip_id
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Rev (%c%d); "
argument_list|,
operator|(
name|CHIP_REV
argument_list|(
name|sc
argument_list|)
operator|>>
literal|12
operator|)
operator|+
literal|'A'
argument_list|,
operator|(
name|CHIP_METAL
argument_list|(
name|sc
argument_list|)
operator|>>
literal|4
operator|)
argument_list|)
expr_stmt|;
comment|/* Bus info. */
name|printf
argument_list|(
literal|"Bus (PCIe x%d, "
argument_list|,
name|sc
operator|->
name|pcie_link_width
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|pcie_link_speed
condition|)
block|{
case|case
literal|1
case|:
name|printf
argument_list|(
literal|"2.5Gbps"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printf
argument_list|(
literal|"5Gbps"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Unknown link speed"
argument_list|)
expr_stmt|;
block|}
comment|/* Device features. */
name|printf
argument_list|(
literal|"); Flags ("
argument_list|)
expr_stmt|;
comment|/* Miscellaneous flags. */
if|if
condition|(
name|sc
operator|->
name|msi_count
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"MSI"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msix_count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"|"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"MSI-X"
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|TPA_ENABLED
argument_list|(
name|sc
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"|"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"TPA"
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"); Queues ("
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|multi_mode
condition|)
block|{
case|case
name|ETH_RSS_MODE_DISABLED
case|:
name|printf
argument_list|(
literal|"None"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ETH_RSS_MODE_REGULAR
case|:
name|printf
argument_list|(
literal|"RSS:%d"
argument_list|,
name|sc
operator|->
name|num_queues
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Unknown"
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"); BD's (RX:%d,TX:%d"
argument_list|,
operator|(
name|int
operator|)
name|USABLE_RX_BD
argument_list|,
operator|(
name|int
operator|)
name|USABLE_TX_BD
argument_list|)
expr_stmt|;
comment|/* Firmware versions and device features. */
name|printf
argument_list|(
literal|"); Firmware (%d.%d.%d); Bootcode (%d.%d.%d)\n"
argument_list|,
name|BCM_5710_FW_MAJOR_VERSION
argument_list|,
name|BCM_5710_FW_MINOR_VERSION
argument_list|,
name|BCM_5710_FW_REVISION_VERSION
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|sc
operator|->
name|common
operator|.
name|bc_ver
operator|&
literal|0xff0000
operator|)
operator|>>
literal|16
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|sc
operator|->
name|common
operator|.
name|bc_ver
operator|&
literal|0x00ff00
operator|)
operator|>>
literal|8
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|sc
operator|->
name|common
operator|.
name|bc_ver
operator|&
literal|0x0000ff
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_EXTREME_LOAD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Release any interrupts allocated by the driver.  *  * Returns:  *   None  */
end_comment

begin_function
specifier|static
name|void
name|bxe_interrupt_free
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_RESET
operator||
name|BXE_VERBOSE_UNLOAD
argument_list|)
expr_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msix_count
operator|>
literal|0
condition|)
block|{
comment|/* Free MSI-X resources. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|msix_count
condition|;
name|i
operator|++
control|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
operator|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator||
name|BXE_VERBOSE_INTR
operator|)
argument_list|,
literal|"%s(): Releasing MSI-X[%d] "
literal|"vector.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|bxe_msix_res
index|[
name|i
index|]
operator|&&
name|sc
operator|->
name|bxe_msix_rid
index|[
name|i
index|]
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|bxe_msix_rid
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|bxe_msix_res
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|msi_count
operator|>
literal|0
condition|)
block|{
comment|/* Free MSI resources. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|msi_count
condition|;
name|i
operator|++
control|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
operator|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator||
name|BXE_VERBOSE_INTR
operator|)
argument_list|,
literal|"%s(): Releasing MSI[%d] "
literal|"vector.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|bxe_msi_res
index|[
name|i
index|]
operator|&&
name|sc
operator|->
name|bxe_msi_rid
index|[
name|i
index|]
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|bxe_msi_rid
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|bxe_msi_res
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Free legacy interrupt resources. */
name|DBPRINT
argument_list|(
name|sc
argument_list|,
operator|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator||
name|BXE_VERBOSE_INTR
operator|)
argument_list|,
literal|"%s(): Releasing legacy interrupt.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|bxe_irq_res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|bxe_irq_rid
argument_list|,
name|sc
operator|->
name|bxe_irq_res
argument_list|)
expr_stmt|;
block|}
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_RESET
operator||
name|BXE_VERBOSE_UNLOAD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function determines and allocates the appropriate  * interrupt based on system capabilites and user request.  *  * The user may force a particular interrupt mode, specify  * the number of receive queues, specify the method for  * distribuitng received frames to receive queues, or use  * the default settings which will automatically select the  * best supported combination.  In addition, the OS may or  * may not support certain combinations of these settings.  * This routine attempts to reconcile the settings requested  * by the user with the capabilites available from the system  * to select the optimal combination of features.  *  * Returns:  *   0 = Success, !0 = Failure.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_interrupt_alloc
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|rid
decl_stmt|,
name|rc
decl_stmt|;
name|int
name|msi_count
decl_stmt|,
name|msi_required
decl_stmt|,
name|msi_allocated
decl_stmt|;
name|int
name|msix_count
decl_stmt|,
name|msix_required
decl_stmt|,
name|msix_allocated
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_INTR
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|msi_count
operator|=
name|msi_required
operator|=
name|msi_allocated
operator|=
literal|0
expr_stmt|;
name|msix_count
operator|=
name|msix_required
operator|=
name|msix_allocated
operator|=
literal|0
expr_stmt|;
comment|/* Get the number of available MSI/MSI-X interrupts from the OS. */
if|if
condition|(
name|sc
operator|->
name|int_mode
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|bxe_cap_flags
operator|&
name|BXE_MSIX_CAPABLE_FLAG
condition|)
name|msix_count
operator|=
name|pci_msix_count
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|bxe_cap_flags
operator|&
name|BXE_MSI_CAPABLE_FLAG
condition|)
name|msi_count
operator|=
name|pci_msi_count
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
operator|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_INTR
operator|)
argument_list|,
literal|"%s(): %d MSI and %d MSI-X vectors available.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|msi_count
argument_list|,
name|msix_count
argument_list|)
expr_stmt|;
block|}
comment|/* Try allocating MSI-X interrupt resources. */
if|if
condition|(
operator|(
name|sc
operator|->
name|bxe_cap_flags
operator|&
name|BXE_MSIX_CAPABLE_FLAG
operator|)
operator|&&
operator|(
name|sc
operator|->
name|int_mode
operator|>
literal|1
operator|)
operator|&&
operator|(
name|msix_count
operator|>
literal|0
operator|)
operator|&&
operator|(
name|msix_count
operator|>=
name|sc
operator|->
name|num_queues
operator|)
condition|)
block|{
comment|/* Ask for the necessary number	of MSI-X vectors. */
if|if
condition|(
name|sc
operator|->
name|num_queues
operator|==
literal|1
condition|)
name|msix_allocated
operator|=
name|msix_required
operator|=
literal|2
expr_stmt|;
else|else
name|msix_allocated
operator|=
name|msix_required
operator|=
name|sc
operator|->
name|num_queues
operator|+
literal|1
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
operator|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_INTR
operator|)
argument_list|,
literal|"%s(): Requesting %d MSI-X vectors.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|msix_required
argument_list|)
expr_stmt|;
comment|/* BSD resource identifier */
name|rid
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|pci_alloc_msix
argument_list|(
name|dev
argument_list|,
operator|&
name|msix_allocated
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
operator|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_INTR
operator|)
argument_list|,
literal|"%s(): Required/Allocated (%d/%d) MSI-X vector(s).\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|msix_required
argument_list|,
name|msix_allocated
argument_list|)
expr_stmt|;
comment|/* Make sure we got all the interrupts we asked for. */
if|if
condition|(
name|msix_allocated
operator|>=
name|msix_required
condition|)
block|{
name|sc
operator|->
name|msix_count
operator|=
name|msix_required
expr_stmt|;
name|msi_count
operator|=
literal|0
expr_stmt|;
comment|/* Allocate the MSI-X vectors. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msix_required
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|bxe_msix_rid
index|[
name|i
index|]
operator|=
name|rid
operator|+
name|i
operator|+
name|BP_L_ID
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bxe_msix_res
index|[
name|i
index|]
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|bxe_msix_rid
index|[
name|i
index|]
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
comment|/* Report any IRQ allocation errors. */
if|if
condition|(
name|sc
operator|->
name|bxe_msix_res
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Failed to map MSI-X[%d] vector!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
operator|(
literal|3
operator|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bxe_interrupt_alloc_exit
goto|;
block|}
block|}
block|}
else|else
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): MSI-X allocation failed!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* Release any resources acquired. */
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msix_count
operator|=
name|msix_count
operator|=
literal|0
expr_stmt|;
comment|/* We'll try MSI next. */
name|sc
operator|->
name|int_mode
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* Try allocating MSI vector resources. */
if|if
condition|(
operator|(
name|sc
operator|->
name|bxe_cap_flags
operator|&
name|BXE_MSI_CAPABLE_FLAG
operator|)
operator|&&
operator|(
name|sc
operator|->
name|int_mode
operator|>
literal|0
operator|)
operator|&&
operator|(
name|msi_count
operator|>
literal|0
operator|)
operator|&&
operator|(
name|msi_count
operator|>=
name|sc
operator|->
name|num_queues
operator|)
condition|)
block|{
comment|/* Ask for the necessary number	of MSI vectors. */
if|if
condition|(
name|sc
operator|->
name|num_queues
operator|==
literal|1
condition|)
name|msi_required
operator|=
name|msi_allocated
operator|=
literal|1
expr_stmt|;
else|else
name|msi_required
operator|=
name|msi_allocated
operator|=
name|BXE_MSI_VECTOR_COUNT
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
operator|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_INTR
operator|)
argument_list|,
literal|"%s(): Requesting %d MSI vectors.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|msi_required
argument_list|)
expr_stmt|;
name|rid
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|pci_alloc_msi
argument_list|(
name|dev
argument_list|,
operator|&
name|msi_allocated
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
operator|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_INTR
operator|)
argument_list|,
literal|"%s(): Required/Allocated (%d/%d) MSI vector(s).\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|msi_required
argument_list|,
name|msi_allocated
argument_list|)
expr_stmt|;
comment|/* 			 * Make sure we got all the vectors we asked for. 			 * XXX 			 * FreeBSD always gives 8 even if we ask for less. 			 */
if|if
condition|(
name|msi_required
operator|>=
name|msi_allocated
condition|)
block|{
name|sc
operator|->
name|msi_count
operator|=
name|msi_required
expr_stmt|;
comment|/* Allocate the MSI vectors. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msi_required
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|bxe_msi_rid
index|[
name|i
index|]
operator|=
name|i
operator|+
name|rid
expr_stmt|;
name|sc
operator|->
name|bxe_msi_res
index|[
name|i
index|]
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|bxe_msi_rid
index|[
name|i
index|]
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
comment|/* Report any IRQ allocation errors. */
if|if
condition|(
name|sc
operator|->
name|bxe_msi_res
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Failed to map MSI vector (%d)!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
operator|(
name|i
operator|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bxe_interrupt_alloc_exit
goto|;
block|}
block|}
block|}
block|}
else|else
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): MSI allocation failed!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* Release any resources acquired. */
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msi_count
operator|=
name|msi_count
operator|=
literal|0
expr_stmt|;
comment|/* We'll try INTx next. */
name|sc
operator|->
name|int_mode
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Try allocating INTx resources. */
if|if
condition|(
name|sc
operator|->
name|int_mode
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|num_queues
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|multi_mode
operator|=
name|ETH_RSS_MODE_DISABLED
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
operator|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_INTR
operator|)
argument_list|,
literal|"%s(): Requesting legacy INTx interrupt.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|bxe_irq_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
comment|/* Report any IRQ allocation errors. */
if|if
condition|(
name|sc
operator|->
name|bxe_irq_res
operator|==
name|NULL
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): PCI map interrupt failed!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bxe_interrupt_alloc_exit
goto|;
block|}
name|sc
operator|->
name|bxe_irq_rid
operator|=
name|rid
expr_stmt|;
block|}
name|DBPRINT
argument_list|(
name|sc
argument_list|,
operator|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_INTR
operator|)
argument_list|,
literal|"%s(): Actual: int_mode = %d, multi_mode = %d, num_queues = %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|int_mode
argument_list|,
name|sc
operator|->
name|multi_mode
argument_list|,
name|sc
operator|->
name|num_queues
argument_list|)
expr_stmt|;
name|bxe_interrupt_alloc_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_INTR
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function releases taskqueues.  *  * Returns:  *   None  */
end_comment

begin_function
specifier|static
name|void
name|bxe_interrupt_detach
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|BXE_TASK
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
endif|#
directive|endif
name|device_t
name|dev
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_UNLOAD
argument_list|)
expr_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
ifdef|#
directive|ifdef
name|BXE_TASK
comment|/* Free the OS taskqueue resources. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|tq
operator|!=
name|NULL
condition|)
block|{
name|taskqueue_drain
argument_list|(
name|fp
operator|->
name|tq
argument_list|,
operator|&
name|fp
operator|->
name|task
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|fp
operator|->
name|tq
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|tq
operator|!=
name|NULL
condition|)
block|{
name|taskqueue_drain
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|sc
operator|->
name|task
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|sc
operator|->
name|tq
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Release interrupt resources. */
if|if
condition|(
name|sc
operator|->
name|msix_count
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|msix_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|bxe_msix_tag
index|[
name|i
index|]
operator|&&
name|sc
operator|->
name|bxe_msix_res
index|[
name|i
index|]
condition|)
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|bxe_msix_res
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|bxe_msix_tag
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|msi_count
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|msi_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|bxe_msi_tag
index|[
name|i
index|]
operator|&&
name|sc
operator|->
name|bxe_msi_res
index|[
name|i
index|]
condition|)
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|bxe_msi_res
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|bxe_msi_tag
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|bxe_irq_tag
operator|!=
name|NULL
condition|)
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|bxe_irq_res
argument_list|,
name|sc
operator|->
name|bxe_irq_tag
argument_list|)
expr_stmt|;
block|}
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_UNLOAD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function enables interrupts and attachs to the ISR.  *  * When using multiple MSI/MSI-X vectors the first vector  * is used for slowpath operations while all remaining  * vectors are used for fastpath operations.  If only a  * single MSI/MSI-X vector is used (SINGLE_ISR) then the  * ISR must look for both slowpath and fastpath completions.  *  * Returns:  *   0 = Success, !0 = Failure.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_interrupt_attach
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_INTR
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|BXE_TASK
comment|/* Setup the slowpath deferred task queue. */
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|task
argument_list|,
literal|0
argument_list|,
name|bxe_task_sp
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"bxe_spq"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|sc
operator|->
name|tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|sc
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s spq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Setup interrupt handlers. */
if|if
condition|(
name|sc
operator|->
name|msix_count
operator|>
literal|0
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
operator|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_INTR
operator|)
argument_list|,
literal|"%s(): Enabling slowpath MSI-X[0] vector.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* 		 * Setup the interrupt handler.  Note that we pass the 		 * driver instance to the interrupt handler for the 		 * slowpath. 		 */
name|rc
operator|=
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|bxe_msix_res
index|[
literal|0
index|]
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|bxe_intr_sp
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|bxe_msix_tag
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Failed to allocate MSI-X[0] vector!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
goto|goto
name|bxe_interrupt_attach_exit
goto|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800504
name|bus_describe_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|bxe_msix_res
index|[
literal|0
index|]
argument_list|,
name|sc
operator|->
name|bxe_msix_tag
index|[
literal|0
index|]
argument_list|,
literal|"sp"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Now initialize the fastpath vectors. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|sc
operator|->
name|num_queues
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
operator|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_INTR
operator|)
argument_list|,
literal|"%s(): Enabling MSI-X[%d] vector.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 			 * Setup the interrupt handler. Note that we pass the 			 * fastpath context to the interrupt handler in this 			 * case. Also the first msix_res was used by the sp. 			 */
name|rc
operator|=
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|bxe_msix_res
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|bxe_intr_fp
argument_list|,
name|fp
argument_list|,
operator|&
name|sc
operator|->
name|bxe_msix_tag
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Failed to allocate MSI-X[%d] vector!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
operator|(
name|i
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|bxe_interrupt_attach_exit
goto|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800504
name|bus_describe_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|bxe_msix_res
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|sc
operator|->
name|bxe_msix_tag
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
literal|"fp[%02d]"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Bind the fastpath instance to a CPU. */
if|if
condition|(
name|sc
operator|->
name|num_queues
operator|>
literal|1
condition|)
block|{
name|bus_bind_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|bxe_msix_res
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BXE_TASK
name|TASK_INIT
argument_list|(
operator|&
name|fp
operator|->
name|task
argument_list|,
literal|0
argument_list|,
name|bxe_task_fp
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"bxe_fpq"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|fp
operator|->
name|tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|fp
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s fpq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fp
operator|->
name|state
operator|=
name|BXE_FP_STATE_IRQ
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|msi_count
operator|>
literal|0
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
operator|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_INTR
operator|)
argument_list|,
literal|"%s(): Enabling slowpath MSI[0] vector.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* 		 * Setup the interrupt handler. Note that we pass the driver 		 * instance to the interrupt handler for the slowpath. 		 */
name|rc
operator|=
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|bxe_msi_res
index|[
literal|0
index|]
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|bxe_intr_sp
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|bxe_msi_tag
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Failed to allocate MSI[0] vector!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
goto|goto
name|bxe_interrupt_attach_exit
goto|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800504
name|bus_describe_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|bxe_msi_res
index|[
literal|0
index|]
argument_list|,
name|sc
operator|->
name|bxe_msi_tag
index|[
literal|0
index|]
argument_list|,
literal|"sp"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Now initialize the fastpath vectors. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|sc
operator|->
name|num_queues
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
operator|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_INTR
operator|)
argument_list|,
literal|"%s(): Enabling MSI[%d] vector.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 			 * Setup the interrupt handler. Note that we pass the 			 * fastpath context to the interrupt handler in this 			 * case. 			 */
name|rc
operator|=
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|bxe_msi_res
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|bxe_intr_fp
argument_list|,
name|fp
argument_list|,
operator|&
name|sc
operator|->
name|bxe_msi_tag
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Failed to allocate MSI[%d] vector!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
operator|(
name|i
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|bxe_interrupt_attach_exit
goto|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800504
name|bus_describe_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|bxe_msi_res
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|sc
operator|->
name|bxe_msi_tag
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
literal|"fp[%02d]"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BXE_TASK
name|TASK_INIT
argument_list|(
operator|&
name|fp
operator|->
name|task
argument_list|,
literal|0
argument_list|,
name|bxe_task_fp
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"bxe_fpq"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|fp
operator|->
name|tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|fp
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s fpq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|BXE_TASK
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
literal|0
index|]
expr_stmt|;
endif|#
directive|endif
name|DBPRINT
argument_list|(
name|sc
argument_list|,
operator|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_INTR
operator|)
argument_list|,
literal|"%s(): Enabling INTx interrupts.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* 		 * Setup the interrupt handler.  Note that we pass the 		 * driver instance to the interrupt handler which 		 * will handle both the slowpath and fastpath. 		 */
name|rc
operator|=
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|bxe_irq_res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|bxe_intr_legacy
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|bxe_irq_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Failed to allocate interrupt!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
goto|goto
name|bxe_interrupt_attach_exit
goto|;
block|}
ifdef|#
directive|ifdef
name|BXE_TASK
name|TASK_INIT
argument_list|(
operator|&
name|fp
operator|->
name|task
argument_list|,
literal|0
argument_list|,
name|bxe_task_fp
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"bxe_fpq"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|fp
operator|->
name|tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|fp
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s fpq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|bxe_interrupt_attach_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_INTR
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * PCI Capabilities Probe Function.  *  * Walks the PCI capabiites list for the device to find what features are  * supported.  These capabilites may be enabled/disabled by firmware so it's  * best to walk the list rather than hard code any values.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_probe_pci_caps
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
name|uint16_t
name|link_status
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_EXTREME_LOAD
argument_list|)
expr_stmt|;
comment|/* Check if PCI Power Management capability is enabled. */
if|if
condition|(
name|pci_find_cap
argument_list|(
name|dev
argument_list|,
name|PCIY_PMG
argument_list|,
operator|&
name|reg
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_EXTREME_LOAD
argument_list|,
literal|"%s(): Found PM capability at 0x%04X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|sc
operator|->
name|pm_cap
operator|=
name|reg
expr_stmt|;
block|}
block|}
comment|/* Check if PCIe capability is enabled. */
if|if
condition|(
name|pci_find_cap
argument_list|(
name|dev
argument_list|,
name|PCIY_EXPRESS
argument_list|,
operator|&
name|reg
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|link_status
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|reg
operator|+
literal|0x12
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_EXTREME_LOAD
argument_list|,
literal|"%s(): Found PCIe capability at 0x%04X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Handle PCIe 2.0 workarounds for the 57710. */
if|if
condition|(
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* Workaround for 57710 errata E4_57710_27462. */
name|sc
operator|->
name|pcie_link_speed
operator|=
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
literal|0x3d04
argument_list|)
operator|&
operator|(
literal|1
operator|<<
literal|24
operator|)
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
comment|/* Workaround for 57710 errata E4_57710_27488. */
name|sc
operator|->
name|pcie_link_width
operator|=
operator|(
name|link_status
operator|>>
literal|4
operator|)
operator|&
literal|0x3f
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|pcie_link_speed
operator|>
literal|1
condition|)
name|sc
operator|->
name|pcie_link_width
operator|=
operator|(
operator|(
name|link_status
operator|>>
literal|4
operator|)
operator|&
literal|0x3f
operator|)
operator|>>
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|pcie_link_speed
operator|=
name|link_status
operator|&
literal|0xf
expr_stmt|;
name|sc
operator|->
name|pcie_link_width
operator|=
operator|(
name|link_status
operator|>>
literal|4
operator|)
operator|&
literal|0x3f
expr_stmt|;
block|}
name|sc
operator|->
name|bxe_cap_flags
operator||=
name|BXE_PCIE_CAPABLE_FLAG
expr_stmt|;
name|sc
operator|->
name|pcie_cap
operator|=
name|reg
expr_stmt|;
block|}
block|}
comment|/* Check if MSI capability is enabled. */
if|if
condition|(
name|pci_find_cap
argument_list|(
name|dev
argument_list|,
name|PCIY_MSI
argument_list|,
operator|&
name|reg
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_EXTREME_LOAD
argument_list|,
literal|"%s(): Found MSI capability at 0x%04X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bxe_cap_flags
operator||=
name|BXE_MSI_CAPABLE_FLAG
expr_stmt|;
block|}
block|}
comment|/* Check if MSI-X capability is enabled. */
if|if
condition|(
name|pci_find_cap
argument_list|(
name|dev
argument_list|,
name|PCIY_MSIX
argument_list|,
operator|&
name|reg
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_EXTREME_LOAD
argument_list|,
literal|"%s(): Found MSI-X capability at 0x%04X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bxe_cap_flags
operator||=
name|BXE_MSIX_CAPABLE_FLAG
expr_stmt|;
block|}
block|}
name|DBEXIT
argument_list|(
name|BXE_EXTREME_LOAD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Setup firmware pointers for BCM57710.  *  * Returns:  *   None  */
end_comment

begin_function
specifier|static
name|void
name|bxe_init_e1_firmware
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|INIT_OPS
argument_list|(
name|sc
argument_list|)
operator|=
operator|(
expr|struct
name|raw_op
operator|*
operator|)
name|init_ops_e1
expr_stmt|;
name|INIT_DATA
argument_list|(
name|sc
argument_list|)
operator|=
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|init_data_e1
expr_stmt|;
name|INIT_OPS_OFFSETS
argument_list|(
name|sc
argument_list|)
operator|=
operator|(
specifier|const
name|uint16_t
operator|*
operator|)
name|init_ops_offsets_e1
expr_stmt|;
name|INIT_TSEM_INT_TABLE_DATA
argument_list|(
name|sc
argument_list|)
operator|=
name|tsem_int_table_data_e1
expr_stmt|;
name|INIT_TSEM_PRAM_DATA
argument_list|(
name|sc
argument_list|)
operator|=
name|tsem_pram_data_e1
expr_stmt|;
name|INIT_USEM_INT_TABLE_DATA
argument_list|(
name|sc
argument_list|)
operator|=
name|usem_int_table_data_e1
expr_stmt|;
name|INIT_USEM_PRAM_DATA
argument_list|(
name|sc
argument_list|)
operator|=
name|usem_pram_data_e1
expr_stmt|;
name|INIT_XSEM_INT_TABLE_DATA
argument_list|(
name|sc
argument_list|)
operator|=
name|xsem_int_table_data_e1
expr_stmt|;
name|INIT_XSEM_PRAM_DATA
argument_list|(
name|sc
argument_list|)
operator|=
name|xsem_pram_data_e1
expr_stmt|;
name|INIT_CSEM_INT_TABLE_DATA
argument_list|(
name|sc
argument_list|)
operator|=
name|csem_int_table_data_e1
expr_stmt|;
name|INIT_CSEM_PRAM_DATA
argument_list|(
name|sc
argument_list|)
operator|=
name|csem_pram_data_e1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Setup firmware pointers for BCM57711.  *  * Returns:  *   None  */
end_comment

begin_function
specifier|static
name|void
name|bxe_init_e1h_firmware
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|INIT_OPS
argument_list|(
name|sc
argument_list|)
operator|=
operator|(
expr|struct
name|raw_op
operator|*
operator|)
name|init_ops_e1h
expr_stmt|;
name|INIT_DATA
argument_list|(
name|sc
argument_list|)
operator|=
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|init_data_e1h
expr_stmt|;
name|INIT_OPS_OFFSETS
argument_list|(
name|sc
argument_list|)
operator|=
operator|(
specifier|const
name|uint16_t
operator|*
operator|)
name|init_ops_offsets_e1h
expr_stmt|;
name|INIT_TSEM_INT_TABLE_DATA
argument_list|(
name|sc
argument_list|)
operator|=
name|tsem_int_table_data_e1h
expr_stmt|;
name|INIT_TSEM_PRAM_DATA
argument_list|(
name|sc
argument_list|)
operator|=
name|tsem_pram_data_e1h
expr_stmt|;
name|INIT_USEM_INT_TABLE_DATA
argument_list|(
name|sc
argument_list|)
operator|=
name|usem_int_table_data_e1h
expr_stmt|;
name|INIT_USEM_PRAM_DATA
argument_list|(
name|sc
argument_list|)
operator|=
name|usem_pram_data_e1h
expr_stmt|;
name|INIT_XSEM_INT_TABLE_DATA
argument_list|(
name|sc
argument_list|)
operator|=
name|xsem_int_table_data_e1h
expr_stmt|;
name|INIT_XSEM_PRAM_DATA
argument_list|(
name|sc
argument_list|)
operator|=
name|xsem_pram_data_e1h
expr_stmt|;
name|INIT_CSEM_INT_TABLE_DATA
argument_list|(
name|sc
argument_list|)
operator|=
name|csem_int_table_data_e1h
expr_stmt|;
name|INIT_CSEM_PRAM_DATA
argument_list|(
name|sc
argument_list|)
operator|=
name|csem_pram_data_e1h
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Sets up pointers for loading controller firmware.  *  * Returns:  *   0 = Success, !0 = Failure  */
end_comment

begin_function
specifier|static
name|int
name|bxe_init_firmware
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
name|bxe_init_e1_firmware
argument_list|(
name|sc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
condition|)
name|bxe_init_e1h_firmware
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): No firmware to support chip revision!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENXIO
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_tunables_set
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* 	 * Get our starting point for interrupt mode/number of queues. 	 * We will progressively step down from MSI-X to MSI to INTx 	 * and reduce the number of receive queues as necessary to 	 * match the system capabilities. 	 */
name|sc
operator|->
name|multi_mode
operator|=
name|bxe_multi_mode
expr_stmt|;
name|sc
operator|->
name|int_mode
operator|=
name|bxe_int_mode
expr_stmt|;
name|sc
operator|->
name|tso_enable
operator|=
name|bxe_tso_enable
expr_stmt|;
comment|/* 	 * Verify the Priority -> Receive Queue mappings. 	 */
if|if
condition|(
name|sc
operator|->
name|int_mode
operator|>
literal|0
condition|)
block|{
comment|/* Multi-queue modes require MSI/MSI-X. */
switch|switch
condition|(
name|sc
operator|->
name|multi_mode
condition|)
block|{
case|case
name|ETH_RSS_MODE_DISABLED
case|:
comment|/* No multi-queue mode requested. */
name|sc
operator|->
name|num_queues
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ETH_RSS_MODE_REGULAR
case|:
if|if
condition|(
name|sc
operator|->
name|int_mode
operator|>
literal|1
condition|)
block|{
comment|/* 				 * Assume we can use MSI-X 				 * (max of 16 receive queues). 				 */
name|sc
operator|->
name|num_queues
operator|=
name|min
argument_list|(
operator|(
name|bxe_queue_count
condition|?
name|bxe_queue_count
else|:
name|mp_ncpus
operator|)
argument_list|,
name|MAX_CONTEXT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Assume we can use MSI 				 * (max of 7 receive queues). 				 */
name|sc
operator|->
name|num_queues
operator|=
name|min
argument_list|(
operator|(
name|bxe_queue_count
condition|?
name|bxe_queue_count
else|:
name|mp_ncpus
operator|)
argument_list|,
name|BXE_MSI_VECTOR_COUNT
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Unsupported multi_mode parameter (%d), "
literal|"disabling multi-queue support!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|sc
operator|->
name|multi_mode
argument_list|)
expr_stmt|;
name|sc
operator|->
name|multi_mode
operator|=
name|ETH_RSS_MODE_DISABLED
expr_stmt|;
name|sc
operator|->
name|num_queues
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* User	has forced INTx mode. */
name|sc
operator|->
name|multi_mode
operator|=
name|ETH_RSS_MODE_DISABLED
expr_stmt|;
name|sc
operator|->
name|num_queues
operator|=
literal|1
expr_stmt|;
block|}
name|DBPRINT
argument_list|(
name|sc
argument_list|,
operator|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_INTR
operator|)
argument_list|,
literal|"%s(): Requested: int_mode = %d, multi_mode = %d num_queues = %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|int_mode
argument_list|,
name|sc
operator|->
name|multi_mode
argument_list|,
name|sc
operator|->
name|num_queues
argument_list|)
expr_stmt|;
name|sc
operator|->
name|stats_enable
operator|=
name|TRUE
expr_stmt|;
comment|/* Select the host coalescing tick count values (limit values). */
if|if
condition|(
name|bxe_tx_ticks
operator|>
literal|100
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): bxe_tx_ticks too large "
literal|"(%d), setting default value of 50.\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|bxe_tx_ticks
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx_ticks
operator|=
literal|50
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|tx_ticks
operator|=
name|bxe_tx_ticks
expr_stmt|;
if|if
condition|(
name|bxe_rx_ticks
operator|>
literal|100
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): bxe_rx_ticks too large "
literal|"(%d), setting default value of 25.\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|bxe_rx_ticks
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx_ticks
operator|=
literal|25
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|rx_ticks
operator|=
name|bxe_rx_ticks
expr_stmt|;
comment|/* Select the PCIe maximum read request size (MRRS). */
if|if
condition|(
name|bxe_mrrs
operator|>
literal|3
condition|)
name|sc
operator|->
name|mrrs
operator|=
literal|3
expr_stmt|;
else|else
name|sc
operator|->
name|mrrs
operator|=
name|bxe_mrrs
expr_stmt|;
comment|/* Check for DCC support. */
if|if
condition|(
name|bxe_dcc_enable
operator|==
name|FALSE
condition|)
name|sc
operator|->
name|dcc_enable
operator|=
name|FALSE
expr_stmt|;
else|else
name|sc
operator|->
name|dcc_enable
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocates PCI resources from OS.  *  * Returns:  *   0 = Success, !0 = Failure  */
end_comment

begin_function
specifier|static
name|int
name|bxe_pci_resources_alloc
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rid
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate PCI memory resources for BAR0. 	 * This includes device registers and internal 	 * processor memory. 	 */
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bxe_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|bxe_res
operator|==
name|NULL
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d):PCI BAR0 memory allocation failed\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bxe_pci_resources_alloc_exit
goto|;
block|}
comment|/* Get OS resource handles for BAR0 memory. */
name|sc
operator|->
name|bxe_btag
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|bxe_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bxe_bhandle
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|bxe_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bxe_vhandle
operator|=
operator|(
name|vm_offset_t
operator|)
name|rman_get_virtual
argument_list|(
name|sc
operator|->
name|bxe_res
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate PCI memory resources for BAR2. 	 * Doorbell (DB) memory. 	 */
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bxe_db_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|bxe_db_res
operator|==
name|NULL
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): PCI BAR2 memory allocation failed\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bxe_pci_resources_alloc_exit
goto|;
block|}
comment|/* Get OS resource handles for BAR2 memory. */
name|sc
operator|->
name|bxe_db_btag
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|bxe_db_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bxe_db_bhandle
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|bxe_db_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bxe_db_vhandle
operator|=
operator|(
name|vm_offset_t
operator|)
name|rman_get_virtual
argument_list|(
name|sc
operator|->
name|bxe_db_res
argument_list|)
expr_stmt|;
name|bxe_pci_resources_alloc_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Frees PCI resources allocated in bxe_pci_resources_alloc().  *  * Returns:  *   None  */
end_comment

begin_function
specifier|static
name|void
name|bxe_pci_resources_free
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|DBENTER
argument_list|(
name|BXE_VERBOSE_UNLOAD
argument_list|)
expr_stmt|;
comment|/* Release the PCIe BAR0 mapped memory. */
if|if
condition|(
name|sc
operator|->
name|bxe_res
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|sc
operator|->
name|bxe_res
argument_list|)
expr_stmt|;
block|}
comment|/* Release the PCIe BAR2 (doorbell) mapped memory. */
if|if
condition|(
name|sc
operator|->
name|bxe_db_res
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCIR_BAR
argument_list|(
literal|2
argument_list|)
argument_list|,
name|sc
operator|->
name|bxe_db_res
argument_list|)
expr_stmt|;
block|}
name|DBENTER
argument_list|(
name|BXE_VERBOSE_UNLOAD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Determines the media reported to the OS by examining  * the installed PHY type.  *  * Returns:  *   0 = Success, !0 = Failure  */
end_comment

begin_function
specifier|static
name|int
name|bxe_media_detect
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
comment|/* Identify supported media based on the PHY type. */
switch|switch
condition|(
name|XGXS_EXT_PHY_TYPE
argument_list|(
name|sc
operator|->
name|link_params
operator|.
name|ext_phy_config
argument_list|)
condition|)
block|{
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT
case|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_INFO_LOAD
argument_list|,
literal|"%s(): Found 10GBase-CX4 media.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|media
operator|=
name|IFM_10G_CX4
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073
case|:
comment|/* Technically 10GBase-KR but report as 10GBase-SR*/
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726
case|:
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727
case|:
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727_NOC
case|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_INFO_LOAD
argument_list|,
literal|"%s(): Found 10GBase-SR media.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|media
operator|=
name|IFM_10G_SR
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8705
case|:
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8706
case|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_INFO_LOAD
argument_list|,
literal|"%s(): Found 10Gb twinax media.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|media
operator|=
name|IFM_10G_TWINAX
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8481
case|:
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_SFX7101
case|:
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84823
case|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_INFO_LOAD
argument_list|,
literal|"%s(): Found 10GBase-T media.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|media
operator|=
name|IFM_10G_T
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_FAILURE
case|:
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_NOT_CONN
case|:
default|default:
name|sc
operator|->
name|media
operator|=
literal|0
expr_stmt|;
name|rc
operator|=
name|ENODEV
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Device attach function.  *  * Allocates device resources, performs secondary chip identification,  * resets and initializes the hardware, and initializes driver instance  * variables.  *  * Returns:  *   0 = Success, Positive value on failure.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_INFO_LOAD
operator||
name|BXE_INFO_RESET
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|bxe_unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bxe_func
operator|=
name|pci_get_function
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bxe_flags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|state
operator|=
name|BXE_STATE_CLOSED
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): ************************\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): ** Debug mode enabled **\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): ************************\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): sc vaddr = 0x%08X:%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|uint32_t
operator|)
name|U64_HI
argument_list|(
name|sc
argument_list|)
argument_list|,
operator|(
name|uint32_t
operator|)
name|U64_LO
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the user configurable values for driver load. */
name|bxe_tunables_set
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_mutexes_alloc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Prepare tick routine. */
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|bxe_tick_callout
argument_list|,
operator|&
name|sc
operator|->
name|bxe_core_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Enable bus master capability */
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Enable PCI BAR mapped memory for register access. */
name|rc
operator|=
name|bxe_pci_resources_alloc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Error allocating PCI resources!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
goto|goto
name|bxe_attach_fail
goto|;
block|}
comment|/* Put indirect address registers into a sane state. */
name|pci_write_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|PCICFG_GRC_ADDRESS
argument_list|,
name|PCICFG_VENDOR_ID_OFFSET
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_PGL_ADDR_88_F0
operator|+
name|BP_PORT
argument_list|(
name|sc
argument_list|)
operator|*
literal|16
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_PGL_ADDR_8C_F0
operator|+
name|BP_PORT
argument_list|(
name|sc
argument_list|)
operator|*
literal|16
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_PGL_ADDR_90_F0
operator|+
name|BP_PORT
argument_list|(
name|sc
argument_list|)
operator|*
literal|16
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_PGL_ADDR_94_F0
operator|+
name|BP_PORT
argument_list|(
name|sc
argument_list|)
operator|*
literal|16
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Get hardware info from shared memory and validate data. */
name|rc
operator|=
name|bxe_hwinfo_function_get
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): Failed to get hardware info!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
goto|goto
name|bxe_attach_fail
goto|;
block|}
comment|/* Setup supported media options. */
name|rc
operator|=
name|bxe_media_detect
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Unknown media (PHY) type!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
goto|goto
name|bxe_attach_fail
goto|;
block|}
comment|/* Interface entrypoint for media type/status reporting. */
name|ifmedia_init
argument_list|(
operator|&
name|sc
operator|->
name|bxe_ifmedia
argument_list|,
name|IFM_IMASK
argument_list|,
name|bxe_ifmedia_upd
argument_list|,
name|bxe_ifmedia_status
argument_list|)
expr_stmt|;
comment|/* Default interface values. */
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|bxe_ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|sc
operator|->
name|media
operator||
name|IFM_FDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|bxe_ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|bxe_ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bxe_ifmedia
operator|.
name|ifm_media
operator|=
name|sc
operator|->
name|bxe_ifmedia
operator|.
name|ifm_cur
operator|->
name|ifm_media
expr_stmt|;
comment|/* Setup firmware arrays (firmware load comes later). */
name|rc
operator|=
name|bxe_init_firmware
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Error preparing firmware load!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
goto|goto
name|bxe_attach_fail
goto|;
block|}
ifdef|#
directive|ifdef
name|BXE_DEBUG
comment|/* Allocate a memory buffer for grcdump output.*/
name|sc
operator|->
name|grcdump_buffer
operator|=
name|malloc
argument_list|(
name|BXE_GRCDUMP_BUF_SIZE
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|grcdump_buffer
operator|==
name|NULL
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Failed to allocate grcdump memory "
literal|"buffer!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOBUFS
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Check that NVRAM contents are valid.*/
name|rc
operator|=
name|bxe_nvram_test
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Failed NVRAM test!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
goto|goto
name|bxe_attach_fail
goto|;
block|}
comment|/* Allocate the appropriate interrupts.*/
name|rc
operator|=
name|bxe_interrupt_alloc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Interrupt allocation failed!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
goto|goto
name|bxe_attach_fail
goto|;
block|}
comment|/* Useful for accessing unconfigured devices (i.e. factory diags).*/
if|if
condition|(
name|nomcp
condition|)
name|sc
operator|->
name|bxe_flags
operator||=
name|BXE_NO_MCP_FLAG
expr_stmt|;
comment|/* If bootcode is not running only initialize port 0. */
if|if
condition|(
name|nomcp
operator|&&
name|BP_PORT
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Second device disabled (no bootcode), "
literal|"exiting...\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|bxe_attach_fail
goto|;
block|}
comment|/* Check if PXE/UNDI is still active and unload it. */
if|if
condition|(
operator|!
name|NOMCP
argument_list|(
name|sc
argument_list|)
condition|)
name|bxe_undi_unload
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Select the RX and TX ring sizes.  The actual 	 * ring size for TX is complicated by the fact 	 * that a single TX frame may be broken up into 	 * many buffer descriptors (tx_start_bd, 	 * tx_parse_bd, tx_data_bd).  In the best case, 	 * there are always at least two BD's required 	 * so we'll assume the best case here. 	 */
name|sc
operator|->
name|tx_ring_size
operator|=
operator|(
name|USABLE_TX_BD
operator|>>
literal|1
operator|)
expr_stmt|;
name|sc
operator|->
name|rx_ring_size
operator|=
name|USABLE_RX_BD
expr_stmt|;
comment|/* Assume receive IP/TCP/UDP checksum is enabled. */
comment|/* ToDo: Change when IOCTL changes checksum offload? */
name|sc
operator|->
name|rx_csum
operator|=
literal|1
expr_stmt|;
comment|/* Disable WoL. */
name|sc
operator|->
name|wol
operator|=
literal|0
expr_stmt|;
comment|/* Assume a standard 1500 byte MTU size for mbuf allocations. */
name|sc
operator|->
name|mbuf_alloc_size
operator|=
name|MCLBYTES
expr_stmt|;
comment|/* Allocate DMA memory resources. */
name|rc
operator|=
name|bxe_host_structures_alloc
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): DMA memory allocation failed!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
goto|goto
name|bxe_attach_fail
goto|;
block|}
comment|/* Allocate a FreeBSD ifnet structure. */
name|ifp
operator|=
name|sc
operator|->
name|bxe_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Interface allocation failed!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bxe_attach_fail
goto|;
block|}
comment|/* Initialize the FreeBSD ifnet interface. */
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Written by driver before attach, read-only afterwards. */
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
comment|/* Driver entrypoints from the network interface. */
name|ifp
operator|->
name|if_ioctl
operator|=
name|bxe_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|bxe_tx_start
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
name|ifp
operator|->
name|if_transmit
operator|=
name|bxe_tx_mq_start
expr_stmt|;
name|ifp
operator|->
name|if_qflush
operator|=
name|bxe_mq_flush
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FreeBSD8_0
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_init
operator|=
name|bxe_init
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|=
name|BXE_IF_HWASSIST
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator|=
name|BXE_IF_CAPABILITIES
expr_stmt|;
comment|/* TPA not enabled by default. */
name|ifp
operator|->
name|if_capenable
operator|=
name|BXE_IF_CAPABILITIES
operator|&
operator|~
name|IFCAP_LRO
expr_stmt|;
name|ifp
operator|->
name|if_baudrate
operator|=
name|IF_Gbps
argument_list|(
literal|10UL
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|sc
operator|->
name|tx_ring_size
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
argument_list|)
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
comment|/* Attach to the Ethernet interface list. */
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|mac_addr
argument_list|)
expr_stmt|;
comment|/* Attach the interrupts to the interrupt handlers. */
name|rc
operator|=
name|bxe_interrupt_attach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Interrupt allocation failed!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
goto|goto
name|bxe_attach_fail
goto|;
block|}
comment|/* Print important adapter info for the user. */
name|bxe_print_adapter_info
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Add the supported sysctls to the kernel. */
name|bxe_add_sysctls
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_attach_fail
label|:
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|bxe_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_INFO_LOAD
operator||
name|BXE_INFO_RESET
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Supported link settings.  *  * Examines hardware configuration present in NVRAM and  * determines the link settings that are supported between  * the external PHY and the switch.  *  * Returns:  *   None.  *  * Side effects:  * 	 Sets sc->port.supported  *	 Sets sc->link_params.phy_addr  */
end_comment

begin_function
specifier|static
name|void
name|bxe_link_settings_supported
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|switch_cfg
parameter_list|)
block|{
name|uint32_t
name|ext_phy_type
decl_stmt|;
name|int
name|port
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_PHY
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_PHY
argument_list|,
literal|"%s(): switch_cfg = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|switch_cfg
argument_list|)
expr_stmt|;
name|port
operator|=
name|BP_PORT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Get the link	settings supported by the external PHY. */
switch|switch
condition|(
name|switch_cfg
condition|)
block|{
case|case
name|SWITCH_CFG_1G
case|:
name|ext_phy_type
operator|=
name|SERDES_EXT_PHY_TYPE
argument_list|(
name|sc
operator|->
name|link_params
operator|.
name|ext_phy_config
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_PHY
argument_list|,
literal|"%s(): 1G switch w/ ext_phy_type = "
literal|"0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|ext_phy_type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ext_phy_type
condition|)
block|{
case|case
name|PORT_HW_CFG_SERDES_EXT_PHY_TYPE_DIRECT
case|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_PHY
argument_list|,
literal|"%s(): 1G Direct.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|port
operator|.
name|supported
operator||=
operator|(
name|SUPPORTED_10baseT_Half
operator||
name|SUPPORTED_10baseT_Full
operator||
name|SUPPORTED_100baseT_Half
operator||
name|SUPPORTED_100baseT_Full
operator||
name|SUPPORTED_1000baseT_Full
operator||
name|SUPPORTED_2500baseX_Full
operator||
name|SUPPORTED_TP
operator||
name|SUPPORTED_FIBRE
operator||
name|SUPPORTED_Autoneg
operator||
name|SUPPORTED_Pause
operator||
name|SUPPORTED_Asym_Pause
operator|)
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_SERDES_EXT_PHY_TYPE_BCM5482
case|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_PHY
argument_list|,
literal|"%s(): 1G 5482\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|port
operator|.
name|supported
operator||=
operator|(
name|SUPPORTED_10baseT_Half
operator||
name|SUPPORTED_10baseT_Full
operator||
name|SUPPORTED_100baseT_Half
operator||
name|SUPPORTED_100baseT_Full
operator||
name|SUPPORTED_1000baseT_Full
operator||
name|SUPPORTED_TP
operator||
name|SUPPORTED_FIBRE
operator||
name|SUPPORTED_Autoneg
operator||
name|SUPPORTED_Pause
operator||
name|SUPPORTED_Asym_Pause
operator|)
expr_stmt|;
break|break;
default|default:
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Bad NVRAM 1Gb PHY configuration data "
literal|"(ext_phy_config=0x%08X).\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|ext_phy_config
argument_list|)
expr_stmt|;
goto|goto
name|bxe_link_settings_supported_exit
goto|;
block|}
name|sc
operator|->
name|port
operator|.
name|phy_addr
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_SERDES0_CTRL_PHY_ADDR
operator|+
operator|(
name|port
operator|*
literal|0x10
operator|)
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_PHY
argument_list|,
literal|"%s(): phy_addr = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|port
operator|.
name|phy_addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SWITCH_CFG_10G
case|:
name|ext_phy_type
operator|=
name|XGXS_EXT_PHY_TYPE
argument_list|(
name|sc
operator|->
name|link_params
operator|.
name|ext_phy_config
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_PHY
argument_list|,
literal|"%s(): 10G switch w/ ext_phy_type = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|ext_phy_type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ext_phy_type
condition|)
block|{
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT
case|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_PHY
argument_list|,
literal|"%s(): 10G switch w/ direct connect.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|port
operator|.
name|supported
operator||=
operator|(
name|SUPPORTED_10baseT_Half
operator||
name|SUPPORTED_10baseT_Full
operator||
name|SUPPORTED_100baseT_Half
operator||
name|SUPPORTED_100baseT_Full
operator||
name|SUPPORTED_1000baseT_Full
operator||
name|SUPPORTED_2500baseX_Full
operator||
name|SUPPORTED_10000baseT_Full
operator||
name|SUPPORTED_TP
operator||
name|SUPPORTED_FIBRE
operator||
name|SUPPORTED_Autoneg
operator||
name|SUPPORTED_Pause
operator||
name|SUPPORTED_Asym_Pause
operator|)
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8072
case|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_PHY
argument_list|,
literal|"ext_phy_type 0x%x (8072)\n"
argument_list|,
name|ext_phy_type
argument_list|)
expr_stmt|;
name|sc
operator|->
name|port
operator|.
name|supported
operator||=
operator|(
name|SUPPORTED_10000baseT_Full
operator||
name|SUPPORTED_1000baseT_Full
operator||
name|SUPPORTED_FIBRE
operator||
name|SUPPORTED_Autoneg
operator||
name|SUPPORTED_Pause
operator||
name|SUPPORTED_Asym_Pause
operator|)
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073
case|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_PHY
argument_list|,
literal|"ext_phy_type 0x%x (8073)\n"
argument_list|,
name|ext_phy_type
argument_list|)
expr_stmt|;
name|sc
operator|->
name|port
operator|.
name|supported
operator||=
operator|(
name|SUPPORTED_10000baseT_Full
operator||
name|SUPPORTED_2500baseX_Full
operator||
name|SUPPORTED_1000baseT_Full
operator||
name|SUPPORTED_FIBRE
operator||
name|SUPPORTED_Autoneg
operator||
name|SUPPORTED_Pause
operator||
name|SUPPORTED_Asym_Pause
operator|)
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8705
case|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_PHY
argument_list|,
literal|"%s(): 10G switch w/ 8705.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|port
operator|.
name|supported
operator||=
operator|(
name|SUPPORTED_10000baseT_Full
operator||
name|SUPPORTED_FIBRE
operator||
name|SUPPORTED_Pause
operator||
name|SUPPORTED_Asym_Pause
operator|)
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8706
case|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_PHY
argument_list|,
literal|"%s(): 10G switch w/ 8706.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|port
operator|.
name|supported
operator||=
operator|(
name|SUPPORTED_10000baseT_Full
operator||
name|SUPPORTED_1000baseT_Full
operator||
name|SUPPORTED_FIBRE
operator||
name|SUPPORTED_Pause
operator||
name|SUPPORTED_Asym_Pause
operator|)
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726
case|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_PHY
argument_list|,
literal|"%s(): 10G switch w/ 8726.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|port
operator|.
name|supported
operator||=
operator|(
name|SUPPORTED_10000baseT_Full
operator||
name|SUPPORTED_FIBRE
operator||
name|SUPPORTED_Pause
operator||
name|SUPPORTED_Asym_Pause
operator|)
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727
case|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_PHY
argument_list|,
literal|"ext_phy_type 0x%x (8727)\n"
argument_list|,
name|ext_phy_type
argument_list|)
expr_stmt|;
name|sc
operator|->
name|port
operator|.
name|supported
operator||=
operator|(
name|SUPPORTED_10000baseT_Full
operator||
name|SUPPORTED_1000baseT_Full
operator||
name|SUPPORTED_Autoneg
operator||
name|SUPPORTED_FIBRE
operator||
name|SUPPORTED_Pause
operator||
name|SUPPORTED_Asym_Pause
operator|)
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_SFX7101
case|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_PHY
argument_list|,
literal|"%s(): 10G switch w/ SFX7101.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|port
operator|.
name|supported
operator||=
operator|(
name|SUPPORTED_10000baseT_Full
operator||
name|SUPPORTED_TP
operator||
name|SUPPORTED_Autoneg
operator||
name|SUPPORTED_Pause
operator||
name|SUPPORTED_Asym_Pause
operator|)
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8481
case|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_PHY
argument_list|,
literal|"ext_phy_type 0x%x (BCM8481)\n"
argument_list|,
name|ext_phy_type
argument_list|)
expr_stmt|;
name|sc
operator|->
name|port
operator|.
name|supported
operator||=
operator|(
name|SUPPORTED_10baseT_Half
operator||
name|SUPPORTED_10baseT_Full
operator||
name|SUPPORTED_100baseT_Half
operator||
name|SUPPORTED_100baseT_Full
operator||
name|SUPPORTED_1000baseT_Full
operator||
name|SUPPORTED_10000baseT_Full
operator||
name|SUPPORTED_TP
operator||
name|SUPPORTED_Autoneg
operator||
name|SUPPORTED_Pause
operator||
name|SUPPORTED_Asym_Pause
operator|)
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_FAILURE
case|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): 10G XGXS PHY failure detected.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
break|break;
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Bad NVRAM 10Gb PHY configuration data "
literal|"(ext_phy_config=0x%08X).\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|ext_phy_config
argument_list|)
expr_stmt|;
goto|goto
name|bxe_link_settings_supported_exit
goto|;
block|}
name|sc
operator|->
name|port
operator|.
name|phy_addr
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_XGXS0_CTRL_PHY_ADDR
operator|+
operator|(
name|port
operator|*
literal|0x18
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): BAD switch configuration "
literal|"(link_config = 0x%08X)\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|port
operator|.
name|link_config
argument_list|)
expr_stmt|;
goto|goto
name|bxe_link_settings_supported_exit
goto|;
block|}
name|sc
operator|->
name|link_params
operator|.
name|phy_addr
operator|=
name|sc
operator|->
name|port
operator|.
name|phy_addr
expr_stmt|;
comment|/* Mask out unsupported speeds according to NVRAM. */
if|if
condition|(
operator|(
name|sc
operator|->
name|link_params
operator|.
name|speed_cap_mask
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_10M_HALF
operator|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|port
operator|.
name|supported
operator|&=
operator|~
name|SUPPORTED_10baseT_Half
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|link_params
operator|.
name|speed_cap_mask
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_10M_FULL
operator|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|port
operator|.
name|supported
operator|&=
operator|~
name|SUPPORTED_10baseT_Full
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|link_params
operator|.
name|speed_cap_mask
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_100M_HALF
operator|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|port
operator|.
name|supported
operator|&=
operator|~
name|SUPPORTED_100baseT_Half
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|link_params
operator|.
name|speed_cap_mask
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_100M_FULL
operator|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|port
operator|.
name|supported
operator|&=
operator|~
name|SUPPORTED_100baseT_Full
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|link_params
operator|.
name|speed_cap_mask
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_1G
operator|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|port
operator|.
name|supported
operator|&=
operator|~
operator|(
name|SUPPORTED_1000baseT_Half
operator||
name|SUPPORTED_1000baseT_Full
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|link_params
operator|.
name|speed_cap_mask
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_2_5G
operator|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|port
operator|.
name|supported
operator|&=
operator|~
name|SUPPORTED_2500baseX_Full
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|link_params
operator|.
name|speed_cap_mask
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_10G
operator|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|port
operator|.
name|supported
operator|&=
operator|~
name|SUPPORTED_10000baseT_Full
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_PHY
argument_list|,
literal|"%s(): Supported link settings = 0x%b\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|port
operator|.
name|supported
argument_list|,
name|BXE_SUPPORTED_PRINTFB
argument_list|)
expr_stmt|;
name|bxe_link_settings_supported_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_PHY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Requested link settings.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_link_settings_requested
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|ext_phy_type
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_PHY
argument_list|)
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|req_duplex
operator|=
name|MEDIUM_FULL_DUPLEX
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|port
operator|.
name|link_config
operator|&
name|PORT_FEATURE_LINK_SPEED_MASK
condition|)
block|{
case|case
name|PORT_FEATURE_LINK_SPEED_AUTO
case|:
if|if
condition|(
name|sc
operator|->
name|port
operator|.
name|supported
operator|&
name|SUPPORTED_Autoneg
condition|)
block|{
name|sc
operator|->
name|link_params
operator|.
name|req_line_speed
operator||=
name|SPEED_AUTO_NEG
expr_stmt|;
name|sc
operator|->
name|port
operator|.
name|advertising
operator|=
name|sc
operator|->
name|port
operator|.
name|supported
expr_stmt|;
block|}
else|else
block|{
name|ext_phy_type
operator|=
name|XGXS_EXT_PHY_TYPE
argument_list|(
name|sc
operator|->
name|link_params
operator|.
name|ext_phy_config
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ext_phy_type
operator|==
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8705
operator|)
operator|||
operator|(
name|ext_phy_type
operator|==
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8706
operator|)
condition|)
block|{
comment|/* Force 10G, no autonegotiation. */
name|sc
operator|->
name|link_params
operator|.
name|req_line_speed
operator|=
name|SPEED_10000
expr_stmt|;
name|sc
operator|->
name|port
operator|.
name|advertising
operator|=
name|ADVERTISED_10000baseT_Full
operator||
name|ADVERTISED_FIBRE
expr_stmt|;
break|break;
block|}
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): NVRAM config error. Invalid "
literal|"link_config (0x%08X) - Autoneg not supported!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|port
operator|.
name|link_config
argument_list|)
expr_stmt|;
goto|goto
name|bxe_link_settings_requested_exit
goto|;
block|}
break|break;
case|case
name|PORT_FEATURE_LINK_SPEED_10M_FULL
case|:
if|if
condition|(
name|sc
operator|->
name|port
operator|.
name|supported
operator|&
name|SUPPORTED_10baseT_Full
condition|)
block|{
name|sc
operator|->
name|link_params
operator|.
name|req_line_speed
operator|=
name|SPEED_10
expr_stmt|;
name|sc
operator|->
name|port
operator|.
name|advertising
operator|=
name|ADVERTISED_10baseT_Full
operator||
name|ADVERTISED_TP
expr_stmt|;
block|}
else|else
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): NVRAM config error. Invalid "
literal|"link_config (0x%08X) - speed_cap_mask 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|port
operator|.
name|link_config
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|speed_cap_mask
argument_list|)
expr_stmt|;
goto|goto
name|bxe_link_settings_requested_exit
goto|;
block|}
break|break;
case|case
name|PORT_FEATURE_LINK_SPEED_10M_HALF
case|:
if|if
condition|(
name|sc
operator|->
name|port
operator|.
name|supported
operator|&
name|SUPPORTED_10baseT_Half
condition|)
block|{
name|sc
operator|->
name|link_params
operator|.
name|req_line_speed
operator|=
name|SPEED_10
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|req_duplex
operator|=
name|MEDIUM_HALF_DUPLEX
expr_stmt|;
name|sc
operator|->
name|port
operator|.
name|advertising
operator|=
name|ADVERTISED_10baseT_Half
operator||
name|ADVERTISED_TP
expr_stmt|;
block|}
else|else
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): NVRAM config error. Invalid "
literal|"link_config (0x%08X) - speed_cap_mask = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|port
operator|.
name|link_config
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|speed_cap_mask
argument_list|)
expr_stmt|;
goto|goto
name|bxe_link_settings_requested_exit
goto|;
block|}
break|break;
case|case
name|PORT_FEATURE_LINK_SPEED_100M_FULL
case|:
if|if
condition|(
name|sc
operator|->
name|port
operator|.
name|supported
operator|&
name|SUPPORTED_100baseT_Full
condition|)
block|{
name|sc
operator|->
name|link_params
operator|.
name|req_line_speed
operator|=
name|SPEED_100
expr_stmt|;
name|sc
operator|->
name|port
operator|.
name|advertising
operator|=
name|ADVERTISED_100baseT_Full
operator||
name|ADVERTISED_TP
expr_stmt|;
block|}
else|else
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): NVRAM config error. Invalid "
literal|"link_config (0x%08X) - speed_cap_mask = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|port
operator|.
name|link_config
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|speed_cap_mask
argument_list|)
expr_stmt|;
goto|goto
name|bxe_link_settings_requested_exit
goto|;
block|}
break|break;
case|case
name|PORT_FEATURE_LINK_SPEED_100M_HALF
case|:
if|if
condition|(
name|sc
operator|->
name|port
operator|.
name|supported
operator|&
name|SUPPORTED_100baseT_Half
condition|)
block|{
name|sc
operator|->
name|link_params
operator|.
name|req_line_speed
operator|=
name|SPEED_100
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|req_duplex
operator|=
name|MEDIUM_HALF_DUPLEX
expr_stmt|;
name|sc
operator|->
name|port
operator|.
name|advertising
operator|=
name|ADVERTISED_100baseT_Half
operator||
name|ADVERTISED_TP
expr_stmt|;
block|}
else|else
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): NVRAM config error. Invalid "
literal|"link_config (0x%08X) - speed_cap_mask = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|port
operator|.
name|link_config
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|speed_cap_mask
argument_list|)
expr_stmt|;
goto|goto
name|bxe_link_settings_requested_exit
goto|;
block|}
break|break;
case|case
name|PORT_FEATURE_LINK_SPEED_1G
case|:
if|if
condition|(
name|sc
operator|->
name|port
operator|.
name|supported
operator|&
name|SUPPORTED_1000baseT_Full
condition|)
block|{
name|sc
operator|->
name|link_params
operator|.
name|req_line_speed
operator|=
name|SPEED_1000
expr_stmt|;
name|sc
operator|->
name|port
operator|.
name|advertising
operator|=
name|ADVERTISED_1000baseT_Full
operator||
name|ADVERTISED_TP
expr_stmt|;
block|}
else|else
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): NVRAM config error. Invalid "
literal|"link_config (0x%08X) - speed_cap_mask = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|port
operator|.
name|link_config
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|speed_cap_mask
argument_list|)
expr_stmt|;
goto|goto
name|bxe_link_settings_requested_exit
goto|;
block|}
break|break;
case|case
name|PORT_FEATURE_LINK_SPEED_2_5G
case|:
if|if
condition|(
name|sc
operator|->
name|port
operator|.
name|supported
operator|&
name|SUPPORTED_2500baseX_Full
condition|)
block|{
name|sc
operator|->
name|link_params
operator|.
name|req_line_speed
operator|=
name|SPEED_2500
expr_stmt|;
name|sc
operator|->
name|port
operator|.
name|advertising
operator|=
name|ADVERTISED_2500baseX_Full
operator||
name|ADVERTISED_TP
expr_stmt|;
block|}
else|else
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): NVRAM config error. Invalid "
literal|"link_config (0x%08X) - speed_cap_mask = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|port
operator|.
name|link_config
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|speed_cap_mask
argument_list|)
expr_stmt|;
goto|goto
name|bxe_link_settings_requested_exit
goto|;
block|}
break|break;
case|case
name|PORT_FEATURE_LINK_SPEED_10G_CX4
case|:
case|case
name|PORT_FEATURE_LINK_SPEED_10G_KX4
case|:
case|case
name|PORT_FEATURE_LINK_SPEED_10G_KR
case|:
if|if
condition|(
name|sc
operator|->
name|port
operator|.
name|supported
operator|&
name|SUPPORTED_10000baseT_Full
condition|)
block|{
name|sc
operator|->
name|link_params
operator|.
name|req_line_speed
operator|=
name|SPEED_10000
expr_stmt|;
name|sc
operator|->
name|port
operator|.
name|advertising
operator|=
name|ADVERTISED_10000baseT_Full
operator||
name|ADVERTISED_FIBRE
expr_stmt|;
block|}
else|else
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): NVRAM config error. Invalid "
literal|"link_config (0x%08X) - speed_cap_mask = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|port
operator|.
name|link_config
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|speed_cap_mask
argument_list|)
expr_stmt|;
goto|goto
name|bxe_link_settings_requested_exit
goto|;
block|}
break|break;
default|default:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): NVRAM config error. BAD link "
literal|"speed - link_config = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|port
operator|.
name|link_config
argument_list|)
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|req_line_speed
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|port
operator|.
name|advertising
operator|=
name|sc
operator|->
name|port
operator|.
name|supported
expr_stmt|;
break|break;
block|}
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_PHY
argument_list|,
literal|"%s(): req_line_speed = %d, req_duplex = %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|req_line_speed
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|req_duplex
argument_list|)
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|req_flow_ctrl
operator|=
name|sc
operator|->
name|port
operator|.
name|link_config
operator|&
name|PORT_FEATURE_FLOW_CONTROL_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|link_params
operator|.
name|req_flow_ctrl
operator|==
name|FLOW_CTRL_AUTO
operator|)
operator|&&
operator|!
operator|(
name|sc
operator|->
name|port
operator|.
name|supported
operator|&
name|SUPPORTED_Autoneg
operator|)
condition|)
name|sc
operator|->
name|link_params
operator|.
name|req_flow_ctrl
operator|=
name|FLOW_CTRL_NONE
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_PHY
argument_list|,
literal|"%s(): req_flow_ctrl = 0x%08X, advertising = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|req_flow_ctrl
argument_list|,
name|sc
operator|->
name|port
operator|.
name|advertising
argument_list|)
expr_stmt|;
name|bxe_link_settings_requested_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_PHY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get function specific hardware configuration.  *  * Multiple function devices such as the BCM57711E have configuration  * information that is specific to each PCIe function of the controller.  * The number of PCIe functions is not necessarily the same as the number  * of Ethernet ports supported by the device.  *  * Returns:  *   0 = Success, !0 = Failure  */
end_comment

begin_function
specifier|static
name|int
name|bxe_hwinfo_function_get
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|mac_hi
decl_stmt|,
name|mac_lo
decl_stmt|,
name|val
decl_stmt|;
name|int
name|func
decl_stmt|,
name|rc
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
name|func
operator|=
name|BP_FUNC
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Get the common hardware configuration first. */
name|bxe_hwinfo_common_get
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Assume no outer VLAN/multi-function support. */
name|sc
operator|->
name|e1hov
operator|=
name|sc
operator|->
name|e1hmf
operator|=
literal|0
expr_stmt|;
comment|/* Get config info for mf enabled devices. */
if|if
condition|(
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|sc
operator|->
name|mf_config
index|[
name|BP_E1HVN
argument_list|(
name|sc
argument_list|)
index|]
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|mf_cfg
operator|.
name|func_mf_config
index|[
name|func
index|]
operator|.
name|config
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|mf_cfg
operator|.
name|func_mf_config
index|[
name|func
index|]
operator|.
name|e1hov_tag
argument_list|)
operator|&
name|FUNC_MF_CFG_E1HOV_TAG_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|FUNC_MF_CFG_E1HOV_TAG_DEFAULT
condition|)
block|{
name|sc
operator|->
name|e1hov
operator|=
operator|(
name|uint16_t
operator|)
name|val
expr_stmt|;
name|sc
operator|->
name|e1hmf
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|BP_E1HVN
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|rc
operator|=
name|EPERM
expr_stmt|;
goto|goto
name|bxe_hwinfo_function_get_exit
goto|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|NOMCP
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|bxe_hwinfo_port_get
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fw_seq
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|func_mb
index|[
name|func
index|]
operator|.
name|drv_mb_header
argument_list|)
operator|&
name|DRV_MSG_SEQ_NUMBER_MASK
expr_stmt|;
block|}
comment|/* 	 * Fetch the factory configured MAC address for multi function 	 * devices. If this is not a multi-function device then the MAC 	 * address was already read in the bxe_hwinfo_port_get() routine. 	 * The MAC addresses used by the port are not the same as the MAC 	 * addressed used by the function. 	 */
if|if
condition|(
name|IS_E1HMF
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|mac_hi
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|mf_cfg
operator|.
name|func_mf_config
index|[
name|func
index|]
operator|.
name|mac_upper
argument_list|)
expr_stmt|;
name|mac_lo
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|mf_cfg
operator|.
name|func_mf_config
index|[
name|func
index|]
operator|.
name|mac_lower
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mac_lo
operator|==
literal|0
operator|)
operator|&&
operator|(
name|mac_hi
operator|==
literal|0
operator|)
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Invalid Ethernet address!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENODEV
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|link_params
operator|.
name|mac_addr
index|[
literal|0
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|mac_hi
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|mac_addr
index|[
literal|1
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|mac_hi
argument_list|)
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|mac_addr
index|[
literal|2
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|mac_lo
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|mac_addr
index|[
literal|3
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|mac_lo
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|mac_addr
index|[
literal|4
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|mac_lo
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|mac_addr
index|[
literal|5
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|mac_lo
argument_list|)
expr_stmt|;
block|}
block|}
name|bxe_hwinfo_function_get_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get port specific hardware configuration.  *  * Multiple port devices such as the BCM57710 have configuration  * information that is specific to each Ethernet port of the  * controller.  This function reads that configuration  * information from the bootcode's shared memory and saves it  * for future use.  *  * Returns:  *   0 = Success, !0 = Failure  */
end_comment

begin_function
specifier|static
name|int
name|bxe_hwinfo_port_get
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|port
decl_stmt|,
name|rc
decl_stmt|;
name|uint32_t
name|val
decl_stmt|,
name|mac_hi
decl_stmt|,
name|mac_lo
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
name|port
operator|=
name|BP_PORT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|sc
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|port
operator|=
name|port
expr_stmt|;
comment|/* Fetch several configuration values from bootcode shared memory. */
name|sc
operator|->
name|link_params
operator|.
name|lane_config
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|port
index|]
operator|.
name|lane_config
argument_list|)
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|ext_phy_config
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|port
index|]
operator|.
name|external_phy_config
argument_list|)
expr_stmt|;
if|if
condition|(
name|XGXS_EXT_PHY_TYPE
argument_list|(
name|sc
operator|->
name|link_params
operator|.
name|ext_phy_config
argument_list|)
operator|==
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727_NOC
condition|)
block|{
name|sc
operator|->
name|link_params
operator|.
name|ext_phy_config
operator|&=
operator|~
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_MASK
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|ext_phy_config
operator||=
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|feature_config_flags
operator||=
name|FEATURE_CONFIG_BCM8727_NOC
expr_stmt|;
block|}
name|sc
operator|->
name|link_params
operator|.
name|speed_cap_mask
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|port
index|]
operator|.
name|speed_capability_mask
argument_list|)
expr_stmt|;
name|sc
operator|->
name|port
operator|.
name|link_config
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|dev_info
operator|.
name|port_feature_config
index|[
name|port
index|]
operator|.
name|link_config
argument_list|)
expr_stmt|;
comment|/* Read the XGXS RX/TX preemphasis values. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|val
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|port
index|]
operator|.
name|xgxs_config_rx
index|[
name|i
operator|<<
literal|1
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|xgxs_config_rx
index|[
name|i
operator|<<
literal|1
index|]
operator|=
operator|(
operator|(
name|val
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|xgxs_config_rx
index|[
operator|(
name|i
operator|<<
literal|1
operator|)
operator|+
literal|1
index|]
operator|=
operator|(
name|val
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|val
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|port
index|]
operator|.
name|xgxs_config_tx
index|[
name|i
operator|<<
literal|1
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|xgxs_config_tx
index|[
name|i
operator|<<
literal|1
index|]
operator|=
operator|(
operator|(
name|val
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|xgxs_config_tx
index|[
operator|(
name|i
operator|<<
literal|1
operator|)
operator|+
literal|1
index|]
operator|=
operator|(
name|val
operator|&
literal|0xffff
operator|)
expr_stmt|;
block|}
comment|/* Fetch the device configured link settings. */
name|sc
operator|->
name|link_params
operator|.
name|switch_cfg
operator|=
name|sc
operator|->
name|port
operator|.
name|link_config
operator|&
name|PORT_FEATURE_CONNECTED_SWITCH_MASK
expr_stmt|;
name|bxe_link_settings_supported
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|switch_cfg
argument_list|)
expr_stmt|;
name|bxe_link_settings_requested
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mac_hi
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|port
index|]
operator|.
name|mac_upper
argument_list|)
expr_stmt|;
name|mac_lo
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|port
index|]
operator|.
name|mac_lower
argument_list|)
expr_stmt|;
if|if
condition|(
name|mac_lo
operator|==
literal|0
operator|&&
name|mac_hi
operator|==
literal|0
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): No Ethernet address programmed on the "
literal|"controller!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENODEV
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|link_params
operator|.
name|mac_addr
index|[
literal|0
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|mac_hi
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|mac_addr
index|[
literal|1
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|mac_hi
argument_list|)
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|mac_addr
index|[
literal|2
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|mac_lo
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|mac_addr
index|[
literal|3
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|mac_lo
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|mac_addr
index|[
literal|4
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|mac_lo
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|mac_addr
index|[
literal|5
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|mac_lo
argument_list|)
expr_stmt|;
block|}
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get common hardware configuration.  *  * Multiple port devices such as the BCM57710 have configuration  * information that is shared between all ports of the Ethernet  * controller.  This function reads that configuration  * information from the bootcode's shared memory and saves it  * for future use.  *  * Returns:  *   0 = Success, !0 = Failure  */
end_comment

begin_function
specifier|static
name|int
name|bxe_hwinfo_common_get
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
comment|/* Get the chip revision. */
name|sc
operator|->
name|common
operator|.
name|chip_id
operator|=
name|sc
operator|->
name|link_params
operator|.
name|chip_id
operator|=
operator|(
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_CHIP_NUM
argument_list|)
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_CHIP_REV
argument_list|)
operator|&
literal|0x000f
operator|)
operator|<<
literal|12
operator|)
operator||
operator|(
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_CHIP_METAL
argument_list|)
operator|&
literal|0xff
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_BOND_ID
argument_list|)
operator|&
literal|0xf
operator|)
operator|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_LOAD
argument_list|,
literal|"%s(): chip_id = 0x%08X.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|common
operator|.
name|chip_id
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
literal|0x2874
argument_list|)
operator|&
literal|0x55
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|common
operator|.
name|chip_id
operator|&
literal|0x1
operator|)
operator|||
operator|(
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
operator|&&
name|val
operator|)
operator|||
operator|(
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
operator|&&
operator|(
name|val
operator|==
literal|0x55
operator|)
operator|)
condition|)
block|{
name|sc
operator|->
name|bxe_flags
operator||=
name|BXE_ONE_PORT_FLAG
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_LOAD
argument_list|,
literal|"%s(): Single port device.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
comment|/* Identify enabled PCI capabilites (PCIe, MSI-X, etc.). */
name|bxe_probe_pci_caps
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Get the NVRAM size. */
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_NVM_CFG4
argument_list|)
expr_stmt|;
name|sc
operator|->
name|common
operator|.
name|flash_size
operator|=
operator|(
name|NVRAM_1MB_SIZE
operator|<<
operator|(
name|val
operator|&
name|MCPR_NVM_CFG4_FLASH_SIZE
operator|)
operator|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_LOAD
argument_list|,
literal|"%s(): flash_size = 0x%08x (%dKB)\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|common
operator|.
name|flash_size
argument_list|,
operator|(
name|sc
operator|->
name|common
operator|.
name|flash_size
operator|>>
literal|10
operator|)
argument_list|)
expr_stmt|;
comment|/* Find the shared memory base address. */
name|sc
operator|->
name|common
operator|.
name|shmem_base
operator|=
name|sc
operator|->
name|link_params
operator|.
name|shmem_base
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_SHARED_MEM_ADDR
argument_list|)
expr_stmt|;
name|sc
operator|->
name|common
operator|.
name|shmem2_base
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_GENERIC_CR_0
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_LOAD
argument_list|,
literal|"%s(): shmem_base = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|common
operator|.
name|shmem_base
argument_list|)
expr_stmt|;
comment|/* Make sure the shared memory address is valid. */
if|if
condition|(
operator|!
name|sc
operator|->
name|common
operator|.
name|shmem_base
operator|||
operator|(
name|sc
operator|->
name|common
operator|.
name|shmem_base
operator|<
literal|0xA0000
operator|)
operator|||
operator|(
name|sc
operator|->
name|common
operator|.
name|shmem_base
operator|>
literal|0xC0000
operator|)
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): MCP is not active!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
comment|/* ToDo: Remove the NOMCP support. */
name|sc
operator|->
name|bxe_flags
operator||=
name|BXE_NO_MCP_FLAG
expr_stmt|;
name|rc
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|bxe_hwinfo_common_get_exit
goto|;
block|}
comment|/* Make sure the shared memory contents are valid. */
name|val
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|validity_map
index|[
name|BP_PORT
argument_list|(
name|sc
argument_list|)
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
operator|(
name|SHR_MEM_VALIDITY_DEV_INFO
operator||
name|SHR_MEM_VALIDITY_MB
operator|)
operator|)
operator|!=
operator|(
name|SHR_MEM_VALIDITY_DEV_INFO
operator||
name|SHR_MEM_VALIDITY_MB
operator|)
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Invalid NVRAM! Bad validity "
literal|"signature.\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|bxe_hwinfo_common_get_exit
goto|;
block|}
comment|/* Read the device configuration from shared memory. */
name|sc
operator|->
name|common
operator|.
name|hw_config
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|dev_info
operator|.
name|shared_hw_config
operator|.
name|config
argument_list|)
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|hw_led_mode
operator|=
operator|(
operator|(
name|sc
operator|->
name|common
operator|.
name|hw_config
operator|&
name|SHARED_HW_CFG_LED_MODE_MASK
operator|)
operator|>>
name|SHARED_HW_CFG_LED_MODE_SHIFT
operator|)
expr_stmt|;
comment|/* Check if we need to override the preemphasis values. */
name|sc
operator|->
name|link_params
operator|.
name|feature_config_flags
operator|=
literal|0
expr_stmt|;
name|val
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|dev_info
operator|.
name|shared_feature_config
operator|.
name|config
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|SHARED_FEAT_CFG_OVERRIDE_PREEMPHASIS_CFG_ENABLED
condition|)
name|sc
operator|->
name|link_params
operator|.
name|feature_config_flags
operator||=
name|FEATURE_CONFIG_OVERRIDE_PREEMPHASIS_ENABLED
expr_stmt|;
else|else
name|sc
operator|->
name|link_params
operator|.
name|feature_config_flags
operator|&=
operator|~
name|FEATURE_CONFIG_OVERRIDE_PREEMPHASIS_ENABLED
expr_stmt|;
comment|/* In multifunction mode, we can't support WoL on a VN. */
if|if
condition|(
name|BP_E1HVN
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
condition|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|PCICFG_OFFSET
operator|+
name|PCICFG_PM_CAPABILITY
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bxe_flags
operator||=
operator|(
name|val
operator|&
name|PCICFG_PM_CAPABILITY_PME_IN_D3_COLD
operator|)
condition|?
literal|0
else|:
name|BXE_NO_WOL_FLAG
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|bxe_flags
operator||=
name|BXE_NO_WOL_FLAG
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_LOAD
argument_list|,
literal|"%s(): %sWoL capable\n"
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|sc
operator|->
name|bxe_flags
operator|&
name|BXE_NO_WOL_FLAG
operator|)
condition|?
literal|"Not "
else|:
literal|""
argument_list|)
expr_stmt|;
comment|/* Check bootcode version */
name|sc
operator|->
name|common
operator|.
name|bc_ver
operator|=
operator|(
operator|(
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|dev_info
operator|.
name|bc_rev
argument_list|)
operator|)
operator|>>
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|common
operator|.
name|bc_ver
operator|<
name|MIN_BXE_BC_VER
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Warning: This driver needs bootcode "
literal|"0x%08X but found 0x%08X, please upgrade!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|MIN_BXE_BC_VER
argument_list|,
name|sc
operator|->
name|common
operator|.
name|bc_ver
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|bxe_hwinfo_common_get_exit
goto|;
block|}
name|bxe_hwinfo_common_get_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove traces of PXE boot by forcing UNDI driver unload.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_undi_unload
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|reset_code
decl_stmt|,
name|swap_en
decl_stmt|,
name|swap_val
decl_stmt|,
name|val
decl_stmt|;
name|int
name|func
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
argument_list|)
expr_stmt|;
comment|/* Check if there is any driver already loaded */
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_UNPREPARED
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0x1
condition|)
block|{
comment|/* Check if it is the UNDI driver. */
name|bxe_acquire_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_UNDI
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|DORQ_REG_NORM_CID_OFST
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0x7
condition|)
block|{
name|reset_code
operator|=
name|DRV_MSG_CODE_UNLOAD_REQ_WOL_DIS
expr_stmt|;
name|func
operator|=
name|BP_FUNC
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): UNDI is active! Resetting the device.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* Clear the UNDI indication. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|DORQ_REG_NORM_CID_OFST
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Try to unload UNDI on port 0. */
name|sc
operator|->
name|bxe_func
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|fw_seq
operator|=
operator|(
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|func_mb
index|[
name|sc
operator|->
name|bxe_func
index|]
operator|.
name|drv_mb_header
argument_list|)
operator|&
name|DRV_MSG_SEQ_NUMBER_MASK
operator|)
expr_stmt|;
name|reset_code
operator|=
name|bxe_fw_command
argument_list|(
name|sc
argument_list|,
name|reset_code
argument_list|)
expr_stmt|;
comment|/* Check if UNDI is active on port 1. */
if|if
condition|(
name|reset_code
operator|!=
name|FW_MSG_CODE_DRV_UNLOAD_COMMON
condition|)
block|{
comment|/* Send "done" for previous unload. */
name|bxe_fw_command
argument_list|(
name|sc
argument_list|,
name|DRV_MSG_CODE_UNLOAD_DONE
argument_list|)
expr_stmt|;
comment|/* Now unload on port 1. */
name|sc
operator|->
name|bxe_func
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|fw_seq
operator|=
operator|(
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|func_mb
index|[
name|sc
operator|->
name|bxe_func
index|]
operator|.
name|drv_mb_header
argument_list|)
operator|&
name|DRV_MSG_SEQ_NUMBER_MASK
operator|)
expr_stmt|;
name|reset_code
operator|=
name|DRV_MSG_CODE_UNLOAD_REQ_WOL_DIS
expr_stmt|;
name|bxe_fw_command
argument_list|(
name|sc
argument_list|,
name|reset_code
argument_list|)
expr_stmt|;
block|}
comment|/* It's	now safe to release the lock. */
name|bxe_release_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_UNDI
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|BP_PORT
argument_list|(
name|sc
argument_list|)
condition|?
name|HC_REG_CONFIG_1
else|:
name|HC_REG_CONFIG_0
operator|)
argument_list|,
literal|0x1000
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|BP_PORT
argument_list|(
name|sc
argument_list|)
condition|?
name|NIG_REG_LLH1_BRB1_DRV_MASK
else|:
name|NIG_REG_LLH0_BRB1_DRV_MASK
operator|)
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|BP_PORT
argument_list|(
name|sc
argument_list|)
condition|?
name|NIG_REG_LLH1_BRB1_NOT_MCP
else|:
name|NIG_REG_LLH0_BRB1_NOT_MCP
operator|)
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* Clear AEU. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|BP_PORT
argument_list|(
name|sc
argument_list|)
condition|?
name|MISC_REG_AEU_MASK_ATTN_FUNC_1
else|:
name|MISC_REG_AEU_MASK_ATTN_FUNC_0
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/* Save NIG port swap information. */
name|swap_val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_PORT_SWAP
argument_list|)
expr_stmt|;
name|swap_en
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_STRAP_OVERRIDE
argument_list|)
expr_stmt|;
comment|/* Reset the controller. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_1_CLEAR
argument_list|,
literal|0xd3ffffff
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_2_CLEAR
argument_list|,
literal|0x00001403
argument_list|)
expr_stmt|;
comment|/* Take the NIG out of reset and restore swap values.*/
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_1_SET
argument_list|,
name|MISC_REGISTERS_RESET_REG_1_RST_NIG
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_PORT_SWAP
argument_list|,
name|swap_val
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_STRAP_OVERRIDE
argument_list|,
name|swap_en
argument_list|)
expr_stmt|;
comment|/* Send completion message to the MCP. */
name|bxe_fw_command
argument_list|(
name|sc
argument_list|,
name|DRV_MSG_CODE_UNLOAD_DONE
argument_list|)
expr_stmt|;
comment|/* 			 * Restore our function and firmware sequence counter. 			 */
name|sc
operator|->
name|bxe_func
operator|=
name|func
expr_stmt|;
name|sc
operator|->
name|fw_seq
operator|=
operator|(
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|func_mb
index|[
name|sc
operator|->
name|bxe_func
index|]
operator|.
name|drv_mb_header
argument_list|)
operator|&
name|DRV_MSG_SEQ_NUMBER_MASK
operator|)
expr_stmt|;
block|}
else|else
name|bxe_release_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_UNDI
argument_list|)
expr_stmt|;
block|}
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Device detach function.  *  * Stops the controller, resets the controller, and releases resources.  *  * Returns:  *   0 on success, !0 = failure.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_INFO_UNLOAD
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|bxe_ifp
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
operator|&&
name|ifp
operator|->
name|if_vlantrunk
operator|!=
name|NULL
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Cannot detach while VLANs are in use.\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|bxe_detach_exit
goto|;
block|}
comment|/* Stop and reset the controller if it was open. */
if|if
condition|(
name|sc
operator|->
name|state
operator|!=
name|BXE_STATE_CLOSED
condition|)
block|{
name|BXE_CORE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rc
operator|=
name|bxe_stop_locked
argument_list|(
name|sc
argument_list|,
name|UNLOAD_CLOSE
argument_list|)
expr_stmt|;
name|BXE_CORE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BXE_DEBUG
comment|/* Free memory buffer for grcdump output.*/
if|if
condition|(
name|sc
operator|->
name|grcdump_buffer
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sc
operator|->
name|grcdump_buffer
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Clean-up any remaining interrupt resources. */
name|bxe_interrupt_detach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_interrupt_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Release the network interface. */
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ifmedia_removeall
argument_list|(
operator|&
name|sc
operator|->
name|bxe_ifmedia
argument_list|)
expr_stmt|;
comment|/* Release all remaining resources. */
name|bxe_release_resources
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Free all PCI resources. */
name|bxe_pci_resources_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|pci_disable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bxe_mutexes_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_detach_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_INFO_UNLOAD
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Setup a leading connection for the controller.  *  * Returns:  *   0 = Success, !0 = Failure.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_setup_leading
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator||
name|BXE_VERBOSE_RAMROD
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_LOAD
argument_list|,
literal|"%s(): Setup leading connection "
literal|"on fp[00].\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* Reset IGU state for the leading connection. */
name|bxe_ack_sb
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|fp
index|[
literal|0
index|]
operator|.
name|sb_id
argument_list|,
name|CSTORM_ID
argument_list|,
literal|0
argument_list|,
name|IGU_INT_ENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Post a PORT_SETUP ramrod and wait for completion. */
name|bxe_sp_post
argument_list|(
name|sc
argument_list|,
name|RAMROD_CMD_ID_ETH_PORT_SETUP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Wait for the ramrod to complete on the leading connection. */
name|rc
operator|=
name|bxe_wait_ramrod
argument_list|(
name|sc
argument_list|,
name|BXE_STATE_OPEN
argument_list|,
literal|0
argument_list|,
operator|&
operator|(
name|sc
operator|->
name|state
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator||
name|BXE_VERBOSE_RAMROD
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Stop the leading connection on the controller.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_stop_leading
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint16_t
name|dsb_sp_prod_idx
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|timeout
decl_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
operator|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator||
name|BXE_VERBOSE_UNLOAD
operator|)
argument_list|,
literal|"%s(): Stop client connection "
literal|"on fp[00].\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* Send the ETH_HALT ramrod. */
name|sc
operator|->
name|fp
index|[
literal|0
index|]
operator|.
name|state
operator|=
name|BXE_FP_STATE_HALTING
expr_stmt|;
name|bxe_sp_post
argument_list|(
name|sc
argument_list|,
name|RAMROD_CMD_ID_ETH_HALT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|fp
index|[
literal|0
index|]
operator|.
name|cl_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Poll for the ETH_HALT ramrod on the leading connection. */
name|rc
operator|=
name|bxe_wait_ramrod
argument_list|(
name|sc
argument_list|,
name|BXE_FP_STATE_HALTED
argument_list|,
literal|0
argument_list|,
operator|&
operator|(
name|sc
operator|->
name|fp
index|[
literal|0
index|]
operator|.
name|state
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): Timeout waiting for "
literal|"STATE_HALTED ramrod completion!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
goto|goto
name|bxe_stop_leading_exit
goto|;
block|}
comment|/* Get the default status block SP producer index. */
name|dsb_sp_prod_idx
operator|=
operator|*
name|sc
operator|->
name|dsb_sp_prod
expr_stmt|;
comment|/* After HALT we send PORT_DELETE ramrod. */
name|bxe_sp_post
argument_list|(
name|sc
argument_list|,
name|RAMROD_CMD_ID_ETH_PORT_DEL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Be patient but don't wait forever. */
name|timeout
operator|=
literal|500
expr_stmt|;
while|while
condition|(
name|dsb_sp_prod_idx
operator|==
operator|*
name|sc
operator|->
name|dsb_sp_prod
condition|)
block|{
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): Timeout waiting for "
literal|"PORT_DEL ramrod completion!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|timeout
operator|--
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|rmb
argument_list|()
expr_stmt|;
block|}
comment|/* Update the adapter and connection states. */
name|sc
operator|->
name|state
operator|=
name|BXE_STATE_CLOSING_WAIT4_UNLOAD
expr_stmt|;
name|sc
operator|->
name|fp
index|[
literal|0
index|]
operator|.
name|state
operator|=
name|BXE_FP_STATE_CLOSED
expr_stmt|;
name|bxe_stop_leading_exit
label|:
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Setup a client connection when using multi-queue/RSS.  *  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_setup_multi
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
operator|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator||
name|BXE_VERBOSE_UNLOAD
operator|)
argument_list|,
literal|"%s(): Setup client connection "
literal|"on fp[%02d].\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|index
index|]
expr_stmt|;
comment|/* Reset IGU state. */
name|bxe_ack_sb
argument_list|(
name|sc
argument_list|,
name|fp
operator|->
name|sb_id
argument_list|,
name|CSTORM_ID
argument_list|,
literal|0
argument_list|,
name|IGU_INT_ENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Post a CLIENT_SETUP ramrod. */
name|fp
operator|->
name|state
operator|=
name|BXE_FP_STATE_OPENING
expr_stmt|;
name|bxe_sp_post
argument_list|(
name|sc
argument_list|,
name|RAMROD_CMD_ID_ETH_CLIENT_SETUP
argument_list|,
name|index
argument_list|,
literal|0
argument_list|,
name|fp
operator|->
name|cl_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Wait for the ramrod to complete. */
name|rc
operator|=
name|bxe_wait_ramrod
argument_list|(
name|sc
argument_list|,
name|BXE_FP_STATE_OPEN
argument_list|,
name|index
argument_list|,
operator|&
name|fp
operator|->
name|state
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Stop a client connection.  *  * Stops an individual client connection on the device.  Use  * bxe_stop_leading() for the first/default connection.  *  * Returns:  *   0 = Success, !0 = Failure.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_stop_multi
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
operator|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator||
name|BXE_VERBOSE_UNLOAD
operator|)
argument_list|,
literal|"%s(): Stop client connection "
literal|"on fp[%02d].\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|index
index|]
expr_stmt|;
comment|/* Halt the client connection. */
name|fp
operator|->
name|state
operator|=
name|BXE_FP_STATE_HALTING
expr_stmt|;
name|bxe_sp_post
argument_list|(
name|sc
argument_list|,
name|RAMROD_CMD_ID_ETH_HALT
argument_list|,
name|index
argument_list|,
literal|0
argument_list|,
name|fp
operator|->
name|cl_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Wait for the HALT ramrod completion. */
name|rc
operator|=
name|bxe_wait_ramrod
argument_list|(
name|sc
argument_list|,
name|BXE_FP_STATE_HALTED
argument_list|,
name|index
argument_list|,
operator|&
name|fp
operator|->
name|state
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): fp[%02d] client ramrod halt failed!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|index
argument_list|)
expr_stmt|;
goto|goto
name|bxe_stop_multi_exit
goto|;
block|}
comment|/* Delete the CFC entry. */
name|bxe_sp_post
argument_list|(
name|sc
argument_list|,
name|RAMROD_CMD_ID_ETH_CFC_DEL
argument_list|,
name|index
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Poll for the DELETE ramrod completion. */
name|rc
operator|=
name|bxe_wait_ramrod
argument_list|(
name|sc
argument_list|,
name|BXE_FP_STATE_CLOSED
argument_list|,
name|index
argument_list|,
operator|&
name|fp
operator|->
name|state
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bxe_stop_multi_exit
label|:
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Hardware lock for shared, dual-port PHYs.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_acquire_phy_lock
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|ext_phy_type
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_PHY
argument_list|)
expr_stmt|;
name|ext_phy_type
operator|=
name|XGXS_EXT_PHY_TYPE
argument_list|(
name|sc
operator|->
name|link_params
operator|.
name|ext_phy_config
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ext_phy_type
condition|)
block|{
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8072
case|:
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073
case|:
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726
case|:
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727
case|:
name|bxe_acquire_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_MDIO
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_PHY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Hardware unlock for shared, dual-port PHYs.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_release_phy_lock
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|ext_phy_type
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_PHY
argument_list|)
expr_stmt|;
name|ext_phy_type
operator|=
name|XGXS_EXT_PHY_TYPE
argument_list|(
name|sc
operator|->
name|link_params
operator|.
name|ext_phy_config
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ext_phy_type
condition|)
block|{
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8072
case|:
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073
case|:
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726
case|:
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727
case|:
name|bxe_release_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_MDIO
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_PHY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe__link_reset
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|DBENTER
argument_list|(
name|BXE_VERBOSE_PHY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NOMCP
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|bxe_acquire_phy_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_link_reset
argument_list|(
operator|&
name|sc
operator|->
name|link_params
argument_list|,
operator|&
name|sc
operator|->
name|link_vars
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bxe_release_phy_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): Bootcode is not running, not resetting link!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_PHY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop the controller.  *  * Returns:  *   0 = Success, !0 = Failure  */
end_comment

begin_function
specifier|static
name|int
name|bxe_stop_locked
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|unload_mode
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mac_configuration_cmd
modifier|*
name|config
decl_stmt|;
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|uint32_t
name|reset_code
decl_stmt|;
name|uint32_t
name|emac_base
decl_stmt|,
name|val
decl_stmt|;
name|uint8_t
name|entry
decl_stmt|,
modifier|*
name|mac_addr
decl_stmt|;
name|int
name|count
decl_stmt|,
name|i
decl_stmt|,
name|port
decl_stmt|,
name|rc
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_INFO_LOAD
operator||
name|BXE_INFO_RESET
operator||
name|BXE_INFO_UNLOAD
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|bxe_ifp
expr_stmt|;
name|port
operator|=
name|BP_PORT
argument_list|(
name|sc
argument_list|)
operator|,
name|rc
operator|=
name|reset_code
operator|=
literal|0
expr_stmt|;
name|BXE_CORE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Stop the periodic tick. */
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|bxe_tick_callout
argument_list|)
expr_stmt|;
name|sc
operator|->
name|state
operator|=
name|BXE_STATE_CLOSING_WAIT4_HALT
expr_stmt|;
comment|/* Prevent any further RX traffic. */
name|sc
operator|->
name|rx_mode
operator|=
name|BXE_RX_MODE_NONE
expr_stmt|;
name|bxe_set_storm_rx_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Tell the stack the driver is stopped and TX queue is full. */
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
name|ifp
operator|->
name|if_drv_flags
operator|=
literal|0
expr_stmt|;
comment|/* Tell the bootcode to stop watching for a heartbeat. */
name|SHMEM_WR
argument_list|(
name|sc
argument_list|,
name|func_mb
index|[
name|BP_FUNC
argument_list|(
name|sc
argument_list|)
index|]
operator|.
name|drv_pulse_mb
argument_list|,
operator|(
name|DRV_PULSE_ALWAYS_ALIVE
operator||
name|sc
operator|->
name|fw_drv_pulse_wr_seq
operator|)
argument_list|)
expr_stmt|;
comment|/* Stop the statistics updates. */
name|bxe_stats_handle
argument_list|(
name|sc
argument_list|,
name|STATS_EVENT_STOP
argument_list|)
expr_stmt|;
comment|/* Wait until all TX fastpath tasks have completed. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
operator|||
name|fp
operator|->
name|tx_pkt_cons_sb
operator|==
name|NULL
condition|)
break|break;
name|count
operator|=
literal|1000
expr_stmt|;
while|while
condition|(
name|bxe_has_tx_work
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|bxe_txeof
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Timeout wating for fp[%02d] transmits to complete!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
name|count
operator|--
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|rmb
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Wait until all slowpath tasks have completed. */
name|count
operator|=
literal|1000
expr_stmt|;
while|while
condition|(
operator|(
name|sc
operator|->
name|spq_left
operator|!=
name|MAX_SPQ_PENDING
operator|)
operator|&&
name|count
operator|--
condition|)
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* Disable Interrupts */
name|bxe_int_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* Clear the MAC addresses. */
if|if
condition|(
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|config
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|mcast_config
argument_list|)
expr_stmt|;
name|bxe_set_mac_addr_e1
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|config
operator|->
name|hdr
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|CAM_INVALIDATE
argument_list|(
operator|&
name|config
operator|->
name|config_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|config
operator|->
name|hdr
operator|.
name|length
operator|=
name|i
expr_stmt|;
name|config
operator|->
name|hdr
operator|.
name|offset
operator|=
name|BXE_MAX_MULTICAST
operator|*
operator|(
literal|1
operator|+
name|port
operator|)
expr_stmt|;
name|config
operator|->
name|hdr
operator|.
name|client_id
operator|=
name|BP_CL_ID
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|config
operator|->
name|hdr
operator|.
name|reserved1
operator|=
literal|0
expr_stmt|;
name|bxe_sp_post
argument_list|(
name|sc
argument_list|,
name|RAMROD_CMD_ID_ETH_SET_MAC
argument_list|,
literal|0
argument_list|,
name|U64_HI
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|mcast_config
argument_list|)
argument_list|)
argument_list|,
name|U64_LO
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|mcast_config
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LLH0_FUNC_EN
operator|+
name|port
operator|*
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bxe_set_mac_addr_e1h
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MC_HASH_SIZE
condition|;
name|i
operator|++
control|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MC_HASH_OFFSET
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_E1HMF_MODE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Determine if any WoL settings needed. */
if|if
condition|(
name|unload_mode
operator|==
name|UNLOAD_NORMAL
condition|)
comment|/* Driver initiatied WoL is disabled. */
name|reset_code
operator|=
name|DRV_MSG_CODE_UNLOAD_REQ_WOL_DIS
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|bxe_flags
operator|&
name|BXE_NO_WOL_FLAG
condition|)
block|{
comment|/* Driver initiated WoL is disabled, use OOB WoL settings. */
name|reset_code
operator|=
name|DRV_MSG_CODE_UNLOAD_REQ_WOL_MCP
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
condition|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_E1HMF_MODE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|wol
condition|)
block|{
name|emac_base
operator|=
name|BP_PORT
argument_list|(
name|sc
argument_list|)
condition|?
name|GRCBASE_EMAC0
else|:
name|GRCBASE_EMAC1
expr_stmt|;
name|mac_addr
operator|=
name|sc
operator|->
name|link_params
operator|.
name|mac_addr
expr_stmt|;
name|entry
operator|=
operator|(
name|BP_E1HVN
argument_list|(
name|sc
argument_list|)
operator|+
literal|1
operator|)
operator|*
literal|8
expr_stmt|;
name|val
operator|=
operator|(
name|mac_addr
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|mac_addr
index|[
literal|1
index|]
expr_stmt|;
name|EMAC_WR
argument_list|(
name|sc
argument_list|,
name|EMAC_REG_EMAC_MAC_MATCH
operator|+
name|entry
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|mac_addr
index|[
literal|2
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|mac_addr
index|[
literal|3
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|mac_addr
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator||
name|mac_addr
index|[
literal|5
index|]
expr_stmt|;
name|EMAC_WR
argument_list|(
name|sc
argument_list|,
name|EMAC_REG_EMAC_MAC_MATCH
operator|+
name|entry
operator|+
literal|4
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|reset_code
operator|=
name|DRV_MSG_CODE_UNLOAD_REQ_WOL_EN
expr_stmt|;
block|}
else|else
block|{
comment|/* Prevent WoL. */
name|reset_code
operator|=
name|DRV_MSG_CODE_UNLOAD_REQ_WOL_DIS
expr_stmt|;
block|}
comment|/* Stop all non-leading client connections. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bxe_stop_multi
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
condition|)
block|{
goto|goto
name|bxe_stop_locked_exit
goto|;
block|}
block|}
comment|/* Stop the leading client connection. */
name|rc
operator|=
name|bxe_stop_leading
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|bxe_stop_locked_exit
label|:
if|if
condition|(
name|NOMCP
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_INFO
argument_list|,
literal|"%s(): Old No MCP load counts:  %d, %d, %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|load_count
index|[
literal|0
index|]
argument_list|,
name|load_count
index|[
literal|1
index|]
argument_list|,
name|load_count
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|load_count
index|[
literal|0
index|]
operator|--
expr_stmt|;
name|load_count
index|[
literal|1
operator|+
name|port
index|]
operator|--
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_INFO
argument_list|,
literal|"%s(): New No MCP load counts:  %d, %d, %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|load_count
index|[
literal|0
index|]
argument_list|,
name|load_count
index|[
literal|1
index|]
argument_list|,
name|load_count
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|load_count
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|reset_code
operator|=
name|FW_MSG_CODE_DRV_UNLOAD_COMMON
expr_stmt|;
elseif|else
if|if
condition|(
name|load_count
index|[
literal|1
operator|+
name|BP_PORT
argument_list|(
name|sc
argument_list|)
index|]
operator|==
literal|0
condition|)
name|reset_code
operator|=
name|FW_MSG_CODE_DRV_UNLOAD_PORT
expr_stmt|;
else|else
name|reset_code
operator|=
name|FW_MSG_CODE_DRV_UNLOAD_FUNCTION
expr_stmt|;
block|}
else|else
block|{
comment|/* Tell MCP driver unload is complete. */
name|reset_code
operator|=
name|bxe_fw_command
argument_list|(
name|sc
argument_list|,
name|reset_code
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|reset_code
operator|==
name|FW_MSG_CODE_DRV_UNLOAD_COMMON
operator|)
operator|||
operator|(
name|reset_code
operator|==
name|FW_MSG_CODE_DRV_UNLOAD_PORT
operator|)
condition|)
name|bxe__link_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/* Reset the chip */
name|bxe_reset_chip
argument_list|(
name|sc
argument_list|,
name|reset_code
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/* Report UNLOAD_DONE to MCP */
if|if
condition|(
operator|!
name|NOMCP
argument_list|(
name|sc
argument_list|)
condition|)
name|bxe_fw_command
argument_list|(
name|sc
argument_list|,
name|DRV_MSG_CODE_UNLOAD_DONE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|port
operator|.
name|pmf
operator|=
literal|0
expr_stmt|;
comment|/* Free RX chains and buffers. */
name|bxe_clear_rx_chains
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Free TX chains and buffers. */
name|bxe_clear_tx_chains
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|state
operator|=
name|BXE_STATE_CLOSED
expr_stmt|;
name|bxe_ack_int
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_INFO_LOAD
operator||
name|BXE_INFO_RESET
operator||
name|BXE_INFO_UNLOAD
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Device shutdown function.  *  * Stops and resets the controller.  *  * Returns:  *   0 = Success, !0 = Failure  */
end_comment

begin_function
specifier|static
name|int
name|bxe_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_INFO_LOAD
operator||
name|BXE_INFO_RESET
operator||
name|BXE_INFO_UNLOAD
argument_list|)
expr_stmt|;
name|BXE_CORE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_stop_locked
argument_list|(
name|sc
argument_list|,
name|UNLOAD_NORMAL
argument_list|)
expr_stmt|;
name|BXE_CORE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_INFO_LOAD
operator||
name|BXE_INFO_RESET
operator||
name|BXE_INFO_UNLOAD
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Prints out link speed and duplex setting to console.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_link_report
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|line_speed
decl_stmt|;
name|uint16_t
name|vn_max_rate
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_PHY
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|link_vars
operator|.
name|link_up
condition|)
block|{
comment|/* Report the link status change to OS. */
if|if
condition|(
name|sc
operator|->
name|state
operator|==
name|BXE_STATE_OPEN
condition|)
name|if_link_state_change
argument_list|(
name|sc
operator|->
name|bxe_ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
name|line_speed
operator|=
name|sc
operator|->
name|link_vars
operator|.
name|line_speed
expr_stmt|;
if|if
condition|(
name|IS_E1HMF
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|vn_max_rate
operator|=
operator|(
operator|(
name|sc
operator|->
name|mf_config
index|[
name|BP_E1HVN
argument_list|(
name|sc
argument_list|)
index|]
operator|&
name|FUNC_MF_CFG_MAX_BW_MASK
operator|)
operator|>>
name|FUNC_MF_CFG_MAX_BW_SHIFT
operator|)
operator|*
literal|100
expr_stmt|;
if|if
condition|(
name|vn_max_rate
operator|<
name|line_speed
condition|)
name|line_speed
operator|=
name|vn_max_rate
expr_stmt|;
block|}
name|BXE_PRINTF
argument_list|(
literal|"Link is up, %d Mbps, "
argument_list|,
name|line_speed
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|link_vars
operator|.
name|duplex
operator|==
name|MEDIUM_FULL_DUPLEX
condition|)
name|printf
argument_list|(
literal|"full duplex"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"half duplex"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|link_vars
operator|.
name|flow_ctrl
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|link_vars
operator|.
name|flow_ctrl
operator|&
name|FLOW_CTRL_RX
condition|)
block|{
name|printf
argument_list|(
literal|", receive "
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|link_vars
operator|.
name|flow_ctrl
operator|&
name|FLOW_CTRL_TX
condition|)
name|printf
argument_list|(
literal|"& transmit "
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|", transmit "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"flow control ON"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Report the link down */
name|BXE_PRINTF
argument_list|(
literal|"Link is down\n"
argument_list|)
expr_stmt|;
name|if_link_state_change
argument_list|(
name|sc
operator|->
name|bxe_ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
block|}
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_PHY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe__link_status_update
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|DBENTER
argument_list|(
name|BXE_VERBOSE_PHY
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|stats_enable
operator|==
name|FALSE
operator|||
name|sc
operator|->
name|state
operator|!=
name|BXE_STATE_OPEN
condition|)
return|return;
name|bxe_link_status_update
argument_list|(
operator|&
name|sc
operator|->
name|link_params
argument_list|,
operator|&
name|sc
operator|->
name|link_vars
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|link_vars
operator|.
name|link_up
condition|)
name|bxe_stats_handle
argument_list|(
name|sc
argument_list|,
name|STATS_EVENT_LINK_UP
argument_list|)
expr_stmt|;
else|else
name|bxe_stats_handle
argument_list|(
name|sc
argument_list|,
name|STATS_EVENT_STOP
argument_list|)
expr_stmt|;
name|bxe_read_mf_cfg
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Indicate link status. */
name|bxe_link_report
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_PHY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Calculate flow control to advertise during autonegotiation.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_calc_fc_adv
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|DBENTER
argument_list|(
name|BXE_EXTREME_PHY
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|link_vars
operator|.
name|ieee_fc
operator|&
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_MASK
condition|)
block|{
case|case
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_NONE
case|:
name|sc
operator|->
name|port
operator|.
name|advertising
operator|&=
operator|~
operator|(
name|ADVERTISED_Asym_Pause
operator||
name|ADVERTISED_Pause
operator|)
expr_stmt|;
break|break;
case|case
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH
case|:
name|sc
operator|->
name|port
operator|.
name|advertising
operator||=
operator|(
name|ADVERTISED_Asym_Pause
operator||
name|ADVERTISED_Pause
operator|)
expr_stmt|;
break|break;
case|case
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC
case|:
name|sc
operator|->
name|port
operator|.
name|advertising
operator||=
name|ADVERTISED_Asym_Pause
expr_stmt|;
break|break;
default|default:
name|sc
operator|->
name|port
operator|.
name|advertising
operator|&=
operator|~
operator|(
name|ADVERTISED_Asym_Pause
operator||
name|ADVERTISED_Pause
operator|)
expr_stmt|;
break|break;
block|}
name|DBEXIT
argument_list|(
name|BXE_EXTREME_PHY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  * Returns:  *  */
end_comment

begin_function
specifier|static
name|uint8_t
name|bxe_initial_phy_init
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint8_t
name|rc
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_PHY
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|NOMCP
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* 		 * It is recommended to turn off RX flow control for 5771x 		 * when using jumbo frames for better performance. 		 */
if|if
condition|(
operator|!
name|IS_E1HMF
argument_list|(
name|sc
argument_list|)
operator|&&
operator|(
name|sc
operator|->
name|mbuf_alloc_size
operator|>
literal|5000
operator|)
condition|)
name|sc
operator|->
name|link_params
operator|.
name|req_fc_auto_adv
operator|=
name|FLOW_CTRL_TX
expr_stmt|;
else|else
name|sc
operator|->
name|link_params
operator|.
name|req_fc_auto_adv
operator|=
name|FLOW_CTRL_BOTH
expr_stmt|;
name|bxe_acquire_phy_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rc
operator|=
name|bxe_phy_init
argument_list|(
operator|&
name|sc
operator|->
name|link_params
argument_list|,
operator|&
name|sc
operator|->
name|link_vars
argument_list|)
expr_stmt|;
name|bxe_release_phy_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_calc_fc_adv
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|link_vars
operator|.
name|link_up
condition|)
block|{
name|bxe_stats_handle
argument_list|(
name|sc
argument_list|,
name|STATS_EVENT_LINK_UP
argument_list|)
expr_stmt|;
name|bxe_link_report
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): Bootcode is not running, "
literal|"not initializing link!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EINVAL
expr_stmt|;
block|}
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_PHY
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
end_if

begin_comment
comment|/*  * Allocate buffer rings used for multiqueue.  *  * Returns:  *   0 = Success, !0 = Failure.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_alloc_buf_rings
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
name|fp
operator|->
name|br
operator|=
name|buf_ring_alloc
argument_list|(
name|BXE_BR_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|,
operator|&
name|fp
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|br
operator|==
name|NULL
condition|)
block|{
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bxe_alloc_buf_rings_exit
goto|;
block|}
block|}
else|else
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Bug!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
name|bxe_alloc_buf_rings_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Releases buffer rings used for multiqueue.  *  * Returns:  *   None  */
end_comment

begin_function
specifier|static
name|void
name|bxe_free_buf_rings
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_UNLOAD
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fp
operator|->
name|br
operator|!=
name|NULL
condition|)
name|buf_ring_free
argument_list|(
name|fp
operator|->
name|br
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_UNLOAD
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Handles controller initialization.  *  * Must be called from a locked routine.  Since this code  * may be called from the OS it does not provide a return  * error value and must clean-up it's own mess.  *  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_init_locked
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|load_mode
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|uint32_t
name|load_code
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|port
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_INFO_LOAD
operator||
name|BXE_INFO_RESET
argument_list|)
expr_stmt|;
name|BXE_CORE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|bxe_ifp
expr_stmt|;
comment|/* Skip if we're in panic mode. */
if|if
condition|(
name|sc
operator|->
name|panic
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): Panic mode enabled, exiting!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
goto|goto
name|bxe_init_locked_exit
goto|;
block|}
comment|/* Check if the driver is still running and bail out if it is. */
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): Init called while driver is running!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
goto|goto
name|bxe_init_locked_exit
goto|;
block|}
comment|/* 	 * Send LOAD_REQUEST command to MCP. 	 * The MCP will return the type of LOAD 	 * the driver should perform. 	 * - If it is the first port to be initialized 	 *   then all common blocks should be initialized. 	 * - If it is not the first port to be initialized 	 *   then don't do the common block initialization. 	 */
name|sc
operator|->
name|state
operator|=
name|BXE_STATE_OPENING_WAIT4_LOAD
expr_stmt|;
if|if
condition|(
name|NOMCP
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|port
operator|=
name|BP_PORT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_INFO
argument_list|,
literal|"%s(): Old No MCP load counts:  %d, %d, %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|load_count
index|[
literal|0
index|]
argument_list|,
name|load_count
index|[
literal|1
index|]
argument_list|,
name|load_count
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|load_count
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|load_count
index|[
literal|1
operator|+
name|port
index|]
operator|++
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_INFO
argument_list|,
literal|"%s(): New No MCP load counts:  %d, %d, %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|load_count
index|[
literal|0
index|]
argument_list|,
name|load_count
index|[
literal|1
index|]
argument_list|,
name|load_count
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* No MCP to tell us what to do. */
if|if
condition|(
name|load_count
index|[
literal|0
index|]
operator|==
literal|1
condition|)
name|load_code
operator|=
name|FW_MSG_CODE_DRV_LOAD_COMMON
expr_stmt|;
elseif|else
if|if
condition|(
name|load_count
index|[
literal|1
operator|+
name|port
index|]
operator|==
literal|1
condition|)
name|load_code
operator|=
name|FW_MSG_CODE_DRV_LOAD_PORT
expr_stmt|;
else|else
name|load_code
operator|=
name|FW_MSG_CODE_DRV_LOAD_FUNCTION
expr_stmt|;
block|}
else|else
block|{
comment|/* Ask the MCP what type of initialization we need to do. */
name|load_code
operator|=
name|bxe_fw_command
argument_list|(
name|sc
argument_list|,
name|DRV_MSG_CODE_LOAD_REQ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|load_code
operator|==
literal|0
operator|)
operator|||
operator|(
name|load_code
operator|==
name|FW_MSG_CODE_DRV_LOAD_REFUSED
operator|)
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Bootcode refused load request.!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
goto|goto
name|bxe_init_locked_failed1
goto|;
block|}
block|}
comment|/* Keep track of whether we are controlling the port. */
if|if
condition|(
operator|(
name|load_code
operator|==
name|FW_MSG_CODE_DRV_LOAD_COMMON
operator|)
operator|||
operator|(
name|load_code
operator|==
name|FW_MSG_CODE_DRV_LOAD_PORT
operator|)
condition|)
name|sc
operator|->
name|port
operator|.
name|pmf
operator|=
literal|1
expr_stmt|;
else|else
name|sc
operator|->
name|port
operator|.
name|pmf
operator|=
literal|0
expr_stmt|;
comment|/* Block any interrupts until we're ready. */
name|sc
operator|->
name|intr_sem
operator|=
literal|1
expr_stmt|;
comment|/* Initialize hardware. */
name|error
operator|=
name|bxe_init_hw
argument_list|(
name|sc
argument_list|,
name|load_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Hardware initialization failed, "
literal|"aborting!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
goto|goto
name|bxe_init_locked_failed1
goto|;
block|}
comment|/* Calculate and save the Ethernet MTU size. */
name|sc
operator|->
name|port
operator|.
name|ether_mtu
operator|=
name|ifp
operator|->
name|if_mtu
operator|+
name|ETHER_HDR_LEN
operator|+
operator|(
name|ETHER_VLAN_ENCAP_LEN
operator|*
literal|2
operator|)
operator|+
name|ETHER_CRC_LEN
operator|+
literal|4
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_INFO
argument_list|,
literal|"%s(): Setting MTU = %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|port
operator|.
name|ether_mtu
argument_list|)
expr_stmt|;
comment|/* Setup the mbuf allocation size for RX frames. */
if|if
condition|(
name|sc
operator|->
name|port
operator|.
name|ether_mtu
operator|<=
name|MCLBYTES
condition|)
name|sc
operator|->
name|mbuf_alloc_size
operator|=
name|MCLBYTES
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|port
operator|.
name|ether_mtu
operator|<=
name|PAGE_SIZE
condition|)
name|sc
operator|->
name|mbuf_alloc_size
operator|=
name|PAGE_SIZE
expr_stmt|;
else|else
name|sc
operator|->
name|mbuf_alloc_size
operator|=
name|MJUM9BYTES
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_INFO
argument_list|,
literal|"%s(): mbuf_alloc_size = %d, "
literal|"max_frame_size = %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|mbuf_alloc_size
argument_list|,
name|sc
operator|->
name|port
operator|.
name|ether_mtu
argument_list|)
expr_stmt|;
comment|/* Setup NIC internals and enable interrupts. */
name|error
operator|=
name|bxe_init_nic
argument_list|(
name|sc
argument_list|,
name|load_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): NIC initialization failed, "
literal|"aborting!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
goto|goto
name|bxe_init_locked_failed1
goto|;
block|}
if|if
condition|(
operator|(
name|load_code
operator|==
name|FW_MSG_CODE_DRV_LOAD_COMMON
operator|)
operator|&&
operator|(
name|sc
operator|->
name|common
operator|.
name|shmem2_base
operator|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|dcc_enable
operator|==
name|TRUE
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"Enabing DCC support\n"
argument_list|)
expr_stmt|;
name|SHMEM2_WR
argument_list|(
name|sc
argument_list|,
name|dcc_support
argument_list|,
operator|(
name|SHMEM_DCC_SUPPORT_DISABLE_ENABLE_PF_TLV
operator||
name|SHMEM_DCC_SUPPORT_BANDWIDTH_ALLOCATION_TLV
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
comment|/* Allocate buffer rings for multiqueue operation. */
name|error
operator|=
name|bxe_alloc_buf_rings
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Buffer ring initialization failed, "
literal|"aborting!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
goto|goto
name|bxe_init_locked_failed1
goto|;
block|}
endif|#
directive|endif
comment|/* Tell MCP that driver load is done. */
if|if
condition|(
operator|!
name|NOMCP
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|load_code
operator|=
name|bxe_fw_command
argument_list|(
name|sc
argument_list|,
name|DRV_MSG_CODE_LOAD_DONE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|load_code
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Driver load failed! No MCP "
literal|"response to LOAD_DONE!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
goto|goto
name|bxe_init_locked_failed2
goto|;
block|}
block|}
name|sc
operator|->
name|state
operator|=
name|BXE_STATE_OPENING_WAIT4_PORT
expr_stmt|;
comment|/* Enable ISR for PORT_SETUP ramrod. */
name|sc
operator|->
name|intr_sem
operator|=
literal|0
expr_stmt|;
comment|/* Setup the leading connection for the controller. */
name|error
operator|=
name|bxe_setup_leading
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): Initial PORT_SETUP ramrod "
literal|"failed. State is not OPEN!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
goto|goto
name|bxe_init_locked_failed3
goto|;
block|}
if|if
condition|(
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|mf_config
index|[
name|BP_E1HVN
argument_list|(
name|sc
argument_list|)
index|]
operator|&
name|FUNC_MF_CFG_FUNC_DISABLED
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"Multi-function mode is disabled\n"
argument_list|)
expr_stmt|;
comment|/* sc->state = BXE_STATE_DISABLED; */
block|}
comment|/* Setup additional client connections for RSS/multi-queue */
if|if
condition|(
name|sc
operator|->
name|state
operator|==
name|BXE_STATE_OPEN
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bxe_setup_multi
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): fp[%02d] CLIENT_SETUP ramrod failed! State not OPEN!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|bxe_init_locked_failed4
goto|;
block|}
block|}
block|}
block|}
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
name|bxe_int_enable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
comment|/* Initialize statistics. */
name|bxe_stats_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* Load our MAC address. */
name|bcopy
argument_list|(
name|IF_LLADDR
argument_list|(
name|sc
operator|->
name|bxe_ifp
argument_list|)
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|mac_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
name|bxe_set_mac_addr_e1
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|bxe_set_mac_addr_e1h
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* Perform PHY initialization for the primary port. */
if|if
condition|(
name|sc
operator|->
name|port
operator|.
name|pmf
condition|)
name|bxe_initial_phy_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* Start fastpath. */
switch|switch
condition|(
name|load_mode
condition|)
block|{
case|case
name|LOAD_NORMAL
case|:
case|case
name|LOAD_OPEN
case|:
comment|/* Initialize the receive filters. */
name|bxe_set_rx_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOAD_DIAG
case|:
comment|/* Initialize the receive filters. */
name|bxe_set_rx_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|state
operator|=
name|BXE_STATE_DIAG
expr_stmt|;
break|break;
default|default:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): Unknown load mode (%d)!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|load_mode
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|sc
operator|->
name|port
operator|.
name|pmf
condition|)
name|bxe__link_status_update
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* Tell the stack the driver is running. */
name|ifp
operator|->
name|if_drv_flags
operator|=
name|IFF_DRV_RUNNING
expr_stmt|;
comment|/* Schedule our periodic timer tick. */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|bxe_tick_callout
argument_list|,
name|hz
argument_list|,
name|bxe_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* Everything went OK, go ahead and exit. */
goto|goto
name|bxe_init_locked_exit
goto|;
name|bxe_init_locked_failed4
label|:
comment|/* Try and gracefully shutdown the device because of a failure. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
name|bxe_stop_multi
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|bxe_init_locked_failed3
label|:
name|bxe_stop_leading
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_stats_handle
argument_list|(
name|sc
argument_list|,
name|STATS_EVENT_STOP
argument_list|)
expr_stmt|;
name|bxe_init_locked_failed2
label|:
name|bxe_int_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_init_locked_failed1
label|:
if|if
condition|(
operator|!
name|NOMCP
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|bxe_fw_command
argument_list|(
name|sc
argument_list|,
name|DRV_MSG_CODE_LOAD_DONE
argument_list|)
expr_stmt|;
name|bxe_fw_command
argument_list|(
name|sc
argument_list|,
name|DRV_MSG_CODE_UNLOAD_REQ_WOL_MCP
argument_list|)
expr_stmt|;
name|bxe_fw_command
argument_list|(
name|sc
argument_list|,
name|DRV_MSG_CODE_UNLOAD_DONE
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|port
operator|.
name|pmf
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
name|bxe_free_buf_rings
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): Initialization failed!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|bxe_init_locked_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_INFO_LOAD
operator||
name|BXE_INFO_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Ramrod wait function.  *  * Waits for a ramrod command to complete.  *  * Returns:  *   0 = Success, !0 = Failure  */
end_comment

begin_function
specifier|static
name|int
name|bxe_wait_ramrod
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|state
parameter_list|,
name|int
name|idx
parameter_list|,
name|int
modifier|*
name|state_p
parameter_list|,
name|int
name|poll
parameter_list|)
block|{
name|int
name|rc
decl_stmt|,
name|timeout
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator||
name|BXE_VERBOSE_RAMROD
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_RAMROD
argument_list|,
literal|"%s(): %s for state 0x%08X on "
literal|"fp[%02d], currently 0x%08X.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|poll
condition|?
literal|"Polling"
else|:
literal|"Waiting"
argument_list|,
name|state
argument_list|,
name|idx
argument_list|,
operator|*
name|state_p
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
name|timeout
operator|=
literal|5000
expr_stmt|;
while|while
condition|(
name|timeout
condition|)
block|{
comment|/* Manually check for the completion. */
if|if
condition|(
name|poll
condition|)
block|{
name|bxe_rxeof
argument_list|(
name|sc
operator|->
name|fp
argument_list|)
expr_stmt|;
comment|/* 			 * Some commands don't use the leading client 			 * connection. 			 */
if|if
condition|(
name|idx
condition|)
name|bxe_rxeof
argument_list|(
operator|&
name|sc
operator|->
name|fp
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* State may be changed by bxe_sp_event(). */
name|mb
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|state_p
operator|==
name|state
condition|)
goto|goto
name|bxe_wait_ramrod_exit
goto|;
name|timeout
operator|--
expr_stmt|;
comment|/* Pause 1ms before checking again. */
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
comment|/* We timed out polling for a completion. */
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): Timeout %s for state 0x%08X on fp[%02d]. "
literal|"Got 0x%x instead\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|poll
condition|?
literal|"polling"
else|:
literal|"waiting"
argument_list|,
name|state
argument_list|,
name|idx
argument_list|,
operator|*
name|state_p
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EBUSY
expr_stmt|;
name|bxe_wait_ramrod_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator||
name|BXE_VERBOSE_RAMROD
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  *  */
end_comment

begin_function
specifier|static
name|void
name|bxe_write_dmae_phys_len
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|bus_addr_t
name|phys_addr
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|len
parameter_list|)
block|{
name|int
name|dmae_wr_max
decl_stmt|,
name|offset
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_INSANE_REGS
argument_list|)
expr_stmt|;
name|dmae_wr_max
operator|=
name|DMAE_LEN32_WR_MAX
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|len
operator|>
name|dmae_wr_max
condition|)
block|{
name|bxe_write_dmae
argument_list|(
name|sc
argument_list|,
name|phys_addr
operator|+
name|offset
argument_list|,
name|addr
operator|+
name|offset
argument_list|,
name|dmae_wr_max
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|dmae_wr_max
operator|*
literal|4
expr_stmt|;
name|len
operator|-=
name|dmae_wr_max
expr_stmt|;
block|}
name|bxe_write_dmae
argument_list|(
name|sc
argument_list|,
name|phys_addr
operator|+
name|offset
argument_list|,
name|addr
operator|+
name|offset
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_INSANE_REGS
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|INIT_MEM_WR
parameter_list|(
name|block
parameter_list|,
name|reg
parameter_list|,
name|part
parameter_list|,
name|hw
parameter_list|,
name|data
parameter_list|,
name|reg_off
parameter_list|,
name|len
parameter_list|)
define|\
value|bxe_init_str_wr(sc, GRCBASE_##block + reg + reg_off * 4, data, len)
end_define

begin_comment
comment|/*  * Write a block of data to a range of registers.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_init_str_wr
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
specifier|const
name|uint32_t
modifier|*
name|data
parameter_list|,
name|uint32_t
name|len
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|addr
operator|+
name|i
operator|*
literal|4
argument_list|,
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write a block of data to a range of registers using indirect access.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_init_ind_wr
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
specifier|const
name|uint32_t
modifier|*
name|data
parameter_list|,
name|uint16_t
name|len
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|addr
operator|+
name|i
operator|*
literal|4
argument_list|,
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_write_big_buf
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|len
parameter_list|)
block|{
name|DBENTER
argument_list|(
name|BXE_INSANE_REGS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BXE_USE_DMAE
if|if
condition|(
name|sc
operator|->
name|dmae_ready
condition|)
name|bxe_write_dmae_phys_len
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|gz_dma
operator|.
name|paddr
argument_list|,
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|bxe_init_str_wr
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|sc
operator|->
name|gz
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|#
directive|else
name|bxe_init_str_wr
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|sc
operator|->
name|gz
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DBEXIT
argument_list|(
name|BXE_INSANE_REGS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Fill areas of device memory with the specified value.  *  * Generally used to clear a small area of device memory prior to writing  * firmware to STORM memory or writing STORM firmware to device memory.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_init_fill
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|int
name|fill
parameter_list|,
name|uint32_t
name|len
parameter_list|)
block|{
name|uint32_t
name|cur_len
decl_stmt|,
name|i
decl_stmt|,
name|leftovers
decl_stmt|,
name|length
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
argument_list|)
expr_stmt|;
name|length
operator|=
operator|(
operator|(
operator|(
name|len
operator|*
literal|4
operator|)
operator|>
name|BXE_FW_BUF_SIZE
operator|)
condition|?
name|BXE_FW_BUF_SIZE
else|:
operator|(
name|len
operator|*
literal|4
operator|)
operator|)
expr_stmt|;
name|leftovers
operator|=
name|length
operator|/
literal|4
expr_stmt|;
name|memset
argument_list|(
name|sc
operator|->
name|gz
argument_list|,
name|fill
argument_list|,
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
name|leftovers
control|)
block|{
name|cur_len
operator|=
name|min
argument_list|(
name|leftovers
argument_list|,
name|len
operator|-
name|i
argument_list|)
expr_stmt|;
name|bxe_write_big_buf
argument_list|(
name|sc
argument_list|,
name|addr
operator|+
name|i
operator|*
literal|4
argument_list|,
name|cur_len
argument_list|)
expr_stmt|;
block|}
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_init_wr_64
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
specifier|const
name|uint32_t
modifier|*
name|data
parameter_list|,
name|uint32_t
name|len64
parameter_list|)
block|{
name|uint64_t
name|data64
decl_stmt|,
modifier|*
name|pdata
decl_stmt|;
name|uint32_t
name|buf_len32
decl_stmt|,
name|cur_len
decl_stmt|,
name|len
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_INSANE_REGS
argument_list|)
expr_stmt|;
name|buf_len32
operator|=
name|BXE_FW_BUF_SIZE
operator|/
literal|4
expr_stmt|;
name|len
operator|=
name|len64
operator|*
literal|2
expr_stmt|;
comment|/* 64 bit value is in a blob: first low DWORD, then high DWORD. */
name|data64
operator|=
name|HILO_U64
argument_list|(
operator|(
operator|*
operator|(
name|data
operator|+
literal|1
operator|)
operator|)
argument_list|,
operator|(
operator|*
name|data
operator|)
argument_list|)
expr_stmt|;
name|len64
operator|=
name|min
argument_list|(
call|(
name|uint32_t
call|)
argument_list|(
name|BXE_FW_BUF_SIZE
operator|/
literal|8
argument_list|)
argument_list|,
name|len64
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len64
condition|;
name|i
operator|++
control|)
block|{
name|pdata
operator|=
operator|(
operator|(
name|uint64_t
operator|*
operator|)
operator|(
name|sc
operator|->
name|gz
operator|)
operator|)
operator|+
name|i
expr_stmt|;
operator|*
name|pdata
operator|=
name|data64
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
name|buf_len32
control|)
block|{
name|cur_len
operator|=
name|min
argument_list|(
name|buf_len32
argument_list|,
name|len
operator|-
name|i
argument_list|)
expr_stmt|;
name|bxe_write_big_buf
argument_list|(
name|sc
argument_list|,
name|addr
operator|+
name|i
operator|*
literal|4
argument_list|,
name|cur_len
argument_list|)
expr_stmt|;
block|}
name|DBEXIT
argument_list|(
name|BXE_INSANE_REGS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * There are different blobs for each PRAM section. In addition, each  * blob write operation is divided into multiple, smaller write  * operations in order to decrease the amount of physically contiguous  * buffer memory needed. Thus, when we select a blob, the address may  * be with some offset from the beginning of PRAM section. The same  * holds for the INT_TABLE sections.  */
end_comment

begin_define
define|#
directive|define
name|IF_IS_INT_TABLE_ADDR
parameter_list|(
name|base
parameter_list|,
name|addr
parameter_list|)
define|\
value|if (((base)<= (addr))&& ((base) + 0x400>= (addr)))
end_define

begin_define
define|#
directive|define
name|IF_IS_PRAM_ADDR
parameter_list|(
name|base
parameter_list|,
name|addr
parameter_list|)
define|\
value|if (((base)<= (addr))&& ((base) + 0x40000>= (addr)))
end_define

begin_comment
comment|/*  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
specifier|const
name|uint8_t
modifier|*
name|bxe_sel_blob
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|data
parameter_list|)
block|{
name|IF_IS_INT_TABLE_ADDR
argument_list|(
argument|TSEM_REG_INT_TABLE
argument_list|,
argument|addr
argument_list|)
name|data
operator|=
name|INIT_TSEM_INT_TABLE_DATA
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|IF_IS_INT_TABLE_ADDR
argument_list|(
argument|CSEM_REG_INT_TABLE
argument_list|,
argument|addr
argument_list|)
name|data
operator|=
name|INIT_CSEM_INT_TABLE_DATA
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|IF_IS_INT_TABLE_ADDR
argument_list|(
argument|USEM_REG_INT_TABLE
argument_list|,
argument|addr
argument_list|)
name|data
operator|=
name|INIT_USEM_INT_TABLE_DATA
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|IF_IS_INT_TABLE_ADDR
argument_list|(
argument|XSEM_REG_INT_TABLE
argument_list|,
argument|addr
argument_list|)
name|data
operator|=
name|INIT_XSEM_INT_TABLE_DATA
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|IF_IS_PRAM_ADDR
argument_list|(
argument|TSEM_REG_PRAM
argument_list|,
argument|addr
argument_list|)
name|data
operator|=
name|INIT_TSEM_PRAM_DATA
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|IF_IS_PRAM_ADDR
argument_list|(
argument|CSEM_REG_PRAM
argument_list|,
argument|addr
argument_list|)
name|data
operator|=
name|INIT_CSEM_PRAM_DATA
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|IF_IS_PRAM_ADDR
argument_list|(
argument|USEM_REG_PRAM
argument_list|,
argument|addr
argument_list|)
name|data
operator|=
name|INIT_USEM_PRAM_DATA
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|IF_IS_PRAM_ADDR
argument_list|(
argument|XSEM_REG_PRAM
argument_list|,
argument|addr
argument_list|)
name|data
operator|=
name|INIT_XSEM_PRAM_DATA
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_write_big_buf_wb
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|dmae_ready
condition|)
name|bxe_write_dmae_phys_len
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|gz_dma
operator|.
name|paddr
argument_list|,
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|bxe_init_ind_wr
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|sc
operator|->
name|gz
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|VIRT_WR_DMAE_LEN
parameter_list|(
name|sc
parameter_list|,
name|data
parameter_list|,
name|addr
parameter_list|,
name|len32
parameter_list|,
name|le32_swap
parameter_list|)
define|\
value|do { \ 		memcpy(sc->gz, data, (len32)*4); \ 		bxe_write_big_buf_wb(sc, addr, len32); \ 	} while (0)
end_define

begin_comment
comment|/*  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_init_wr_wb
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
specifier|const
name|uint32_t
modifier|*
name|data
parameter_list|,
name|uint32_t
name|len
parameter_list|)
block|{
specifier|const
name|uint32_t
modifier|*
name|old_data
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_INSANE_REGS
argument_list|)
expr_stmt|;
name|old_data
operator|=
name|data
expr_stmt|;
name|data
operator|=
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|bxe_sel_blob
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|dmae_ready
condition|)
block|{
if|if
condition|(
name|old_data
operator|!=
name|data
condition|)
name|VIRT_WR_DMAE_LEN
argument_list|(
name|sc
argument_list|,
name|data
argument_list|,
name|addr
argument_list|,
name|len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|VIRT_WR_DMAE_LEN
argument_list|(
name|sc
argument_list|,
name|data
argument_list|,
name|addr
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|bxe_init_ind_wr
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_INSANE_REGS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_init_wr_zp
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|len
parameter_list|,
name|uint32_t
name|blob_off
parameter_list|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Compressed FW is not supported yet. "
literal|"ERROR: address:0x%x len:0x%x blob_offset:0x%x\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|addr
argument_list|,
name|len
argument_list|,
name|blob_off
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize blocks of the device.  *  * This routine basically performs bulk register programming for different  * blocks within the controller.  The file bxe_init_values.h contains a  * series of register access operations (read, write, fill, etc.) as well  * as a BLOB of data to initialize multiple blocks within the controller.  * Block initialization may be supported by all controllers or by specific  * models only.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_init_block
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|block
parameter_list|,
name|uint32_t
name|stage
parameter_list|)
block|{
name|union
name|init_op
modifier|*
name|op
decl_stmt|;
specifier|const
name|uint32_t
modifier|*
name|data
decl_stmt|,
modifier|*
name|data_base
decl_stmt|;
name|uint32_t
name|i
decl_stmt|,
name|op_type
decl_stmt|,
name|addr
decl_stmt|,
name|len
decl_stmt|;
name|uint16_t
name|op_end
decl_stmt|,
name|op_start
decl_stmt|;
name|int
name|hw_wr
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
name|op_start
operator|=
name|INIT_OPS_OFFSETS
argument_list|(
name|sc
argument_list|)
index|[
name|BLOCK_OPS_IDX
argument_list|(
name|block
argument_list|,
name|stage
argument_list|,
name|STAGE_START
argument_list|)
index|]
expr_stmt|;
name|op_end
operator|=
name|INIT_OPS_OFFSETS
argument_list|(
name|sc
argument_list|)
index|[
name|BLOCK_OPS_IDX
argument_list|(
name|block
argument_list|,
name|stage
argument_list|,
name|STAGE_END
argument_list|)
index|]
expr_stmt|;
comment|/* If empty block */
if|if
condition|(
name|op_start
operator|==
name|op_end
condition|)
return|return;
name|hw_wr
operator|=
name|OP_WR_ASIC
expr_stmt|;
name|data_base
operator|=
name|INIT_DATA
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|op_start
init|;
name|i
operator|<
name|op_end
condition|;
name|i
operator|++
control|)
block|{
name|op
operator|=
operator|(
expr|union
name|init_op
operator|*
operator|)
operator|&
operator|(
name|INIT_OPS
argument_list|(
name|sc
argument_list|)
index|[
name|i
index|]
operator|)
expr_stmt|;
name|op_type
operator|=
name|op
operator|->
name|str_wr
operator|.
name|op
expr_stmt|;
name|addr
operator|=
name|op
operator|->
name|str_wr
operator|.
name|offset
expr_stmt|;
name|len
operator|=
name|op
operator|->
name|str_wr
operator|.
name|data_len
expr_stmt|;
name|data
operator|=
name|data_base
operator|+
name|op
operator|->
name|str_wr
operator|.
name|data_off
expr_stmt|;
comment|/* HW/EMUL specific */
if|if
condition|(
operator|(
name|op_type
operator|>
name|OP_WB
operator|)
operator|&&
operator|(
name|op_type
operator|==
name|hw_wr
operator|)
condition|)
name|op_type
operator|=
name|OP_WR
expr_stmt|;
switch|switch
condition|(
name|op_type
condition|)
block|{
case|case
name|OP_RD
case|:
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_WR
case|:
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|op
operator|->
name|write
operator|.
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_SW
case|:
name|bxe_init_str_wr
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_WB
case|:
name|bxe_init_wr_wb
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_SI
case|:
name|bxe_init_ind_wr
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_ZR
case|:
name|bxe_init_fill
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|,
name|op
operator|->
name|zero
operator|.
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_ZP
case|:
name|bxe_init_wr_zp
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|len
argument_list|,
name|op
operator|->
name|str_wr
operator|.
name|data_off
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_WR_64
case|:
name|bxe_init_wr_64
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* happens whenever an op is of a diff HW */
break|break;
block|}
block|}
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handles controller initialization when called from an unlocked routine.  * ifconfig calls this function.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|xsc
expr_stmt|;
name|BXE_CORE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_init_locked
argument_list|(
name|sc
argument_list|,
name|LOAD_NORMAL
argument_list|)
expr_stmt|;
name|BXE_CORE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Release all resources used by the driver.  *  * Releases all resources acquired by the driver including interrupts,  * interrupt handler, interfaces, mutexes, and DMA memory.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_release_resources
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_RESET
operator||
name|BXE_VERBOSE_UNLOAD
argument_list|)
expr_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
comment|/* Release the FreeBSD interface. */
if|if
condition|(
name|sc
operator|->
name|bxe_ifp
operator|!=
name|NULL
condition|)
name|if_free
argument_list|(
name|sc
operator|->
name|bxe_ifp
argument_list|)
expr_stmt|;
comment|/* Free the DMA resources. */
name|bxe_host_structures_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
comment|/* Free multiqueue buffer rings. */
name|bxe_free_buf_rings
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Indirect register write.  *  * Writes NetXtreme II registers using an index/data register pair in PCI  * configuration space.  Using this mechanism avoids issues with posted  * writes but is much slower than memory-mapped I/O.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_reg_wr_ind
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_INSANE_REGS
argument_list|,
literal|"%s(); offset = 0x%08X, val = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|PCICFG_GRC_ADDRESS
argument_list|,
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|PCICFG_GRC_DATA
argument_list|,
name|val
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Return to a safe address. */
name|pci_write_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|PCICFG_GRC_ADDRESS
argument_list|,
name|PCICFG_VENDOR_ID_OFFSET
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Indirect register read.  *  * Reads NetXtreme II registers using an index/data register pair in PCI  * configuration space.  Using this mechanism avoids issues with posted  * reads but is much slower than memory-mapped I/O.  *  * Returns:  *   The value of the register.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|bxe_reg_rd_ind
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|offset
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|PCICFG_GRC_ADDRESS
argument_list|,
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|val
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|PCICFG_GRC_DATA
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Return to a safe address. */
name|pci_write_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|PCICFG_GRC_ADDRESS
argument_list|,
name|PCICFG_VENDOR_ID_OFFSET
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_INSANE_REGS
argument_list|,
literal|"%s(); offset = 0x%08X, val = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|uint32_t
name|dmae_reg_go_c
index|[]
init|=
block|{
name|DMAE_REG_GO_C0
block|,
name|DMAE_REG_GO_C1
block|,
name|DMAE_REG_GO_C2
block|,
name|DMAE_REG_GO_C3
block|,
name|DMAE_REG_GO_C4
block|,
name|DMAE_REG_GO_C5
block|,
name|DMAE_REG_GO_C6
block|,
name|DMAE_REG_GO_C7
block|,
name|DMAE_REG_GO_C8
block|,
name|DMAE_REG_GO_C9
block|,
name|DMAE_REG_GO_C10
block|,
name|DMAE_REG_GO_C11
block|,
name|DMAE_REG_GO_C12
block|,
name|DMAE_REG_GO_C13
block|,
name|DMAE_REG_GO_C14
block|,
name|DMAE_REG_GO_C15
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Copy DMAE command into memory and start the command.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_post_dmae
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|dmae_command
modifier|*
name|dmae
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|uint32_t
name|cmd_offset
decl_stmt|;
name|int
name|i
decl_stmt|;
name|cmd_offset
operator|=
operator|(
name|DMAE_REG_CMD_MEM
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|dmae_command
argument_list|)
operator|*
name|idx
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|dmae_command
argument_list|)
operator|/
literal|4
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|cmd_offset
operator|+
name|i
operator|*
literal|4
argument_list|,
operator|*
operator|(
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|dmae
operator|)
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_INSANE_REGS
argument_list|,
literal|"%s(): DMAE cmd[%d].%d : 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|idx
argument_list|,
name|i
argument_list|,
name|cmd_offset
operator|+
name|i
operator|*
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* Kick off the command. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|dmae_reg_go_c
index|[
name|idx
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Perform a DMAE write to device memory.  *  * Some of the registers on the 577XX controller are 128bits wide.  It is  * required that when accessing those registers that they be written  * atomically and that no intervening bus acceses to the device occur.  * This could be handled by a lock held across all driver instances for  * the device or it can be handled by performing a DMA operation when  * writing to the device.  This code implements the latter.  *  * Returns:  *   None.  */
end_comment

begin_function
name|void
name|bxe_write_dmae
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|bus_addr_t
name|dma_addr
parameter_list|,
name|uint32_t
name|dst_addr
parameter_list|,
name|uint32_t
name|len32
parameter_list|)
block|{
name|struct
name|dmae_command
name|dmae
decl_stmt|;
name|uint32_t
modifier|*
name|data
decl_stmt|,
modifier|*
name|wb_comp
decl_stmt|;
name|int
name|timeout
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_INSANE_REGS
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_EXTREME_REGS
argument_list|,
literal|"%s(): host addr = 0x%jX, device addr = 0x%08X, length = %d.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|uintmax_t
operator|)
name|dma_addr
argument_list|,
name|dst_addr
argument_list|,
operator|(
name|int
operator|)
name|len32
argument_list|)
expr_stmt|;
name|wb_comp
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|wb_comp
argument_list|)
expr_stmt|;
comment|/* Fall back to indirect access if DMAE is not ready. */
if|if
condition|(
operator|!
name|sc
operator|->
name|dmae_ready
condition|)
block|{
name|data
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|wb_data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): DMAE not ready, "
literal|"using indirect.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|bxe_init_ind_wr
argument_list|(
name|sc
argument_list|,
name|dst_addr
argument_list|,
name|data
argument_list|,
name|len32
argument_list|)
expr_stmt|;
goto|goto
name|bxe_write_dmae_exit
goto|;
block|}
name|memset
argument_list|(
operator|&
name|dmae
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dmae_command
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|.
name|opcode
operator|=
operator|(
name|DMAE_CMD_SRC_PCI
operator||
name|DMAE_CMD_DST_GRC
operator||
name|DMAE_CMD_C_DST_PCI
operator||
name|DMAE_CMD_C_ENABLE
operator||
name|DMAE_CMD_SRC_RESET
operator||
name|DMAE_CMD_DST_RESET
operator||
ifdef|#
directive|ifdef
name|__BIG_ENDIAN
name|DMAE_CMD_ENDIANITY_B_DW_SWAP
operator||
else|#
directive|else
name|DMAE_CMD_ENDIANITY_DW_SWAP
operator||
endif|#
directive|endif
operator|(
name|BP_PORT
argument_list|(
name|sc
argument_list|)
condition|?
name|DMAE_CMD_PORT_1
else|:
name|DMAE_CMD_PORT_0
operator|)
operator||
operator|(
name|BP_E1HVN
argument_list|(
name|sc
argument_list|)
operator|<<
name|DMAE_CMD_E1HVN_SHIFT
operator|)
operator|)
expr_stmt|;
name|dmae
operator|.
name|src_addr_lo
operator|=
name|U64_LO
argument_list|(
name|dma_addr
argument_list|)
expr_stmt|;
name|dmae
operator|.
name|src_addr_hi
operator|=
name|U64_HI
argument_list|(
name|dma_addr
argument_list|)
expr_stmt|;
name|dmae
operator|.
name|dst_addr_lo
operator|=
name|dst_addr
operator|>>
literal|2
expr_stmt|;
name|dmae
operator|.
name|dst_addr_hi
operator|=
literal|0
expr_stmt|;
name|dmae
operator|.
name|len
operator|=
name|len32
expr_stmt|;
name|dmae
operator|.
name|comp_addr_lo
operator|=
name|U64_LO
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|wb_comp
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|.
name|comp_addr_hi
operator|=
name|U64_HI
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|wb_comp
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|.
name|comp_val
operator|=
name|BXE_WB_COMP_VAL
expr_stmt|;
name|BXE_DMAE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
operator|*
name|wb_comp
operator|=
literal|0
expr_stmt|;
name|bxe_post_dmae
argument_list|(
name|sc
argument_list|,
operator|&
name|dmae
argument_list|,
name|INIT_DMAE_C
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|/* Wait up to 200ms. */
name|timeout
operator|=
literal|4000
expr_stmt|;
while|while
condition|(
operator|*
name|wb_comp
operator|!=
name|BXE_WB_COMP_VAL
condition|)
block|{
if|if
condition|(
operator|!
name|timeout
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): DMAE timeout (dst_addr = 0x%08X, len = %d)!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|dst_addr
argument_list|,
name|len32
argument_list|)
expr_stmt|;
break|break;
block|}
name|timeout
operator|--
expr_stmt|;
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
name|BXE_DMAE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_write_dmae_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_INSANE_REGS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Perform a DMAE read from to device memory.  *  * Some of the registers on the 577XX controller are 128bits wide.  It is  * required that when accessing those registers that they be read  * atomically and that no intervening bus acceses to the device occur.  * This could be handled by a lock held across all driver instances for  * the device or it can be handled by performing a DMA operation when  * reading from the device.  This code implements the latter.  *  * Returns:  *   None.  */
end_comment

begin_function
name|void
name|bxe_read_dmae
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|src_addr
parameter_list|,
name|uint32_t
name|len32
parameter_list|)
block|{
name|struct
name|dmae_command
name|dmae
decl_stmt|;
name|uint32_t
modifier|*
name|data
decl_stmt|,
modifier|*
name|wb_comp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|timeout
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_INSANE_REGS
argument_list|)
expr_stmt|;
name|wb_comp
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|wb_comp
argument_list|)
expr_stmt|;
comment|/* Fall back to indirect access if DMAE is not ready. */
if|if
condition|(
operator|!
name|sc
operator|->
name|dmae_ready
condition|)
block|{
name|data
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|wb_data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): DMAE not ready, "
literal|"using indirect.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len32
condition|;
name|i
operator|++
control|)
name|data
index|[
name|i
index|]
operator|=
name|bxe_reg_rd_ind
argument_list|(
name|sc
argument_list|,
name|src_addr
operator|+
name|i
operator|*
literal|4
argument_list|)
expr_stmt|;
goto|goto
name|bxe_read_dmae_exit
goto|;
block|}
name|memset
argument_list|(
operator|&
name|dmae
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dmae_command
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|.
name|opcode
operator|=
operator|(
name|DMAE_CMD_SRC_GRC
operator||
name|DMAE_CMD_DST_PCI
operator||
name|DMAE_CMD_C_DST_PCI
operator||
name|DMAE_CMD_C_ENABLE
operator||
name|DMAE_CMD_SRC_RESET
operator||
name|DMAE_CMD_DST_RESET
operator||
ifdef|#
directive|ifdef
name|__BIG_ENDIAN
name|DMAE_CMD_ENDIANITY_B_DW_SWAP
operator||
else|#
directive|else
name|DMAE_CMD_ENDIANITY_DW_SWAP
operator||
endif|#
directive|endif
operator|(
name|BP_PORT
argument_list|(
name|sc
argument_list|)
condition|?
name|DMAE_CMD_PORT_1
else|:
name|DMAE_CMD_PORT_0
operator|)
operator||
operator|(
name|BP_E1HVN
argument_list|(
name|sc
argument_list|)
operator|<<
name|DMAE_CMD_E1HVN_SHIFT
operator|)
operator|)
expr_stmt|;
name|dmae
operator|.
name|src_addr_lo
operator|=
name|src_addr
operator|>>
literal|2
expr_stmt|;
name|dmae
operator|.
name|src_addr_hi
operator|=
literal|0
expr_stmt|;
name|dmae
operator|.
name|dst_addr_lo
operator|=
name|U64_LO
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|wb_data
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|.
name|dst_addr_hi
operator|=
name|U64_HI
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|wb_data
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|.
name|len
operator|=
name|len32
expr_stmt|;
name|dmae
operator|.
name|comp_addr_lo
operator|=
name|U64_LO
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|wb_comp
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|.
name|comp_addr_hi
operator|=
name|U64_HI
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|wb_comp
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|.
name|comp_val
operator|=
name|BXE_WB_COMP_VAL
expr_stmt|;
name|BXE_DMAE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|wb_data
index|[
literal|0
index|]
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
literal|4
argument_list|)
expr_stmt|;
operator|*
name|wb_comp
operator|=
literal|0
expr_stmt|;
name|bxe_post_dmae
argument_list|(
name|sc
argument_list|,
operator|&
name|dmae
argument_list|,
name|INIT_DMAE_C
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|timeout
operator|=
literal|4000
expr_stmt|;
while|while
condition|(
operator|*
name|wb_comp
operator|!=
name|BXE_WB_COMP_VAL
condition|)
block|{
if|if
condition|(
operator|!
name|timeout
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): DMAE timeout (src_addr = 0x%08X, len = %d)!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|src_addr
argument_list|,
name|len32
argument_list|)
expr_stmt|;
break|break;
block|}
name|timeout
operator|--
expr_stmt|;
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
name|BXE_DMAE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_read_dmae_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_INSANE_REGS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * DMAE write wrapper.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_wb_wr
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|reg
parameter_list|,
name|uint32_t
name|val_hi
parameter_list|,
name|uint32_t
name|val_lo
parameter_list|)
block|{
name|uint32_t
name|wb_write
index|[
literal|2
index|]
decl_stmt|;
name|wb_write
index|[
literal|0
index|]
operator|=
name|val_hi
expr_stmt|;
name|wb_write
index|[
literal|1
index|]
operator|=
name|val_lo
expr_stmt|;
name|REG_WR_DMAE
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
name|wb_write
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Poll a register waiting for a value.  *  * Returns:  *   The last read register value.  */
end_comment

begin_function
specifier|static
name|__inline
name|uint32_t
name|bxe_reg_poll
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|reg
parameter_list|,
name|uint32_t
name|expected
parameter_list|,
name|int
name|ms
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
do|do
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|expected
condition|)
break|break;
name|ms
operator|-=
name|wait
expr_stmt|;
name|DELAY
argument_list|(
name|wait
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ms
operator|>
literal|0
condition|)
do|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Microcode assert display.  *  * This function walks through each STORM processor and prints out a  * listing of all asserts currently in effect.  Useful for post-mortem  * debugging.  *  * Returns:  *   The number of asserts detected.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_mc_assert
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|row0
decl_stmt|,
name|row1
decl_stmt|,
name|row2
decl_stmt|,
name|row3
decl_stmt|;
name|char
name|last_idx
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_INTR
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
comment|/* XSTORM */
name|last_idx
operator|=
name|REG_RD8
argument_list|(
name|sc
argument_list|,
name|BAR_XSTORM_INTMEM
operator|+
name|XSTORM_ASSERT_LIST_INDEX_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_idx
condition|)
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"DATA XSTORM_ASSERT_LIST_INDEX 0x%x\n"
argument_list|,
name|last_idx
argument_list|)
expr_stmt|;
comment|/* Print the asserts */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STORM_ASSERT_ARRAY_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|row0
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BAR_XSTORM_INTMEM
operator|+
name|XSTORM_ASSERT_LIST_OFFSET
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|row1
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BAR_XSTORM_INTMEM
operator|+
name|XSTORM_ASSERT_LIST_OFFSET
argument_list|(
name|i
argument_list|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|row2
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BAR_XSTORM_INTMEM
operator|+
name|XSTORM_ASSERT_LIST_OFFSET
argument_list|(
name|i
argument_list|)
operator|+
literal|8
argument_list|)
expr_stmt|;
name|row3
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BAR_XSTORM_INTMEM
operator|+
name|XSTORM_ASSERT_LIST_OFFSET
argument_list|(
name|i
argument_list|)
operator|+
literal|12
argument_list|)
expr_stmt|;
if|if
condition|(
name|row0
operator|!=
name|COMMON_ASM_INVALID_ASSERT_OPCODE
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"DATA XSTORM_ASSERT_INDEX %d = "
literal|"0x%08x 0x%08x 0x%08x 0x%08x\n"
argument_list|,
name|i
argument_list|,
name|row3
argument_list|,
name|row2
argument_list|,
name|row1
argument_list|,
name|row0
argument_list|)
expr_stmt|;
name|rc
operator|++
expr_stmt|;
block|}
else|else
break|break;
block|}
comment|/* TSTORM */
name|last_idx
operator|=
name|REG_RD8
argument_list|(
name|sc
argument_list|,
name|BAR_TSTORM_INTMEM
operator|+
name|TSTORM_ASSERT_LIST_INDEX_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_idx
condition|)
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"DATA TSTORM_ASSERT_LIST_INDEX 0x%x\n"
argument_list|,
name|last_idx
argument_list|)
expr_stmt|;
comment|/* Print the asserts */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STORM_ASSERT_ARRAY_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|row0
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BAR_TSTORM_INTMEM
operator|+
name|TSTORM_ASSERT_LIST_OFFSET
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|row1
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BAR_TSTORM_INTMEM
operator|+
name|TSTORM_ASSERT_LIST_OFFSET
argument_list|(
name|i
argument_list|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|row2
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BAR_TSTORM_INTMEM
operator|+
name|TSTORM_ASSERT_LIST_OFFSET
argument_list|(
name|i
argument_list|)
operator|+
literal|8
argument_list|)
expr_stmt|;
name|row3
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BAR_TSTORM_INTMEM
operator|+
name|TSTORM_ASSERT_LIST_OFFSET
argument_list|(
name|i
argument_list|)
operator|+
literal|12
argument_list|)
expr_stmt|;
if|if
condition|(
name|row0
operator|!=
name|COMMON_ASM_INVALID_ASSERT_OPCODE
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"DATA TSTORM_ASSERT_INDEX %d = "
literal|"0x%08x 0x%08x 0x%08x 0x%08x\n"
argument_list|,
name|i
argument_list|,
name|row3
argument_list|,
name|row2
argument_list|,
name|row1
argument_list|,
name|row0
argument_list|)
expr_stmt|;
name|rc
operator|++
expr_stmt|;
block|}
else|else
break|break;
block|}
comment|/* CSTORM */
name|last_idx
operator|=
name|REG_RD8
argument_list|(
name|sc
argument_list|,
name|BAR_CSTORM_INTMEM
operator|+
name|CSTORM_ASSERT_LIST_INDEX_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_idx
condition|)
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"DATA CSTORM_ASSERT_LIST_INDEX 0x%x\n"
argument_list|,
name|last_idx
argument_list|)
expr_stmt|;
comment|/* Print the asserts */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STORM_ASSERT_ARRAY_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|row0
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BAR_CSTORM_INTMEM
operator|+
name|CSTORM_ASSERT_LIST_OFFSET
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|row1
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BAR_CSTORM_INTMEM
operator|+
name|CSTORM_ASSERT_LIST_OFFSET
argument_list|(
name|i
argument_list|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|row2
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BAR_CSTORM_INTMEM
operator|+
name|CSTORM_ASSERT_LIST_OFFSET
argument_list|(
name|i
argument_list|)
operator|+
literal|8
argument_list|)
expr_stmt|;
name|row3
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BAR_CSTORM_INTMEM
operator|+
name|CSTORM_ASSERT_LIST_OFFSET
argument_list|(
name|i
argument_list|)
operator|+
literal|12
argument_list|)
expr_stmt|;
if|if
condition|(
name|row0
operator|!=
name|COMMON_ASM_INVALID_ASSERT_OPCODE
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"DATA CSTORM_ASSERT_INDEX %d = "
literal|"0x%08x 0x%08x 0x%08x 0x%08x\n"
argument_list|,
name|i
argument_list|,
name|row3
argument_list|,
name|row2
argument_list|,
name|row1
argument_list|,
name|row0
argument_list|)
expr_stmt|;
name|rc
operator|++
expr_stmt|;
block|}
else|else
break|break;
block|}
comment|/* USTORM */
name|last_idx
operator|=
name|REG_RD8
argument_list|(
name|sc
argument_list|,
name|BAR_USTORM_INTMEM
operator|+
name|USTORM_ASSERT_LIST_INDEX_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_idx
condition|)
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"DATA USTORM_ASSERT_LIST_INDEX 0x%x\n"
argument_list|,
name|last_idx
argument_list|)
expr_stmt|;
comment|/* Print the asserts */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STORM_ASSERT_ARRAY_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|row0
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BAR_USTORM_INTMEM
operator|+
name|USTORM_ASSERT_LIST_OFFSET
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|row1
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BAR_USTORM_INTMEM
operator|+
name|USTORM_ASSERT_LIST_OFFSET
argument_list|(
name|i
argument_list|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|row2
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BAR_USTORM_INTMEM
operator|+
name|USTORM_ASSERT_LIST_OFFSET
argument_list|(
name|i
argument_list|)
operator|+
literal|8
argument_list|)
expr_stmt|;
name|row3
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BAR_USTORM_INTMEM
operator|+
name|USTORM_ASSERT_LIST_OFFSET
argument_list|(
name|i
argument_list|)
operator|+
literal|12
argument_list|)
expr_stmt|;
if|if
condition|(
name|row0
operator|!=
name|COMMON_ASM_INVALID_ASSERT_OPCODE
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"DATA USTORM_ASSERT_INDEX %d = "
literal|"0x%08x 0x%08x 0x%08x 0x%08x\n"
argument_list|,
name|i
argument_list|,
name|row3
argument_list|,
name|row2
argument_list|,
name|row1
argument_list|,
name|row0
argument_list|)
expr_stmt|;
name|rc
operator|++
expr_stmt|;
block|}
else|else
break|break;
block|}
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_INTR
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Perform a panic dump.  *  * Returns:  *   None  */
end_comment

begin_function
specifier|static
name|void
name|bxe_panic_dump
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|DBENTER
argument_list|(
name|BXE_FATAL
argument_list|)
expr_stmt|;
name|sc
operator|->
name|stats_state
operator|=
name|STATS_STATE_DISABLED
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"---------- Begin crash dump ----------\n"
argument_list|)
expr_stmt|;
comment|/* Idle	check is run twice to verify the controller has	stopped. */
name|bxe_idle_chk
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_idle_chk
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_mc_assert
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BXE_DEBUG
name|bxe_breakpoint
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|BXE_PRINTF
argument_list|(
literal|"----------  End crash dump  ----------\n"
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_FATAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Enables interrupt generation.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_int_enable
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|hc_addr
decl_stmt|,
name|val
decl_stmt|;
name|int
name|port
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_INTR
argument_list|)
expr_stmt|;
name|port
operator|=
name|BP_PORT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hc_addr
operator|=
name|port
condition|?
name|HC_REG_CONFIG_1
else|:
name|HC_REG_CONFIG_0
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|hc_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msix_count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|msix_count
operator|==
literal|1
condition|)
block|{
comment|/* Single interrupt, multiple queues.*/
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_INTR
argument_list|,
literal|"%s(): Setting host coalescing registers for MSI-X (SIMQ).\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* Clear INTx. */
name|val
operator|&=
operator|~
name|HC_CONFIG_0_REG_INT_LINE_EN_0
expr_stmt|;
comment|/* Enable single ISR mode, MSI/MSI-X, and attention messages. */
name|val
operator||=
operator|(
name|HC_CONFIG_0_REG_SINGLE_ISR_EN_0
operator||
name|HC_CONFIG_0_REG_MSI_MSIX_INT_EN_0
operator||
name|HC_CONFIG_0_REG_ATTN_BIT_EN_0
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Multiple interrupts, multiple queues.*/
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_INTR
argument_list|,
literal|"%s(): Setting host coalescing registers for MSI-X (MIMQ).\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* Clear single ISR mode and INTx. */
name|val
operator|&=
operator|~
operator|(
name|HC_CONFIG_0_REG_SINGLE_ISR_EN_0
operator||
name|HC_CONFIG_0_REG_INT_LINE_EN_0
operator|)
expr_stmt|;
comment|/* Enable MSI/MSI-X and attention messages. */
name|val
operator||=
operator|(
name|HC_CONFIG_0_REG_MSI_MSIX_INT_EN_0
operator||
name|HC_CONFIG_0_REG_ATTN_BIT_EN_0
operator|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|msi_count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|msi_count
operator|==
literal|1
condition|)
block|{
comment|/* Single interrupt, multiple queues.*/
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_INTR
argument_list|,
literal|"%s(): Setting host coalescing registers for MSI (SIMQ).\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* Clear INTx. */
name|val
operator|&=
operator|~
name|HC_CONFIG_0_REG_INT_LINE_EN_0
expr_stmt|;
comment|/* Enable single ISR mode, MSI/MSI-X, and attention 			 * messages. 			 */
name|val
operator||=
operator|(
name|HC_CONFIG_0_REG_SINGLE_ISR_EN_0
operator||
name|HC_CONFIG_0_REG_MSI_MSIX_INT_EN_0
operator||
name|HC_CONFIG_0_REG_ATTN_BIT_EN_0
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Multiple interrupts, multiple queues.*/
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_INTR
argument_list|,
literal|"%s(): Setting host coalescing registers for"
literal|"MSI (MIMQ).\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* Clear single ISR mode and INTx. */
name|val
operator|&=
operator|~
operator|(
name|HC_CONFIG_0_REG_SINGLE_ISR_EN_0
operator||
name|HC_CONFIG_0_REG_INT_LINE_EN_0
operator|)
expr_stmt|;
comment|/* Enable MSI/MSI-X and attention messages. */
name|val
operator||=
operator|(
name|HC_CONFIG_0_REG_MSI_MSIX_INT_EN_0
operator||
name|HC_CONFIG_0_REG_ATTN_BIT_EN_0
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Single interrupt, single queue. */
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_INTR
argument_list|,
literal|"%s(): Setting host coalescing registers for INTA#.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|val
operator||=
operator|(
name|HC_CONFIG_0_REG_SINGLE_ISR_EN_0
operator||
name|HC_CONFIG_0_REG_MSI_MSIX_INT_EN_0
operator||
name|HC_CONFIG_0_REG_INT_LINE_EN_0
operator||
name|HC_CONFIG_0_REG_ATTN_BIT_EN_0
operator|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|hc_addr
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|HC_CONFIG_0_REG_MSI_MSIX_INT_EN_0
expr_stmt|;
block|}
comment|/* Write the interrupt mode to the host coalescing block. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|hc_addr
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* Init leading/trailing edge attention generation. */
if|if
condition|(
name|IS_E1HMF
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|val
operator|=
operator|(
literal|0xee0f
operator||
operator|(
literal|1
operator|<<
operator|(
name|BP_E1HVN
argument_list|(
name|sc
argument_list|)
operator|+
literal|4
operator|)
operator|)
operator|)
expr_stmt|;
comment|/* 			 * Check if this driver instance is the port 			 * master function. 			 */
if|if
condition|(
name|sc
operator|->
name|port
operator|.
name|pmf
condition|)
comment|/* Enable nig& GPIO3 attentions. */
name|val
operator||=
literal|0x1100
expr_stmt|;
block|}
else|else
name|val
operator|=
literal|0xffff
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|HC_REG_TRAILING_EDGE_0
operator|+
name|port
operator|*
literal|8
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|HC_REG_LEADING_EDGE_0
operator|+
name|port
operator|*
literal|8
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_INTR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Disables interrupt generation.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_int_disable
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|hc_addr
decl_stmt|,
name|val
decl_stmt|;
name|int
name|port
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_INTR
operator||
name|BXE_VERBOSE_RESET
operator||
name|BXE_VERBOSE_UNLOAD
argument_list|)
expr_stmt|;
name|port
operator|=
name|BP_PORT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hc_addr
operator|=
name|port
condition|?
name|HC_REG_CONFIG_1
else|:
name|HC_REG_CONFIG_0
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|hc_addr
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
name|HC_CONFIG_0_REG_MSI_MSIX_INT_EN_0
operator||
name|HC_CONFIG_0_REG_INT_LINE_EN_0
operator||
name|HC_CONFIG_0_REG_ATTN_BIT_EN_0
operator|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|hc_addr
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|hc_addr
argument_list|)
operator|!=
name|val
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): BUG! Returned value from IGU "
literal|"doesn't match value written (0x%08X).\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_INTR
operator||
name|BXE_VERBOSE_RESET
operator||
name|BXE_VERBOSE_UNLOAD
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|BXE_CRC32_RESIDUAL
value|0xdebb20e3
end_define

begin_comment
comment|/*  * Returns:  *   0 = Success, !0 = Failure.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_nvram_acquire_lock
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|int
name|i
decl_stmt|,
name|port
decl_stmt|,
name|rc
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_NVRAM
argument_list|)
expr_stmt|;
name|port
operator|=
name|BP_PORT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
comment|/* Acquire the NVRAM lock. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_NVM_SW_ARB
argument_list|,
operator|(
name|MCPR_NVM_SW_ARB_ARB_REQ_SET1
operator|<<
name|port
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NVRAM_TIMEOUT_COUNT
operator|*
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_NVM_SW_ARB
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
operator|(
name|MCPR_NVM_SW_ARB_ARB_ARB1
operator|<<
name|port
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|val
operator|&
operator|(
name|MCPR_NVM_SW_ARB_ARB_ARB1
operator|<<
name|port
operator|)
operator|)
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): Cannot acquire NVRAM lock!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EBUSY
expr_stmt|;
block|}
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_NVRAM
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns:  *   0 = Success, !0 = Failure.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_nvram_release_lock
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|int
name|i
decl_stmt|,
name|port
decl_stmt|,
name|rc
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_NVRAM
argument_list|)
expr_stmt|;
name|port
operator|=
name|BP_PORT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
comment|/* Release the NVRAM lock. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_NVM_SW_ARB
argument_list|,
operator|(
name|MCPR_NVM_SW_ARB_ARB_REQ_CLR1
operator|<<
name|port
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NVRAM_TIMEOUT_COUNT
operator|*
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_NVM_SW_ARB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|&
operator|(
name|MCPR_NVM_SW_ARB_ARB_ARB1
operator|<<
name|port
operator|)
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
operator|(
name|MCPR_NVM_SW_ARB_ARB_ARB1
operator|<<
name|port
operator|)
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): Cannot release NVRAM lock!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EBUSY
expr_stmt|;
block|}
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_NVRAM
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_nvram_enable_access
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_NVRAM
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_NVM_ACCESS_ENABLE
argument_list|)
expr_stmt|;
comment|/* Enable both bits, even on read */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_NVM_ACCESS_ENABLE
argument_list|,
operator|(
name|val
operator||
name|MCPR_NVM_ACCESS_ENABLE_EN
operator||
name|MCPR_NVM_ACCESS_ENABLE_WR_EN
operator|)
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_NVRAM
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_nvram_disable_access
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_NVRAM
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_NVM_ACCESS_ENABLE
argument_list|)
expr_stmt|;
comment|/* Disable both bits, even after read. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_NVM_ACCESS_ENABLE
argument_list|,
operator|(
name|val
operator|&
operator|~
operator|(
name|MCPR_NVM_ACCESS_ENABLE_EN
operator||
name|MCPR_NVM_ACCESS_ENABLE_WR_EN
operator|)
operator|)
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_NVRAM
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns:  *   0 = Success, !0 = Failure.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_nvram_read_dword
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint32_t
modifier|*
name|ret_val
parameter_list|,
name|uint32_t
name|cmd_flags
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_INSANE_NVRAM
argument_list|)
expr_stmt|;
comment|/* Build the command word. */
name|cmd_flags
operator||=
name|MCPR_NVM_COMMAND_DOIT
expr_stmt|;
comment|/* Need to clear DONE bit separately. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_NVM_COMMAND
argument_list|,
name|MCPR_NVM_COMMAND_DONE
argument_list|)
expr_stmt|;
comment|/* Address within the NVRAM to read. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_NVM_ADDR
argument_list|,
operator|(
name|offset
operator|&
name|MCPR_NVM_ADDR_NVM_ADDR_VALUE
operator|)
argument_list|)
expr_stmt|;
comment|/* Issue a read command. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_NVM_COMMAND
argument_list|,
name|cmd_flags
argument_list|)
expr_stmt|;
comment|/* Wait for completion. */
operator|*
name|ret_val
operator|=
literal|0
expr_stmt|;
name|rc
operator|=
name|EBUSY
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NVRAM_TIMEOUT_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_NVM_COMMAND
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|MCPR_NVM_COMMAND_DONE
condition|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_NVM_READ
argument_list|)
expr_stmt|;
name|val
operator|=
name|htobe32
argument_list|(
name|val
argument_list|)
expr_stmt|;
operator|*
name|ret_val
operator|=
name|val
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_INSANE_NVRAM
argument_list|,
literal|"%s(): Read 0x%08X from offset 0x%08X.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
operator|*
name|ret_val
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_INSANE_NVRAM
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns:  *   0 = Success, !0 = Failure.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_nvram_read
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint8_t
modifier|*
name|ret_buf
parameter_list|,
name|int
name|buf_size
parameter_list|)
block|{
name|uint32_t
name|cmd_flags
decl_stmt|,
name|val
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_EXTREME_NVRAM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|&
literal|0x03
operator|)
operator|||
operator|(
name|buf_size
operator|&
literal|0x03
operator|)
operator|||
operator|(
name|buf_size
operator|==
literal|0
operator|)
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): Unaligned address or invalid "
literal|"buffer for NVRAM read (offset = 0x%08X, buf_size = %d)!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|offset
argument_list|,
name|buf_size
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bxe_nvram_read_exit
goto|;
block|}
if|if
condition|(
name|offset
operator|+
name|buf_size
operator|>
name|sc
operator|->
name|common
operator|.
name|flash_size
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): Read extends beyond the end of "
literal|"the NVRAM (offset (0x%08X) + buf_size (%d)> flash_size "
literal|"(0x%08X))!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|offset
argument_list|,
name|buf_size
argument_list|,
name|sc
operator|->
name|common
operator|.
name|flash_size
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bxe_nvram_read_exit
goto|;
block|}
name|rc
operator|=
name|bxe_nvram_acquire_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|bxe_nvram_read_exit
goto|;
name|bxe_nvram_enable_access
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Read the first word(s). */
name|cmd_flags
operator|=
name|MCPR_NVM_COMMAND_FIRST
expr_stmt|;
while|while
condition|(
operator|(
name|buf_size
operator|>
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
operator|&&
operator|(
name|rc
operator|==
literal|0
operator|)
condition|)
block|{
name|rc
operator|=
name|bxe_nvram_read_dword
argument_list|(
name|sc
argument_list|,
name|offset
argument_list|,
operator|&
name|val
argument_list|,
name|cmd_flags
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ret_buf
argument_list|,
operator|&
name|val
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Advance to the next DWORD. */
name|offset
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|ret_buf
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|buf_size
operator|-=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|cmd_flags
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Read the final word. */
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
name|cmd_flags
operator||=
name|MCPR_NVM_COMMAND_LAST
expr_stmt|;
name|rc
operator|=
name|bxe_nvram_read_dword
argument_list|(
name|sc
argument_list|,
name|offset
argument_list|,
operator|&
name|val
argument_list|,
name|cmd_flags
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ret_buf
argument_list|,
operator|&
name|val
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* Disable access to NVRAM interface. */
name|bxe_nvram_disable_access
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_nvram_release_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_nvram_read_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_EXTREME_NVRAM
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BXE_NVRAM_WRITE_SUPPORT
end_ifdef

begin_comment
comment|/*  * Returns:  *   0 = Success, !0 = Failure.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_nvram_write_dword
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint32_t
name|val
parameter_list|,
name|uint32_t
name|cmd_flags
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_NVRAM
argument_list|)
expr_stmt|;
comment|/* Build the command word. */
name|cmd_flags
operator||=
name|MCPR_NVM_COMMAND_DOIT
operator||
name|MCPR_NVM_COMMAND_WR
expr_stmt|;
comment|/* Need to clear DONE bit separately. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_NVM_COMMAND
argument_list|,
name|MCPR_NVM_COMMAND_DONE
argument_list|)
expr_stmt|;
comment|/* Write the data. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_NVM_WRITE
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Address to write within the NVRAM. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_NVM_ADDR
argument_list|,
operator|(
name|offset
operator|&
name|MCPR_NVM_ADDR_NVM_ADDR_VALUE
operator|)
argument_list|)
expr_stmt|;
comment|/* Issue the write command. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_NVM_COMMAND
argument_list|,
name|cmd_flags
argument_list|)
expr_stmt|;
comment|/* Wait for completion. */
name|rc
operator|=
name|EBUSY
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NVRAM_TIMEOUT_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_NVM_COMMAND
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|MCPR_NVM_COMMAND_DONE
condition|)
block|{
name|rc
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_NVRAM
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|BYTE_OFFSET
parameter_list|(
name|offset
parameter_list|)
value|(8 * (offset& 0x03))
end_define

begin_comment
comment|/*  * Returns:  *  */
end_comment

begin_function
specifier|static
name|int
name|bxe_nvram_write1
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint8_t
modifier|*
name|data_buf
parameter_list|,
name|int
name|buf_size
parameter_list|)
block|{
name|uint32_t
name|align_offset
decl_stmt|,
name|cmd_flags
decl_stmt|,
name|val
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_NVRAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|+
name|buf_size
operator|>
name|sc
operator|->
name|common
operator|.
name|flash_size
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): Write extends beyond the end of "
literal|"the NVRAM (offset (0x%08X) + buf_size (%d)> flash_size "
literal|"(0x%08X))!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|offset
argument_list|,
name|buf_size
argument_list|,
name|sc
operator|->
name|common
operator|.
name|flash_size
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bxe_nvram_write1_exit
goto|;
block|}
comment|/* request access to nvram interface */
name|rc
operator|=
name|bxe_nvram_acquire_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|bxe_nvram_write1_exit
goto|;
comment|/* Enable access to the NVRAM interface. */
name|bxe_nvram_enable_access
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cmd_flags
operator|=
operator|(
name|MCPR_NVM_COMMAND_FIRST
operator||
name|MCPR_NVM_COMMAND_LAST
operator|)
expr_stmt|;
name|align_offset
operator|=
operator|(
name|offset
operator|&
operator|~
literal|0x03
operator|)
expr_stmt|;
name|rc
operator|=
name|bxe_nvram_read_dword
argument_list|(
name|sc
argument_list|,
name|align_offset
argument_list|,
operator|&
name|val
argument_list|,
name|cmd_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
name|val
operator|&=
operator|~
operator|(
literal|0xff
operator|<<
name|BYTE_OFFSET
argument_list|(
name|offset
argument_list|)
operator|)
expr_stmt|;
name|val
operator||=
operator|(
operator|*
name|data_buf
operator|<<
name|BYTE_OFFSET
argument_list|(
name|offset
argument_list|)
operator|)
expr_stmt|;
name|val
operator|=
name|be32toh
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|rc
operator|=
name|bxe_nvram_write_dword
argument_list|(
name|sc
argument_list|,
name|align_offset
argument_list|,
name|val
argument_list|,
name|cmd_flags
argument_list|)
expr_stmt|;
block|}
comment|/* Disable access to the NVRAM interface. */
name|bxe_nvram_disable_access
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_nvram_release_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_nvram_write1_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_NVRAM
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns:  *   0 = Success, !0 = Failure.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_nvram_write
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint8_t
modifier|*
name|data_buf
parameter_list|,
name|int
name|buf_size
parameter_list|)
block|{
name|uint32_t
name|cmd_flags
decl_stmt|,
name|val
decl_stmt|,
name|written_so_far
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|buf_size
operator|==
literal|1
condition|)
return|return
operator|(
name|bxe_nvram_write1
argument_list|(
name|sc
argument_list|,
name|offset
argument_list|,
name|data_buf
argument_list|,
name|buf_size
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|offset
operator|&
literal|0x03
operator|)
operator|||
operator|(
name|buf_size
operator|&
literal|0x03
operator|)
operator|||
operator|(
name|buf_size
operator|==
literal|0
operator|)
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): Unaligned address or invalid "
literal|"buffer for NVRAM write "
literal|"(offset = 0x%08X, buf_size = %d)!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|offset
argument_list|,
name|buf_size
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bxe_nvram_write_exit
goto|;
block|}
if|if
condition|(
name|offset
operator|+
name|buf_size
operator|>
name|sc
operator|->
name|common
operator|.
name|flash_size
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): Write extends beyond the end of "
literal|"the NVRAM (offset (0x%08X) + buf_size (%d)> flash_size "
literal|"(0x%08X))!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|offset
argument_list|,
name|buf_size
argument_list|,
name|sc
operator|->
name|common
operator|.
name|flash_size
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bxe_nvram_write_exit
goto|;
block|}
comment|/* Request access to NVRAM interface. */
name|rc
operator|=
name|bxe_nvram_acquire_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|bxe_nvram_write_exit
goto|;
comment|/* Enable access to the NVRAM interface. */
name|bxe_nvram_enable_access
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|written_so_far
operator|=
literal|0
expr_stmt|;
name|cmd_flags
operator|=
name|MCPR_NVM_COMMAND_FIRST
expr_stmt|;
while|while
condition|(
operator|(
name|written_so_far
operator|<
name|buf_size
operator|)
operator|&&
operator|(
name|rc
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|written_so_far
operator|==
operator|(
name|buf_size
operator|-
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
condition|)
name|cmd_flags
operator||=
name|MCPR_NVM_COMMAND_LAST
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|offset
operator|+
literal|4
operator|)
operator|%
name|NVRAM_PAGE_SIZE
operator|)
operator|==
literal|0
condition|)
name|cmd_flags
operator||=
name|MCPR_NVM_COMMAND_LAST
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|offset
operator|%
name|NVRAM_PAGE_SIZE
operator|)
operator|==
literal|0
condition|)
name|cmd_flags
operator||=
name|MCPR_NVM_COMMAND_FIRST
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|val
argument_list|,
name|data_buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|rc
operator|=
name|bxe_nvram_write_dword
argument_list|(
name|sc
argument_list|,
name|offset
argument_list|,
name|val
argument_list|,
name|cmd_flags
argument_list|)
expr_stmt|;
comment|/* Advance to the next DWORD. */
name|offset
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|data_buf
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|written_so_far
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|cmd_flags
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Disable access to the NVRAM interface. */
name|bxe_nvram_disable_access
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_nvram_release_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_nvram_write_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_NVRAM
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This function validates NVRAM content by reading spcific  * regions and validating that the NVRAM checksum matches the  * actual content.  *  * Returns:  *   0 = Success, !0 = Failure.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_nvram_test
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|static
specifier|const
struct|struct
block|{
name|int
name|offset
decl_stmt|;
name|int
name|size
decl_stmt|;
block|}
name|nvram_tbl
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|0x14
block|}
block|,
comment|/* bootstrap area*/
block|{
literal|0x14
block|,
literal|0xec
block|}
block|,
comment|/* directory area */
block|{
literal|0x100
block|,
literal|0x350
block|}
block|,
comment|/* manuf_info */
block|{
literal|0x450
block|,
literal|0xf0
block|}
block|,
comment|/* feature_info */
block|{
literal|0x640
block|,
literal|0x64
block|}
block|,
comment|/* upgrade_key_info */
block|{
literal|0x708
block|,
literal|0x70
block|}
block|,
comment|/* manuf_key_info */
block|{
literal|0
block|,
literal|0
block|}
block|}
struct|;
name|uint32_t
name|magic
decl_stmt|,
name|csum
decl_stmt|,
name|buf
index|[
literal|0x350
operator|/
literal|4
index|]
decl_stmt|;
name|uint8_t
modifier|*
name|data
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_NVRAM
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|buf
expr_stmt|;
comment|/* Read the DWORD at offset 0 in NVRAM. */
name|rc
operator|=
name|bxe_nvram_read
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Error (%d) returned reading NVRAM!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|bxe_nvram_test_exit
goto|;
block|}
comment|/* Make sure we found our magic value. */
name|magic
operator|=
name|be32toh
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|magic
operator|!=
literal|0x669955aa
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Invalid magic value (0x%08x) found!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|magic
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|bxe_nvram_test_exit
goto|;
block|}
comment|/* Read through each region in NVRAM and validate the checksum. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|nvram_tbl
index|[
name|i
index|]
operator|.
name|size
condition|;
name|i
operator|++
control|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_NVRAM
argument_list|,
literal|"%s(): Testing NVRAM region %d, "
literal|"starting offset = %d, length = %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|i
argument_list|,
name|nvram_tbl
index|[
name|i
index|]
operator|.
name|offset
argument_list|,
name|nvram_tbl
index|[
name|i
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
name|rc
operator|=
name|bxe_nvram_read
argument_list|(
name|sc
argument_list|,
name|nvram_tbl
index|[
name|i
index|]
operator|.
name|offset
argument_list|,
name|data
argument_list|,
name|nvram_tbl
index|[
name|i
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Error (%d) returned reading NVRAM "
literal|"region %d!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|rc
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|bxe_nvram_test_exit
goto|;
block|}
name|csum
operator|=
name|ether_crc32_le
argument_list|(
name|data
argument_list|,
name|nvram_tbl
index|[
name|i
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|csum
operator|!=
name|BXE_CRC32_RESIDUAL
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Checksum error (0x%08X) for NVRAM "
literal|"region %d!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|csum
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|bxe_nvram_test_exit
goto|;
block|}
block|}
name|bxe_nvram_test_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_NVRAM
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Acknowledge status block and modify interrupt mode.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|bxe_ack_sb
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|sb_id
parameter_list|,
name|uint8_t
name|storm
parameter_list|,
name|uint16_t
name|index
parameter_list|,
name|uint8_t
name|int_mode
parameter_list|,
name|uint8_t
name|update
parameter_list|)
block|{
name|struct
name|igu_ack_register
name|igu_ack
decl_stmt|;
name|uint32_t
name|hc_addr
decl_stmt|;
name|hc_addr
operator|=
operator|(
name|HC_REG_COMMAND_REG
operator|+
name|BP_PORT
argument_list|(
name|sc
argument_list|)
operator|*
literal|32
operator|+
name|COMMAND_REG_INT_ACK
operator|)
expr_stmt|;
name|igu_ack
operator|.
name|status_block_index
operator|=
name|index
expr_stmt|;
name|igu_ack
operator|.
name|sb_id_and_flags
operator|=
operator|(
operator|(
name|sb_id
operator|<<
name|IGU_ACK_REGISTER_STATUS_BLOCK_ID_SHIFT
operator|)
operator||
operator|(
name|storm
operator|<<
name|IGU_ACK_REGISTER_STORM_ID_SHIFT
operator|)
operator||
operator|(
name|update
operator|<<
name|IGU_ACK_REGISTER_UPDATE_INDEX_SHIFT
operator|)
operator||
operator|(
name|int_mode
operator|<<
name|IGU_ACK_REGISTER_INTERRUPT_MODE_SHIFT
operator|)
operator|)
expr_stmt|;
name|rmb
argument_list|()
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|hc_addr
argument_list|,
operator|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|igu_ack
operator|)
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update fastpath status block index.  *  * Returns:  *   0 = Nu completes, 1 = TX completes, 2 = RX completes,  *   3 = RX& TX completes  */
end_comment

begin_function
specifier|static
name|__inline
name|uint16_t
name|bxe_update_fpsb_idx
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|host_status_block
modifier|*
name|fpsb
decl_stmt|;
name|uint16_t
name|rc
decl_stmt|;
name|fpsb
operator|=
name|fp
operator|->
name|status_block
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
name|rmb
argument_list|()
expr_stmt|;
comment|/* Check for any CSTORM transmit completions. */
if|if
condition|(
name|fp
operator|->
name|fp_c_idx
operator|!=
name|le16toh
argument_list|(
name|fpsb
operator|->
name|c_status_block
operator|.
name|status_block_index
argument_list|)
condition|)
block|{
name|fp
operator|->
name|fp_c_idx
operator|=
name|le16toh
argument_list|(
name|fpsb
operator|->
name|c_status_block
operator|.
name|status_block_index
argument_list|)
expr_stmt|;
name|rc
operator||=
literal|0x1
expr_stmt|;
block|}
comment|/* Check for any USTORM receive completions. */
if|if
condition|(
name|fp
operator|->
name|fp_u_idx
operator|!=
name|le16toh
argument_list|(
name|fpsb
operator|->
name|u_status_block
operator|.
name|status_block_index
argument_list|)
condition|)
block|{
name|fp
operator|->
name|fp_u_idx
operator|=
name|le16toh
argument_list|(
name|fpsb
operator|->
name|u_status_block
operator|.
name|status_block_index
argument_list|)
expr_stmt|;
name|rc
operator||=
literal|0x2
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Acknowledge interrupt.  *  * Returns:  *   Interrupt value read from IGU.  */
end_comment

begin_function
specifier|static
name|uint16_t
name|bxe_ack_int
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|hc_addr
decl_stmt|,
name|result
decl_stmt|;
name|hc_addr
operator|=
name|HC_REG_COMMAND_REG
operator|+
name|BP_PORT
argument_list|(
name|sc
argument_list|)
operator|*
literal|32
operator|+
name|COMMAND_REG_SIMD_MASK
expr_stmt|;
name|result
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|hc_addr
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_INSANE_INTR
argument_list|,
literal|"%s(): Read 0x%08X from HC addr 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|result
argument_list|,
name|hc_addr
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Slowpath event handler.  *  * Checks that a ramrod completion occurs while	the  * controller is in the proper state.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_sp_event
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|union
name|eth_rx_cqe
modifier|*
name|rr_cqe
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|cid
decl_stmt|,
name|command
decl_stmt|;
name|sc
operator|=
name|fp
operator|->
name|sc
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_RAMROD
argument_list|)
expr_stmt|;
name|cid
operator|=
name|SW_CID
argument_list|(
name|rr_cqe
operator|->
name|ramrod_cqe
operator|.
name|conn_and_cmd_data
argument_list|)
expr_stmt|;
name|command
operator|=
name|CQE_CMD
argument_list|(
name|rr_cqe
operator|->
name|ramrod_cqe
operator|.
name|conn_and_cmd_data
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_RAMROD
argument_list|,
literal|"%s(): CID = %d, ramrod command = %d, "
literal|"device state = 0x%08X, fp[%02d].state = 0x%08X, type = %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|cid
argument_list|,
name|command
argument_list|,
name|sc
operator|->
name|state
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|fp
operator|->
name|state
argument_list|,
name|rr_cqe
operator|->
name|ramrod_cqe
operator|.
name|ramrod_type
argument_list|)
expr_stmt|;
comment|/* Free up an entry on the slowpath queue. */
name|sc
operator|->
name|spq_left
operator|++
expr_stmt|;
comment|/* Handle ramrod commands that completed on a client connection. */
if|if
condition|(
name|fp
operator|->
name|index
condition|)
block|{
comment|/* Check for a completion for the current state. */
switch|switch
condition|(
name|command
operator||
name|fp
operator|->
name|state
condition|)
block|{
case|case
operator|(
name|RAMROD_CMD_ID_ETH_CLIENT_SETUP
operator||
name|BXE_FP_STATE_OPENING
operator|)
case|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_RAMROD
argument_list|,
literal|"%s(): Completed fp[%02d] CLIENT_SETUP Ramrod.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|cid
argument_list|)
expr_stmt|;
name|fp
operator|->
name|state
operator|=
name|BXE_FP_STATE_OPEN
expr_stmt|;
break|break;
case|case
operator|(
name|RAMROD_CMD_ID_ETH_HALT
operator||
name|BXE_FP_STATE_HALTING
operator|)
case|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_RAMROD
argument_list|,
literal|"%s(): Completed fp[%02d] ETH_HALT ramrod\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|cid
argument_list|)
expr_stmt|;
name|fp
operator|->
name|state
operator|=
name|BXE_FP_STATE_HALTED
expr_stmt|;
break|break;
default|default:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_RAMROD
argument_list|,
literal|"%s(): Unexpected microcode reply (%d) while "
literal|"in state 0x%04X!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|command
argument_list|,
name|fp
operator|->
name|state
argument_list|)
expr_stmt|;
block|}
goto|goto
name|bxe_sp_event_exit
goto|;
block|}
comment|/* Handle ramrod commands that completed on the leading connection. */
switch|switch
condition|(
name|command
operator||
name|sc
operator|->
name|state
condition|)
block|{
case|case
operator|(
name|RAMROD_CMD_ID_ETH_PORT_SETUP
operator||
name|BXE_STATE_OPENING_WAIT4_PORT
operator|)
case|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_RAMROD
argument_list|,
literal|"%s(): Completed PORT_SETUP ramrod.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|state
operator|=
name|BXE_STATE_OPEN
expr_stmt|;
break|break;
case|case
operator|(
name|RAMROD_CMD_ID_ETH_HALT
operator||
name|BXE_STATE_CLOSING_WAIT4_HALT
operator|)
case|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_RAMROD
argument_list|,
literal|"%s(): Completed ETH_HALT ramrod.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|state
operator|=
name|BXE_STATE_CLOSING_WAIT4_DELETE
expr_stmt|;
name|fp
operator|->
name|state
operator|=
name|BXE_FP_STATE_HALTED
expr_stmt|;
break|break;
case|case
operator|(
name|RAMROD_CMD_ID_ETH_CFC_DEL
operator||
name|BXE_STATE_CLOSING_WAIT4_HALT
operator|)
case|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_RAMROD
argument_list|,
literal|"%s(): Completed fp[%02d] ETH_CFC_DEL ramrod.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|cid
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fp
index|[
name|cid
index|]
operator|.
name|state
operator|=
name|BXE_FP_STATE_CLOSED
expr_stmt|;
break|break;
case|case
operator|(
name|RAMROD_CMD_ID_ETH_SET_MAC
operator||
name|BXE_STATE_OPEN
operator|)
case|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_RAMROD
argument_list|,
literal|"%s(): Completed ETH_SET_MAC ramrod in STATE_OPEN state.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|RAMROD_CMD_ID_ETH_SET_MAC
operator||
name|BXE_STATE_CLOSING_WAIT4_HALT
operator|)
case|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_RAMROD
argument_list|,
literal|"%s(): Completed ETH_SET_MAC ramrod in "
literal|"CLOSING_WAIT4_HALT state.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): Unexpected microcode reply (%d)! "
literal|"State is 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|command
argument_list|,
name|sc
operator|->
name|state
argument_list|)
expr_stmt|;
block|}
name|bxe_sp_event_exit
label|:
comment|/* Force bxe_wait_ramrod() to see the change. */
name|mb
argument_list|()
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_RAMROD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Lock access to a hardware resource using controller arbitration  * register.  *  * Returns:  *   0 = Success, !0 = Failure.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_acquire_hw_lock
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|resource
parameter_list|)
block|{
name|uint32_t
name|hw_lock_control_reg
decl_stmt|,
name|lock_status
decl_stmt|,
name|resource_bit
decl_stmt|;
name|uint8_t
name|func
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|rc
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_MISC
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_MISC
argument_list|,
literal|"%s(): Locking resource 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|resource
argument_list|)
expr_stmt|;
name|func
operator|=
name|BP_FUNC
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|resource_bit
operator|=
literal|1
operator|<<
name|resource
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
name|hw_lock_control_reg
operator|=
operator|(
operator|(
name|func
operator|<=
literal|5
operator|)
condition|?
operator|(
name|MISC_REG_DRIVER_CONTROL_1
operator|+
name|func
operator|*
literal|8
operator|)
else|:
operator|(
name|MISC_REG_DRIVER_CONTROL_7
operator|+
operator|(
name|func
operator|-
literal|6
operator|)
operator|*
literal|8
operator|)
operator|)
expr_stmt|;
comment|/* Validating that the resource is within range. */
if|if
condition|(
name|resource
operator|>
name|HW_LOCK_MAX_RESOURCE_VALUE
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): Resource is out of range! "
literal|"resource(0x%08X)> HW_LOCK_MAX_RESOURCE_VALUE(0x%08X)\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|resource
argument_list|,
name|HW_LOCK_MAX_RESOURCE_VALUE
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bxe_acquire_hw_lock_exit
goto|;
block|}
comment|/* Validating that the resource is not already taken. */
name|lock_status
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|hw_lock_control_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock_status
operator|&
name|resource_bit
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): Failed to acquire lock! "
literal|"lock_status = 0x%08X, resource_bit = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|lock_status
argument_list|,
name|resource_bit
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EEXIST
expr_stmt|;
goto|goto
name|bxe_acquire_hw_lock_exit
goto|;
block|}
comment|/* Try for 5 seconds every 5ms. */
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
literal|1000
condition|;
name|cnt
operator|++
control|)
block|{
comment|/* Try to acquire the lock. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|hw_lock_control_reg
operator|+
literal|4
argument_list|,
name|resource_bit
argument_list|)
expr_stmt|;
name|lock_status
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|hw_lock_control_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock_status
operator|&
name|resource_bit
condition|)
goto|goto
name|bxe_acquire_hw_lock_exit
goto|;
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
block|}
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): Timeout!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EAGAIN
expr_stmt|;
name|bxe_acquire_hw_lock_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_MISC
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unlock access to a hardware resource using controller arbitration  * register.  *  * Returns:  *   0 = Success, !0 = Failure.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_release_hw_lock
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|resource
parameter_list|)
block|{
name|uint32_t
name|hw_lock_control_reg
decl_stmt|,
name|lock_status
decl_stmt|,
name|resource_bit
decl_stmt|;
name|uint8_t
name|func
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_MISC
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_MISC
argument_list|,
literal|"%s(): Unlocking resource 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|resource
argument_list|)
expr_stmt|;
name|resource_bit
operator|=
literal|1
operator|<<
name|resource
expr_stmt|;
name|func
operator|=
name|BP_FUNC
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
comment|/* Validating that the resource is within range */
if|if
condition|(
name|resource
operator|>
name|HW_LOCK_MAX_RESOURCE_VALUE
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): Resource is out of range! "
literal|"resource(0x%08X)> HW_LOCK_MAX_RESOURCE_VALUE(0x%08X)\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|resource
argument_list|,
name|HW_LOCK_MAX_RESOURCE_VALUE
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bxe_release_hw_lock_exit
goto|;
block|}
comment|/* Find the register for the resource lock. */
name|hw_lock_control_reg
operator|=
operator|(
operator|(
name|func
operator|<=
literal|5
operator|)
condition|?
operator|(
name|MISC_REG_DRIVER_CONTROL_1
operator|+
name|func
operator|*
literal|8
operator|)
else|:
operator|(
name|MISC_REG_DRIVER_CONTROL_7
operator|+
operator|(
name|func
operator|-
literal|6
operator|)
operator|*
literal|8
operator|)
operator|)
expr_stmt|;
comment|/* Validating that the resource is currently taken */
name|lock_status
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|hw_lock_control_reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|lock_status
operator|&
name|resource_bit
operator|)
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): The resource is not currently "
literal|"locked! lock_status = 0x%08X, resource_bit = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|lock_status
argument_list|,
name|resource_bit
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|bxe_release_hw_lock_exit
goto|;
block|}
comment|/* Free the hardware lock. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|hw_lock_control_reg
argument_list|,
name|resource_bit
argument_list|)
expr_stmt|;
name|bxe_release_hw_lock_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_MISC
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bxe_get_gpio
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|gpio_num
parameter_list|,
name|uint8_t
name|port
parameter_list|)
block|{
name|uint32_t
name|gpio_mask
decl_stmt|,
name|gpio_reg
decl_stmt|;
name|int
name|gpio_port
decl_stmt|,
name|gpio_shift
decl_stmt|,
name|value
decl_stmt|;
comment|/* The GPIO should be swapped if swap register is set and active */
name|gpio_port
operator|=
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_PORT_SWAP
argument_list|)
operator|&&
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_STRAP_OVERRIDE
argument_list|)
operator|)
operator|^
name|port
expr_stmt|;
name|gpio_shift
operator|=
name|gpio_num
operator|+
operator|(
name|gpio_port
condition|?
name|MISC_REGISTERS_GPIO_PORT_SHIFT
else|:
literal|0
operator|)
expr_stmt|;
name|gpio_mask
operator|=
literal|1
operator|<<
name|gpio_shift
expr_stmt|;
if|if
condition|(
name|gpio_num
operator|>
name|MISC_REGISTERS_GPIO_3
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): Invalid GPIO %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|gpio_num
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|EINVAL
operator|)
return|;
block|}
comment|/* read GPIO value */
name|gpio_reg
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_GPIO
argument_list|)
expr_stmt|;
comment|/* get the requested pin value */
if|if
condition|(
operator|(
name|gpio_reg
operator|&
name|gpio_mask
operator|)
operator|==
name|gpio_mask
condition|)
name|value
operator|=
literal|1
expr_stmt|;
else|else
name|value
operator|=
literal|0
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_PHY
argument_list|,
literal|"pin %d  value 0x%x\n"
argument_list|,
name|gpio_num
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Sets the state of a General Purpose I/O (GPIO).  *  * Returns:  *   None.  */
end_comment

begin_function
name|int
name|bxe_set_gpio
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|gpio_num
parameter_list|,
name|uint32_t
name|mode
parameter_list|,
name|uint8_t
name|port
parameter_list|)
block|{
name|uint32_t
name|gpio_reg
decl_stmt|,
name|gpio_mask
decl_stmt|;
name|int
name|gpio_port
decl_stmt|,
name|gpio_shift
decl_stmt|,
name|rc
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_MISC
argument_list|)
expr_stmt|;
comment|/* The GPIO should be swapped if swap register is set and active. */
name|gpio_port
operator|=
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_PORT_SWAP
argument_list|)
operator|&&
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_STRAP_OVERRIDE
argument_list|)
operator|)
operator|^
name|port
expr_stmt|;
name|gpio_shift
operator|=
name|gpio_num
operator|+
operator|(
name|gpio_port
condition|?
name|MISC_REGISTERS_GPIO_PORT_SHIFT
else|:
literal|0
operator|)
expr_stmt|;
name|gpio_mask
operator|=
operator|(
literal|1
operator|<<
name|gpio_shift
operator|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gpio_num
operator|>
name|MISC_REGISTERS_GPIO_3
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): Invalid GPIO (%d)!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|gpio_num
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bxe_set_gpio_exit
goto|;
block|}
comment|/* Make sure no one else is trying to use the GPIO. */
name|rc
operator|=
name|bxe_acquire_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_GPIO
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): Can't acquire GPIO lock!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
goto|goto
name|bxe_set_gpio_exit
goto|;
block|}
comment|/* Read GPIO and mask all but the float bits. */
name|gpio_reg
operator|=
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_GPIO
argument_list|)
operator|&
name|MISC_REGISTERS_GPIO_FLOAT
operator|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|MISC_REGISTERS_GPIO_OUTPUT_LOW
case|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE
argument_list|,
literal|"%s(): Set GPIO %d (shift %d) -> "
literal|"output low\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|gpio_num
argument_list|,
name|gpio_shift
argument_list|)
expr_stmt|;
name|gpio_reg
operator|&=
operator|~
operator|(
name|gpio_mask
operator|<<
name|MISC_REGISTERS_GPIO_FLOAT_POS
operator|)
expr_stmt|;
name|gpio_reg
operator||=
operator|(
name|gpio_mask
operator|<<
name|MISC_REGISTERS_GPIO_CLR_POS
operator|)
expr_stmt|;
break|break;
case|case
name|MISC_REGISTERS_GPIO_OUTPUT_HIGH
case|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE
argument_list|,
literal|"%s(): Set GPIO %d (shift %d) -> "
literal|"output high\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|gpio_num
argument_list|,
name|gpio_shift
argument_list|)
expr_stmt|;
name|gpio_reg
operator|&=
operator|~
operator|(
name|gpio_mask
operator|<<
name|MISC_REGISTERS_GPIO_FLOAT_POS
operator|)
expr_stmt|;
name|gpio_reg
operator||=
operator|(
name|gpio_mask
operator|<<
name|MISC_REGISTERS_GPIO_SET_POS
operator|)
expr_stmt|;
break|break;
case|case
name|MISC_REGISTERS_GPIO_INPUT_HI_Z
case|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE
argument_list|,
literal|"%s(): Set GPIO %d (shift %d) -> "
literal|"input\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|gpio_num
argument_list|,
name|gpio_shift
argument_list|)
expr_stmt|;
name|gpio_reg
operator||=
operator|(
name|gpio_mask
operator|<<
name|MISC_REGISTERS_GPIO_FLOAT_POS
operator|)
expr_stmt|;
break|break;
default|default:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): Unknown GPIO mode (0x%08X)!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|mode
argument_list|)
expr_stmt|;
break|break;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_GPIO
argument_list|,
name|gpio_reg
argument_list|)
expr_stmt|;
name|rc
operator|=
name|bxe_release_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_GPIO
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): Can't release GPIO lock!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
name|bxe_set_gpio_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_MISC
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bxe_set_gpio_int
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|gpio_num
parameter_list|,
name|uint32_t
name|mode
parameter_list|,
name|uint8_t
name|port
parameter_list|)
block|{
name|uint32_t
name|gpio_mask
decl_stmt|,
name|gpio_reg
decl_stmt|;
name|int
name|gpio_port
decl_stmt|,
name|gpio_shift
decl_stmt|;
comment|/* The GPIO should be swapped if swap register is set and active */
name|gpio_port
operator|=
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_PORT_SWAP
argument_list|)
operator|&&
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_STRAP_OVERRIDE
argument_list|)
operator|)
operator|^
name|port
expr_stmt|;
name|gpio_shift
operator|=
name|gpio_num
operator|+
operator|(
name|gpio_port
condition|?
name|MISC_REGISTERS_GPIO_PORT_SHIFT
else|:
literal|0
operator|)
expr_stmt|;
name|gpio_mask
operator|=
operator|(
literal|1
operator|<<
name|gpio_shift
operator|)
expr_stmt|;
if|if
condition|(
name|gpio_num
operator|>
name|MISC_REGISTERS_GPIO_3
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): Invalid GPIO %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|gpio_num
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|EINVAL
operator|)
return|;
block|}
name|bxe_acquire_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_GPIO
argument_list|)
expr_stmt|;
comment|/* read GPIO int */
name|gpio_reg
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_GPIO_INT
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|MISC_REGISTERS_GPIO_INT_OUTPUT_CLR
case|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_PHY
argument_list|,
literal|"Clear GPIO INT %d (shift %d) -> "
literal|"output low\n"
argument_list|,
name|gpio_num
argument_list|,
name|gpio_shift
argument_list|)
expr_stmt|;
comment|/* clear SET and set CLR */
name|gpio_reg
operator|&=
operator|~
operator|(
name|gpio_mask
operator|<<
name|MISC_REGISTERS_GPIO_INT_SET_POS
operator|)
expr_stmt|;
name|gpio_reg
operator||=
operator|(
name|gpio_mask
operator|<<
name|MISC_REGISTERS_GPIO_INT_CLR_POS
operator|)
expr_stmt|;
break|break;
case|case
name|MISC_REGISTERS_GPIO_INT_OUTPUT_SET
case|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_PHY
argument_list|,
literal|"Set GPIO INT %d (shift %d) -> "
literal|"output high\n"
argument_list|,
name|gpio_num
argument_list|,
name|gpio_shift
argument_list|)
expr_stmt|;
comment|/* clear CLR and set SET */
name|gpio_reg
operator|&=
operator|~
operator|(
name|gpio_mask
operator|<<
name|MISC_REGISTERS_GPIO_INT_CLR_POS
operator|)
expr_stmt|;
name|gpio_reg
operator||=
operator|(
name|gpio_mask
operator|<<
name|MISC_REGISTERS_GPIO_INT_SET_POS
operator|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_GPIO_INT
argument_list|,
name|gpio_reg
argument_list|)
expr_stmt|;
name|bxe_release_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_GPIO
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Sets the state of a Shared Purpose I/O (SPIO).  *  * Returns:  *   0 = Success, !0 = Failure.  */
end_comment

begin_function
name|int
name|bxe_set_spio
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|spio_num
parameter_list|,
name|uint32_t
name|mode
parameter_list|)
block|{
name|uint32_t
name|spio_reg
decl_stmt|,
name|spio_mask
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
name|spio_mask
operator|=
literal|1
operator|<<
name|spio_num
expr_stmt|;
comment|/* Validate the SPIO. */
if|if
condition|(
operator|(
name|spio_num
operator|<
name|MISC_REGISTERS_SPIO_4
operator|)
operator|||
operator|(
name|spio_num
operator|>
name|MISC_REGISTERS_SPIO_7
operator|)
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): Invalid SPIO (%d)!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|spio_num
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bxe_set_spio_exit
goto|;
block|}
name|rc
operator|=
name|bxe_acquire_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_SPIO
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): Can't acquire SPIO lock!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
goto|goto
name|bxe_set_spio_exit
goto|;
block|}
comment|/* Read SPIO and mask all but the float bits. */
name|spio_reg
operator|=
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_SPIO
argument_list|)
operator|&
name|MISC_REGISTERS_SPIO_FLOAT
operator|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|MISC_REGISTERS_SPIO_OUTPUT_LOW
case|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_MISC
argument_list|,
literal|"%s(): Set SPIO %d -> "
literal|"output low\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|spio_num
argument_list|)
expr_stmt|;
name|spio_reg
operator|&=
operator|~
operator|(
name|spio_mask
operator|<<
name|MISC_REGISTERS_SPIO_FLOAT_POS
operator|)
expr_stmt|;
name|spio_reg
operator||=
operator|(
name|spio_mask
operator|<<
name|MISC_REGISTERS_SPIO_CLR_POS
operator|)
expr_stmt|;
break|break;
case|case
name|MISC_REGISTERS_SPIO_OUTPUT_HIGH
case|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_MISC
argument_list|,
literal|"%s(): Set SPIO %d -> "
literal|"output high\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|spio_num
argument_list|)
expr_stmt|;
name|spio_reg
operator|&=
operator|~
operator|(
name|spio_mask
operator|<<
name|MISC_REGISTERS_SPIO_FLOAT_POS
operator|)
expr_stmt|;
name|spio_reg
operator||=
operator|(
name|spio_mask
operator|<<
name|MISC_REGISTERS_SPIO_SET_POS
operator|)
expr_stmt|;
break|break;
case|case
name|MISC_REGISTERS_SPIO_INPUT_HI_Z
case|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_MISC
argument_list|,
literal|"%s(): Set SPIO %d -> "
literal|"input\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|spio_num
argument_list|)
expr_stmt|;
name|spio_reg
operator||=
operator|(
name|spio_mask
operator|<<
name|MISC_REGISTERS_SPIO_FLOAT_POS
operator|)
expr_stmt|;
break|break;
default|default:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): Unknown SPIO mode (0x%08X)!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|mode
argument_list|)
expr_stmt|;
break|break;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_SPIO
argument_list|,
name|spio_reg
argument_list|)
expr_stmt|;
name|rc
operator|=
name|bxe_release_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_SPIO
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): Can't release SPIO lock!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
name|bxe_set_spio_exit
label|:
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * When the 57711E is operating in multi-function mode, the controller  * must be configured to arbitrate TX between multiple VNICs.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_init_port_minmax
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|fair_periodic_timeout_usec
decl_stmt|,
name|r_param
decl_stmt|,
name|t_fair
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_MISC
argument_list|)
expr_stmt|;
name|r_param
operator|=
name|sc
operator|->
name|link_vars
operator|.
name|line_speed
operator|/
literal|8
expr_stmt|;
name|memset
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|cmng
operator|.
name|rs_vars
operator|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rate_shaping_vars_per_port
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|cmng
operator|.
name|fair_vars
operator|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fairness_vars_per_port
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 100 usec in SDM ticks = 25 since each tick is 4 usec. */
name|sc
operator|->
name|cmng
operator|.
name|rs_vars
operator|.
name|rs_periodic_timeout
operator|=
name|RS_PERIODIC_TIMEOUT_USEC
operator|/
literal|4
expr_stmt|;
comment|/* 	 * This is the threshold below which no timer arming will occur. 	 * We use a coefficient of 1, 25 so that the threshold is a 	 * little bigger that real time to compensate for timer 	 * in-accuracy. 	 */
name|sc
operator|->
name|cmng
operator|.
name|rs_vars
operator|.
name|rs_threshold
operator|=
operator|(
name|RS_PERIODIC_TIMEOUT_USEC
operator|*
name|r_param
operator|*
literal|5
operator|)
operator|/
literal|4
expr_stmt|;
comment|/* Resolution of fairness timer. */
name|fair_periodic_timeout_usec
operator|=
name|QM_ARB_BYTES
operator|/
name|r_param
expr_stmt|;
comment|/* For 10G it is 1000us, for 1G it is 10000us. */
name|t_fair
operator|=
name|T_FAIR_COEF
operator|/
name|sc
operator|->
name|link_vars
operator|.
name|line_speed
expr_stmt|;
comment|/* This is the threshold where we won't arm the timer 	   anymore. */
name|sc
operator|->
name|cmng
operator|.
name|fair_vars
operator|.
name|fair_threshold
operator|=
name|QM_ARB_BYTES
expr_stmt|;
comment|/* 	 * Multiply by 1e3/8 to get bytes/msec. We don't want the 	 * credits to pass a credit of the T_FAIR*FAIR_MEM (algorithm 	 * resolution) 	 */
name|sc
operator|->
name|cmng
operator|.
name|fair_vars
operator|.
name|upper_bound
operator|=
name|r_param
operator|*
name|t_fair
operator|*
name|FAIR_MEM
expr_stmt|;
comment|/* Since each tick is 4 us. */
name|sc
operator|->
name|cmng
operator|.
name|fair_vars
operator|.
name|fairness_timeout
operator|=
name|fair_periodic_timeout_usec
operator|/
literal|4
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_MISC
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function is called when a link interrupt is generated  * and configures the controller for the new link state.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_link_attn
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|host_port_stats
modifier|*
name|pstats
decl_stmt|;
name|uint32_t
name|pause_enabled
decl_stmt|;
name|int
name|func
decl_stmt|,
name|i
decl_stmt|,
name|port
decl_stmt|,
name|vn
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_PHY
argument_list|)
expr_stmt|;
comment|/* Make sure that we are synced with the current statistics. */
name|bxe_stats_handle
argument_list|(
name|sc
argument_list|,
name|STATS_EVENT_STOP
argument_list|)
expr_stmt|;
name|bxe_link_update
argument_list|(
operator|&
name|sc
operator|->
name|link_params
argument_list|,
operator|&
name|sc
operator|->
name|link_vars
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|link_vars
operator|.
name|link_up
condition|)
block|{
if|if
condition|(
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|port
operator|=
name|BP_PORT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|pause_enabled
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|link_vars
operator|.
name|flow_ctrl
operator|&
name|FLOW_CTRL_TX
condition|)
name|pause_enabled
operator|=
literal|1
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_USTORM_INTMEM
operator|+
name|USTORM_ETH_PAUSE_ENABLED_OFFSET
argument_list|(
name|port
argument_list|)
argument_list|,
name|pause_enabled
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|link_vars
operator|.
name|mac_type
operator|==
name|MAC_TYPE_BMAC
condition|)
block|{
name|pstats
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|port_stats
argument_list|)
expr_stmt|;
comment|/* Reset old BMAC statistics. */
name|memset
argument_list|(
operator|&
operator|(
name|pstats
operator|->
name|mac_stx
index|[
literal|0
index|]
operator|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mac_stx
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|state
operator|==
name|BXE_STATE_OPEN
operator|)
operator|||
operator|(
name|sc
operator|->
name|state
operator|==
name|BXE_STATE_DISABLED
operator|)
condition|)
name|bxe_stats_handle
argument_list|(
name|sc
argument_list|,
name|STATS_EVENT_LINK_UP
argument_list|)
expr_stmt|;
block|}
comment|/* Need additional handling for multi-function devices. */
if|if
condition|(
name|IS_E1HMF
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|port
operator|=
name|BP_PORT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|link_vars
operator|.
name|link_up
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|dcc_enable
operator|==
name|TRUE
condition|)
block|{
name|bxe_congestionmgmt
argument_list|(
name|sc
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Store in internal memory. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|cmng_struct_per_port
argument_list|)
operator|/
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_XSTORM_INTMEM
operator|+
name|XSTORM_CMNG_PER_PORT_VARS_OFFSET
argument_list|(
name|port
argument_list|)
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
argument_list|,
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|(
operator|&
name|sc
operator|->
name|cmng
operator|)
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|vn
operator|=
name|VN_0
init|;
name|vn
operator|<
name|E1HVN_MAX
condition|;
name|vn
operator|++
control|)
block|{
comment|/* Don't send an attention to ourselves. */
if|if
condition|(
name|vn
operator|==
name|BP_E1HVN
argument_list|(
name|sc
argument_list|)
condition|)
continue|continue;
name|func
operator|=
operator|(
operator|(
name|vn
operator|<<
literal|1
operator|)
operator||
name|port
operator|)
expr_stmt|;
comment|/* 			 * Send an attention to other drivers on the same port. 			 */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_GENERAL_ATTN_0
operator|+
operator|(
name|LINK_SYNC_ATTENTION_BIT_FUNC_0
operator|+
name|func
operator|)
operator|*
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_PHY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Sets the driver instance as the port management function (PMF).  *  * This is only used on "multi-function" capable devices such as the  * 57711E and initializes the controller so that the PMF driver instance  * can interact with other driver instances that may be operating on  * the same Ethernet port.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_pmf_update
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|int
name|port
decl_stmt|;
comment|/* Record that this driver instance is managing the port. */
name|sc
operator|->
name|port
operator|.
name|pmf
operator|=
literal|1
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_INFO
argument_list|,
literal|"%s(): Enabling this port as PMF.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* Enable NIG attention. */
name|port
operator|=
name|BP_PORT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
literal|0xff0f
operator||
operator|(
literal|1
operator|<<
operator|(
name|BP_E1HVN
argument_list|(
name|sc
argument_list|)
operator|+
literal|4
operator|)
operator|)
operator|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|HC_REG_TRAILING_EDGE_0
operator|+
name|port
operator|*
literal|8
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|HC_REG_LEADING_EDGE_0
operator|+
name|port
operator|*
literal|8
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|bxe_stats_handle
argument_list|(
name|sc
argument_list|,
name|STATS_EVENT_PMF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* 8073 Download definitions */
end_comment

begin_comment
comment|/* spi Parameters.*/
end_comment

begin_define
define|#
directive|define
name|SPI_CTRL_1_L
value|0xC000
end_define

begin_define
define|#
directive|define
name|SPI_CTRL_1_H
value|0xC002
end_define

begin_define
define|#
directive|define
name|SPI_CTRL_2_L
value|0xC400
end_define

begin_define
define|#
directive|define
name|SPI_CTRL_2_H
value|0xC402
end_define

begin_define
define|#
directive|define
name|SPI_TXFIFO
value|0xD000
end_define

begin_define
define|#
directive|define
name|SPI_RXFIFO
value|0xD400
end_define

begin_comment
comment|/* Input Command Messages.*/
end_comment

begin_comment
comment|/*  * Write CPU/SPI Control Regs, followed by Count And CPU/SPI Controller  * Reg add/data pairs.  */
end_comment

begin_define
define|#
directive|define
name|WR_CPU_CTRL_REGS
value|0x11
end_define

begin_comment
comment|/*  * Read CPU/SPI Control Regs, followed by Count and CPU/SPI Controller  * Register Add.  */
end_comment

begin_define
define|#
directive|define
name|RD_CPU_CTRL_REGS
value|0xEE
end_define

begin_comment
comment|/*  * Write CPU/SPI Control Regs Continously, followed by Count and  * CPU/SPI Controller Reg addr and data's.  */
end_comment

begin_define
define|#
directive|define
name|WR_CPU_CTRL_FIFO
value|0x66
end_define

begin_comment
comment|/* Output Command Messages.*/
end_comment

begin_define
define|#
directive|define
name|DONE
value|0x4321
end_define

begin_comment
comment|/* SPI Controller Commands (known As messages).*/
end_comment

begin_define
define|#
directive|define
name|MSGTYPE_HWR
value|0x40
end_define

begin_define
define|#
directive|define
name|MSGTYPE_HRD
value|0x80
end_define

begin_define
define|#
directive|define
name|WRSR_OPCODE
value|0x01
end_define

begin_define
define|#
directive|define
name|WR_OPCODE
value|0x02
end_define

begin_define
define|#
directive|define
name|RD_OPCODE
value|0x03
end_define

begin_define
define|#
directive|define
name|WRDI_OPCODE
value|0x04
end_define

begin_define
define|#
directive|define
name|RDSR_OPCODE
value|0x05
end_define

begin_define
define|#
directive|define
name|WREN_OPCODE
value|0x06
end_define

begin_define
define|#
directive|define
name|WR_BLOCK_SIZE
value|0x40
end_define

begin_comment
comment|/* Maximum 64 Bytes Writes.*/
end_comment

begin_comment
comment|/*  * Post a slowpath command.  *  * A slowpath command is used to propogate a configuration change through  * the controller in a controlled manner, allowing each STORM processor and  * other H/W blocks to phase in the change.  The commands sent on the  * slowpath are referred to as ramrods.  Depending on the ramrod used the  * completion of the ramrod will occur in different ways.  Here's a  * breakdown of ramrods and how they complete:  *  * RAMROD_CMD_ID_ETH_PORT_SETUP  *   Used to setup the leading connection on a port.  Completes on the  *   Receive Completion Queue (RCQ) of that port (typically fp[0]).  *  * RAMROD_CMD_ID_ETH_CLIENT_SETUP  *   Used to setup an additional connection on a port.  Completes on the  *   RCQ of the multi-queue/RSS connection being initialized.  *  * RAMROD_CMD_ID_ETH_STAT_QUERY  *   Used to force the storm processors to update the statistics database  *   in host memory.  This ramrod is send on the leading connection CID and  *   completes as an index increment of the CSTORM on the default status  *   block.  *  * RAMROD_CMD_ID_ETH_UPDATE  *   Used to update the state of the leading connection, usually to udpate  *   the RSS indirection table.  Completes on the RCQ of the leading  *   connection. (Not currently used under FreeBSD until OS support becomes  *   available.)  *  * RAMROD_CMD_ID_ETH_HALT  *   Used when tearing down a connection prior to driver unload.  Completes  *   on the RCQ of the multi-queue/RSS connection being torn down.  Don't  *   use this on the leading connection.  *  * RAMROD_CMD_ID_ETH_SET_MAC  *   Sets the Unicast/Broadcast/Multicast used by the port.  Completes on  *   the RCQ of the leading connection.  *  * RAMROD_CMD_ID_ETH_CFC_DEL  *   Used when tearing down a conneciton prior to driver unload.  Completes  *   on the RCQ of the leading connection (since the current connection  *   has been completely removed from controller memory).  *  * RAMROD_CMD_ID_ETH_PORT_DEL  *   Used to tear down the leading connection prior to driver unload,  *   typically fp[0].  Completes as an index increment of the CSTORM on the  *   default status block.  *  * RAMROD_CMD_ID_ETH_FORWARD_SETUP  *   Used for connection offload.  Completes on the RCQ of the multi-queue  *   RSS connection that is being offloaded.  (Not currently used under  *   FreeBSD.)  *  * There can only be one command pending per function.  *  * Returns:  *   0 = Success, !0 = Failure.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_sp_post
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|command
parameter_list|,
name|int
name|cid
parameter_list|,
name|uint32_t
name|data_hi
parameter_list|,
name|uint32_t
name|data_lo
parameter_list|,
name|int
name|common
parameter_list|)
block|{
name|int
name|func
decl_stmt|,
name|rc
decl_stmt|;
name|DBRUNMSG
argument_list|(
operator|(
name|BXE_EXTREME_LOAD
operator||
name|BXE_EXTREME_RESET
operator||
name|BXE_EXTREME_UNLOAD
operator||
name|BXE_EXTREME_RAMROD
operator|)
argument_list|,
name|bxe_decode_ramrod_cmd
argument_list|(
name|sc
argument_list|,
name|command
argument_list|)
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_RAMROD
argument_list|,
literal|"%s(): cid = %d, data_hi = 0x%08X, "
literal|"data_low = 0x%08X, remaining spq entries = %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|cid
argument_list|,
name|data_hi
argument_list|,
name|data_lo
argument_list|,
name|sc
operator|->
name|spq_left
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
comment|/* Skip all slowpath commands if the driver has panic'd. */
if|if
condition|(
name|sc
operator|->
name|panic
condition|)
block|{
name|rc
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bxe_sp_post_exit
goto|;
block|}
name|BXE_SP_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* We are limited to 8 slowpath commands. */
if|if
condition|(
operator|!
name|sc
operator|->
name|spq_left
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Slowpath queue is full!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|bxe_panic_dump
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|bxe_sp_post_exit
goto|;
block|}
comment|/* Encode the CID with the command. */
name|sc
operator|->
name|spq_prod_bd
operator|->
name|hdr
operator|.
name|conn_and_cmd_data
operator|=
name|htole32
argument_list|(
operator|(
operator|(
name|command
operator|<<
name|SPE_HDR_CMD_ID_SHIFT
operator|)
operator||
name|HW_CID
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|spq_prod_bd
operator|->
name|hdr
operator|.
name|type
operator|=
name|htole16
argument_list|(
name|ETH_CONNECTION_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
condition|)
name|sc
operator|->
name|spq_prod_bd
operator|->
name|hdr
operator|.
name|type
operator||=
name|htole16
argument_list|(
operator|(
literal|1
operator|<<
name|SPE_HDR_COMMON_RAMROD_SHIFT
operator|)
argument_list|)
expr_stmt|;
comment|/* Point the hardware at the new configuration data. */
name|sc
operator|->
name|spq_prod_bd
operator|->
name|data
operator|.
name|mac_config_addr
operator|.
name|hi
operator|=
name|htole32
argument_list|(
name|data_hi
argument_list|)
expr_stmt|;
name|sc
operator|->
name|spq_prod_bd
operator|->
name|data
operator|.
name|mac_config_addr
operator|.
name|lo
operator|=
name|htole32
argument_list|(
name|data_lo
argument_list|)
expr_stmt|;
comment|/* Reduce the number of available slots for slowpath commands. */
name|sc
operator|->
name|spq_left
operator|--
expr_stmt|;
comment|/* Manage the end of the ring. */
if|if
condition|(
name|sc
operator|->
name|spq_prod_bd
operator|==
name|sc
operator|->
name|spq_last_bd
condition|)
block|{
name|sc
operator|->
name|spq_prod_bd
operator|=
name|sc
operator|->
name|spq
expr_stmt|;
name|sc
operator|->
name|spq_prod_idx
operator|=
literal|0
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE
argument_list|,
literal|"%s(): End of slowpath queue.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|spq_prod_bd
operator|++
expr_stmt|;
name|sc
operator|->
name|spq_prod_idx
operator|++
expr_stmt|;
block|}
name|func
operator|=
name|BP_FUNC
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Kick off the slowpath command. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_XSTORM_INTMEM
operator|+
name|XSTORM_SPQ_PROD_OFFSET
argument_list|(
name|func
argument_list|)
argument_list|,
name|sc
operator|->
name|spq_prod_idx
argument_list|)
expr_stmt|;
name|bxe_sp_post_exit
label|:
name|BXE_SP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Acquire the MCP access lock.  *  * Returns:  *   0 = Success, !0 = Failure.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_acquire_alr
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|,
name|retries
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_MISC
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
name|retries
operator|=
literal|100
expr_stmt|;
comment|/* Acquire lock using mcpr_access_lock SPLIT register. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|retries
operator|*
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|val
operator|=
literal|1UL
operator|<<
literal|31
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MCP
operator|+
literal|0x9c
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MCP
operator|+
literal|0x9c
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
operator|(
literal|1L
operator|<<
literal|31
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|val
operator|&
operator|(
literal|1L
operator|<<
literal|31
operator|)
operator|)
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): Cannot acquire MCP split access lock.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EBUSY
expr_stmt|;
block|}
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_MISC
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release the MCP access lock.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_release_alr
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|DBENTER
argument_list|(
name|BXE_VERBOSE_MISC
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MCP
operator|+
literal|0x9c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_MISC
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update driver's copies of the values in the host default status block.  *  * Returns:  *   Bitmap indicating changes to the block.  */
end_comment

begin_function
specifier|static
name|__inline
name|uint16_t
name|bxe_update_dsb_idx
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|host_def_status_block
modifier|*
name|dsb
decl_stmt|;
name|uint16_t
name|rc
decl_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
name|dsb
operator|=
name|sc
operator|->
name|def_sb
expr_stmt|;
comment|/* Read memory barrier since block is written by hardware. */
name|rmb
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|def_att_idx
operator|!=
name|le16toh
argument_list|(
name|dsb
operator|->
name|atten_status_block
operator|.
name|attn_bits_index
argument_list|)
condition|)
block|{
name|sc
operator|->
name|def_att_idx
operator|=
name|le16toh
argument_list|(
name|dsb
operator|->
name|atten_status_block
operator|.
name|attn_bits_index
argument_list|)
expr_stmt|;
name|rc
operator||=
literal|0x1
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|def_c_idx
operator|!=
name|le16toh
argument_list|(
name|dsb
operator|->
name|c_def_status_block
operator|.
name|status_block_index
argument_list|)
condition|)
block|{
name|sc
operator|->
name|def_c_idx
operator|=
name|le16toh
argument_list|(
name|dsb
operator|->
name|c_def_status_block
operator|.
name|status_block_index
argument_list|)
expr_stmt|;
name|rc
operator||=
literal|0x2
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|def_u_idx
operator|!=
name|le16toh
argument_list|(
name|dsb
operator|->
name|u_def_status_block
operator|.
name|status_block_index
argument_list|)
condition|)
block|{
name|sc
operator|->
name|def_u_idx
operator|=
name|le16toh
argument_list|(
name|dsb
operator|->
name|u_def_status_block
operator|.
name|status_block_index
argument_list|)
expr_stmt|;
name|rc
operator||=
literal|0x4
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|def_x_idx
operator|!=
name|le16toh
argument_list|(
name|dsb
operator|->
name|x_def_status_block
operator|.
name|status_block_index
argument_list|)
condition|)
block|{
name|sc
operator|->
name|def_x_idx
operator|=
name|le16toh
argument_list|(
name|dsb
operator|->
name|x_def_status_block
operator|.
name|status_block_index
argument_list|)
expr_stmt|;
name|rc
operator||=
literal|0x8
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|def_t_idx
operator|!=
name|le16toh
argument_list|(
name|dsb
operator|->
name|t_def_status_block
operator|.
name|status_block_index
argument_list|)
condition|)
block|{
name|sc
operator|->
name|def_t_idx
operator|=
name|le16toh
argument_list|(
name|dsb
operator|->
name|t_def_status_block
operator|.
name|status_block_index
argument_list|)
expr_stmt|;
name|rc
operator||=
literal|0x10
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle any attentions that have been newly asserted.  *  * Returns:  *   None  */
end_comment

begin_function
specifier|static
name|void
name|bxe_attn_int_asserted
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|asserted
parameter_list|)
block|{
name|uint32_t
name|aeu_addr
decl_stmt|,
name|hc_addr
decl_stmt|,
name|nig_int_mask_addr
decl_stmt|;
name|uint32_t
name|aeu_mask
decl_stmt|,
name|nig_mask
decl_stmt|;
name|int
name|port
decl_stmt|,
name|rc
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_INTR
argument_list|)
expr_stmt|;
name|port
operator|=
name|BP_PORT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hc_addr
operator|=
operator|(
name|HC_REG_COMMAND_REG
operator|+
name|port
operator|*
literal|32
operator|+
name|COMMAND_REG_ATTN_BITS_SET
operator|)
expr_stmt|;
name|aeu_addr
operator|=
name|port
condition|?
name|MISC_REG_AEU_MASK_ATTN_FUNC_1
else|:
name|MISC_REG_AEU_MASK_ATTN_FUNC_0
expr_stmt|;
name|nig_int_mask_addr
operator|=
name|port
condition|?
name|NIG_REG_MASK_INTERRUPT_PORT1
else|:
name|NIG_REG_MASK_INTERRUPT_PORT0
expr_stmt|;
name|nig_mask
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|attn_state
operator|&
name|asserted
condition|)
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): IGU attention ERROR!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|bxe_acquire_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_PORT0_ATT_MASK
operator|+
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): Failed to acquire attention lock for port %d!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|port
argument_list|)
expr_stmt|;
goto|goto
name|bxe_attn_int_asserted_exit
goto|;
block|}
name|aeu_mask
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|aeu_addr
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_INTR
argument_list|,
literal|"%s(): aeu_mask = 0x%08X, newly asserted = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|aeu_mask
argument_list|,
name|asserted
argument_list|)
expr_stmt|;
name|aeu_mask
operator|&=
operator|~
operator|(
name|asserted
operator|&
literal|0xff
operator|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_INTR
argument_list|,
literal|"%s(): new mask = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|aeu_mask
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|aeu_addr
argument_list|,
name|aeu_mask
argument_list|)
expr_stmt|;
name|rc
operator|=
name|bxe_release_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_PORT0_ATT_MASK
operator|+
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): Failed to release attention lock!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
goto|goto
name|bxe_attn_int_asserted_exit
goto|;
block|}
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_INTR
argument_list|,
literal|"%s(): attn_state = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|attn_state
argument_list|)
expr_stmt|;
name|sc
operator|->
name|attn_state
operator||=
name|asserted
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_INTR
argument_list|,
literal|"%s(): new attn_state = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|attn_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|asserted
operator|&
name|ATTN_HARD_WIRED_MASK
condition|)
block|{
if|if
condition|(
name|asserted
operator|&
name|ATTN_NIG_FOR_FUNC
condition|)
block|{
name|bxe_acquire_phy_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Save NIG interrupt mask. */
name|nig_mask
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|nig_int_mask_addr
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|nig_int_mask_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bxe_link_attn
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|asserted
operator|&
name|ATTN_SW_TIMER_4_FUNC
condition|)
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): ATTN_SW_TIMER_4_FUNC!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
if|if
condition|(
name|asserted
operator|&
name|GPIO_2_FUNC
condition|)
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): GPIO_2_FUNC!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
if|if
condition|(
name|asserted
operator|&
name|GPIO_3_FUNC
condition|)
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): GPIO_3_FUNC!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
if|if
condition|(
name|asserted
operator|&
name|GPIO_4_FUNC
condition|)
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): GPIO_4_FUNC!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|asserted
operator|&
name|ATTN_GENERAL_ATTN_1
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): ATTN_GENERAL_ATTN_1!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_GENERAL_ATTN_1
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|asserted
operator|&
name|ATTN_GENERAL_ATTN_2
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): ATTN_GENERAL_ATTN_2!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_GENERAL_ATTN_2
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|asserted
operator|&
name|ATTN_GENERAL_ATTN_3
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): ATTN_GENERAL_ATTN_3!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_GENERAL_ATTN_3
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|asserted
operator|&
name|ATTN_GENERAL_ATTN_4
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): ATTN_GENERAL_ATTN_4!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_GENERAL_ATTN_4
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|asserted
operator|&
name|ATTN_GENERAL_ATTN_5
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): ATTN_GENERAL_ATTN_5!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_GENERAL_ATTN_5
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|asserted
operator|&
name|ATTN_GENERAL_ATTN_6
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): ATTN_GENERAL_ATTN_6!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_GENERAL_ATTN_6
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_INTR
argument_list|,
literal|"%s(): Writing 0x%08X to HC addr 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|asserted
argument_list|,
name|hc_addr
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|hc_addr
argument_list|,
name|asserted
argument_list|)
expr_stmt|;
comment|/* Now set back the NIG mask. */
if|if
condition|(
name|asserted
operator|&
name|ATTN_NIG_FOR_FUNC
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|nig_int_mask_addr
argument_list|,
name|nig_mask
argument_list|)
expr_stmt|;
name|bxe_release_phy_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|bxe_attn_int_asserted_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_INTR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle any attentions that have been newly deasserted.  *  * Returns:  *   None  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|bxe_attn_int_deasserted0
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|attn
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|,
name|swap_val
decl_stmt|,
name|swap_override
decl_stmt|;
name|int
name|port
decl_stmt|,
name|reg_offset
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_INTR
argument_list|)
expr_stmt|;
name|port
operator|=
name|BP_PORT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|reg_offset
operator|=
name|port
condition|?
name|MISC_REG_AEU_ENABLE1_FUNC_1_OUT_0
else|:
name|MISC_REG_AEU_ENABLE1_FUNC_0_OUT_0
expr_stmt|;
comment|/* Handle SPIO5 attention. */
if|if
condition|(
name|attn
operator|&
name|AEU_INPUTS_ATTN_BITS_SPIO5
condition|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|reg_offset
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|AEU_INPUTS_ATTN_BITS_SPIO5
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|reg_offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): SPIO5 H/W attention!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* Fan failure attention */
switch|switch
condition|(
name|XGXS_EXT_PHY_TYPE
argument_list|(
name|sc
operator|->
name|link_params
operator|.
name|ext_phy_config
argument_list|)
condition|)
block|{
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_SFX7101
case|:
comment|/* 			 * SPIO5 is used on A1022G boards to indicate 			 * fan failure.  Shutdown the controller and 			 * associated PHY to avoid damage. 			 */
comment|/* Low power mode is controled by GPIO 2. */
name|bxe_set_gpio
argument_list|(
name|sc
argument_list|,
name|MISC_REGISTERS_GPIO_2
argument_list|,
name|MISC_REGISTERS_GPIO_OUTPUT_LOW
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/* PHY reset is controled by GPIO 1. */
name|bxe_set_gpio
argument_list|(
name|sc
argument_list|,
name|MISC_REGISTERS_GPIO_1
argument_list|,
name|MISC_REGISTERS_GPIO_OUTPUT_LOW
argument_list|,
name|port
argument_list|)
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727
case|:
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8481
case|:
comment|/* 			 * The PHY reset is controlled by GPIO 1. 			 * Fake the port number to cancel the swap done in 			 * set_gpio(). 			 */
name|swap_val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_PORT_SWAP
argument_list|)
expr_stmt|;
name|swap_override
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_STRAP_OVERRIDE
argument_list|)
expr_stmt|;
name|port
operator|=
operator|(
name|swap_val
operator|&&
name|swap_override
operator|)
operator|^
literal|1
expr_stmt|;
name|bxe_set_gpio
argument_list|(
name|sc
argument_list|,
name|MISC_REGISTERS_GPIO_1
argument_list|,
name|MISC_REGISTERS_GPIO_OUTPUT_LOW
argument_list|,
name|port
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Mark the failure. */
name|sc
operator|->
name|link_params
operator|.
name|ext_phy_config
operator|&=
operator|~
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_MASK
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|ext_phy_config
operator||=
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_FAILURE
expr_stmt|;
name|SHMEM_WR
argument_list|(
name|sc
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|port
index|]
operator|.
name|external_phy_config
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|ext_phy_config
argument_list|)
expr_stmt|;
comment|/* Log the failure */
name|BXE_PRINTF
argument_list|(
literal|"A fan failure has caused the driver to "
literal|"shutdown the device to prevent permanent damage.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|attn
operator|&
operator|(
name|AEU_INPUTS_ATTN_BITS_GPIO3_FUNCTION_0
operator||
name|AEU_INPUTS_ATTN_BITS_GPIO3_FUNCTION_1
operator|)
condition|)
block|{
name|bxe_acquire_phy_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_handle_module_detect_int
argument_list|(
operator|&
name|sc
operator|->
name|link_params
argument_list|)
expr_stmt|;
name|bxe_release_phy_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* Checking for an assert on the zero block */
if|if
condition|(
name|attn
operator|&
name|HW_INTERRUT_ASSERT_SET_0
condition|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|reg_offset
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
name|attn
operator|&
name|HW_INTERRUT_ASSERT_SET_0
operator|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|reg_offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): FATAL hardware block attention "
literal|"(set0 = 0x%08X)!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
operator|(
name|attn
operator|&
operator|(
name|uint32_t
operator|)
name|HW_INTERRUT_ASSERT_SET_0
operator|)
argument_list|)
expr_stmt|;
name|bxe_panic_dump
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_INTR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle any attentions that have been newly deasserted.  *  * Returns:  *   None  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|bxe_attn_int_deasserted1
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|attn
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|int
name|port
decl_stmt|,
name|reg_offset
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_INTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|attn
operator|&
name|AEU_INPUTS_ATTN_BITS_DOORBELLQ_HW_INTERRUPT
condition|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|DORQ_REG_DORQ_INT_STS_CLR
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): Doorbell hardware attention (0x%08X).\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* DORQ discard attention */
if|if
condition|(
name|val
operator|&
literal|0x2
condition|)
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): FATAL doorbell queue error!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|attn
operator|&
name|HW_INTERRUT_ASSERT_SET_1
condition|)
block|{
name|port
operator|=
name|BP_PORT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|reg_offset
operator|=
name|port
condition|?
name|MISC_REG_AEU_ENABLE1_FUNC_1_OUT_1
else|:
name|MISC_REG_AEU_ENABLE1_FUNC_0_OUT_1
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|reg_offset
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
name|attn
operator|&
name|HW_INTERRUT_ASSERT_SET_1
operator|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|reg_offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): FATAL hardware block attention "
literal|"(set1 = 0x%08X)!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
operator|(
name|attn
operator|&
operator|(
name|uint32_t
operator|)
name|HW_INTERRUT_ASSERT_SET_1
operator|)
argument_list|)
expr_stmt|;
name|bxe_panic_dump
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_INTR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle any attentions that have been newly deasserted.  *  * Returns:  *   None  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|bxe_attn_int_deasserted2
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|attn
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|int
name|port
decl_stmt|,
name|reg_offset
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_INTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|attn
operator|&
name|AEU_INPUTS_ATTN_BITS_CFC_HW_INTERRUPT
condition|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|CFC_REG_CFC_INT_STS_CLR
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): CFC hardware attention (0x%08X).\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* CFC error attention. */
if|if
condition|(
name|val
operator|&
literal|0x2
condition|)
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): FATAL CFC error!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|attn
operator|&
name|AEU_INPUTS_ATTN_BITS_PXP_HW_INTERRUPT
condition|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|PXP_REG_PXP_INT_STS_CLR_0
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): PXP hardware attention (0x%08X).\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* RQ_USDMDP_FIFO_OVERFLOW */
if|if
condition|(
name|val
operator|&
literal|0x18000
condition|)
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): FATAL PXP error!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|attn
operator|&
name|HW_INTERRUT_ASSERT_SET_2
condition|)
block|{
name|port
operator|=
name|BP_PORT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|reg_offset
operator|=
name|port
condition|?
name|MISC_REG_AEU_ENABLE1_FUNC_1_OUT_2
else|:
name|MISC_REG_AEU_ENABLE1_FUNC_0_OUT_2
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|reg_offset
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
name|attn
operator|&
name|HW_INTERRUT_ASSERT_SET_2
operator|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|reg_offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): FATAL hardware block attention (set2 = "
literal|"0x%08X)! port=%d, val written=0x%x attn=0x%x\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
operator|(
name|attn
operator|&
operator|(
name|uint32_t
operator|)
name|HW_INTERRUT_ASSERT_SET_2
operator|)
argument_list|,
name|port
argument_list|,
name|val
argument_list|,
name|attn
argument_list|)
expr_stmt|;
name|bxe_panic_dump
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_INTR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle any attentions that have been newly deasserted.  *  * Returns:  *   None  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|bxe_attn_int_deasserted3
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|attn
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|int
name|func
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_INTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|attn
operator|&
name|EVEREST_GEN_ATTN_IN_USE_MASK
condition|)
block|{
comment|/* Look for any port assertions. */
if|if
condition|(
name|attn
operator|&
name|BXE_PMF_LINK_ASSERT
condition|)
block|{
comment|/* 			 * We received a message from the driver instance 			 * that is managing the Ethernet port (link up/down). 			 * Go ahead and handle it. 			 */
name|func
operator|=
name|BP_FUNC
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_INFO
argument_list|,
literal|"%s(): Received link attention from PMF.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* Clear the attention. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_GENERAL_ATTN_12
operator|+
name|func
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mf_config
index|[
name|BP_E1HVN
argument_list|(
name|sc
argument_list|)
index|]
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|mf_cfg
operator|.
name|func_mf_config
index|[
operator|(
name|sc
operator|->
name|bxe_func
operator|&
literal|1
operator|)
index|]
operator|.
name|config
argument_list|)
expr_stmt|;
name|val
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|func_mb
index|[
name|func
index|]
operator|.
name|drv_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|dcc_enable
operator|==
name|TRUE
condition|)
block|{
if|if
condition|(
name|val
operator|&
name|DRV_STATUS_DCC_EVENT_MASK
condition|)
name|bxe_dcc_event
argument_list|(
name|sc
argument_list|,
name|val
operator|&
name|DRV_STATUS_DCC_EVENT_MASK
argument_list|)
expr_stmt|;
block|}
name|bxe__link_status_update
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|port
operator|.
name|pmf
operator|==
literal|0
operator|)
operator|&&
operator|(
name|val
operator|&
name|DRV_STATUS_PMF
operator|)
condition|)
name|bxe_pmf_update
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Look for any microcode assertions. */
block|}
elseif|else
if|if
condition|(
name|attn
operator|&
name|BXE_MC_ASSERT_BITS
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): Microcode assert!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_GENERAL_ATTN_10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_GENERAL_ATTN_9
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_GENERAL_ATTN_8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_GENERAL_ATTN_7
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bxe_panic_dump
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Look for any bootcode assertions. */
block|}
elseif|else
if|if
condition|(
name|attn
operator|&
name|BXE_MCP_ASSERT
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): Bootcode assert!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_GENERAL_ATTN_11
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DBRUN
argument_list|(
name|bxe_dump_fw
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): Unknown hardware assertion "
literal|"(attn = 0x%08X)!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|attn
argument_list|)
expr_stmt|;
block|}
comment|/* Look for any hardware latched attentions. */
if|if
condition|(
name|attn
operator|&
name|EVEREST_LATCHED_ATTN_IN_USE_MASK
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): Latched attention 0x%08X (masked)!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|attn
argument_list|)
expr_stmt|;
comment|/* Check if a GRC register access timeout occurred. */
if|if
condition|(
name|attn
operator|&
name|BXE_GRC_TIMEOUT
condition|)
block|{
name|val
operator|=
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
condition|?
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_GRC_TIMEOUT_ATTN
argument_list|)
else|:
literal|0
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): GRC timeout for register 0x%08X!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
comment|/* Check if a GRC reserved register was accessed. */
if|if
condition|(
name|attn
operator|&
name|BXE_GRC_RSV
condition|)
block|{
name|val
operator|=
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
condition|?
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_GRC_RSV_ATTN
argument_list|)
else|:
literal|0
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): GRC register 0x%08X is reserved!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_CLR_LATCH_SIGNAL
argument_list|,
literal|0x7ff
argument_list|)
expr_stmt|;
block|}
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_INTR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle any attentions that have been newly deasserted.  *  * Returns:  *   None  */
end_comment

begin_function
specifier|static
name|void
name|bxe_attn_int_deasserted
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|deasserted
parameter_list|)
block|{
name|struct
name|attn_route
name|attn
decl_stmt|;
name|struct
name|attn_route
name|group_mask
decl_stmt|;
name|uint32_t
name|val
decl_stmt|,
name|reg_addr
decl_stmt|,
name|aeu_mask
decl_stmt|;
name|int
name|index
decl_stmt|,
name|port
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_INTR
argument_list|)
expr_stmt|;
comment|/* 	 * Need to take HW lock because MCP or other port might also try 	 * to handle this event. 	 */
name|bxe_acquire_alr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|port
operator|=
name|BP_PORT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Get the current attention signal bits. */
name|attn
operator|.
name|sig
index|[
literal|0
index|]
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_AFTER_INVERT_1_FUNC_0
operator|+
name|port
operator|*
literal|4
argument_list|)
expr_stmt|;
name|attn
operator|.
name|sig
index|[
literal|1
index|]
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_AFTER_INVERT_2_FUNC_0
operator|+
name|port
operator|*
literal|4
argument_list|)
expr_stmt|;
name|attn
operator|.
name|sig
index|[
literal|2
index|]
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_AFTER_INVERT_3_FUNC_0
operator|+
name|port
operator|*
literal|4
argument_list|)
expr_stmt|;
name|attn
operator|.
name|sig
index|[
literal|3
index|]
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_AFTER_INVERT_4_FUNC_0
operator|+
name|port
operator|*
literal|4
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_EXTREME_INTR
argument_list|,
literal|"%s(): attention = 0x%08X 0x%08X 0x%08X 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|attn
operator|.
name|sig
index|[
literal|0
index|]
argument_list|,
name|attn
operator|.
name|sig
index|[
literal|1
index|]
argument_list|,
name|attn
operator|.
name|sig
index|[
literal|2
index|]
argument_list|,
name|attn
operator|.
name|sig
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Compare the current attention bits to each attention group 	 * to see if anyone has registered this attention. 	 */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|MAX_DYNAMIC_ATTN_GRPS
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
name|deasserted
operator|&
operator|(
literal|1
operator|<<
name|index
operator|)
condition|)
block|{
name|group_mask
operator|=
name|sc
operator|->
name|attn_group
index|[
name|index
index|]
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_EXTREME_INTR
argument_list|,
literal|"%s(): group[%02d] = 0x%08X 0x%08X 0x%08x 0X%08x\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|index
argument_list|,
name|group_mask
operator|.
name|sig
index|[
literal|0
index|]
argument_list|,
name|group_mask
operator|.
name|sig
index|[
literal|1
index|]
argument_list|,
name|group_mask
operator|.
name|sig
index|[
literal|2
index|]
argument_list|,
name|group_mask
operator|.
name|sig
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* Handle any registered attentions. */
name|bxe_attn_int_deasserted3
argument_list|(
name|sc
argument_list|,
name|attn
operator|.
name|sig
index|[
literal|3
index|]
operator|&
name|group_mask
operator|.
name|sig
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|bxe_attn_int_deasserted1
argument_list|(
name|sc
argument_list|,
name|attn
operator|.
name|sig
index|[
literal|1
index|]
operator|&
name|group_mask
operator|.
name|sig
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|bxe_attn_int_deasserted2
argument_list|(
name|sc
argument_list|,
name|attn
operator|.
name|sig
index|[
literal|2
index|]
operator|&
name|group_mask
operator|.
name|sig
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|bxe_attn_int_deasserted0
argument_list|(
name|sc
argument_list|,
name|attn
operator|.
name|sig
index|[
literal|0
index|]
operator|&
name|group_mask
operator|.
name|sig
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|attn
operator|.
name|sig
index|[
literal|0
index|]
operator|&
name|group_mask
operator|.
name|sig
index|[
literal|0
index|]
operator|&
name|HW_PRTY_ASSERT_SET_0
operator|)
operator|||
operator|(
name|attn
operator|.
name|sig
index|[
literal|1
index|]
operator|&
name|group_mask
operator|.
name|sig
index|[
literal|1
index|]
operator|&
name|HW_PRTY_ASSERT_SET_1
operator|)
operator|||
operator|(
name|attn
operator|.
name|sig
index|[
literal|2
index|]
operator|&
name|group_mask
operator|.
name|sig
index|[
literal|2
index|]
operator|&
name|HW_PRTY_ASSERT_SET_2
operator|)
condition|)
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): FATAL hardware block "
literal|"parity attention!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
block|}
name|bxe_release_alr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|reg_addr
operator|=
operator|(
name|HC_REG_COMMAND_REG
operator|+
name|port
operator|*
literal|32
operator|+
name|COMMAND_REG_ATTN_BITS_CLR
operator|)
expr_stmt|;
name|val
operator|=
operator|~
name|deasserted
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_EXTREME_INTR
argument_list|,
literal|"%s(): About to mask 0x%08X at HC addr 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|deasserted
argument_list|,
name|reg_addr
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|reg_addr
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|~
name|sc
operator|->
name|attn_state
operator|&
name|deasserted
condition|)
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): IGU Bug!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|reg_addr
operator|=
name|port
condition|?
name|MISC_REG_AEU_MASK_ATTN_FUNC_1
else|:
name|MISC_REG_AEU_MASK_ATTN_FUNC_0
expr_stmt|;
name|bxe_acquire_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_PORT0_ATT_MASK
operator|+
name|port
argument_list|)
expr_stmt|;
name|aeu_mask
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|reg_addr
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_EXTREME_INTR
argument_list|,
literal|"%s(): Current aeu_mask = 0x%08X, newly deasserted = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|aeu_mask
argument_list|,
name|deasserted
argument_list|)
expr_stmt|;
name|aeu_mask
operator||=
operator|(
name|deasserted
operator|&
literal|0xff
operator|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_EXTREME_INTR
argument_list|,
literal|"%s(): New aeu_mask = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|aeu_mask
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|reg_addr
argument_list|,
name|aeu_mask
argument_list|)
expr_stmt|;
name|bxe_release_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_PORT0_ATT_MASK
operator|+
name|port
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_EXTREME_INTR
argument_list|,
literal|"%s(): Current attn_state = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|attn_state
argument_list|)
expr_stmt|;
name|sc
operator|->
name|attn_state
operator|&=
operator|~
name|deasserted
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_EXTREME_INTR
argument_list|,
literal|"%s(): New attn_state = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|attn_state
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_INTR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle interrupts caused by internal attentions (everything else other  * than RX, TX, and link state changes).  *  * Returns:  *   None  */
end_comment

begin_function
specifier|static
name|void
name|bxe_attn_int
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|attn_ack
decl_stmt|,
name|attn_bits
decl_stmt|,
name|attn_state
decl_stmt|;
name|uint32_t
name|asserted
decl_stmt|,
name|deasserted
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_INTR
argument_list|)
expr_stmt|;
name|attn_bits
operator|=
name|le32toh
argument_list|(
name|sc
operator|->
name|def_sb
operator|->
name|atten_status_block
operator|.
name|attn_bits
argument_list|)
expr_stmt|;
name|attn_ack
operator|=
name|le32toh
argument_list|(
name|sc
operator|->
name|def_sb
operator|->
name|atten_status_block
operator|.
name|attn_bits_ack
argument_list|)
expr_stmt|;
name|attn_state
operator|=
name|sc
operator|->
name|attn_state
expr_stmt|;
name|asserted
operator|=
name|attn_bits
operator|&
operator|~
name|attn_ack
operator|&
operator|~
name|attn_state
expr_stmt|;
name|deasserted
operator|=
operator|~
name|attn_bits
operator|&
name|attn_ack
operator|&
name|attn_state
expr_stmt|;
comment|/* Make sure we're in a sane state. */
if|if
condition|(
operator|~
operator|(
name|attn_bits
operator|^
name|attn_ack
operator|)
operator|&
operator|(
name|attn_bits
operator|^
name|attn_state
operator|)
condition|)
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Bad attention state!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
comment|/* Handle any attentions that are newly asserted. */
if|if
condition|(
name|asserted
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_INTR
argument_list|,
literal|"%s(): attn_state = 0x%08X, attn_bits = 0x%08X, "
literal|"attn_ack = 0x%08X, asserted = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|attn_state
argument_list|,
name|attn_bits
argument_list|,
name|attn_ack
argument_list|,
name|asserted
argument_list|)
expr_stmt|;
name|bxe_attn_int_asserted
argument_list|(
name|sc
argument_list|,
name|asserted
argument_list|)
expr_stmt|;
block|}
comment|/* Handle any attentions that are newly deasserted. */
if|if
condition|(
name|deasserted
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_INTR
argument_list|,
literal|"%s(): attn_state = 0x%08X, attn_bits = 0x%08X, "
literal|"attn_ack = 0x%08X, deasserted = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|attn_state
argument_list|,
name|attn_bits
argument_list|,
name|attn_ack
argument_list|,
name|deasserted
argument_list|)
expr_stmt|;
name|bxe_attn_int_deasserted
argument_list|(
name|sc
argument_list|,
name|deasserted
argument_list|)
expr_stmt|;
block|}
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_INTR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* sum[hi:lo] += add[hi:lo] */
end_comment

begin_define
define|#
directive|define
name|ADD_64
parameter_list|(
name|s_hi
parameter_list|,
name|a_hi
parameter_list|,
name|s_lo
parameter_list|,
name|a_lo
parameter_list|)
value|do {			\ 	s_lo += a_lo;						\ 	s_hi += a_hi + ((s_lo< a_lo) ? 1 : 0);			\ } while (0)
end_define

begin_comment
comment|/* Subtraction = minuend -= subtrahend */
end_comment

begin_define
define|#
directive|define
name|SUB_64
parameter_list|(
name|m_hi
parameter_list|,
name|s_hi
parameter_list|,
name|m_lo
parameter_list|,
name|s_lo
parameter_list|)
define|\
value|do {							\ 		DIFF_64(m_hi, m_hi, s_hi, m_lo, m_lo, s_lo);	\ 	} while (0)
end_define

begin_comment
comment|/* difference = minuend - subtrahend */
end_comment

begin_define
define|#
directive|define
name|DIFF_64
parameter_list|(
name|d_hi
parameter_list|,
name|m_hi
parameter_list|,
name|s_hi
parameter_list|,
name|d_lo
parameter_list|,
name|m_lo
parameter_list|,
name|s_lo
parameter_list|)
value|do {	\ 	if (m_lo< s_lo) {					\
comment|/* underflow */
value|\ 		d_hi = m_hi - s_hi;				\ 		if (d_hi> 0) {					\
comment|/* we can 'loan' 1 */
value|\ 			d_hi--;					\ 			d_lo = m_lo + (UINT_MAX - s_lo) + 1;	\ 		} else {					\
comment|/* m_hi<= s_hi */
value|\ 			d_hi = 0;				\ 			d_lo = 0;				\ 		}						\ 	} else {						\
comment|/* m_lo>= s_lo */
value|\ 		if (m_hi< s_hi) {				\ 			d_hi = 0;				\ 			d_lo = 0;				\ 		} else {					\
comment|/* m_hi>= s_hi */
value|\ 			d_hi = m_hi - s_hi;			\ 			d_lo = m_lo - s_lo;			\ 		}						\ 	}							\ } while (0)
end_define

begin_define
define|#
directive|define
name|UPDATE_STAT64
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
value|do {				\ 	DIFF_64(diff.hi, new->s##_hi, pstats->mac_stx[0].t##_hi,\ 	    diff.lo, new->s##_lo, pstats->mac_stx[0].t##_lo);	\ 	pstats->mac_stx[0].t##_hi = new->s##_hi;		\ 	pstats->mac_stx[0].t##_lo = new->s##_lo;		\ 	ADD_64(pstats->mac_stx[1].t##_hi, diff.hi,		\ 	    pstats->mac_stx[1].t##_lo, diff.lo);		\ } while (0)
end_define

begin_define
define|#
directive|define
name|UPDATE_STAT64_NIG
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
value|do {				\ 	DIFF_64(diff.hi, new->s##_hi, old->s##_hi,		\ 	    diff.lo, new->s##_lo, old->s##_lo);			\ 	ADD_64(estats->t##_hi, diff.hi,				\ 	    estats->t##_lo, diff.lo);				\ } while (0)
end_define

begin_comment
comment|/* sum[hi:lo] += add */
end_comment

begin_define
define|#
directive|define
name|ADD_EXTEND_64
parameter_list|(
name|s_hi
parameter_list|,
name|s_lo
parameter_list|,
name|a
parameter_list|)
value|do {			\ 	s_lo += a;						\ 	s_hi += (s_lo< a) ? 1 : 0;				\ } while (0)
end_define

begin_define
define|#
directive|define
name|UPDATE_EXTEND_STAT
parameter_list|(
name|s
parameter_list|)
value|do {				\ 	ADD_EXTEND_64(pstats->mac_stx[1].s##_hi,		\ 	    pstats->mac_stx[1].s##_lo, new->s);			\ } while (0)
end_define

begin_define
define|#
directive|define
name|UPDATE_EXTEND_TSTAT
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
value|do {				\ 	diff = (tclient->s) - (old_tclient->s);	\ 	old_tclient->s = (tclient->s);				\ 	ADD_EXTEND_64(qstats->t##_hi, qstats->t##_lo, diff);	\ } while (0)
end_define

begin_define
define|#
directive|define
name|UPDATE_EXTEND_XSTAT
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
value|do {				\ 	diff = xclient->s - old_xclient->s;	\ 	old_xclient->s = xclient->s;				\ 	ADD_EXTEND_64(qstats->t##_hi, qstats->t##_lo, diff);	\ } while (0)
end_define

begin_define
define|#
directive|define
name|UPDATE_EXTEND_USTAT
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
value|do {				\ 	diff = uclient->s - old_uclient->s;	\ 	old_uclient->s = uclient->s;				\ 	ADD_EXTEND_64(qstats->t##_hi, qstats->t##_lo, diff);	\ } while (0)
end_define

begin_define
define|#
directive|define
name|SUB_EXTEND_64
parameter_list|(
name|m_hi
parameter_list|,
name|m_lo
parameter_list|,
name|s
parameter_list|)
value|do {			\ 	SUB_64(m_hi, 0, m_lo, s);				\ } while (0)
end_define

begin_define
define|#
directive|define
name|SUB_EXTEND_USTAT
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
value|do {				\ 	diff = (uclient->s) - (old_uclient->s);	\ 	SUB_EXTEND_64(qstats->t##_hi, qstats->t##_lo, diff);	\ } while (0)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__i386__
end_ifdef

begin_define
define|#
directive|define
name|BITS_PER_LONG
value|32
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BITS_PER_LONG
value|64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|__inline
name|long
name|bxe_hilo
parameter_list|(
name|uint32_t
modifier|*
name|hiref
parameter_list|)
block|{
name|uint32_t
name|lo
decl_stmt|;
name|lo
operator|=
operator|*
operator|(
name|hiref
operator|+
literal|1
operator|)
expr_stmt|;
if|#
directive|if
operator|(
name|BITS_PER_LONG
operator|==
literal|64
operator|)
name|uint32_t
name|hi
init|=
operator|*
name|hiref
decl_stmt|;
return|return
operator|(
name|HILO_U64
argument_list|(
name|hi
argument_list|,
name|lo
argument_list|)
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|lo
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Request the STORM statistics by posting a slowpath ramrod.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_stats_storm_post
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|eth_query_ramrod_data
name|ramrod_data
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_INSANE_STATS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|stats_pending
condition|)
block|{
name|ramrod_data
operator|.
name|drv_counter
operator|=
name|sc
operator|->
name|stats_counter
operator|++
expr_stmt|;
name|ramrod_data
operator|.
name|collect_port
operator|=
name|sc
operator|->
name|port
operator|.
name|pmf
condition|?
literal|1
else|:
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
name|ramrod_data
operator|.
name|ctr_id_vector
operator||=
operator|(
literal|1
operator|<<
name|sc
operator|->
name|fp
index|[
name|i
index|]
operator|.
name|cl_id
operator|)
expr_stmt|;
name|rc
operator|=
name|bxe_sp_post
argument_list|(
name|sc
argument_list|,
name|RAMROD_CMD_ID_ETH_STAT_QUERY
argument_list|,
literal|0
argument_list|,
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|ramrod_data
operator|)
index|[
literal|1
index|]
argument_list|,
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|ramrod_data
operator|)
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
comment|/* Stats ramrod has it's own slot on the SPQ. */
name|sc
operator|->
name|spq_left
operator|++
expr_stmt|;
name|sc
operator|->
name|stats_pending
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|DBEXIT
argument_list|(
name|BXE_INSANE_STATS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Setup the adrress used by the driver to report port-based statistics  * back to the controller.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_stats_port_base_init
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
modifier|*
name|stats_comp
decl_stmt|;
name|struct
name|dmae_command
modifier|*
name|dmae
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_STATS
argument_list|)
expr_stmt|;
comment|/* Only the port management function (PMF) does this work. */
if|if
condition|(
operator|(
name|sc
operator|->
name|port
operator|.
name|pmf
operator|==
literal|0
operator|)
operator|||
operator|!
name|sc
operator|->
name|port
operator|.
name|port_stx
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Invalid statistcs port setup!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
goto|goto
name|bxe_stats_port_base_init_exit
goto|;
block|}
name|stats_comp
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|stats_comp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|executer_idx
operator|=
literal|0
expr_stmt|;
comment|/* DMA the address of the drivers port statistics block. */
name|dmae
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|dmae
index|[
name|sc
operator|->
name|executer_idx
operator|++
index|]
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|opcode
operator|=
operator|(
name|DMAE_CMD_SRC_PCI
operator||
name|DMAE_CMD_DST_GRC
operator||
name|DMAE_CMD_C_DST_PCI
operator||
name|DMAE_CMD_C_ENABLE
operator||
name|DMAE_CMD_SRC_RESET
operator||
name|DMAE_CMD_DST_RESET
operator||
ifdef|#
directive|ifdef
name|__BIG_ENDIAN
name|DMAE_CMD_ENDIANITY_B_DW_SWAP
operator||
else|#
directive|else
name|DMAE_CMD_ENDIANITY_DW_SWAP
operator||
endif|#
directive|endif
operator|(
name|BP_PORT
argument_list|(
name|sc
argument_list|)
condition|?
name|DMAE_CMD_PORT_1
else|:
name|DMAE_CMD_PORT_0
operator|)
operator||
operator|(
name|BP_E1HVN
argument_list|(
name|sc
argument_list|)
operator|<<
name|DMAE_CMD_E1HVN_SHIFT
operator|)
operator|)
expr_stmt|;
name|dmae
operator|->
name|src_addr_lo
operator|=
name|U64_LO
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|port_stats
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|src_addr_hi
operator|=
name|U64_HI
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|port_stats
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|dst_addr_lo
operator|=
name|sc
operator|->
name|port
operator|.
name|port_stx
operator|>>
literal|2
expr_stmt|;
name|dmae
operator|->
name|dst_addr_hi
operator|=
literal|0
expr_stmt|;
name|dmae
operator|->
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|host_port_stats
argument_list|)
operator|>>
literal|2
expr_stmt|;
name|dmae
operator|->
name|comp_addr_lo
operator|=
name|U64_LO
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|stats_comp
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|comp_addr_hi
operator|=
name|U64_HI
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|stats_comp
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|comp_val
operator|=
name|DMAE_COMP_VAL
expr_stmt|;
operator|*
name|stats_comp
operator|=
literal|0
expr_stmt|;
name|bxe_stats_hw_post
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_stats_comp
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_stats_port_base_init_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_STATS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Setup the adrress used by the driver to report function-based statistics  * back to the controller.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_stats_func_base_init
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|port
decl_stmt|,
name|func
decl_stmt|;
name|int
name|vn
decl_stmt|,
name|vn_max
decl_stmt|;
name|uint32_t
name|func_stx
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_STATS
argument_list|)
expr_stmt|;
comment|/* Only the port management function (PMF) does this work. */
if|if
condition|(
operator|(
name|sc
operator|->
name|port
operator|.
name|pmf
operator|==
literal|0
operator|)
operator|||
operator|!
name|sc
operator|->
name|func_stx
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Invalid statistcs function setup!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
goto|goto
name|bxe_stats_func_base_init_exit
goto|;
block|}
name|port
operator|=
name|BP_PORT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|func_stx
operator|=
name|sc
operator|->
name|func_stx
expr_stmt|;
name|vn_max
operator|=
name|IS_E1HMF
argument_list|(
name|sc
argument_list|)
condition|?
name|E1HVN_MAX
else|:
name|E1VN_MAX
expr_stmt|;
comment|/* Initialize each function individually. */
for|for
control|(
name|vn
operator|=
name|VN_0
init|;
name|vn
operator|<
name|vn_max
condition|;
name|vn
operator|++
control|)
block|{
name|func
operator|=
literal|2
operator|*
name|vn
operator|+
name|port
expr_stmt|;
name|sc
operator|->
name|func_stx
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|func_mb
index|[
name|func
index|]
operator|.
name|fw_mb_param
argument_list|)
expr_stmt|;
name|bxe_stats_func_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_stats_hw_post
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_stats_comp
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|func_stx
operator|=
name|func_stx
expr_stmt|;
name|bxe_stats_func_base_init_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_STATS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * DMA the function-based statistics to the controller.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_stats_func_base_update
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
modifier|*
name|stats_comp
decl_stmt|;
name|struct
name|dmae_command
modifier|*
name|dmae
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_STATS
argument_list|)
expr_stmt|;
comment|/* Only the port management function (PMF) does this work. */
if|if
condition|(
operator|(
name|sc
operator|->
name|port
operator|.
name|pmf
operator|==
literal|0
operator|)
operator|||
operator|!
name|sc
operator|->
name|func_stx
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Invalid statistcs function update!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
goto|goto
name|bxe_stats_func_base_update_exit
goto|;
block|}
name|dmae
operator|=
operator|&
name|sc
operator|->
name|stats_dmae
expr_stmt|;
name|stats_comp
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|stats_comp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|executer_idx
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|dmae
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dmae_command
argument_list|)
argument_list|)
expr_stmt|;
comment|/* DMA the function statistics from the driver to the H/W. */
name|dmae
operator|->
name|opcode
operator|=
operator|(
name|DMAE_CMD_SRC_GRC
operator||
name|DMAE_CMD_DST_PCI
operator||
name|DMAE_CMD_C_DST_PCI
operator||
name|DMAE_CMD_C_ENABLE
operator||
name|DMAE_CMD_SRC_RESET
operator||
name|DMAE_CMD_DST_RESET
operator||
ifdef|#
directive|ifdef
name|__BIG_ENDIAN
name|DMAE_CMD_ENDIANITY_B_DW_SWAP
operator||
else|#
directive|else
name|DMAE_CMD_ENDIANITY_DW_SWAP
operator||
endif|#
directive|endif
operator|(
name|BP_PORT
argument_list|(
name|sc
argument_list|)
condition|?
name|DMAE_CMD_PORT_1
else|:
name|DMAE_CMD_PORT_0
operator|)
operator||
operator|(
name|BP_E1HVN
argument_list|(
name|sc
argument_list|)
operator|<<
name|DMAE_CMD_E1HVN_SHIFT
operator|)
operator|)
expr_stmt|;
name|dmae
operator|->
name|src_addr_lo
operator|=
name|sc
operator|->
name|func_stx
operator|>>
literal|2
expr_stmt|;
name|dmae
operator|->
name|src_addr_hi
operator|=
literal|0
expr_stmt|;
name|dmae
operator|->
name|dst_addr_lo
operator|=
name|U64_LO
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|func_stats_base
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|dst_addr_hi
operator|=
name|U64_HI
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|func_stats_base
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|host_func_stats
argument_list|)
operator|>>
literal|2
expr_stmt|;
name|dmae
operator|->
name|comp_addr_lo
operator|=
name|U64_LO
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|stats_comp
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|comp_addr_hi
operator|=
name|U64_HI
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|stats_comp
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|comp_val
operator|=
name|DMAE_COMP_VAL
expr_stmt|;
operator|*
name|stats_comp
operator|=
literal|0
expr_stmt|;
name|bxe_stats_hw_post
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_stats_comp
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_stats_func_base_update_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_STATS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize statistics.  *  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_stats_init
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|int
name|func
decl_stmt|,
name|i
decl_stmt|,
name|port
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_STATS
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|stats_enable
operator|==
name|FALSE
condition|)
goto|goto
name|bxe_stats_init_exit
goto|;
name|port
operator|=
name|BP_PORT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|func
operator|=
name|BP_FUNC
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|executer_idx
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|stats_counter
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|stats_pending
operator|=
literal|0
expr_stmt|;
comment|/* Fetch the offset of port& function statistics in shared memory. */
if|if
condition|(
name|NOMCP
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|sc
operator|->
name|port
operator|.
name|port_stx
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|func_stx
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|port
operator|.
name|port_stx
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|port_mb
index|[
name|port
index|]
operator|.
name|port_stx
argument_list|)
expr_stmt|;
name|sc
operator|->
name|func_stx
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|func_mb
index|[
name|func
index|]
operator|.
name|fw_mb_param
argument_list|)
expr_stmt|;
block|}
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_STATS
argument_list|,
literal|"%s(): sc->port.port_stx = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|port
operator|.
name|port_stx
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_STATS
argument_list|,
literal|"%s(): sc->func_stx = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|func_stx
argument_list|)
expr_stmt|;
comment|/* Port statistics. */
name|memset
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|port
operator|.
name|old_nig_stats
operator|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nig_stats
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|port
operator|.
name|old_nig_stats
operator|.
name|brb_discard
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_STAT0_BRB_DISCARD
operator|+
name|port
operator|*
literal|0x38
argument_list|)
expr_stmt|;
name|sc
operator|->
name|port
operator|.
name|old_nig_stats
operator|.
name|brb_truncate
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_STAT0_BRB_TRUNCATE
operator|+
name|port
operator|*
literal|0x38
argument_list|)
expr_stmt|;
name|REG_RD_DMAE
argument_list|(
name|sc
argument_list|,
name|NIG_REG_STAT0_EGRESS_MAC_PKT0
operator|+
name|port
operator|*
literal|0x50
argument_list|,
operator|&
operator|(
name|sc
operator|->
name|port
operator|.
name|old_nig_stats
operator|.
name|egress_mac_pkt0_lo
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|REG_RD_DMAE
argument_list|(
name|sc
argument_list|,
name|NIG_REG_STAT0_EGRESS_MAC_PKT1
operator|+
name|port
operator|*
literal|0x50
argument_list|,
operator|&
operator|(
name|sc
operator|->
name|port
operator|.
name|old_nig_stats
operator|.
name|egress_mac_pkt1_lo
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Function statistics. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
expr_stmt|;
comment|/* Clear all per-queue statistics. */
name|memset
argument_list|(
operator|&
name|fp
operator|->
name|old_tclient
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tstorm_per_client_stats
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|fp
operator|->
name|old_uclient
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ustorm_per_client_stats
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|fp
operator|->
name|old_xclient
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|xstorm_per_client_stats
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|fp
operator|->
name|eth_q_stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bxe_q_stats
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* ToDo: Clear any driver specific statistics? */
name|sc
operator|->
name|stats_state
operator|=
name|STATS_STATE_DISABLED
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|port
operator|.
name|pmf
operator|==
literal|1
condition|)
block|{
comment|/* Init port& function stats if we're PMF. */
if|if
condition|(
name|sc
operator|->
name|port
operator|.
name|port_stx
condition|)
name|bxe_stats_port_base_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|func_stx
condition|)
name|bxe_stats_func_base_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|func_stx
condition|)
comment|/* Update function stats if we're not PMF. */
name|bxe_stats_func_base_update
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_stats_init_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_STATS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_stats_hw_post
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|dmae_command
modifier|*
name|dmae
decl_stmt|;
name|uint32_t
modifier|*
name|stats_comp
decl_stmt|;
name|int
name|loader_idx
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_INSANE_STATS
argument_list|)
expr_stmt|;
name|dmae
operator|=
operator|&
name|sc
operator|->
name|stats_dmae
expr_stmt|;
name|stats_comp
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|stats_comp
argument_list|)
expr_stmt|;
operator|*
name|stats_comp
operator|=
name|DMAE_COMP_VAL
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|executer_idx
condition|)
block|{
name|loader_idx
operator|=
name|PMF_DMAE_C
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|dmae
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dmae_command
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|opcode
operator|=
operator|(
name|DMAE_CMD_SRC_PCI
operator||
name|DMAE_CMD_DST_GRC
operator||
name|DMAE_CMD_C_DST_GRC
operator||
name|DMAE_CMD_C_ENABLE
operator||
name|DMAE_CMD_DST_RESET
operator||
ifdef|#
directive|ifdef
name|__BIG_ENDIAN
name|DMAE_CMD_ENDIANITY_B_DW_SWAP
operator||
else|#
directive|else
name|DMAE_CMD_ENDIANITY_DW_SWAP
operator||
endif|#
directive|endif
operator|(
name|BP_PORT
argument_list|(
name|sc
argument_list|)
condition|?
name|DMAE_CMD_PORT_1
else|:
name|DMAE_CMD_PORT_0
operator|)
operator||
operator|(
name|BP_E1HVN
argument_list|(
name|sc
argument_list|)
operator|<<
name|DMAE_CMD_E1HVN_SHIFT
operator|)
operator|)
expr_stmt|;
name|dmae
operator|->
name|src_addr_lo
operator|=
name|U64_LO
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|dmae
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|src_addr_hi
operator|=
name|U64_HI
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|dmae
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|dst_addr_lo
operator|=
operator|(
name|DMAE_REG_CMD_MEM
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|dmae_command
argument_list|)
operator|*
operator|(
name|loader_idx
operator|+
literal|1
operator|)
operator|)
operator|>>
literal|2
expr_stmt|;
name|dmae
operator|->
name|dst_addr_hi
operator|=
literal|0
expr_stmt|;
name|dmae
operator|->
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dmae_command
argument_list|)
operator|>>
literal|2
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
name|dmae
operator|->
name|len
operator|--
expr_stmt|;
name|dmae
operator|->
name|comp_addr_lo
operator|=
name|dmae_reg_go_c
index|[
name|loader_idx
operator|+
literal|1
index|]
operator|>>
literal|2
expr_stmt|;
name|dmae
operator|->
name|comp_addr_hi
operator|=
literal|0
expr_stmt|;
name|dmae
operator|->
name|comp_val
operator|=
literal|1
expr_stmt|;
operator|*
name|stats_comp
operator|=
literal|0
expr_stmt|;
name|bxe_post_dmae
argument_list|(
name|sc
argument_list|,
name|dmae
argument_list|,
name|loader_idx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|func_stx
condition|)
block|{
operator|*
name|stats_comp
operator|=
literal|0
expr_stmt|;
name|bxe_post_dmae
argument_list|(
name|sc
argument_list|,
name|dmae
argument_list|,
name|INIT_DMAE_C
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DBEXIT
argument_list|(
name|BXE_INSANE_STATS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Delay routine which polls for the DMA engine to complete.  *  * Returns:  *   0 = Failure, !0 = Success  */
end_comment

begin_function
specifier|static
name|int
name|bxe_stats_comp
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
modifier|*
name|stats_comp
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_STATS
argument_list|)
expr_stmt|;
name|stats_comp
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|stats_comp
argument_list|)
expr_stmt|;
name|cnt
operator|=
literal|10
expr_stmt|;
while|while
condition|(
operator|*
name|stats_comp
operator|!=
name|DMAE_COMP_VAL
condition|)
block|{
if|if
condition|(
operator|!
name|cnt
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Timeout waiting for statistics "
literal|"completions.\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
break|break;
block|}
name|cnt
operator|--
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_STATS
argument_list|)
expr_stmt|;
comment|/* ToDo: Shouldn't this return the value of cnt? */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * DMA port statistcs from controller to driver.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_stats_pmf_update
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|dmae_command
modifier|*
name|dmae
decl_stmt|;
name|uint32_t
name|opcode
decl_stmt|,
modifier|*
name|stats_comp
decl_stmt|;
name|int
name|loader_idx
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_STATS
argument_list|)
expr_stmt|;
name|stats_comp
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|stats_comp
argument_list|)
expr_stmt|;
name|loader_idx
operator|=
name|PMF_DMAE_C
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* We shouldn't be here if any of the following are false. */
if|if
condition|(
operator|!
name|IS_E1HMF
argument_list|(
name|sc
argument_list|)
operator|||
operator|(
name|sc
operator|->
name|port
operator|.
name|pmf
operator|==
literal|0
operator|)
operator|||
operator|!
name|sc
operator|->
name|port
operator|.
name|port_stx
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Statistics bug!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
goto|goto
name|bxe_stats_pmf_update_exit
goto|;
block|}
name|sc
operator|->
name|executer_idx
operator|=
literal|0
expr_stmt|;
comment|/* Instruct DMA engine to copy port statistics from H/W to driver. */
name|opcode
operator|=
operator|(
name|DMAE_CMD_SRC_GRC
operator||
name|DMAE_CMD_DST_PCI
operator||
name|DMAE_CMD_C_DST_PCI
operator||
name|DMAE_CMD_C_ENABLE
operator||
name|DMAE_CMD_SRC_RESET
operator||
name|DMAE_CMD_DST_RESET
operator||
ifdef|#
directive|ifdef
name|__BIG_ENDIAN
name|DMAE_CMD_ENDIANITY_B_DW_SWAP
operator||
else|#
directive|else
name|DMAE_CMD_ENDIANITY_DW_SWAP
operator||
endif|#
directive|endif
operator|(
name|BP_PORT
argument_list|(
name|sc
argument_list|)
condition|?
name|DMAE_CMD_PORT_1
else|:
name|DMAE_CMD_PORT_0
operator|)
operator||
operator|(
name|BP_E1HVN
argument_list|(
name|sc
argument_list|)
operator|<<
name|DMAE_CMD_E1HVN_SHIFT
operator|)
operator|)
expr_stmt|;
name|dmae
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|dmae
index|[
name|sc
operator|->
name|executer_idx
operator|++
index|]
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|opcode
operator|=
operator|(
name|opcode
operator||
name|DMAE_CMD_C_DST_GRC
operator|)
expr_stmt|;
name|dmae
operator|->
name|src_addr_lo
operator|=
name|sc
operator|->
name|port
operator|.
name|port_stx
operator|>>
literal|2
expr_stmt|;
name|dmae
operator|->
name|src_addr_hi
operator|=
literal|0
expr_stmt|;
name|dmae
operator|->
name|dst_addr_lo
operator|=
name|U64_LO
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|port_stats
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|dst_addr_hi
operator|=
name|U64_HI
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|port_stats
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|len
operator|=
name|DMAE_LEN32_RD_MAX
expr_stmt|;
name|dmae
operator|->
name|comp_addr_lo
operator|=
name|dmae_reg_go_c
index|[
name|loader_idx
index|]
operator|>>
literal|2
expr_stmt|;
name|dmae
operator|->
name|comp_addr_hi
operator|=
literal|0
expr_stmt|;
name|dmae
operator|->
name|comp_val
operator|=
literal|1
expr_stmt|;
name|dmae
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|dmae
index|[
name|sc
operator|->
name|executer_idx
operator|++
index|]
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|opcode
operator|=
operator|(
name|opcode
operator||
name|DMAE_CMD_C_DST_PCI
operator|)
expr_stmt|;
name|dmae
operator|->
name|src_addr_lo
operator|=
operator|(
name|sc
operator|->
name|port
operator|.
name|port_stx
operator|>>
literal|2
operator|)
operator|+
name|DMAE_LEN32_RD_MAX
expr_stmt|;
name|dmae
operator|->
name|src_addr_hi
operator|=
literal|0
expr_stmt|;
name|dmae
operator|->
name|dst_addr_lo
operator|=
name|U64_LO
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|port_stats
argument_list|)
operator|+
name|DMAE_LEN32_RD_MAX
operator|*
literal|4
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|dst_addr_hi
operator|=
name|U64_HI
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|port_stats
argument_list|)
operator|+
name|DMAE_LEN32_RD_MAX
operator|*
literal|4
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|len
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|host_port_stats
argument_list|)
operator|>>
literal|2
operator|)
operator|-
name|DMAE_LEN32_RD_MAX
expr_stmt|;
name|dmae
operator|->
name|comp_addr_lo
operator|=
name|U64_LO
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|stats_comp
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|comp_addr_hi
operator|=
name|U64_HI
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|stats_comp
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|comp_val
operator|=
name|DMAE_COMP_VAL
expr_stmt|;
comment|/* Start the DMA and wait for the result. */
operator|*
name|stats_comp
operator|=
literal|0
expr_stmt|;
name|bxe_stats_hw_post
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_stats_comp
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_stats_pmf_update_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_STATS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Prepare the DMAE parameters required for all statistics.  *  * This function should only be called by the driver instance  * that is designated as the port management function (PMF).  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_stats_port_init
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|dmae_command
modifier|*
name|dmae
decl_stmt|;
name|uint32_t
name|mac_addr
decl_stmt|,
name|opcode
decl_stmt|,
modifier|*
name|stats_comp
decl_stmt|;
name|int
name|loader_idx
decl_stmt|,
name|port
decl_stmt|,
name|vn
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_STATS
argument_list|)
expr_stmt|;
name|port
operator|=
name|BP_PORT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vn
operator|=
name|BP_E1HVN
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|loader_idx
operator|=
name|PMF_DMAE_C
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|stats_comp
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|stats_comp
argument_list|)
expr_stmt|;
comment|/* Only the port management function (PMF) does this work. */
if|if
condition|(
operator|!
name|sc
operator|->
name|link_vars
operator|.
name|link_up
operator|||
operator|(
name|sc
operator|->
name|port
operator|.
name|pmf
operator|==
literal|0
operator|)
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Invalid statistics port setup!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
goto|goto
name|bxe_stats_port_init_exit
goto|;
block|}
name|sc
operator|->
name|executer_idx
operator|=
literal|0
expr_stmt|;
comment|/* The same opcde is used for multiple DMA operations. */
name|opcode
operator|=
operator|(
name|DMAE_CMD_SRC_PCI
operator||
name|DMAE_CMD_DST_GRC
operator||
name|DMAE_CMD_C_DST_GRC
operator||
name|DMAE_CMD_C_ENABLE
operator||
name|DMAE_CMD_SRC_RESET
operator||
name|DMAE_CMD_DST_RESET
operator||
ifdef|#
directive|ifdef
name|__BIG_ENDIAN
name|DMAE_CMD_ENDIANITY_B_DW_SWAP
operator||
else|#
directive|else
name|DMAE_CMD_ENDIANITY_DW_SWAP
operator||
endif|#
directive|endif
operator|(
name|port
condition|?
name|DMAE_CMD_PORT_1
else|:
name|DMAE_CMD_PORT_0
operator|)
operator||
operator|(
name|vn
operator|<<
name|DMAE_CMD_E1HVN_SHIFT
operator|)
operator|)
expr_stmt|;
comment|/* Setup the DMA for port statistics. */
if|if
condition|(
name|sc
operator|->
name|port
operator|.
name|port_stx
condition|)
block|{
name|dmae
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|dmae
index|[
name|sc
operator|->
name|executer_idx
operator|++
index|]
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|opcode
operator|=
name|opcode
expr_stmt|;
name|dmae
operator|->
name|src_addr_lo
operator|=
name|U64_LO
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|port_stats
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|src_addr_hi
operator|=
name|U64_HI
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|port_stats
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|dst_addr_lo
operator|=
name|sc
operator|->
name|port
operator|.
name|port_stx
operator|>>
literal|2
expr_stmt|;
name|dmae
operator|->
name|dst_addr_hi
operator|=
literal|0
expr_stmt|;
name|dmae
operator|->
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|host_port_stats
argument_list|)
operator|>>
literal|2
expr_stmt|;
name|dmae
operator|->
name|comp_addr_lo
operator|=
name|dmae_reg_go_c
index|[
name|loader_idx
index|]
operator|>>
literal|2
expr_stmt|;
name|dmae
operator|->
name|comp_addr_hi
operator|=
literal|0
expr_stmt|;
name|dmae
operator|->
name|comp_val
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Setup the DMA for function statistics. */
if|if
condition|(
name|sc
operator|->
name|func_stx
condition|)
block|{
name|dmae
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|dmae
index|[
name|sc
operator|->
name|executer_idx
operator|++
index|]
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|opcode
operator|=
name|opcode
expr_stmt|;
name|dmae
operator|->
name|src_addr_lo
operator|=
name|U64_LO
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|func_stats
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|src_addr_hi
operator|=
name|U64_HI
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|func_stats
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|dst_addr_lo
operator|=
name|sc
operator|->
name|func_stx
operator|>>
literal|2
expr_stmt|;
name|dmae
operator|->
name|dst_addr_hi
operator|=
literal|0
expr_stmt|;
name|dmae
operator|->
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|host_func_stats
argument_list|)
operator|>>
literal|2
expr_stmt|;
name|dmae
operator|->
name|comp_addr_lo
operator|=
name|dmae_reg_go_c
index|[
name|loader_idx
index|]
operator|>>
literal|2
expr_stmt|;
name|dmae
operator|->
name|comp_addr_hi
operator|=
literal|0
expr_stmt|;
name|dmae
operator|->
name|comp_val
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Setup statistics reporting for the MAC. */
name|opcode
operator|=
operator|(
name|DMAE_CMD_SRC_GRC
operator||
name|DMAE_CMD_DST_PCI
operator||
name|DMAE_CMD_C_DST_GRC
operator||
name|DMAE_CMD_C_ENABLE
operator||
name|DMAE_CMD_SRC_RESET
operator||
name|DMAE_CMD_DST_RESET
operator||
ifdef|#
directive|ifdef
name|__BIG_ENDIAN
name|DMAE_CMD_ENDIANITY_B_DW_SWAP
operator||
else|#
directive|else
name|DMAE_CMD_ENDIANITY_DW_SWAP
operator||
endif|#
directive|endif
operator|(
name|port
condition|?
name|DMAE_CMD_PORT_1
else|:
name|DMAE_CMD_PORT_0
operator|)
operator||
operator|(
name|vn
operator|<<
name|DMAE_CMD_E1HVN_SHIFT
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|link_vars
operator|.
name|mac_type
operator|==
name|MAC_TYPE_BMAC
condition|)
block|{
comment|/* Enable statistics for the 10Gb BMAC. */
name|mac_addr
operator|=
operator|(
name|port
condition|?
name|NIG_REG_INGRESS_BMAC1_MEM
else|:
name|NIG_REG_INGRESS_BMAC0_MEM
operator|)
expr_stmt|;
comment|/* Setup BMAC TX statistics (TX_STAT_GTPKT .. TX_STAT_GTBYT). */
name|dmae
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|dmae
index|[
name|sc
operator|->
name|executer_idx
operator|++
index|]
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|opcode
operator|=
name|opcode
expr_stmt|;
name|dmae
operator|->
name|src_addr_lo
operator|=
operator|(
name|mac_addr
operator|+
name|BIGMAC_REGISTER_TX_STAT_GTPKT
operator|)
operator|>>
literal|2
expr_stmt|;
name|dmae
operator|->
name|src_addr_hi
operator|=
literal|0
expr_stmt|;
name|dmae
operator|->
name|dst_addr_lo
operator|=
name|U64_LO
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|mac_stats
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|dst_addr_hi
operator|=
name|U64_HI
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|mac_stats
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|len
operator|=
operator|(
literal|8
operator|+
name|BIGMAC_REGISTER_TX_STAT_GTBYT
operator|-
name|BIGMAC_REGISTER_TX_STAT_GTPKT
operator|)
operator|>>
literal|2
expr_stmt|;
name|dmae
operator|->
name|comp_addr_lo
operator|=
name|dmae_reg_go_c
index|[
name|loader_idx
index|]
operator|>>
literal|2
expr_stmt|;
name|dmae
operator|->
name|comp_addr_hi
operator|=
literal|0
expr_stmt|;
name|dmae
operator|->
name|comp_val
operator|=
literal|1
expr_stmt|;
comment|/* Setup BMAC RX statistcs (RX_STAT_GR64 .. RX_STAT_GRIPJ). */
name|dmae
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|dmae
index|[
name|sc
operator|->
name|executer_idx
operator|++
index|]
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|opcode
operator|=
name|opcode
expr_stmt|;
name|dmae
operator|->
name|src_addr_lo
operator|=
operator|(
name|mac_addr
operator|+
name|BIGMAC_REGISTER_RX_STAT_GR64
operator|)
operator|>>
literal|2
expr_stmt|;
name|dmae
operator|->
name|src_addr_hi
operator|=
literal|0
expr_stmt|;
name|dmae
operator|->
name|dst_addr_lo
operator|=
name|U64_LO
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|mac_stats
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|bmac_stats
argument_list|,
name|rx_stat_gr64_lo
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|dst_addr_hi
operator|=
name|U64_HI
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|mac_stats
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|bmac_stats
argument_list|,
name|rx_stat_gr64_lo
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|len
operator|=
operator|(
literal|8
operator|+
name|BIGMAC_REGISTER_RX_STAT_GRIPJ
operator|-
name|BIGMAC_REGISTER_RX_STAT_GR64
operator|)
operator|>>
literal|2
expr_stmt|;
name|dmae
operator|->
name|comp_addr_lo
operator|=
name|dmae_reg_go_c
index|[
name|loader_idx
index|]
operator|>>
literal|2
expr_stmt|;
name|dmae
operator|->
name|comp_addr_hi
operator|=
literal|0
expr_stmt|;
name|dmae
operator|->
name|comp_val
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|link_vars
operator|.
name|mac_type
operator|==
name|MAC_TYPE_EMAC
condition|)
block|{
comment|/* Enable statistics for the 1Gb EMAC. */
name|mac_addr
operator|=
operator|(
name|port
condition|?
name|GRCBASE_EMAC1
else|:
name|GRCBASE_EMAC0
operator|)
expr_stmt|;
comment|/* Setup EMAC RX statistics. */
name|dmae
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|dmae
index|[
name|sc
operator|->
name|executer_idx
operator|++
index|]
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|opcode
operator|=
name|opcode
expr_stmt|;
name|dmae
operator|->
name|src_addr_lo
operator|=
operator|(
name|mac_addr
operator|+
name|EMAC_REG_EMAC_RX_STAT_AC
operator|)
operator|>>
literal|2
expr_stmt|;
name|dmae
operator|->
name|src_addr_hi
operator|=
literal|0
expr_stmt|;
name|dmae
operator|->
name|dst_addr_lo
operator|=
name|U64_LO
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|mac_stats
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|dst_addr_hi
operator|=
name|U64_HI
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|mac_stats
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|len
operator|=
name|EMAC_REG_EMAC_RX_STAT_AC_COUNT
expr_stmt|;
name|dmae
operator|->
name|comp_addr_lo
operator|=
name|dmae_reg_go_c
index|[
name|loader_idx
index|]
operator|>>
literal|2
expr_stmt|;
name|dmae
operator|->
name|comp_addr_hi
operator|=
literal|0
expr_stmt|;
name|dmae
operator|->
name|comp_val
operator|=
literal|1
expr_stmt|;
comment|/* Setup additional EMAC RX statistics. */
name|dmae
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|dmae
index|[
name|sc
operator|->
name|executer_idx
operator|++
index|]
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|opcode
operator|=
name|opcode
expr_stmt|;
name|dmae
operator|->
name|src_addr_lo
operator|=
operator|(
name|mac_addr
operator|+
name|EMAC_REG_EMAC_RX_STAT_AC_28
operator|)
operator|>>
literal|2
expr_stmt|;
name|dmae
operator|->
name|src_addr_hi
operator|=
literal|0
expr_stmt|;
name|dmae
operator|->
name|dst_addr_lo
operator|=
name|U64_LO
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|mac_stats
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|emac_stats
argument_list|,
name|rx_stat_falsecarriererrors
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|dst_addr_hi
operator|=
name|U64_HI
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|mac_stats
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|emac_stats
argument_list|,
name|rx_stat_falsecarriererrors
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|len
operator|=
literal|1
expr_stmt|;
name|dmae
operator|->
name|comp_addr_lo
operator|=
name|dmae_reg_go_c
index|[
name|loader_idx
index|]
operator|>>
literal|2
expr_stmt|;
name|dmae
operator|->
name|comp_addr_hi
operator|=
literal|0
expr_stmt|;
name|dmae
operator|->
name|comp_val
operator|=
literal|1
expr_stmt|;
comment|/* Setup EMAC TX statistics. */
name|dmae
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|dmae
index|[
name|sc
operator|->
name|executer_idx
operator|++
index|]
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|opcode
operator|=
name|opcode
expr_stmt|;
name|dmae
operator|->
name|src_addr_lo
operator|=
operator|(
name|mac_addr
operator|+
name|EMAC_REG_EMAC_TX_STAT_AC
operator|)
operator|>>
literal|2
expr_stmt|;
name|dmae
operator|->
name|src_addr_hi
operator|=
literal|0
expr_stmt|;
name|dmae
operator|->
name|dst_addr_lo
operator|=
name|U64_LO
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|mac_stats
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|emac_stats
argument_list|,
name|tx_stat_ifhcoutoctets
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|dst_addr_hi
operator|=
name|U64_HI
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|mac_stats
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|emac_stats
argument_list|,
name|tx_stat_ifhcoutoctets
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|len
operator|=
name|EMAC_REG_EMAC_TX_STAT_AC_COUNT
expr_stmt|;
name|dmae
operator|->
name|comp_addr_lo
operator|=
name|dmae_reg_go_c
index|[
name|loader_idx
index|]
operator|>>
literal|2
expr_stmt|;
name|dmae
operator|->
name|comp_addr_hi
operator|=
literal|0
expr_stmt|;
name|dmae
operator|->
name|comp_val
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): Undefined MAC type.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
comment|/* Enable NIG statistics. */
name|dmae
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|dmae
index|[
name|sc
operator|->
name|executer_idx
operator|++
index|]
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|opcode
operator|=
name|opcode
expr_stmt|;
name|dmae
operator|->
name|src_addr_lo
operator|=
operator|(
name|port
condition|?
name|NIG_REG_STAT1_BRB_DISCARD
else|:
name|NIG_REG_STAT0_BRB_DISCARD
operator|)
operator|>>
literal|2
expr_stmt|;
name|dmae
operator|->
name|src_addr_hi
operator|=
literal|0
expr_stmt|;
name|dmae
operator|->
name|dst_addr_lo
operator|=
name|U64_LO
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|nig_stats
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|dst_addr_hi
operator|=
name|U64_HI
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|nig_stats
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|len
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|nig_stats
argument_list|)
operator|-
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
operator|>>
literal|2
expr_stmt|;
name|dmae
operator|->
name|comp_addr_lo
operator|=
name|dmae_reg_go_c
index|[
name|loader_idx
index|]
operator|>>
literal|2
expr_stmt|;
name|dmae
operator|->
name|comp_addr_hi
operator|=
literal|0
expr_stmt|;
name|dmae
operator|->
name|comp_val
operator|=
literal|1
expr_stmt|;
name|dmae
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|dmae
index|[
name|sc
operator|->
name|executer_idx
operator|++
index|]
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|opcode
operator|=
name|opcode
expr_stmt|;
name|dmae
operator|->
name|src_addr_lo
operator|=
operator|(
name|port
condition|?
name|NIG_REG_STAT1_EGRESS_MAC_PKT0
else|:
name|NIG_REG_STAT0_EGRESS_MAC_PKT0
operator|)
operator|>>
literal|2
expr_stmt|;
name|dmae
operator|->
name|src_addr_hi
operator|=
literal|0
expr_stmt|;
name|dmae
operator|->
name|dst_addr_lo
operator|=
name|U64_LO
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|nig_stats
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|nig_stats
argument_list|,
name|egress_mac_pkt0_lo
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|dst_addr_hi
operator|=
name|U64_HI
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|nig_stats
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|nig_stats
argument_list|,
name|egress_mac_pkt0_lo
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|len
operator|=
operator|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
operator|>>
literal|2
expr_stmt|;
name|dmae
operator|->
name|comp_addr_lo
operator|=
name|dmae_reg_go_c
index|[
name|loader_idx
index|]
operator|>>
literal|2
expr_stmt|;
name|dmae
operator|->
name|comp_addr_hi
operator|=
literal|0
expr_stmt|;
name|dmae
operator|->
name|comp_val
operator|=
literal|1
expr_stmt|;
name|dmae
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|dmae
index|[
name|sc
operator|->
name|executer_idx
operator|++
index|]
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|opcode
operator|=
operator|(
name|DMAE_CMD_SRC_GRC
operator||
name|DMAE_CMD_DST_PCI
operator||
name|DMAE_CMD_C_DST_PCI
operator||
name|DMAE_CMD_C_ENABLE
operator||
name|DMAE_CMD_SRC_RESET
operator||
name|DMAE_CMD_DST_RESET
operator||
ifdef|#
directive|ifdef
name|__BIG_ENDIAN
name|DMAE_CMD_ENDIANITY_B_DW_SWAP
operator||
else|#
directive|else
name|DMAE_CMD_ENDIANITY_DW_SWAP
operator||
endif|#
directive|endif
operator|(
name|port
condition|?
name|DMAE_CMD_PORT_1
else|:
name|DMAE_CMD_PORT_0
operator|)
operator||
operator|(
name|vn
operator|<<
name|DMAE_CMD_E1HVN_SHIFT
operator|)
operator|)
expr_stmt|;
name|dmae
operator|->
name|src_addr_lo
operator|=
operator|(
name|port
condition|?
name|NIG_REG_STAT1_EGRESS_MAC_PKT1
else|:
name|NIG_REG_STAT0_EGRESS_MAC_PKT1
operator|)
operator|>>
literal|2
expr_stmt|;
name|dmae
operator|->
name|src_addr_hi
operator|=
literal|0
expr_stmt|;
name|dmae
operator|->
name|dst_addr_lo
operator|=
name|U64_LO
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|nig_stats
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|nig_stats
argument_list|,
name|egress_mac_pkt1_lo
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|dst_addr_hi
operator|=
name|U64_HI
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|nig_stats
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|nig_stats
argument_list|,
name|egress_mac_pkt1_lo
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|len
operator|=
operator|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
operator|>>
literal|2
expr_stmt|;
name|dmae
operator|->
name|comp_addr_lo
operator|=
name|U64_LO
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|stats_comp
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|comp_addr_hi
operator|=
name|U64_HI
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|stats_comp
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|comp_val
operator|=
name|DMAE_COMP_VAL
expr_stmt|;
comment|/* Clear the statistics completion value. */
operator|*
name|stats_comp
operator|=
literal|0
expr_stmt|;
name|bxe_stats_port_init_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_STATS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Prepare the DMAE parameters required for function statistics.  *  * This function is called by all driver instances.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_stats_func_init
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|dmae_command
modifier|*
name|dmae
decl_stmt|;
name|uint32_t
modifier|*
name|stats_comp
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_STATS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|func_stx
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Invalid statistics function setup!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
goto|goto
name|bxe_stats_func_init_exit
goto|;
block|}
name|dmae
operator|=
operator|&
name|sc
operator|->
name|stats_dmae
expr_stmt|;
name|stats_comp
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|stats_comp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|executer_idx
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|dmae
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dmae_command
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Setup the DMA for function statistics. */
name|dmae
operator|->
name|opcode
operator|=
operator|(
name|DMAE_CMD_SRC_PCI
operator||
name|DMAE_CMD_DST_GRC
operator||
name|DMAE_CMD_C_DST_PCI
operator||
name|DMAE_CMD_C_ENABLE
operator||
name|DMAE_CMD_SRC_RESET
operator||
name|DMAE_CMD_DST_RESET
operator||
ifdef|#
directive|ifdef
name|__BIG_ENDIAN
name|DMAE_CMD_ENDIANITY_B_DW_SWAP
operator||
else|#
directive|else
name|DMAE_CMD_ENDIANITY_DW_SWAP
operator||
endif|#
directive|endif
operator|(
name|BP_PORT
argument_list|(
name|sc
argument_list|)
condition|?
name|DMAE_CMD_PORT_1
else|:
name|DMAE_CMD_PORT_0
operator|)
operator||
operator|(
name|BP_E1HVN
argument_list|(
name|sc
argument_list|)
operator|<<
name|DMAE_CMD_E1HVN_SHIFT
operator|)
operator|)
expr_stmt|;
name|dmae
operator|->
name|src_addr_lo
operator|=
name|U64_LO
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|func_stats
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|src_addr_hi
operator|=
name|U64_HI
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|func_stats
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|dst_addr_lo
operator|=
name|sc
operator|->
name|func_stx
operator|>>
literal|2
expr_stmt|;
name|dmae
operator|->
name|dst_addr_hi
operator|=
literal|0
expr_stmt|;
name|dmae
operator|->
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|host_func_stats
argument_list|)
operator|>>
literal|2
expr_stmt|;
name|dmae
operator|->
name|comp_addr_lo
operator|=
name|U64_LO
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|stats_comp
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|comp_addr_hi
operator|=
name|U64_HI
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|stats_comp
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|comp_val
operator|=
name|DMAE_COMP_VAL
expr_stmt|;
operator|*
name|stats_comp
operator|=
literal|0
expr_stmt|;
name|bxe_stats_func_init_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_STATS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Starts a statistics update DMA and waits for completion.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_stats_start
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|DBENTER
argument_list|(
name|BXE_VERBOSE_STATS
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|port
operator|.
name|pmf
operator|==
literal|1
condition|)
name|bxe_stats_port_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|func_stx
condition|)
name|bxe_stats_func_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_stats_hw_post
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_stats_storm_post
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_STATS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_stats_pmf_start
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|DBENTER
argument_list|(
name|BXE_VERBOSE_STATS
argument_list|)
expr_stmt|;
name|bxe_stats_comp
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_stats_pmf_update
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_stats_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_STATS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_stats_restart
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|DBENTER
argument_list|(
name|BXE_VERBOSE_STATS
argument_list|)
expr_stmt|;
name|bxe_stats_comp
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_stats_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_STATS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update the Big MAC (10Gb BMAC) statistics.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_stats_bmac_update
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bmac_stats
modifier|*
name|new
decl_stmt|;
name|struct
name|host_port_stats
modifier|*
name|pstats
decl_stmt|;
name|struct
name|bxe_port_stats
modifier|*
name|estats
decl_stmt|;
name|struct
name|regpair
name|diff
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_INSANE_STATS
argument_list|)
expr_stmt|;
name|new
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|mac_stats
operator|.
name|bmac_stats
argument_list|)
expr_stmt|;
name|pstats
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|port_stats
argument_list|)
expr_stmt|;
name|estats
operator|=
operator|&
name|sc
operator|->
name|eth_stats
expr_stmt|;
name|UPDATE_STAT64
argument_list|(
name|rx_stat_grerb
argument_list|,
name|rx_stat_ifhcinbadoctets
argument_list|)
expr_stmt|;
name|UPDATE_STAT64
argument_list|(
name|rx_stat_grfcs
argument_list|,
name|rx_stat_dot3statsfcserrors
argument_list|)
expr_stmt|;
name|UPDATE_STAT64
argument_list|(
name|rx_stat_grund
argument_list|,
name|rx_stat_etherstatsundersizepkts
argument_list|)
expr_stmt|;
name|UPDATE_STAT64
argument_list|(
name|rx_stat_grovr
argument_list|,
name|rx_stat_dot3statsframestoolong
argument_list|)
expr_stmt|;
name|UPDATE_STAT64
argument_list|(
name|rx_stat_grfrg
argument_list|,
name|rx_stat_etherstatsfragments
argument_list|)
expr_stmt|;
name|UPDATE_STAT64
argument_list|(
name|rx_stat_grjbr
argument_list|,
name|rx_stat_etherstatsjabbers
argument_list|)
expr_stmt|;
name|UPDATE_STAT64
argument_list|(
name|rx_stat_grxcf
argument_list|,
name|rx_stat_maccontrolframesreceived
argument_list|)
expr_stmt|;
name|UPDATE_STAT64
argument_list|(
name|rx_stat_grxpf
argument_list|,
name|rx_stat_xoffstateentered
argument_list|)
expr_stmt|;
name|UPDATE_STAT64
argument_list|(
name|rx_stat_grxpf
argument_list|,
name|rx_stat_bmac_xpf
argument_list|)
expr_stmt|;
name|UPDATE_STAT64
argument_list|(
name|tx_stat_gtxpf
argument_list|,
name|tx_stat_outxoffsent
argument_list|)
expr_stmt|;
name|UPDATE_STAT64
argument_list|(
name|tx_stat_gtxpf
argument_list|,
name|tx_stat_flowcontroldone
argument_list|)
expr_stmt|;
name|UPDATE_STAT64
argument_list|(
name|tx_stat_gt64
argument_list|,
name|tx_stat_etherstatspkts64octets
argument_list|)
expr_stmt|;
name|UPDATE_STAT64
argument_list|(
name|tx_stat_gt127
argument_list|,
name|tx_stat_etherstatspkts65octetsto127octets
argument_list|)
expr_stmt|;
name|UPDATE_STAT64
argument_list|(
name|tx_stat_gt255
argument_list|,
name|tx_stat_etherstatspkts128octetsto255octets
argument_list|)
expr_stmt|;
name|UPDATE_STAT64
argument_list|(
name|tx_stat_gt511
argument_list|,
name|tx_stat_etherstatspkts256octetsto511octets
argument_list|)
expr_stmt|;
name|UPDATE_STAT64
argument_list|(
name|tx_stat_gt1023
argument_list|,
name|tx_stat_etherstatspkts512octetsto1023octets
argument_list|)
expr_stmt|;
name|UPDATE_STAT64
argument_list|(
name|tx_stat_gt1518
argument_list|,
name|tx_stat_etherstatspkts1024octetsto1522octets
argument_list|)
expr_stmt|;
name|UPDATE_STAT64
argument_list|(
name|tx_stat_gt2047
argument_list|,
name|tx_stat_bmac_2047
argument_list|)
expr_stmt|;
name|UPDATE_STAT64
argument_list|(
name|tx_stat_gt4095
argument_list|,
name|tx_stat_bmac_4095
argument_list|)
expr_stmt|;
name|UPDATE_STAT64
argument_list|(
name|tx_stat_gt9216
argument_list|,
name|tx_stat_bmac_9216
argument_list|)
expr_stmt|;
name|UPDATE_STAT64
argument_list|(
name|tx_stat_gt16383
argument_list|,
name|tx_stat_bmac_16383
argument_list|)
expr_stmt|;
name|UPDATE_STAT64
argument_list|(
name|tx_stat_gterr
argument_list|,
name|tx_stat_dot3statsinternalmactransmiterrors
argument_list|)
expr_stmt|;
name|UPDATE_STAT64
argument_list|(
name|tx_stat_gtufl
argument_list|,
name|tx_stat_bmac_ufl
argument_list|)
expr_stmt|;
name|estats
operator|->
name|pause_frames_received_hi
operator|=
name|pstats
operator|->
name|mac_stx
index|[
literal|1
index|]
operator|.
name|rx_stat_bmac_xpf_hi
expr_stmt|;
name|estats
operator|->
name|pause_frames_received_lo
operator|=
name|pstats
operator|->
name|mac_stx
index|[
literal|1
index|]
operator|.
name|rx_stat_bmac_xpf_lo
expr_stmt|;
name|estats
operator|->
name|pause_frames_sent_hi
operator|=
name|pstats
operator|->
name|mac_stx
index|[
literal|1
index|]
operator|.
name|tx_stat_outxoffsent_hi
expr_stmt|;
name|estats
operator|->
name|pause_frames_sent_lo
operator|=
name|pstats
operator|->
name|mac_stx
index|[
literal|1
index|]
operator|.
name|tx_stat_outxoffsent_lo
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_INSANE_STATS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update the Ethernet MAC (1Gb EMAC) statistics.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_stats_emac_update
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|emac_stats
modifier|*
name|new
decl_stmt|;
name|struct
name|host_port_stats
modifier|*
name|pstats
decl_stmt|;
name|struct
name|bxe_port_stats
modifier|*
name|estats
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_INSANE_STATS
argument_list|)
expr_stmt|;
name|new
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|mac_stats
operator|.
name|emac_stats
argument_list|)
expr_stmt|;
name|pstats
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|port_stats
argument_list|)
expr_stmt|;
name|estats
operator|=
operator|&
name|sc
operator|->
name|eth_stats
expr_stmt|;
name|UPDATE_EXTEND_STAT
argument_list|(
name|rx_stat_ifhcinbadoctets
argument_list|)
expr_stmt|;
name|UPDATE_EXTEND_STAT
argument_list|(
name|tx_stat_ifhcoutbadoctets
argument_list|)
expr_stmt|;
name|UPDATE_EXTEND_STAT
argument_list|(
name|rx_stat_dot3statsfcserrors
argument_list|)
expr_stmt|;
name|UPDATE_EXTEND_STAT
argument_list|(
name|rx_stat_dot3statsalignmenterrors
argument_list|)
expr_stmt|;
name|UPDATE_EXTEND_STAT
argument_list|(
name|rx_stat_dot3statscarriersenseerrors
argument_list|)
expr_stmt|;
name|UPDATE_EXTEND_STAT
argument_list|(
name|rx_stat_falsecarriererrors
argument_list|)
expr_stmt|;
name|UPDATE_EXTEND_STAT
argument_list|(
name|rx_stat_etherstatsundersizepkts
argument_list|)
expr_stmt|;
name|UPDATE_EXTEND_STAT
argument_list|(
name|rx_stat_dot3statsframestoolong
argument_list|)
expr_stmt|;
name|UPDATE_EXTEND_STAT
argument_list|(
name|rx_stat_etherstatsfragments
argument_list|)
expr_stmt|;
name|UPDATE_EXTEND_STAT
argument_list|(
name|rx_stat_etherstatsjabbers
argument_list|)
expr_stmt|;
name|UPDATE_EXTEND_STAT
argument_list|(
name|rx_stat_maccontrolframesreceived
argument_list|)
expr_stmt|;
name|UPDATE_EXTEND_STAT
argument_list|(
name|rx_stat_xoffstateentered
argument_list|)
expr_stmt|;
name|UPDATE_EXTEND_STAT
argument_list|(
name|rx_stat_xonpauseframesreceived
argument_list|)
expr_stmt|;
name|UPDATE_EXTEND_STAT
argument_list|(
name|rx_stat_xoffpauseframesreceived
argument_list|)
expr_stmt|;
name|UPDATE_EXTEND_STAT
argument_list|(
name|tx_stat_outxonsent
argument_list|)
expr_stmt|;
name|UPDATE_EXTEND_STAT
argument_list|(
name|tx_stat_outxoffsent
argument_list|)
expr_stmt|;
name|UPDATE_EXTEND_STAT
argument_list|(
name|tx_stat_flowcontroldone
argument_list|)
expr_stmt|;
name|UPDATE_EXTEND_STAT
argument_list|(
name|tx_stat_etherstatscollisions
argument_list|)
expr_stmt|;
name|UPDATE_EXTEND_STAT
argument_list|(
name|tx_stat_dot3statssinglecollisionframes
argument_list|)
expr_stmt|;
name|UPDATE_EXTEND_STAT
argument_list|(
name|tx_stat_dot3statsmultiplecollisionframes
argument_list|)
expr_stmt|;
name|UPDATE_EXTEND_STAT
argument_list|(
name|tx_stat_dot3statsdeferredtransmissions
argument_list|)
expr_stmt|;
name|UPDATE_EXTEND_STAT
argument_list|(
name|tx_stat_dot3statsexcessivecollisions
argument_list|)
expr_stmt|;
name|UPDATE_EXTEND_STAT
argument_list|(
name|tx_stat_dot3statslatecollisions
argument_list|)
expr_stmt|;
name|UPDATE_EXTEND_STAT
argument_list|(
name|tx_stat_etherstatspkts64octets
argument_list|)
expr_stmt|;
name|UPDATE_EXTEND_STAT
argument_list|(
name|tx_stat_etherstatspkts65octetsto127octets
argument_list|)
expr_stmt|;
name|UPDATE_EXTEND_STAT
argument_list|(
name|tx_stat_etherstatspkts128octetsto255octets
argument_list|)
expr_stmt|;
name|UPDATE_EXTEND_STAT
argument_list|(
name|tx_stat_etherstatspkts256octetsto511octets
argument_list|)
expr_stmt|;
name|UPDATE_EXTEND_STAT
argument_list|(
name|tx_stat_etherstatspkts512octetsto1023octets
argument_list|)
expr_stmt|;
name|UPDATE_EXTEND_STAT
argument_list|(
name|tx_stat_etherstatspkts1024octetsto1522octets
argument_list|)
expr_stmt|;
name|UPDATE_EXTEND_STAT
argument_list|(
name|tx_stat_etherstatspktsover1522octets
argument_list|)
expr_stmt|;
name|UPDATE_EXTEND_STAT
argument_list|(
name|tx_stat_dot3statsinternalmactransmiterrors
argument_list|)
expr_stmt|;
name|estats
operator|->
name|pause_frames_received_hi
operator|=
name|pstats
operator|->
name|mac_stx
index|[
literal|1
index|]
operator|.
name|rx_stat_xonpauseframesreceived_hi
expr_stmt|;
name|estats
operator|->
name|pause_frames_received_lo
operator|=
name|pstats
operator|->
name|mac_stx
index|[
literal|1
index|]
operator|.
name|rx_stat_xonpauseframesreceived_lo
expr_stmt|;
name|ADD_64
argument_list|(
name|estats
operator|->
name|pause_frames_received_hi
argument_list|,
name|pstats
operator|->
name|mac_stx
index|[
literal|1
index|]
operator|.
name|rx_stat_xoffpauseframesreceived_hi
argument_list|,
name|estats
operator|->
name|pause_frames_received_lo
argument_list|,
name|pstats
operator|->
name|mac_stx
index|[
literal|1
index|]
operator|.
name|rx_stat_xoffpauseframesreceived_lo
argument_list|)
expr_stmt|;
name|estats
operator|->
name|pause_frames_sent_hi
operator|=
name|pstats
operator|->
name|mac_stx
index|[
literal|1
index|]
operator|.
name|tx_stat_outxonsent_hi
expr_stmt|;
name|estats
operator|->
name|pause_frames_sent_lo
operator|=
name|pstats
operator|->
name|mac_stx
index|[
literal|1
index|]
operator|.
name|tx_stat_outxonsent_lo
expr_stmt|;
name|ADD_64
argument_list|(
name|estats
operator|->
name|pause_frames_sent_hi
argument_list|,
name|pstats
operator|->
name|mac_stx
index|[
literal|1
index|]
operator|.
name|tx_stat_outxoffsent_hi
argument_list|,
name|estats
operator|->
name|pause_frames_sent_lo
argument_list|,
name|pstats
operator|->
name|mac_stx
index|[
literal|1
index|]
operator|.
name|tx_stat_outxoffsent_lo
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_INSANE_STATS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns:  *   0 = Success, !0 = Failure.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_stats_hw_update
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|nig_stats
modifier|*
name|new
decl_stmt|,
modifier|*
name|old
decl_stmt|;
name|struct
name|host_port_stats
modifier|*
name|pstats
decl_stmt|;
name|struct
name|bxe_port_stats
modifier|*
name|estats
decl_stmt|;
name|struct
name|regpair
name|diff
decl_stmt|;
name|uint32_t
name|nig_timer_max
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_INSANE_STATS
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
name|new
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|nig_stats
argument_list|)
expr_stmt|;
name|old
operator|=
operator|&
operator|(
name|sc
operator|->
name|port
operator|.
name|old_nig_stats
operator|)
expr_stmt|;
name|pstats
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|port_stats
argument_list|)
expr_stmt|;
name|estats
operator|=
operator|&
name|sc
operator|->
name|eth_stats
expr_stmt|;
comment|/* Update statistics for the active MAC. */
if|if
condition|(
name|sc
operator|->
name|link_vars
operator|.
name|mac_type
operator|==
name|MAC_TYPE_BMAC
condition|)
name|bxe_stats_bmac_update
argument_list|(
name|sc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|link_vars
operator|.
name|mac_type
operator|==
name|MAC_TYPE_EMAC
condition|)
name|bxe_stats_emac_update
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): Statistics updated by DMAE but no MAC is active!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bxe_stats_hw_update_exit
goto|;
block|}
comment|/* Now update the hardware (NIG) statistics. */
name|ADD_EXTEND_64
argument_list|(
name|pstats
operator|->
name|brb_drop_hi
argument_list|,
name|pstats
operator|->
name|brb_drop_lo
argument_list|,
name|new
operator|->
name|brb_discard
operator|-
name|old
operator|->
name|brb_discard
argument_list|)
expr_stmt|;
name|ADD_EXTEND_64
argument_list|(
name|estats
operator|->
name|brb_truncate_hi
argument_list|,
name|estats
operator|->
name|brb_truncate_lo
argument_list|,
name|new
operator|->
name|brb_truncate
operator|-
name|old
operator|->
name|brb_truncate
argument_list|)
expr_stmt|;
name|UPDATE_STAT64_NIG
argument_list|(
name|egress_mac_pkt0
argument_list|,
name|etherstatspkts1024octetsto1522octets
argument_list|)
expr_stmt|;
name|UPDATE_STAT64_NIG
argument_list|(
name|egress_mac_pkt1
argument_list|,
name|etherstatspktsover1522octets
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|old
argument_list|,
name|new
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nig_stats
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
operator|(
name|estats
operator|->
name|rx_stat_ifhcinbadoctets_hi
operator|)
argument_list|,
operator|&
operator|(
name|pstats
operator|->
name|mac_stx
index|[
literal|1
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mac_stx
argument_list|)
argument_list|)
expr_stmt|;
name|estats
operator|->
name|brb_drop_hi
operator|=
name|pstats
operator|->
name|brb_drop_hi
expr_stmt|;
name|estats
operator|->
name|brb_drop_lo
operator|=
name|pstats
operator|->
name|brb_drop_lo
expr_stmt|;
name|pstats
operator|->
name|host_port_stats_start
operator|=
operator|++
name|pstats
operator|->
name|host_port_stats_end
expr_stmt|;
if|if
condition|(
operator|!
name|NOMCP
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|nig_timer_max
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|port_mb
index|[
name|BP_PORT
argument_list|(
name|sc
argument_list|)
index|]
operator|.
name|stat_nig_timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|nig_timer_max
operator|!=
name|estats
operator|->
name|nig_timer_max
condition|)
block|{
name|estats
operator|->
name|nig_timer_max
operator|=
name|nig_timer_max
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): NIG timer reached max value (%u)!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|estats
operator|->
name|nig_timer_max
argument_list|)
expr_stmt|;
block|}
block|}
name|bxe_stats_hw_update_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_INSANE_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns:  *   0 = Success, !0 = Failure.  */
end_comment

begin_comment
comment|// DRC - Done
end_comment

begin_function
specifier|static
name|int
name|bxe_stats_storm_update
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|,
name|cl_id
decl_stmt|;
name|struct
name|eth_stats_query
modifier|*
name|stats
decl_stmt|;
name|struct
name|bxe_port_stats
modifier|*
name|estats
decl_stmt|;
name|struct
name|host_func_stats
modifier|*
name|fstats
decl_stmt|;
name|struct
name|bxe_q_stats
modifier|*
name|qstats
decl_stmt|;
name|struct
name|tstorm_per_port_stats
modifier|*
name|tport
decl_stmt|;
name|struct
name|tstorm_per_client_stats
modifier|*
name|tclient
decl_stmt|;
name|struct
name|ustorm_per_client_stats
modifier|*
name|uclient
decl_stmt|;
name|struct
name|xstorm_per_client_stats
modifier|*
name|xclient
decl_stmt|;
name|struct
name|tstorm_per_client_stats
modifier|*
name|old_tclient
decl_stmt|;
name|struct
name|ustorm_per_client_stats
modifier|*
name|old_uclient
decl_stmt|;
name|struct
name|xstorm_per_client_stats
modifier|*
name|old_xclient
decl_stmt|;
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|uint32_t
name|diff
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_INSANE_STATS
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
name|diff
operator|=
literal|0
expr_stmt|;
name|stats
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|fw_stats
argument_list|)
expr_stmt|;
name|tport
operator|=
operator|&
name|stats
operator|->
name|tstorm_common
operator|.
name|port_statistics
expr_stmt|;
name|fstats
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|func_stats
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
operator|(
name|fstats
operator|->
name|total_bytes_received_hi
operator|)
argument_list|,
operator|&
operator|(
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|func_stats_base
argument_list|)
operator|->
name|total_bytes_received_hi
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|host_func_stats
argument_list|)
operator|-
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|estats
operator|=
operator|&
name|sc
operator|->
name|eth_stats
expr_stmt|;
name|estats
operator|->
name|no_buff_discard_hi
operator|=
literal|0
expr_stmt|;
name|estats
operator|->
name|no_buff_discard_lo
operator|=
literal|0
expr_stmt|;
name|estats
operator|->
name|error_bytes_received_hi
operator|=
literal|0
expr_stmt|;
name|estats
operator|->
name|error_bytes_received_lo
operator|=
literal|0
expr_stmt|;
name|estats
operator|->
name|etherstatsoverrsizepkts_hi
operator|=
literal|0
expr_stmt|;
name|estats
operator|->
name|etherstatsoverrsizepkts_lo
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
expr_stmt|;
name|cl_id
operator|=
name|fp
operator|->
name|cl_id
expr_stmt|;
name|tclient
operator|=
operator|&
name|stats
operator|->
name|tstorm_common
operator|.
name|client_statistics
index|[
name|cl_id
index|]
expr_stmt|;
name|old_tclient
operator|=
operator|&
name|fp
operator|->
name|old_tclient
expr_stmt|;
name|uclient
operator|=
operator|&
name|stats
operator|->
name|ustorm_common
operator|.
name|client_statistics
index|[
name|cl_id
index|]
expr_stmt|;
name|old_uclient
operator|=
operator|&
name|fp
operator|->
name|old_uclient
expr_stmt|;
name|xclient
operator|=
operator|&
name|stats
operator|->
name|xstorm_common
operator|.
name|client_statistics
index|[
name|cl_id
index|]
expr_stmt|;
name|old_xclient
operator|=
operator|&
name|fp
operator|->
name|old_xclient
expr_stmt|;
name|qstats
operator|=
operator|&
name|fp
operator|->
name|eth_q_stats
expr_stmt|;
comment|/* Are TSTORM statistics valid? */
if|if
condition|(
call|(
name|uint16_t
call|)
argument_list|(
name|le16toh
argument_list|(
name|tclient
operator|->
name|stats_counter
argument_list|)
operator|+
literal|1
argument_list|)
operator|!=
name|sc
operator|->
name|stats_counter
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): Stats not updated by TSTORM "
literal|"(tstorm counter (%d) != stats_counter (%d))!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|tclient
operator|->
name|stats_counter
argument_list|,
name|sc
operator|->
name|stats_counter
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|bxe_stats_storm_update_exit
goto|;
block|}
comment|/* Are USTORM statistics valid? */
if|if
condition|(
call|(
name|uint16_t
call|)
argument_list|(
name|le16toh
argument_list|(
name|uclient
operator|->
name|stats_counter
argument_list|)
operator|+
literal|1
argument_list|)
operator|!=
name|sc
operator|->
name|stats_counter
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): Stats not updated by USTORM "
literal|"(ustorm counter (%d) != stats_counter (%d))!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|uclient
operator|->
name|stats_counter
argument_list|,
name|sc
operator|->
name|stats_counter
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|2
expr_stmt|;
goto|goto
name|bxe_stats_storm_update_exit
goto|;
block|}
comment|/* Are XSTORM statistics valid? */
if|if
condition|(
call|(
name|uint16_t
call|)
argument_list|(
name|le16toh
argument_list|(
name|xclient
operator|->
name|stats_counter
argument_list|)
operator|+
literal|1
argument_list|)
operator|!=
name|sc
operator|->
name|stats_counter
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): Stats not updated by XSTORM "
literal|"(xstorm counter (%d) != stats_counter (%d))!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|xclient
operator|->
name|stats_counter
argument_list|,
name|sc
operator|->
name|stats_counter
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|3
expr_stmt|;
goto|goto
name|bxe_stats_storm_update_exit
goto|;
block|}
name|qstats
operator|->
name|total_bytes_received_hi
operator|=
operator|(
name|tclient
operator|->
name|rcv_broadcast_bytes
operator|.
name|hi
operator|)
expr_stmt|;
name|qstats
operator|->
name|total_bytes_received_lo
operator|=
name|le32toh
argument_list|(
name|tclient
operator|->
name|rcv_broadcast_bytes
operator|.
name|lo
argument_list|)
expr_stmt|;
name|ADD_64
argument_list|(
name|qstats
operator|->
name|total_bytes_received_hi
argument_list|,
name|le32toh
argument_list|(
name|tclient
operator|->
name|rcv_multicast_bytes
operator|.
name|hi
argument_list|)
argument_list|,
name|qstats
operator|->
name|total_bytes_received_lo
argument_list|,
name|le32toh
argument_list|(
name|tclient
operator|->
name|rcv_multicast_bytes
operator|.
name|lo
argument_list|)
argument_list|)
expr_stmt|;
name|ADD_64
argument_list|(
name|qstats
operator|->
name|total_bytes_received_hi
argument_list|,
name|le32toh
argument_list|(
name|tclient
operator|->
name|rcv_unicast_bytes
operator|.
name|hi
argument_list|)
argument_list|,
name|qstats
operator|->
name|total_bytes_received_lo
argument_list|,
name|le32toh
argument_list|(
name|tclient
operator|->
name|rcv_unicast_bytes
operator|.
name|lo
argument_list|)
argument_list|)
expr_stmt|;
name|SUB_64
argument_list|(
name|qstats
operator|->
name|total_bytes_received_hi
argument_list|,
name|le32toh
argument_list|(
name|uclient
operator|->
name|bcast_no_buff_bytes
operator|.
name|hi
argument_list|)
argument_list|,
name|qstats
operator|->
name|total_bytes_received_lo
argument_list|,
name|le32toh
argument_list|(
name|uclient
operator|->
name|bcast_no_buff_bytes
operator|.
name|lo
argument_list|)
argument_list|)
expr_stmt|;
name|SUB_64
argument_list|(
name|qstats
operator|->
name|total_bytes_received_hi
argument_list|,
name|le32toh
argument_list|(
name|uclient
operator|->
name|mcast_no_buff_bytes
operator|.
name|hi
argument_list|)
argument_list|,
name|qstats
operator|->
name|total_bytes_received_lo
argument_list|,
name|le32toh
argument_list|(
name|uclient
operator|->
name|mcast_no_buff_bytes
operator|.
name|lo
argument_list|)
argument_list|)
expr_stmt|;
name|SUB_64
argument_list|(
name|qstats
operator|->
name|total_bytes_received_hi
argument_list|,
name|le32toh
argument_list|(
name|uclient
operator|->
name|ucast_no_buff_bytes
operator|.
name|hi
argument_list|)
argument_list|,
name|qstats
operator|->
name|total_bytes_received_lo
argument_list|,
name|le32toh
argument_list|(
name|uclient
operator|->
name|ucast_no_buff_bytes
operator|.
name|lo
argument_list|)
argument_list|)
expr_stmt|;
name|qstats
operator|->
name|valid_bytes_received_hi
operator|=
name|qstats
operator|->
name|total_bytes_received_hi
expr_stmt|;
name|qstats
operator|->
name|valid_bytes_received_lo
operator|=
name|qstats
operator|->
name|total_bytes_received_lo
expr_stmt|;
name|qstats
operator|->
name|error_bytes_received_hi
operator|=
name|le32toh
argument_list|(
name|tclient
operator|->
name|rcv_error_bytes
operator|.
name|hi
argument_list|)
expr_stmt|;
name|qstats
operator|->
name|error_bytes_received_lo
operator|=
name|le32toh
argument_list|(
name|tclient
operator|->
name|rcv_error_bytes
operator|.
name|lo
argument_list|)
expr_stmt|;
name|ADD_64
argument_list|(
name|qstats
operator|->
name|total_bytes_received_hi
argument_list|,
name|qstats
operator|->
name|error_bytes_received_hi
argument_list|,
name|qstats
operator|->
name|total_bytes_received_lo
argument_list|,
name|qstats
operator|->
name|error_bytes_received_lo
argument_list|)
expr_stmt|;
name|UPDATE_EXTEND_TSTAT
argument_list|(
name|rcv_unicast_pkts
argument_list|,
name|total_unicast_packets_received
argument_list|)
expr_stmt|;
name|UPDATE_EXTEND_TSTAT
argument_list|(
name|rcv_multicast_pkts
argument_list|,
name|total_multicast_packets_received
argument_list|)
expr_stmt|;
name|UPDATE_EXTEND_TSTAT
argument_list|(
name|rcv_broadcast_pkts
argument_list|,
name|total_broadcast_packets_received
argument_list|)
expr_stmt|;
name|UPDATE_EXTEND_TSTAT
argument_list|(
name|packets_too_big_discard
argument_list|,
name|etherstatsoverrsizepkts
argument_list|)
expr_stmt|;
name|UPDATE_EXTEND_TSTAT
argument_list|(
name|no_buff_discard
argument_list|,
name|no_buff_discard
argument_list|)
expr_stmt|;
name|SUB_EXTEND_USTAT
argument_list|(
name|ucast_no_buff_pkts
argument_list|,
name|total_unicast_packets_received
argument_list|)
expr_stmt|;
name|SUB_EXTEND_USTAT
argument_list|(
name|mcast_no_buff_pkts
argument_list|,
name|total_multicast_packets_received
argument_list|)
expr_stmt|;
name|SUB_EXTEND_USTAT
argument_list|(
name|bcast_no_buff_pkts
argument_list|,
name|total_broadcast_packets_received
argument_list|)
expr_stmt|;
name|UPDATE_EXTEND_USTAT
argument_list|(
name|ucast_no_buff_pkts
argument_list|,
name|no_buff_discard
argument_list|)
expr_stmt|;
name|UPDATE_EXTEND_USTAT
argument_list|(
name|mcast_no_buff_pkts
argument_list|,
name|no_buff_discard
argument_list|)
expr_stmt|;
name|UPDATE_EXTEND_USTAT
argument_list|(
name|bcast_no_buff_pkts
argument_list|,
name|no_buff_discard
argument_list|)
expr_stmt|;
name|qstats
operator|->
name|total_bytes_transmitted_hi
operator|=
name|le32toh
argument_list|(
name|xclient
operator|->
name|unicast_bytes_sent
operator|.
name|hi
argument_list|)
expr_stmt|;
name|qstats
operator|->
name|total_bytes_transmitted_lo
operator|=
name|le32toh
argument_list|(
name|xclient
operator|->
name|unicast_bytes_sent
operator|.
name|lo
argument_list|)
expr_stmt|;
name|ADD_64
argument_list|(
name|qstats
operator|->
name|total_bytes_transmitted_hi
argument_list|,
name|le32toh
argument_list|(
name|xclient
operator|->
name|multicast_bytes_sent
operator|.
name|hi
argument_list|)
argument_list|,
name|qstats
operator|->
name|total_bytes_transmitted_lo
argument_list|,
name|le32toh
argument_list|(
name|xclient
operator|->
name|multicast_bytes_sent
operator|.
name|lo
argument_list|)
argument_list|)
expr_stmt|;
name|ADD_64
argument_list|(
name|qstats
operator|->
name|total_bytes_transmitted_hi
argument_list|,
name|le32toh
argument_list|(
name|xclient
operator|->
name|broadcast_bytes_sent
operator|.
name|hi
argument_list|)
argument_list|,
name|qstats
operator|->
name|total_bytes_transmitted_lo
argument_list|,
name|le32toh
argument_list|(
name|xclient
operator|->
name|broadcast_bytes_sent
operator|.
name|lo
argument_list|)
argument_list|)
expr_stmt|;
name|UPDATE_EXTEND_XSTAT
argument_list|(
name|unicast_pkts_sent
argument_list|,
name|total_unicast_packets_transmitted
argument_list|)
expr_stmt|;
name|UPDATE_EXTEND_XSTAT
argument_list|(
name|multicast_pkts_sent
argument_list|,
name|total_multicast_packets_transmitted
argument_list|)
expr_stmt|;
name|UPDATE_EXTEND_XSTAT
argument_list|(
name|broadcast_pkts_sent
argument_list|,
name|total_broadcast_packets_transmitted
argument_list|)
expr_stmt|;
name|old_tclient
operator|->
name|checksum_discard
operator|=
name|tclient
operator|->
name|checksum_discard
expr_stmt|;
name|old_tclient
operator|->
name|ttl0_discard
operator|=
name|tclient
operator|->
name|ttl0_discard
expr_stmt|;
name|ADD_64
argument_list|(
name|fstats
operator|->
name|total_bytes_received_hi
argument_list|,
name|qstats
operator|->
name|total_bytes_received_hi
argument_list|,
name|fstats
operator|->
name|total_bytes_received_lo
argument_list|,
name|qstats
operator|->
name|total_bytes_received_lo
argument_list|)
expr_stmt|;
name|ADD_64
argument_list|(
name|fstats
operator|->
name|total_bytes_transmitted_hi
argument_list|,
name|qstats
operator|->
name|total_bytes_transmitted_hi
argument_list|,
name|fstats
operator|->
name|total_bytes_transmitted_lo
argument_list|,
name|qstats
operator|->
name|total_bytes_transmitted_lo
argument_list|)
expr_stmt|;
name|ADD_64
argument_list|(
name|fstats
operator|->
name|total_unicast_packets_received_hi
argument_list|,
name|qstats
operator|->
name|total_unicast_packets_received_hi
argument_list|,
name|fstats
operator|->
name|total_unicast_packets_received_lo
argument_list|,
name|qstats
operator|->
name|total_unicast_packets_received_lo
argument_list|)
expr_stmt|;
name|ADD_64
argument_list|(
name|fstats
operator|->
name|total_multicast_packets_received_hi
argument_list|,
name|qstats
operator|->
name|total_multicast_packets_received_hi
argument_list|,
name|fstats
operator|->
name|total_multicast_packets_received_lo
argument_list|,
name|qstats
operator|->
name|total_multicast_packets_received_lo
argument_list|)
expr_stmt|;
name|ADD_64
argument_list|(
name|fstats
operator|->
name|total_broadcast_packets_received_hi
argument_list|,
name|qstats
operator|->
name|total_broadcast_packets_received_hi
argument_list|,
name|fstats
operator|->
name|total_broadcast_packets_received_lo
argument_list|,
name|qstats
operator|->
name|total_broadcast_packets_received_lo
argument_list|)
expr_stmt|;
name|ADD_64
argument_list|(
name|fstats
operator|->
name|total_unicast_packets_transmitted_hi
argument_list|,
name|qstats
operator|->
name|total_unicast_packets_transmitted_hi
argument_list|,
name|fstats
operator|->
name|total_unicast_packets_transmitted_lo
argument_list|,
name|qstats
operator|->
name|total_unicast_packets_transmitted_lo
argument_list|)
expr_stmt|;
name|ADD_64
argument_list|(
name|fstats
operator|->
name|total_multicast_packets_transmitted_hi
argument_list|,
name|qstats
operator|->
name|total_multicast_packets_transmitted_hi
argument_list|,
name|fstats
operator|->
name|total_multicast_packets_transmitted_lo
argument_list|,
name|qstats
operator|->
name|total_multicast_packets_transmitted_lo
argument_list|)
expr_stmt|;
name|ADD_64
argument_list|(
name|fstats
operator|->
name|total_broadcast_packets_transmitted_hi
argument_list|,
name|qstats
operator|->
name|total_broadcast_packets_transmitted_hi
argument_list|,
name|fstats
operator|->
name|total_broadcast_packets_transmitted_lo
argument_list|,
name|qstats
operator|->
name|total_broadcast_packets_transmitted_lo
argument_list|)
expr_stmt|;
name|ADD_64
argument_list|(
name|fstats
operator|->
name|valid_bytes_received_hi
argument_list|,
name|qstats
operator|->
name|valid_bytes_received_hi
argument_list|,
name|fstats
operator|->
name|valid_bytes_received_lo
argument_list|,
name|qstats
operator|->
name|valid_bytes_received_lo
argument_list|)
expr_stmt|;
name|ADD_64
argument_list|(
name|estats
operator|->
name|error_bytes_received_hi
argument_list|,
name|qstats
operator|->
name|error_bytes_received_hi
argument_list|,
name|estats
operator|->
name|error_bytes_received_lo
argument_list|,
name|qstats
operator|->
name|error_bytes_received_lo
argument_list|)
expr_stmt|;
name|ADD_64
argument_list|(
name|estats
operator|->
name|etherstatsoverrsizepkts_hi
argument_list|,
name|qstats
operator|->
name|etherstatsoverrsizepkts_hi
argument_list|,
name|estats
operator|->
name|etherstatsoverrsizepkts_lo
argument_list|,
name|qstats
operator|->
name|etherstatsoverrsizepkts_lo
argument_list|)
expr_stmt|;
name|ADD_64
argument_list|(
name|estats
operator|->
name|no_buff_discard_hi
argument_list|,
name|qstats
operator|->
name|no_buff_discard_hi
argument_list|,
name|estats
operator|->
name|no_buff_discard_lo
argument_list|,
name|qstats
operator|->
name|no_buff_discard_lo
argument_list|)
expr_stmt|;
block|}
name|ADD_64
argument_list|(
name|fstats
operator|->
name|total_bytes_received_hi
argument_list|,
name|estats
operator|->
name|rx_stat_ifhcinbadoctets_hi
argument_list|,
name|fstats
operator|->
name|total_bytes_received_lo
argument_list|,
name|estats
operator|->
name|rx_stat_ifhcinbadoctets_lo
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|estats
argument_list|,
operator|&
operator|(
name|fstats
operator|->
name|total_bytes_received_hi
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|host_func_stats
argument_list|)
operator|-
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|ADD_64
argument_list|(
name|estats
operator|->
name|etherstatsoverrsizepkts_hi
argument_list|,
name|estats
operator|->
name|rx_stat_dot3statsframestoolong_hi
argument_list|,
name|estats
operator|->
name|etherstatsoverrsizepkts_lo
argument_list|,
name|estats
operator|->
name|rx_stat_dot3statsframestoolong_lo
argument_list|)
expr_stmt|;
name|ADD_64
argument_list|(
name|estats
operator|->
name|error_bytes_received_hi
argument_list|,
name|estats
operator|->
name|rx_stat_ifhcinbadoctets_hi
argument_list|,
name|estats
operator|->
name|error_bytes_received_lo
argument_list|,
name|estats
operator|->
name|rx_stat_ifhcinbadoctets_lo
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|port
operator|.
name|pmf
condition|)
block|{
name|estats
operator|->
name|mac_filter_discard
operator|=
name|le32toh
argument_list|(
name|tport
operator|->
name|mac_filter_discard
argument_list|)
expr_stmt|;
name|estats
operator|->
name|xxoverflow_discard
operator|=
name|le32toh
argument_list|(
name|tport
operator|->
name|xxoverflow_discard
argument_list|)
expr_stmt|;
name|estats
operator|->
name|brb_truncate_discard
operator|=
name|le32toh
argument_list|(
name|tport
operator|->
name|brb_truncate_discard
argument_list|)
expr_stmt|;
name|estats
operator|->
name|mac_discard
operator|=
name|le32toh
argument_list|(
name|tport
operator|->
name|mac_discard
argument_list|)
expr_stmt|;
block|}
name|fstats
operator|->
name|host_func_stats_start
operator|=
operator|++
name|fstats
operator|->
name|host_func_stats_end
expr_stmt|;
name|sc
operator|->
name|stats_pending
operator|=
literal|0
expr_stmt|;
name|bxe_stats_storm_update_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_INSANE_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy the controller maintained statistics over to the OS.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_stats_net_update
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|tstorm_per_client_stats
modifier|*
name|old_tclient
decl_stmt|;
name|struct
name|bxe_port_stats
modifier|*
name|estats
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_INSANE_STATS
argument_list|)
expr_stmt|;
name|old_tclient
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
literal|0
index|]
operator|.
name|old_tclient
expr_stmt|;
name|estats
operator|=
operator|&
name|sc
operator|->
name|eth_stats
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|bxe_ifp
expr_stmt|;
comment|/* 	 * Update the OS interface statistics from 	 * the hardware statistics. 	 */
name|ifp
operator|->
name|if_collisions
operator|=
operator|(
name|u_long
operator|)
name|estats
operator|->
name|tx_stat_dot3statssinglecollisionframes_lo
operator|+
operator|(
name|u_long
operator|)
name|estats
operator|->
name|tx_stat_dot3statsmultiplecollisionframes_lo
operator|+
operator|(
name|u_long
operator|)
name|estats
operator|->
name|tx_stat_dot3statslatecollisions_lo
operator|+
operator|(
name|u_long
operator|)
name|estats
operator|->
name|tx_stat_dot3statsexcessivecollisions_lo
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|=
operator|(
name|u_long
operator|)
name|old_tclient
operator|->
name|checksum_discard
operator|+
operator|(
name|u_long
operator|)
name|estats
operator|->
name|no_buff_discard_lo
operator|+
operator|(
name|u_long
operator|)
name|estats
operator|->
name|mac_discard
operator|+
operator|(
name|u_long
operator|)
name|estats
operator|->
name|rx_stat_etherstatsundersizepkts_lo
operator|+
operator|(
name|u_long
operator|)
name|estats
operator|->
name|brb_drop_lo
operator|+
operator|(
name|u_long
operator|)
name|estats
operator|->
name|brb_truncate_discard
operator|+
operator|(
name|u_long
operator|)
name|estats
operator|->
name|rx_stat_dot3statsfcserrors_lo
operator|+
operator|(
name|u_long
operator|)
name|estats
operator|->
name|rx_stat_dot3statsalignmenterrors_lo
operator|+
operator|(
name|u_long
operator|)
name|estats
operator|->
name|xxoverflow_discard
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|=
operator|(
name|u_long
operator|)
name|estats
operator|->
name|tx_stat_dot3statslatecollisions_lo
operator|+
operator|(
name|u_long
operator|)
name|estats
operator|->
name|tx_stat_dot3statsexcessivecollisions_lo
operator|+
operator|(
name|u_long
operator|)
name|estats
operator|->
name|tx_stat_dot3statsinternalmactransmiterrors_lo
expr_stmt|;
name|ifp
operator|->
name|if_ipackets
operator|=
name|bxe_hilo
argument_list|(
operator|&
name|estats
operator|->
name|total_unicast_packets_received_hi
argument_list|)
operator|+
name|bxe_hilo
argument_list|(
operator|&
name|estats
operator|->
name|total_multicast_packets_received_hi
argument_list|)
operator|+
name|bxe_hilo
argument_list|(
operator|&
name|estats
operator|->
name|total_broadcast_packets_received_hi
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|=
name|bxe_hilo
argument_list|(
operator|&
name|estats
operator|->
name|total_unicast_packets_transmitted_hi
argument_list|)
operator|+
name|bxe_hilo
argument_list|(
operator|&
name|estats
operator|->
name|total_multicast_packets_transmitted_hi
argument_list|)
operator|+
name|bxe_hilo
argument_list|(
operator|&
name|estats
operator|->
name|total_broadcast_packets_transmitted_hi
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_INSANE_STATS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_stats_update
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
modifier|*
name|stats_comp
decl_stmt|;
name|int
name|update
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_INSANE_STATS
argument_list|)
expr_stmt|;
name|stats_comp
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|stats_comp
argument_list|)
expr_stmt|;
name|update
operator|=
literal|0
expr_stmt|;
comment|/* Make sure the statistics DMAE update has completed. */
if|if
condition|(
operator|*
name|stats_comp
operator|!=
name|DMAE_COMP_VAL
condition|)
goto|goto
name|bxe_stats_update_exit
goto|;
comment|/* Check for any hardware statistics updates. */
if|if
condition|(
name|sc
operator|->
name|port
operator|.
name|pmf
operator|==
literal|1
condition|)
name|update
operator|=
operator|(
name|bxe_stats_hw_update
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
comment|/* Check for any STORM statistics updates. */
name|update
operator||=
operator|(
name|bxe_stats_storm_update
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
comment|/* If we got updated hardware statistics then update the OS. */
if|if
condition|(
name|update
condition|)
name|bxe_stats_net_update
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Check if any statistics updates are pending. */
if|if
condition|(
name|sc
operator|->
name|stats_pending
condition|)
block|{
comment|/* The update hasn't completed, keep waiting. */
name|sc
operator|->
name|stats_pending
operator|++
expr_stmt|;
comment|/* Have we been waiting for too long? */
if|if
condition|(
name|sc
operator|->
name|stats_pending
operator|>=
literal|3
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Failed to get statistics after "
literal|"3 tries!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|bxe_panic_dump
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|bxe_stats_update_exit
goto|;
block|}
block|}
block|}
comment|/* Kickoff the next statistics request. */
name|bxe_stats_hw_post
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_stats_storm_post
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_stats_update_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_INSANE_STATS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_stats_port_stop
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|dmae_command
modifier|*
name|dmae
decl_stmt|;
name|uint32_t
name|opcode
decl_stmt|,
modifier|*
name|stats_comp
decl_stmt|;
name|int
name|loader_idx
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_STATS
argument_list|)
expr_stmt|;
name|stats_comp
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|stats_comp
argument_list|)
expr_stmt|;
name|loader_idx
operator|=
name|PMF_DMAE_C
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|executer_idx
operator|=
literal|0
expr_stmt|;
name|opcode
operator|=
operator|(
name|DMAE_CMD_SRC_PCI
operator||
name|DMAE_CMD_DST_GRC
operator||
name|DMAE_CMD_C_ENABLE
operator||
name|DMAE_CMD_SRC_RESET
operator||
name|DMAE_CMD_DST_RESET
operator||
ifdef|#
directive|ifdef
name|__BIG_ENDIAN
name|DMAE_CMD_ENDIANITY_B_DW_SWAP
operator||
else|#
directive|else
name|DMAE_CMD_ENDIANITY_DW_SWAP
operator||
endif|#
directive|endif
operator|(
name|BP_PORT
argument_list|(
name|sc
argument_list|)
condition|?
name|DMAE_CMD_PORT_1
else|:
name|DMAE_CMD_PORT_0
operator|)
operator||
operator|(
name|BP_E1HVN
argument_list|(
name|sc
argument_list|)
operator|<<
name|DMAE_CMD_E1HVN_SHIFT
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|port
operator|.
name|port_stx
condition|)
block|{
name|dmae
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|dmae
index|[
name|sc
operator|->
name|executer_idx
operator|++
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|func_stx
condition|)
name|dmae
operator|->
name|opcode
operator|=
operator|(
name|opcode
operator||
name|DMAE_CMD_C_DST_GRC
operator|)
expr_stmt|;
else|else
name|dmae
operator|->
name|opcode
operator|=
operator|(
name|opcode
operator||
name|DMAE_CMD_C_DST_PCI
operator|)
expr_stmt|;
name|dmae
operator|->
name|src_addr_lo
operator|=
name|U64_LO
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|port_stats
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|src_addr_hi
operator|=
name|U64_HI
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|port_stats
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|dst_addr_lo
operator|=
name|sc
operator|->
name|port
operator|.
name|port_stx
operator|>>
literal|2
expr_stmt|;
name|dmae
operator|->
name|dst_addr_hi
operator|=
literal|0
expr_stmt|;
name|dmae
operator|->
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|host_port_stats
argument_list|)
operator|>>
literal|2
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|func_stx
condition|)
block|{
name|dmae
operator|->
name|comp_addr_lo
operator|=
name|dmae_reg_go_c
index|[
name|loader_idx
index|]
operator|>>
literal|2
expr_stmt|;
name|dmae
operator|->
name|comp_addr_hi
operator|=
literal|0
expr_stmt|;
name|dmae
operator|->
name|comp_val
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|dmae
operator|->
name|comp_addr_lo
operator|=
name|U64_LO
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|stats_comp
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|comp_addr_hi
operator|=
name|U64_HI
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|stats_comp
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|comp_val
operator|=
name|DMAE_COMP_VAL
expr_stmt|;
operator|*
name|stats_comp
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|func_stx
condition|)
block|{
name|dmae
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|dmae
index|[
name|sc
operator|->
name|executer_idx
operator|++
index|]
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|opcode
operator|=
operator|(
name|opcode
operator||
name|DMAE_CMD_C_DST_PCI
operator|)
expr_stmt|;
name|dmae
operator|->
name|src_addr_lo
operator|=
name|U64_LO
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|func_stats
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|src_addr_hi
operator|=
name|U64_HI
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|func_stats
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|dst_addr_lo
operator|=
name|sc
operator|->
name|func_stx
operator|>>
literal|2
expr_stmt|;
name|dmae
operator|->
name|dst_addr_hi
operator|=
literal|0
expr_stmt|;
name|dmae
operator|->
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|host_func_stats
argument_list|)
operator|>>
literal|2
expr_stmt|;
name|dmae
operator|->
name|comp_addr_lo
operator|=
name|U64_LO
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|stats_comp
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|comp_addr_hi
operator|=
name|U64_HI
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|stats_comp
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|comp_val
operator|=
name|DMAE_COMP_VAL
expr_stmt|;
operator|*
name|stats_comp
operator|=
literal|0
expr_stmt|;
block|}
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_STATS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_stats_stop
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|update
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_STATS
argument_list|)
expr_stmt|;
name|update
operator|=
literal|0
expr_stmt|;
comment|/* Wait for any pending completions. */
name|bxe_stats_comp
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|port
operator|.
name|pmf
operator|==
literal|1
condition|)
name|update
operator|=
operator|(
name|bxe_stats_hw_update
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
name|update
operator||=
operator|(
name|bxe_stats_storm_update
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|update
condition|)
block|{
name|bxe_stats_net_update
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|port
operator|.
name|pmf
operator|==
literal|1
condition|)
name|bxe_stats_port_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_stats_hw_post
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_stats_comp
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_STATS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * A dummy function to fill in the statistics state transition table.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_stats_do_nothing
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|DBENTER
argument_list|(
name|BXE_VERBOSE_STATS
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_STATS
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|void
function_decl|(
modifier|*
name|action
function_decl|)
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
name|enum
name|bxe_stats_state
name|next_state
decl_stmt|;
block|}
name|bxe_stats_stm
index|[
name|STATS_STATE_MAX
index|]
index|[
name|STATS_EVENT_MAX
index|]
init|=
block|{
comment|/* State   Event  */
block|{
comment|/* DISABLED	PMF	*/
block|{
name|bxe_stats_pmf_update
block|,
name|STATS_STATE_DISABLED
block|}
block|,
comment|/*		LINK_UP	*/
block|{
name|bxe_stats_start
block|,
name|STATS_STATE_ENABLED
block|}
block|,
comment|/*		UPDATE	*/
block|{
name|bxe_stats_do_nothing
block|,
name|STATS_STATE_DISABLED
block|}
block|,
comment|/*		STOP	*/
block|{
name|bxe_stats_do_nothing
block|,
name|STATS_STATE_DISABLED
block|}
block|}
block|,
block|{
comment|/* ENABLED	PMF	*/
block|{
name|bxe_stats_pmf_start
block|,
name|STATS_STATE_ENABLED
block|}
block|,
comment|/*		LINK_UP	*/
block|{
name|bxe_stats_restart
block|,
name|STATS_STATE_ENABLED
block|}
block|,
comment|/*		UPDATE	*/
block|{
name|bxe_stats_update
block|,
name|STATS_STATE_ENABLED
block|}
block|,
comment|/*		STOP	*/
block|{
name|bxe_stats_stop
block|,
name|STATS_STATE_DISABLED
block|}
block|}
block|}
struct|;
end_struct

begin_comment
comment|/*  * Move to the next state of the statistics state machine.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_stats_handle
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|enum
name|bxe_stats_event
name|event
parameter_list|)
block|{
name|enum
name|bxe_stats_state
name|state
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_EXTREME_STATS
argument_list|)
expr_stmt|;
name|state
operator|=
name|sc
operator|->
name|stats_state
expr_stmt|;
ifdef|#
directive|ifdef
name|BXE_DEBUG
if|if
condition|(
name|event
operator|!=
name|STATS_EVENT_UPDATE
condition|)
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_STATS
argument_list|,
literal|"%s(): Current state = %d, event = %d.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|state
argument_list|,
name|event
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bxe_stats_stm
index|[
name|state
index|]
index|[
name|event
index|]
operator|.
name|action
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|stats_state
operator|=
name|bxe_stats_stm
index|[
name|state
index|]
index|[
name|event
index|]
operator|.
name|next_state
expr_stmt|;
ifdef|#
directive|ifdef
name|BXE_DEBUG
if|if
condition|(
name|event
operator|!=
name|STATS_EVENT_UPDATE
condition|)
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_STATS
argument_list|,
literal|"%s(): New state = %d.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|stats_state
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DBEXIT
argument_list|(
name|BXE_EXTREME_STATS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * bxe_chktso_window()  * Checks to ensure the 13 bd sliding window is>= MSS for TSO.  * Check that (13 total bds - 3bds) = 10 bd window>= MSS.  * The window: 3 bds are = 1 (for headers BD) + 2 (for PBD and last BD)  * The headers comes in a seperate bd in FreeBSD. So 13-3=10.  *  * Returns:  *   0 if OK to send, 1 if packet needs further defragmentation.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_chktso_window
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
name|uint32_t
name|num_wnds
decl_stmt|,
name|wnd_size
decl_stmt|,
name|wnd_sum
decl_stmt|;
name|int32_t
name|frag_idx
decl_stmt|,
name|wnd_idx
decl_stmt|;
name|unsigned
name|short
name|lso_mss
decl_stmt|;
name|int
name|defrag
decl_stmt|;
name|defrag
operator|=
literal|0
expr_stmt|;
name|wnd_sum
operator|=
literal|0
expr_stmt|;
name|wnd_size
operator|=
literal|10
expr_stmt|;
name|num_wnds
operator|=
name|nsegs
operator|-
name|wnd_size
expr_stmt|;
name|lso_mss
operator|=
name|htole16
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
argument_list|)
expr_stmt|;
comment|/* 	 * Total Header lengths Eth+IP+TCP in 1st FreeBSD mbuf so 	 * calculate the first window sum of data skip the first 	 * assuming it is the header in FreeBSD. 	 */
for|for
control|(
name|frag_idx
operator|=
literal|1
init|;
operator|(
name|frag_idx
operator|<=
name|wnd_size
operator|)
condition|;
name|frag_idx
operator|++
control|)
name|wnd_sum
operator|+=
name|htole16
argument_list|(
name|segs
index|[
name|frag_idx
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
comment|/* Chk the first 10 bd window size */
if|if
condition|(
name|wnd_sum
operator|<
name|lso_mss
condition|)
return|return
operator|(
name|defrag
operator|=
literal|1
operator|)
return|;
comment|/* Run through the windows */
for|for
control|(
name|wnd_idx
operator|=
literal|0
init|;
name|wnd_idx
operator|<
name|num_wnds
condition|;
name|wnd_idx
operator|++
operator|,
name|frag_idx
operator|++
control|)
block|{
comment|/* Subtract the 1st mbuf->m_len of the last wndw(-header). */
name|wnd_sum
operator|-=
name|htole16
argument_list|(
name|segs
index|[
name|wnd_idx
operator|+
literal|1
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
comment|/* Add the next mbuf len to the len of our new window. */
name|wnd_sum
operator|+=
name|htole16
argument_list|(
name|segs
index|[
name|frag_idx
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|wnd_sum
operator|<
name|lso_mss
condition|)
block|{
name|defrag
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|defrag
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Encapsultes an mbuf cluster into the tx_bd chain structure and  * makes the memory visible to the controller.  *  * If an mbuf is submitted to this routine and cannot be given to the  * controller (e.g. it has too many fragments) then the function may free  * the mbuf and return to the caller.  *  * Returns:  *   0 = Success, !0 = Failure  *   Note the side effect that an mbuf may be freed if it causes a problem.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_tx_encap
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m_head
parameter_list|)
block|{
name|bus_dma_segment_t
name|segs
index|[
literal|32
index|]
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|struct
name|eth_tx_parse_bd
modifier|*
name|tx_parse_bd
decl_stmt|;
name|struct
name|eth_tx_bd
modifier|*
name|tx_data_bd
decl_stmt|;
name|struct
name|eth_tx_bd
modifier|*
name|tx_total_pkt_size_bd
decl_stmt|;
name|struct
name|eth_tx_start_bd
modifier|*
name|tx_start_bd
decl_stmt|;
name|uint16_t
name|etype
decl_stmt|,
name|sw_tx_bd_prod
decl_stmt|,
name|sw_pkt_prod
decl_stmt|,
name|total_pkt_size
decl_stmt|;
comment|//	uint16_t bd_index, pkt_index;
name|uint8_t
name|mac_type
decl_stmt|;
name|int
name|i
decl_stmt|,
name|defragged
decl_stmt|,
name|e_hlen
decl_stmt|,
name|error
decl_stmt|,
name|nsegs
decl_stmt|,
name|rc
decl_stmt|,
name|nbds
decl_stmt|,
name|vlan_off
decl_stmt|,
name|ovlan
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|fp
operator|->
name|sc
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_SEND
argument_list|)
expr_stmt|;
name|DBRUN
argument_list|(
name|M_ASSERTPKTHDR
argument_list|(
operator|*
name|m_head
argument_list|)
argument_list|)
expr_stmt|;
name|m0
operator|=
operator|*
name|m_head
expr_stmt|;
name|rc
operator|=
name|defragged
operator|=
name|nbds
operator|=
name|ovlan
operator|=
name|vlan_off
operator|=
name|total_pkt_size
operator|=
literal|0
expr_stmt|;
name|tx_start_bd
operator|=
name|NULL
expr_stmt|;
name|tx_data_bd
operator|=
name|NULL
expr_stmt|;
name|tx_parse_bd
operator|=
name|NULL
expr_stmt|;
name|tx_total_pkt_size_bd
operator|=
name|NULL
expr_stmt|;
comment|/* Get the H/W pointer (0 to 65535) for packets and BD's. */
name|sw_pkt_prod
operator|=
name|fp
operator|->
name|tx_pkt_prod
expr_stmt|;
name|sw_tx_bd_prod
operator|=
name|fp
operator|->
name|tx_bd_prod
expr_stmt|;
comment|/* Create the S/W index (0 to MAX_TX_BD) for packets and BD's. */
comment|//	pkt_index = TX_BD(sw_pkt_prod);
comment|//	bd_index = TX_BD(sw_tx_bd_prod);
name|mac_type
operator|=
name|UNICAST_ADDRESS
expr_stmt|;
comment|/* Map the mbuf into the next open DMAable memory. */
name|map
operator|=
name|fp
operator|->
name|tx_mbuf_map
index|[
name|TX_BD
argument_list|(
name|sw_pkt_prod
argument_list|)
index|]
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|fp
operator|->
name|tx_mbuf_tag
argument_list|,
name|map
argument_list|,
name|m0
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
comment|/* Handle any mapping errors. */
if|if
condition|(
name|__predict_false
argument_list|(
name|error
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|fp
operator|->
name|tx_dma_mapping_failure
operator|++
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOMEM
condition|)
block|{
comment|/* Resource issue, try again later. */
name|rc
operator|=
name|ENOMEM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|EFBIG
condition|)
block|{
comment|/* Possibly recoverable with defragmentation. */
name|fp
operator|->
name|mbuf_defrag_attempts
operator|++
expr_stmt|;
name|m0
operator|=
name|m_defrag
argument_list|(
operator|*
name|m_head
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|fp
operator|->
name|mbuf_defrag_failures
operator|++
expr_stmt|;
name|rc
operator|=
name|ENOBUFS
expr_stmt|;
block|}
else|else
block|{
comment|/* Defrag successful, try mapping again.*/
operator|*
name|m_head
operator|=
name|m0
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|fp
operator|->
name|tx_mbuf_tag
argument_list|,
name|map
argument_list|,
name|m0
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|fp
operator|->
name|tx_dma_mapping_failure
operator|++
expr_stmt|;
name|rc
operator|=
name|error
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Unknown, unrecoverable mapping error. */
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN_SEND
argument_list|,
literal|"%s(): Unknown TX mapping error! "
literal|"rc = %d.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|DBRUN
argument_list|(
name|bxe_dump_mbuf
argument_list|(
name|sc
argument_list|,
name|m0
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|error
expr_stmt|;
block|}
goto|goto
name|bxe_tx_encap_continue
goto|;
block|}
comment|/* Make sure there's enough room in the send queue. */
if|if
condition|(
name|__predict_false
argument_list|(
operator|(
name|nsegs
operator|+
literal|2
operator|)
operator|>
operator|(
name|USABLE_TX_BD
operator|-
name|fp
operator|->
name|tx_bd_used
operator|)
argument_list|)
condition|)
block|{
comment|/* Recoverable, try again later. */
name|fp
operator|->
name|tx_hw_queue_full
operator|++
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|fp
operator|->
name|tx_mbuf_tag
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bxe_tx_encap_continue
goto|;
block|}
comment|/* Capture the current H/W TX chain high watermark. */
if|if
condition|(
name|__predict_false
argument_list|(
name|fp
operator|->
name|tx_hw_max_queue_depth
operator|<
name|fp
operator|->
name|tx_bd_used
argument_list|)
condition|)
name|fp
operator|->
name|tx_hw_max_queue_depth
operator|=
name|fp
operator|->
name|tx_bd_used
expr_stmt|;
comment|/* Now make sure it fits in the packet window. */
if|if
condition|(
name|__predict_false
argument_list|(
name|nsegs
operator|>
literal|12
argument_list|)
condition|)
block|{
comment|/* 		 * The mbuf may be to big for the controller 		 * to handle.  If the frame is a TSO frame 		 * we'll need to do an additional check. 		 */
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
condition|)
block|{
if|if
condition|(
name|bxe_chktso_window
argument_list|(
name|sc
argument_list|,
name|nsegs
argument_list|,
name|segs
argument_list|,
name|m0
argument_list|)
operator|==
literal|0
condition|)
comment|/* OK to send. */
goto|goto
name|bxe_tx_encap_continue
goto|;
else|else
name|fp
operator|->
name|tx_window_violation_tso
operator|++
expr_stmt|;
block|}
else|else
name|fp
operator|->
name|tx_window_violation_std
operator|++
expr_stmt|;
comment|/* No sense trying to defrag again, we'll drop the frame. */
if|if
condition|(
name|defragged
operator|>
literal|0
condition|)
name|rc
operator|=
name|ENODEV
expr_stmt|;
block|}
name|bxe_tx_encap_continue
label|:
comment|/* Check for errors */
if|if
condition|(
name|rc
condition|)
block|{
if|if
condition|(
name|rc
operator|==
name|ENOMEM
condition|)
block|{
comment|/* Recoverable try again later  */
block|}
else|else
block|{
name|fp
operator|->
name|tx_soft_errors
operator|++
expr_stmt|;
name|fp
operator|->
name|tx_mbuf_alloc
operator|--
expr_stmt|;
name|m_freem
argument_list|(
operator|*
name|m_head
argument_list|)
expr_stmt|;
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
block|}
goto|goto
name|bxe_tx_encap_exit
goto|;
block|}
comment|/* Save the mbuf and mapping. */
name|fp
operator|->
name|tx_mbuf_ptr
index|[
name|TX_BD
argument_list|(
name|sw_pkt_prod
argument_list|)
index|]
operator|=
name|m0
expr_stmt|;
name|fp
operator|->
name|tx_mbuf_map
index|[
name|TX_BD
argument_list|(
name|sw_pkt_prod
argument_list|)
index|]
operator|=
name|map
expr_stmt|;
comment|/* Set flag according to packet type (UNICAST_ADDRESS is default). */
if|if
condition|(
name|m0
operator|->
name|m_flags
operator|&
name|M_BCAST
condition|)
name|mac_type
operator|=
name|BROADCAST_ADDRESS
expr_stmt|;
elseif|else
if|if
condition|(
name|m0
operator|->
name|m_flags
operator|&
name|M_MCAST
condition|)
name|mac_type
operator|=
name|MULTICAST_ADDRESS
expr_stmt|;
comment|/* Prepare the first transmit (Start) BD for the mbuf. */
name|tx_start_bd
operator|=
operator|&
name|fp
operator|->
name|tx_chain
index|[
name|TX_BD
argument_list|(
name|sw_tx_bd_prod
argument_list|)
index|]
operator|.
name|start_bd
expr_stmt|;
name|tx_start_bd
operator|->
name|addr_lo
operator|=
name|htole32
argument_list|(
name|U64_LO
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|tx_start_bd
operator|->
name|addr_hi
operator|=
name|htole32
argument_list|(
name|U64_HI
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|tx_start_bd
operator|->
name|nbytes
operator|=
name|htole16
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
name|total_pkt_size
operator|+=
name|tx_start_bd
operator|->
name|nbytes
expr_stmt|;
name|tx_start_bd
operator|->
name|bd_flags
operator|.
name|as_bitfield
operator|=
name|ETH_TX_BD_FLAGS_START_BD
expr_stmt|;
name|tx_start_bd
operator|->
name|general_data
operator|=
operator|(
name|mac_type
operator|<<
name|ETH_TX_START_BD_ETH_ADDR_TYPE_SHIFT
operator|)
expr_stmt|;
name|tx_start_bd
operator|->
name|general_data
operator||=
operator|(
literal|1
operator|<<
name|ETH_TX_START_BD_HDR_NBDS_SHIFT
operator|)
expr_stmt|;
comment|/* All frames have at least Start BD + Parsing BD. */
name|nbds
operator|=
name|nsegs
operator|+
literal|1
expr_stmt|;
name|tx_start_bd
operator|->
name|nbd
operator|=
name|htole16
argument_list|(
name|nbds
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|->
name|m_flags
operator|&
name|M_VLANTAG
condition|)
block|{
name|tx_start_bd
operator|->
name|bd_flags
operator|.
name|as_bitfield
operator||=
name|ETH_TX_BD_FLAGS_VLAN_TAG
expr_stmt|;
name|tx_start_bd
operator|->
name|vlan
operator|=
name|htole16
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* 		 * In cases where the VLAN tag is not used the firmware 		 * expects to see a packet counter in the VLAN tag field 		 * Failure to do so will cause an assertion which will 		 * stop the controller. 		 */
name|tx_start_bd
operator|->
name|vlan
operator|=
name|htole16
argument_list|(
name|fp
operator|->
name|tx_pkt_prod
argument_list|)
expr_stmt|;
comment|/* 	 * Add a parsing BD from the chain. The parsing BD is always added, 	 * however, it is only used for TSO& chksum. 	 */
name|sw_tx_bd_prod
operator|=
name|NEXT_TX_BD
argument_list|(
name|sw_tx_bd_prod
argument_list|)
expr_stmt|;
name|tx_parse_bd
operator|=
operator|(
expr|struct
name|eth_tx_parse_bd
operator|*
operator|)
operator|&
name|fp
operator|->
name|tx_chain
index|[
name|TX_BD
argument_list|(
name|sw_tx_bd_prod
argument_list|)
index|]
operator|.
name|parse_bd
expr_stmt|;
name|memset
argument_list|(
name|tx_parse_bd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|eth_tx_parse_bd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Gather all info about the packet and add to tx_parse_bd */
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
condition|)
block|{
name|struct
name|ether_vlan_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
init|=
name|NULL
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|th
init|=
name|NULL
decl_stmt|;
name|uint16_t
name|flags
init|=
literal|0
decl_stmt|;
name|struct
name|udphdr
modifier|*
name|uh
init|=
name|NULL
decl_stmt|;
comment|/* Map Ethernet header to find type& header length. */
name|eh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
expr_stmt|;
comment|/* Handle VLAN encapsulation if present. */
if|if
condition|(
name|eh
operator|->
name|evl_encap_proto
operator|==
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
condition|)
block|{
name|etype
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|evl_proto
argument_list|)
expr_stmt|;
name|e_hlen
operator|=
name|ETHER_HDR_LEN
operator|+
name|vlan_off
expr_stmt|;
block|}
else|else
block|{
name|etype
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|evl_encap_proto
argument_list|)
expr_stmt|;
name|e_hlen
operator|=
name|ETHER_HDR_LEN
expr_stmt|;
block|}
comment|/* Set the Ethernet header length in 16 bit words. */
name|tx_parse_bd
operator|->
name|global_data
operator|=
operator|(
name|e_hlen
operator|+
name|ovlan
operator|)
operator|>>
literal|1
expr_stmt|;
name|tx_parse_bd
operator|->
name|global_data
operator||=
operator|(
operator|(
name|m0
operator|->
name|m_flags
operator|&
name|M_VLANTAG
operator|)
operator|<<
name|ETH_TX_PARSE_BD_LLC_SNAP_EN_SHIFT
operator|)
expr_stmt|;
switch|switch
condition|(
name|etype
condition|)
block|{
case|case
name|ETHERTYPE_IP
case|:
comment|/* If mbuf len< 20bytes, IP header is in next mbuf. */
if|if
condition|(
name|m0
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|m0
operator|->
name|m_next
operator|->
name|m_data
expr_stmt|;
else|else
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|m0
operator|->
name|m_data
operator|+
name|e_hlen
operator|)
expr_stmt|;
comment|/* Calculate IP header length (16 bit words). */
name|tx_parse_bd
operator|->
name|ip_hlen
operator|=
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|1
operator|)
expr_stmt|;
comment|/* Calculate enet + IP header length (16 bit words). */
name|tx_parse_bd
operator|->
name|total_hlen
operator|=
name|tx_parse_bd
operator|->
name|ip_hlen
operator|+
operator|(
name|e_hlen
operator|>>
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_IP
condition|)
block|{
name|fp
operator|->
name|tx_offload_frames_csum_ip
operator|++
expr_stmt|;
name|flags
operator||=
name|ETH_TX_BD_FLAGS_IP_CSUM
expr_stmt|;
block|}
comment|/* Handle any checksums requested by the stack. */
if|if
condition|(
operator|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TCP
operator|)
operator|||
operator|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
operator|)
condition|)
block|{
comment|/* Get the TCP header. */
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
comment|/* Add the TCP checksum offload flag. */
name|flags
operator||=
name|ETH_TX_BD_FLAGS_L4_CSUM
expr_stmt|;
name|fp
operator|->
name|tx_offload_frames_csum_tcp
operator|++
expr_stmt|;
comment|/* Update the enet + IP + TCP header length. */
name|tx_parse_bd
operator|->
name|total_hlen
operator|+=
call|(
name|uint16_t
call|)
argument_list|(
name|th
operator|->
name|th_off
operator|<<
literal|1
argument_list|)
expr_stmt|;
comment|/* Get the pseudo header checksum. */
name|tx_parse_bd
operator|->
name|tcp_pseudo_csum
operator|=
name|ntohs
argument_list|(
name|th
operator|->
name|th_sum
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_UDP
condition|)
block|{
comment|/* 				 * The hardware doesn't actually support UDP 				 * checksum offload but we can fake it by 				 * doing TCP checksum offload and factoring 				 * out the extra bytes that are	different 				 * between the TCP header and the UDP header. 				 * 				 * Calculation will begin 10 bytes before the 				 * actual start of the UDP header.  To work 				 * around this we need to calculate the 				 * checksum of the 10 bytes before the UDP 				 * header and factor that out of the UDP 				 * pseudo header checksum before asking the 				 * H/W to calculate the full UDP checksum. 				 */
name|uint16_t
name|tmp_csum
decl_stmt|;
name|uint32_t
modifier|*
name|tmp_uh
decl_stmt|;
comment|/* This value is 10. */
name|uint8_t
name|fix
init|=
call|(
name|uint8_t
call|)
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|tcphdr
argument_list|,
name|th_sum
argument_list|)
operator|-
operator|(
name|int
operator|)
name|offsetof
argument_list|(
expr|struct
name|udphdr
argument_list|,
name|uh_sum
argument_list|)
argument_list|)
decl_stmt|;
comment|/* 				 * Add the TCP checksum offload flag for 				 * UDP frames too.* 				 */
name|flags
operator||=
name|ETH_TX_BD_FLAGS_L4_CSUM
expr_stmt|;
name|fp
operator|->
name|tx_offload_frames_csum_udp
operator|++
expr_stmt|;
name|tx_parse_bd
operator|->
name|global_data
operator||=
name|ETH_TX_PARSE_BD_UDP_CS_FLG
expr_stmt|;
comment|/* Get a pointer to the UDP header. */
name|uh
operator|=
operator|(
expr|struct
name|udphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
comment|/* Set pointer 10 bytes before UDP header. */
name|tmp_uh
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|uh
operator|-
name|fix
operator|)
expr_stmt|;
comment|/* 				 * Calculate a pseudo header checksum over 				 * the 10 bytes	before the UDP header. 				 */
name|tmp_csum
operator|=
name|in_pseudo
argument_list|(
name|ntohl
argument_list|(
operator|*
name|tmp_uh
argument_list|)
argument_list|,
name|ntohl
argument_list|(
operator|*
operator|(
name|tmp_uh
operator|+
literal|1
operator|)
argument_list|)
argument_list|,
name|ntohl
argument_list|(
operator|(
operator|*
operator|(
name|tmp_uh
operator|+
literal|2
operator|)
operator|)
operator|&
literal|0x0000FFFF
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Update the enet + IP + UDP header length. */
name|tx_parse_bd
operator|->
name|total_hlen
operator|+=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
operator|>>
literal|1
operator|)
expr_stmt|;
name|tx_parse_bd
operator|->
name|tcp_pseudo_csum
operator|=
operator|~
name|in_addword
argument_list|(
name|uh
operator|->
name|uh_sum
argument_list|,
operator|~
name|tmp_csum
argument_list|)
expr_stmt|;
block|}
comment|/* Update the offload flags. */
name|tx_start_bd
operator|->
name|bd_flags
operator|.
name|as_bitfield
operator||=
name|flags
expr_stmt|;
break|break;
case|case
name|ETHERTYPE_IPV6
case|:
name|fp
operator|->
name|tx_unsupported_tso_request_ipv6
operator|++
expr_stmt|;
comment|/* ToDo: Add IPv6 support. */
break|break;
default|default:
name|fp
operator|->
name|tx_unsupported_tso_request_not_tcp
operator|++
expr_stmt|;
comment|/* ToDo - How to handle this error? */
block|}
comment|/* Setup the Parsing BD with TSO specific info */
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
condition|)
block|{
name|uint16_t
name|hdr_len
init|=
name|tx_parse_bd
operator|->
name|total_hlen
operator|<<
literal|1
decl_stmt|;
name|tx_start_bd
operator|->
name|bd_flags
operator|.
name|as_bitfield
operator||=
name|ETH_TX_BD_FLAGS_SW_LSO
expr_stmt|;
name|fp
operator|->
name|tx_offload_frames_tso
operator|++
expr_stmt|;
comment|/* ToDo: Does this really help? */
if|if
condition|(
name|__predict_false
argument_list|(
name|tx_start_bd
operator|->
name|nbytes
operator|>
name|hdr_len
argument_list|)
condition|)
block|{
name|fp
operator|->
name|tx_header_splits
operator|++
expr_stmt|;
comment|/* 				 * Split the first BD into 2 BDs to make the 				 * firmwares job easy... 				 */
name|tx_start_bd
operator|->
name|nbd
operator|++
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_EXTREME_SEND
argument_list|,
literal|"%s(): TSO split headr size is %d (%x:%x) nbds %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|tx_start_bd
operator|->
name|nbytes
argument_list|,
name|tx_start_bd
operator|->
name|addr_hi
argument_list|,
name|tx_start_bd
operator|->
name|addr_lo
argument_list|,
name|nbds
argument_list|)
expr_stmt|;
name|sw_tx_bd_prod
operator|=
name|NEXT_TX_BD
argument_list|(
name|sw_tx_bd_prod
argument_list|)
expr_stmt|;
comment|/* New transmit BD (after the tx_parse_bd). */
name|tx_data_bd
operator|=
operator|&
name|fp
operator|->
name|tx_chain
index|[
name|TX_BD
argument_list|(
name|sw_tx_bd_prod
argument_list|)
index|]
operator|.
name|reg_bd
expr_stmt|;
name|tx_data_bd
operator|->
name|addr_hi
operator|=
name|htole32
argument_list|(
name|U64_HI
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
operator|+
name|hdr_len
argument_list|)
argument_list|)
expr_stmt|;
name|tx_data_bd
operator|->
name|addr_lo
operator|=
name|htole32
argument_list|(
name|U64_LO
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
operator|+
name|hdr_len
argument_list|)
argument_list|)
expr_stmt|;
name|tx_data_bd
operator|->
name|nbytes
operator|=
name|htole16
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_len
argument_list|)
operator|-
name|hdr_len
expr_stmt|;
if|if
condition|(
name|tx_total_pkt_size_bd
operator|==
name|NULL
condition|)
name|tx_total_pkt_size_bd
operator|=
name|tx_data_bd
expr_stmt|;
block|}
comment|/* 			 * The controller needs the following info for TSO: 			 * MSS, tcp_send_seq, ip_id, and tcp_pseudo_csum. 			 */
name|tx_parse_bd
operator|->
name|lso_mss
operator|=
name|htole16
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
argument_list|)
expr_stmt|;
name|tx_parse_bd
operator|->
name|tcp_send_seq
operator|=
name|ntohl
argument_list|(
name|th
operator|->
name|th_seq
argument_list|)
expr_stmt|;
name|tx_parse_bd
operator|->
name|tcp_flags
operator|=
name|th
operator|->
name|th_flags
expr_stmt|;
name|tx_parse_bd
operator|->
name|ip_id
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_id
argument_list|)
expr_stmt|;
name|tx_parse_bd
operator|->
name|tcp_pseudo_csum
operator|=
name|ntohs
argument_list|(
name|in_pseudo
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|,
name|htons
argument_list|(
name|IPPROTO_TCP
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tx_parse_bd
operator|->
name|global_data
operator||=
name|ETH_TX_PARSE_BD_PSEUDO_CS_WITHOUT_LEN
expr_stmt|;
block|}
block|}
comment|/* Prepare remaining BDs. Start_tx_bd contains first seg (frag). */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
name|sw_tx_bd_prod
operator|=
name|NEXT_TX_BD
argument_list|(
name|sw_tx_bd_prod
argument_list|)
expr_stmt|;
name|tx_data_bd
operator|=
operator|&
name|fp
operator|->
name|tx_chain
index|[
name|TX_BD
argument_list|(
name|sw_tx_bd_prod
argument_list|)
index|]
operator|.
name|reg_bd
expr_stmt|;
name|tx_data_bd
operator|->
name|addr_lo
operator|=
name|htole32
argument_list|(
name|U64_LO
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|tx_data_bd
operator|->
name|addr_hi
operator|=
name|htole32
argument_list|(
name|U64_HI
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|tx_data_bd
operator|->
name|nbytes
operator|=
name|htole16
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx_total_pkt_size_bd
operator|==
name|NULL
condition|)
name|tx_total_pkt_size_bd
operator|=
name|tx_data_bd
expr_stmt|;
name|total_pkt_size
operator|+=
name|tx_data_bd
operator|->
name|nbytes
expr_stmt|;
block|}
if|if
condition|(
name|tx_total_pkt_size_bd
operator|!=
name|NULL
condition|)
name|tx_total_pkt_size_bd
operator|->
name|total_pkt_bytes
operator|=
name|total_pkt_size
expr_stmt|;
comment|/* Update TX BD producer index value for next TX */
name|sw_tx_bd_prod
operator|=
name|NEXT_TX_BD
argument_list|(
name|sw_tx_bd_prod
argument_list|)
expr_stmt|;
comment|/* Update the used TX BD counter. */
name|fp
operator|->
name|tx_bd_used
operator|+=
name|nbds
expr_stmt|;
comment|/* 	 * If the chain of tx_bd's describing this frame 	 * is adjacent to or spans an eth_tx_next_bd element 	 * then we need to increment the nbds value. 	 */
if|if
condition|(
name|TX_IDX
argument_list|(
name|sw_tx_bd_prod
argument_list|)
operator|<
name|nbds
condition|)
name|nbds
operator|++
expr_stmt|;
comment|/* Don't allow reordering of writes for nbd and packets. */
name|mb
argument_list|()
expr_stmt|;
name|fp
operator|->
name|tx_db
operator|.
name|data
operator|.
name|prod
operator|+=
name|nbds
expr_stmt|;
comment|/* Producer points to the next free tx_bd at this point. */
name|fp
operator|->
name|tx_pkt_prod
operator|++
expr_stmt|;
name|fp
operator|->
name|tx_bd_prod
operator|=
name|sw_tx_bd_prod
expr_stmt|;
name|DOORBELL
argument_list|(
name|sc
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|fp
operator|->
name|tx_db
operator|.
name|raw
argument_list|)
expr_stmt|;
name|fp
operator|->
name|tx_pkts
operator|++
expr_stmt|;
comment|/* Prevent speculative reads from getting ahead of the status block. */
name|bus_space_barrier
argument_list|(
name|sc
operator|->
name|bxe_btag
argument_list|,
name|sc
operator|->
name|bxe_bhandle
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_BARRIER_READ
argument_list|)
expr_stmt|;
comment|/* Prevent speculative reads from getting ahead of the doorbell. */
name|bus_space_barrier
argument_list|(
name|sc
operator|->
name|bxe_db_btag
argument_list|,
name|sc
operator|->
name|bxe_db_bhandle
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_BARRIER_READ
argument_list|)
expr_stmt|;
name|bxe_tx_encap_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_SEND
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Legacy (non-RSS) dispatch routine.  *  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_tx_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_EXTREME_SEND
argument_list|)
expr_stmt|;
comment|/* Exit if the transmit queue is full or link down. */
if|if
condition|(
operator|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
operator|)
operator|!=
name|IFF_DRV_RUNNING
operator|)
operator|||
operator|!
name|sc
operator|->
name|link_vars
operator|.
name|link_up
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): No link or TX queue full, ignoring "
literal|"transmit request.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
goto|goto
name|bxe_tx_start_exit
goto|;
block|}
comment|/* Set the TX queue for the frame. */
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
literal|0
index|]
expr_stmt|;
name|BXE_FP_LOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|bxe_tx_start_locked
argument_list|(
name|ifp
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|BXE_FP_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|bxe_tx_start_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_EXTREME_SEND
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Legacy (non-RSS) transmit routine.  *  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_tx_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|int
name|tx_count
init|=
literal|0
decl_stmt|;
name|sc
operator|=
name|fp
operator|->
name|sc
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_EXTREME_SEND
argument_list|)
expr_stmt|;
name|BXE_FP_LOCK_ASSERT
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* Keep adding entries while there are frames to send. */
while|while
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
block|{
comment|/* Check for any frames to send. */
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|==
name|NULL
argument_list|)
condition|)
break|break;
comment|/* The transmit mbuf now belongs to us, keep track of it. */
name|fp
operator|->
name|tx_mbuf_alloc
operator|++
expr_stmt|;
comment|/* 		 * Pack the data into the transmit ring. If we 		 * don't have room, place the mbuf back at the 		 * head of the TX queue, set the OACTIVE flag, 		 * and wait for the NIC to drain the chain. 		 */
if|if
condition|(
name|__predict_false
argument_list|(
name|bxe_tx_encap
argument_list|(
name|fp
argument_list|,
operator|&
name|m
argument_list|)
argument_list|)
condition|)
block|{
name|fp
operator|->
name|tx_encap_failures
operator|++
expr_stmt|;
comment|/* Very Bad Frames(tm) may have been dropped. */
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * Mark the TX queue as full and return 				 * the frame. 				 */
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
name|IFQ_DRV_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|fp
operator|->
name|tx_mbuf_alloc
operator|--
expr_stmt|;
name|fp
operator|->
name|tx_queue_xoff
operator|++
expr_stmt|;
block|}
else|else
block|{  			}
comment|/* Stop looking for more work. */
break|break;
block|}
comment|/* The transmit frame was enqueued successfully. */
name|tx_count
operator|++
expr_stmt|;
comment|/* Send a copy of the frame to any BPF listeners. */
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* No TX packets were dequeued. */
if|if
condition|(
name|tx_count
operator|>
literal|0
condition|)
comment|/* Reset the TX watchdog timeout timer. */
name|fp
operator|->
name|watchdog_timer
operator|=
name|BXE_TX_TIMEOUT
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_EXTREME_SEND
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
end_if

begin_comment
comment|/*  * Multiqueue (RSS) dispatch routine.  *  * Returns:  *   0 if transmit succeeds, !0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_tx_mq_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|int
name|fp_index
decl_stmt|,
name|rc
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_EXTREME_SEND
argument_list|)
expr_stmt|;
name|fp_index
operator|=
literal|0
expr_stmt|;
comment|/* If using flow ID, assign the TX queue based on the flow ID. */
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_FLOWID
operator|)
operator|!=
literal|0
condition|)
name|fp_index
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|%
name|sc
operator|->
name|num_queues
expr_stmt|;
comment|/* Select the fastpath TX queue for the frame. */
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|fp_index
index|]
expr_stmt|;
comment|/* Skip H/W enqueue if transmit queue is full or link down. */
if|if
condition|(
operator|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
operator|)
operator|!=
name|IFF_DRV_RUNNING
operator|)
operator|||
operator|!
name|sc
operator|->
name|link_vars
operator|.
name|link_up
condition|)
block|{
comment|/* Stash the mbuf if we can. */
name|rc
operator|=
name|drbr_enqueue
argument_list|(
name|ifp
argument_list|,
name|fp
operator|->
name|br
argument_list|,
name|m
argument_list|)
expr_stmt|;
goto|goto
name|bxe_tx_mq_start_exit
goto|;
block|}
name|BXE_FP_LOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|rc
operator|=
name|bxe_tx_mq_start_locked
argument_list|(
name|ifp
argument_list|,
name|fp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|BXE_FP_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|bxe_tx_mq_start_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_EXTREME_SEND
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Multiqueue (TSS) transmit routine.  This routine is responsible  * for adding a frame to the hardware's transmit queue.  *  * Returns:  *   0 if transmit succeeds, !0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_tx_mq_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|next
decl_stmt|;
name|int
name|depth
decl_stmt|,
name|rc
decl_stmt|,
name|tx_count
decl_stmt|;
name|sc
operator|=
name|fp
operator|->
name|sc
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_EXTREME_SEND
argument_list|)
expr_stmt|;
name|rc
operator|=
name|tx_count
operator|=
literal|0
expr_stmt|;
comment|/* Fetch the depth of the driver queue. */
name|depth
operator|=
name|drbr_inuse
argument_list|(
name|ifp
argument_list|,
name|fp
operator|->
name|br
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth
operator|>
name|fp
operator|->
name|tx_max_drbr_queue_depth
condition|)
name|fp
operator|->
name|tx_max_drbr_queue_depth
operator|=
name|depth
expr_stmt|;
name|BXE_FP_LOCK_ASSERT
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|rc
operator|=
name|drbr_enqueue
argument_list|(
name|ifp
argument_list|,
name|fp
operator|->
name|br
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|fp
operator|->
name|tx_soft_errors
operator|++
expr_stmt|;
goto|goto
name|bxe_tx_mq_start_locked_exit
goto|;
block|}
block|}
comment|/* Keep adding entries while there are frames to send. */
while|while
condition|(
operator|(
name|next
operator|=
name|drbr_peek
argument_list|(
name|ifp
argument_list|,
name|fp
operator|->
name|br
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* The transmit mbuf now belongs to us, keep track of it. */
name|fp
operator|->
name|tx_mbuf_alloc
operator|++
expr_stmt|;
comment|/* 		 * Pack the data into the transmit ring. If we 		 * don't have room, place the mbuf back at the 		 * head of the TX queue, set the OACTIVE flag, 		 * and wait for the NIC to drain the chain. 		 */
name|rc
operator|=
name|bxe_tx_encap
argument_list|(
name|fp
argument_list|,
operator|&
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|rc
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|fp
operator|->
name|tx_encap_failures
operator|++
expr_stmt|;
comment|/* Very Bad Frames(tm) may have been dropped. */
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
block|{
name|drbr_advance
argument_list|(
name|ifp
argument_list|,
name|fp
operator|->
name|br
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|drbr_putback
argument_list|(
name|ifp
argument_list|,
name|fp
operator|->
name|br
argument_list|,
name|next
argument_list|)
expr_stmt|;
comment|/* 				 * Mark the TX queue as full and save 				 * the frame. 				 */
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
name|fp
operator|->
name|tx_frame_deferred
operator|++
expr_stmt|;
name|fp
operator|->
name|tx_mbuf_alloc
operator|--
expr_stmt|;
block|}
comment|/* Stop looking for more work. */
break|break;
block|}
name|drbr_advance
argument_list|(
name|ifp
argument_list|,
name|fp
operator|->
name|br
argument_list|)
expr_stmt|;
comment|/* The transmit frame was enqueued successfully. */
name|tx_count
operator|++
expr_stmt|;
comment|/* Update stats */
name|ifp
operator|->
name|if_obytes
operator|+=
name|next
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|m_flags
operator|&
name|M_MCAST
condition|)
name|ifp
operator|->
name|if_omcasts
operator|++
expr_stmt|;
comment|/* Send a copy of the frame to any BPF listeners. */
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|next
argument_list|)
expr_stmt|;
comment|/* Handle any completions if we're running low. */
if|if
condition|(
name|fp
operator|->
name|tx_bd_used
operator|>=
name|BXE_TX_CLEANUP_THRESHOLD
condition|)
name|bxe_txeof
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* Close TX since there's so little room left. */
if|if
condition|(
name|fp
operator|->
name|tx_bd_used
operator|>=
name|BXE_TX_CLEANUP_THRESHOLD
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
break|break;
block|}
block|}
comment|/* No TX packets were dequeued. */
if|if
condition|(
name|tx_count
operator|>
literal|0
condition|)
comment|/* Reset the TX watchdog timeout timer. */
name|fp
operator|->
name|watchdog_timer
operator|=
name|BXE_TX_TIMEOUT
expr_stmt|;
name|bxe_tx_mq_start_locked_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_EXTREME_SEND
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_mq_flush
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_UNLOAD
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|br
operator|!=
name|NULL
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_UNLOAD
argument_list|,
literal|"%s(): Clearing fp[%02d]...\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|fp
operator|->
name|index
argument_list|)
expr_stmt|;
name|BXE_FP_LOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|buf_ring_dequeue_sc
argument_list|(
name|fp
operator|->
name|br
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|BXE_FP_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
name|if_qflush
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_UNLOAD
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FreeBSD_version>= 800000 */
end_comment

begin_comment
comment|/*  * Handles any IOCTL calls from the operating system.  *  * Returns:  *   0 for success, positive value for failure.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
name|int
name|error
decl_stmt|,
name|mask
decl_stmt|,
name|reinit
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator||
name|BXE_VERBOSE_MISC
argument_list|)
expr_stmt|;
name|ifr
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|reinit
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFMTU
case|:
comment|/* Set the MTU. */
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_MISC
argument_list|,
literal|"%s(): Received SIOCSIFMTU\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* Check that the MTU setting is supported. */
if|if
condition|(
operator|(
name|ifr
operator|->
name|ifr_mtu
operator|<
name|BXE_MIN_MTU
operator|)
operator|||
operator|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|BXE_JUMBO_MTU
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|BXE_CORE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
name|BXE_CORE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|reinit
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
comment|/* Toggle the interface state up or down. */
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_MISC
argument_list|,
literal|"%s(): Received SIOCSIFFLAGS\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|BXE_CORE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Check if the interface is up. */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
comment|/* Set promiscuous/multicast flags. */
name|bxe_set_rx_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Start the HW */
name|bxe_init_locked
argument_list|(
name|sc
argument_list|,
name|LOAD_NORMAL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Bring down the interface. */
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|bxe_stop_locked
argument_list|(
name|sc
argument_list|,
name|UNLOAD_NORMAL
argument_list|)
expr_stmt|;
block|}
name|BXE_CORE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
comment|/* Add/Delete multicast addresses. */
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_MISC
argument_list|,
literal|"%s(): Received SIOCADDMULTI/SIOCDELMULTI\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|BXE_CORE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Check if the interface is up. */
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
comment|/* Set receive mode flags. */
name|bxe_set_rx_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BXE_CORE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
comment|/* Set/Get Interface media */
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_MISC
argument_list|,
literal|"%s(): Received SIOCSIFMEDIA/SIOCGIFMEDIA\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|bxe_ifmedia
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
comment|/* Set interface capability */
comment|/* Find out which capabilities have changed. */
name|mask
operator|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_MISC
argument_list|,
literal|"%s(): Received SIOCSIFCAP (mask = 0x%08X)\n"
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|uint32_t
operator|)
name|mask
argument_list|)
expr_stmt|;
name|BXE_CORE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Toggle the LRO capabilites enable flag. */
if|if
condition|(
name|mask
operator|&
name|IFCAP_LRO
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_LRO
expr_stmt|;
name|sc
operator|->
name|bxe_flags
operator|^=
name|BXE_TPA_ENABLE_FLAG
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_INFO_MISC
argument_list|,
literal|"%s(): Toggling LRO (bxe_flags = "
literal|"0x%08X).\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|bxe_flags
argument_list|)
expr_stmt|;
comment|/* LRO requires different buffer setup. */
name|reinit
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Toggle the TX checksum capabilites enable flag. */
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_MISC
argument_list|,
literal|"%s(): Toggling IFCAP_TXCSUM.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TXCSUM
expr_stmt|;
if|if
condition|(
name|IFCAP_TXCSUM
operator|&
name|ifp
operator|->
name|if_capenable
condition|)
name|ifp
operator|->
name|if_hwassist
operator|=
name|BXE_IF_HWASSIST
expr_stmt|;
else|else
name|ifp
operator|->
name|if_hwassist
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Toggle the RX checksum capabilities enable flag. */
if|if
condition|(
name|mask
operator|&
name|IFCAP_RXCSUM
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_MISC
argument_list|,
literal|"%s(): Toggling IFCAP_RXCSUM.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_RXCSUM
expr_stmt|;
if|if
condition|(
name|IFCAP_RXCSUM
operator|&
name|ifp
operator|->
name|if_capenable
condition|)
name|ifp
operator|->
name|if_hwassist
operator|=
name|BXE_IF_HWASSIST
expr_stmt|;
else|else
name|ifp
operator|->
name|if_hwassist
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Toggle VLAN_MTU capabilities enable flag. */
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_MTU
condition|)
block|{
comment|/* ToDo: Is this really true? */
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Changing VLAN_MTU not supported.\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
comment|/* Toggle VLANHWTAG capabilities enabled flag. */
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWTAGGING
condition|)
block|{
comment|/* ToDo: Is this really true? */
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Changing VLAN_HWTAGGING not supported!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
comment|/* Toggle TSO4 capabilities enabled flag. */
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO4
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_MISC
argument_list|,
literal|"%s(): Toggling IFCAP_TSO4.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TSO4
expr_stmt|;
block|}
comment|/* Toggle TSO6 capabilities enabled flag. */
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO6
condition|)
block|{
comment|/* ToDo: Add TSO6 support. */
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Changing TSO6 not supported!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
name|BXE_CORE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 		 * ToDo: Look into supporting: 		 *   VLAN_HWFILTER 		 *   VLAN_HWCSUM 		 *   VLAN_HWTSO 		 *   POLLING 		 *   WOL[_UCAST|_MCAST|_MAGIC] 		 * 		 */
break|break;
default|default:
comment|/* We don't know how to handle the IOCTL, pass it on. */
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Restart the controller with the new capabilities. */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|&&
operator|(
name|reinit
operator|!=
literal|0
operator|)
condition|)
block|{
name|BXE_CORE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_stop_locked
argument_list|(
name|sc
argument_list|,
name|UNLOAD_NORMAL
argument_list|)
expr_stmt|;
name|bxe_init_locked
argument_list|(
name|sc
argument_list|,
name|LOAD_NORMAL
argument_list|)
expr_stmt|;
name|BXE_CORE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator||
name|BXE_VERBOSE_MISC
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Gets the current value of the RX Completion Consumer index  * from the fastpath status block, updates it as necessary if  * it is pointing to a "Next Page" entry, and returns it to the  * caller.  *  * Returns:  *   The adjusted value of *fp->rx_cons_sb.  */
end_comment

begin_function
specifier|static
name|__inline
name|uint16_t
name|bxe_rx_cq_cons
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|)
block|{
specifier|volatile
name|uint16_t
name|rx_cq_cons_sb
init|=
literal|0
decl_stmt|;
name|rmb
argument_list|()
expr_stmt|;
name|rx_cq_cons_sb
operator|=
operator|(
specifier|volatile
name|uint16_t
operator|)
name|le16toh
argument_list|(
operator|*
name|fp
operator|->
name|rx_cq_cons_sb
argument_list|)
expr_stmt|;
comment|/* 	 * It is valid for the hardware's copy of the completion 	 * consumer index to be pointing at a "Next Page" entry in 	 * the completion chain but the driver prefers to assume 	 * that it is pointing at the next available CQE so we 	 * need to adjust the value accordingly. 	 */
if|if
condition|(
operator|(
name|rx_cq_cons_sb
operator|&
name|USABLE_RCQ_ENTRIES_PER_PAGE
operator|)
operator|==
name|USABLE_RCQ_ENTRIES_PER_PAGE
condition|)
name|rx_cq_cons_sb
operator|++
expr_stmt|;
return|return
operator|(
name|rx_cq_cons_sb
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|bxe_has_tx_work
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|)
block|{
name|rmb
argument_list|()
expr_stmt|;
return|return
operator|(
operator|(
operator|(
name|fp
operator|->
name|tx_pkt_prod
operator|!=
name|le16toh
argument_list|(
operator|*
name|fp
operator|->
name|tx_pkt_cons_sb
argument_list|)
operator|)
operator|||
expr|\
operator|(
name|fp
operator|->
name|tx_pkt_prod
operator|!=
name|fp
operator|->
name|tx_pkt_cons
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Checks if there are any received frames to process on the  * completion queue.  *  * Returns:  *   0 = No received frames pending, !0 = Received frames  *       pending  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|bxe_has_rx_work
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|)
block|{
name|rmb
argument_list|()
expr_stmt|;
return|return
operator|(
name|bxe_rx_cq_cons
argument_list|(
name|fp
argument_list|)
operator|!=
name|fp
operator|->
name|rx_cq_cons
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Slowpath task entry point.  *  * Returns:  *   None  */
end_comment

begin_function
specifier|static
name|void
name|bxe_task_sp
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|sp_status
decl_stmt|;
name|sc
operator|=
name|xsc
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_EXTREME_INTR
argument_list|,
literal|"%s(): pending = %d.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|pending
argument_list|)
expr_stmt|;
comment|/* Check for the source of the interrupt. */
name|sp_status
operator|=
name|bxe_update_dsb_idx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Handle any hardware attentions. */
if|if
condition|(
name|sp_status
operator|&
literal|0x1
condition|)
block|{
name|bxe_attn_int
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sp_status
operator|&=
operator|~
literal|0x1
expr_stmt|;
block|}
comment|/* CSTORM event asserted (query_stats, port delete ramrod, etc.). */
if|if
condition|(
name|sp_status
operator|&
literal|0x2
condition|)
block|{
name|sc
operator|->
name|stats_pending
operator|=
literal|0
expr_stmt|;
name|sp_status
operator|&=
operator|~
literal|0x2
expr_stmt|;
block|}
comment|/* Check for other weirdness. */
if|if
condition|(
name|sp_status
operator|!=
literal|0
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): Unexpected slowpath interrupt "
literal|"(sp_status = 0x%04X)!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sp_status
argument_list|)
expr_stmt|;
block|}
comment|/* Acknowledge the xSTORM tags and enable slowpath interrupts. */
name|bxe_ack_sb
argument_list|(
name|sc
argument_list|,
name|DEF_SB_ID
argument_list|,
name|ATTENTION_ID
argument_list|,
name|le16toh
argument_list|(
name|sc
operator|->
name|def_att_idx
argument_list|)
argument_list|,
name|IGU_INT_NOP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bxe_ack_sb
argument_list|(
name|sc
argument_list|,
name|DEF_SB_ID
argument_list|,
name|USTORM_ID
argument_list|,
name|le16toh
argument_list|(
name|sc
operator|->
name|def_u_idx
argument_list|)
argument_list|,
name|IGU_INT_NOP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bxe_ack_sb
argument_list|(
name|sc
argument_list|,
name|DEF_SB_ID
argument_list|,
name|CSTORM_ID
argument_list|,
name|le16toh
argument_list|(
name|sc
operator|->
name|def_c_idx
argument_list|)
argument_list|,
name|IGU_INT_NOP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bxe_ack_sb
argument_list|(
name|sc
argument_list|,
name|DEF_SB_ID
argument_list|,
name|XSTORM_ID
argument_list|,
name|le16toh
argument_list|(
name|sc
operator|->
name|def_x_idx
argument_list|)
argument_list|,
name|IGU_INT_NOP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bxe_ack_sb
argument_list|(
name|sc
argument_list|,
name|DEF_SB_ID
argument_list|,
name|TSTORM_ID
argument_list|,
name|le16toh
argument_list|(
name|sc
operator|->
name|def_t_idx
argument_list|)
argument_list|,
name|IGU_INT_ENABLE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Legacy interrupt entry point.  *  * Verifies that the controller generated the interrupt and  * then calls a separate routine to handle the various  * interrupt causes: link, RX, and TX.  *  * Returns:  *   None  */
end_comment

begin_function
specifier|static
name|void
name|bxe_intr_legacy
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|,
name|fp_status
decl_stmt|;
name|sc
operator|=
name|xsc
expr_stmt|;
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
literal|0
index|]
expr_stmt|;
comment|/* Don't handle any interrupts if we're not ready. */
if|if
condition|(
name|__predict_false
argument_list|(
name|sc
operator|->
name|intr_sem
operator|!=
literal|0
argument_list|)
condition|)
goto|goto
name|bxe_intr_legacy_exit
goto|;
comment|/* Bail out if the interrupt wasn't generated by our hardware. */
name|fp_status
operator|=
name|bxe_ack_int
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp_status
operator|==
literal|0
condition|)
goto|goto
name|bxe_intr_legacy_exit
goto|;
comment|/* Handle the fastpath interrupt. */
comment|/* 	 * sb_id = 0 for ustorm, 1 for cstorm. 	 * The bits returned from ack_int() are 0-15, 	 * bit 0=attention status block 	 * bit 1=fast path status block 	 * A mask of 0x2 or more = tx/rx event 	 * A mask of 1 = slow path event 	 */
name|mask
operator|=
operator|(
literal|0x2
operator|<<
name|fp
operator|->
name|sb_id
operator|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_INSANE_INTR
argument_list|,
literal|"%s(): fp_status = 0x%08X, mask = "
literal|"0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|fp_status
argument_list|,
name|mask
argument_list|)
expr_stmt|;
comment|/* CSTORM event means fastpath completion. */
if|if
condition|(
name|fp_status
operator|&
name|mask
condition|)
block|{
comment|/* This interrupt must be ours, disable further interrupts. */
name|bxe_ack_sb
argument_list|(
name|sc
argument_list|,
name|fp
operator|->
name|sb_id
argument_list|,
name|USTORM_ID
argument_list|,
literal|0
argument_list|,
name|IGU_INT_DISABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BXE_TASK
name|taskqueue_enqueue
argument_list|(
name|fp
operator|->
name|tq
argument_list|,
operator|&
name|fp
operator|->
name|task
argument_list|)
expr_stmt|;
else|#
directive|else
name|bxe_task_fp
argument_list|(
operator|(
name|void
operator|*
operator|)
name|fp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Clear this event from the status flags. */
name|fp_status
operator|&=
operator|~
name|mask
expr_stmt|;
block|}
comment|/* Handle all slow path interrupts and attentions */
if|if
condition|(
name|fp_status
operator|&
literal|0x1
condition|)
block|{
comment|/* Acknowledge and disable further slowpath interrupts. */
name|bxe_ack_sb
argument_list|(
name|sc
argument_list|,
name|DEF_SB_ID
argument_list|,
name|TSTORM_ID
argument_list|,
literal|0
argument_list|,
name|IGU_INT_DISABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BXE_TASK
comment|/* Schedule the slowpath task. */
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|sc
operator|->
name|task
argument_list|)
expr_stmt|;
else|#
directive|else
name|bxe_task_sp
argument_list|(
name|xsc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Clear this event from the status flags. */
name|fp_status
operator|&=
operator|~
literal|0x1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BXE_DEBUG
if|if
condition|(
name|fp_status
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): Unexpected fastpath status (fp_status = 0x%08X)!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|fp_status
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|DBEXIT
argument_list|(
name|BXE_EXTREME_INTR
argument_list|)
expr_stmt|;
name|bxe_intr_legacy_exit
label|:
return|return;
block|}
end_function

begin_comment
comment|/*  * Slowpath interrupt entry point.  *  * Acknowledge the interrupt and schedule a slowpath task.  *  * Returns:  *   None  */
end_comment

begin_function
specifier|static
name|void
name|bxe_intr_sp
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|xsc
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_INSANE_INTR
argument_list|,
literal|"%s(%d): Slowpath interrupt.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|curcpu
argument_list|)
expr_stmt|;
comment|/* Don't handle any interrupts if we're not ready. */
if|if
condition|(
name|__predict_false
argument_list|(
name|sc
operator|->
name|intr_sem
operator|!=
literal|0
argument_list|)
condition|)
goto|goto
name|bxe_intr_sp_exit
goto|;
comment|/* Acknowledge and disable further slowpath interrupts. */
name|bxe_ack_sb
argument_list|(
name|sc
argument_list|,
name|DEF_SB_ID
argument_list|,
name|TSTORM_ID
argument_list|,
literal|0
argument_list|,
name|IGU_INT_DISABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BXE_TASK
comment|/* Schedule the slowpath task. */
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|sc
operator|->
name|task
argument_list|)
expr_stmt|;
else|#
directive|else
name|bxe_task_sp
argument_list|(
name|xsc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bxe_intr_sp_exit
label|:
return|return;
block|}
end_function

begin_comment
comment|/*  * Fastpath interrupt entry point.  *  * Acknowledge the interrupt and schedule a fastpath task.  *  * Returns:  *   None  */
end_comment

begin_function
specifier|static
name|void
name|bxe_intr_fp
parameter_list|(
name|void
modifier|*
name|xfp
parameter_list|)
block|{
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|fp
operator|=
name|xfp
expr_stmt|;
name|sc
operator|=
name|fp
operator|->
name|sc
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_INSANE_INTR
argument_list|,
literal|"%s(%d): fp[%02d].sb_id = %d interrupt.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|curcpu
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|fp
operator|->
name|sb_id
argument_list|)
expr_stmt|;
comment|/* Don't handle any interrupts if we're not ready. */
if|if
condition|(
name|__predict_false
argument_list|(
name|sc
operator|->
name|intr_sem
operator|!=
literal|0
argument_list|)
condition|)
goto|goto
name|bxe_intr_fp_exit
goto|;
comment|/* Disable further interrupts. */
name|bxe_ack_sb
argument_list|(
name|sc
argument_list|,
name|fp
operator|->
name|sb_id
argument_list|,
name|USTORM_ID
argument_list|,
literal|0
argument_list|,
name|IGU_INT_DISABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BXE_TASK
name|taskqueue_enqueue
argument_list|(
name|fp
operator|->
name|tq
argument_list|,
operator|&
name|fp
operator|->
name|task
argument_list|)
expr_stmt|;
else|#
directive|else
name|bxe_task_fp
argument_list|(
name|xfp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bxe_intr_fp_exit
label|:
return|return;
block|}
end_function

begin_comment
comment|/*  * Fastpath task entry point.  *  * Handle any pending transmit or receive events.  *  * Returns:  *   None  */
end_comment

begin_function
specifier|static
name|void
name|bxe_task_fp
parameter_list|(
name|void
modifier|*
name|xfp
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|fp
operator|=
name|xfp
expr_stmt|;
name|sc
operator|=
name|fp
operator|->
name|sc
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_EXTREME_INTR
argument_list|,
literal|"%s(%d): Fastpath task on fp[%02d]"
literal|".sb_id = %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|curcpu
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|fp
operator|->
name|sb_id
argument_list|)
expr_stmt|;
comment|/* Update the fast path indices */
name|bxe_update_fpsb_idx
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* Service any completed TX frames. */
if|if
condition|(
name|bxe_has_tx_work
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|BXE_FP_LOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|bxe_txeof
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|BXE_FP_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
comment|/* Service any completed RX frames. */
name|rmb
argument_list|()
expr_stmt|;
name|bxe_rxeof
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* Acknowledge the fastpath status block indices. */
name|bxe_ack_sb
argument_list|(
name|sc
argument_list|,
name|fp
operator|->
name|sb_id
argument_list|,
name|USTORM_ID
argument_list|,
name|fp
operator|->
name|fp_u_idx
argument_list|,
name|IGU_INT_NOP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bxe_ack_sb
argument_list|(
name|sc
argument_list|,
name|fp
operator|->
name|sb_id
argument_list|,
name|CSTORM_ID
argument_list|,
name|fp
operator|->
name|fp_c_idx
argument_list|,
name|IGU_INT_ENABLE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Clears the fastpath (per-queue) status block.  *  * Returns:  *   None  */
end_comment

begin_function
specifier|static
name|void
name|bxe_zero_sb
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|sb_id
parameter_list|)
block|{
name|int
name|port
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator||
name|BXE_VERBOSE_INTR
argument_list|)
expr_stmt|;
name|port
operator|=
name|BP_PORT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* "CSTORM" */
name|bxe_init_fill
argument_list|(
name|sc
argument_list|,
name|CSEM_REG_FAST_MEMORY
operator|+
name|CSTORM_SB_HOST_STATUS_BLOCK_U_OFFSET
argument_list|(
name|port
argument_list|,
name|sb_id
argument_list|)
argument_list|,
literal|0
argument_list|,
name|CSTORM_SB_STATUS_BLOCK_U_SIZE
operator|/
literal|4
argument_list|)
expr_stmt|;
name|bxe_init_fill
argument_list|(
name|sc
argument_list|,
name|CSEM_REG_FAST_MEMORY
operator|+
name|CSTORM_SB_HOST_STATUS_BLOCK_C_OFFSET
argument_list|(
name|port
argument_list|,
name|sb_id
argument_list|)
argument_list|,
literal|0
argument_list|,
name|CSTORM_SB_STATUS_BLOCK_C_SIZE
operator|/
literal|4
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator||
name|BXE_VERBOSE_INTR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the fastpath (per queue) status block.  *  * Returns:  *   None  */
end_comment

begin_function
specifier|static
name|void
name|bxe_init_sb
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|host_status_block
modifier|*
name|sb
parameter_list|,
name|bus_addr_t
name|mapping
parameter_list|,
name|int
name|sb_id
parameter_list|)
block|{
name|uint64_t
name|section
decl_stmt|;
name|int
name|func
decl_stmt|,
name|index
decl_stmt|,
name|port
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator||
name|BXE_VERBOSE_INTR
argument_list|)
expr_stmt|;
name|port
operator|=
name|BP_PORT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|func
operator|=
name|BP_FUNC
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
operator|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator||
name|BXE_VERBOSE_INTR
operator|)
argument_list|,
literal|"%s(): Initializing sb_id = %d on port %d, function %d.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sb_id
argument_list|,
name|port
argument_list|,
name|func
argument_list|)
expr_stmt|;
comment|/* Setup the USTORM status block. */
name|section
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|mapping
operator|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|host_status_block
argument_list|,
name|u_status_block
argument_list|)
expr_stmt|;
name|sb
operator|->
name|u_status_block
operator|.
name|status_block_id
operator|=
name|sb_id
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_CSTORM_INTMEM
operator|+
name|CSTORM_SB_HOST_SB_ADDR_U_OFFSET
argument_list|(
name|port
argument_list|,
name|sb_id
argument_list|)
argument_list|,
name|U64_LO
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_CSTORM_INTMEM
operator|+
operator|(
operator|(
name|CSTORM_SB_HOST_SB_ADDR_U_OFFSET
argument_list|(
name|port
argument_list|,
name|sb_id
argument_list|)
operator|)
operator|+
literal|4
operator|)
argument_list|,
name|U64_HI
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
name|REG_WR8
argument_list|(
name|sc
argument_list|,
name|BAR_CSTORM_INTMEM
operator|+
name|FP_USB_FUNC_OFF
operator|+
name|CSTORM_SB_HOST_STATUS_BLOCK_U_OFFSET
argument_list|(
name|port
argument_list|,
name|sb_id
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|HC_USTORM_SB_NUM_INDICES
condition|;
name|index
operator|++
control|)
name|REG_WR16
argument_list|(
name|sc
argument_list|,
name|BAR_CSTORM_INTMEM
operator|+
name|CSTORM_SB_HC_DISABLE_U_OFFSET
argument_list|(
name|port
argument_list|,
name|sb_id
argument_list|,
name|index
argument_list|)
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
comment|/* Setup the CSTORM status block. */
name|section
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|mapping
operator|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|host_status_block
argument_list|,
name|c_status_block
argument_list|)
expr_stmt|;
name|sb
operator|->
name|c_status_block
operator|.
name|status_block_id
operator|=
name|sb_id
expr_stmt|;
comment|/* Write the status block address to CSTORM. Order is important! */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_CSTORM_INTMEM
operator|+
name|CSTORM_SB_HOST_SB_ADDR_C_OFFSET
argument_list|(
name|port
argument_list|,
name|sb_id
argument_list|)
argument_list|,
name|U64_LO
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_CSTORM_INTMEM
operator|+
operator|(
operator|(
name|CSTORM_SB_HOST_SB_ADDR_C_OFFSET
argument_list|(
name|port
argument_list|,
name|sb_id
argument_list|)
operator|)
operator|+
literal|4
operator|)
argument_list|,
name|U64_HI
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
name|REG_WR8
argument_list|(
name|sc
argument_list|,
name|BAR_CSTORM_INTMEM
operator|+
name|FP_CSB_FUNC_OFF
operator|+
name|CSTORM_SB_HOST_STATUS_BLOCK_C_OFFSET
argument_list|(
name|port
argument_list|,
name|sb_id
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|HC_CSTORM_SB_NUM_INDICES
condition|;
name|index
operator|++
control|)
name|REG_WR16
argument_list|(
name|sc
argument_list|,
name|BAR_CSTORM_INTMEM
operator|+
name|CSTORM_SB_HC_DISABLE_C_OFFSET
argument_list|(
name|port
argument_list|,
name|sb_id
argument_list|,
name|index
argument_list|)
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
comment|/* Enable interrupts. */
name|bxe_ack_sb
argument_list|(
name|sc
argument_list|,
name|sb_id
argument_list|,
name|CSTORM_ID
argument_list|,
literal|0
argument_list|,
name|IGU_INT_ENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator||
name|BXE_VERBOSE_INTR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Clears the default status block.  *  * Returns:  *   None  */
end_comment

begin_function
specifier|static
name|void
name|bxe_zero_def_sb
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|func
decl_stmt|;
name|func
operator|=
name|BP_FUNC
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator||
name|BXE_VERBOSE_INTR
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
operator|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator||
name|BXE_VERBOSE_INTR
operator|)
argument_list|,
literal|"%s(): Clearing default status block on function %d.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|func
argument_list|)
expr_stmt|;
comment|/* Fill the STORM's copy of the default status block with 0. */
name|bxe_init_fill
argument_list|(
name|sc
argument_list|,
name|TSEM_REG_FAST_MEMORY
operator|+
name|TSTORM_DEF_SB_HOST_STATUS_BLOCK_OFFSET
argument_list|(
name|func
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tstorm_def_status_block
argument_list|)
operator|/
literal|4
argument_list|)
expr_stmt|;
name|bxe_init_fill
argument_list|(
name|sc
argument_list|,
name|CSEM_REG_FAST_MEMORY
operator|+
name|CSTORM_DEF_SB_HOST_STATUS_BLOCK_U_OFFSET
argument_list|(
name|func
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cstorm_def_status_block_u
argument_list|)
operator|/
literal|4
argument_list|)
expr_stmt|;
name|bxe_init_fill
argument_list|(
name|sc
argument_list|,
name|CSEM_REG_FAST_MEMORY
operator|+
name|CSTORM_DEF_SB_HOST_STATUS_BLOCK_C_OFFSET
argument_list|(
name|func
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cstorm_def_status_block_c
argument_list|)
operator|/
literal|4
argument_list|)
expr_stmt|;
name|bxe_init_fill
argument_list|(
name|sc
argument_list|,
name|XSEM_REG_FAST_MEMORY
operator|+
name|XSTORM_DEF_SB_HOST_STATUS_BLOCK_OFFSET
argument_list|(
name|func
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|xstorm_def_status_block
argument_list|)
operator|/
literal|4
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator||
name|BXE_VERBOSE_INTR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize default status block.  *  * Returns:  *   None  */
end_comment

begin_function
specifier|static
name|void
name|bxe_init_def_sb
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|host_def_status_block
modifier|*
name|def_sb
parameter_list|,
name|bus_addr_t
name|mapping
parameter_list|,
name|int
name|sb_id
parameter_list|)
block|{
name|uint64_t
name|section
decl_stmt|;
name|int
name|func
decl_stmt|,
name|index
decl_stmt|,
name|port
decl_stmt|,
name|reg_offset
decl_stmt|,
name|val
decl_stmt|;
name|port
operator|=
name|BP_PORT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|func
operator|=
name|BP_FUNC
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator||
name|BXE_VERBOSE_INTR
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
operator|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator||
name|BXE_VERBOSE_INTR
operator|)
argument_list|,
literal|"%s(): Initializing default status block on port %d, function %d.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|port
argument_list|,
name|func
argument_list|)
expr_stmt|;
comment|/* Setup the default status block (DSB). */
name|section
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|mapping
operator|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|host_def_status_block
argument_list|,
name|atten_status_block
argument_list|)
expr_stmt|;
name|def_sb
operator|->
name|atten_status_block
operator|.
name|status_block_id
operator|=
name|sb_id
expr_stmt|;
name|sc
operator|->
name|attn_state
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|def_att_idx
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Read routing configuration for attn signal 	 * output of groups. Currently, only groups 	 * 0 through 3 are wired. 	 */
name|reg_offset
operator|=
name|port
condition|?
name|MISC_REG_AEU_ENABLE1_FUNC_1_OUT_0
else|:
name|MISC_REG_AEU_ENABLE1_FUNC_0_OUT_0
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|MAX_DYNAMIC_ATTN_GRPS
condition|;
name|index
operator|++
control|)
block|{
name|sc
operator|->
name|attn_group
index|[
name|index
index|]
operator|.
name|sig
index|[
literal|0
index|]
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|reg_offset
operator|+
literal|0x10
operator|*
name|index
argument_list|)
expr_stmt|;
name|sc
operator|->
name|attn_group
index|[
name|index
index|]
operator|.
name|sig
index|[
literal|1
index|]
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|reg_offset
operator|+
literal|0x10
operator|*
name|index
operator|+
literal|0x4
argument_list|)
expr_stmt|;
name|sc
operator|->
name|attn_group
index|[
name|index
index|]
operator|.
name|sig
index|[
literal|2
index|]
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|reg_offset
operator|+
literal|0x10
operator|*
name|index
operator|+
literal|0x8
argument_list|)
expr_stmt|;
name|sc
operator|->
name|attn_group
index|[
name|index
index|]
operator|.
name|sig
index|[
literal|3
index|]
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|reg_offset
operator|+
literal|0x10
operator|*
name|index
operator|+
literal|0xc
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
operator|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator||
name|BXE_VERBOSE_INTR
operator|)
argument_list|,
literal|"%s(): attn_group[%d] = 0x%08X 0x%08X 0x%08x 0X%08x\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|index
argument_list|,
name|sc
operator|->
name|attn_group
index|[
name|index
index|]
operator|.
name|sig
index|[
literal|0
index|]
argument_list|,
name|sc
operator|->
name|attn_group
index|[
name|index
index|]
operator|.
name|sig
index|[
literal|1
index|]
argument_list|,
name|sc
operator|->
name|attn_group
index|[
name|index
index|]
operator|.
name|sig
index|[
literal|2
index|]
argument_list|,
name|sc
operator|->
name|attn_group
index|[
name|index
index|]
operator|.
name|sig
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
name|reg_offset
operator|=
name|port
condition|?
name|HC_REG_ATTN_MSG1_ADDR_L
else|:
name|HC_REG_ATTN_MSG0_ADDR_L
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|reg_offset
argument_list|,
name|U64_LO
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|reg_offset
operator|+
literal|4
argument_list|,
name|U64_HI
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
name|reg_offset
operator|=
name|port
condition|?
name|HC_REG_ATTN_NUM_P1
else|:
name|HC_REG_ATTN_NUM_P0
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|reg_offset
argument_list|)
expr_stmt|;
name|val
operator||=
name|sb_id
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|reg_offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* USTORM */
name|section
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|mapping
operator|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|host_def_status_block
argument_list|,
name|u_def_status_block
argument_list|)
expr_stmt|;
name|def_sb
operator|->
name|u_def_status_block
operator|.
name|status_block_id
operator|=
name|sb_id
expr_stmt|;
name|sc
operator|->
name|def_u_idx
operator|=
literal|0
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_CSTORM_INTMEM
operator|+
name|CSTORM_DEF_SB_HOST_SB_ADDR_U_OFFSET
argument_list|(
name|func
argument_list|)
argument_list|,
name|U64_LO
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_CSTORM_INTMEM
operator|+
operator|(
operator|(
name|CSTORM_DEF_SB_HOST_SB_ADDR_U_OFFSET
argument_list|(
name|func
argument_list|)
operator|)
operator|+
literal|4
operator|)
argument_list|,
name|U64_HI
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
name|REG_WR8
argument_list|(
name|sc
argument_list|,
name|BAR_CSTORM_INTMEM
operator|+
name|DEF_USB_FUNC_OFF
operator|+
name|CSTORM_DEF_SB_HOST_STATUS_BLOCK_U_OFFSET
argument_list|(
name|func
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|HC_USTORM_DEF_SB_NUM_INDICES
condition|;
name|index
operator|++
control|)
name|REG_WR16
argument_list|(
name|sc
argument_list|,
name|BAR_CSTORM_INTMEM
operator|+
name|CSTORM_DEF_SB_HC_DISABLE_U_OFFSET
argument_list|(
name|func
argument_list|,
name|index
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* CSTORM */
name|section
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|mapping
operator|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|host_def_status_block
argument_list|,
name|c_def_status_block
argument_list|)
expr_stmt|;
name|def_sb
operator|->
name|c_def_status_block
operator|.
name|status_block_id
operator|=
name|sb_id
expr_stmt|;
name|sc
operator|->
name|def_c_idx
operator|=
literal|0
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_CSTORM_INTMEM
operator|+
name|CSTORM_DEF_SB_HOST_SB_ADDR_C_OFFSET
argument_list|(
name|func
argument_list|)
argument_list|,
name|U64_LO
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_CSTORM_INTMEM
operator|+
operator|(
operator|(
name|CSTORM_DEF_SB_HOST_SB_ADDR_C_OFFSET
argument_list|(
name|func
argument_list|)
operator|)
operator|+
literal|4
operator|)
argument_list|,
name|U64_HI
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
name|REG_WR8
argument_list|(
name|sc
argument_list|,
name|BAR_CSTORM_INTMEM
operator|+
name|DEF_CSB_FUNC_OFF
operator|+
name|CSTORM_DEF_SB_HOST_STATUS_BLOCK_C_OFFSET
argument_list|(
name|func
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|HC_CSTORM_DEF_SB_NUM_INDICES
condition|;
name|index
operator|++
control|)
name|REG_WR16
argument_list|(
name|sc
argument_list|,
name|BAR_CSTORM_INTMEM
operator|+
name|CSTORM_DEF_SB_HC_DISABLE_C_OFFSET
argument_list|(
name|func
argument_list|,
name|index
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* TSTORM */
name|section
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|mapping
operator|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|host_def_status_block
argument_list|,
name|t_def_status_block
argument_list|)
expr_stmt|;
name|def_sb
operator|->
name|t_def_status_block
operator|.
name|status_block_id
operator|=
name|sb_id
expr_stmt|;
name|sc
operator|->
name|def_t_idx
operator|=
literal|0
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_TSTORM_INTMEM
operator|+
name|TSTORM_DEF_SB_HOST_SB_ADDR_OFFSET
argument_list|(
name|func
argument_list|)
argument_list|,
name|U64_LO
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_TSTORM_INTMEM
operator|+
operator|(
operator|(
name|TSTORM_DEF_SB_HOST_SB_ADDR_OFFSET
argument_list|(
name|func
argument_list|)
operator|)
operator|+
literal|4
operator|)
argument_list|,
name|U64_HI
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
name|REG_WR8
argument_list|(
name|sc
argument_list|,
name|BAR_TSTORM_INTMEM
operator|+
name|DEF_TSB_FUNC_OFF
operator|+
name|TSTORM_DEF_SB_HOST_STATUS_BLOCK_OFFSET
argument_list|(
name|func
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|HC_TSTORM_DEF_SB_NUM_INDICES
condition|;
name|index
operator|++
control|)
name|REG_WR16
argument_list|(
name|sc
argument_list|,
name|BAR_TSTORM_INTMEM
operator|+
name|TSTORM_DEF_SB_HC_DISABLE_OFFSET
argument_list|(
name|func
argument_list|,
name|index
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* XSTORM */
name|section
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|mapping
operator|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|host_def_status_block
argument_list|,
name|x_def_status_block
argument_list|)
expr_stmt|;
name|def_sb
operator|->
name|x_def_status_block
operator|.
name|status_block_id
operator|=
name|sb_id
expr_stmt|;
name|sc
operator|->
name|def_x_idx
operator|=
literal|0
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_XSTORM_INTMEM
operator|+
name|XSTORM_DEF_SB_HOST_SB_ADDR_OFFSET
argument_list|(
name|func
argument_list|)
argument_list|,
name|U64_LO
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_XSTORM_INTMEM
operator|+
operator|(
operator|(
name|XSTORM_DEF_SB_HOST_SB_ADDR_OFFSET
argument_list|(
name|func
argument_list|)
operator|)
operator|+
literal|4
operator|)
argument_list|,
name|U64_HI
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
name|REG_WR8
argument_list|(
name|sc
argument_list|,
name|BAR_XSTORM_INTMEM
operator|+
name|DEF_XSB_FUNC_OFF
operator|+
name|XSTORM_DEF_SB_HOST_STATUS_BLOCK_OFFSET
argument_list|(
name|func
argument_list|)
argument_list|,
name|func
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|HC_XSTORM_DEF_SB_NUM_INDICES
condition|;
name|index
operator|++
control|)
name|REG_WR16
argument_list|(
name|sc
argument_list|,
name|BAR_XSTORM_INTMEM
operator|+
name|XSTORM_DEF_SB_HC_DISABLE_OFFSET
argument_list|(
name|func
argument_list|,
name|index
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|stats_pending
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|set_mac_pending
operator|=
literal|0
expr_stmt|;
name|bxe_ack_sb
argument_list|(
name|sc
argument_list|,
name|sb_id
argument_list|,
name|CSTORM_ID
argument_list|,
literal|0
argument_list|,
name|IGU_INT_ENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator||
name|BXE_VERBOSE_INTR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update interrupt coalescing parameters.  *  * Returns:  *   None  */
end_comment

begin_function
specifier|static
name|void
name|bxe_update_coalesce
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|port
decl_stmt|,
name|sb_id
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
name|port
operator|=
name|BP_PORT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Cycle through each fastpath queue and set the coalescing values. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|sb_id
operator|=
name|sc
operator|->
name|fp
index|[
name|i
index|]
operator|.
name|sb_id
expr_stmt|;
comment|/* Receive interrupt coalescing is done on USTORM. */
name|REG_WR8
argument_list|(
name|sc
argument_list|,
name|BAR_CSTORM_INTMEM
operator|+
name|CSTORM_SB_HC_TIMEOUT_U_OFFSET
argument_list|(
name|port
argument_list|,
name|sb_id
argument_list|,
name|U_SB_ETH_RX_CQ_INDEX
argument_list|)
argument_list|,
name|sc
operator|->
name|rx_ticks
operator|/
operator|(
name|BXE_BTR
operator|*
literal|4
operator|)
argument_list|)
expr_stmt|;
name|REG_WR16
argument_list|(
name|sc
argument_list|,
name|BAR_CSTORM_INTMEM
operator|+
name|CSTORM_SB_HC_DISABLE_U_OFFSET
argument_list|(
name|port
argument_list|,
name|sb_id
argument_list|,
name|U_SB_ETH_RX_CQ_INDEX
argument_list|)
argument_list|,
operator|(
name|sc
operator|->
name|rx_ticks
operator|/
operator|(
name|BXE_BTR
operator|*
literal|4
operator|)
operator|)
condition|?
literal|0
else|:
literal|1
argument_list|)
expr_stmt|;
comment|/* Transmit interrupt coalescing is done on CSTORM. */
name|REG_WR8
argument_list|(
name|sc
argument_list|,
name|BAR_CSTORM_INTMEM
operator|+
name|CSTORM_SB_HC_TIMEOUT_C_OFFSET
argument_list|(
name|port
argument_list|,
name|sb_id
argument_list|,
name|C_SB_ETH_TX_CQ_INDEX
argument_list|)
argument_list|,
name|sc
operator|->
name|tx_ticks
operator|/
operator|(
name|BXE_BTR
operator|*
literal|4
operator|)
argument_list|)
expr_stmt|;
name|REG_WR16
argument_list|(
name|sc
argument_list|,
name|BAR_CSTORM_INTMEM
operator|+
name|CSTORM_SB_HC_DISABLE_C_OFFSET
argument_list|(
name|port
argument_list|,
name|sb_id
argument_list|,
name|C_SB_ETH_TX_CQ_INDEX
argument_list|)
argument_list|,
operator|(
name|sc
operator|->
name|tx_ticks
operator|/
operator|(
name|BXE_BTR
operator|*
literal|4
operator|)
operator|)
condition|?
literal|0
else|:
literal|1
argument_list|)
expr_stmt|;
block|}
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate an mbuf and assign it to the TPA pool.  *  * Returns:  *   0 = Success, !0 = Failure  *  * Modifies:  *   fp->tpa_mbuf_ptr[queue]  *   fp->tpa_mbuf_map[queue]  *   fp->tpa_mbuf_segs[queue]  */
end_comment

begin_function
specifier|static
name|int
name|bxe_alloc_tpa_mbuf
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|int
name|queue
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
literal|1
index|]
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|nsegs
decl_stmt|,
name|rc
decl_stmt|;
name|sc
operator|=
name|fp
operator|->
name|sc
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_INSANE_TPA
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
name|DBRUNIF
argument_list|(
operator|(
name|fp
operator|->
name|disable_tpa
operator|==
name|TRUE
operator|)
argument_list|,
name|BXE_PRINTF
argument_list|(
literal|"%s(): fp[%02d] TPA disabled!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|fp
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BXE_DEBUG
comment|/* Simulate an mbuf allocation failure. */
if|if
condition|(
name|DB_RANDOMTRUE
argument_list|(
name|bxe_debug_mbuf_allocation_failure
argument_list|)
condition|)
block|{
name|sc
operator|->
name|debug_sim_mbuf_alloc_failed
operator|++
expr_stmt|;
name|fp
operator|->
name|mbuf_tpa_alloc_failed
operator|++
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bxe_alloc_tpa_mbuf_exit
goto|;
block|}
endif|#
directive|endif
comment|/* Allocate the new TPA mbuf. */
name|m
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|sc
operator|->
name|mbuf_alloc_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|fp
operator|->
name|mbuf_tpa_alloc_failed
operator|++
expr_stmt|;
name|rc
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bxe_alloc_tpa_mbuf_exit
goto|;
block|}
name|DBRUN
argument_list|(
name|fp
operator|->
name|tpa_mbuf_alloc
operator|++
argument_list|)
expr_stmt|;
comment|/* Initialize the mbuf buffer length. */
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|sc
operator|->
name|mbuf_alloc_size
expr_stmt|;
ifdef|#
directive|ifdef
name|BXE_DEBUG
comment|/* Simulate an mbuf mapping failure. */
if|if
condition|(
name|DB_RANDOMTRUE
argument_list|(
name|bxe_debug_dma_map_addr_failure
argument_list|)
condition|)
block|{
name|sc
operator|->
name|debug_sim_mbuf_map_failed
operator|++
expr_stmt|;
name|fp
operator|->
name|mbuf_tpa_mapping_failed
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|DBRUN
argument_list|(
name|fp
operator|->
name|tpa_mbuf_alloc
operator|--
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bxe_alloc_tpa_mbuf_exit
goto|;
block|}
endif|#
directive|endif
comment|/* Map the TPA mbuf into non-paged pool. */
name|rc
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|fp
operator|->
name|tpa_mbuf_spare_map
argument_list|,
name|m
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|rc
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|fp
operator|->
name|mbuf_tpa_mapping_failed
operator|++
expr_stmt|;
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|DBRUN
argument_list|(
name|fp
operator|->
name|tpa_mbuf_alloc
operator|--
argument_list|)
expr_stmt|;
goto|goto
name|bxe_alloc_tpa_mbuf_exit
goto|;
block|}
comment|/* All mubfs must map to a single segment. */
name|KASSERT
argument_list|(
name|nsegs
operator|==
literal|1
argument_list|,
operator|(
literal|"%s(): Too many segments (%d) returned!"
operator|,
name|__FUNCTION__
operator|,
name|nsegs
operator|)
argument_list|)
expr_stmt|;
comment|/* Release any existing TPA mbuf mapping. */
if|if
condition|(
name|fp
operator|->
name|tpa_mbuf_map
index|[
name|queue
index|]
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|fp
operator|->
name|tpa_mbuf_map
index|[
name|queue
index|]
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|fp
operator|->
name|tpa_mbuf_map
index|[
name|queue
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Save the mbuf and mapping info for the TPA mbuf. */
name|map
operator|=
name|fp
operator|->
name|tpa_mbuf_map
index|[
name|queue
index|]
expr_stmt|;
name|fp
operator|->
name|tpa_mbuf_map
index|[
name|queue
index|]
operator|=
name|fp
operator|->
name|tpa_mbuf_spare_map
expr_stmt|;
name|fp
operator|->
name|tpa_mbuf_spare_map
operator|=
name|map
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|fp
operator|->
name|tpa_mbuf_map
index|[
name|queue
index|]
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|fp
operator|->
name|tpa_mbuf_ptr
index|[
name|queue
index|]
operator|=
name|m
expr_stmt|;
name|fp
operator|->
name|tpa_mbuf_segs
index|[
name|queue
index|]
operator|=
name|segs
index|[
literal|0
index|]
expr_stmt|;
name|bxe_alloc_tpa_mbuf_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_INSANE_TPA
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate mbufs for a fastpath TPA pool.  *  * Returns:  *   0 = Success, !0 = Failure.  *  * Modifies:  *   fp->tpa_state[]  *   fp->disable_tpa  */
end_comment

begin_function
specifier|static
name|int
name|bxe_fill_tpa_pool
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|max_agg_queues
decl_stmt|,
name|queue
decl_stmt|,
name|rc
decl_stmt|;
name|sc
operator|=
name|fp
operator|->
name|sc
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|TPA_ENABLED
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|fp
operator|->
name|disable_tpa
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|bxe_fill_tpa_pool_exit
goto|;
block|}
name|max_agg_queues
operator|=
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|?
name|ETH_MAX_AGGREGATION_QUEUES_E1
else|:
name|ETH_MAX_AGGREGATION_QUEUES_E1H
expr_stmt|;
comment|/* Assume the fill operation worked. */
name|fp
operator|->
name|disable_tpa
operator|=
name|FALSE
expr_stmt|;
comment|/* Fill the TPA pool. */
for|for
control|(
name|queue
operator|=
literal|0
init|;
name|queue
operator|<
name|max_agg_queues
condition|;
name|queue
operator|++
control|)
block|{
name|rc
operator|=
name|bxe_alloc_tpa_mbuf
argument_list|(
name|fp
argument_list|,
name|queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): fp[%02d] TPA disabled!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|fp
operator|->
name|index
argument_list|)
expr_stmt|;
name|fp
operator|->
name|disable_tpa
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|fp
operator|->
name|tpa_state
index|[
name|queue
index|]
operator|=
name|BXE_TPA_STATE_STOP
expr_stmt|;
block|}
name|bxe_fill_tpa_pool_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free all mbufs from a fastpath TPA pool.  *  * Returns:  *   None  *  * Modifies:  *   fp->tpa_mbuf_ptr[]  *   fp->tpa_mbuf_map[]  *   fp->tpa_mbuf_alloc  */
end_comment

begin_function
specifier|static
name|void
name|bxe_free_tpa_pool
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|max_agg_queues
decl_stmt|;
name|sc
operator|=
name|fp
operator|->
name|sc
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_INSANE_LOAD
operator||
name|BXE_INSANE_UNLOAD
operator||
name|BXE_INSANE_TPA
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|rx_mbuf_tag
operator|==
name|NULL
condition|)
goto|goto
name|bxe_free_tpa_pool_exit
goto|;
name|max_agg_queues
operator|=
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
condition|?
name|ETH_MAX_AGGREGATION_QUEUES_E1H
else|:
name|ETH_MAX_AGGREGATION_QUEUES_E1
expr_stmt|;
comment|/* Release all mbufs and and all DMA maps in the TPA pool. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_agg_queues
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fp
operator|->
name|tpa_mbuf_map
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|fp
operator|->
name|tpa_mbuf_map
index|[
name|i
index|]
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|fp
operator|->
name|tpa_mbuf_map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|->
name|tpa_mbuf_ptr
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|fp
operator|->
name|tpa_mbuf_ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|DBRUN
argument_list|(
name|fp
operator|->
name|tpa_mbuf_alloc
operator|--
argument_list|)
expr_stmt|;
name|fp
operator|->
name|tpa_mbuf_ptr
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|bxe_free_tpa_pool_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_INSANE_LOAD
operator||
name|BXE_INSANE_UNLOAD
operator||
name|BXE_INSANE_TPA
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate an mbuf and assign it to the receive scatter gather chain.  * The caller must take care to save a copy of the existing mbuf in the  * SG mbuf chain.  *  * Returns:  *   0 = Success, !0= Failure.  *  * Modifies:  *   fp->sg_chain[index]  *   fp->rx_sge_buf_ptr[index]  *   fp->rx_sge_buf_map[index]  *   fp->rx_sge_spare_map  */
end_comment

begin_function
specifier|static
name|int
name|bxe_alloc_rx_sge_mbuf
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|uint16_t
name|index
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|eth_rx_sge
modifier|*
name|sge
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
literal|1
index|]
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|nsegs
decl_stmt|,
name|rc
decl_stmt|;
name|sc
operator|=
name|fp
operator|->
name|sc
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_INSANE_TPA
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|BXE_DEBUG
comment|/* Simulate an mbuf allocation failure. */
if|if
condition|(
name|DB_RANDOMTRUE
argument_list|(
name|bxe_debug_mbuf_allocation_failure
argument_list|)
condition|)
block|{
name|sc
operator|->
name|debug_sim_mbuf_alloc_failed
operator|++
expr_stmt|;
name|fp
operator|->
name|mbuf_sge_alloc_failed
operator|++
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bxe_alloc_rx_sge_mbuf_exit
goto|;
block|}
endif|#
directive|endif
comment|/* Allocate a new SGE mbuf. */
name|m
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|SGE_PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|fp
operator|->
name|mbuf_sge_alloc_failed
operator|++
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bxe_alloc_rx_sge_mbuf_exit
goto|;
block|}
name|DBRUN
argument_list|(
name|fp
operator|->
name|sge_mbuf_alloc
operator|++
argument_list|)
expr_stmt|;
comment|/* Initialize the mbuf buffer length. */
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|SGE_PAGE_SIZE
expr_stmt|;
ifdef|#
directive|ifdef
name|BXE_DEBUG
comment|/* Simulate an mbuf mapping failure. */
if|if
condition|(
name|DB_RANDOMTRUE
argument_list|(
name|bxe_debug_dma_map_addr_failure
argument_list|)
condition|)
block|{
name|sc
operator|->
name|debug_sim_mbuf_map_failed
operator|++
expr_stmt|;
name|fp
operator|->
name|mbuf_sge_mapping_failed
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|DBRUN
argument_list|(
name|fp
operator|->
name|sge_mbuf_alloc
operator|--
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bxe_alloc_rx_sge_mbuf_exit
goto|;
block|}
endif|#
directive|endif
comment|/* Map the SGE mbuf into non-paged pool. */
name|rc
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|fp
operator|->
name|rx_sge_buf_tag
argument_list|,
name|fp
operator|->
name|rx_sge_spare_map
argument_list|,
name|m
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|rc
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|fp
operator|->
name|mbuf_sge_mapping_failed
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|DBRUN
argument_list|(
name|fp
operator|->
name|sge_mbuf_alloc
operator|--
argument_list|)
expr_stmt|;
goto|goto
name|bxe_alloc_rx_sge_mbuf_exit
goto|;
block|}
comment|/* All mubfs must map to a single segment. */
name|KASSERT
argument_list|(
name|nsegs
operator|==
literal|1
argument_list|,
operator|(
literal|"%s(): Too many segments (%d) returned!"
operator|,
name|__FUNCTION__
operator|,
name|nsegs
operator|)
argument_list|)
expr_stmt|;
comment|/* Unload any existing SGE mbuf mapping. */
if|if
condition|(
name|fp
operator|->
name|rx_sge_buf_map
index|[
name|index
index|]
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|fp
operator|->
name|rx_sge_buf_tag
argument_list|,
name|fp
operator|->
name|rx_sge_buf_map
index|[
name|index
index|]
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|fp
operator|->
name|rx_sge_buf_tag
argument_list|,
name|fp
operator|->
name|rx_sge_buf_map
index|[
name|index
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Add the new SGE mbuf to the SGE ring. */
name|map
operator|=
name|fp
operator|->
name|rx_sge_buf_map
index|[
name|index
index|]
expr_stmt|;
name|fp
operator|->
name|rx_sge_buf_map
index|[
name|index
index|]
operator|=
name|fp
operator|->
name|rx_sge_spare_map
expr_stmt|;
name|fp
operator|->
name|rx_sge_spare_map
operator|=
name|map
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|fp
operator|->
name|rx_sge_buf_tag
argument_list|,
name|fp
operator|->
name|rx_sge_buf_map
index|[
name|index
index|]
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|fp
operator|->
name|rx_sge_buf_ptr
index|[
name|index
index|]
operator|=
name|m
expr_stmt|;
name|sge
operator|=
operator|&
name|fp
operator|->
name|sg_chain
index|[
name|index
index|]
expr_stmt|;
name|sge
operator|->
name|addr_hi
operator|=
name|htole32
argument_list|(
name|U64_HI
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|sge
operator|->
name|addr_lo
operator|=
name|htole32
argument_list|(
name|U64_LO
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|bxe_alloc_rx_sge_mbuf_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_INSANE_TPA
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate mbufs for a SGE chain.  *  * Returns:  *   0 = Success, !0 = Failure.  *  * Modifies:  *   fp->disable_tpa  *   fp->rx_sge_prod  */
end_comment

begin_function
specifier|static
name|int
name|bxe_fill_sg_chain
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|uint16_t
name|index
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|sc
operator|=
name|fp
operator|->
name|sc
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|TPA_ENABLED
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|fp
operator|->
name|disable_tpa
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|bxe_fill_sg_chain_exit
goto|;
block|}
comment|/* Assume the fill operation works. */
name|fp
operator|->
name|disable_tpa
operator|=
name|FALSE
expr_stmt|;
comment|/* Fill the RX SGE chain. */
name|index
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|USABLE_RX_SGE
condition|;
name|i
operator|++
control|)
block|{
name|rc
operator|=
name|bxe_alloc_rx_sge_mbuf
argument_list|(
name|fp
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): fp[%02d] SGE memory allocation failure!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|fp
operator|->
name|index
argument_list|)
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|disable_tpa
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|index
operator|=
name|NEXT_SGE_IDX
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
comment|/* Update the driver's copy of the RX SGE producer index. */
name|fp
operator|->
name|rx_sge_prod
operator|=
name|index
expr_stmt|;
name|bxe_fill_sg_chain_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free all elements from the receive scatter gather chain.  *  * Returns:  *   None  *  * Modifies:  *   fp->rx_sge_buf_ptr[]  *   fp->rx_sge_buf_map[]  *   fp->sge_mbuf_alloc  */
end_comment

begin_function
specifier|static
name|void
name|bxe_free_sg_chain
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|fp
operator|->
name|sc
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_INSANE_TPA
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|rx_sge_buf_tag
operator|==
name|NULL
condition|)
goto|goto
name|bxe_free_sg_chain_exit
goto|;
comment|/* Free all mbufs and unload all maps. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TOTAL_RX_SGE
condition|;
name|i
operator|++
control|)
block|{
comment|/* Free the map and the mbuf if they're allocated. */
if|if
condition|(
name|fp
operator|->
name|rx_sge_buf_map
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|fp
operator|->
name|rx_sge_buf_tag
argument_list|,
name|fp
operator|->
name|rx_sge_buf_map
index|[
name|i
index|]
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|fp
operator|->
name|rx_sge_buf_tag
argument_list|,
name|fp
operator|->
name|rx_sge_buf_map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|->
name|rx_sge_buf_ptr
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|fp
operator|->
name|rx_sge_buf_ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|DBRUN
argument_list|(
name|fp
operator|->
name|sge_mbuf_alloc
operator|--
argument_list|)
expr_stmt|;
name|fp
operator|->
name|rx_sge_buf_ptr
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|bxe_free_sg_chain_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_INSANE_TPA
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate an mbuf, if necessary, and add it to the receive chain.  *  * Returns:  *   0 = Success, !0 = Failure.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_alloc_rx_bd_mbuf
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|uint16_t
name|index
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|eth_rx_bd
modifier|*
name|rx_bd
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
literal|1
index|]
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|nsegs
decl_stmt|,
name|rc
decl_stmt|;
name|sc
operator|=
name|fp
operator|->
name|sc
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_INSANE_LOAD
operator||
name|BXE_INSANE_RESET
operator||
name|BXE_INSANE_RECV
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|BXE_DEBUG
comment|/* Simulate an mbuf allocation failure. */
if|if
condition|(
name|DB_RANDOMTRUE
argument_list|(
name|bxe_debug_mbuf_allocation_failure
argument_list|)
condition|)
block|{
name|sc
operator|->
name|debug_sim_mbuf_alloc_failed
operator|++
expr_stmt|;
name|fp
operator|->
name|mbuf_rx_bd_alloc_failed
operator|++
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bxe_alloc_rx_bd_mbuf_exit
goto|;
block|}
endif|#
directive|endif
comment|/* Allocate the new RX BD mbuf. */
name|m
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|sc
operator|->
name|mbuf_alloc_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|fp
operator|->
name|mbuf_rx_bd_alloc_failed
operator|++
expr_stmt|;
name|rc
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bxe_alloc_rx_bd_mbuf_exit
goto|;
block|}
name|DBRUN
argument_list|(
name|fp
operator|->
name|rx_mbuf_alloc
operator|++
argument_list|)
expr_stmt|;
comment|/* Initialize the mbuf buffer length. */
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|sc
operator|->
name|mbuf_alloc_size
expr_stmt|;
ifdef|#
directive|ifdef
name|BXE_DEBUG
comment|/* Simulate an mbuf mapping failure. */
if|if
condition|(
name|DB_RANDOMTRUE
argument_list|(
name|bxe_debug_dma_map_addr_failure
argument_list|)
condition|)
block|{
name|sc
operator|->
name|debug_sim_mbuf_map_failed
operator|++
expr_stmt|;
name|fp
operator|->
name|mbuf_rx_bd_mapping_failed
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|DBRUN
argument_list|(
name|fp
operator|->
name|rx_mbuf_alloc
operator|--
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bxe_alloc_rx_bd_mbuf_exit
goto|;
block|}
endif|#
directive|endif
comment|/* Map the TPA mbuf into non-paged pool. */
name|rc
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|fp
operator|->
name|rx_mbuf_spare_map
argument_list|,
name|m
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|rc
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|fp
operator|->
name|mbuf_rx_bd_mapping_failed
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|DBRUN
argument_list|(
name|fp
operator|->
name|rx_mbuf_alloc
operator|--
argument_list|)
expr_stmt|;
goto|goto
name|bxe_alloc_rx_bd_mbuf_exit
goto|;
block|}
comment|/* All mubfs must map to a single segment. */
name|KASSERT
argument_list|(
name|nsegs
operator|==
literal|1
argument_list|,
operator|(
literal|"%s(): Too many segments (%d) returned!"
operator|,
name|__FUNCTION__
operator|,
name|nsegs
operator|)
argument_list|)
expr_stmt|;
comment|/* Release any existing RX BD mbuf mapping. */
if|if
condition|(
name|fp
operator|->
name|rx_mbuf_map
index|[
name|index
index|]
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|fp
operator|->
name|rx_mbuf_map
index|[
name|index
index|]
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|fp
operator|->
name|rx_mbuf_map
index|[
name|index
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Save the mbuf and mapping info. */
name|map
operator|=
name|fp
operator|->
name|rx_mbuf_map
index|[
name|index
index|]
expr_stmt|;
name|fp
operator|->
name|rx_mbuf_map
index|[
name|index
index|]
operator|=
name|fp
operator|->
name|rx_mbuf_spare_map
expr_stmt|;
name|fp
operator|->
name|rx_mbuf_spare_map
operator|=
name|map
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|fp
operator|->
name|rx_mbuf_map
index|[
name|index
index|]
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|fp
operator|->
name|rx_mbuf_ptr
index|[
name|index
index|]
operator|=
name|m
expr_stmt|;
name|rx_bd
operator|=
operator|&
name|fp
operator|->
name|rx_chain
index|[
name|index
index|]
expr_stmt|;
name|rx_bd
operator|->
name|addr_hi
operator|=
name|htole32
argument_list|(
name|U64_HI
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|rx_bd
operator|->
name|addr_lo
operator|=
name|htole32
argument_list|(
name|U64_LO
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|bxe_alloc_rx_bd_mbuf_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_INSANE_LOAD
operator||
name|BXE_INSANE_RESET
operator||
name|BXE_INSANE_RECV
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate mbufs for a receive  chain.  *  * Returns:  *   0 = Success, !0 = Failure.  *  * Modifies:  *   fp->rx_bd_prod  */
end_comment

begin_function
specifier|static
name|int
name|bxe_fill_rx_bd_chain
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|uint16_t
name|index
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|sc
operator|=
name|fp
operator|->
name|sc
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
name|rc
operator|=
name|index
operator|=
literal|0
expr_stmt|;
comment|/* Allocate buffers for all the RX BDs in RX BD Chain. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|USABLE_RX_BD
condition|;
name|i
operator|++
control|)
block|{
name|rc
operator|=
name|bxe_alloc_rx_bd_mbuf
argument_list|(
name|fp
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Memory allocation failure! Cannot fill fp[%02d] RX chain.\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|fp
operator|->
name|index
argument_list|)
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|index
operator|=
name|NEXT_RX_BD
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
name|fp
operator|->
name|rx_bd_prod
operator|=
name|index
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free all buffers from the receive chain.  *  * Returns:  *   None  *  * Modifies:  *   fp->rx_mbuf_ptr[]  *   fp->rx_mbuf_map[]  *   fp->rx_mbuf_alloc  */
end_comment

begin_function
specifier|static
name|void
name|bxe_free_rx_bd_chain
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|fp
operator|->
name|sc
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|rx_mbuf_tag
operator|==
name|NULL
condition|)
goto|goto
name|bxe_free_rx_bd_chain_exit
goto|;
comment|/* Free all mbufs and unload all maps. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TOTAL_RX_BD
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fp
operator|->
name|rx_mbuf_map
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|fp
operator|->
name|rx_mbuf_map
index|[
name|i
index|]
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|fp
operator|->
name|rx_mbuf_map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|->
name|rx_mbuf_ptr
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|fp
operator|->
name|rx_mbuf_ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|DBRUN
argument_list|(
name|fp
operator|->
name|rx_mbuf_alloc
operator|--
argument_list|)
expr_stmt|;
name|fp
operator|->
name|rx_mbuf_ptr
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|bxe_free_rx_bd_chain_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Setup mutexes used by the driver.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_mutexes_alloc
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
argument_list|)
expr_stmt|;
name|BXE_CORE_LOCK_INIT
argument_list|(
name|sc
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|BXE_SP_LOCK_INIT
argument_list|(
name|sc
argument_list|,
literal|"bxe_sp_lock"
argument_list|)
expr_stmt|;
name|BXE_DMAE_LOCK_INIT
argument_list|(
name|sc
argument_list|,
literal|"bxe_dmae_lock"
argument_list|)
expr_stmt|;
name|BXE_PHY_LOCK_INIT
argument_list|(
name|sc
argument_list|,
literal|"bxe_phy_lock"
argument_list|)
expr_stmt|;
name|BXE_FWMB_LOCK_INIT
argument_list|(
name|sc
argument_list|,
literal|"bxe_fwmb_lock"
argument_list|)
expr_stmt|;
name|BXE_PRINT_LOCK_INIT
argument_list|(
name|sc
argument_list|,
literal|"bxe_print_lock"
argument_list|)
expr_stmt|;
comment|/* Allocate one mutex for each fastpath structure. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
expr_stmt|;
comment|/* Allocate per fastpath mutexes. */
name|snprintf
argument_list|(
name|fp
operator|->
name|mtx_name
argument_list|,
sizeof|sizeof
argument_list|(
name|fp
operator|->
name|mtx_name
argument_list|)
argument_list|,
literal|"%s:fp[%02d]"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|fp
operator|->
name|index
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|fp
operator|->
name|mtx
argument_list|,
name|fp
operator|->
name|mtx_name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
block|}
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free mutexes used by the driver.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_mutexes_free
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_UNLOAD
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
expr_stmt|;
comment|/* Release per fastpath mutexes. */
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|fp
operator|->
name|mtx
argument_list|)
condition|)
name|mtx_destroy
argument_list|(
operator|&
name|fp
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
name|BXE_PRINT_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BXE_FWMB_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BXE_PHY_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BXE_DMAE_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BXE_SP_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BXE_CORE_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_UNLOAD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free memory and clear the RX data structures.  *  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_clear_rx_chains
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
expr_stmt|;
comment|/* Free all RX buffers. */
name|bxe_free_rx_bd_chain
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|bxe_free_tpa_pool
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|bxe_free_sg_chain
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* Check if any mbufs lost in the process. */
name|DBRUNIF
argument_list|(
operator|(
name|fp
operator|->
name|tpa_mbuf_alloc
operator|)
argument_list|,
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): Memory leak! Lost %d mbufs from fp[%02d] TPA pool!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|fp
operator|->
name|tpa_mbuf_alloc
argument_list|,
name|fp
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|DBRUNIF
argument_list|(
operator|(
name|fp
operator|->
name|sge_mbuf_alloc
operator|)
argument_list|,
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): Memory leak! Lost %d mbufs from fp[%02d] SGE chain!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|fp
operator|->
name|sge_mbuf_alloc
argument_list|,
name|fp
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|DBRUNIF
argument_list|(
operator|(
name|fp
operator|->
name|rx_mbuf_alloc
operator|)
argument_list|,
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): Memory leak! Lost %d mbufs from fp[%02d] RX chain!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|fp
operator|->
name|rx_mbuf_alloc
argument_list|,
name|fp
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the receive rings.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_init_rx_chains
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|int
name|func
decl_stmt|,
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
name|func
operator|=
name|BP_FUNC
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Allocate memory for RX and CQ chains. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
operator|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator|)
argument_list|,
literal|"%s(): Initializing fp[%02d] RX chain.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fp
operator|->
name|rx_bd_cons
operator|=
name|fp
operator|->
name|rx_bd_prod
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|rx_cq_cons
operator|=
name|fp
operator|->
name|rx_cq_prod
operator|=
literal|0
expr_stmt|;
comment|/* Pointer to status block's CQ consumer index. */
name|fp
operator|->
name|rx_cq_cons_sb
operator|=
operator|&
name|fp
operator|->
name|status_block
operator|->
name|u_status_block
operator|.
name|index_values
index|[
name|HC_INDEX_U_ETH_RX_CQ_CONS
index|]
expr_stmt|;
comment|/* Pointer to status block's receive consumer index. */
name|fp
operator|->
name|rx_bd_cons_sb
operator|=
operator|&
name|fp
operator|->
name|status_block
operator|->
name|u_status_block
operator|.
name|index_values
index|[
name|HC_INDEX_U_ETH_RX_BD_CONS
index|]
expr_stmt|;
name|fp
operator|->
name|rx_cq_prod
operator|=
name|TOTAL_RCQ_ENTRIES
expr_stmt|;
name|fp
operator|->
name|rx_pkts
operator|=
name|fp
operator|->
name|rx_tpa_pkts
operator|=
name|fp
operator|->
name|rx_soft_errors
operator|=
literal|0
expr_stmt|;
comment|/* Allocate memory for the receive chain. */
name|rc
operator|=
name|bxe_fill_rx_bd_chain
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|bxe_init_rx_chains_exit
goto|;
comment|/* Allocate memory for TPA pool. */
name|rc
operator|=
name|bxe_fill_tpa_pool
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|bxe_init_rx_chains_exit
goto|;
comment|/* Allocate memory for scatter-gather chain. */
name|rc
operator|=
name|bxe_fill_sg_chain
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|bxe_init_rx_chains_exit
goto|;
comment|/* Prepare the receive BD and CQ buffers for DMA access. */
name|bus_dmamap_sync
argument_list|(
name|fp
operator|->
name|rx_dma
operator|.
name|tag
argument_list|,
name|fp
operator|->
name|rx_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|fp
operator|->
name|rcq_dma
operator|.
name|tag
argument_list|,
name|fp
operator|->
name|rcq_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* 		 * Tell the controller that we have rx_bd's and CQE's 		 * available.  Warning! this will generate an interrupt 		 * (to the TSTORM).  This must only be done when the 		 * controller is initialized. 		 */
name|bxe_update_rx_prod
argument_list|(
name|sc
argument_list|,
name|fp
argument_list|,
name|fp
operator|->
name|rx_bd_prod
argument_list|,
name|fp
operator|->
name|rx_cq_prod
argument_list|,
name|fp
operator|->
name|rx_sge_prod
argument_list|)
expr_stmt|;
comment|/* ToDo - Move to dma_alloc(). */
comment|/* 		 * Tell controller where the receive CQ 		 * chains start in physical memory. 		 */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_USTORM_INTMEM
operator|+
name|USTORM_MEM_WORKAROUND_ADDRESS_OFFSET
argument_list|(
name|func
argument_list|)
argument_list|,
name|U64_LO
argument_list|(
name|fp
operator|->
name|rcq_dma
operator|.
name|paddr
argument_list|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_USTORM_INTMEM
operator|+
name|USTORM_MEM_WORKAROUND_ADDRESS_OFFSET
argument_list|(
name|func
argument_list|)
operator|+
literal|4
argument_list|,
name|U64_HI
argument_list|(
name|fp
operator|->
name|rcq_dma
operator|.
name|paddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|bxe_init_rx_chains_exit
label|:
comment|/* Release memory if an error occurred. */
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|bxe_clear_rx_chains
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free memory and clear the TX data structures.  *  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_clear_tx_chains
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
expr_stmt|;
comment|/* Free all mbufs and unload all maps. */
if|if
condition|(
name|fp
operator|->
name|tx_mbuf_tag
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|TOTAL_TX_BD
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|fp
operator|->
name|tx_mbuf_ptr
index|[
name|j
index|]
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|fp
operator|->
name|tx_mbuf_tag
argument_list|,
name|fp
operator|->
name|tx_mbuf_map
index|[
name|j
index|]
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|fp
operator|->
name|tx_mbuf_tag
argument_list|,
name|fp
operator|->
name|tx_mbuf_map
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|fp
operator|->
name|tx_mbuf_ptr
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|fp
operator|->
name|tx_mbuf_alloc
operator|--
expr_stmt|;
name|fp
operator|->
name|tx_mbuf_ptr
index|[
name|j
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
comment|/* Check if we lost any mbufs in the process. */
name|DBRUNIF
argument_list|(
operator|(
name|fp
operator|->
name|tx_mbuf_alloc
operator|)
argument_list|,
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): Memory leak! Lost %d mbufs from fp[%02d] TX chain!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|fp
operator|->
name|tx_mbuf_alloc
argument_list|,
name|fp
operator|->
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the transmit chain.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_init_tx_chains
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
expr_stmt|;
comment|/* Initialize transmit doorbell. */
name|fp
operator|->
name|tx_db
operator|.
name|data
operator|.
name|header
operator|.
name|header
operator|=
name|DOORBELL_HDR_DB_TYPE
expr_stmt|;
name|fp
operator|->
name|tx_db
operator|.
name|data
operator|.
name|zero_fill1
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|tx_db
operator|.
name|data
operator|.
name|prod
operator|=
literal|0
expr_stmt|;
comment|/* Initialize tranmsit producer/consumer indices. */
name|fp
operator|->
name|tx_pkt_prod
operator|=
name|fp
operator|->
name|tx_pkt_cons
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|tx_bd_prod
operator|=
name|fp
operator|->
name|tx_bd_cons
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|tx_bd_used
operator|=
literal|0
expr_stmt|;
comment|/* Pointer to TX packet consumer in status block. */
name|fp
operator|->
name|tx_pkt_cons_sb
operator|=
operator|&
name|fp
operator|->
name|status_block
operator|->
name|c_status_block
operator|.
name|index_values
index|[
name|C_SB_ETH_TX_CQ_INDEX
index|]
expr_stmt|;
comment|/* Soft TX counters. */
name|fp
operator|->
name|tx_pkts
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|tx_soft_errors
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|tx_offload_frames_csum_ip
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|tx_offload_frames_csum_tcp
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|tx_offload_frames_csum_udp
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|tx_offload_frames_tso
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|tx_header_splits
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|tx_encap_failures
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|tx_hw_queue_full
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|tx_hw_max_queue_depth
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|tx_dma_mapping_failure
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|tx_max_drbr_queue_depth
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|tx_window_violation_std
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|tx_window_violation_tso
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|tx_unsupported_tso_request_ipv6
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|tx_unsupported_tso_request_not_tcp
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|tx_chain_lost_mbuf
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|tx_frame_deferred
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|tx_queue_xoff
operator|=
literal|0
expr_stmt|;
comment|/* Clear all TX mbuf pointers. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|TOTAL_TX_BD
condition|;
name|j
operator|++
control|)
block|{
name|fp
operator|->
name|tx_mbuf_ptr
index|[
name|j
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the slowpath ring.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_init_sp_ring
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|func
decl_stmt|;
name|func
operator|=
name|BP_FUNC
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sc
operator|->
name|slowpath
argument_list|,
name|BXE_SLOWPATH_SZ
argument_list|)
expr_stmt|;
comment|/* When the producer equals the consumer the chain is empty. */
name|sc
operator|->
name|spq_left
operator|=
name|MAX_SPQ_PENDING
expr_stmt|;
name|sc
operator|->
name|spq_prod_idx
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|dsb_sp_prod
operator|=
name|BXE_SP_DSB_INDEX
expr_stmt|;
name|sc
operator|->
name|spq_prod_bd
operator|=
name|sc
operator|->
name|spq
expr_stmt|;
name|sc
operator|->
name|spq_last_bd
operator|=
name|sc
operator|->
name|spq_prod_bd
operator|+
name|MAX_SP_DESC_CNT
expr_stmt|;
comment|/* Tell the controller the address of the slowpath ring. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|XSEM_REG_FAST_MEMORY
operator|+
name|XSTORM_SPQ_PAGE_BASE_OFFSET
argument_list|(
name|func
argument_list|)
argument_list|,
name|U64_LO
argument_list|(
name|sc
operator|->
name|spq_dma
operator|.
name|paddr
argument_list|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|XSEM_REG_FAST_MEMORY
operator|+
name|XSTORM_SPQ_PAGE_BASE_OFFSET
argument_list|(
name|func
argument_list|)
operator|+
literal|4
argument_list|,
name|U64_HI
argument_list|(
name|sc
operator|->
name|spq_dma
operator|.
name|paddr
argument_list|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|XSEM_REG_FAST_MEMORY
operator|+
name|XSTORM_SPQ_PROD_OFFSET
argument_list|(
name|func
argument_list|)
argument_list|,
name|sc
operator|->
name|spq_prod_idx
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize STORM processor context.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_init_context
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|eth_context
modifier|*
name|context
decl_stmt|;
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|uint8_t
name|sb_id
decl_stmt|;
name|uint8_t
name|cl_id
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|context
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|context
index|[
name|i
index|]
operator|.
name|eth
argument_list|)
expr_stmt|;
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
expr_stmt|;
name|sb_id
operator|=
name|fp
operator|->
name|sb_id
expr_stmt|;
name|cl_id
operator|=
name|fp
operator|->
name|cl_id
expr_stmt|;
comment|/* Update the USTORM context. */
name|context
operator|->
name|ustorm_st_context
operator|.
name|common
operator|.
name|sb_index_numbers
operator|=
name|BXE_RX_SB_INDEX_NUM
expr_stmt|;
name|context
operator|->
name|ustorm_st_context
operator|.
name|common
operator|.
name|clientId
operator|=
name|cl_id
expr_stmt|;
name|context
operator|->
name|ustorm_st_context
operator|.
name|common
operator|.
name|status_block_id
operator|=
name|sb_id
expr_stmt|;
comment|/* Enable packet alignment/pad and statistics. */
name|context
operator|->
name|ustorm_st_context
operator|.
name|common
operator|.
name|flags
operator|=
name|USTORM_ETH_ST_CONTEXT_CONFIG_ENABLE_MC_ALIGNMENT
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|stats_enable
operator|==
name|TRUE
condition|)
name|context
operator|->
name|ustorm_st_context
operator|.
name|common
operator|.
name|flags
operator||=
name|USTORM_ETH_ST_CONTEXT_CONFIG_ENABLE_STATISTICS
expr_stmt|;
name|context
operator|->
name|ustorm_st_context
operator|.
name|common
operator|.
name|statistics_counter_id
operator|=
name|cl_id
expr_stmt|;
comment|/* 		 * Set packet alignment boundary. 		 * (Must be>= 4 (i.e. 16 bytes).) 		 */
name|context
operator|->
name|ustorm_st_context
operator|.
name|common
operator|.
name|mc_alignment_log_size
operator|=
literal|8
expr_stmt|;
comment|/* Set the size of the receive buffers. */
name|context
operator|->
name|ustorm_st_context
operator|.
name|common
operator|.
name|bd_buff_size
operator|=
name|sc
operator|->
name|mbuf_alloc_size
expr_stmt|;
comment|/* Set the address of the receive chain base page. */
name|context
operator|->
name|ustorm_st_context
operator|.
name|common
operator|.
name|bd_page_base_hi
operator|=
name|U64_HI
argument_list|(
name|fp
operator|->
name|rx_dma
operator|.
name|paddr
argument_list|)
expr_stmt|;
name|context
operator|->
name|ustorm_st_context
operator|.
name|common
operator|.
name|bd_page_base_lo
operator|=
name|U64_LO
argument_list|(
name|fp
operator|->
name|rx_dma
operator|.
name|paddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TPA_ENABLED
argument_list|(
name|sc
argument_list|)
operator|&&
operator|(
name|fp
operator|->
name|disable_tpa
operator|==
name|FALSE
operator|)
condition|)
block|{
comment|/* Enable TPA and SGE chain support. */
name|context
operator|->
name|ustorm_st_context
operator|.
name|common
operator|.
name|flags
operator||=
name|USTORM_ETH_ST_CONTEXT_CONFIG_ENABLE_TPA
expr_stmt|;
comment|/* Set the size of the SGE buffer. */
name|context
operator|->
name|ustorm_st_context
operator|.
name|common
operator|.
name|sge_buff_size
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|SGE_PAGE_SIZE
operator|*
name|PAGES_PER_SGE
argument_list|)
expr_stmt|;
comment|/* Set the address of the SGE chain base page. */
name|context
operator|->
name|ustorm_st_context
operator|.
name|common
operator|.
name|sge_page_base_hi
operator|=
name|U64_HI
argument_list|(
name|fp
operator|->
name|sg_dma
operator|.
name|paddr
argument_list|)
expr_stmt|;
name|context
operator|->
name|ustorm_st_context
operator|.
name|common
operator|.
name|sge_page_base_lo
operator|=
name|U64_LO
argument_list|(
name|fp
operator|->
name|sg_dma
operator|.
name|paddr
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_TPA
argument_list|,
literal|"%s(): MTU = %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|int
operator|)
name|sc
operator|->
name|bxe_ifp
operator|->
name|if_mtu
argument_list|)
expr_stmt|;
comment|/* Describe MTU to SGE alignment. */
name|context
operator|->
name|ustorm_st_context
operator|.
name|common
operator|.
name|max_sges_for_packet
operator|=
name|SGE_PAGE_ALIGN
argument_list|(
name|sc
operator|->
name|bxe_ifp
operator|->
name|if_mtu
argument_list|)
operator|>>
name|SGE_PAGE_SHIFT
expr_stmt|;
name|context
operator|->
name|ustorm_st_context
operator|.
name|common
operator|.
name|max_sges_for_packet
operator|=
operator|(
operator|(
name|context
operator|->
name|ustorm_st_context
operator|.
name|common
operator|.
name|max_sges_for_packet
operator|+
name|PAGES_PER_SGE
operator|-
literal|1
operator|)
operator|&
operator|(
operator|~
operator|(
name|PAGES_PER_SGE
operator|-
literal|1
operator|)
operator|)
operator|)
operator|>>
name|PAGES_PER_SGE_SHIFT
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_TPA
argument_list|,
literal|"%s(): max_sges_for_packet = %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|context
operator|->
name|ustorm_st_context
operator|.
name|common
operator|.
name|max_sges_for_packet
argument_list|)
expr_stmt|;
block|}
comment|/* Update USTORM context. */
name|context
operator|->
name|ustorm_ag_context
operator|.
name|cdu_usage
operator|=
name|CDU_RSRVD_VALUE_TYPE_A
argument_list|(
name|HW_CID
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
argument_list|,
name|CDU_REGION_NUMBER_UCM_AG
argument_list|,
name|ETH_CONNECTION_TYPE
argument_list|)
expr_stmt|;
comment|/* Update XSTORM context. */
name|context
operator|->
name|xstorm_ag_context
operator|.
name|cdu_reserved
operator|=
name|CDU_RSRVD_VALUE_TYPE_A
argument_list|(
name|HW_CID
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
argument_list|,
name|CDU_REGION_NUMBER_XCM_AG
argument_list|,
name|ETH_CONNECTION_TYPE
argument_list|)
expr_stmt|;
comment|/* Set the address of the transmit chain base page. */
name|context
operator|->
name|xstorm_st_context
operator|.
name|tx_bd_page_base_hi
operator|=
name|U64_HI
argument_list|(
name|fp
operator|->
name|tx_dma
operator|.
name|paddr
argument_list|)
expr_stmt|;
name|context
operator|->
name|xstorm_st_context
operator|.
name|tx_bd_page_base_lo
operator|=
name|U64_LO
argument_list|(
name|fp
operator|->
name|tx_dma
operator|.
name|paddr
argument_list|)
expr_stmt|;
comment|/* Enable XSTORM statistics. */
name|context
operator|->
name|xstorm_st_context
operator|.
name|statistics_data
operator|=
operator|(
name|cl_id
operator||
name|XSTORM_ETH_ST_CONTEXT_STATISTICS_ENABLE
operator|)
expr_stmt|;
comment|/* Update CSTORM status block configuration. */
name|context
operator|->
name|cstorm_st_context
operator|.
name|sb_index_number
operator|=
name|C_SB_ETH_TX_CQ_INDEX
expr_stmt|;
name|context
operator|->
name|cstorm_st_context
operator|.
name|status_block_id
operator|=
name|sb_id
expr_stmt|;
block|}
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize indirection table.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_init_ind_table
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|func
decl_stmt|,
name|i
decl_stmt|;
name|func
operator|=
name|BP_FUNC
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|multi_mode
operator|==
name|ETH_RSS_MODE_DISABLED
condition|)
return|return;
comment|/* Initialize the indirection table. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TSTORM_INDIRECTION_TABLE_SIZE
condition|;
name|i
operator|++
control|)
name|REG_WR8
argument_list|(
name|sc
argument_list|,
name|BAR_TSTORM_INTMEM
operator|+
name|TSTORM_INDIRECTION_TABLE_OFFSET
argument_list|(
name|func
argument_list|)
operator|+
name|i
argument_list|,
name|sc
operator|->
name|fp
operator|->
name|cl_id
operator|+
operator|(
name|i
operator|%
name|sc
operator|->
name|num_queues
operator|)
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set client configuration.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_set_client_config
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|tstorm_eth_client_config
name|tstorm_client
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|i
decl_stmt|,
name|port
decl_stmt|;
name|port
operator|=
name|BP_PORT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_MISC
argument_list|)
expr_stmt|;
name|tstorm_client
operator|.
name|mtu
operator|=
name|sc
operator|->
name|bxe_ifp
operator|->
name|if_mtu
expr_stmt|;
comment|/* ETHERMTU */
name|tstorm_client
operator|.
name|config_flags
operator|=
operator|(
name|TSTORM_ETH_CLIENT_CONFIG_STATSITICS_ENABLE
operator||
name|TSTORM_ETH_CLIENT_CONFIG_E1HOV_REM_ENABLE
operator|)
expr_stmt|;
comment|/* Unconditionally enable VLAN tag stripping. */
if|if
condition|(
name|sc
operator|->
name|rx_mode
condition|)
block|{
name|tstorm_client
operator|.
name|config_flags
operator||=
name|TSTORM_ETH_CLIENT_CONFIG_VLAN_REM_ENABLE
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE
argument_list|,
literal|"%s(): VLAN tag stripping enabled.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize the receive mode for each receive queue. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|tstorm_client
operator|.
name|statistics_counter_id
operator|=
name|sc
operator|->
name|fp
index|[
name|i
index|]
operator|.
name|cl_id
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_TSTORM_INTMEM
operator|+
name|TSTORM_CLIENT_CONFIG_OFFSET
argument_list|(
name|port
argument_list|,
name|sc
operator|->
name|fp
index|[
name|i
index|]
operator|.
name|cl_id
argument_list|)
argument_list|,
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|tstorm_client
operator|)
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_TSTORM_INTMEM
operator|+
name|TSTORM_CLIENT_CONFIG_OFFSET
argument_list|(
name|port
argument_list|,
name|sc
operator|->
name|fp
index|[
name|i
index|]
operator|.
name|cl_id
argument_list|)
operator|+
literal|4
argument_list|,
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|tstorm_client
operator|)
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_MISC
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set receive mode.  *  * Programs the MAC according to the type of unicast/broadcast/multicast  * packets it should receive.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_set_storm_rx_mode
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|tstorm_eth_mac_filter_config
name|tstorm_mac_filter
init|=
block|{
literal|0
block|}
decl_stmt|;
name|uint32_t
name|llh_mask
decl_stmt|;
name|int
name|mode
decl_stmt|,
name|mask
decl_stmt|;
name|int
name|func
decl_stmt|,
name|i
decl_stmt|,
name|port
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
name|mode
operator|=
name|sc
operator|->
name|rx_mode
expr_stmt|;
name|mask
operator|=
literal|1
operator|<<
name|BP_L_ID
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|func
operator|=
name|BP_FUNC
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|port
operator|=
name|BP_PORT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* All but management unicast packets should pass to the host as well */
name|llh_mask
operator|=
name|NIG_LLH0_BRB1_DRV_MASK_REG_LLH0_BRB1_DRV_MASK_BRCST
operator||
name|NIG_LLH0_BRB1_DRV_MASK_REG_LLH0_BRB1_DRV_MASK_MLCST
operator||
name|NIG_LLH0_BRB1_DRV_MASK_REG_LLH0_BRB1_DRV_MASK_VLAN
operator||
name|NIG_LLH0_BRB1_DRV_MASK_REG_LLH0_BRB1_DRV_MASK_NO_VLAN
expr_stmt|;
comment|/* Set the individual accept/drop flags based on the receive mode. */
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|BXE_RX_MODE_NONE
case|:
comment|/* Drop everything. */
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE
argument_list|,
literal|"%s(): Setting RX_MODE_NONE for function %d.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|tstorm_mac_filter
operator|.
name|ucast_drop_all
operator|=
name|mask
expr_stmt|;
name|tstorm_mac_filter
operator|.
name|mcast_drop_all
operator|=
name|mask
expr_stmt|;
name|tstorm_mac_filter
operator|.
name|bcast_drop_all
operator|=
name|mask
expr_stmt|;
break|break;
case|case
name|BXE_RX_MODE_NORMAL
case|:
comment|/* Accept all broadcast frames. */
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE
argument_list|,
literal|"%s(): Setting RX_MODE_NORMAL for function %d.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|tstorm_mac_filter
operator|.
name|bcast_accept_all
operator|=
name|mask
expr_stmt|;
break|break;
case|case
name|BXE_RX_MODE_ALLMULTI
case|:
comment|/* Accept all broadcast and multicast frames. */
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE
argument_list|,
literal|"%s(): Setting RX_MODE_ALLMULTI for function %d.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|tstorm_mac_filter
operator|.
name|mcast_accept_all
operator|=
name|mask
expr_stmt|;
name|tstorm_mac_filter
operator|.
name|bcast_accept_all
operator|=
name|mask
expr_stmt|;
break|break;
case|case
name|BXE_RX_MODE_PROMISC
case|:
comment|/* Accept all frames (promiscuous mode). */
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE
argument_list|,
literal|"%s(): Setting RX_MODE_PROMISC for function %d.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|tstorm_mac_filter
operator|.
name|ucast_accept_all
operator|=
name|mask
expr_stmt|;
name|tstorm_mac_filter
operator|.
name|mcast_accept_all
operator|=
name|mask
expr_stmt|;
name|tstorm_mac_filter
operator|.
name|bcast_accept_all
operator|=
name|mask
expr_stmt|;
name|llh_mask
operator||=
name|NIG_LLH0_BRB1_DRV_MASK_REG_LLH0_BRB1_DRV_MASK_UNCST
expr_stmt|;
break|break;
default|default:
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Tried to set unknown receive mode (0x%08X)!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|port
condition|?
name|NIG_REG_LLH1_BRB1_DRV_MASK
else|:
name|NIG_REG_LLH0_BRB1_DRV_MASK
argument_list|,
name|llh_mask
argument_list|)
expr_stmt|;
comment|/* Write the RX mode filter to the TSTORM. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|tstorm_eth_mac_filter_config
argument_list|)
operator|/
literal|4
condition|;
name|i
operator|++
control|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_TSTORM_INTMEM
operator|+
name|TSTORM_MAC_FILTER_CONFIG_OFFSET
argument_list|(
name|func
argument_list|)
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
argument_list|,
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|tstorm_mac_filter
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|BXE_RX_MODE_NONE
condition|)
name|bxe_set_client_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize common internal resources.  (Applies to both ports and  * functions.)  *  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_init_internal_common
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
comment|/* 	 * Zero this manually as its initialization is currently not 	 * handled through block initialization. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|USTORM_AGG_DATA_SIZE
operator|>>
literal|2
operator|)
condition|;
name|i
operator|++
control|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_USTORM_INTMEM
operator|+
name|USTORM_AGG_DATA_OFFSET
operator|+
name|i
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize port specific internal resources.  *  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_init_internal_port
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|port
init|=
name|BP_PORT
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|port
operator|=
name|BP_PORT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
operator|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator|)
argument_list|,
literal|"%s(): Port %d internal initialization.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/* 	 * Each SDM timer tick is 4us. Configure host coalescing 	 * basic timer resolution (BTR) to 12us (3 * 4us). 	 */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_CSTORM_INTMEM
operator|+
name|CSTORM_HC_BTR_U_OFFSET
argument_list|(
name|port
argument_list|)
argument_list|,
name|BXE_BTR
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_CSTORM_INTMEM
operator|+
name|CSTORM_HC_BTR_C_OFFSET
argument_list|(
name|port
argument_list|)
argument_list|,
name|BXE_BTR
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_TSTORM_INTMEM
operator|+
name|TSTORM_HC_BTR_OFFSET
argument_list|(
name|port
argument_list|)
argument_list|,
name|BXE_BTR
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_XSTORM_INTMEM
operator|+
name|XSTORM_HC_BTR_OFFSET
argument_list|(
name|port
argument_list|)
argument_list|,
name|BXE_BTR
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize function specific internal resources.  *  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_init_internal_func
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|tstorm_eth_function_common_config
name|tstorm_config
init|=
block|{
literal|0
block|}
decl_stmt|;
name|struct
name|stats_indication_flags
name|stats_flags
init|=
block|{
literal|0
block|}
decl_stmt|;
name|struct
name|ustorm_eth_rx_pause_data_e1h
name|rx_pause
init|=
block|{
literal|0
block|}
decl_stmt|;
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|struct
name|eth_rx_cqe_next_page
modifier|*
name|nextpg
decl_stmt|;
name|uint32_t
name|offset
decl_stmt|,
name|size
decl_stmt|;
name|uint16_t
name|max_agg_size
decl_stmt|;
name|uint8_t
name|cl_id
decl_stmt|;
name|int
name|func
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|port
decl_stmt|;
name|port
operator|=
name|BP_PORT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|func
operator|=
name|BP_FUNC
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
operator|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator|)
argument_list|,
literal|"%s(): Port %d, function %d internal initialization.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|port
argument_list|,
name|func
argument_list|)
expr_stmt|;
comment|/* 	 * Configure which fields the controller looks at when 	 * distributing incoming frames for RSS/multi-queue operation. 	 */
if|if
condition|(
name|sc
operator|->
name|num_queues
operator|>
literal|1
condition|)
block|{
name|tstorm_config
operator|.
name|config_flags
operator|=
name|MULTI_FLAGS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tstorm_config
operator|.
name|rss_result_mask
operator|=
name|MULTI_MASK
expr_stmt|;
block|}
comment|/* Enable TPA if needed */
if|if
condition|(
name|TPA_ENABLED
argument_list|(
name|sc
argument_list|)
condition|)
name|tstorm_config
operator|.
name|config_flags
operator||=
name|TSTORM_ETH_FUNCTION_COMMON_CONFIG_ENABLE_TPA
expr_stmt|;
if|if
condition|(
name|IS_E1HMF
argument_list|(
name|sc
argument_list|)
condition|)
name|tstorm_config
operator|.
name|config_flags
operator||=
name|TSTORM_ETH_FUNCTION_COMMON_CONFIG_E1HOV_IN_CAM
expr_stmt|;
name|tstorm_config
operator|.
name|leading_client_id
operator|=
name|BP_L_ID
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_TSTORM_INTMEM
operator|+
name|TSTORM_FUNCTION_COMMON_CONFIG_OFFSET
argument_list|(
name|func
argument_list|)
argument_list|,
operator|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|tstorm_config
operator|)
argument_list|)
expr_stmt|;
comment|/* Don't receive anything until the link is up. */
name|sc
operator|->
name|rx_mode
operator|=
name|BXE_RX_MODE_NONE
expr_stmt|;
name|sc
operator|->
name|rx_mode_cl_mask
operator|=
operator|(
literal|1
operator|<<
name|BP_L_ID
argument_list|(
name|sc
argument_list|)
operator|)
expr_stmt|;
name|bxe_set_storm_rx_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|cl_id
operator|=
name|sc
operator|->
name|fp
index|[
name|i
index|]
operator|.
name|cl_id
expr_stmt|;
comment|/* Reset XSTORM per client statistics. */
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|xstorm_per_client_stats
argument_list|)
operator|/
literal|4
expr_stmt|;
name|offset
operator|=
name|BAR_XSTORM_INTMEM
operator|+
name|XSTORM_PER_COUNTER_ID_STATS_OFFSET
argument_list|(
name|port
argument_list|,
name|cl_id
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|size
condition|;
name|j
operator|++
control|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|offset
operator|+
operator|(
name|j
operator|*
literal|4
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reset TSTORM per client statistics. */
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|tstorm_per_client_stats
argument_list|)
operator|/
literal|4
expr_stmt|;
name|offset
operator|=
name|BAR_TSTORM_INTMEM
operator|+
name|TSTORM_PER_COUNTER_ID_STATS_OFFSET
argument_list|(
name|port
argument_list|,
name|cl_id
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|size
condition|;
name|j
operator|++
control|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|offset
operator|+
operator|(
name|j
operator|*
literal|4
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reset USTORM per client statistics. */
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ustorm_per_client_stats
argument_list|)
operator|/
literal|4
expr_stmt|;
name|offset
operator|=
name|BAR_USTORM_INTMEM
operator|+
name|USTORM_PER_COUNTER_ID_STATS_OFFSET
argument_list|(
name|port
argument_list|,
name|cl_id
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|size
condition|;
name|j
operator|++
control|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|offset
operator|+
operator|(
name|j
operator|*
literal|4
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize statistics related context. */
name|stats_flags
operator|.
name|collect_eth
operator|=
literal|1
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_XSTORM_INTMEM
operator|+
name|XSTORM_STATS_FLAGS_OFFSET
argument_list|(
name|func
argument_list|)
argument_list|,
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|stats_flags
operator|)
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_XSTORM_INTMEM
operator|+
name|XSTORM_STATS_FLAGS_OFFSET
argument_list|(
name|func
argument_list|)
operator|+
literal|4
argument_list|,
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|stats_flags
operator|)
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_TSTORM_INTMEM
operator|+
name|TSTORM_STATS_FLAGS_OFFSET
argument_list|(
name|func
argument_list|)
argument_list|,
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|stats_flags
operator|)
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_TSTORM_INTMEM
operator|+
name|TSTORM_STATS_FLAGS_OFFSET
argument_list|(
name|func
argument_list|)
operator|+
literal|4
argument_list|,
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|stats_flags
operator|)
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_USTORM_INTMEM
operator|+
name|USTORM_STATS_FLAGS_OFFSET
argument_list|(
name|func
argument_list|)
argument_list|,
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|stats_flags
operator|)
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_USTORM_INTMEM
operator|+
name|USTORM_STATS_FLAGS_OFFSET
argument_list|(
name|func
argument_list|)
operator|+
literal|4
argument_list|,
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|stats_flags
operator|)
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_CSTORM_INTMEM
operator|+
name|CSTORM_STATS_FLAGS_OFFSET
argument_list|(
name|func
argument_list|)
argument_list|,
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|stats_flags
operator|)
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_CSTORM_INTMEM
operator|+
name|CSTORM_STATS_FLAGS_OFFSET
argument_list|(
name|func
argument_list|)
operator|+
literal|4
argument_list|,
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|stats_flags
operator|)
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_XSTORM_INTMEM
operator|+
name|XSTORM_ETH_STATS_QUERY_ADDR_OFFSET
argument_list|(
name|func
argument_list|)
argument_list|,
name|U64_LO
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|fw_stats
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_XSTORM_INTMEM
operator|+
name|XSTORM_ETH_STATS_QUERY_ADDR_OFFSET
argument_list|(
name|func
argument_list|)
operator|+
literal|4
argument_list|,
name|U64_HI
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|fw_stats
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_TSTORM_INTMEM
operator|+
name|TSTORM_ETH_STATS_QUERY_ADDR_OFFSET
argument_list|(
name|func
argument_list|)
argument_list|,
name|U64_LO
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|fw_stats
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_TSTORM_INTMEM
operator|+
name|TSTORM_ETH_STATS_QUERY_ADDR_OFFSET
argument_list|(
name|func
argument_list|)
operator|+
literal|4
argument_list|,
name|U64_HI
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|fw_stats
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_USTORM_INTMEM
operator|+
name|USTORM_ETH_STATS_QUERY_ADDR_OFFSET
argument_list|(
name|func
argument_list|)
argument_list|,
name|U64_LO
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|fw_stats
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_USTORM_INTMEM
operator|+
name|USTORM_ETH_STATS_QUERY_ADDR_OFFSET
argument_list|(
name|func
argument_list|)
operator|+
literal|4
argument_list|,
name|U64_HI
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|fw_stats
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Additional initialization for 57711/57711E. */
if|if
condition|(
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|REG_WR8
argument_list|(
name|sc
argument_list|,
name|BAR_XSTORM_INTMEM
operator|+
name|XSTORM_FUNCTION_MODE_OFFSET
argument_list|,
name|IS_E1HMF
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|REG_WR8
argument_list|(
name|sc
argument_list|,
name|BAR_TSTORM_INTMEM
operator|+
name|TSTORM_FUNCTION_MODE_OFFSET
argument_list|,
name|IS_E1HMF
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|REG_WR8
argument_list|(
name|sc
argument_list|,
name|BAR_CSTORM_INTMEM
operator|+
name|CSTORM_FUNCTION_MODE_OFFSET
argument_list|,
name|IS_E1HMF
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|REG_WR8
argument_list|(
name|sc
argument_list|,
name|BAR_USTORM_INTMEM
operator|+
name|USTORM_FUNCTION_MODE_OFFSET
argument_list|,
name|IS_E1HMF
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the outer VLAN tag. */
name|REG_WR16
argument_list|(
name|sc
argument_list|,
name|BAR_XSTORM_INTMEM
operator|+
name|XSTORM_E1HOV_OFFSET
argument_list|(
name|func
argument_list|)
argument_list|,
name|sc
operator|->
name|e1hov
argument_list|)
expr_stmt|;
block|}
comment|/* Init completion queue mapping and TPA aggregation size. */
name|max_agg_size
operator|=
name|min
argument_list|(
call|(
name|uint32_t
call|)
argument_list|(
name|sc
operator|->
name|mbuf_alloc_size
operator|+
operator|(
literal|8
operator|*
name|BCM_PAGE_SIZE
operator|*
name|PAGES_PER_SGE
operator|)
argument_list|)
argument_list|,
operator|(
name|uint32_t
operator|)
literal|0xffff
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_TPA
argument_list|,
literal|"%s(): max_agg_size = 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|max_agg_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
expr_stmt|;
name|nextpg
operator|=
operator|(
expr|struct
name|eth_rx_cqe_next_page
operator|*
operator|)
operator|&
name|fp
operator|->
name|rcq_chain
index|[
name|USABLE_RCQ_ENTRIES_PER_PAGE
index|]
expr_stmt|;
comment|/* Program the completion queue address. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_USTORM_INTMEM
operator|+
name|USTORM_CQE_PAGE_BASE_OFFSET
argument_list|(
name|port
argument_list|,
name|fp
operator|->
name|cl_id
argument_list|)
argument_list|,
name|U64_LO
argument_list|(
name|fp
operator|->
name|rcq_dma
operator|.
name|paddr
argument_list|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_USTORM_INTMEM
operator|+
name|USTORM_CQE_PAGE_BASE_OFFSET
argument_list|(
name|port
argument_list|,
name|fp
operator|->
name|cl_id
argument_list|)
operator|+
literal|4
argument_list|,
name|U64_HI
argument_list|(
name|fp
operator|->
name|rcq_dma
operator|.
name|paddr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Program the first CQ next page address. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_USTORM_INTMEM
operator|+
name|USTORM_CQE_PAGE_NEXT_OFFSET
argument_list|(
name|port
argument_list|,
name|fp
operator|->
name|cl_id
argument_list|)
argument_list|,
name|nextpg
operator|->
name|addr_lo
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_USTORM_INTMEM
operator|+
name|USTORM_CQE_PAGE_NEXT_OFFSET
argument_list|(
name|port
argument_list|,
name|fp
operator|->
name|cl_id
argument_list|)
operator|+
literal|4
argument_list|,
name|nextpg
operator|->
name|addr_hi
argument_list|)
expr_stmt|;
comment|/* Set the maximum TPA aggregation size. */
name|REG_WR16
argument_list|(
name|sc
argument_list|,
name|BAR_USTORM_INTMEM
operator|+
name|USTORM_MAX_AGG_SIZE_OFFSET
argument_list|(
name|port
argument_list|,
name|fp
operator|->
name|cl_id
argument_list|)
argument_list|,
name|max_agg_size
argument_list|)
expr_stmt|;
block|}
comment|/* Configure lossless flow control. */
if|if
condition|(
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|rx_pause
operator|.
name|bd_thr_low
operator|=
literal|250
expr_stmt|;
name|rx_pause
operator|.
name|cqe_thr_low
operator|=
literal|250
expr_stmt|;
name|rx_pause
operator|.
name|cos
operator|=
literal|1
expr_stmt|;
name|rx_pause
operator|.
name|sge_thr_low
operator|=
literal|0
expr_stmt|;
name|rx_pause
operator|.
name|bd_thr_high
operator|=
literal|350
expr_stmt|;
name|rx_pause
operator|.
name|cqe_thr_high
operator|=
literal|350
expr_stmt|;
name|rx_pause
operator|.
name|sge_thr_high
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|disable_tpa
operator|==
name|FALSE
condition|)
block|{
name|rx_pause
operator|.
name|sge_thr_low
operator|=
literal|150
expr_stmt|;
name|rx_pause
operator|.
name|sge_thr_high
operator|=
literal|250
expr_stmt|;
block|}
name|offset
operator|=
name|BAR_USTORM_INTMEM
operator|+
name|USTORM_ETH_RING_PAUSE_DATA_OFFSET
argument_list|(
name|port
argument_list|,
name|fp
operator|->
name|cl_id
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ustorm_eth_rx_pause_data_e1h
argument_list|)
operator|/
literal|4
condition|;
name|j
operator|++
control|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|offset
operator|+
operator|(
name|j
operator|*
literal|4
operator|)
argument_list|,
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|rx_pause
operator|)
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|memset
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|cmng
operator|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cmng_struct_per_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_E1HMF
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* 		 * During init there is no active link. 		 * Until link is up, assume link rate @ 10Gbps 		 */
name|bxe_read_mf_cfg
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|vn_wsum
condition|)
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_MISC
argument_list|,
literal|"%s(): All MIN values are zeroes, "
literal|"fairness will be disabled.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
comment|/* Store it to internal memory */
if|if
condition|(
name|sc
operator|->
name|port
operator|.
name|pmf
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|cmng_struct_per_port
argument_list|)
operator|/
literal|4
condition|;
name|i
operator|++
control|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_XSTORM_INTMEM
operator|+
name|XSTORM_CMNG_PER_PORT_VARS_OFFSET
argument_list|(
name|port
argument_list|)
operator|+
name|i
operator|*
literal|4
argument_list|,
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|(
operator|&
name|sc
operator|->
name|cmng
operator|)
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize internal resources.  *  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_init_internal
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|load_code
parameter_list|)
block|{
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|load_code
condition|)
block|{
case|case
name|FW_MSG_CODE_DRV_LOAD_COMMON
case|:
name|bxe_init_internal_common
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|FW_MSG_CODE_DRV_LOAD_PORT
case|:
name|bxe_init_internal_port
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|FW_MSG_CODE_DRV_LOAD_FUNCTION
case|:
name|bxe_init_internal_func
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Unknown load_code (0x%08X) from MCP!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|load_code
argument_list|)
expr_stmt|;
break|break;
block|}
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Perform driver instance specific initialization.  *  * Returns:  *   None  */
end_comment

begin_function
specifier|static
name|int
name|bxe_init_nic
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|load_code
parameter_list|)
block|{
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
comment|/* Intialize fastpath structures and the status block. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
expr_stmt|;
name|fp
operator|->
name|disable_tpa
operator|=
name|TRUE
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fp
operator|->
name|status_block
argument_list|,
name|BXE_STATUS_BLK_SZ
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fp_u_idx
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|fp_c_idx
operator|=
literal|0
expr_stmt|;
comment|/* Set a pointer back to the driver instance. */
name|fp
operator|->
name|sc
operator|=
name|sc
expr_stmt|;
comment|/* Set the fastpath starting state as closed. */
name|fp
operator|->
name|state
operator|=
name|BXE_FP_STATE_CLOSED
expr_stmt|;
comment|/* Self-reference to this fastpath's instance. */
name|fp
operator|->
name|index
operator|=
name|i
expr_stmt|;
comment|/* Set the client ID beginning with the leading id. */
name|fp
operator|->
name|cl_id
operator|=
name|BP_L_ID
argument_list|(
name|sc
argument_list|)
operator|+
name|i
expr_stmt|;
comment|/* Set the status block ID for this fastpath instance. */
name|fp
operator|->
name|sb_id
operator|=
name|fp
operator|->
name|cl_id
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
operator|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator|)
argument_list|,
literal|"%s(): fp[%02d]: cl_id = %d, sb_id = %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|fp
operator|->
name|cl_id
argument_list|,
name|fp
operator|->
name|sb_id
argument_list|)
expr_stmt|;
comment|/* Initialize the fastpath status block. */
name|bxe_init_sb
argument_list|(
name|sc
argument_list|,
name|fp
operator|->
name|status_block
argument_list|,
name|fp
operator|->
name|sb_dma
operator|.
name|paddr
argument_list|,
name|fp
operator|->
name|sb_id
argument_list|)
expr_stmt|;
name|bxe_update_fpsb_idx
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|rmb
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sc
operator|->
name|def_sb
argument_list|,
name|BXE_DEF_STATUS_BLK_SZ
argument_list|)
expr_stmt|;
comment|/* Initialize the Default Status Block. */
name|bxe_init_def_sb
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|def_sb
argument_list|,
name|sc
operator|->
name|def_sb_dma
operator|.
name|paddr
argument_list|,
name|DEF_SB_ID
argument_list|)
expr_stmt|;
name|bxe_update_dsb_idx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Initialize the coalescence parameters. */
name|bxe_update_coalesce
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Initialize receive chains. */
name|rc
operator|=
name|bxe_init_rx_chains
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
goto|goto
name|bxe_init_nic_exit
goto|;
block|}
comment|/* Initialize the Transmit BD Chain. */
name|bxe_init_tx_chains
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Initialize the Slow Path Chain. */
name|bxe_init_sp_ring
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Initialize STORM processor context/configuration. */
name|bxe_init_context
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Initialize the Context. */
name|bxe_init_internal
argument_list|(
name|sc
argument_list|,
name|load_code
argument_list|)
expr_stmt|;
comment|/* Enable indirection table for multi-queue operation. */
name|bxe_init_ind_table
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
comment|/* Disable the interrupts from device until init is complete.*/
name|bxe_int_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_init_nic_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send a loopback packet through the Network Interface Glue (NIG) block.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_lb_pckt
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|BXE_USE_DMAE
name|uint32_t
name|wb_write
index|[
literal|3
index|]
decl_stmt|;
endif|#
directive|endif
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
comment|/* Ethernet source and destination addresses. */
ifdef|#
directive|ifdef
name|BXE_USE_DMAE
name|wb_write
index|[
literal|0
index|]
operator|=
literal|0x55555555
expr_stmt|;
name|wb_write
index|[
literal|1
index|]
operator|=
literal|0x55555555
expr_stmt|;
name|wb_write
index|[
literal|2
index|]
operator|=
literal|0x20
expr_stmt|;
comment|/* SOP */
name|REG_WR_DMAE
argument_list|(
name|sc
argument_list|,
name|NIG_REG_DEBUG_PACKET_LB
argument_list|,
name|wb_write
argument_list|,
literal|3
argument_list|)
expr_stmt|;
else|#
directive|else
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|NIG_REG_DEBUG_PACKET_LB
argument_list|,
literal|0x55555555
argument_list|)
expr_stmt|;
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|NIG_REG_DEBUG_PACKET_LB
operator|+
literal|4
argument_list|,
literal|0x55555555
argument_list|)
expr_stmt|;
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|NIG_REG_DEBUG_PACKET_LB
operator|+
literal|8
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NON-IP protocol. */
ifdef|#
directive|ifdef
name|BXE_USE_DMAE
name|wb_write
index|[
literal|0
index|]
operator|=
literal|0x09000000
expr_stmt|;
name|wb_write
index|[
literal|1
index|]
operator|=
literal|0x55555555
expr_stmt|;
name|wb_write
index|[
literal|2
index|]
operator|=
literal|0x10
expr_stmt|;
comment|/* EOP */
name|REG_WR_DMAE
argument_list|(
name|sc
argument_list|,
name|NIG_REG_DEBUG_PACKET_LB
argument_list|,
name|wb_write
argument_list|,
literal|3
argument_list|)
expr_stmt|;
else|#
directive|else
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|NIG_REG_DEBUG_PACKET_LB
argument_list|,
literal|0x09000000
argument_list|)
expr_stmt|;
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|NIG_REG_DEBUG_PACKET_LB
operator|+
literal|4
argument_list|,
literal|0x55555555
argument_list|)
expr_stmt|;
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|NIG_REG_DEBUG_PACKET_LB
operator|+
literal|8
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Perform an internal memory test.  *  * Some internal memories are not accessible through the PCIe interface so  * we send some debug packets for the test.  *  * Returns:  *   0 = Success, !0 = Failure.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_int_mem_test
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|int
name|count
decl_stmt|,
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
comment|/* Perform a single debug packet test. */
comment|/* Disable inputs of parser neighbor blocks. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|TSDM_REG_ENABLE_IN1
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|TCM_REG_PRS_IFEN
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|CFC_REG_DEBUG0
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_PRS_REQ_IN_EN
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/*  Write 0 to parser credits for CFC search request. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PRS_REG_CFC_SEARCH_INITIAL_CREDIT
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* Send an Ethernet packet. */
name|bxe_lb_pckt
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Wait until NIG register shows 1 packet of size 0x10. */
name|count
operator|=
literal|1000
expr_stmt|;
while|while
condition|(
name|count
condition|)
block|{
name|bxe_read_dmae
argument_list|(
name|sc
argument_list|,
name|NIG_REG_STAT2_BRB_OCTET
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|val
operator|=
operator|*
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|wb_data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0x10
condition|)
break|break;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|!=
literal|0x10
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): NIG loopback test 1 timeout (val = 0x%08X)!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|bxe_int_mem_test_exit
goto|;
block|}
comment|/* Wait until PRS register shows 1 packet */
name|count
operator|=
literal|1000
expr_stmt|;
while|while
condition|(
name|count
condition|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|PRS_REG_NUM_OF_PACKETS
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|1
condition|)
break|break;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|!=
literal|0x1
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): PRS loopback test 1 timeout (val = 0x%08X)!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|2
expr_stmt|;
goto|goto
name|bxe_int_mem_test_exit
goto|;
block|}
comment|/* Reset and init BRB, PRS. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_1_CLEAR
argument_list|,
literal|0x3
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_1_SET
argument_list|,
literal|0x3
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|BRB1_BLOCK
argument_list|,
name|COMMON_STAGE
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|PRS_BLOCK
argument_list|,
name|COMMON_STAGE
argument_list|)
expr_stmt|;
comment|/* Perform the test again, this time with 10 packets. */
comment|/* Disable inputs of parser neighbor blocks. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|TSDM_REG_ENABLE_IN1
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|TCM_REG_PRS_IFEN
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|CFC_REG_DEBUG0
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_PRS_REQ_IN_EN
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* Write 0 to parser credits for CFC search request. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PRS_REG_CFC_SEARCH_INITIAL_CREDIT
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* Send 10 Ethernet packets. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
name|bxe_lb_pckt
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Wait until NIG shows 10 + 1 packets of size 11 * 0x10 = 0xb0. */
name|count
operator|=
literal|1000
expr_stmt|;
while|while
condition|(
name|count
condition|)
block|{
name|bxe_read_dmae
argument_list|(
name|sc
argument_list|,
name|NIG_REG_STAT2_BRB_OCTET
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|val
operator|=
operator|*
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|wb_data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0xb0
condition|)
break|break;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|!=
literal|0xb0
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): NIG loopback test 2 timeout (val = 0x%08X)!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|3
expr_stmt|;
goto|goto
name|bxe_int_mem_test_exit
goto|;
block|}
comment|/* Wait until PRS register shows 2 packets. */
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|PRS_REG_NUM_OF_PACKETS
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|2
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): PRS loopback test 2 timeout (val = 0x%x)!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|4
expr_stmt|;
goto|goto
name|bxe_int_mem_test_exit
goto|;
block|}
comment|/* Write 1 to parser credits for CFC search request. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PRS_REG_CFC_SEARCH_INITIAL_CREDIT
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
comment|/* Wait until PRS register shows 3 packets. */
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/* Wait until NIG register shows 1 packet of size 0x10. */
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|PRS_REG_NUM_OF_PACKETS
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|3
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): PRS loopback test 3 timeout (val = 0x%08X)!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|5
expr_stmt|;
goto|goto
name|bxe_int_mem_test_exit
goto|;
block|}
comment|/* Clear NIG end-of-packet FIFO. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|11
condition|;
name|i
operator|++
control|)
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_INGRESS_EOP_LB_FIFO
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_INGRESS_EOP_LB_EMPTY
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|1
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_INFO
argument_list|,
literal|"%s(): Unable to clear NIG!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|6
expr_stmt|;
goto|goto
name|bxe_int_mem_test_exit
goto|;
block|}
comment|/* Reset and init BRB, PRS, NIG. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_1_CLEAR
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_1_SET
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|BRB1_BLOCK
argument_list|,
name|COMMON_STAGE
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|PRS_BLOCK
argument_list|,
name|COMMON_STAGE
argument_list|)
expr_stmt|;
comment|/* Set NIC mode. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PRS_REG_NIC_MODE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Enable inputs of parser neighbor blocks. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|TSDM_REG_ENABLE_IN1
argument_list|,
literal|0x7fffffff
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|TCM_REG_PRS_IFEN
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|CFC_REG_DEBUG0
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_PRS_REQ_IN_EN
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|bxe_int_mem_test_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Enable attentions from various blocks.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_enable_blocks_attention
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP_REG_PXP_INT_MASK_0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP_REG_PXP_INT_MASK_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|DORQ_REG_DORQ_INT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|CFC_REG_CFC_INT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|QM_REG_QM_INT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|TM_REG_TM_INT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|XSDM_REG_XSDM_INT_MASK_0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|XSDM_REG_XSDM_INT_MASK_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|XCM_REG_XCM_INT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|USDM_REG_USDM_INT_MASK_0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|USDM_REG_USDM_INT_MASK_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|UCM_REG_UCM_INT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_UPB
operator|+
name|PB_REG_PB_INT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|CSDM_REG_CSDM_INT_MASK_0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|CSDM_REG_CSDM_INT_MASK_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|CCM_REG_CCM_INT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_PXP2_INT_MASK_0
argument_list|,
literal|0x480000
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|TSDM_REG_TSDM_INT_MASK_0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|TSDM_REG_TSDM_INT_MASK_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|TCM_REG_TCM_INT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|CDU_REG_CDU_INT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|DMAE_REG_DMAE_INT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_PBF_INT_MASK
argument_list|,
literal|0X18
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * PXP Arbiter  */
end_comment

begin_comment
comment|/*  * This code configures the PCI read/write arbiter  * which implements a weighted round robin  * between the virtual queues in the chip.  *  * The values were derived for each PCI max payload and max request size.  * since max payload and max request size are only known at run time,  * this is done as a separate init stage.  */
end_comment

begin_define
define|#
directive|define
name|NUM_WR_Q
value|13
end_define

begin_define
define|#
directive|define
name|NUM_RD_Q
value|29
end_define

begin_define
define|#
directive|define
name|MAX_RD_ORD
value|3
end_define

begin_define
define|#
directive|define
name|MAX_WR_ORD
value|2
end_define

begin_comment
comment|/* Configuration for one arbiter queue. */
end_comment

begin_struct
struct|struct
name|arb_line
block|{
name|int
name|l
decl_stmt|;
name|int
name|add
decl_stmt|;
name|int
name|ubound
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Derived configuration for each read queue for each max request size. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|arb_line
name|read_arb_data
index|[
name|NUM_RD_Q
index|]
index|[
name|MAX_RD_ORD
operator|+
literal|1
index|]
init|=
block|{
comment|/* 1 */
block|{
block|{
literal|8
block|,
literal|64
block|,
literal|25
block|}
block|,
block|{
literal|16
block|,
literal|64
block|,
literal|25
block|}
block|,
block|{
literal|32
block|,
literal|64
block|,
literal|25
block|}
block|,
block|{
literal|64
block|,
literal|64
block|,
literal|41
block|}
block|}
block|,
block|{
block|{
literal|4
block|,
literal|8
block|,
literal|4
block|}
block|,
block|{
literal|4
block|,
literal|8
block|,
literal|4
block|}
block|,
block|{
literal|4
block|,
literal|8
block|,
literal|4
block|}
block|,
block|{
literal|4
block|,
literal|8
block|,
literal|4
block|}
block|}
block|,
block|{
block|{
literal|4
block|,
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|4
block|,
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|4
block|,
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|4
block|,
literal|3
block|,
literal|3
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|64
block|,
literal|25
block|}
block|,
block|{
literal|16
block|,
literal|64
block|,
literal|25
block|}
block|,
block|{
literal|32
block|,
literal|64
block|,
literal|25
block|}
block|,
block|{
literal|64
block|,
literal|64
block|,
literal|41
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|64
block|,
literal|3
block|,
literal|41
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|64
block|,
literal|3
block|,
literal|41
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|64
block|,
literal|3
block|,
literal|41
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|64
block|,
literal|3
block|,
literal|41
block|}
block|}
block|,
comment|/* 10 */
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|64
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|64
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|64
block|,
literal|21
block|}
block|,
block|{
literal|32
block|,
literal|64
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|}
block|,
comment|/* 20 */
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|64
block|,
literal|25
block|}
block|,
block|{
literal|16
block|,
literal|64
block|,
literal|41
block|}
block|,
block|{
literal|32
block|,
literal|64
block|,
literal|81
block|}
block|,
block|{
literal|64
block|,
literal|64
block|,
literal|120
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Derived configuration for each write queue for each max request size. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|arb_line
name|write_arb_data
index|[
name|NUM_WR_Q
index|]
index|[
name|MAX_WR_ORD
operator|+
literal|1
index|]
init|=
block|{
comment|/* 1 */
block|{
block|{
literal|4
block|,
literal|6
block|,
literal|3
block|}
block|,
block|{
literal|4
block|,
literal|6
block|,
literal|3
block|}
block|,
block|{
literal|4
block|,
literal|6
block|,
literal|3
block|}
block|}
block|,
block|{
block|{
literal|4
block|,
literal|2
block|,
literal|3
block|}
block|,
block|{
literal|4
block|,
literal|2
block|,
literal|3
block|}
block|,
block|{
literal|4
block|,
literal|2
block|,
literal|3
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|2
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|2
block|,
literal|11
block|}
block|,
block|{
literal|16
block|,
literal|2
block|,
literal|11
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|2
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|2
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|2
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|2
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|2
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|2
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|2
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|2
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|2
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|64
block|,
literal|25
block|}
block|,
block|{
literal|16
block|,
literal|64
block|,
literal|25
block|}
block|,
block|{
literal|32
block|,
literal|64
block|,
literal|25
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|2
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|2
block|,
literal|11
block|}
block|,
block|{
literal|16
block|,
literal|2
block|,
literal|11
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|2
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|2
block|,
literal|11
block|}
block|,
block|{
literal|16
block|,
literal|2
block|,
literal|11
block|}
block|}
block|,
comment|/* 10 */
block|{
block|{
literal|8
block|,
literal|9
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|9
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|9
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|47
block|,
literal|19
block|}
block|,
block|{
literal|16
block|,
literal|47
block|,
literal|19
block|}
block|,
block|{
literal|32
block|,
literal|47
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|9
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|9
block|,
literal|11
block|}
block|,
block|{
literal|16
block|,
literal|9
block|,
literal|11
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|64
block|,
literal|25
block|}
block|,
block|{
literal|16
block|,
literal|64
block|,
literal|41
block|}
block|,
block|{
literal|32
block|,
literal|64
block|,
literal|81
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Register addresses for read queues. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|arb_line
name|read_arb_addr
index|[
name|NUM_RD_Q
operator|-
literal|1
index|]
init|=
block|{
comment|/* 1 */
block|{
name|PXP2_REG_RQ_BW_RD_L0
block|,
name|PXP2_REG_RQ_BW_RD_ADD0
block|,
name|PXP2_REG_RQ_BW_RD_UBOUND0
block|}
block|,
block|{
name|PXP2_REG_PSWRQ_BW_L1
block|,
name|PXP2_REG_PSWRQ_BW_ADD1
block|,
name|PXP2_REG_PSWRQ_BW_UB1
block|}
block|,
block|{
name|PXP2_REG_PSWRQ_BW_L2
block|,
name|PXP2_REG_PSWRQ_BW_ADD2
block|,
name|PXP2_REG_PSWRQ_BW_UB2
block|}
block|,
block|{
name|PXP2_REG_PSWRQ_BW_L3
block|,
name|PXP2_REG_PSWRQ_BW_ADD3
block|,
name|PXP2_REG_PSWRQ_BW_UB3
block|}
block|,
block|{
name|PXP2_REG_RQ_BW_RD_L4
block|,
name|PXP2_REG_RQ_BW_RD_ADD4
block|,
name|PXP2_REG_RQ_BW_RD_UBOUND4
block|}
block|,
block|{
name|PXP2_REG_RQ_BW_RD_L5
block|,
name|PXP2_REG_RQ_BW_RD_ADD5
block|,
name|PXP2_REG_RQ_BW_RD_UBOUND5
block|}
block|,
block|{
name|PXP2_REG_PSWRQ_BW_L6
block|,
name|PXP2_REG_PSWRQ_BW_ADD6
block|,
name|PXP2_REG_PSWRQ_BW_UB6
block|}
block|,
block|{
name|PXP2_REG_PSWRQ_BW_L7
block|,
name|PXP2_REG_PSWRQ_BW_ADD7
block|,
name|PXP2_REG_PSWRQ_BW_UB7
block|}
block|,
block|{
name|PXP2_REG_PSWRQ_BW_L8
block|,
name|PXP2_REG_PSWRQ_BW_ADD8
block|,
name|PXP2_REG_PSWRQ_BW_UB8
block|}
block|,
comment|/* 10 */
block|{
name|PXP2_REG_PSWRQ_BW_L9
block|,
name|PXP2_REG_PSWRQ_BW_ADD9
block|,
name|PXP2_REG_PSWRQ_BW_UB9
block|}
block|,
block|{
name|PXP2_REG_PSWRQ_BW_L10
block|,
name|PXP2_REG_PSWRQ_BW_ADD10
block|,
name|PXP2_REG_PSWRQ_BW_UB10
block|}
block|,
block|{
name|PXP2_REG_PSWRQ_BW_L11
block|,
name|PXP2_REG_PSWRQ_BW_ADD11
block|,
name|PXP2_REG_PSWRQ_BW_UB11
block|}
block|,
block|{
name|PXP2_REG_RQ_BW_RD_L12
block|,
name|PXP2_REG_RQ_BW_RD_ADD12
block|,
name|PXP2_REG_RQ_BW_RD_UBOUND12
block|}
block|,
block|{
name|PXP2_REG_RQ_BW_RD_L13
block|,
name|PXP2_REG_RQ_BW_RD_ADD13
block|,
name|PXP2_REG_RQ_BW_RD_UBOUND13
block|}
block|,
block|{
name|PXP2_REG_RQ_BW_RD_L14
block|,
name|PXP2_REG_RQ_BW_RD_ADD14
block|,
name|PXP2_REG_RQ_BW_RD_UBOUND14
block|}
block|,
block|{
name|PXP2_REG_RQ_BW_RD_L15
block|,
name|PXP2_REG_RQ_BW_RD_ADD15
block|,
name|PXP2_REG_RQ_BW_RD_UBOUND15
block|}
block|,
block|{
name|PXP2_REG_RQ_BW_RD_L16
block|,
name|PXP2_REG_RQ_BW_RD_ADD16
block|,
name|PXP2_REG_RQ_BW_RD_UBOUND16
block|}
block|,
block|{
name|PXP2_REG_RQ_BW_RD_L17
block|,
name|PXP2_REG_RQ_BW_RD_ADD17
block|,
name|PXP2_REG_RQ_BW_RD_UBOUND17
block|}
block|,
block|{
name|PXP2_REG_RQ_BW_RD_L18
block|,
name|PXP2_REG_RQ_BW_RD_ADD18
block|,
name|PXP2_REG_RQ_BW_RD_UBOUND18
block|}
block|,
comment|/* 20 */
block|{
name|PXP2_REG_RQ_BW_RD_L19
block|,
name|PXP2_REG_RQ_BW_RD_ADD19
block|,
name|PXP2_REG_RQ_BW_RD_UBOUND19
block|}
block|,
block|{
name|PXP2_REG_RQ_BW_RD_L20
block|,
name|PXP2_REG_RQ_BW_RD_ADD20
block|,
name|PXP2_REG_RQ_BW_RD_UBOUND20
block|}
block|,
block|{
name|PXP2_REG_RQ_BW_RD_L22
block|,
name|PXP2_REG_RQ_BW_RD_ADD22
block|,
name|PXP2_REG_RQ_BW_RD_UBOUND22
block|}
block|,
block|{
name|PXP2_REG_RQ_BW_RD_L23
block|,
name|PXP2_REG_RQ_BW_RD_ADD23
block|,
name|PXP2_REG_RQ_BW_RD_UBOUND23
block|}
block|,
block|{
name|PXP2_REG_RQ_BW_RD_L24
block|,
name|PXP2_REG_RQ_BW_RD_ADD24
block|,
name|PXP2_REG_RQ_BW_RD_UBOUND24
block|}
block|,
block|{
name|PXP2_REG_RQ_BW_RD_L25
block|,
name|PXP2_REG_RQ_BW_RD_ADD25
block|,
name|PXP2_REG_RQ_BW_RD_UBOUND25
block|}
block|,
block|{
name|PXP2_REG_RQ_BW_RD_L26
block|,
name|PXP2_REG_RQ_BW_RD_ADD26
block|,
name|PXP2_REG_RQ_BW_RD_UBOUND26
block|}
block|,
block|{
name|PXP2_REG_RQ_BW_RD_L27
block|,
name|PXP2_REG_RQ_BW_RD_ADD27
block|,
name|PXP2_REG_RQ_BW_RD_UBOUND27
block|}
block|,
block|{
name|PXP2_REG_PSWRQ_BW_L28
block|,
name|PXP2_REG_PSWRQ_BW_ADD28
block|,
name|PXP2_REG_PSWRQ_BW_UB28
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Register addresses for write queues. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|arb_line
name|write_arb_addr
index|[
name|NUM_WR_Q
operator|-
literal|1
index|]
init|=
block|{
comment|/* 1 */
block|{
name|PXP2_REG_PSWRQ_BW_L1
block|,
name|PXP2_REG_PSWRQ_BW_ADD1
block|,
name|PXP2_REG_PSWRQ_BW_UB1
block|}
block|,
block|{
name|PXP2_REG_PSWRQ_BW_L2
block|,
name|PXP2_REG_PSWRQ_BW_ADD2
block|,
name|PXP2_REG_PSWRQ_BW_UB2
block|}
block|,
block|{
name|PXP2_REG_PSWRQ_BW_L3
block|,
name|PXP2_REG_PSWRQ_BW_ADD3
block|,
name|PXP2_REG_PSWRQ_BW_UB3
block|}
block|,
block|{
name|PXP2_REG_PSWRQ_BW_L6
block|,
name|PXP2_REG_PSWRQ_BW_ADD6
block|,
name|PXP2_REG_PSWRQ_BW_UB6
block|}
block|,
block|{
name|PXP2_REG_PSWRQ_BW_L7
block|,
name|PXP2_REG_PSWRQ_BW_ADD7
block|,
name|PXP2_REG_PSWRQ_BW_UB7
block|}
block|,
block|{
name|PXP2_REG_PSWRQ_BW_L8
block|,
name|PXP2_REG_PSWRQ_BW_ADD8
block|,
name|PXP2_REG_PSWRQ_BW_UB8
block|}
block|,
block|{
name|PXP2_REG_PSWRQ_BW_L9
block|,
name|PXP2_REG_PSWRQ_BW_ADD9
block|,
name|PXP2_REG_PSWRQ_BW_UB9
block|}
block|,
block|{
name|PXP2_REG_PSWRQ_BW_L10
block|,
name|PXP2_REG_PSWRQ_BW_ADD10
block|,
name|PXP2_REG_PSWRQ_BW_UB10
block|}
block|,
block|{
name|PXP2_REG_PSWRQ_BW_L11
block|,
name|PXP2_REG_PSWRQ_BW_ADD11
block|,
name|PXP2_REG_PSWRQ_BW_UB11
block|}
block|,
comment|/* 10 */
block|{
name|PXP2_REG_PSWRQ_BW_L28
block|,
name|PXP2_REG_PSWRQ_BW_ADD28
block|,
name|PXP2_REG_PSWRQ_BW_UB28
block|}
block|,
block|{
name|PXP2_REG_RQ_BW_WR_L29
block|,
name|PXP2_REG_RQ_BW_WR_ADD29
block|,
name|PXP2_REG_RQ_BW_WR_UBOUND29
block|}
block|,
block|{
name|PXP2_REG_RQ_BW_WR_L30
block|,
name|PXP2_REG_RQ_BW_WR_ADD30
block|,
name|PXP2_REG_RQ_BW_WR_UBOUND30
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|bxe_init_pxp_arb
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|r_order
parameter_list|,
name|int
name|w_order
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|r_order
operator|>
name|MAX_RD_ORD
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
operator|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator|)
argument_list|,
literal|"%s(): Read order of %d order adjusted to %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|r_order
argument_list|,
name|MAX_RD_ORD
argument_list|)
expr_stmt|;
name|r_order
operator|=
name|MAX_RD_ORD
expr_stmt|;
block|}
if|if
condition|(
name|w_order
operator|>
name|MAX_WR_ORD
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
operator|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator|)
argument_list|,
literal|"%s(): Write order of %d order adjusted to %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|w_order
argument_list|,
name|MAX_WR_ORD
argument_list|)
expr_stmt|;
name|w_order
operator|=
name|MAX_WR_ORD
expr_stmt|;
block|}
name|DBPRINT
argument_list|(
name|sc
argument_list|,
operator|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator|)
argument_list|,
literal|"%s(): Read order %d, write order %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|r_order
argument_list|,
name|w_order
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_RD_Q
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|read_arb_addr
index|[
name|i
index|]
operator|.
name|l
argument_list|,
name|read_arb_data
index|[
name|i
index|]
index|[
name|r_order
index|]
operator|.
name|l
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|read_arb_addr
index|[
name|i
index|]
operator|.
name|add
argument_list|,
name|read_arb_data
index|[
name|i
index|]
index|[
name|r_order
index|]
operator|.
name|add
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|read_arb_addr
index|[
name|i
index|]
operator|.
name|ubound
argument_list|,
name|read_arb_data
index|[
name|i
index|]
index|[
name|r_order
index|]
operator|.
name|ubound
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_WR_Q
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|write_arb_addr
index|[
name|i
index|]
operator|.
name|l
operator|==
name|PXP2_REG_RQ_BW_WR_L29
operator|)
operator|||
operator|(
name|write_arb_addr
index|[
name|i
index|]
operator|.
name|l
operator|==
name|PXP2_REG_RQ_BW_WR_L30
operator|)
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|write_arb_addr
index|[
name|i
index|]
operator|.
name|l
argument_list|,
name|write_arb_data
index|[
name|i
index|]
index|[
name|w_order
index|]
operator|.
name|l
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|write_arb_addr
index|[
name|i
index|]
operator|.
name|add
argument_list|,
name|write_arb_data
index|[
name|i
index|]
index|[
name|w_order
index|]
operator|.
name|add
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|write_arb_addr
index|[
name|i
index|]
operator|.
name|ubound
argument_list|,
name|write_arb_data
index|[
name|i
index|]
index|[
name|w_order
index|]
operator|.
name|ubound
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|write_arb_addr
index|[
name|i
index|]
operator|.
name|l
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|write_arb_addr
index|[
name|i
index|]
operator|.
name|l
argument_list|,
name|val
operator||
operator|(
name|write_arb_data
index|[
name|i
index|]
index|[
name|w_order
index|]
operator|.
name|l
operator|<<
literal|10
operator|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|write_arb_addr
index|[
name|i
index|]
operator|.
name|add
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|write_arb_addr
index|[
name|i
index|]
operator|.
name|add
argument_list|,
name|val
operator||
operator|(
name|write_arb_data
index|[
name|i
index|]
index|[
name|w_order
index|]
operator|.
name|add
operator|<<
literal|10
operator|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|write_arb_addr
index|[
name|i
index|]
operator|.
name|ubound
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|write_arb_addr
index|[
name|i
index|]
operator|.
name|ubound
argument_list|,
name|val
operator||
operator|(
name|write_arb_data
index|[
name|i
index|]
index|[
name|w_order
index|]
operator|.
name|ubound
operator|<<
literal|7
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|val
operator|=
name|write_arb_data
index|[
name|NUM_WR_Q
operator|-
literal|1
index|]
index|[
name|w_order
index|]
operator|.
name|add
expr_stmt|;
name|val
operator|+=
name|write_arb_data
index|[
name|NUM_WR_Q
operator|-
literal|1
index|]
index|[
name|w_order
index|]
operator|.
name|ubound
operator|<<
literal|10
expr_stmt|;
name|val
operator|+=
name|write_arb_data
index|[
name|NUM_WR_Q
operator|-
literal|1
index|]
index|[
name|w_order
index|]
operator|.
name|l
operator|<<
literal|17
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_PSWRQ_BW_RD
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|read_arb_data
index|[
name|NUM_RD_Q
operator|-
literal|1
index|]
index|[
name|r_order
index|]
operator|.
name|add
expr_stmt|;
name|val
operator|+=
name|read_arb_data
index|[
name|NUM_RD_Q
operator|-
literal|1
index|]
index|[
name|r_order
index|]
operator|.
name|ubound
operator|<<
literal|10
expr_stmt|;
name|val
operator|+=
name|read_arb_data
index|[
name|NUM_RD_Q
operator|-
literal|1
index|]
index|[
name|r_order
index|]
operator|.
name|l
operator|<<
literal|17
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_PSWRQ_BW_WR
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RQ_WR_MBS0
argument_list|,
name|w_order
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RQ_WR_MBS1
argument_list|,
name|w_order
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RQ_RD_MBS0
argument_list|,
name|r_order
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RQ_RD_MBS1
argument_list|,
name|r_order
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_order
operator|==
name|MAX_RD_ORD
condition|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RQ_PDR_LIMIT
argument_list|,
literal|0xe00
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_WR_USDMDP_TH
argument_list|,
operator|(
literal|0x18
operator|<<
name|w_order
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/*    MPS      w_order     optimal TH      presently TH 		 *    128         0             0               2 		 *    256         1             1               3 		 *>=512       2             2               3 		 */
name|val
operator|=
operator|(
operator|(
name|w_order
operator|==
literal|0
operator|)
condition|?
literal|2
else|:
literal|3
operator|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_WR_HC_MPS
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_WR_USDM_MPS
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_WR_CSDM_MPS
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_WR_TSDM_MPS
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_WR_XSDM_MPS
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_WR_QM_MPS
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_WR_TM_MPS
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_WR_SRC_MPS
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_WR_DBG_MPS
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_WR_DMAE_MPS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* DMAE is special */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_WR_CDU_MPS
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_init_pxp
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint16_t
name|devctl
decl_stmt|;
name|int
name|r_order
decl_stmt|,
name|w_order
decl_stmt|;
name|devctl
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|pcie_cap
operator|+
name|PCI_EXP_DEVCTL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
operator|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator|)
argument_list|,
literal|"%s(): Read 0x%x from devctl\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|devctl
argument_list|)
expr_stmt|;
name|w_order
operator|=
operator|(
operator|(
name|devctl
operator|&
name|PCI_EXP_DEVCTL_PAYLOAD
operator|)
operator|>>
literal|5
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mrrs
operator|==
operator|-
literal|1
condition|)
name|r_order
operator|=
operator|(
operator|(
name|devctl
operator|&
name|PCI_EXP_DEVCTL_READRQ
operator|)
operator|>>
literal|12
operator|)
expr_stmt|;
else|else
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
operator|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator|)
argument_list|,
literal|"%s(): Force MRRS read order to %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|mrrs
argument_list|)
expr_stmt|;
name|r_order
operator|=
name|sc
operator|->
name|mrrs
expr_stmt|;
block|}
name|bxe_init_pxp_arb
argument_list|(
name|sc
argument_list|,
name|r_order
argument_list|,
name|w_order
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_setup_fan_failure_detection
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|phy_type
decl_stmt|,
name|val
decl_stmt|;
name|int
name|is_required
decl_stmt|,
name|port
decl_stmt|;
name|is_required
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|NOMCP
argument_list|(
name|sc
argument_list|)
condition|)
return|return;
name|val
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|dev_info
operator|.
name|shared_hw_config
operator|.
name|config2
argument_list|)
operator|&
name|SHARED_HW_CFG_FAN_FAILURE_MASK
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|SHARED_HW_CFG_FAN_FAILURE_ENABLED
condition|)
name|is_required
operator|=
literal|1
expr_stmt|;
comment|/* 	 * The fan failure mechanism is usually related to the PHY type since 	 * the power consumption of the board is affected by the PHY. Currently, 	 * fan is required for most designs with SFX7101, BCM8727 and BCM8481. 	 */
elseif|else
if|if
condition|(
name|val
operator|==
name|SHARED_HW_CFG_FAN_FAILURE_PHY_TYPE
condition|)
for|for
control|(
name|port
operator|=
name|PORT_0
init|;
name|port
operator|<
name|PORT_MAX
condition|;
name|port
operator|++
control|)
block|{
name|phy_type
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|port
index|]
operator|.
name|external_phy_config
argument_list|)
operator|&
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_MASK
expr_stmt|;
name|is_required
operator||=
operator|(
operator|(
name|phy_type
operator|==
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_SFX7101
operator|)
operator|||
operator|(
name|phy_type
operator|==
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727
operator|)
operator|||
operator|(
name|phy_type
operator|==
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8481
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|is_required
operator|==
literal|0
condition|)
return|return;
comment|/* Fan failure is indicated by SPIO 5. */
name|bxe_set_spio
argument_list|(
name|sc
argument_list|,
name|MISC_REGISTERS_SPIO_5
argument_list|,
name|MISC_REGISTERS_SPIO_INPUT_HI_Z
argument_list|)
expr_stmt|;
comment|/* Set to active low mode. */
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_SPIO_INT
argument_list|)
expr_stmt|;
name|val
operator||=
operator|(
operator|(
literal|1
operator|<<
name|MISC_REGISTERS_SPIO_5
operator|)
operator|<<
name|MISC_REGISTERS_SPIO_INT_OLD_SET_POS
operator|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_SPIO_INT
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Enable interrupt to signal the IGU. */
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_SPIO_EVENT_EN
argument_list|)
expr_stmt|;
name|val
operator||=
operator|(
literal|1
operator|<<
name|MISC_REGISTERS_SPIO_5
operator|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_SPIO_EVENT_EN
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Common initialization.  *  * Returns:  *   0 = Success, !0 = Failure.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_init_common
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
comment|/* Reset all blocks within the chip except the BMAC. */
name|bxe_reset_common
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|30000
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_1_SET
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_2_SET
argument_list|,
literal|0xfffc
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|30000
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|MISC_BLOCK
argument_list|,
name|COMMON_STAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
condition|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_E1HMF_MODE
argument_list|,
name|IS_E1HMF
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_LCPLL_CTRL_REG_2
argument_list|,
literal|0x100
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|30000
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_LCPLL_CTRL_REG_2
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|PXP_BLOCK
argument_list|,
name|COMMON_STAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* 		 * Enable HW interrupt from PXP on USDM overflow 		 * bit 16 on INT_MASK_0. 		 */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP_REG_PXP_INT_MASK_0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|PXP2_BLOCK
argument_list|,
name|COMMON_STAGE
argument_list|)
expr_stmt|;
name|bxe_init_pxp
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__BIG_ENDIAN
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RQ_QM_ENDIAN_M
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RQ_TM_ENDIAN_M
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RQ_SRC_ENDIAN_M
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RQ_CDU_ENDIAN_M
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RQ_DBG_ENDIAN_M
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Make sure this value is 0. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RQ_HC_ENDIAN_M
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RD_QM_SWAP_MODE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RD_TM_SWAP_MODE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RD_SRC_SWAP_MODE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RD_CDURD_SWAP_MODE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RQ_CDU_P_SIZE
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Let the HW do it's magic ... */
name|DELAY
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
comment|/* Finish the PXP initialization. */
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RQ_CFG_DONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|1
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): PXP2 CFG failed!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|bxe_init_common_exit
goto|;
block|}
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RD_INIT_DONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|1
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): PXP2 RD_INIT failed!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|bxe_init_common_exit
goto|;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RQ_DISABLE_INPUTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RD_DISABLE_INPUTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|DMAE_BLOCK
argument_list|,
name|COMMON_STAGE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dmae_ready
operator|=
literal|1
expr_stmt|;
name|bxe_init_fill
argument_list|(
name|sc
argument_list|,
name|TSEM_REG_PRAM
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|TCM_BLOCK
argument_list|,
name|COMMON_STAGE
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|UCM_BLOCK
argument_list|,
name|COMMON_STAGE
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|CCM_BLOCK
argument_list|,
name|COMMON_STAGE
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|XCM_BLOCK
argument_list|,
name|COMMON_STAGE
argument_list|)
expr_stmt|;
name|bxe_read_dmae
argument_list|(
name|sc
argument_list|,
name|XSEM_REG_PASSIVE_BUFFER
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|bxe_read_dmae
argument_list|(
name|sc
argument_list|,
name|CSEM_REG_PASSIVE_BUFFER
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|bxe_read_dmae
argument_list|(
name|sc
argument_list|,
name|TSEM_REG_PASSIVE_BUFFER
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|bxe_read_dmae
argument_list|(
name|sc
argument_list|,
name|USEM_REG_PASSIVE_BUFFER
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|QM_BLOCK
argument_list|,
name|COMMON_STAGE
argument_list|)
expr_stmt|;
comment|/* Soft reset pulse. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|QM_REG_SOFT_RESET
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|QM_REG_SOFT_RESET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|DQ_BLOCK
argument_list|,
name|COMMON_STAGE
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|DORQ_REG_DPM_CID_OFST
argument_list|,
name|BCM_PAGE_SHIFT
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|DORQ_REG_DORQ_INT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|BRB1_BLOCK
argument_list|,
name|COMMON_STAGE
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|PRS_BLOCK
argument_list|,
name|COMMON_STAGE
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PRS_REG_A_PRSU_20
argument_list|,
literal|0xf
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
condition|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PRS_REG_E1HOV_MODE
argument_list|,
name|IS_E1HMF
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|TSDM_BLOCK
argument_list|,
name|COMMON_STAGE
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|CSDM_BLOCK
argument_list|,
name|COMMON_STAGE
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|USDM_BLOCK
argument_list|,
name|COMMON_STAGE
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|XSDM_BLOCK
argument_list|,
name|COMMON_STAGE
argument_list|)
expr_stmt|;
comment|/* Clear STORM processor memory. */
name|bxe_init_fill
argument_list|(
name|sc
argument_list|,
name|TSEM_REG_FAST_MEMORY
argument_list|,
literal|0
argument_list|,
name|STORM_INTMEM_SIZE
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|bxe_init_fill
argument_list|(
name|sc
argument_list|,
name|USEM_REG_FAST_MEMORY
argument_list|,
literal|0
argument_list|,
name|STORM_INTMEM_SIZE
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|bxe_init_fill
argument_list|(
name|sc
argument_list|,
name|CSEM_REG_FAST_MEMORY
argument_list|,
literal|0
argument_list|,
name|STORM_INTMEM_SIZE
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|bxe_init_fill
argument_list|(
name|sc
argument_list|,
name|XSEM_REG_FAST_MEMORY
argument_list|,
literal|0
argument_list|,
name|STORM_INTMEM_SIZE
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|TSEM_BLOCK
argument_list|,
name|COMMON_STAGE
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|USEM_BLOCK
argument_list|,
name|COMMON_STAGE
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|CSEM_BLOCK
argument_list|,
name|COMMON_STAGE
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|XSEM_BLOCK
argument_list|,
name|COMMON_STAGE
argument_list|)
expr_stmt|;
comment|/* Sync semi rtc. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_1_CLEAR
argument_list|,
literal|0x80000000
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_1_SET
argument_list|,
literal|0x80000000
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|UPB_BLOCK
argument_list|,
name|COMMON_STAGE
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|XPB_BLOCK
argument_list|,
name|COMMON_STAGE
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|PBF_BLOCK
argument_list|,
name|COMMON_STAGE
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|SRC_REG_SOFT_RST
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Setup RSS/multi-queue hasking keys. */
for|for
control|(
name|i
operator|=
name|SRC_REG_KEYRSS0_0
init|;
name|i
operator|<=
name|SRC_REG_KEYRSS1_9
condition|;
name|i
operator|+=
literal|4
control|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
literal|0xc0cac01a
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|SRCH_BLOCK
argument_list|,
name|COMMON_STAGE
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|SRC_REG_SOFT_RST
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Make sure the cdu_context structure has the right size. */
if|if
condition|(
sizeof|sizeof
argument_list|(
expr|union
name|cdu_context
argument_list|)
operator|!=
literal|1024
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Invalid size for context (%ld != 1024)!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
expr|union
name|cdu_context
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|bxe_init_common_exit
goto|;
block|}
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|CDU_BLOCK
argument_list|,
name|COMMON_STAGE
argument_list|)
expr_stmt|;
comment|/* 	 * val = (num_context_in_page<< 24) + 	 * (context_waste_size<< 12) + 	 * context_line_size. 	 */
name|val
operator|=
operator|(
literal|4
operator|<<
literal|24
operator|)
operator|+
operator|(
literal|0
operator|<<
literal|12
operator|)
operator|+
literal|1024
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|CDU_REG_CDU_GLOBAL_PARAMS
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|CFC_BLOCK
argument_list|,
name|COMMON_STAGE
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|CFC_REG_INIT_REG
argument_list|,
literal|0x7FF
argument_list|)
expr_stmt|;
comment|/* Enable context validation interrupt from CFC. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|CFC_REG_CFC_INT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set the thresholds to prevent CFC/CDU race. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|CFC_REG_DEBUG0
argument_list|,
literal|0x20020000
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|HC_BLOCK
argument_list|,
name|COMMON_STAGE
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|MISC_AEU_BLOCK
argument_list|,
name|COMMON_STAGE
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|PXPCS_BLOCK
argument_list|,
name|COMMON_STAGE
argument_list|)
expr_stmt|;
comment|/* Clear PCIe block debug status bits. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
literal|0x2814
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
literal|0x3820
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|EMAC0_BLOCK
argument_list|,
name|COMMON_STAGE
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|EMAC1_BLOCK
argument_list|,
name|COMMON_STAGE
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|DBU_BLOCK
argument_list|,
name|COMMON_STAGE
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|DBG_BLOCK
argument_list|,
name|COMMON_STAGE
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|NIG_BLOCK
argument_list|,
name|COMMON_STAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LLH_MF_MODE
argument_list|,
name|IS_E1HMF
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LLH_E1HOV_MODE
argument_list|,
name|IS_E1HOV
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Finish CFC initialization. */
name|val
operator|=
name|bxe_reg_poll
argument_list|(
name|sc
argument_list|,
name|CFC_REG_LL_INIT_DONE
argument_list|,
literal|1
argument_list|,
literal|100
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|1
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): CFC LL_INIT failed!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|bxe_init_common_exit
goto|;
block|}
name|val
operator|=
name|bxe_reg_poll
argument_list|(
name|sc
argument_list|,
name|CFC_REG_AC_INIT_DONE
argument_list|,
literal|1
argument_list|,
literal|100
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|1
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): CFC AC_INIT failed!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|bxe_init_common_exit
goto|;
block|}
name|val
operator|=
name|bxe_reg_poll
argument_list|(
name|sc
argument_list|,
name|CFC_REG_CAM_INIT_DONE
argument_list|,
literal|1
argument_list|,
literal|100
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|1
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): CFC CAM_INIT failed!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|bxe_init_common_exit
goto|;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|CFC_REG_DEBUG0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Read NIG statistic and check for first load since powerup. */
name|bxe_read_dmae
argument_list|(
name|sc
argument_list|,
name|NIG_REG_STAT2_BRB_OCTET
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|val
operator|=
operator|*
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|wb_data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Do internal memory self test only after a full power cycle. */
if|if
condition|(
operator|(
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
operator|)
operator|&&
operator|(
name|val
operator|==
literal|0
operator|)
operator|&&
name|bxe_int_mem_test
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Internal memory self-test failed!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|bxe_init_common_exit
goto|;
block|}
comment|/* Handle any board specific initialization. */
switch|switch
condition|(
name|XGXS_EXT_PHY_TYPE
argument_list|(
name|sc
operator|->
name|link_params
operator|.
name|ext_phy_config
argument_list|)
condition|)
block|{
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8072
case|:
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073
case|:
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726
case|:
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727
case|:
break|break;
default|default:
break|break;
block|}
name|bxe_setup_fan_failure_detection
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Clear PXP2 attentions. */
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_PXP2_INT_STS_CLR_0
argument_list|)
expr_stmt|;
name|bxe_enable_blocks_attention
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NOMCP
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|bxe_acquire_phy_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_common_init_phy
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|common
operator|.
name|shmem_base
argument_list|)
expr_stmt|;
name|bxe_release_phy_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Bootcode is missing - cannot initialize PHY!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|bxe_init_common_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Port initialization.  *  * Returns:  *   0 = Success, !0 = Failure.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_init_port
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|,
name|low
decl_stmt|,
name|high
decl_stmt|;
name|uint32_t
name|swap_val
decl_stmt|,
name|swap_override
decl_stmt|,
name|aeu_gpio_mask
decl_stmt|,
name|offset
decl_stmt|;
name|uint32_t
name|reg_addr
decl_stmt|;
name|int
name|init_stage
decl_stmt|,
name|port
decl_stmt|;
name|port
operator|=
name|BP_PORT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|init_stage
operator|=
name|port
condition|?
name|PORT1_STAGE
else|:
name|PORT0_STAGE
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
operator|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator|)
argument_list|,
literal|"%s(): Initializing port %d.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_MASK_INTERRUPT_PORT0
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|PXP_BLOCK
argument_list|,
name|init_stage
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|PXP2_BLOCK
argument_list|,
name|init_stage
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|TCM_BLOCK
argument_list|,
name|init_stage
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|UCM_BLOCK
argument_list|,
name|init_stage
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|CCM_BLOCK
argument_list|,
name|init_stage
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|XCM_BLOCK
argument_list|,
name|init_stage
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|DQ_BLOCK
argument_list|,
name|init_stage
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|BRB1_BLOCK
argument_list|,
name|init_stage
argument_list|)
expr_stmt|;
comment|/* Determine the pause threshold for the BRB */
if|if
condition|(
name|IS_E1HMF
argument_list|(
name|sc
argument_list|)
condition|)
name|low
operator|=
operator|(
name|sc
operator|->
name|bxe_flags
operator|&
name|BXE_ONE_PORT_FLAG
operator|)
condition|?
literal|160
else|:
literal|246
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|bxe_ifp
operator|->
name|if_mtu
operator|>
literal|4096
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|bxe_flags
operator|&
name|BXE_ONE_PORT_FLAG
condition|)
name|low
operator|=
literal|160
expr_stmt|;
else|else
block|{
name|val
operator|=
name|sc
operator|->
name|bxe_ifp
operator|->
name|if_mtu
expr_stmt|;
comment|/* (24*1024 + val*4)/256 */
name|low
operator|=
literal|96
operator|+
operator|(
name|val
operator|/
literal|64
operator|)
operator|+
operator|(
operator|(
name|val
operator|%
literal|64
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
block|}
block|}
else|else
name|low
operator|=
operator|(
name|sc
operator|->
name|bxe_flags
operator|&
name|BXE_ONE_PORT_FLAG
operator|)
condition|?
literal|80
else|:
literal|160
expr_stmt|;
name|high
operator|=
name|low
operator|+
literal|56
expr_stmt|;
comment|/* 14 * 1024 / 256 */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BRB1_REG_PAUSE_LOW_THRESHOLD_0
operator|+
name|port
operator|*
literal|4
argument_list|,
name|low
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BRB1_REG_PAUSE_HIGH_THRESHOLD_0
operator|+
name|port
operator|*
literal|4
argument_list|,
name|high
argument_list|)
expr_stmt|;
comment|/* Port PRS comes here. */
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|PRS_BLOCK
argument_list|,
name|init_stage
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|TSDM_BLOCK
argument_list|,
name|init_stage
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|CSDM_BLOCK
argument_list|,
name|init_stage
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|USDM_BLOCK
argument_list|,
name|init_stage
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|XSDM_BLOCK
argument_list|,
name|init_stage
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|TSEM_BLOCK
argument_list|,
name|init_stage
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|USEM_BLOCK
argument_list|,
name|init_stage
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|CSEM_BLOCK
argument_list|,
name|init_stage
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|XSEM_BLOCK
argument_list|,
name|init_stage
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|UPB_BLOCK
argument_list|,
name|init_stage
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|XPB_BLOCK
argument_list|,
name|init_stage
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|PBF_BLOCK
argument_list|,
name|init_stage
argument_list|)
expr_stmt|;
comment|/* Configure PBF to work without pause for MTU = 9000. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_P0_PAUSE_ENABLE
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Update threshold. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_P0_ARB_THRSH
operator|+
name|port
operator|*
literal|4
argument_list|,
operator|(
literal|9040
operator|/
literal|16
operator|)
argument_list|)
expr_stmt|;
comment|/* Update initial credit. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_P0_INIT_CRD
operator|+
name|port
operator|*
literal|4
argument_list|,
operator|(
literal|9040
operator|/
literal|16
operator|)
operator|+
literal|553
operator|-
literal|22
argument_list|)
expr_stmt|;
comment|/* Probe changes. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_INIT_P0
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_INIT_P0
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|CDU_BLOCK
argument_list|,
name|init_stage
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|CFC_BLOCK
argument_list|,
name|init_stage
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|HC_REG_LEADING_EDGE_0
operator|+
name|port
operator|*
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|HC_REG_TRAILING_EDGE_0
operator|+
name|port
operator|*
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|HC_BLOCK
argument_list|,
name|init_stage
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|MISC_AEU_BLOCK
argument_list|,
name|init_stage
argument_list|)
expr_stmt|;
comment|/* 	 * init aeu_mask_attn_func_0/1: 	 *  - SF mode: bits 3-7 are masked. only bits 0-2 are in use 	 *  - MF mode: bit 3 is masked. bits 0-2 are in use as in SF 	 *             bits 4-7 are used for "per vn group attention" 	 */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_MASK_ATTN_FUNC_0
operator|+
name|port
operator|*
literal|4
argument_list|,
operator|(
name|IS_E1HMF
argument_list|(
name|sc
argument_list|)
condition|?
literal|0xF7
else|:
literal|0x7
operator|)
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|PXPCS_BLOCK
argument_list|,
name|init_stage
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|EMAC0_BLOCK
argument_list|,
name|init_stage
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|EMAC1_BLOCK
argument_list|,
name|init_stage
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|DBU_BLOCK
argument_list|,
name|init_stage
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|DBG_BLOCK
argument_list|,
name|init_stage
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|NIG_BLOCK
argument_list|,
name|init_stage
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_XGXS_SERDES0_MODE_SEL
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* Enable outer VLAN support if required. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LLH0_BRB1_DRV_MASK_MF
operator|+
name|port
operator|*
literal|4
argument_list|,
operator|(
name|IS_E1HOV
argument_list|(
name|sc
argument_list|)
condition|?
literal|0x1
else|:
literal|0x2
operator|)
argument_list|)
expr_stmt|;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LLFC_ENABLE_0
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LLFC_OUT_EN_0
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_PAUSE_ENABLE_0
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|MCP_BLOCK
argument_list|,
name|init_stage
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|DMAE_BLOCK
argument_list|,
name|init_stage
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|XGXS_EXT_PHY_TYPE
argument_list|(
name|sc
operator|->
name|link_params
operator|.
name|ext_phy_config
argument_list|)
condition|)
block|{
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726
case|:
name|bxe_set_gpio
argument_list|(
name|sc
argument_list|,
name|MISC_REGISTERS_GPIO_3
argument_list|,
name|MISC_REGISTERS_GPIO_INPUT_HI_Z
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/* 		 * The GPIO should be swapped if the swap register is 		 * set and active. 		 */
name|swap_val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_PORT_SWAP
argument_list|)
expr_stmt|;
name|swap_override
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_STRAP_OVERRIDE
argument_list|)
expr_stmt|;
comment|/* Select function upon port-swap configuration. */
if|if
condition|(
name|port
operator|==
literal|0
condition|)
block|{
name|offset
operator|=
name|MISC_REG_AEU_ENABLE1_FUNC_0_OUT_0
expr_stmt|;
name|aeu_gpio_mask
operator|=
operator|(
name|swap_val
operator|&&
name|swap_override
operator|)
condition|?
name|AEU_INPUTS_ATTN_BITS_GPIO3_FUNCTION_1
else|:
name|AEU_INPUTS_ATTN_BITS_GPIO3_FUNCTION_0
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|=
name|MISC_REG_AEU_ENABLE1_FUNC_1_OUT_0
expr_stmt|;
name|aeu_gpio_mask
operator|=
operator|(
name|swap_val
operator|&&
name|swap_override
operator|)
condition|?
name|AEU_INPUTS_ATTN_BITS_GPIO3_FUNCTION_0
else|:
name|AEU_INPUTS_ATTN_BITS_GPIO3_FUNCTION_1
expr_stmt|;
block|}
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* Add GPIO3 to group. */
name|val
operator||=
name|aeu_gpio_mask
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_SFX7101
case|:
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727
case|:
comment|/* Add SPIO 5 to group 0. */
name|reg_addr
operator|=
name|port
condition|?
name|MISC_REG_AEU_ENABLE1_FUNC_1_OUT_0
else|:
name|MISC_REG_AEU_ENABLE1_FUNC_0_OUT_0
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|reg_addr
argument_list|)
expr_stmt|;
name|val
operator||=
name|AEU_INPUTS_ATTN_BITS_SPIO5
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|reg_addr
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|bxe__link_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ILT_PER_FUNC
value|(768/2)
end_define

begin_define
define|#
directive|define
name|FUNC_ILT_BASE
parameter_list|(
name|func
parameter_list|)
value|(func * ILT_PER_FUNC)
end_define

begin_comment
comment|/*  * The phys address is shifted right 12 bits and has an added 1=valid  * bit added to the 53rd bit (bit 52) then since this is a wide  * register(TM) we split it into two 32 bit writes.  */
end_comment

begin_define
define|#
directive|define
name|ONCHIP_ADDR1
parameter_list|(
name|x
parameter_list|)
value|((uint32_t)(((uint64_t)x>> 12)& 0xFFFFFFFF))
end_define

begin_define
define|#
directive|define
name|ONCHIP_ADDR2
parameter_list|(
name|x
parameter_list|)
value|((uint32_t)((1<< 20) | ((uint64_t)x>> 44)))
end_define

begin_define
define|#
directive|define
name|PXP_ONE_ILT
parameter_list|(
name|x
parameter_list|)
value|(((x)<< 10) | x)
end_define

begin_define
define|#
directive|define
name|PXP_ILT_RANGE
parameter_list|(
name|f
parameter_list|,
name|l
parameter_list|)
value|(((l)<< 10) | f)
end_define

begin_define
define|#
directive|define
name|CNIC_ILT_LINES
value|0
end_define

begin_comment
comment|/*  * ILT write.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_ilt_wr
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|index
parameter_list|,
name|bus_addr_t
name|addr
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_INSANE_LOAD
operator||
name|BXE_INSANE_RESET
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
condition|)
name|reg
operator|=
name|PXP2_REG_RQ_ONCHIP_AT_B0
operator|+
name|index
operator|*
literal|8
expr_stmt|;
else|else
name|reg
operator|=
name|PXP2_REG_RQ_ONCHIP_AT
operator|+
name|index
operator|*
literal|8
expr_stmt|;
name|bxe_wb_wr
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
name|ONCHIP_ADDR1
argument_list|(
name|addr
argument_list|)
argument_list|,
name|ONCHIP_ADDR2
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_INSANE_LOAD
operator||
name|BXE_INSANE_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize a function.  *  * Returns:  *   0 = Success, !0 = Failure.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_init_func
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|addr
decl_stmt|,
name|val
decl_stmt|;
name|int
name|func
decl_stmt|,
name|i
decl_stmt|,
name|port
decl_stmt|;
name|port
operator|=
name|BP_PORT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|func
operator|=
name|BP_FUNC
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
operator|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator|)
argument_list|,
literal|"%s(): Initializing port %d, function %d.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|port
argument_list|,
name|func
argument_list|)
expr_stmt|;
comment|/* Set MSI reconfigure capability. */
name|addr
operator|=
operator|(
name|port
condition|?
name|HC_REG_CONFIG_1
else|:
name|HC_REG_CONFIG_0
operator|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|val
operator||=
name|HC_CONFIG_0_REG_MSI_ATTN_EN_0
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|i
operator|=
name|FUNC_ILT_BASE
argument_list|(
name|func
argument_list|)
expr_stmt|;
name|bxe_ilt_wr
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|context
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RQ_CDU_FIRST_ILT
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RQ_CDU_LAST_ILT
argument_list|,
name|i
operator|+
name|CNIC_ILT_LINES
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* E1 */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_PSWRQ_CDU0_L2P
operator|+
name|func
operator|*
literal|4
argument_list|,
name|PXP_ILT_RANGE
argument_list|(
name|i
argument_list|,
name|i
operator|+
name|CNIC_ILT_LINES
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|MISC_BLOCK
argument_list|,
name|FUNC0_STAGE
operator|+
name|func
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|TCM_BLOCK
argument_list|,
name|FUNC0_STAGE
operator|+
name|func
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|UCM_BLOCK
argument_list|,
name|FUNC0_STAGE
operator|+
name|func
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|CCM_BLOCK
argument_list|,
name|FUNC0_STAGE
operator|+
name|func
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|XCM_BLOCK
argument_list|,
name|FUNC0_STAGE
operator|+
name|func
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|TSEM_BLOCK
argument_list|,
name|FUNC0_STAGE
operator|+
name|func
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|USEM_BLOCK
argument_list|,
name|FUNC0_STAGE
operator|+
name|func
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|CSEM_BLOCK
argument_list|,
name|FUNC0_STAGE
operator|+
name|func
argument_list|)
expr_stmt|;
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|XSEM_BLOCK
argument_list|,
name|FUNC0_STAGE
operator|+
name|func
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LLH0_FUNC_EN
operator|+
name|port
operator|*
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LLH0_FUNC_VLAN_ID
operator|+
name|port
operator|*
literal|8
argument_list|,
name|sc
operator|->
name|e1hov
argument_list|)
expr_stmt|;
block|}
comment|/* Host Coalescing initialization per function. */
if|if
condition|(
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_GENERAL_ATTN_12
operator|+
name|func
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|HC_REG_LEADING_EDGE_0
operator|+
name|port
operator|*
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|HC_REG_TRAILING_EDGE_0
operator|+
name|port
operator|*
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|bxe_init_block
argument_list|(
name|sc
argument_list|,
name|HC_BLOCK
argument_list|,
name|FUNC0_STAGE
operator|+
name|func
argument_list|)
expr_stmt|;
comment|/* Reset PCIe block debug values. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
literal|0x2114
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
literal|0x2120
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  * Returns:  *   0 = Failure, !0 = Failure.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_init_hw
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|load_code
parameter_list|)
block|{
name|int
name|func
decl_stmt|,
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dmae_ready
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|load_code
condition|)
block|{
case|case
name|FW_MSG_CODE_DRV_LOAD_COMMON
case|:
name|rc
operator|=
name|bxe_init_common
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|bxe_init_hw_exit
goto|;
comment|/* FALLTHROUGH */
case|case
name|FW_MSG_CODE_DRV_LOAD_PORT
case|:
name|sc
operator|->
name|dmae_ready
operator|=
literal|1
expr_stmt|;
name|rc
operator|=
name|bxe_init_port
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|bxe_init_hw_exit
goto|;
comment|/* FALLTHROUGH */
case|case
name|FW_MSG_CODE_DRV_LOAD_FUNCTION
case|:
name|sc
operator|->
name|dmae_ready
operator|=
literal|1
expr_stmt|;
name|rc
operator|=
name|bxe_init_func
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|bxe_init_hw_exit
goto|;
break|break;
default|default:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): Unknown load_code (0x%08X) from MCP!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|load_code
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Fetch additional config data if the bootcode is running. */
if|if
condition|(
operator|!
name|NOMCP
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|func
operator|=
name|BP_FUNC
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Fetch the pulse sequence number. */
name|sc
operator|->
name|fw_drv_pulse_wr_seq
operator|=
operator|(
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|func_mb
index|[
name|func
index|]
operator|.
name|drv_pulse_mb
argument_list|)
operator|&
name|DRV_PULSE_SEQ_MASK
operator|)
expr_stmt|;
block|}
comment|/* Clear the default status block. */
name|bxe_zero_def_sb
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
name|bxe_zero_sb
argument_list|(
name|sc
argument_list|,
name|BP_L_ID
argument_list|(
name|sc
argument_list|)
operator|+
name|i
argument_list|)
expr_stmt|;
name|bxe_init_hw_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send a firmware command and wait for the response.  *  * Post a command to shared memory for the bootcode running on the MCP and  * stall until the bootcode responds or a timeout occurs.  *  * Returns:  *   0 = Failure, otherwise firmware response code (FW_MSG_CODE_*).  */
end_comment

begin_function
specifier|static
name|int
name|bxe_fw_command
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|command
parameter_list|)
block|{
name|uint32_t
name|cnt
decl_stmt|,
name|rc
decl_stmt|,
name|seq
decl_stmt|;
name|int
name|func
decl_stmt|;
name|func
operator|=
name|BP_FUNC
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|seq
operator|=
operator|++
name|sc
operator|->
name|fw_seq
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
name|cnt
operator|=
literal|1
expr_stmt|;
name|DBRUNMSG
argument_list|(
name|BXE_VERBOSE
argument_list|,
name|bxe_decode_mb_msgs
argument_list|(
name|sc
argument_list|,
operator|(
name|command
operator||
name|seq
operator|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|BXE_FWMB_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Write the command to the shared memory mailbox. */
name|SHMEM_WR
argument_list|(
name|sc
argument_list|,
name|func_mb
index|[
name|func
index|]
operator|.
name|drv_mb_header
argument_list|,
operator|(
name|command
operator||
name|seq
operator|)
argument_list|)
expr_stmt|;
comment|/* Wait up to 2 seconds for a response. */
do|do
block|{
comment|/* Wait 10ms for a response. */
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/* Pickup the response. */
name|rc
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|func_mb
index|[
name|func
index|]
operator|.
name|fw_mb_header
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|seq
operator|!=
operator|(
name|rc
operator|&
name|FW_MSG_SEQ_NUMBER_MASK
operator|)
operator|)
operator|&&
operator|(
name|cnt
operator|++
operator|<
literal|400
operator|)
condition|)
do|;
name|DBRUNMSG
argument_list|(
name|BXE_VERBOSE
argument_list|,
name|bxe_decode_mb_msgs
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|rc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure we read the right response. */
if|if
condition|(
name|seq
operator|==
operator|(
name|rc
operator|&
name|FW_MSG_SEQ_NUMBER_MASK
operator|)
condition|)
name|rc
operator|&=
name|FW_MSG_CODE_MASK
expr_stmt|;
else|else
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Bootcode failed to respond!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|DBRUN
argument_list|(
name|bxe_dump_fw
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
block|}
name|BXE_FWMB_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a block of memory and map it for DMA.  No partial  * completions allowed, release any resources acquired if we  * can't acquire all resources.  *  * Returns:  *   0 = Success, !0 = Failure  *  * Modifies:  *   dma->paddr  *   dma->vaddr  *   dma->tag  *   dma->map  *   dma->size  *  */
end_comment

begin_function
specifier|static
name|int
name|bxe_dma_malloc
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|size
parameter_list|,
name|struct
name|bxe_dma
modifier|*
name|dma
parameter_list|,
name|int
name|mapflags
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
name|DBRUNIF
argument_list|(
name|dma
operator|->
name|size
operator|>
literal|0
argument_list|,
name|BXE_PRINTF
argument_list|(
literal|"%s(): Called for %s with size> 0 (%05d)!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|msg
argument_list|,
operator|(
name|int
operator|)
name|dma
operator|->
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_tag
argument_list|,
comment|/* parent */
name|BCM_PAGE_SIZE
argument_list|,
comment|/* alignment for segs */
name|BXE_DMA_BOUNDARY
argument_list|,
comment|/* cannot cross */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* restricted low */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* restricted hi */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter f(), arg */
name|size
argument_list|,
comment|/* max size for this tag */
literal|1
argument_list|,
comment|/* # of discontinuities */
name|size
argument_list|,
comment|/* max seg size */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lock f(), arg */
operator|&
name|dma
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): bus_dma_tag_create() "
literal|"failed (rc = %d) for %s!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|rc
argument_list|,
name|msg
argument_list|)
expr_stmt|;
goto|goto
name|bxe_dma_malloc_fail_create
goto|;
block|}
name|rc
operator|=
name|bus_dmamem_alloc
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|dma
operator|->
name|vaddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|dma
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): bus_dmamem_alloc() "
literal|"failed (rc = %d) for %s!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|rc
argument_list|,
name|msg
argument_list|)
expr_stmt|;
goto|goto
name|bxe_dma_malloc_fail_alloc
goto|;
block|}
name|rc
operator|=
name|bus_dmamap_load
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|,
name|dma
operator|->
name|vaddr
argument_list|,
name|size
argument_list|,
name|bxe_dma_map_addr
argument_list|,
operator|&
name|dma
operator|->
name|paddr
argument_list|,
name|mapflags
operator||
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): bus_dmamap_load() "
literal|"failed (rc = %d) for %s!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|rc
argument_list|,
name|msg
argument_list|)
expr_stmt|;
goto|goto
name|bxe_dma_malloc_fail_load
goto|;
block|}
name|dma
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE
argument_list|,
literal|"%s(): size=%06d, vaddr=0x%p, "
literal|"paddr=0x%jX - %s\n"
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|int
operator|)
name|dma
operator|->
name|size
argument_list|,
name|dma
operator|->
name|vaddr
argument_list|,
operator|(
name|uintmax_t
operator|)
name|dma
operator|->
name|paddr
argument_list|,
name|msg
argument_list|)
expr_stmt|;
goto|goto
name|bxe_dma_malloc_exit
goto|;
name|bxe_dma_malloc_fail_load
label|:
name|bus_dmamem_free
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|vaddr
argument_list|,
name|dma
operator|->
name|map
argument_list|)
expr_stmt|;
name|bxe_dma_malloc_fail_alloc
label|:
name|bus_dma_tag_destroy
argument_list|(
name|dma
operator|->
name|tag
argument_list|)
expr_stmt|;
name|dma
operator|->
name|vaddr
operator|=
name|NULL
expr_stmt|;
name|bxe_dma_malloc_fail_create
label|:
name|dma
operator|->
name|map
operator|=
name|NULL
expr_stmt|;
name|dma
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
name|dma
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|bxe_dma_malloc_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release a block of DMA memory associated tag/map.  *  * Returns:  *   None  */
end_comment

begin_function
specifier|static
name|void
name|bxe_dma_free
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bxe_dma
modifier|*
name|dma
parameter_list|)
block|{
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_UNLOAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|dma
operator|->
name|size
operator|>
literal|0
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|vaddr
argument_list|,
name|dma
operator|->
name|map
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|dma
operator|->
name|tag
argument_list|)
expr_stmt|;
name|dma
operator|->
name|size
operator|=
literal|0
expr_stmt|;
block|}
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_UNLOAD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free any DMA memory owned by the driver.  *  * Scans through each data structre that requires DMA memory and frees  * the memory if allocated.  *  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_host_structures_free
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|max_agg_queues
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator||
name|BXE_VERBOSE_UNLOAD
argument_list|)
expr_stmt|;
name|max_agg_queues
operator|=
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
condition|?
name|ETH_MAX_AGGREGATION_QUEUES_E1H
else|:
name|ETH_MAX_AGGREGATION_QUEUES_E1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|parent_tag
operator|==
name|NULL
condition|)
goto|goto
name|bxe_host_structures_free_exit
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
expr_stmt|;
comment|/* Trust no one! */
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
break|break;
comment|/* Status block. */
name|bxe_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|fp
operator|->
name|sb_dma
argument_list|)
expr_stmt|;
comment|/* TX chain. */
name|bxe_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|fp
operator|->
name|tx_dma
argument_list|)
expr_stmt|;
name|fp
operator|->
name|tx_chain
operator|=
name|NULL
expr_stmt|;
comment|/* RX chain */
name|bxe_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|fp
operator|->
name|rx_dma
argument_list|)
expr_stmt|;
name|fp
operator|->
name|rx_chain
operator|=
name|NULL
expr_stmt|;
comment|/* RCQ chain */
name|bxe_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|fp
operator|->
name|rcq_dma
argument_list|)
expr_stmt|;
name|fp
operator|->
name|rcq_chain
operator|=
name|NULL
expr_stmt|;
comment|/* SG chain */
name|bxe_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|fp
operator|->
name|sg_dma
argument_list|)
expr_stmt|;
name|fp
operator|->
name|sg_chain
operator|=
name|NULL
expr_stmt|;
comment|/* Unload and destroy the TX mbuf maps. */
if|if
condition|(
name|fp
operator|->
name|tx_mbuf_tag
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|TOTAL_TX_BD
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|fp
operator|->
name|tx_mbuf_map
index|[
name|j
index|]
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|fp
operator|->
name|tx_mbuf_tag
argument_list|,
name|fp
operator|->
name|tx_mbuf_map
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|fp
operator|->
name|tx_mbuf_tag
argument_list|,
name|fp
operator|->
name|tx_mbuf_map
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|bus_dma_tag_destroy
argument_list|(
name|fp
operator|->
name|tx_mbuf_tag
argument_list|)
expr_stmt|;
block|}
comment|/* Unload and destroy the TPA pool mbuf maps. */
if|if
condition|(
name|fp
operator|->
name|rx_mbuf_tag
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fp
operator|->
name|tpa_mbuf_spare_map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|fp
operator|->
name|tpa_mbuf_spare_map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|fp
operator|->
name|tpa_mbuf_spare_map
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|max_agg_queues
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|fp
operator|->
name|tpa_mbuf_map
index|[
name|j
index|]
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|fp
operator|->
name|tpa_mbuf_map
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|fp
operator|->
name|tpa_mbuf_map
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Unload and destroy the SGE Buf maps. */
if|if
condition|(
name|fp
operator|->
name|rx_sge_buf_tag
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fp
operator|->
name|rx_sge_spare_map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|fp
operator|->
name|rx_sge_buf_tag
argument_list|,
name|fp
operator|->
name|rx_sge_spare_map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|fp
operator|->
name|rx_sge_buf_tag
argument_list|,
name|fp
operator|->
name|rx_sge_spare_map
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|TOTAL_RX_SGE
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|fp
operator|->
name|rx_sge_buf_map
index|[
name|j
index|]
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|fp
operator|->
name|rx_sge_buf_tag
argument_list|,
name|fp
operator|->
name|rx_sge_buf_map
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|fp
operator|->
name|rx_sge_buf_tag
argument_list|,
name|fp
operator|->
name|rx_sge_buf_map
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|bus_dma_tag_destroy
argument_list|(
name|fp
operator|->
name|rx_sge_buf_tag
argument_list|)
expr_stmt|;
block|}
comment|/* Unload and destroy the RX mbuf maps. */
if|if
condition|(
name|fp
operator|->
name|rx_mbuf_tag
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fp
operator|->
name|rx_mbuf_spare_map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|fp
operator|->
name|rx_mbuf_spare_map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|fp
operator|->
name|rx_mbuf_spare_map
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|TOTAL_RX_BD
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|fp
operator|->
name|rx_mbuf_map
index|[
name|j
index|]
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|fp
operator|->
name|rx_mbuf_map
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|fp
operator|->
name|rx_mbuf_map
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|bus_dma_tag_destroy
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Destroy the default status block */
name|bxe_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|def_sb_dma
argument_list|)
expr_stmt|;
name|sc
operator|->
name|def_sb
operator|=
name|NULL
expr_stmt|;
comment|/* Destroy the statistics block */
name|bxe_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|stats_dma
argument_list|)
expr_stmt|;
name|sc
operator|->
name|stats
operator|=
name|NULL
expr_stmt|;
comment|/* Destroy the slowpath block. */
name|bxe_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|slowpath_dma
argument_list|)
expr_stmt|;
name|sc
operator|->
name|slowpath
operator|=
name|NULL
expr_stmt|;
comment|/* Destroy the slowpath queue. */
name|bxe_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|spq_dma
argument_list|)
expr_stmt|;
name|sc
operator|->
name|spq
operator|=
name|NULL
expr_stmt|;
comment|/* Destroy the slowpath queue. */
name|bxe_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|gz_dma
argument_list|)
expr_stmt|;
name|sc
operator|->
name|gz
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|strm
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|strm
operator|=
name|NULL
expr_stmt|;
name|bxe_host_structures_free_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator||
name|BXE_VERBOSE_UNLOAD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get DMA memory from the OS.  *  * Validates that the OS has provided DMA buffers in response to a  * bus_dmamap_load call and saves the physical address of those buffers.  * When the callback is used the OS will return 0 for the mapping function  * (bus_dmamap_load) so we use the value of map_arg->maxsegs to pass any  * failures back to the caller.  *  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_dma_map_addr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|bus_addr_t
modifier|*
name|busaddr
decl_stmt|;
name|busaddr
operator|=
name|arg
expr_stmt|;
comment|/* Check for an error and signal the caller that an error occurred. */
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"bxe %s(%d): DMA mapping error (error = %d, nseg = %d)!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|error
argument_list|,
name|nseg
argument_list|)
expr_stmt|;
operator|*
name|busaddr
operator|=
literal|0
expr_stmt|;
return|return;
block|}
operator|*
name|busaddr
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate any non-paged DMA memory needed by the driver.  *  * Returns:  *   0 = Success, !0 = Failure.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_host_structures_alloc
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|bus_addr_t
name|busaddr
decl_stmt|;
name|bus_size_t
name|max_size
decl_stmt|,
name|max_seg_size
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|max_segments
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
name|int
name|max_agg_queues
init|=
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
condition|?
name|ETH_MAX_AGGREGATION_QUEUES_E1H
else|:
name|ETH_MAX_AGGREGATION_QUEUES_E1
decl_stmt|;
comment|/* 	 * Allocate the parent bus DMA tag appropriate for PCI. 	 */
name|rc
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
comment|/* PCI parent tag */
literal|1
argument_list|,
comment|/* alignment for segs */
name|BXE_DMA_BOUNDARY
argument_list|,
comment|/* cannot cross */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* restricted low */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* restricted hi */
name|NULL
argument_list|,
comment|/* filter f() */
name|NULL
argument_list|,
comment|/* filter f() arg */
name|MAXBSIZE
argument_list|,
comment|/* max map for this tag */
name|BUS_SPACE_UNRESTRICTED
argument_list|,
comment|/* # of discontinuities */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* max seg size */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lock f() */
name|NULL
argument_list|,
comment|/* lock f() arg */
operator|&
name|sc
operator|->
name|parent_tag
argument_list|)
expr_stmt|;
comment|/* dma tag */
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Could not allocate parent DMA tag!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bxe_host_structures_alloc_exit
goto|;
block|}
comment|/* Allocate DMA memory for each fastpath structure. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
expr_stmt|;
comment|/* 		 * Allocate status block* 		*/
name|rc
operator|=
name|bxe_dma_malloc
argument_list|(
name|sc
argument_list|,
name|BXE_STATUS_BLK_SZ
argument_list|,
operator|&
name|fp
operator|->
name|sb_dma
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
literal|"fp status block"
argument_list|)
expr_stmt|;
comment|/* ToDo: Only using 32 bytes out of 4KB allocation! */
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|bxe_host_structures_alloc_exit
goto|;
name|fp
operator|->
name|status_block
operator|=
operator|(
expr|struct
name|host_status_block
operator|*
operator|)
name|fp
operator|->
name|sb_dma
operator|.
name|vaddr
expr_stmt|;
comment|/* 		 * Allocate TX chain. 		 */
name|rc
operator|=
name|bxe_dma_malloc
argument_list|(
name|sc
argument_list|,
name|BXE_TX_CHAIN_PAGE_SZ
operator|*
name|NUM_TX_PAGES
argument_list|,
operator|&
name|fp
operator|->
name|tx_dma
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
literal|"tx chain pages"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|bxe_host_structures_alloc_exit
goto|;
name|fp
operator|->
name|tx_chain
operator|=
operator|(
expr|union
name|eth_tx_bd_types
operator|*
operator|)
name|fp
operator|->
name|tx_dma
operator|.
name|vaddr
expr_stmt|;
comment|/* Link the TX chain pages. */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|NUM_TX_PAGES
condition|;
name|j
operator|++
control|)
block|{
name|struct
name|eth_tx_next_bd
modifier|*
name|tx_n_bd
init|=
operator|&
name|fp
operator|->
name|tx_chain
index|[
name|TOTAL_TX_BD_PER_PAGE
operator|*
name|j
operator|-
literal|1
index|]
operator|.
name|next_bd
decl_stmt|;
name|busaddr
operator|=
name|fp
operator|->
name|tx_dma
operator|.
name|paddr
operator|+
name|BCM_PAGE_SIZE
operator|*
operator|(
name|j
operator|%
name|NUM_TX_PAGES
operator|)
expr_stmt|;
name|tx_n_bd
operator|->
name|addr_hi
operator|=
name|htole32
argument_list|(
name|U64_HI
argument_list|(
name|busaddr
argument_list|)
argument_list|)
expr_stmt|;
name|tx_n_bd
operator|->
name|addr_lo
operator|=
name|htole32
argument_list|(
name|U64_LO
argument_list|(
name|busaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Allocate RX chain. 		 */
name|rc
operator|=
name|bxe_dma_malloc
argument_list|(
name|sc
argument_list|,
name|BXE_RX_CHAIN_PAGE_SZ
operator|*
name|NUM_RX_PAGES
argument_list|,
operator|&
name|fp
operator|->
name|rx_dma
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
literal|"rx chain pages"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|bxe_host_structures_alloc_exit
goto|;
name|fp
operator|->
name|rx_chain
operator|=
operator|(
expr|struct
name|eth_rx_bd
operator|*
operator|)
name|fp
operator|->
name|rx_dma
operator|.
name|vaddr
expr_stmt|;
comment|/* Link the RX chain pages. */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|NUM_RX_PAGES
condition|;
name|j
operator|++
control|)
block|{
name|struct
name|eth_rx_bd
modifier|*
name|rx_bd
init|=
operator|&
name|fp
operator|->
name|rx_chain
index|[
name|TOTAL_RX_BD_PER_PAGE
operator|*
name|j
operator|-
literal|2
index|]
decl_stmt|;
name|busaddr
operator|=
name|fp
operator|->
name|rx_dma
operator|.
name|paddr
operator|+
name|BCM_PAGE_SIZE
operator|*
operator|(
name|j
operator|%
name|NUM_RX_PAGES
operator|)
expr_stmt|;
name|rx_bd
operator|->
name|addr_hi
operator|=
name|htole32
argument_list|(
name|U64_HI
argument_list|(
name|busaddr
argument_list|)
argument_list|)
expr_stmt|;
name|rx_bd
operator|->
name|addr_lo
operator|=
name|htole32
argument_list|(
name|U64_LO
argument_list|(
name|busaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Allocate CQ chain. 		 */
name|rc
operator|=
name|bxe_dma_malloc
argument_list|(
name|sc
argument_list|,
name|BXE_RX_CHAIN_PAGE_SZ
operator|*
name|NUM_RCQ_PAGES
argument_list|,
operator|&
name|fp
operator|->
name|rcq_dma
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
literal|"rcq chain pages"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|bxe_host_structures_alloc_exit
goto|;
name|fp
operator|->
name|rcq_chain
operator|=
operator|(
expr|union
name|eth_rx_cqe
operator|*
operator|)
name|fp
operator|->
name|rcq_dma
operator|.
name|vaddr
expr_stmt|;
comment|/* Link the CQ chain pages. */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|NUM_RCQ_PAGES
condition|;
name|j
operator|++
control|)
block|{
name|struct
name|eth_rx_cqe_next_page
modifier|*
name|nextpg
init|=
operator|(
expr|struct
name|eth_rx_cqe_next_page
operator|*
operator|)
operator|&
name|fp
operator|->
name|rcq_chain
index|[
name|TOTAL_RCQ_ENTRIES_PER_PAGE
operator|*
name|j
operator|-
literal|1
index|]
decl_stmt|;
name|busaddr
operator|=
name|fp
operator|->
name|rcq_dma
operator|.
name|paddr
operator|+
name|BCM_PAGE_SIZE
operator|*
operator|(
name|j
operator|%
name|NUM_RCQ_PAGES
operator|)
expr_stmt|;
name|nextpg
operator|->
name|addr_hi
operator|=
name|htole32
argument_list|(
name|U64_HI
argument_list|(
name|busaddr
argument_list|)
argument_list|)
expr_stmt|;
name|nextpg
operator|->
name|addr_lo
operator|=
name|htole32
argument_list|(
name|U64_LO
argument_list|(
name|busaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Allocate SG chain. 		 */
name|rc
operator|=
name|bxe_dma_malloc
argument_list|(
name|sc
argument_list|,
name|BXE_RX_CHAIN_PAGE_SZ
operator|*
name|NUM_RX_SGE_PAGES
argument_list|,
operator|&
name|fp
operator|->
name|sg_dma
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
literal|"sg chain pages"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|bxe_host_structures_alloc_exit
goto|;
name|fp
operator|->
name|sg_chain
operator|=
operator|(
expr|struct
name|eth_rx_sge
operator|*
operator|)
name|fp
operator|->
name|sg_dma
operator|.
name|vaddr
expr_stmt|;
comment|/* Link the SG chain pages. */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|NUM_RX_SGE_PAGES
condition|;
name|j
operator|++
control|)
block|{
name|struct
name|eth_rx_sge
modifier|*
name|nextpg
init|=
operator|&
name|fp
operator|->
name|sg_chain
index|[
name|TOTAL_RX_SGE_PER_PAGE
operator|*
name|j
operator|-
literal|2
index|]
decl_stmt|;
name|busaddr
operator|=
name|fp
operator|->
name|sg_dma
operator|.
name|paddr
operator|+
name|BCM_PAGE_SIZE
operator|*
operator|(
name|j
operator|%
name|NUM_RX_SGE_PAGES
operator|)
expr_stmt|;
name|nextpg
operator|->
name|addr_hi
operator|=
name|htole32
argument_list|(
name|U64_HI
argument_list|(
name|busaddr
argument_list|)
argument_list|)
expr_stmt|;
name|nextpg
operator|->
name|addr_lo
operator|=
name|htole32
argument_list|(
name|U64_LO
argument_list|(
name|busaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Check required size before mapping to conserve resources. 		 */
if|if
condition|(
name|sc
operator|->
name|tso_enable
operator|==
name|TRUE
condition|)
block|{
name|max_size
operator|=
name|BXE_TSO_MAX_SIZE
expr_stmt|;
name|max_segments
operator|=
name|BXE_TSO_MAX_SEGMENTS
expr_stmt|;
name|max_seg_size
operator|=
name|BXE_TSO_MAX_SEG_SIZE
expr_stmt|;
block|}
else|else
block|{
name|max_size
operator|=
name|MCLBYTES
operator|*
name|BXE_MAX_SEGMENTS
expr_stmt|;
name|max_segments
operator|=
name|BXE_MAX_SEGMENTS
expr_stmt|;
name|max_seg_size
operator|=
name|MCLBYTES
expr_stmt|;
block|}
comment|/* Create a DMA tag for TX mbufs. */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_tag
argument_list|,
literal|1
argument_list|,
comment|/* alignment for segs */
name|BXE_DMA_BOUNDARY
argument_list|,
comment|/* cannot cross */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* restricted low */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* restricted hi */
name|NULL
argument_list|,
comment|/* filter f() */
name|NULL
argument_list|,
comment|/* filter f() arg */
name|max_size
argument_list|,
comment|/* max map for this tag */
name|max_segments
argument_list|,
comment|/* # of discontinuities */
name|max_seg_size
argument_list|,
comment|/* max seg size */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lock f() */
name|NULL
argument_list|,
comment|/* lock f() arg */
operator|&
name|fp
operator|->
name|tx_mbuf_tag
argument_list|)
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Could not allocate fp[%d] "
literal|"TX mbuf DMA tag!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bxe_host_structures_alloc_exit
goto|;
block|}
comment|/* Create DMA maps for each the TX mbuf cluster(ext buf). */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|TOTAL_TX_BD
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|fp
operator|->
name|tx_mbuf_tag
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|fp
operator|->
name|tx_mbuf_map
index|[
name|j
index|]
argument_list|)
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Unable to create fp[%02d]."
literal|"tx_mbuf_map[%d] DMA map!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bxe_host_structures_alloc_exit
goto|;
block|}
block|}
comment|/* 		 * Create a DMA tag for RX mbufs. 		 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_tag
argument_list|,
literal|1
argument_list|,
comment|/* alignment for segs */
name|BXE_DMA_BOUNDARY
argument_list|,
comment|/* cannot cross */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* restricted low */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* restricted hi */
name|NULL
argument_list|,
comment|/* filter f() */
name|NULL
argument_list|,
comment|/* filter f() arg */
name|MJUM9BYTES
argument_list|,
comment|/* max map for this tag */
literal|1
argument_list|,
comment|/* # of discontinuities */
name|MJUM9BYTES
argument_list|,
comment|/* max seg size */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lock f() */
name|NULL
argument_list|,
comment|/* lock f() arg */
operator|&
name|fp
operator|->
name|rx_mbuf_tag
argument_list|)
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Could not allocate fp[%02d] "
literal|"RX mbuf DMA tag!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bxe_host_structures_alloc_exit
goto|;
block|}
comment|/* Create DMA maps for the RX mbuf clusters. */
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|fp
operator|->
name|rx_mbuf_spare_map
argument_list|)
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Unable to create fp[%02d]."
literal|"rx_mbuf_spare_map DMA map!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bxe_host_structures_alloc_exit
goto|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|TOTAL_RX_BD
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|fp
operator|->
name|rx_mbuf_map
index|[
name|j
index|]
argument_list|)
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Unable to create fp[%02d]."
literal|"rx_mbuf_map[%d] DMA map!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bxe_host_structures_alloc_exit
goto|;
block|}
block|}
comment|/* 		 * Create a DMA tag for RX SGE bufs. 		 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_tag
argument_list|,
literal|1
argument_list|,
name|BXE_DMA_BOUNDARY
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|1
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|fp
operator|->
name|rx_sge_buf_tag
argument_list|)
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Could not allocate fp[%02d] "
literal|"RX SGE mbuf DMA tag!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bxe_host_structures_alloc_exit
goto|;
block|}
comment|/* Create DMA maps for the SGE mbuf clusters. */
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|fp
operator|->
name|rx_sge_buf_tag
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|fp
operator|->
name|rx_sge_spare_map
argument_list|)
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Unable to create fp[%02d]."
literal|"rx_sge_spare_map DMA map!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bxe_host_structures_alloc_exit
goto|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|TOTAL_RX_SGE
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|fp
operator|->
name|rx_sge_buf_tag
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|fp
operator|->
name|rx_sge_buf_map
index|[
name|j
index|]
argument_list|)
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Unable to create fp[%02d]."
literal|"rx_sge_buf_map[%d] DMA map!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bxe_host_structures_alloc_exit
goto|;
block|}
block|}
comment|/* Create DMA maps for the TPA pool mbufs. */
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|fp
operator|->
name|tpa_mbuf_spare_map
argument_list|)
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Unable to create fp[%02d]."
literal|"tpa_mbuf_spare_map DMA map!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bxe_host_structures_alloc_exit
goto|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|max_agg_queues
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|fp
operator|->
name|tpa_mbuf_map
index|[
name|j
index|]
argument_list|)
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Unable to create fp[%02d]."
literal|"tpa_mbuf_map[%d] DMA map!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bxe_host_structures_alloc_exit
goto|;
block|}
block|}
name|bxe_init_sge_ring_bit_mask
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Allocate default status block. 	 */
name|rc
operator|=
name|bxe_dma_malloc
argument_list|(
name|sc
argument_list|,
name|BXE_DEF_STATUS_BLK_SZ
argument_list|,
operator|&
name|sc
operator|->
name|def_sb_dma
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
literal|"default status block"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|bxe_host_structures_alloc_exit
goto|;
name|sc
operator|->
name|def_sb
operator|=
operator|(
expr|struct
name|host_def_status_block
operator|*
operator|)
name|sc
operator|->
name|def_sb_dma
operator|.
name|vaddr
expr_stmt|;
comment|/* 	 * Allocate statistics block. 	 */
name|rc
operator|=
name|bxe_dma_malloc
argument_list|(
name|sc
argument_list|,
name|BXE_STATS_BLK_SZ
argument_list|,
operator|&
name|sc
operator|->
name|stats_dma
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
literal|"statistics block"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|bxe_host_structures_alloc_exit
goto|;
name|sc
operator|->
name|stats
operator|=
operator|(
expr|struct
name|statistics_block
operator|*
operator|)
name|sc
operator|->
name|stats_dma
operator|.
name|vaddr
expr_stmt|;
comment|/* 	 * Allocate slowpath block. 	 */
name|rc
operator|=
name|bxe_dma_malloc
argument_list|(
name|sc
argument_list|,
name|BXE_SLOWPATH_SZ
argument_list|,
operator|&
name|sc
operator|->
name|slowpath_dma
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
literal|"slowpath block"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|bxe_host_structures_alloc_exit
goto|;
name|sc
operator|->
name|slowpath
operator|=
operator|(
expr|struct
name|bxe_slowpath
operator|*
operator|)
name|sc
operator|->
name|slowpath_dma
operator|.
name|vaddr
expr_stmt|;
comment|/* 	 * Allocate slowpath queue. 	 */
name|rc
operator|=
name|bxe_dma_malloc
argument_list|(
name|sc
argument_list|,
name|BXE_SPQ_SZ
argument_list|,
operator|&
name|sc
operator|->
name|spq_dma
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
literal|"slowpath queue"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|bxe_host_structures_alloc_exit
goto|;
name|sc
operator|->
name|spq
operator|=
operator|(
expr|struct
name|eth_spe
operator|*
operator|)
name|sc
operator|->
name|spq_dma
operator|.
name|vaddr
expr_stmt|;
comment|/* 	 * Allocate firmware decompression buffer. 	 */
name|rc
operator|=
name|bxe_dma_malloc
argument_list|(
name|sc
argument_list|,
name|BXE_FW_BUF_SIZE
argument_list|,
operator|&
name|sc
operator|->
name|gz_dma
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
literal|"gunzip buffer"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|bxe_host_structures_alloc_exit
goto|;
name|sc
operator|->
name|gz
operator|=
name|sc
operator|->
name|gz_dma
operator|.
name|vaddr
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|strm
operator|==
name|NULL
condition|)
block|{
goto|goto
name|bxe_host_structures_alloc_exit
goto|;
block|}
name|sc
operator|->
name|strm
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|strm
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|bxe_host_structures_alloc_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Program the MAC address for 57710 controllers.  *  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_set_mac_addr_e1
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|set
parameter_list|)
block|{
name|struct
name|mac_configuration_cmd
modifier|*
name|config
decl_stmt|;
name|struct
name|mac_configuration_entry
modifier|*
name|config_table
decl_stmt|;
name|uint8_t
modifier|*
name|eaddr
decl_stmt|;
name|int
name|port
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator||
name|BXE_VERBOSE_UNLOAD
argument_list|)
expr_stmt|;
name|config
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|mac_config
argument_list|)
expr_stmt|;
name|port
operator|=
name|BP_PORT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * CAM allocation: 	 * Port 0 Unicast Addresses: 32 Perfect Match Filters (31-0) 	 * Port 1 Unicast Addresses: 32 Perfect Match Filters (63-32) 	 * Port 0 Multicast Addresses: 128 Hashes (127-64) 	 * Port 1 Multicast Addresses: 128 Hashes (191-128) 	 */
name|config
operator|->
name|hdr
operator|.
name|length
operator|=
literal|2
expr_stmt|;
name|config
operator|->
name|hdr
operator|.
name|offset
operator|=
name|port
condition|?
literal|32
else|:
literal|0
expr_stmt|;
name|config
operator|->
name|hdr
operator|.
name|client_id
operator|=
name|BP_CL_ID
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|config
operator|->
name|hdr
operator|.
name|reserved1
operator|=
literal|0
expr_stmt|;
comment|/* Program the primary MAC address. */
name|config_table
operator|=
operator|&
name|config
operator|->
name|config_table
index|[
literal|0
index|]
expr_stmt|;
name|eaddr
operator|=
name|sc
operator|->
name|link_params
operator|.
name|mac_addr
expr_stmt|;
name|config_table
operator|->
name|cam_entry
operator|.
name|msb_mac_addr
operator|=
name|eaddr
index|[
literal|0
index|]
operator|<<
literal|8
operator||
name|eaddr
index|[
literal|1
index|]
expr_stmt|;
name|config_table
operator|->
name|cam_entry
operator|.
name|middle_mac_addr
operator|=
name|eaddr
index|[
literal|2
index|]
operator|<<
literal|8
operator||
name|eaddr
index|[
literal|3
index|]
expr_stmt|;
name|config_table
operator|->
name|cam_entry
operator|.
name|lsb_mac_addr
operator|=
name|eaddr
index|[
literal|4
index|]
operator|<<
literal|8
operator||
name|eaddr
index|[
literal|5
index|]
expr_stmt|;
name|config_table
operator|->
name|cam_entry
operator|.
name|flags
operator|=
name|htole16
argument_list|(
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
condition|)
name|config_table
operator|->
name|target_table_entry
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
else|else
name|CAM_INVALIDATE
argument_list|(
name|config_table
argument_list|)
expr_stmt|;
name|config_table
operator|->
name|target_table_entry
operator|.
name|vlan_id
operator|=
literal|0
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE
argument_list|,
literal|"%s(): %s MAC (%04x:%04x:%04x)\n"
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|set
condition|?
literal|"Setting"
else|:
literal|"Clearing"
operator|)
argument_list|,
name|config_table
operator|->
name|cam_entry
operator|.
name|msb_mac_addr
argument_list|,
name|config_table
operator|->
name|cam_entry
operator|.
name|middle_mac_addr
argument_list|,
name|config_table
operator|->
name|cam_entry
operator|.
name|lsb_mac_addr
argument_list|)
expr_stmt|;
comment|/* Program the broadcast MAC address. */
name|config_table
operator|=
operator|&
name|config
operator|->
name|config_table
index|[
literal|1
index|]
expr_stmt|;
name|config_table
operator|->
name|cam_entry
operator|.
name|msb_mac_addr
operator|=
literal|0xffff
expr_stmt|;
name|config_table
operator|->
name|cam_entry
operator|.
name|middle_mac_addr
operator|=
literal|0xffff
expr_stmt|;
name|config_table
operator|->
name|cam_entry
operator|.
name|lsb_mac_addr
operator|=
literal|0xffff
expr_stmt|;
name|config_table
operator|->
name|cam_entry
operator|.
name|flags
operator|=
name|htole16
argument_list|(
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
condition|)
name|config_table
operator|->
name|target_table_entry
operator|.
name|flags
operator|=
name|TSTORM_CAM_TARGET_TABLE_ENTRY_BROADCAST
expr_stmt|;
else|else
name|CAM_INVALIDATE
argument_list|(
name|config_table
argument_list|)
expr_stmt|;
name|config_table
operator|->
name|target_table_entry
operator|.
name|vlan_id
operator|=
literal|0
expr_stmt|;
comment|/* Post the command to slow path queue. */
name|bxe_sp_post
argument_list|(
name|sc
argument_list|,
name|RAMROD_CMD_ID_ETH_SET_MAC
argument_list|,
literal|0
argument_list|,
name|U64_HI
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|mac_config
argument_list|)
argument_list|)
argument_list|,
name|U64_LO
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|mac_config
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator||
name|BXE_VERBOSE_UNLOAD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Program the MAC address for 57711/57711E controllers.  *  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_set_mac_addr_e1h
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|set
parameter_list|)
block|{
name|struct
name|mac_configuration_cmd_e1h
modifier|*
name|config
decl_stmt|;
name|struct
name|mac_configuration_entry_e1h
modifier|*
name|config_table
decl_stmt|;
name|uint8_t
modifier|*
name|eaddr
decl_stmt|;
name|int
name|func
decl_stmt|,
name|port
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator||
name|BXE_VERBOSE_UNLOAD
argument_list|)
expr_stmt|;
name|config
operator|=
operator|(
expr|struct
name|mac_configuration_cmd_e1h
operator|*
operator|)
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|mac_config
argument_list|)
expr_stmt|;
name|port
operator|=
name|BP_PORT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|func
operator|=
name|BP_FUNC
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|&&
operator|(
name|sc
operator|->
name|state
operator|!=
name|BXE_STATE_OPEN
operator|)
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE
argument_list|,
literal|"%s(): Can't set E1H MAC in state 0x%08X!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|state
argument_list|)
expr_stmt|;
goto|goto
name|bxe_set_mac_addr_e1h_exit
goto|;
block|}
comment|/* 	 * CAM allocation: 	 * Function 0-7 Unicast Addresses: 8 Perfect Match Filters 	 * Multicast Addresses: 20 + FUNC * 20, 20 each (???) 	 */
name|config
operator|->
name|hdr
operator|.
name|length
operator|=
literal|1
expr_stmt|;
name|config
operator|->
name|hdr
operator|.
name|offset
operator|=
name|func
expr_stmt|;
name|config
operator|->
name|hdr
operator|.
name|client_id
operator|=
literal|0xff
expr_stmt|;
name|config
operator|->
name|hdr
operator|.
name|reserved1
operator|=
literal|0
expr_stmt|;
comment|/* Program the primary MAC address. */
name|config_table
operator|=
operator|&
name|config
operator|->
name|config_table
index|[
literal|0
index|]
expr_stmt|;
name|eaddr
operator|=
name|sc
operator|->
name|link_params
operator|.
name|mac_addr
expr_stmt|;
name|config_table
operator|->
name|msb_mac_addr
operator|=
name|eaddr
index|[
literal|0
index|]
operator|<<
literal|8
operator||
name|eaddr
index|[
literal|1
index|]
expr_stmt|;
name|config_table
operator|->
name|middle_mac_addr
operator|=
name|eaddr
index|[
literal|2
index|]
operator|<<
literal|8
operator||
name|eaddr
index|[
literal|3
index|]
expr_stmt|;
name|config_table
operator|->
name|lsb_mac_addr
operator|=
name|eaddr
index|[
literal|4
index|]
operator|<<
literal|8
operator||
name|eaddr
index|[
literal|5
index|]
expr_stmt|;
name|config_table
operator|->
name|clients_bit_vector
operator|=
name|htole32
argument_list|(
literal|1
operator|<<
name|sc
operator|->
name|fp
operator|->
name|cl_id
argument_list|)
expr_stmt|;
name|config_table
operator|->
name|vlan_id
operator|=
literal|0
expr_stmt|;
name|config_table
operator|->
name|e1hov_id
operator|=
name|htole16
argument_list|(
name|sc
operator|->
name|e1hov
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
condition|)
name|config_table
operator|->
name|flags
operator|=
name|port
expr_stmt|;
else|else
name|config_table
operator|->
name|flags
operator|=
name|MAC_CONFIGURATION_ENTRY_E1H_ACTION_TYPE
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE
argument_list|,
literal|"%s(): %s MAC (%04x:%04x:%04x), E1HOV = %d, CLID = %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
operator|(
name|set
condition|?
literal|"Setting"
else|:
literal|"Clearing"
operator|)
argument_list|,
name|config_table
operator|->
name|msb_mac_addr
argument_list|,
name|config_table
operator|->
name|middle_mac_addr
argument_list|,
name|config_table
operator|->
name|lsb_mac_addr
argument_list|,
name|sc
operator|->
name|e1hov
argument_list|,
name|BP_L_ID
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|bxe_sp_post
argument_list|(
name|sc
argument_list|,
name|RAMROD_CMD_ID_ETH_SET_MAC
argument_list|,
literal|0
argument_list|,
name|U64_HI
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|mac_config
argument_list|)
argument_list|)
argument_list|,
name|U64_LO
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|mac_config
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bxe_set_mac_addr_e1h_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator||
name|BXE_VERBOSE_UNLOAD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Programs the various packet receive modes (broadcast and multicast).  *  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_set_rx_mode
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|struct
name|mac_configuration_cmd
modifier|*
name|config
decl_stmt|;
name|struct
name|mac_configuration_entry
modifier|*
name|config_table
decl_stmt|;
name|uint32_t
name|mc_filter
index|[
name|MC_HASH_SIZE
index|]
decl_stmt|;
name|uint8_t
modifier|*
name|maddr
decl_stmt|;
name|uint32_t
name|crc
decl_stmt|,
name|bit
decl_stmt|,
name|regidx
decl_stmt|,
name|rx_mode
decl_stmt|;
name|int
name|i
decl_stmt|,
name|old
decl_stmt|,
name|offset
decl_stmt|,
name|port
decl_stmt|;
name|BXE_CORE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rx_mode
operator|=
name|BXE_RX_MODE_NORMAL
expr_stmt|;
name|port
operator|=
name|BP_PORT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|state
operator|!=
name|BXE_STATE_OPEN
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): State (0x%08X) is not open!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|sc
operator|->
name|state
argument_list|)
expr_stmt|;
goto|goto
name|bxe_set_rx_mode_exit
goto|;
block|}
name|ifp
operator|=
name|sc
operator|->
name|bxe_ifp
expr_stmt|;
comment|/* 	 * Check for promiscuous, all multicast, or selected 	 * multicast address filtering. 	 */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
comment|/* Enable promiscuous mode. */
name|rx_mode
operator|=
name|BXE_RX_MODE_PROMISC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
operator|||
name|ifp
operator|->
name|if_amcount
operator|>
name|BXE_MAX_MULTICAST
condition|)
block|{
comment|/* Enable all multicast addresses. */
name|rx_mode
operator|=
name|BXE_RX_MODE_ALLMULTI
expr_stmt|;
block|}
else|else
block|{
comment|/* Enable selective multicast mode. */
if|if
condition|(
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|config
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|mcast_config
argument_list|)
expr_stmt|;
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|maddr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
expr_stmt|;
name|config_table
operator|=
operator|&
name|config
operator|->
name|config_table
index|[
name|i
index|]
expr_stmt|;
name|config_table
operator|->
name|cam_entry
operator|.
name|msb_mac_addr
operator|=
name|maddr
index|[
literal|0
index|]
operator|<<
literal|8
operator||
name|maddr
index|[
literal|1
index|]
expr_stmt|;
name|config_table
operator|->
name|cam_entry
operator|.
name|middle_mac_addr
operator|=
name|maddr
index|[
literal|2
index|]
operator|<<
literal|8
operator||
name|maddr
index|[
literal|3
index|]
expr_stmt|;
name|config_table
operator|->
name|cam_entry
operator|.
name|lsb_mac_addr
operator|=
name|maddr
index|[
literal|4
index|]
operator|<<
literal|8
operator||
name|maddr
index|[
literal|5
index|]
expr_stmt|;
name|config_table
operator|->
name|cam_entry
operator|.
name|flags
operator|=
name|htole16
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|config_table
operator|->
name|target_table_entry
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|config_table
operator|->
name|target_table_entry
operator|.
name|clients_bit_vector
operator|=
name|htole32
argument_list|(
literal|1
operator|<<
name|BP_L_ID
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|config_table
operator|->
name|target_table_entry
operator|.
name|vlan_id
operator|=
literal|0
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_INFO
argument_list|,
literal|"%s(): Setting MCAST[%d] (%04X:%04X:%04X)\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|i
argument_list|,
name|config_table
operator|->
name|cam_entry
operator|.
name|msb_mac_addr
argument_list|,
name|config_table
operator|->
name|cam_entry
operator|.
name|middle_mac_addr
argument_list|,
name|config_table
operator|->
name|cam_entry
operator|.
name|lsb_mac_addr
argument_list|)
expr_stmt|;
block|}
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|old
operator|=
name|config
operator|->
name|hdr
operator|.
name|length
expr_stmt|;
comment|/* Invalidate any extra MC entries in the CAM. */
if|if
condition|(
name|old
operator|>
name|i
condition|)
block|{
for|for
control|(
init|;
name|i
operator|<
name|old
condition|;
name|i
operator|++
control|)
block|{
name|config_table
operator|=
operator|&
name|config
operator|->
name|config_table
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|CAM_IS_INVALID
argument_list|(
name|config_table
argument_list|)
condition|)
break|break;
comment|/* Invalidate */
name|CAM_INVALIDATE
argument_list|(
name|config_table
argument_list|)
expr_stmt|;
block|}
block|}
name|offset
operator|=
name|BXE_MAX_MULTICAST
operator|*
operator|(
literal|1
operator|+
name|port
operator|)
expr_stmt|;
name|config
operator|->
name|hdr
operator|.
name|length
operator|=
name|i
expr_stmt|;
name|config
operator|->
name|hdr
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|config
operator|->
name|hdr
operator|.
name|client_id
operator|=
name|sc
operator|->
name|fp
operator|->
name|cl_id
expr_stmt|;
name|config
operator|->
name|hdr
operator|.
name|reserved1
operator|=
literal|0
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
name|bxe_sp_post
argument_list|(
name|sc
argument_list|,
name|RAMROD_CMD_ID_ETH_SET_MAC
argument_list|,
literal|0
argument_list|,
name|U64_HI
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|mcast_config
argument_list|)
argument_list|)
argument_list|,
name|U64_LO
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|mcast_config
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* E1H */
comment|/* Accept one or more multicasts */
name|memset
argument_list|(
name|mc_filter
argument_list|,
literal|0
argument_list|,
literal|4
operator|*
name|MC_HASH_SIZE
argument_list|)
expr_stmt|;
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|crc
operator|=
name|ether_crc32_le
argument_list|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_data
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bit
operator|=
operator|(
name|crc
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|regidx
operator|=
name|bit
operator|>>
literal|5
expr_stmt|;
name|bit
operator|&=
literal|0x1f
expr_stmt|;
name|mc_filter
index|[
name|regidx
index|]
operator||=
operator|(
literal|1
operator|<<
name|bit
operator|)
expr_stmt|;
block|}
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MC_HASH_SIZE
condition|;
name|i
operator|++
control|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MC_HASH_OFFSET
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
argument_list|,
name|mc_filter
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE
argument_list|,
literal|"%s(): Enabling new receive mode: 0x%08X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|rx_mode
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx_mode
operator|=
name|rx_mode
expr_stmt|;
name|bxe_set_storm_rx_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_set_rx_mode_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function specific controller reset.  *  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_reset_func
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|base
decl_stmt|,
name|func
decl_stmt|,
name|i
decl_stmt|,
name|port
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator||
name|BXE_VERBOSE_UNLOAD
argument_list|)
expr_stmt|;
name|port
operator|=
name|BP_PORT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|func
operator|=
name|BP_FUNC
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Configure IGU. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|HC_REG_LEADING_EDGE_0
operator|+
name|port
operator|*
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|HC_REG_TRAILING_EDGE_0
operator|+
name|port
operator|*
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|HC_REG_CONFIG_0
operator|+
operator|(
name|port
operator|*
literal|4
operator|)
argument_list|,
literal|0x1000
argument_list|)
expr_stmt|;
comment|/* Clear ILT. */
name|base
operator|=
name|FUNC_ILT_BASE
argument_list|(
name|func
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|base
init|;
name|i
operator|<
name|base
operator|+
name|ILT_PER_FUNC
condition|;
name|i
operator|++
control|)
name|bxe_ilt_wr
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator||
name|BXE_VERBOSE_UNLOAD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Port specific controller reset.  *  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_reset_port
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|int
name|port
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator||
name|BXE_VERBOSE_UNLOAD
argument_list|)
expr_stmt|;
name|port
operator|=
name|BP_PORT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_MASK_INTERRUPT_PORT0
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Do not receive packets to BRB. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LLH0_BRB1_DRV_MASK
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* Do not direct receive packets that are not for MCP to the BRB. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|port
condition|?
name|NIG_REG_LLH1_BRB1_NOT_MCP
else|:
name|NIG_REG_LLH0_BRB1_NOT_MCP
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* Configure AEU. */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_MASK_ATTN_FUNC_0
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
comment|/* Check for BRB port occupancy. */
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BRB1_REG_PORT_NUM_OCC_BLOCKS_0
operator|+
name|port
operator|*
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE
argument_list|,
literal|"%s(): BRB1 is not empty (%d blocks are occupied)!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator||
name|BXE_VERBOSE_UNLOAD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Common controller reset.  *  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_reset_common
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator||
name|BXE_VERBOSE_UNLOAD
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_1_CLEAR
argument_list|,
literal|0xd3ffff7f
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_2_CLEAR
argument_list|,
literal|0x1403
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator||
name|BXE_VERBOSE_UNLOAD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset the controller.  *  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_reset_chip
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|reset_code
parameter_list|)
block|{
name|DBENTER
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator||
name|BXE_VERBOSE_UNLOAD
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|reset_code
condition|)
block|{
case|case
name|FW_MSG_CODE_DRV_UNLOAD_COMMON
case|:
name|bxe_reset_port
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_reset_func
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_reset_common
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_MSG_CODE_DRV_UNLOAD_PORT
case|:
name|bxe_reset_port
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_reset_func
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_MSG_CODE_DRV_UNLOAD_FUNCTION
case|:
name|bxe_reset_func
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): Unknown reset code (0x%08X) from MCP!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|reset_code
argument_list|)
expr_stmt|;
break|break;
block|}
name|DBEXIT
argument_list|(
name|BXE_VERBOSE_LOAD
operator||
name|BXE_VERBOSE_RESET
operator||
name|BXE_VERBOSE_UNLOAD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called by the OS to set media options (link, speed, etc.)  * when the user specifies "ifconfig bxe media XXX" or  * "ifconfig bxe mediaopt XXX".  *  * Returns:  *   0 = Success, !0 = Failure  */
end_comment

begin_function
specifier|static
name|int
name|bxe_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifmedia
modifier|*
name|ifm
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_VERBOSE_PHY
argument_list|)
expr_stmt|;
name|ifm
operator|=
operator|&
name|sc
operator|->
name|bxe_ifmedia
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
comment|/* We only support Ethernet media type. */
if|if
condition|(
name|IFM_TYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
operator|!=
name|IFM_ETHER
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bxe_ifmedia_upd_exit
goto|;
block|}
switch|switch
condition|(
name|IFM_SUBTYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
condition|)
block|{
case|case
name|IFM_AUTO
case|:
comment|/* ToDo: What to do here? */
comment|/* Doing nothing translates to success here. */
break|break;
case|case
name|IFM_10G_CX4
case|:
comment|/* Fall-through */
case|case
name|IFM_10G_SR
case|:
comment|/* Fall-through */
case|case
name|IFM_10G_T
case|:
comment|/* Fall-through */
case|case
name|IFM_10G_TWINAX
case|:
comment|/* Fall-through */
default|default:
comment|/* We don't support channging the media type. */
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): Invalid media type!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EINVAL
expr_stmt|;
block|}
name|bxe_ifmedia_upd_exit
label|:
name|DBENTER
argument_list|(
name|BXE_VERBOSE_PHY
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called by the OS to report current media status  * (link, speed, etc.).  *  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_ifmedia_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_EXTREME_LOAD
operator||
name|BXE_EXTREME_RESET
argument_list|)
expr_stmt|;
comment|/* Report link down if the driver isn't running. */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_NONE
expr_stmt|;
goto|goto
name|bxe_ifmedia_status_exit
goto|;
block|}
comment|/* Setup the default interface info. */
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|link_vars
operator|.
name|link_up
condition|)
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
else|else
block|{
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_NONE
expr_stmt|;
goto|goto
name|bxe_ifmedia_status_exit
goto|;
block|}
name|ifmr
operator|->
name|ifm_active
operator||=
name|sc
operator|->
name|media
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|link_vars
operator|.
name|duplex
operator|==
name|MEDIUM_FULL_DUPLEX
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_FDX
expr_stmt|;
else|else
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_HDX
expr_stmt|;
name|bxe_ifmedia_status_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_EXTREME_LOAD
operator||
name|BXE_EXTREME_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update last maximum scatter gather entry.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|bxe_update_last_max_sge
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|uint16_t
name|index
parameter_list|)
block|{
name|uint16_t
name|last_max
decl_stmt|;
name|last_max
operator|=
name|fp
operator|->
name|last_max_sge
expr_stmt|;
if|if
condition|(
name|SUB_S16
argument_list|(
name|index
argument_list|,
name|last_max
argument_list|)
operator|>
literal|0
condition|)
name|fp
operator|->
name|last_max_sge
operator|=
name|index
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Clear scatter gather mask next elements.  *  * Returns:  *   None  */
end_comment

begin_function
specifier|static
name|void
name|bxe_clear_sge_mask_next_elems
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|index
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_RX_SGE_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|index
operator|=
name|i
operator|*
name|TOTAL_RX_SGE_PER_PAGE
operator|+
name|USABLE_RX_SGE_PER_PAGE
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
block|{
name|SGE_MASK_CLEAR_BIT
argument_list|(
name|fp
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|index
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Update SGE producer.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_update_sge_prod
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|struct
name|eth_fast_path_rx_cqe
modifier|*
name|fp_cqe
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|uint16_t
name|delta
decl_stmt|,
name|first_elem
decl_stmt|,
name|last_max
decl_stmt|,
name|last_elem
decl_stmt|,
name|sge_len
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|fp
operator|->
name|sc
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_EXTREME_RECV
argument_list|)
expr_stmt|;
name|delta
operator|=
literal|0
expr_stmt|;
name|sge_len
operator|=
name|SGE_PAGE_ALIGN
argument_list|(
name|le16toh
argument_list|(
name|fp_cqe
operator|->
name|pkt_len
argument_list|)
operator|-
name|le16toh
argument_list|(
name|fp_cqe
operator|->
name|len_on_bd
argument_list|)
argument_list|)
operator|>>
name|SGE_PAGE_SHIFT
expr_stmt|;
if|if
condition|(
operator|!
name|sge_len
condition|)
goto|goto
name|bxe_update_sge_prod_exit
goto|;
comment|/* First mark all used pages. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sge_len
condition|;
name|i
operator|++
control|)
name|SGE_MASK_CLEAR_BIT
argument_list|(
name|fp
argument_list|,
name|RX_SGE
argument_list|(
name|le16toh
argument_list|(
name|fp_cqe
operator|->
name|sgl
index|[
name|i
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Assume that the last SGE index is the biggest. */
name|bxe_update_last_max_sge
argument_list|(
name|fp
argument_list|,
name|le16toh
argument_list|(
name|fp_cqe
operator|->
name|sgl
index|[
name|sge_len
operator|-
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|last_max
operator|=
name|RX_SGE
argument_list|(
name|fp
operator|->
name|last_max_sge
argument_list|)
expr_stmt|;
name|last_elem
operator|=
name|last_max
operator|>>
name|RX_SGE_MASK_ELEM_SHIFT
expr_stmt|;
name|first_elem
operator|=
name|RX_SGE
argument_list|(
name|fp
operator|->
name|rx_sge_prod
argument_list|)
operator|>>
name|RX_SGE_MASK_ELEM_SHIFT
expr_stmt|;
comment|/* If ring is not full. */
if|if
condition|(
name|last_elem
operator|+
literal|1
operator|!=
name|first_elem
condition|)
name|last_elem
operator|++
expr_stmt|;
comment|/* Now update the producer index. */
for|for
control|(
name|i
operator|=
name|first_elem
init|;
name|i
operator|!=
name|last_elem
condition|;
name|i
operator|=
name|NEXT_SGE_MASK_ELEM
argument_list|(
name|i
argument_list|)
control|)
block|{
if|if
condition|(
name|fp
operator|->
name|rx_sge_mask
index|[
name|i
index|]
condition|)
break|break;
name|fp
operator|->
name|rx_sge_mask
index|[
name|i
index|]
operator|=
name|RX_SGE_MASK_ELEM_ONE_MASK
expr_stmt|;
name|delta
operator|+=
name|RX_SGE_MASK_ELEM_SZ
expr_stmt|;
block|}
if|if
condition|(
name|delta
operator|>
literal|0
condition|)
block|{
name|fp
operator|->
name|rx_sge_prod
operator|+=
name|delta
expr_stmt|;
comment|/* clear page-end entries */
name|bxe_clear_sge_mask_next_elems
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|bxe_update_sge_prod_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_EXTREME_RECV
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize scatter gather ring bitmask.  *  * Each entry in the SGE is associated with an aggregation in process.  * Since there is no guarantee that all Ethernet frames associated with  * a partciular TCP flow will arrive at the adapter and be placed into  * the SGE chain contiguously, we maintain a bitmask for each SGE element  * that identifies which aggregation an Ethernet frame belongs to.  *  * Returns:  *   None  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|bxe_init_sge_ring_bit_mask
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|)
block|{
comment|/* Set the mask to all 1s, it's faster to compare to 0 than to 0xf. */
name|memset
argument_list|(
name|fp
operator|->
name|rx_sge_mask
argument_list|,
literal|0xff
argument_list|,
operator|(
name|TOTAL_RX_SGE
operator|>>
name|RX_SGE_MASK_ELEM_SHIFT
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * The SGE chain is formatted just like the RX chain. 	 * The last two elements are reserved as a "next page pointer" 	 * to the next page of SGE elements.  Clear the last two 	 * elements in each SGE chain page since they will never be 	 * used to track an aggregation. 	 */
name|bxe_clear_sge_mask_next_elems
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The current mbuf is part of an aggregation.  Swap the mbuf into the TPA  * aggregation queue, swap an empty mbuf back onto the receive chain, and  * mark the current aggregation queue as in-progress.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_tpa_start
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|uint16_t
name|queue
parameter_list|,
name|uint16_t
name|cons
parameter_list|,
name|uint16_t
name|prod
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_temp
decl_stmt|;
name|struct
name|eth_rx_bd
modifier|*
name|rx_bd
decl_stmt|;
name|bus_dmamap_t
name|map_temp
decl_stmt|;
name|int
name|max_agg_queues
decl_stmt|;
name|sc
operator|=
name|fp
operator|->
name|sc
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_INSANE_RECV
operator||
name|BXE_INSANE_TPA
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_EXTREME_TPA
argument_list|,
literal|"%s(): fp[%02d].tpa[%02d], cons=0x%04X, prod=0x%04X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|queue
argument_list|,
name|cons
argument_list|,
name|prod
argument_list|)
expr_stmt|;
name|max_agg_queues
operator|=
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|?
name|ETH_MAX_AGGREGATION_QUEUES_E1
else|:
name|ETH_MAX_AGGREGATION_QUEUES_E1H
expr_stmt|;
name|DBRUNIF
argument_list|(
operator|(
name|queue
operator|>
name|max_agg_queues
operator|)
argument_list|,
name|BXE_PRINTF
argument_list|(
literal|"%s(): fp[%02d] illegal aggregation (%d> %d)!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|queue
argument_list|,
name|max_agg_queues
argument_list|)
argument_list|)
expr_stmt|;
name|DBRUNIF
argument_list|(
operator|(
name|fp
operator|->
name|tpa_state
index|[
name|queue
index|]
operator|!=
name|BXE_TPA_STATE_STOP
operator|)
argument_list|,
name|BXE_PRINTF
argument_list|(
literal|"%s(): Starting aggregation on "
literal|"fp[%02d].tpa[%02d] even though queue is not in the "
literal|"TPA_STOP state!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|queue
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remove the existing mbuf and mapping from the TPA pool. */
name|m_temp
operator|=
name|fp
operator|->
name|tpa_mbuf_ptr
index|[
name|queue
index|]
expr_stmt|;
name|map_temp
operator|=
name|fp
operator|->
name|tpa_mbuf_map
index|[
name|queue
index|]
expr_stmt|;
comment|/* Only the paranoid survive! */
if|if
condition|(
name|m_temp
operator|==
name|NULL
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"%s(%d): fp[%02d].tpa[%02d] not allocated!\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|queue
argument_list|)
expr_stmt|;
comment|/* ToDo: Additional error handling! */
goto|goto
name|bxe_tpa_start_exit
goto|;
block|}
comment|/* Move received mbuf and mapping to TPA pool. */
name|fp
operator|->
name|tpa_mbuf_ptr
index|[
name|queue
index|]
operator|=
name|fp
operator|->
name|rx_mbuf_ptr
index|[
name|cons
index|]
expr_stmt|;
name|fp
operator|->
name|tpa_mbuf_map
index|[
name|queue
index|]
operator|=
name|fp
operator|->
name|rx_mbuf_map
index|[
name|cons
index|]
expr_stmt|;
comment|/* Place the TPA bin into the START state. */
name|fp
operator|->
name|tpa_state
index|[
name|queue
index|]
operator|=
name|BXE_TPA_STATE_START
expr_stmt|;
name|DBRUN
argument_list|(
name|fp
operator|->
name|tpa_queue_used
operator||=
operator|(
literal|1
operator|<<
name|queue
operator|)
argument_list|)
expr_stmt|;
comment|/* Get the rx_bd for the next open entry on the receive chain. */
name|rx_bd
operator|=
operator|&
name|fp
operator|->
name|rx_chain
index|[
name|prod
index|]
expr_stmt|;
comment|/* Update the rx_bd with the empty mbuf from the TPA pool. */
name|rx_bd
operator|->
name|addr_hi
operator|=
name|htole32
argument_list|(
name|U64_HI
argument_list|(
name|fp
operator|->
name|tpa_mbuf_segs
index|[
name|queue
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|rx_bd
operator|->
name|addr_lo
operator|=
name|htole32
argument_list|(
name|U64_LO
argument_list|(
name|fp
operator|->
name|tpa_mbuf_segs
index|[
name|queue
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|->
name|rx_mbuf_ptr
index|[
name|prod
index|]
operator|=
name|m_temp
expr_stmt|;
name|fp
operator|->
name|rx_mbuf_map
index|[
name|prod
index|]
operator|=
name|map_temp
expr_stmt|;
name|bxe_tpa_start_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_INSANE_RECV
operator||
name|BXE_INSANE_TPA
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * When a TPA aggregation is completed, loop through the individual mbufs  * of the aggregation, combining them into a single mbuf which will be sent  * up the stack.  Refill all freed SGEs with mbufs as we go along.  *  * Returns:  *   0 = Success, !0 = Failure.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_fill_frag_mbuf
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|eth_fast_path_rx_cqe
modifier|*
name|fp_cqe
parameter_list|,
name|uint16_t
name|cqe_idx
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_frag
decl_stmt|;
name|uint32_t
name|frag_len
decl_stmt|,
name|frag_size
decl_stmt|,
name|pages
decl_stmt|,
name|i
decl_stmt|;
name|uint16_t
name|sge_idx
decl_stmt|,
name|len_on_bd
decl_stmt|;
name|int
name|j
decl_stmt|,
name|rc
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_EXTREME_RECV
operator||
name|BXE_EXTREME_TPA
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
name|len_on_bd
operator|=
name|le16toh
argument_list|(
name|fp_cqe
operator|->
name|len_on_bd
argument_list|)
expr_stmt|;
name|frag_size
operator|=
name|le16toh
argument_list|(
name|fp_cqe
operator|->
name|pkt_len
argument_list|)
operator|-
name|len_on_bd
expr_stmt|;
name|pages
operator|=
name|SGE_PAGE_ALIGN
argument_list|(
name|frag_size
argument_list|)
operator|>>
name|SGE_PAGE_SHIFT
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_TPA
argument_list|,
literal|"%s(): len_on_bd=%d, frag_size=%d, pages=%d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|len_on_bd
argument_list|,
name|frag_size
argument_list|,
name|pages
argument_list|)
expr_stmt|;
comment|/* Make sure the aggregated frame is not too big to handle. */
if|if
condition|(
name|pages
operator|>
literal|8
operator|*
name|PAGES_PER_SGE
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): fp[%02d].rx_sge[0x%04X] has too many pages (%d)!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|cqe_idx
argument_list|,
name|pages
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): fp_cqe->pkt_len = %d fp_cqe->len_on_bd = %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|le16toh
argument_list|(
name|fp_cqe
operator|->
name|pkt_len
argument_list|)
argument_list|,
name|len_on_bd
argument_list|)
expr_stmt|;
name|bxe_panic_dump
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bxe_fill_frag_mbuf_exit
goto|;
block|}
comment|/* 	 * Scan through the scatter gather list, pulling individual 	 * mbufs into a single mbuf for the host stack. 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|pages
condition|;
name|i
operator|+=
name|PAGES_PER_SGE
operator|,
name|j
operator|++
control|)
block|{
name|sge_idx
operator|=
name|RX_SGE
argument_list|(
name|le16toh
argument_list|(
name|fp_cqe
operator|->
name|sgl
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Firmware gives the indices of the SGE as if the ring is an 		 * array (meaning that the "next" element will consume 2 		 * indices). 		 */
name|frag_len
operator|=
name|min
argument_list|(
name|frag_size
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|BCM_PAGE_SIZE
operator|*
name|PAGES_PER_SGE
argument_list|)
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_TPA
argument_list|,
literal|"%s(): i=%d, j=%d, frag_size=%d, frag_len=%d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|frag_size
argument_list|,
name|frag_len
argument_list|)
expr_stmt|;
name|m_frag
operator|=
name|fp
operator|->
name|rx_sge_buf_ptr
index|[
name|sge_idx
index|]
expr_stmt|;
comment|/* Allocate a new mbuf for the SGE. */
name|rc
operator|=
name|bxe_alloc_rx_sge_mbuf
argument_list|(
name|fp
argument_list|,
name|sge_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
comment|/* 			 * Leave all remaining SGEs in the ring. 			 */
goto|goto
name|bxe_fill_frag_mbuf_exit
goto|;
block|}
comment|/* Update the fragment its length. */
name|m_frag
operator|->
name|m_len
operator|=
name|frag_len
expr_stmt|;
comment|/* Concatenate the fragment to the head mbuf. */
name|m_cat
argument_list|(
name|m
argument_list|,
name|m_frag
argument_list|)
expr_stmt|;
name|DBRUN
argument_list|(
name|fp
operator|->
name|sge_mbuf_alloc
operator|--
argument_list|)
expr_stmt|;
comment|/* Update TPA mbuf size and remaining fragment size. */
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|frag_len
expr_stmt|;
name|frag_size
operator|-=
name|frag_len
expr_stmt|;
block|}
name|bxe_fill_frag_mbuf_exit
label|:
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_TPA
argument_list|,
literal|"%s(): frag_size=%d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|frag_size
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_EXTREME_RECV
operator||
name|BXE_EXTREME_TPA
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The aggregation on the current TPA queue has completed.  Pull the  * individual mbuf fragments together into a single mbuf, perform all  * necessary checksum calculations, and send the resuting mbuf to the stack.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_tpa_stop
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|uint16_t
name|queue
parameter_list|,
name|int
name|pad
parameter_list|,
name|int
name|len
parameter_list|,
name|union
name|eth_rx_cqe
modifier|*
name|cqe
parameter_list|,
name|uint16_t
name|cqe_idx
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|DBENTER
argument_list|(
name|BXE_INSANE_RECV
operator||
name|BXE_INSANE_TPA
argument_list|)
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
operator|(
name|BXE_EXTREME_RECV
operator||
name|BXE_EXTREME_TPA
operator|)
argument_list|,
literal|"%s(): fp[%02d].tpa[%02d], len=%d, pad=%d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|queue
argument_list|,
name|len
argument_list|,
name|pad
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|bxe_ifp
expr_stmt|;
name|m
operator|=
name|fp
operator|->
name|tpa_mbuf_ptr
index|[
name|queue
index|]
expr_stmt|;
comment|/* Allocate a replacement before modifying existing mbuf. */
name|rc
operator|=
name|bxe_alloc_tpa_mbuf
argument_list|(
name|fp
argument_list|,
name|queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
comment|/* Drop the frame and log a soft error. */
name|fp
operator|->
name|rx_soft_errors
operator|++
expr_stmt|;
goto|goto
name|bxe_tpa_stop_exit
goto|;
block|}
comment|/* We have a replacement, fixup the current mbuf. */
name|m_adj
argument_list|(
name|m
argument_list|,
name|pad
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
comment|/* Mark the checksums valid (taken care of by firmware). */
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_IP_CHECKED
operator||
name|CSUM_IP_VALID
operator||
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xffff
expr_stmt|;
comment|/* Aggregate all of the SGEs into a single mbuf. */
name|rc
operator|=
name|bxe_fill_frag_mbuf
argument_list|(
name|sc
argument_list|,
name|fp
argument_list|,
name|m
argument_list|,
operator|&
name|cqe
operator|->
name|fast_path_cqe
argument_list|,
name|cqe_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
comment|/* Drop the packet and log an error. */
name|fp
operator|->
name|rx_soft_errors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Find VLAN tag and send frame up to the stack. */
if|if
condition|(
operator|(
name|le16toh
argument_list|(
name|cqe
operator|->
name|fast_path_cqe
operator|.
name|pars_flags
operator|.
name|flags
argument_list|)
operator|&
name|PARSING_FLAGS_VLAN
operator|)
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|=
name|cqe
operator|->
name|fast_path_cqe
operator|.
name|vlan_tag
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_VLANTAG
expr_stmt|;
block|}
comment|/* Assign packet to the appropriate interface. */
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
comment|/* Update packet statistics. */
name|fp
operator|->
name|rx_tpa_pkts
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
comment|/* ToDo: Any potential locking issues here? */
comment|/* Pass the frame to the stack. */
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* We passed mbuf up the stack or dropped the frame. */
name|DBRUN
argument_list|(
name|fp
operator|->
name|tpa_mbuf_alloc
operator|--
argument_list|)
expr_stmt|;
name|bxe_tpa_stop_exit
label|:
name|fp
operator|->
name|tpa_state
index|[
name|queue
index|]
operator|=
name|BXE_TPA_STATE_STOP
expr_stmt|;
name|DBRUN
argument_list|(
name|fp
operator|->
name|tpa_queue_used
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|queue
operator|)
argument_list|)
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_INSANE_RECV
operator||
name|BXE_INSANE_TPA
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Notify the controller that the RX producer indices have been updated for  * a fastpath connection by writing them to the controller.  *  * Returns:  *   None  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|bxe_update_rx_prod
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|uint16_t
name|bd_prod
parameter_list|,
name|uint16_t
name|cqe_prod
parameter_list|,
name|uint16_t
name|sge_prod
parameter_list|)
block|{
specifier|volatile
name|struct
name|ustorm_eth_rx_producers
name|rx_prods
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Update producers. */
name|rx_prods
operator|.
name|bd_prod
operator|=
name|bd_prod
expr_stmt|;
name|rx_prods
operator|.
name|cqe_prod
operator|=
name|cqe_prod
expr_stmt|;
name|rx_prods
operator|.
name|sge_prod
operator|=
name|sge_prod
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ustorm_eth_rx_producers
argument_list|)
operator|/
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_USTORM_INTMEM
operator|+
name|USTORM_RX_PRODS_OFFSET
argument_list|(
name|BP_PORT
argument_list|(
name|sc
argument_list|)
argument_list|,
name|fp
operator|->
name|cl_id
argument_list|)
operator|+
name|i
operator|*
literal|4
argument_list|,
operator|(
operator|(
specifier|volatile
name|uint32_t
operator|*
operator|)
operator|&
name|rx_prods
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_EXTREME_RECV
argument_list|,
literal|"%s(%d): Wrote fp[%02d] bd_prod = 0x%04X, "
literal|"cqe_prod = 0x%04X, sge_prod = 0x%04X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|curcpu
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|bd_prod
argument_list|,
name|cqe_prod
argument_list|,
name|sge_prod
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Processes received frames.  *  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_rxeof
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|uint16_t
name|rx_bd_cons
decl_stmt|,
name|rx_bd_cons_idx
decl_stmt|;
name|uint16_t
name|rx_bd_prod
decl_stmt|,
name|rx_bd_prod_idx
decl_stmt|;
name|uint16_t
name|rx_cq_cons
decl_stmt|,
name|rx_cq_cons_idx
decl_stmt|;
name|uint16_t
name|rx_cq_prod
decl_stmt|,
name|rx_cq_cons_sb
decl_stmt|;
name|unsigned
name|long
name|rx_pkts
init|=
literal|0
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|sc
operator|=
name|fp
operator|->
name|sc
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|bxe_ifp
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_EXTREME_RECV
argument_list|)
expr_stmt|;
comment|/* Get the status block's view of the RX completion consumer index. */
name|rx_cq_cons_sb
operator|=
name|bxe_rx_cq_cons
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* 	 * Get working copies of the driver's view of the 	 * RX indices. These are 16 bit values that are 	 * expected to increment from 0 to 65535 and then 	 * wrap-around to 0 again. 	 */
name|rx_bd_cons
operator|=
name|fp
operator|->
name|rx_bd_cons
expr_stmt|;
name|rx_bd_prod
operator|=
name|fp
operator|->
name|rx_bd_prod
expr_stmt|;
name|rx_cq_cons
operator|=
name|fp
operator|->
name|rx_cq_cons
expr_stmt|;
name|rx_cq_prod
operator|=
name|fp
operator|->
name|rx_cq_prod
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
operator|(
name|BXE_EXTREME_RECV
operator|)
argument_list|,
literal|"%s(%d): BEFORE: fp[%02d], rx_bd_cons = 0x%04X, rx_bd_prod = 0x%04X, "
literal|"rx_cq_cons_sw = 0x%04X, rx_cq_prod_sw = 0x%04X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|curcpu
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|rx_bd_cons
argument_list|,
name|rx_bd_prod
argument_list|,
name|rx_cq_cons
argument_list|,
name|rx_cq_prod
argument_list|)
expr_stmt|;
comment|/* 	 * Memory barrier to prevent speculative reads of the RX buffer 	 * from getting ahead of the index in the status block. 	 */
name|rmb
argument_list|()
expr_stmt|;
comment|/* 	 * Scan through the receive chain as long 	 * as there is work to do. 	 */
while|while
condition|(
name|rx_cq_cons
operator|!=
name|rx_cq_cons_sb
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|union
name|eth_rx_cqe
modifier|*
name|cqe
decl_stmt|;
name|uint8_t
name|cqe_fp_flags
decl_stmt|;
name|uint16_t
name|len
decl_stmt|,
name|pad
decl_stmt|;
comment|/* 		 * Convert the 16 bit indices used by hardware 		 * into array indices used by the driver. 		 */
name|rx_cq_cons_idx
operator|=
name|RCQ_ENTRY
argument_list|(
name|rx_cq_cons
argument_list|)
expr_stmt|;
name|rx_bd_prod_idx
operator|=
name|RX_BD
argument_list|(
name|rx_bd_prod
argument_list|)
expr_stmt|;
name|rx_bd_cons_idx
operator|=
name|RX_BD
argument_list|(
name|rx_bd_cons
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
comment|/* Fetch the completion queue entry (i.e. cookie). */
name|cqe
operator|=
operator|(
expr|union
name|eth_rx_cqe
operator|*
operator|)
operator|&
name|fp
operator|->
name|rcq_chain
index|[
name|rx_cq_cons_idx
index|]
expr_stmt|;
name|cqe_fp_flags
operator|=
name|cqe
operator|->
name|fast_path_cqe
operator|.
name|type_error_flags
expr_stmt|;
comment|/* Sanity check the cookie flags. */
if|if
condition|(
name|__predict_false
argument_list|(
name|cqe_fp_flags
operator|==
literal|0
argument_list|)
condition|)
block|{
name|fp
operator|->
name|rx_null_cqe_flags
operator|++
expr_stmt|;
name|DBRUN
argument_list|(
name|bxe_dump_cqe
argument_list|(
name|fp
argument_list|,
name|rx_cq_cons_idx
argument_list|,
name|cqe
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ToDo: What error handling can be done here? */
block|}
comment|/* Check the CQE type for slowpath or fastpath completion. */
if|if
condition|(
name|__predict_false
argument_list|(
name|CQE_TYPE
argument_list|(
name|cqe_fp_flags
argument_list|)
operator|==
name|RX_ETH_CQE_TYPE_ETH_RAMROD
argument_list|)
condition|)
block|{
comment|/* This is a slowpath completion. */
name|bxe_sp_event
argument_list|(
name|fp
argument_list|,
name|cqe
argument_list|)
expr_stmt|;
goto|goto
name|bxe_rxeof_next_cqe
goto|;
block|}
else|else
block|{
comment|/* This is a fastpath completion. */
comment|/* Get the length and pad information from the CQE. */
name|len
operator|=
name|le16toh
argument_list|(
name|cqe
operator|->
name|fast_path_cqe
operator|.
name|pkt_len
argument_list|)
expr_stmt|;
name|pad
operator|=
name|cqe
operator|->
name|fast_path_cqe
operator|.
name|placement_offset
expr_stmt|;
comment|/* Check if the completion is for TPA. */
if|if
condition|(
operator|(
name|fp
operator|->
name|disable_tpa
operator|==
name|FALSE
operator|)
operator|&&
operator|(
name|TPA_TYPE
argument_list|(
name|cqe_fp_flags
argument_list|)
operator|!=
operator|(
name|TPA_TYPE_START
operator||
name|TPA_TYPE_END
operator|)
operator|)
condition|)
block|{
name|uint16_t
name|queue
init|=
name|cqe
operator|->
name|fast_path_cqe
operator|.
name|queue_index
decl_stmt|;
comment|/* 				 * No need to worry about error flags in 				 * the frame as the firmware has already 				 * managed that for us when aggregating 				 * the frames. 				 */
comment|/* Check if TPA aggregation has started. */
if|if
condition|(
name|TPA_TYPE
argument_list|(
name|cqe_fp_flags
argument_list|)
operator|==
name|TPA_TYPE_START
condition|)
block|{
name|bxe_tpa_start
argument_list|(
name|fp
argument_list|,
name|queue
argument_list|,
name|rx_bd_cons_idx
argument_list|,
name|rx_bd_prod_idx
argument_list|)
expr_stmt|;
goto|goto
name|bxe_rxeof_next_rx
goto|;
block|}
comment|/* Check if TPA aggregation has completed. */
if|if
condition|(
name|TPA_TYPE
argument_list|(
name|cqe_fp_flags
argument_list|)
operator|==
name|TPA_TYPE_END
condition|)
block|{
name|DBRUNIF
argument_list|(
operator|!
name|BXE_RX_SUM_FIX
argument_list|(
name|cqe
argument_list|)
argument_list|,
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_FATAL
argument_list|,
literal|"%s(): STOP on non-TCP data.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 					 * This is the size of the linear 					 * data on this mbuf. 					 */
name|len
operator|=
name|le16toh
argument_list|(
name|cqe
operator|->
name|fast_path_cqe
operator|.
name|len_on_bd
argument_list|)
expr_stmt|;
comment|/* 					 * Stop the aggregation and pass 					 * the frame up. 					 */
name|bxe_tpa_stop
argument_list|(
name|sc
argument_list|,
name|fp
argument_list|,
name|queue
argument_list|,
name|pad
argument_list|,
name|len
argument_list|,
name|cqe
argument_list|,
name|rx_cq_cons_idx
argument_list|)
expr_stmt|;
name|bxe_update_sge_prod
argument_list|(
name|fp
argument_list|,
operator|&
name|cqe
operator|->
name|fast_path_cqe
argument_list|)
expr_stmt|;
goto|goto
name|bxe_rxeof_next_cqe
goto|;
block|}
block|}
name|m
operator|=
name|fp
operator|->
name|rx_mbuf_ptr
index|[
name|rx_bd_cons_idx
index|]
expr_stmt|;
comment|/* Allocate a replacement before modifying existing mbuf. */
name|rc
operator|=
name|bxe_alloc_rx_bd_mbuf
argument_list|(
name|fp
argument_list|,
name|rx_bd_prod_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
comment|/* Drop the frame and log a soft error. */
name|fp
operator|->
name|rx_soft_errors
operator|++
expr_stmt|;
goto|goto
name|bxe_rxeof_next_rx
goto|;
block|}
comment|/* Check if the received frame has any errors. */
if|if
condition|(
name|__predict_false
argument_list|(
name|cqe_fp_flags
operator|&
name|ETH_RX_ERROR_FLAGS
argument_list|)
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN
argument_list|,
literal|"%s(): fp[%02d].cqe[0x%04X] has errors "
literal|"(0x%08X)!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|rx_cq_cons
argument_list|,
name|cqe_fp_flags
argument_list|)
expr_stmt|;
name|fp
operator|->
name|rx_soft_errors
operator|++
expr_stmt|;
goto|goto
name|bxe_rxeof_next_rx
goto|;
block|}
comment|/* We have a replacement, fixup the current mbuf. */
name|m_adj
argument_list|(
name|m
argument_list|,
name|pad
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
comment|/* Assign packet to the appropriate interface. */
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
comment|/* Assume no hardware checksum complated. */
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
literal|0
expr_stmt|;
comment|/* Validate checksum if offload enabled. */
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
condition|)
block|{
comment|/* Check whether IP checksummed or not. */
if|if
condition|(
name|sc
operator|->
name|rx_csum
operator|&&
operator|!
operator|(
name|cqe
operator|->
name|fast_path_cqe
operator|.
name|status_flags
operator|&
name|ETH_FAST_PATH_RX_CQE_IP_XSUM_NO_VALIDATION_FLG
operator|)
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_IP_CHECKED
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|cqe_fp_flags
operator|&
name|ETH_FAST_PATH_RX_CQE_IP_BAD_XSUM_FLG
argument_list|)
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_WARN_SEND
argument_list|,
literal|"%s(): Invalid IP checksum!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
else|else
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_IP_VALID
expr_stmt|;
block|}
comment|/* Check for a valid TCP/UDP frame. */
if|if
condition|(
name|sc
operator|->
name|rx_csum
operator|&&
operator|!
operator|(
name|cqe
operator|->
name|fast_path_cqe
operator|.
name|status_flags
operator|&
name|ETH_FAST_PATH_RX_CQE_L4_XSUM_NO_VALIDATION_FLG
operator|)
condition|)
block|{
comment|/* Check for a good TCP/UDP checksum. */
if|if
condition|(
name|__predict_false
argument_list|(
name|cqe_fp_flags
operator|&
name|ETH_FAST_PATH_RX_CQE_L4_BAD_XSUM_FLG
argument_list|)
condition|)
block|{
name|DBPRINT
argument_list|(
name|sc
argument_list|,
name|BXE_VERBOSE_RECV
argument_list|,
literal|"%s(): Invalid TCP/UDP checksum!\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xFFFF
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
operator|(
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 			 * If we received a packet with a vlan tag, 			 * attach that information to the packet. 			 */
if|if
condition|(
name|cqe
operator|->
name|fast_path_cqe
operator|.
name|pars_flags
operator|.
name|flags
operator|&
name|PARSING_FLAGS_VLAN
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|=
name|cqe
operator|->
name|fast_path_cqe
operator|.
name|vlan_tag
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_VLANTAG
expr_stmt|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
comment|/* Tell OS what RSS queue was used for this flow. */
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
name|fp
operator|->
name|index
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_FLOWID
expr_stmt|;
endif|#
directive|endif
comment|/* Last chance to check for problems. */
name|DBRUN
argument_list|(
name|bxe_validate_rx_packet
argument_list|(
name|fp
argument_list|,
name|rx_cq_cons
argument_list|,
name|cqe
argument_list|,
name|m
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Update packet statistics. */
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|rx_pkts
operator|++
expr_stmt|;
comment|/* ToDo: Any potential locking issues here? */
comment|/* Pass the frame to the stack. */
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|DBRUN
argument_list|(
name|fp
operator|->
name|rx_mbuf_alloc
operator|--
argument_list|)
expr_stmt|;
block|}
name|bxe_rxeof_next_rx
label|:
name|rx_bd_prod
operator|=
name|NEXT_RX_BD
argument_list|(
name|rx_bd_prod
argument_list|)
expr_stmt|;
name|rx_bd_cons
operator|=
name|NEXT_RX_BD
argument_list|(
name|rx_bd_cons
argument_list|)
expr_stmt|;
name|bxe_rxeof_next_cqe
label|:
name|rx_cq_prod
operator|=
name|NEXT_RCQ_IDX
argument_list|(
name|rx_cq_prod
argument_list|)
expr_stmt|;
name|rx_cq_cons
operator|=
name|NEXT_RCQ_IDX
argument_list|(
name|rx_cq_cons
argument_list|)
expr_stmt|;
comment|/* 		 * Memory barrier to prevent speculative reads of the RX buffer 		 * from getting ahead of the index in the status block. 		 */
name|rmb
argument_list|()
expr_stmt|;
block|}
comment|/* Update driver copy of the fastpath indices. */
name|fp
operator|->
name|rx_bd_cons
operator|=
name|rx_bd_cons
expr_stmt|;
name|fp
operator|->
name|rx_bd_prod
operator|=
name|rx_bd_prod
expr_stmt|;
name|fp
operator|->
name|rx_cq_cons
operator|=
name|rx_cq_cons
expr_stmt|;
name|fp
operator|->
name|rx_cq_prod
operator|=
name|rx_cq_prod
expr_stmt|;
name|DBPRINT
argument_list|(
name|sc
argument_list|,
operator|(
name|BXE_EXTREME_RECV
operator|)
argument_list|,
literal|"%s(%d):  AFTER: fp[%02d], rx_bd_cons = 0x%04X, rx_bd_prod = 0x%04X, "
literal|"rx_cq_cons_sw = 0x%04X, rx_cq_prod_sw = 0x%04X\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|curcpu
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|rx_bd_cons
argument_list|,
name|rx_bd_prod
argument_list|,
name|rx_cq_cons
argument_list|,
name|rx_cq_prod
argument_list|)
expr_stmt|;
comment|/* Update producers */
name|bxe_update_rx_prod
argument_list|(
name|sc
argument_list|,
name|fp
argument_list|,
name|fp
operator|->
name|rx_bd_prod
argument_list|,
name|fp
operator|->
name|rx_cq_prod
argument_list|,
name|fp
operator|->
name|rx_sge_prod
argument_list|)
expr_stmt|;
name|bus_space_barrier
argument_list|(
name|sc
operator|->
name|bxe_btag
argument_list|,
name|sc
operator|->
name|bxe_bhandle
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_BARRIER_READ
argument_list|)
expr_stmt|;
name|fp
operator|->
name|rx_pkts
operator|+=
name|rx_pkts
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_EXTREME_RECV
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Processes transmit completions.  *  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_txeof
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|eth_tx_start_bd
modifier|*
name|txbd
decl_stmt|;
name|uint16_t
name|hw_pkt_cons
decl_stmt|,
name|sw_pkt_cons
decl_stmt|,
name|sw_tx_bd_cons
decl_stmt|;
name|uint16_t
name|bd_index
decl_stmt|,
name|pkt_index
decl_stmt|,
name|nbds
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|fp
operator|->
name|sc
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|bxe_ifp
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_EXTREME_SEND
argument_list|)
expr_stmt|;
comment|/* Get the hardware's view of the TX packet consumer index. */
name|hw_pkt_cons
operator|=
name|le16toh
argument_list|(
operator|*
name|fp
operator|->
name|tx_pkt_cons_sb
argument_list|)
expr_stmt|;
name|sw_pkt_cons
operator|=
name|fp
operator|->
name|tx_pkt_cons
expr_stmt|;
name|sw_tx_bd_cons
operator|=
name|fp
operator|->
name|tx_bd_cons
expr_stmt|;
comment|/* Cycle through any completed TX chain page entries. */
while|while
condition|(
name|sw_pkt_cons
operator|!=
name|hw_pkt_cons
condition|)
block|{
name|bd_index
operator|=
name|TX_BD
argument_list|(
name|sw_tx_bd_cons
argument_list|)
expr_stmt|;
name|pkt_index
operator|=
name|TX_BD
argument_list|(
name|sw_pkt_cons
argument_list|)
expr_stmt|;
name|txbd
operator|=
operator|&
name|fp
operator|->
name|tx_chain
index|[
name|bd_index
index|]
operator|.
name|start_bd
expr_stmt|;
name|nbds
operator|=
name|txbd
operator|->
name|nbd
expr_stmt|;
comment|/* Free the completed frame's mbuf. */
if|if
condition|(
name|__predict_true
argument_list|(
name|fp
operator|->
name|tx_mbuf_ptr
index|[
name|pkt_index
index|]
operator|!=
name|NULL
argument_list|)
condition|)
block|{
comment|/* Unmap the mbuf from non-paged memory. */
name|bus_dmamap_unload
argument_list|(
name|fp
operator|->
name|tx_mbuf_tag
argument_list|,
name|fp
operator|->
name|tx_mbuf_map
index|[
name|pkt_index
index|]
argument_list|)
expr_stmt|;
comment|/* Return the mbuf to the system. */
name|m_freem
argument_list|(
name|fp
operator|->
name|tx_mbuf_ptr
index|[
name|pkt_index
index|]
argument_list|)
expr_stmt|;
name|fp
operator|->
name|tx_mbuf_alloc
operator|--
expr_stmt|;
name|fp
operator|->
name|tx_mbuf_ptr
index|[
name|pkt_index
index|]
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|opackets
operator|++
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|->
name|tx_chain_lost_mbuf
operator|++
expr_stmt|;
block|}
comment|/* Updated packet consumer value. */
name|sw_pkt_cons
operator|++
expr_stmt|;
comment|/* Skip over the remaining used buffer descriptors. */
name|fp
operator|->
name|tx_bd_used
operator|-=
name|nbds
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbds
condition|;
name|i
operator|++
control|)
name|sw_tx_bd_cons
operator|=
name|NEXT_TX_BD
argument_list|(
name|sw_tx_bd_cons
argument_list|)
expr_stmt|;
comment|/* Check for new work since we started. */
name|hw_pkt_cons
operator|=
name|le16toh
argument_list|(
operator|*
name|fp
operator|->
name|tx_pkt_cons_sb
argument_list|)
expr_stmt|;
name|rmb
argument_list|()
expr_stmt|;
block|}
comment|/* Enable new transmits if we've made enough room. */
if|if
condition|(
name|fp
operator|->
name|tx_bd_used
operator|<
name|BXE_TX_CLEANUP_THRESHOLD
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|tx_bd_used
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Clear the watchdog timer if we've emptied 			 * the TX chain. 			 */
name|fp
operator|->
name|watchdog_timer
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Reset the watchdog timer if we still have 			 * transmits pending. 			 */
name|fp
operator|->
name|watchdog_timer
operator|=
name|BXE_TX_TIMEOUT
expr_stmt|;
block|}
block|}
comment|/* Save our indices. */
name|fp
operator|->
name|tx_pkt_cons
operator|=
name|sw_pkt_cons
expr_stmt|;
name|fp
operator|->
name|tx_bd_cons
operator|=
name|sw_tx_bd_cons
expr_stmt|;
name|DBEXIT
argument_list|(
name|BXE_EXTREME_SEND
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Transmit timeout handler.  *  * Returns:  *   0 = No timeout, !0 = timeout occurred.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_watchdog
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|sc
operator|=
name|fp
operator|->
name|sc
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_INSANE_SEND
argument_list|)
expr_stmt|;
name|BXE_FP_LOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|watchdog_timer
operator|==
literal|0
operator|||
operator|--
name|fp
operator|->
name|watchdog_timer
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
name|BXE_FP_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
goto|goto
name|bxe_watchdog_exit
goto|;
block|}
name|BXE_FP_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"TX watchdog timeout occurred on fp[%02d], "
literal|"resetting!\n"
argument_list|,
name|fp
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* DBRUNLV(BXE_FATAL, bxe_breakpoint(sc)); */
name|BXE_CORE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Mark the interface as down. */
name|sc
operator|->
name|bxe_ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|bxe_stop_locked
argument_list|(
name|sc
argument_list|,
name|UNLOAD_NORMAL
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|bxe_init_locked
argument_list|(
name|sc
argument_list|,
name|LOAD_OPEN
argument_list|)
expr_stmt|;
name|BXE_CORE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_watchdog_exit
label|:
name|DBEXIT
argument_list|(
name|BXE_INSANE_SEND
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The periodic timer tick routine.  *  * This code only runs when the interface is up.  *  * Returns:  *   None  */
end_comment

begin_function
specifier|static
name|void
name|bxe_tick
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
if|#
directive|if
literal|0
comment|/* Re-enable at a later time. */
block|uint32_t drv_pulse, mcp_pulse;
endif|#
directive|endif
name|int
name|i
decl_stmt|,
name|func
decl_stmt|;
name|sc
operator|=
name|xsc
expr_stmt|;
name|DBENTER
argument_list|(
name|BXE_INSANE_MISC
argument_list|)
expr_stmt|;
comment|/* Check for TX timeouts on any fastpath. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|bxe_watchdog
argument_list|(
name|fp
argument_list|)
operator|!=
literal|0
condition|)
break|break;
block|}
name|func
operator|=
name|BP_FUNC
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Schedule the next tick. */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|bxe_tick_callout
argument_list|,
name|hz
argument_list|,
name|bxe_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (!NOMCP(sc)) { 		func = BP_FUNC(sc);  		++sc->fw_drv_pulse_wr_seq; 		sc->fw_drv_pulse_wr_seq&= DRV_PULSE_SEQ_MASK;
comment|/* Let the MCP know we're alive. */
block|drv_pulse = sc->fw_drv_pulse_wr_seq; 		SHMEM_WR(sc, func_mb[func].drv_pulse_mb, drv_pulse);
comment|/* Check if the MCP is still alive. */
block|mcp_pulse = (SHMEM_RD(sc, func_mb[func].mcp_pulse_mb)& 		    MCP_PULSE_SEQ_MASK);
comment|/* 		 * The delta between driver pulse and MCP response should be 1 		 * (before MCP response) or 0 (after MCP response). 		 */
block|if ((drv_pulse != mcp_pulse)&& (drv_pulse != ((mcp_pulse + 1)& 		    MCP_PULSE_SEQ_MASK))) {
comment|/* Someone's in cardiac arrest. */
block|DBPRINT(sc, BXE_WARN, 			    "%s(): drv_pulse (0x%x) != mcp_pulse (0x%x)\n", 			    __FUNCTION__, drv_pulse, mcp_pulse); 		} 	}
endif|#
directive|endif
if|if
condition|(
operator|(
name|sc
operator|->
name|state
operator|==
name|BXE_STATE_OPEN
operator|)
operator|||
operator|(
name|sc
operator|->
name|state
operator|==
name|BXE_STATE_DISABLED
operator|)
condition|)
name|bxe_stats_handle
argument_list|(
name|sc
argument_list|,
name|STATS_EVENT_UPDATE
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BXE_DEBUG
end_ifdef

begin_comment
comment|/*  * Allows the driver state to be dumped through the sysctl interface.  *  * Returns:  *   0 for success, positive value for failure.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_sysctl_driver_state
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|result
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|bxe_softc
operator|*
operator|)
name|arg1
expr_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|result
operator|==
literal|1
condition|)
block|{
name|bxe_dump_driver_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
expr_stmt|;
name|bxe_dump_fp_state
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|bxe_dump_status_block
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allows the hardware state to be dumped through the sysctl interface.  *  * Returns:  *   0 for success, positive value for failure.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_sysctl_hw_state
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|result
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|bxe_softc
operator|*
operator|)
name|arg1
expr_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|result
operator|==
literal|1
condition|)
name|bxe_dump_hw_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allows the MCP firmware to be dumped through the sysctl interface.  *  * Returns:  *   0 for success, positive value for failure.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_sysctl_dump_fw
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|result
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|bxe_softc
operator|*
operator|)
name|arg1
expr_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|result
operator|==
literal|1
condition|)
name|bxe_dump_fw
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Provides a sysctl interface to allow dumping the RX completion chain.  *  * Returns:  *   0 for success, positive value for failure.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_sysctl_dump_rx_cq_chain
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|result
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|bxe_softc
operator|*
operator|)
name|arg1
expr_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|result
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|result
operator|<
name|sc
operator|->
name|num_queues
operator|)
condition|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|result
index|]
expr_stmt|;
name|bxe_dump_rx_cq_chain
argument_list|(
name|fp
argument_list|,
literal|0
argument_list|,
name|TOTAL_RCQ_ENTRIES
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Provides a sysctl interface to allow dumping the RX chain.  *  * Returns:  *   0 for success, positive value for failure.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_sysctl_dump_rx_bd_chain
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|result
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|bxe_softc
operator|*
operator|)
name|arg1
expr_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|result
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|result
operator|<
name|sc
operator|->
name|num_queues
operator|)
condition|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|result
index|]
expr_stmt|;
name|bxe_dump_rx_bd_chain
argument_list|(
name|fp
argument_list|,
literal|0
argument_list|,
name|TOTAL_RX_BD
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* * Provides a sysctl interface to allow dumping the TX chain. * * Returns: *   0 for success, positive value for failure. */
end_comment

begin_function
specifier|static
name|int
name|bxe_sysctl_dump_tx_chain
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|result
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|bxe_softc
operator|*
operator|)
name|arg1
expr_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|result
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|result
operator|<
name|sc
operator|->
name|num_queues
operator|)
condition|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|result
index|]
expr_stmt|;
name|bxe_dump_tx_chain
argument_list|(
name|fp
argument_list|,
literal|0
argument_list|,
name|TOTAL_TX_BD
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Provides a sysctl interface to allow reading arbitrary registers in the  * device.  DO NOT ENABLE ON PRODUCTION SYSTEMS!  *  * Returns:  *   0 for success, positive value for failure.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_sysctl_reg_read
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|result
decl_stmt|,
name|val
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|bxe_softc
operator|*
operator|)
name|arg1
expr_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|(
name|req
operator|->
name|newptr
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"reg 0x%08X = 0x%08X\n"
argument_list|,
name|result
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* * Provides a sysctl interface to allow generating a grcdump. * * Returns: *   0 for success, positive value for failure. */
end_comment

begin_function
specifier|static
name|int
name|bxe_sysctl_grcdump
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|result
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|bxe_softc
operator|*
operator|)
name|arg1
expr_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|result
operator|==
literal|1
condition|)
block|{
comment|/* Generate a grcdump and log the contents.*/
name|bxe_grcdump
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Generate a grcdump and don't log the contents. */
name|bxe_grcdump
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Provides a sysctl interface to forcing the driver to dump state and  * enter the debugger.  DO NOT ENABLE ON PRODUCTION SYSTEMS!  *  * Returns:  *   0 for success, positive value for failure.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_sysctl_breakpoint
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|result
decl_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|result
operator|==
literal|1
condition|)
block|{
name|sc
operator|=
operator|(
expr|struct
name|bxe_softc
operator|*
operator|)
name|arg1
expr_stmt|;
name|bxe_breakpoint
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Adds any sysctl parameters for tuning or debugging purposes.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_add_sysctls
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
init|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|children
init|=
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|bxe_port_stats
modifier|*
name|estats
init|=
operator|&
name|sc
operator|->
name|eth_stats
decl_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"estats_total_bytes_received_hi"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|estats
operator|->
name|total_bytes_received_hi
argument_list|,
literal|0
argument_list|,
literal|"Total bytes received (hi)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"estats_total_bytes_received_lo"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|estats
operator|->
name|total_bytes_received_lo
argument_list|,
literal|0
argument_list|,
literal|"Total bytes received (lo)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"estats_valid_bytes_received_hi"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|estats
operator|->
name|valid_bytes_received_hi
argument_list|,
literal|0
argument_list|,
literal|"Valid bytes received (hi)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"estats_valid_bytes_received_lo"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|estats
operator|->
name|valid_bytes_received_lo
argument_list|,
literal|0
argument_list|,
literal|"Valid bytes received (lo)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"estats_total_unicast_packets_received_hi"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|estats
operator|->
name|total_unicast_packets_received_hi
argument_list|,
literal|0
argument_list|,
literal|"Total unicast packets received (hi)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"estats_total_unicast_packets_received_lo"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|estats
operator|->
name|total_unicast_packets_received_lo
argument_list|,
literal|0
argument_list|,
literal|"Total unicast packets received (lo)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"estats_total_bytes_transmitted_hi"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|estats
operator|->
name|total_bytes_transmitted_hi
argument_list|,
literal|0
argument_list|,
literal|"Total bytes transmitted (hi)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"estats_total_bytes_transmitted_lo"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|estats
operator|->
name|total_bytes_transmitted_lo
argument_list|,
literal|0
argument_list|,
literal|"Total bytes transmitted (lo)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"estats_total_unicast_packets_transmitted_hi"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|estats
operator|->
name|total_unicast_packets_transmitted_hi
argument_list|,
literal|0
argument_list|,
literal|"Total unicast packets transmitted (hi)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"estats_total_unicast_packets_transmitted_lo"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|estats
operator|->
name|total_unicast_packets_transmitted_lo
argument_list|,
literal|0
argument_list|,
literal|"Total unicast packets transmitted (lo)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"estats_total_broadcast_packets_received_lo"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|estats
operator|->
name|total_broadcast_packets_received_lo
argument_list|,
literal|0
argument_list|,
literal|"Total broadcast packets received (lo)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"estats_total_broadcast_packets_transmitted_lo"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|estats
operator|->
name|total_broadcast_packets_transmitted_lo
argument_list|,
literal|0
argument_list|,
literal|"Total broadcast packets transmitted (lo)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"estats_total_multicast_packets_received_lo"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|estats
operator|->
name|total_multicast_packets_received_lo
argument_list|,
literal|0
argument_list|,
literal|"Total multicast packets received (lo)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"estats_total_multicast_packets_transmitted_lo"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|estats
operator|->
name|total_multicast_packets_transmitted_lo
argument_list|,
literal|0
argument_list|,
literal|"Total multicast packets transmitted (lo)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_stat_etherstatspkts64octets_hi"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|estats
operator|->
name|tx_stat_etherstatspkts64octets_hi
argument_list|,
literal|0
argument_list|,
literal|"Total 64 byte packets transmitted (hi)"
argument_list|)
expr_stmt|;
comment|/* ToDo: Fix for 64 bit access. */
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_stat_etherstatspkts64octets_lo"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|estats
operator|->
name|tx_stat_etherstatspkts64octets_lo
argument_list|,
literal|0
argument_list|,
literal|"Total 64 byte packets transmitted (lo)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"driver_xoff"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|estats
operator|->
name|driver_xoff
argument_list|,
literal|0
argument_list|,
literal|"Driver transmit queue full count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_start_called_with_link_down"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|tx_start_called_with_link_down
argument_list|,
literal|"TX start routine called while link down count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_start_called_with_queue_full"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|tx_start_called_with_queue_full
argument_list|,
literal|"TX start routine called with queue full count"
argument_list|)
expr_stmt|;
comment|/* ToDo: Add more statistics here. */
ifdef|#
directive|ifdef
name|BXE_DEBUG
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"bxe_debug"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|bxe_debug
argument_list|,
literal|0
argument_list|,
literal|"Debug message level flag"
argument_list|)
expr_stmt|;
endif|#
directive|endif
do|do
block|{
define|#
directive|define
name|QUEUE_NAME_LEN
value|32
name|char
name|namebuf
index|[
name|QUEUE_NAME_LEN
index|]
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|queue_node
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|queue_list
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|bxe_fastpath
modifier|*
name|fp
init|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|namebuf
argument_list|,
name|QUEUE_NAME_LEN
argument_list|,
literal|"fp[%02d]"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|queue_node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
name|namebuf
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Queue Name"
argument_list|)
expr_stmt|;
name|queue_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|queue_node
argument_list|)
expr_stmt|;
comment|/* 			 * Receive related fastpath statistics.* 			 */
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_pkts"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fp
operator|->
name|rx_pkts
argument_list|,
literal|"Received packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_tpa_pkts"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fp
operator|->
name|rx_tpa_pkts
argument_list|,
literal|"Received TPA packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_null_cqe_flags"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fp
operator|->
name|rx_null_cqe_flags
argument_list|,
literal|"CQEs with NULL flags count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_soft_errors"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fp
operator|->
name|rx_soft_errors
argument_list|,
literal|"Received frames dropped by driver count"
argument_list|)
expr_stmt|;
comment|/* 			 * Transmit related fastpath statistics.* 			 */
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_pkts"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fp
operator|->
name|tx_pkts
argument_list|,
literal|"Transmitted packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_soft_errors"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fp
operator|->
name|tx_soft_errors
argument_list|,
literal|"Transmit frames dropped by driver count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_offload_frames_csum_ip"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fp
operator|->
name|tx_offload_frames_csum_ip
argument_list|,
literal|"IP checksum offload frame count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_offload_frames_csum_tcp"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fp
operator|->
name|tx_offload_frames_csum_tcp
argument_list|,
literal|"TCP checksum offload frame count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_offload_frames_csum_udp"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fp
operator|->
name|tx_offload_frames_csum_udp
argument_list|,
literal|"UDP checksum offload frame count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_offload_frames_tso"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fp
operator|->
name|tx_offload_frames_tso
argument_list|,
literal|"TSO offload frame count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_header_splits"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fp
operator|->
name|tx_header_splits
argument_list|,
literal|"TSO frame header/data split count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_encap_failures"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fp
operator|->
name|tx_encap_failures
argument_list|,
literal|"TX encapsulation failure count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_hw_queue_full"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fp
operator|->
name|tx_hw_queue_full
argument_list|,
literal|"TX H/W queue too full to add a frame count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_hw_max_queue_depth"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fp
operator|->
name|tx_hw_max_queue_depth
argument_list|,
literal|"TX H/W maximum queue depth count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_dma_mapping_failure"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fp
operator|->
name|tx_dma_mapping_failure
argument_list|,
literal|"TX DMA mapping failure"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_max_drbr_queue_depth"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fp
operator|->
name|tx_max_drbr_queue_depth
argument_list|,
literal|0
argument_list|,
literal|"TX S/W queue maximum depth"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_window_violation_std"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fp
operator|->
name|tx_window_violation_std
argument_list|,
literal|"Standard frame TX BD window violation count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_window_violation_tso"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fp
operator|->
name|tx_window_violation_tso
argument_list|,
literal|"TSO frame TX BD window violation count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_unsupported_tso_request_ipv6"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fp
operator|->
name|tx_unsupported_tso_request_ipv6
argument_list|,
literal|"TSO frames with unsupported IPv6 protocol count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_unsupported_tso_request_not_tcp"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fp
operator|->
name|tx_unsupported_tso_request_not_tcp
argument_list|,
literal|"TSO frames with unsupported protocol count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_chain_lost_mbuf"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fp
operator|->
name|tx_chain_lost_mbuf
argument_list|,
literal|"Mbufs lost on TX chain count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_frame_deferred"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fp
operator|->
name|tx_frame_deferred
argument_list|,
literal|"TX frame deferred from H/W queue to S/W queue count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_queue_xoff"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fp
operator|->
name|tx_queue_xoff
argument_list|,
literal|"TX queue full count"
argument_list|)
expr_stmt|;
comment|/* 			 * Memory related fastpath statistics.* 			 */
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mbuf_rx_bd_alloc_failed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fp
operator|->
name|mbuf_rx_bd_alloc_failed
argument_list|,
literal|"RX BD mbuf allocation failure count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mbuf_rx_bd_mapping_failed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fp
operator|->
name|mbuf_rx_bd_mapping_failed
argument_list|,
literal|"RX BD mbuf mapping failure count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mbuf_tpa_alloc_failed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fp
operator|->
name|mbuf_tpa_alloc_failed
argument_list|,
literal|"TPA mbuf allocation failure count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mbuf_tpa_mapping_failed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fp
operator|->
name|mbuf_tpa_mapping_failed
argument_list|,
literal|"TPA mbuf mapping failure count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mbuf_sge_alloc_failed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fp
operator|->
name|mbuf_sge_alloc_failed
argument_list|,
literal|"SGE mbuf allocation failure count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mbuf_sge_mapping_failed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fp
operator|->
name|mbuf_sge_mapping_failed
argument_list|,
literal|"SGE mbuf mapping failure count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mbuf_defrag_attempts"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fp
operator|->
name|mbuf_defrag_attempts
argument_list|,
literal|"Mbuf defrag attempt count"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mbuf_defrag_failures"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fp
operator|->
name|mbuf_defrag_failures
argument_list|,
literal|"Mbuf defrag failure count"
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
literal|0
condition|)
do|;
ifdef|#
directive|ifdef
name|BXE_DEBUG
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"driver_state"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
literal|0
argument_list|,
name|bxe_sysctl_driver_state
argument_list|,
literal|"I"
argument_list|,
literal|"Drive state information"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"hw_state"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
literal|0
argument_list|,
name|bxe_sysctl_hw_state
argument_list|,
literal|"I"
argument_list|,
literal|"Hardware state information"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dump_fw"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
literal|0
argument_list|,
name|bxe_sysctl_dump_fw
argument_list|,
literal|"I"
argument_list|,
literal|"Dump MCP firmware"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dump_rx_bd_chain"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
literal|0
argument_list|,
name|bxe_sysctl_dump_rx_bd_chain
argument_list|,
literal|"I"
argument_list|,
literal|"Dump rx_bd chain"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dump_rx_cq_chain"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
literal|0
argument_list|,
name|bxe_sysctl_dump_rx_cq_chain
argument_list|,
literal|"I"
argument_list|,
literal|"Dump cqe chain"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dump_tx_chain"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
literal|0
argument_list|,
name|bxe_sysctl_dump_tx_chain
argument_list|,
literal|"I"
argument_list|,
literal|"Dump tx_bd chain"
argument_list|)
expr_stmt|;
comment|/* 	 * Generates a GRCdump (run sysctl dev.bxe.0.grcdump=0 	 * before accessing buffer below). 	 */
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"grcdump"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
literal|0
argument_list|,
name|bxe_sysctl_grcdump
argument_list|,
literal|"I"
argument_list|,
literal|"Initiate a grcdump operation"
argument_list|)
expr_stmt|;
comment|/* 	 * Hidden sysctl. 	 *  Use "sysctl -b dev.bxe.0.grcdump_buffer> buf.bin". 	 */
name|SYSCTL_ADD_OPAQUE
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"grcdump_buffer"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_SKIP
argument_list|,
name|sc
operator|->
name|grcdump_buffer
argument_list|,
name|BXE_GRCDUMP_BUF_SIZE
argument_list|,
literal|"IU"
argument_list|,
literal|"Access grcdump buffer"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"breakpoint"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
literal|0
argument_list|,
name|bxe_sysctl_breakpoint
argument_list|,
literal|"I"
argument_list|,
literal|"Driver breakpoint"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"reg_read"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
literal|0
argument_list|,
name|bxe_sysctl_reg_read
argument_list|,
literal|"I"
argument_list|,
literal|"Register read"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BXE_DEBUG */
block|}
end_function

begin_comment
comment|/*  * BXE Debug Routines  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BXE_DEBUG
end_ifdef

begin_comment
comment|/*  * Writes out the header for the debug dump buffer.  *  * Returns:  * 	 None.  *  * Modifies:  *   index  */
end_comment

begin_function
specifier|static
name|void
name|bxe_dump_debug_header
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
modifier|*
name|index
parameter_list|)
block|{
name|struct
name|hd_param
name|hd_param_cu
init|=
block|{
literal|0
block|}
decl_stmt|;
name|uint32_t
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|sc
operator|->
name|grcdump_buffer
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
condition|)
name|hd_param_cu
operator|=
name|hd_param_e1h
expr_stmt|;
else|else
name|hd_param_cu
operator|=
name|hd_param_e1
expr_stmt|;
name|buf
index|[
operator|(
operator|*
name|index
operator|)
operator|++
index|]
operator|=
name|hd_param_cu
operator|.
name|time_stamp
expr_stmt|;
name|buf
index|[
operator|(
operator|*
name|index
operator|)
operator|++
index|]
operator|=
name|hd_param_cu
operator|.
name|diag_ver
expr_stmt|;
name|buf
index|[
operator|(
operator|*
name|index
operator|)
operator|++
index|]
operator|=
name|hd_param_cu
operator|.
name|grc_dump_ver
expr_stmt|;
name|buf
index|[
operator|(
operator|*
name|index
operator|)
operator|++
index|]
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|XSTORM_WAITP_ADDRESS
argument_list|)
expr_stmt|;
name|buf
index|[
operator|(
operator|*
name|index
operator|)
operator|++
index|]
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|TSTORM_WAITP_ADDRESS
argument_list|)
expr_stmt|;
name|buf
index|[
operator|(
operator|*
name|index
operator|)
operator|++
index|]
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|USTORM_WAITP_ADDRESS
argument_list|)
expr_stmt|;
name|buf
index|[
operator|(
operator|*
name|index
operator|)
operator|++
index|]
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|CSTORM_WAITP_ADDRESS
argument_list|)
expr_stmt|;
comment|/* The size of the header is stored at the first DWORD. */
name|buf
index|[
literal|0
index|]
operator|=
operator|(
operator|*
name|index
operator|)
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Writes to the controller to prepare it for a dump.  *  * Returns:  * 	 None.  *  * Modifies:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_dump_debug_writes
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|write_val
decl_stmt|;
name|write_val
operator|=
literal|1
expr_stmt|;
comment|/* Halt the STORMs to get a consistent device state. */
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|XSTORM_WAITP_ADDRESS
argument_list|,
name|write_val
argument_list|)
expr_stmt|;
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|TSTORM_WAITP_ADDRESS
argument_list|,
name|write_val
argument_list|)
expr_stmt|;
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|USTORM_WAITP_ADDRESS
argument_list|,
name|write_val
argument_list|)
expr_stmt|;
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|CSTORM_WAITP_ADDRESS
argument_list|,
name|write_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
condition|)
name|REG_WR_IND
argument_list|(
name|sc
argument_list|,
name|TSTORM_CAM_MODE
argument_list|,
name|write_val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Cycles through the required register reads and dumps them  * to the debug buffer.  *  * Returns:  * 	 None.  *  * Modifies:  *   index  */
end_comment

begin_function
specifier|static
name|void
name|bxe_dump_debug_reg_read
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
modifier|*
name|index
parameter_list|)
block|{
name|preg_addr
name|preg_addrs
decl_stmt|;
name|uint32_t
name|regs_count
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
name|uint32_t
name|i
decl_stmt|,
name|reg_addrs_index
decl_stmt|;
name|buf
operator|=
name|sc
operator|->
name|grcdump_buffer
expr_stmt|;
name|preg_addrs
operator|=
name|NULL
expr_stmt|;
comment|/* Read different registers for different controllers. */
if|if
condition|(
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|regs_count
operator|=
name|regs_count_e1h
expr_stmt|;
name|preg_addrs
operator|=
operator|&
name|reg_addrs_e1h
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|regs_count
operator|=
name|regs_count_e1
expr_stmt|;
name|preg_addrs
operator|=
operator|&
name|reg_addrs_e1
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/* ToDo: Add a buffer size check. */
for|for
control|(
name|reg_addrs_index
operator|=
literal|0
init|;
name|reg_addrs_index
operator|<
name|regs_count
condition|;
name|reg_addrs_index
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|preg_addrs
index|[
name|reg_addrs_index
index|]
operator|.
name|size
condition|;
name|i
operator|++
control|)
block|{
name|buf
index|[
operator|(
operator|*
name|index
operator|)
operator|++
index|]
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|preg_addrs
index|[
name|reg_addrs_index
index|]
operator|.
name|addr
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Cycles through the required wide register reads and dumps them  * to the debug buffer.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_dump_debug_reg_wread
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
modifier|*
name|index
parameter_list|)
block|{
name|pwreg_addr
name|pwreg_addrs
decl_stmt|;
name|uint32_t
name|reg_addrs_index
decl_stmt|,
name|reg_add_read
decl_stmt|,
name|reg_add_count
decl_stmt|;
name|uint32_t
modifier|*
name|buf
decl_stmt|,
name|cam_index
decl_stmt|,
name|wregs_count
decl_stmt|;
name|buf
operator|=
name|sc
operator|->
name|grcdump_buffer
expr_stmt|;
name|pwreg_addrs
operator|=
name|NULL
expr_stmt|;
comment|/* Read different registers for different controllers. */
if|if
condition|(
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|wregs_count
operator|=
name|wregs_count_e1h
expr_stmt|;
name|pwreg_addrs
operator|=
operator|&
name|wreg_addrs_e1h
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|wregs_count
operator|=
name|wregs_count_e1
expr_stmt|;
name|pwreg_addrs
operator|=
operator|&
name|wreg_addrs_e1
index|[
literal|0
index|]
expr_stmt|;
block|}
for|for
control|(
name|reg_addrs_index
operator|=
literal|0
init|;
name|reg_addrs_index
operator|<
name|wregs_count
condition|;
name|reg_addrs_index
operator|++
control|)
block|{
name|reg_add_read
operator|=
name|pwreg_addrs
index|[
name|reg_addrs_index
index|]
operator|.
name|addr
expr_stmt|;
for|for
control|(
name|reg_add_count
operator|=
literal|0
init|;
name|reg_add_count
operator|<
name|pwreg_addrs
index|[
name|reg_addrs_index
index|]
operator|.
name|size
condition|;
name|reg_add_count
operator|++
control|)
block|{
name|buf
index|[
operator|(
operator|*
name|index
operator|)
operator|++
index|]
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|reg_add_read
argument_list|)
expr_stmt|;
name|reg_add_read
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
for|for
control|(
name|cam_index
operator|=
literal|0
init|;
name|cam_index
operator|<
name|pwreg_addrs
index|[
name|reg_addrs_index
index|]
operator|.
name|const_regs_count
condition|;
name|cam_index
operator|++
control|)
name|buf
index|[
operator|(
operator|*
name|index
operator|)
operator|++
index|]
operator|=
name|REG_RD_IND
argument_list|(
name|sc
argument_list|,
name|pwreg_addrs
index|[
name|reg_addrs_index
index|]
operator|.
name|const_regs
index|[
name|cam_index
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Performs a debug dump for offline diagnostics.  *  * Note that when this routine is called the STORM  * processors will be stopped in order to create a  * cohesive dump.  The controller will need to be  * reset before the device can begin passing traffic  * again.  *  * Returns:  *   None.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_grcdump
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|log
parameter_list|)
block|{
name|uint32_t
modifier|*
name|buf
decl_stmt|,
name|i
decl_stmt|,
name|index
decl_stmt|;
name|index
operator|=
literal|1
expr_stmt|;
name|buf
operator|=
name|sc
operator|->
name|grcdump_buffer
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
block|{
comment|/* Write the header and regsiters contents to the dump buffer. */
name|bxe_dump_debug_header
argument_list|(
name|sc
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
name|bxe_dump_debug_writes
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_dump_debug_reg_read
argument_list|(
name|sc
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
name|bxe_dump_debug_reg_wread
argument_list|(
name|sc
argument_list|,
operator|&
name|index
argument_list|)
expr_stmt|;
comment|/* Print the results to the system log is necessary. */
if|if
condition|(
name|log
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"-----------------------------"
literal|"    grcdump   "
literal|"-----------------------------\n"
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"Buffer length = 0x%08X bytes\n"
argument_list|,
name|index
operator|*
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|index
condition|;
name|i
operator|+=
literal|8
control|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"0x%08X - 0x%08X 0x%08X 0x%08X 0x%08X "
literal|"0x%08X 0x%08X 0x%08X 0x%08X\n"
argument_list|,
name|i
operator|*
literal|4
argument_list|,
name|buf
index|[
name|i
operator|+
literal|0
index|]
argument_list|,
name|buf
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|buf
index|[
name|i
operator|+
literal|2
index|]
argument_list|,
name|buf
index|[
name|i
operator|+
literal|3
index|]
argument_list|,
name|buf
index|[
name|i
operator|+
literal|4
index|]
argument_list|,
name|buf
index|[
name|i
operator|+
literal|5
index|]
argument_list|,
name|buf
index|[
name|i
operator|+
literal|6
index|]
argument_list|,
name|buf
index|[
name|i
operator|+
literal|7
index|]
argument_list|)
expr_stmt|;
block|}
name|BXE_PRINTF
argument_list|(
literal|"-----------------------------"
literal|"--------------"
literal|"-----------------------------\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|BXE_PRINTF
argument_list|(
literal|"No grcdump buffer allocated!\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Check that an Etherent frame is valid and prints out debug info if it's  * not.  *  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|__noinline
name|void
name|bxe_validate_rx_packet
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|uint16_t
name|comp_cons
parameter_list|,
name|union
name|eth_rx_cqe
modifier|*
name|cqe
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|fp
operator|->
name|sc
expr_stmt|;
comment|/* Check that the mbuf is sane. */
name|error
operator|=
name|m_sanity
argument_list|(
name|m
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|1
operator|||
operator|(
operator|(
name|m
operator|->
name|m_len
operator|<
name|ETHER_HDR_LEN
operator|)
operator||
operator|(
name|m
operator|->
name|m_len
operator|>
name|ETH_MAX_JUMBO_PACKET_SIZE
operator|+
name|ETH_OVREHEAD
operator|)
operator|)
condition|)
block|{
name|m_print
argument_list|(
name|m
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|bxe_dump_enet
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|bxe_dump_cqe
argument_list|(
name|fp
argument_list|,
name|comp_cons
argument_list|,
name|cqe
argument_list|)
expr_stmt|;
comment|/* Make sure the packet has a valid length. */
block|}
block|}
end_function

begin_comment
comment|/*  * Prints out Ethernet frame information from an mbuf.  *  * Partially decode an Ethernet frame to look at some important headers.  *  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|__noinline
name|void
name|bxe_dump_enet
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ether_vlan_header
modifier|*
name|eh
decl_stmt|;
name|uint16_t
name|etype
decl_stmt|;
name|int
name|e_hlen
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|;
name|struct
name|udphdr
modifier|*
name|uh
decl_stmt|;
name|struct
name|arphdr
modifier|*
name|ah
decl_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"-----------------------------"
literal|" Frame Decode "
literal|"-----------------------------\n"
argument_list|)
expr_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
expr_stmt|;
comment|/* Handle VLAN encapsulation if present. */
if|if
condition|(
name|eh
operator|->
name|evl_encap_proto
operator|==
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
condition|)
block|{
name|etype
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|evl_proto
argument_list|)
expr_stmt|;
name|e_hlen
operator|=
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
block|}
else|else
block|{
name|etype
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|evl_encap_proto
argument_list|)
expr_stmt|;
name|e_hlen
operator|=
name|ETHER_HDR_LEN
expr_stmt|;
block|}
name|BXE_PRINTF
argument_list|(
literal|"enet: dest = %6D, src = %6D, type = 0x%04X, e_hlen = %d\n"
argument_list|,
name|eh
operator|->
name|evl_dhost
argument_list|,
literal|":"
argument_list|,
name|eh
operator|->
name|evl_shost
argument_list|,
literal|":"
argument_list|,
name|etype
argument_list|,
name|e_hlen
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|etype
condition|)
block|{
case|case
name|ETHERTYPE_IP
case|:
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|m
operator|->
name|m_data
operator|+
name|e_hlen
operator|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"--ip: dest = 0x%08X , src = 0x%08X, "
literal|"ip_hlen = %d bytes, len = %d bytes, protocol = 0x%02X, "
literal|"ip_id = 0x%04X, csum = 0x%04X\n"
argument_list|,
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|)
argument_list|,
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
argument_list|,
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
argument_list|,
name|ip
operator|->
name|ip_p
argument_list|,
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_id
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_sum
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ip
operator|->
name|ip_p
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"-tcp: dest = %d, src = %d, tcp_hlen = %d "
literal|"bytes, flags = 0x%b, csum = 0x%04X\n"
argument_list|,
name|ntohs
argument_list|(
name|th
operator|->
name|th_dport
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|th
operator|->
name|th_sport
argument_list|)
argument_list|,
operator|(
name|th
operator|->
name|th_off
operator|<<
literal|2
operator|)
argument_list|,
name|th
operator|->
name|th_flags
argument_list|,
literal|"\20\10CWR\07ECE\06URG\05ACK\04PSH\03RST\02SYN\01FIN"
argument_list|,
name|ntohs
argument_list|(
name|th
operator|->
name|th_sum
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
name|uh
operator|=
operator|(
expr|struct
name|udphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"-udp: dest = %d, src = %d, udp_hlen = %d "
literal|"bytes, len = %d bytes, csum = 0x%04X\n"
argument_list|,
name|ntohs
argument_list|(
name|uh
operator|->
name|uh_dport
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|uh
operator|->
name|uh_sport
argument_list|)
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|uh
operator|->
name|uh_ulen
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|uh
operator|->
name|uh_sum
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_ICMP
case|:
name|BXE_PRINTF
argument_list|(
literal|"icmp:\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|BXE_PRINTF
argument_list|(
literal|"----: Other IP protocol.\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ETHERTYPE_IPV6
case|:
comment|/* ToDo: Add IPv6 support. */
name|BXE_PRINTF
argument_list|(
literal|"IPv6 not supported!.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ETHERTYPE_ARP
case|:
name|BXE_PRINTF
argument_list|(
literal|"-arp: "
argument_list|)
expr_stmt|;
name|ah
operator|=
operator|(
expr|struct
name|arphdr
operator|*
operator|)
operator|(
name|m
operator|->
name|m_data
operator|+
name|e_hlen
operator|)
expr_stmt|;
switch|switch
condition|(
name|ntohs
argument_list|(
name|ah
operator|->
name|ar_op
argument_list|)
condition|)
block|{
case|case
name|ARPOP_REVREQUEST
case|:
name|printf
argument_list|(
literal|"reverse ARP request\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARPOP_REVREPLY
case|:
name|printf
argument_list|(
literal|"reverse ARP reply\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARPOP_REQUEST
case|:
name|printf
argument_list|(
literal|"ARP request\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARPOP_REPLY
case|:
name|printf
argument_list|(
literal|"ARP reply\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"other ARP operation\n"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|BXE_PRINTF
argument_list|(
literal|"----: Other protocol.\n"
argument_list|)
expr_stmt|;
block|}
name|BXE_PRINTF
argument_list|(
literal|"-----------------------------"
literal|"--------------"
literal|"-----------------------------\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void bxe_dump_mbuf_data(struct mbuf *m, int len) { 	uint8_t *ptr; 	int i;  	ptr = mtod(m, uint8_t *); 	printf("\nmbuf->m_data:"); 	printf("\n0x"); 	for (i = 0; i< len; i++){ 		if (i != 0&& i % 40 == 0) 			printf("\n0x"); 		else if (i != 0&& i % 6 == 0) 			printf(" 0x"); 		printf("%02x", *ptr++); 	} 	printf("\n\n"); }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Prints out information about an mbuf.  *  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|__noinline
name|void
name|bxe_dump_mbuf
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"mbuf: null pointer\n"
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|m
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"mbuf: %p, m_len = %d, m_flags = 0x%b, "
literal|"m_data = %p\n"
argument_list|,
name|m
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|m
operator|->
name|m_flags
argument_list|,
literal|"\20\1M_EXT\2M_PKTHDR\3M_EOR\4M_RDONLY"
argument_list|,
name|m
operator|->
name|m_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"- m_pkthdr: len = %d, flags = 0x%b, "
literal|"csum_flags = %b\n"
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|m
operator|->
name|m_flags
argument_list|,
literal|"\20\12M_BCAST\13M_MCAST\14M_FRAG"
literal|"\15M_FIRSTFRAG\16M_LASTFRAG\21M_VLANTAG"
literal|"\22M_PROMISC\23M_NOFREE"
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
argument_list|,
literal|"\20\1CSUM_IP\2CSUM_TCP\3CSUM_UDP"
literal|"\5CSUM_FRAGMENT\6CSUM_TSO\11CSUM_IP_CHECKED"
literal|"\12CSUM_IP_VALID\13CSUM_DATA_VALID"
literal|"\14CSUM_PSEUDO_HDR"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"- m_ext: %p, ext_size = %d, type = "
argument_list|,
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
argument_list|,
name|m
operator|->
name|m_ext
operator|.
name|ext_size
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|m
operator|->
name|m_ext
operator|.
name|ext_type
condition|)
block|{
case|case
name|EXT_CLUSTER
case|:
name|printf
argument_list|(
literal|"EXT_CLUSTER\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXT_SFBUF
case|:
name|printf
argument_list|(
literal|"EXT_SFBUF\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXT_JUMBO9
case|:
name|printf
argument_list|(
literal|"EXT_JUMBO9\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXT_JUMBO16
case|:
name|printf
argument_list|(
literal|"EXT_JUMBO16\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXT_PACKET
case|:
name|printf
argument_list|(
literal|"EXT_PACKET\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXT_MBUF
case|:
name|printf
argument_list|(
literal|"EXT_MBUF\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXT_NET_DRV
case|:
name|printf
argument_list|(
literal|"EXT_NET_DRV\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXT_MOD_TYPE
case|:
name|printf
argument_list|(
literal|"EXT_MOD_TYPE\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXT_DISPOSABLE
case|:
name|printf
argument_list|(
literal|"EXT_DISPOSABLE\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXT_EXTREF
case|:
name|printf
argument_list|(
literal|"EXT_EXTREF\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"UNKNOWN\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Prints out information about an rx_bd.  *  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|__noinline
name|void
name|bxe_dump_rxbd
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|int
name|idx
parameter_list|,
name|struct
name|eth_rx_bd
modifier|*
name|rx_bd
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|fp
operator|->
name|sc
expr_stmt|;
comment|/* Check if index out of range. */
if|if
condition|(
name|idx
operator|>
name|MAX_RX_BD
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"fp[%02d].rx_bd[0x%04X] XX: Invalid rx_bd index!\n"
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|idx
operator|&
name|RX_BD_PER_PAGE_MASK
operator|)
operator|>=
name|USABLE_RX_BD_PER_PAGE
condition|)
block|{
comment|/* RX Chain page pointer. */
name|BXE_PRINTF
argument_list|(
literal|"fp[%02d].rx_bd[0x%04X] NP: haddr=0x%08X:%08X\n"
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|idx
argument_list|,
name|rx_bd
operator|->
name|addr_hi
argument_list|,
name|rx_bd
operator|->
name|addr_lo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BXE_PRINTF
argument_list|(
literal|"fp[%02d].rx_bd[0x%04X] RX: haddr=0x%08X:%08X\n"
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|idx
argument_list|,
name|rx_bd
operator|->
name|addr_hi
argument_list|,
name|rx_bd
operator|->
name|addr_lo
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Prints out a completion queue entry.  *  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|__noinline
name|void
name|bxe_dump_cqe
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|int
name|idx
parameter_list|,
name|union
name|eth_rx_cqe
modifier|*
name|cqe
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|fp
operator|->
name|sc
expr_stmt|;
if|if
condition|(
name|idx
operator|>
name|MAX_RCQ_ENTRIES
condition|)
block|{
comment|/* Index out of range. */
name|BXE_PRINTF
argument_list|(
literal|"fp[%02d].rx_cqe[0x%04X]: Invalid rx_cqe index!\n"
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|idx
operator|&
name|USABLE_RCQ_ENTRIES_PER_PAGE
operator|)
operator|==
name|USABLE_RCQ_ENTRIES_PER_PAGE
condition|)
block|{
comment|/* CQE next page pointer. */
name|BXE_PRINTF
argument_list|(
literal|"fp[%02d].rx_cqe[0x%04X] NP: haddr=0x%08X:%08X\n"
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|idx
argument_list|,
name|le32toh
argument_list|(
name|cqe
operator|->
name|next_page_cqe
operator|.
name|addr_hi
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|cqe
operator|->
name|next_page_cqe
operator|.
name|addr_lo
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Normal CQE. */
name|BXE_PRINTF
argument_list|(
literal|"fp[%02d].rx_cqe[0x%04X] CQ: error_flags=0x%b, "
literal|"pkt_len=0x%04X, status_flags=0x%02X, vlan=0x%04X "
literal|"rss_hash=0x%08X\n"
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|idx
argument_list|,
name|cqe
operator|->
name|fast_path_cqe
operator|.
name|type_error_flags
argument_list|,
name|BXE_ETH_FAST_PATH_RX_CQE_ERROR_FLAGS_PRINTFB
argument_list|,
name|le16toh
argument_list|(
name|cqe
operator|->
name|fast_path_cqe
operator|.
name|pkt_len
argument_list|)
argument_list|,
name|cqe
operator|->
name|fast_path_cqe
operator|.
name|status_flags
argument_list|,
name|le16toh
argument_list|(
name|cqe
operator|->
name|fast_path_cqe
operator|.
name|vlan_tag
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|cqe
operator|->
name|fast_path_cqe
operator|.
name|rss_hash_result
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Prints out information about a TX parsing BD.  *  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|__noinline
name|void
name|bxe_dump_tx_parsing_bd
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|int
name|idx
parameter_list|,
name|struct
name|eth_tx_parse_bd
modifier|*
name|p_bd
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|fp
operator|->
name|sc
expr_stmt|;
if|if
condition|(
name|idx
operator|>
name|MAX_TX_BD
condition|)
block|{
comment|/* Index out of range. */
name|BXE_PRINTF
argument_list|(
literal|"fp[%02d].tx_bd[0x%04X] XX: Invalid tx_bd index!\n"
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BXE_PRINTF
argument_list|(
literal|"fp[%02d]:tx_bd[0x%04X] PB: global_data=0x%b, "
literal|"tcp_flags=0x%b, ip_hlen=%04d, total_hlen=%04d, "
literal|"tcp_pseudo_csum=0x%04X, lso_mss=0x%04X, ip_id=0x%04X, "
literal|"tcp_send_seq=0x%08X\n"
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|idx
argument_list|,
name|p_bd
operator|->
name|global_data
argument_list|,
name|BXE_ETH_TX_PARSE_BD_GLOBAL_DATA_PRINTFB
argument_list|,
name|p_bd
operator|->
name|tcp_flags
argument_list|,
name|BXE_ETH_TX_PARSE_BD_TCP_FLAGS_PRINTFB
argument_list|,
name|p_bd
operator|->
name|ip_hlen
argument_list|,
name|p_bd
operator|->
name|total_hlen
argument_list|,
name|p_bd
operator|->
name|tcp_pseudo_csum
argument_list|,
name|p_bd
operator|->
name|lso_mss
argument_list|,
name|p_bd
operator|->
name|ip_id
argument_list|,
name|p_bd
operator|->
name|tcp_send_seq
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Prints out information about a tx_bd.  *  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|__noinline
name|void
name|bxe_dump_txbd
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|int
name|idx
parameter_list|,
name|union
name|eth_tx_bd_types
modifier|*
name|tx_bd
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|fp
operator|->
name|sc
expr_stmt|;
if|if
condition|(
name|idx
operator|>
name|MAX_TX_BD
condition|)
block|{
comment|/* Index out of range. */
name|BXE_PRINTF
argument_list|(
literal|"fp[%02d]:tx_bd[0x%04X] XX: Invalid tx_bd index!\n"
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|idx
operator|&
name|USABLE_TX_BD_PER_PAGE
operator|)
operator|==
name|USABLE_TX_BD_PER_PAGE
condition|)
block|{
comment|/* TX next page BD. */
name|BXE_PRINTF
argument_list|(
literal|"fp[%02d]:tx_bd[0x%04X] NP: haddr=0x%08X:%08X\n"
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|idx
argument_list|,
name|tx_bd
operator|->
name|next_bd
operator|.
name|addr_hi
argument_list|,
name|tx_bd
operator|->
name|next_bd
operator|.
name|addr_lo
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tx_bd
operator|->
name|start_bd
operator|.
name|bd_flags
operator|.
name|as_bitfield
operator|&
name|ETH_TX_BD_FLAGS_START_BD
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* TX start BD. */
name|BXE_PRINTF
argument_list|(
literal|"fp[%02d]:tx_bd[0x%04X] ST: haddr=0x%08X:%08X, "
literal|"nbd=%02d, nbytes=%05d, vlan/idx=0x%04X, flags=0x%b, "
literal|"gendata=0x%02X\n"
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|idx
argument_list|,
name|tx_bd
operator|->
name|start_bd
operator|.
name|addr_hi
argument_list|,
name|tx_bd
operator|->
name|start_bd
operator|.
name|addr_lo
argument_list|,
name|tx_bd
operator|->
name|start_bd
operator|.
name|nbd
argument_list|,
name|tx_bd
operator|->
name|start_bd
operator|.
name|nbytes
argument_list|,
name|tx_bd
operator|->
name|start_bd
operator|.
name|vlan
argument_list|,
name|tx_bd
operator|->
name|start_bd
operator|.
name|bd_flags
operator|.
name|as_bitfield
argument_list|,
name|BXE_ETH_TX_BD_FLAGS_PRINTFB
argument_list|,
name|tx_bd
operator|->
name|start_bd
operator|.
name|general_data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Regular TX BD. */
name|BXE_PRINTF
argument_list|(
literal|"fp[%02d]:tx_bd[0x%04X] TX: haddr=0x%08X:%08X, "
literal|"total_pkt_bytes=%05d, nbytes=%05d\n"
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|idx
argument_list|,
name|tx_bd
operator|->
name|reg_bd
operator|.
name|addr_hi
argument_list|,
name|tx_bd
operator|->
name|reg_bd
operator|.
name|addr_lo
argument_list|,
name|tx_bd
operator|->
name|reg_bd
operator|.
name|total_pkt_bytes
argument_list|,
name|tx_bd
operator|->
name|reg_bd
operator|.
name|nbytes
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Prints out the transmit chain.  *  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|__noinline
name|void
name|bxe_dump_tx_chain
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|int
name|tx_bd_prod
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|union
name|eth_tx_bd_types
modifier|*
name|tx_bd
decl_stmt|;
name|uint32_t
name|val_hi
decl_stmt|,
name|val_lo
decl_stmt|;
name|int
name|i
decl_stmt|,
name|parsing_bd
init|=
literal|0
decl_stmt|;
name|sc
operator|=
name|fp
operator|->
name|sc
expr_stmt|;
comment|/* First some info about the tx_bd chain structure. */
name|BXE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"  tx_bd chain "
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
name|val_hi
operator|=
name|U64_HI
argument_list|(
name|fp
operator|->
name|tx_dma
operator|.
name|paddr
argument_list|)
expr_stmt|;
name|val_lo
operator|=
name|U64_LO
argument_list|(
name|fp
operator|->
name|tx_dma
operator|.
name|paddr
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"0x%08X:%08X - (fp[%02d]->tx_dma.paddr) TX Chain physical address\n"
argument_list|,
name|val_hi
argument_list|,
name|val_lo
argument_list|,
name|fp
operator|->
name|index
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"page size      = 0x%08X, tx chain pages        = 0x%08X\n"
argument_list|,
operator|(
name|uint32_t
operator|)
name|BCM_PAGE_SIZE
argument_list|,
operator|(
name|uint32_t
operator|)
name|NUM_TX_PAGES
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"tx_bd per page = 0x%08X, usable tx_bd per page = 0x%08X\n"
argument_list|,
operator|(
name|uint32_t
operator|)
name|TOTAL_TX_BD_PER_PAGE
argument_list|,
operator|(
name|uint32_t
operator|)
name|USABLE_TX_BD_PER_PAGE
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"total tx_bd    = 0x%08X\n"
argument_list|,
operator|(
name|uint32_t
operator|)
name|TOTAL_TX_BD
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"-----------------------------"
literal|"  tx_bd data  "
literal|"-----------------------------\n"
argument_list|)
expr_stmt|;
comment|/* Now print out the tx_bd's themselves. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|tx_bd
operator|=
operator|&
name|fp
operator|->
name|tx_chain
index|[
name|tx_bd_prod
index|]
expr_stmt|;
if|if
condition|(
name|parsing_bd
condition|)
block|{
name|struct
name|eth_tx_parse_bd
modifier|*
name|p_bd
decl_stmt|;
name|p_bd
operator|=
operator|(
expr|struct
name|eth_tx_parse_bd
operator|*
operator|)
operator|&
name|fp
operator|->
name|tx_chain
index|[
name|tx_bd_prod
index|]
operator|.
name|parse_bd
expr_stmt|;
name|bxe_dump_tx_parsing_bd
argument_list|(
name|fp
argument_list|,
name|tx_bd_prod
argument_list|,
name|p_bd
argument_list|)
expr_stmt|;
name|parsing_bd
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|bxe_dump_txbd
argument_list|(
name|fp
argument_list|,
name|tx_bd_prod
argument_list|,
name|tx_bd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tx_bd
operator|->
name|start_bd
operator|.
name|bd_flags
operator|.
name|as_bitfield
operator|&
name|ETH_TX_BD_FLAGS_START_BD
operator|)
operator|!=
literal|0
condition|)
comment|/* 				 * There is always a parsing BD following the 				 * tx_bd with the start bit set. 				 */
name|parsing_bd
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Don't skip next page pointers. */
name|tx_bd_prod
operator|=
operator|(
operator|(
name|tx_bd_prod
operator|+
literal|1
operator|)
operator|&
name|MAX_TX_BD
operator|)
expr_stmt|;
block|}
name|BXE_PRINTF
argument_list|(
literal|"-----------------------------"
literal|"--------------"
literal|"-----------------------------\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Prints out the receive completion queue chain.  *  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|__noinline
name|void
name|bxe_dump_rx_cq_chain
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|int
name|rx_cq_prod
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|union
name|eth_rx_cqe
modifier|*
name|cqe
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|fp
operator|->
name|sc
expr_stmt|;
comment|/* First some info about the tx_bd chain structure. */
name|BXE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"   CQE  Chain   "
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"fp[%02d]->rcq_dma.paddr = 0x%jX\n"
argument_list|,
name|fp
operator|->
name|index
argument_list|,
operator|(
name|uintmax_t
operator|)
name|fp
operator|->
name|rcq_dma
operator|.
name|paddr
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"page size       = 0x%08X, cq chain pages    "
literal|"     = 0x%08X\n"
argument_list|,
operator|(
name|uint32_t
operator|)
name|BCM_PAGE_SIZE
argument_list|,
operator|(
name|uint32_t
operator|)
name|NUM_RCQ_PAGES
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"cqe_bd per page = 0x%08X, usable cqe_bd per "
literal|"page = 0x%08X\n"
argument_list|,
operator|(
name|uint32_t
operator|)
name|TOTAL_RCQ_ENTRIES_PER_PAGE
argument_list|,
operator|(
name|uint32_t
operator|)
name|USABLE_RCQ_ENTRIES_PER_PAGE
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"total cqe_bd    = 0x%08X\n"
argument_list|,
operator|(
name|uint32_t
operator|)
name|TOTAL_RCQ_ENTRIES
argument_list|)
expr_stmt|;
comment|/* Now the CQE entries themselves. */
name|BXE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"    CQE Data    "
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|cqe
operator|=
operator|(
expr|union
name|eth_rx_cqe
operator|*
operator|)
operator|&
name|fp
operator|->
name|rcq_chain
index|[
name|rx_cq_prod
index|]
expr_stmt|;
name|bxe_dump_cqe
argument_list|(
name|fp
argument_list|,
name|rx_cq_prod
argument_list|,
name|cqe
argument_list|)
expr_stmt|;
comment|/* Don't skip next page pointers. */
name|rx_cq_prod
operator|=
operator|(
operator|(
name|rx_cq_prod
operator|+
literal|1
operator|)
operator|&
name|MAX_RCQ_ENTRIES
operator|)
expr_stmt|;
block|}
name|BXE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"--------------"
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Prints out the receive chain.  *  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|__noinline
name|void
name|bxe_dump_rx_bd_chain
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|int
name|prod
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|eth_rx_bd
modifier|*
name|rx_bd
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|fp
operator|->
name|sc
expr_stmt|;
comment|/* First some info about the tx_bd chain structure. */
name|BXE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"  rx_bd  chain  "
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"----- RX_BD Chain -----\n"
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"fp[%02d]->rx_dma.paddr = 0x%jX\n"
argument_list|,
name|fp
operator|->
name|index
argument_list|,
operator|(
name|uintmax_t
operator|)
name|fp
operator|->
name|rx_dma
operator|.
name|paddr
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"page size = 0x%08X, rx chain pages = 0x%08X\n"
argument_list|,
operator|(
name|uint32_t
operator|)
name|BCM_PAGE_SIZE
argument_list|,
operator|(
name|uint32_t
operator|)
name|NUM_RX_PAGES
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"rx_bd per page = 0x%08X, usable rx_bd per page = 0x%08X\n"
argument_list|,
operator|(
name|uint32_t
operator|)
name|TOTAL_RX_BD_PER_PAGE
argument_list|,
operator|(
name|uint32_t
operator|)
name|USABLE_RX_BD_PER_PAGE
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"total rx_bd = 0x%08X\n"
argument_list|,
operator|(
name|uint32_t
operator|)
name|TOTAL_RX_BD
argument_list|)
expr_stmt|;
comment|/* Now the rx_bd entries themselves. */
name|BXE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"   rx_bd data   "
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
comment|/* Now print out the rx_bd's themselves. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|rx_bd
operator|=
operator|(
expr|struct
name|eth_rx_bd
operator|*
operator|)
operator|(
operator|&
name|fp
operator|->
name|rx_chain
index|[
name|prod
index|]
operator|)
expr_stmt|;
name|m
operator|=
name|sc
operator|->
name|fp
operator|->
name|rx_mbuf_ptr
index|[
name|prod
index|]
expr_stmt|;
name|bxe_dump_rxbd
argument_list|(
name|fp
argument_list|,
name|prod
argument_list|,
name|rx_bd
argument_list|)
expr_stmt|;
name|bxe_dump_mbuf
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* Don't skip next page pointers. */
name|prod
operator|=
operator|(
operator|(
name|prod
operator|+
literal|1
operator|)
operator|&
name|MAX_RX_BD
operator|)
expr_stmt|;
block|}
name|BXE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"--------------"
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Prints out a register dump.  *  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|__noinline
name|void
name|bxe_dump_hw_state
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"----------------------------"
literal|" Hardware State "
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0x2000
init|;
name|i
operator|<
literal|0x10000
condition|;
name|i
operator|+=
literal|0x10
control|)
name|BXE_PRINTF
argument_list|(
literal|"0x%04X: 0x%08X 0x%08X 0x%08X 0x%08X\n"
argument_list|,
name|i
argument_list|,
name|REG_RD
argument_list|(
name|sc
argument_list|,
literal|0
operator|+
name|i
argument_list|)
argument_list|,
name|REG_RD
argument_list|(
name|sc
argument_list|,
literal|0
operator|+
name|i
operator|+
literal|0x4
argument_list|)
argument_list|,
name|REG_RD
argument_list|(
name|sc
argument_list|,
literal|0
operator|+
name|i
operator|+
literal|0x8
argument_list|)
argument_list|,
name|REG_RD
argument_list|(
name|sc
argument_list|,
literal|0
operator|+
name|i
operator|+
literal|0xC
argument_list|)
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"----------------"
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Prints out the RX mbuf chain.  *  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|__noinline
name|void
name|bxe_dump_rx_mbuf_chain
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|chain_prod
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|i
decl_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"  rx mbuf data  "
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|sc
operator|->
name|fp
operator|->
name|rx_mbuf_ptr
index|[
name|chain_prod
index|]
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"rxmbuf[0x%04X]\n"
argument_list|,
name|chain_prod
argument_list|)
expr_stmt|;
name|bxe_dump_mbuf
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|chain_prod
operator|=
name|RX_BD
argument_list|(
name|NEXT_RX_BD
argument_list|(
name|chain_prod
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|BXE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"----------------"
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Prints out the mbufs in the TX mbuf chain.  *  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|__noinline
name|void
name|bxe_dump_tx_mbuf_chain
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|chain_prod
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|i
decl_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"  tx mbuf data  "
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|sc
operator|->
name|fp
operator|->
name|tx_mbuf_ptr
index|[
name|chain_prod
index|]
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"txmbuf[%d]\n"
argument_list|,
name|chain_prod
argument_list|)
expr_stmt|;
name|bxe_dump_mbuf
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|chain_prod
operator|=
name|TX_BD
argument_list|(
name|NEXT_TX_BD
argument_list|(
name|chain_prod
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|BXE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"----------------"
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Prints out the status block from host memory.  *  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|__noinline
name|void
name|bxe_dump_status_block
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|struct
name|host_def_status_block
modifier|*
name|def_sb
decl_stmt|;
name|struct
name|host_status_block
modifier|*
name|fpsb
decl_stmt|;
name|int
name|i
decl_stmt|;
name|def_sb
operator|=
name|sc
operator|->
name|def_sb
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"  Status Block  "
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
expr_stmt|;
name|fpsb
operator|=
name|fp
operator|->
name|status_block
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"     fp[%02d]     "
literal|"----------------------------\n"
argument_list|,
name|fp
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* Print the USTORM fields (HC_USTORM_SB_NUM_INDICES). */
name|BXE_PRINTF
argument_list|(
literal|"0x%08X - USTORM Flags (F/W RESERVED)\n"
argument_list|,
name|fpsb
operator|->
name|u_status_block
operator|.
name|__flags
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"      0x%02X - USTORM PCIe Function\n"
argument_list|,
name|fpsb
operator|->
name|u_status_block
operator|.
name|func
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"      0x%02X - USTORM Status Block ID\n"
argument_list|,
name|fpsb
operator|->
name|u_status_block
operator|.
name|status_block_id
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"    0x%04X - USTORM Status Block Index (Tag)\n"
argument_list|,
name|fpsb
operator|->
name|u_status_block
operator|.
name|status_block_index
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"    0x%04X - USTORM [TOE_RX_CQ_CONS]\n"
argument_list|,
name|fpsb
operator|->
name|u_status_block
operator|.
name|index_values
index|[
name|HC_INDEX_U_TOE_RX_CQ_CONS
index|]
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"    0x%04X - USTORM [ETH_RX_CQ_CONS]\n"
argument_list|,
name|fpsb
operator|->
name|u_status_block
operator|.
name|index_values
index|[
name|HC_INDEX_U_ETH_RX_CQ_CONS
index|]
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"    0x%04X - USTORM [ETH_RX_BD_CONS]\n"
argument_list|,
name|fpsb
operator|->
name|u_status_block
operator|.
name|index_values
index|[
name|HC_INDEX_U_ETH_RX_BD_CONS
index|]
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"    0x%04X - USTORM [RESERVED]\n"
argument_list|,
name|fpsb
operator|->
name|u_status_block
operator|.
name|index_values
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* Print the CSTORM fields (HC_CSTORM_SB_NUM_INDICES). */
name|BXE_PRINTF
argument_list|(
literal|"0x%08X - CSTORM Flags (F/W RESERVED)\n"
argument_list|,
name|fpsb
operator|->
name|c_status_block
operator|.
name|__flags
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"      0x%02X - CSTORM PCIe Function\n"
argument_list|,
name|fpsb
operator|->
name|c_status_block
operator|.
name|func
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"      0x%02X - CSTORM Status Block ID\n"
argument_list|,
name|fpsb
operator|->
name|c_status_block
operator|.
name|status_block_id
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"    0x%04X - CSTORM Status Block Index (Tag)\n"
argument_list|,
name|fpsb
operator|->
name|c_status_block
operator|.
name|status_block_index
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"    0x%04X - CSTORM [TOE_TX_CQ_CONS]\n"
argument_list|,
name|fpsb
operator|->
name|c_status_block
operator|.
name|index_values
index|[
name|HC_INDEX_C_TOE_TX_CQ_CONS
index|]
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"    0x%04X - CSTORM [ETH_TX_CQ_CONS]\n"
argument_list|,
name|fpsb
operator|->
name|c_status_block
operator|.
name|index_values
index|[
name|HC_INDEX_C_ETH_TX_CQ_CONS
index|]
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"    0x%04X - CSTORM [ISCSI_EQ_CONS]\n"
argument_list|,
name|fpsb
operator|->
name|c_status_block
operator|.
name|index_values
index|[
name|HC_INDEX_C_ISCSI_EQ_CONS
index|]
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"    0x%04X - CSTORM [RESERVED]\n"
argument_list|,
name|fpsb
operator|->
name|c_status_block
operator|.
name|index_values
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
name|BXE_PRINTF
argument_list|(
literal|"--------------------------"
literal|"  Def Status Block  "
literal|"--------------------------\n"
argument_list|)
expr_stmt|;
comment|/* Print attention information. */
name|BXE_PRINTF
argument_list|(
literal|"      0x%02X - Status Block ID\n"
argument_list|,
name|def_sb
operator|->
name|atten_status_block
operator|.
name|status_block_id
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"0x%08X - Attn Bits\n"
argument_list|,
name|def_sb
operator|->
name|atten_status_block
operator|.
name|attn_bits
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"0x%08X - Attn Bits Ack\n"
argument_list|,
name|def_sb
operator|->
name|atten_status_block
operator|.
name|attn_bits_ack
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"    0x%04X - Attn Block Index\n"
argument_list|,
name|le16toh
argument_list|(
name|def_sb
operator|->
name|atten_status_block
operator|.
name|attn_bits_index
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Print the USTORM fields (HC_USTORM_DEF_SB_NUM_INDICES). */
name|BXE_PRINTF
argument_list|(
literal|"      0x%02X - USTORM Status Block ID\n"
argument_list|,
name|def_sb
operator|->
name|u_def_status_block
operator|.
name|status_block_id
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"    0x%04X - USTORM Status Block Index\n"
argument_list|,
name|le16toh
argument_list|(
name|def_sb
operator|->
name|u_def_status_block
operator|.
name|status_block_index
argument_list|)
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"    0x%04X - USTORM [ETH_RDMA_RX_CQ_CONS]\n"
argument_list|,
name|le16toh
argument_list|(
name|def_sb
operator|->
name|u_def_status_block
operator|.
name|index_values
index|[
name|HC_INDEX_DEF_U_ETH_RDMA_RX_CQ_CONS
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"    0x%04X - USTORM [ETH_ISCSI_RX_CQ_CONS]\n"
argument_list|,
name|le16toh
argument_list|(
name|def_sb
operator|->
name|u_def_status_block
operator|.
name|index_values
index|[
name|HC_INDEX_DEF_U_ETH_ISCSI_RX_CQ_CONS
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"    0x%04X - USTORM [ETH_RDMA_RX_BD_CONS]\n"
argument_list|,
name|le16toh
argument_list|(
name|def_sb
operator|->
name|u_def_status_block
operator|.
name|index_values
index|[
name|HC_INDEX_DEF_U_ETH_RDMA_RX_BD_CONS
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"    0x%04X - USTORM [ETH_ISCSI_RX_BD_CONS]\n"
argument_list|,
name|le16toh
argument_list|(
name|def_sb
operator|->
name|u_def_status_block
operator|.
name|index_values
index|[
name|HC_INDEX_DEF_U_ETH_ISCSI_RX_BD_CONS
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Print the CSTORM fields (HC_CSTORM_DEF_SB_NUM_INDICES). */
name|BXE_PRINTF
argument_list|(
literal|"      0x%02X - CSTORM Status Block ID\n"
argument_list|,
name|def_sb
operator|->
name|c_def_status_block
operator|.
name|status_block_id
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"    0x%04X - CSTORM Status Block Index\n"
argument_list|,
name|le16toh
argument_list|(
name|def_sb
operator|->
name|c_def_status_block
operator|.
name|status_block_index
argument_list|)
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"    0x%04X - CSTORM [RDMA_EQ_CONS]\n"
argument_list|,
name|le16toh
argument_list|(
name|def_sb
operator|->
name|c_def_status_block
operator|.
name|index_values
index|[
name|HC_INDEX_DEF_C_RDMA_EQ_CONS
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"    0x%04X - CSTORM [RDMA_NAL_PROD]\n"
argument_list|,
name|le16toh
argument_list|(
name|def_sb
operator|->
name|c_def_status_block
operator|.
name|index_values
index|[
name|HC_INDEX_DEF_C_RDMA_NAL_PROD
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"    0x%04X - CSTORM [ETH_FW_TX_CQ_CONS]\n"
argument_list|,
name|le16toh
argument_list|(
name|def_sb
operator|->
name|c_def_status_block
operator|.
name|index_values
index|[
name|HC_INDEX_DEF_C_ETH_FW_TX_CQ_CONS
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"    0x%04X - CSTORM [ETH_SLOW_PATH]\n"
argument_list|,
name|le16toh
argument_list|(
name|def_sb
operator|->
name|c_def_status_block
operator|.
name|index_values
index|[
name|HC_INDEX_DEF_C_ETH_SLOW_PATH
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"    0x%04X - CSTORM [ETH_RDMA_CQ_CONS]\n"
argument_list|,
name|le16toh
argument_list|(
name|def_sb
operator|->
name|c_def_status_block
operator|.
name|index_values
index|[
name|HC_INDEX_DEF_C_ETH_RDMA_CQ_CONS
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"    0x%04X - CSTORM [ETH_ISCSI_CQ_CONS]\n"
argument_list|,
name|le16toh
argument_list|(
name|def_sb
operator|->
name|c_def_status_block
operator|.
name|index_values
index|[
name|HC_INDEX_DEF_C_ETH_ISCSI_CQ_CONS
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"    0x%04X - CSTORM [UNUSED]\n"
argument_list|,
name|le16toh
argument_list|(
name|def_sb
operator|->
name|c_def_status_block
operator|.
name|index_values
index|[
literal|6
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"    0x%04X - CSTORM [UNUSED]\n"
argument_list|,
name|le16toh
argument_list|(
name|def_sb
operator|->
name|c_def_status_block
operator|.
name|index_values
index|[
literal|7
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Print the TSTORM fields (HC_TSTORM_DEF_SB_NUM_INDICES). */
name|BXE_PRINTF
argument_list|(
literal|"      0x%02X - TSTORM Status Block ID\n"
argument_list|,
name|def_sb
operator|->
name|t_def_status_block
operator|.
name|status_block_id
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"    0x%04X - TSTORM Status Block Index\n"
argument_list|,
name|le16toh
argument_list|(
name|def_sb
operator|->
name|t_def_status_block
operator|.
name|status_block_index
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HC_TSTORM_DEF_SB_NUM_INDICES
condition|;
name|i
operator|++
control|)
name|BXE_PRINTF
argument_list|(
literal|"    0x%04X - TSTORM [UNUSED]\n"
argument_list|,
name|le16toh
argument_list|(
name|def_sb
operator|->
name|t_def_status_block
operator|.
name|index_values
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Print the XSTORM fields (HC_XSTORM_DEF_SB_NUM_INDICES). */
name|BXE_PRINTF
argument_list|(
literal|"      0x%02X - XSTORM Status Block ID\n"
argument_list|,
name|def_sb
operator|->
name|x_def_status_block
operator|.
name|status_block_id
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"    0x%04X - XSTORM Status Block Index\n"
argument_list|,
name|le16toh
argument_list|(
name|def_sb
operator|->
name|x_def_status_block
operator|.
name|status_block_index
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HC_XSTORM_DEF_SB_NUM_INDICES
condition|;
name|i
operator|++
control|)
name|BXE_PRINTF
argument_list|(
literal|"    0x%04X - XSTORM [UNUSED]\n"
argument_list|,
name|le16toh
argument_list|(
name|def_sb
operator|->
name|x_def_status_block
operator|.
name|index_values
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"----------------"
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Prints out the statistics block from host memory.  *  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|__noinline
name|void
name|bxe_dump_stats_block
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{  }
end_function

begin_comment
comment|/*  * Prints out a summary of the fastpath state.  *  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|__noinline
name|void
name|bxe_dump_fp_state
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|val_hi
decl_stmt|,
name|val_lo
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|fp
operator|->
name|sc
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"----------------------------"
literal|" Fastpath State "
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
name|val_hi
operator|=
name|U64_HI
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|val_lo
operator|=
name|U64_LO
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"0x%08X:%08X - (fp[%02d]) fastpath virtual address\n"
argument_list|,
name|val_hi
argument_list|,
name|val_lo
argument_list|,
name|fp
operator|->
name|index
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"                %3d - (fp[%02d]->sb_id)\n"
argument_list|,
name|fp
operator|->
name|sb_id
argument_list|,
name|fp
operator|->
name|index
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"                %3d - (fp[%02d]->cl_id)\n"
argument_list|,
name|fp
operator|->
name|cl_id
argument_list|,
name|fp
operator|->
name|index
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"         0x%08X - (fp[%02d]->state)\n"
argument_list|,
operator|(
name|uint32_t
operator|)
name|fp
operator|->
name|state
argument_list|,
name|fp
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* Receive state. */
name|BXE_PRINTF
argument_list|(
literal|"             0x%04X - (fp[%02d]->rx_bd_prod)\n"
argument_list|,
name|fp
operator|->
name|rx_bd_prod
argument_list|,
name|fp
operator|->
name|index
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"             0x%04X - (fp[%02d]->rx_bd_cons)\n"
argument_list|,
name|fp
operator|->
name|rx_bd_cons
argument_list|,
name|fp
operator|->
name|index
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"             0x%04X - (fp[%02d]->rx_cq_prod)\n"
argument_list|,
name|fp
operator|->
name|rx_cq_prod
argument_list|,
name|fp
operator|->
name|index
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"             0x%04X - (fp[%02d]->rx_cq_cons)\n"
argument_list|,
name|fp
operator|->
name|rx_cq_cons
argument_list|,
name|fp
operator|->
name|index
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"   %16lu - (fp[%02d]->rx_pkts)\n"
argument_list|,
name|fp
operator|->
name|rx_pkts
argument_list|,
name|fp
operator|->
name|index
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"         0x%08X - (fp[%02d]->rx_mbuf_alloc)\n"
argument_list|,
name|fp
operator|->
name|rx_mbuf_alloc
argument_list|,
name|fp
operator|->
name|index
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"   %16lu - (fp[%02d]->ipackets)\n"
argument_list|,
name|fp
operator|->
name|ipackets
argument_list|,
name|fp
operator|->
name|index
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"   %16lu - (fp[%02d]->rx_soft_errors)\n"
argument_list|,
name|fp
operator|->
name|rx_soft_errors
argument_list|,
name|fp
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* Transmit state. */
name|BXE_PRINTF
argument_list|(
literal|"             0x%04X - (fp[%02d]->tx_bd_used)\n"
argument_list|,
name|fp
operator|->
name|tx_bd_used
argument_list|,
name|fp
operator|->
name|index
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"             0x%04X - (fp[%02d]->tx_bd_prod)\n"
argument_list|,
name|fp
operator|->
name|tx_bd_prod
argument_list|,
name|fp
operator|->
name|index
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"             0x%04X - (fp[%02d]->tx_bd_cons)\n"
argument_list|,
name|fp
operator|->
name|tx_bd_cons
argument_list|,
name|fp
operator|->
name|index
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"             0x%04X - (fp[%02d]->tx_pkt_prod)\n"
argument_list|,
name|fp
operator|->
name|tx_pkt_prod
argument_list|,
name|fp
operator|->
name|index
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"             0x%04X - (fp[%02d]->tx_pkt_cons)\n"
argument_list|,
name|fp
operator|->
name|tx_pkt_cons
argument_list|,
name|fp
operator|->
name|index
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"   %16lu - (fp[%02d]->tx_pkts)\n"
argument_list|,
name|fp
operator|->
name|tx_pkts
argument_list|,
name|fp
operator|->
name|index
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"         0x%08X - (fp[%02d]->tx_mbuf_alloc)\n"
argument_list|,
name|fp
operator|->
name|tx_mbuf_alloc
argument_list|,
name|fp
operator|->
name|index
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"   %16lu - (fp[%02d]->opackets)\n"
argument_list|,
name|fp
operator|->
name|opackets
argument_list|,
name|fp
operator|->
name|index
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"   %16lu - (fp[%02d]->tx_soft_errors)\n"
argument_list|,
name|fp
operator|->
name|tx_soft_errors
argument_list|,
name|fp
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* TPA state. */
if|if
condition|(
name|TPA_ENABLED
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"   %16lu - (fp[%02d]->rx_tpa_pkts)\n"
argument_list|,
name|fp
operator|->
name|rx_tpa_pkts
argument_list|,
name|fp
operator|->
name|index
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"         0x%08X - (fp[%02d]->tpa_mbuf_alloc)\n"
argument_list|,
name|fp
operator|->
name|tpa_mbuf_alloc
argument_list|,
name|fp
operator|->
name|index
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"         0x%08X - (fp[%02d]->sge_mbuf_alloc)\n"
argument_list|,
name|fp
operator|->
name|sge_mbuf_alloc
argument_list|,
name|fp
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETH_MAX_AGGREGATION_QUEUES_E1
condition|;
name|i
operator|++
control|)
name|BXE_PRINTF
argument_list|(
literal|"         0x%08X - (fp[%02d]->tpa_state[%02d])\n"
argument_list|,
operator|(
name|uint32_t
operator|)
name|fp
operator|->
name|tpa_state
index|[
name|i
index|]
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETH_MAX_AGGREGATION_QUEUES_E1
condition|;
name|i
operator|++
control|)
name|BXE_PRINTF
argument_list|(
literal|"         0x%08X - (fp[%02d]->tpa_state[%02d])\n"
argument_list|,
operator|(
name|uint32_t
operator|)
name|fp
operator|->
name|tpa_state
index|[
name|i
index|]
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|BXE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"----------------"
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|__noinline
name|void
name|bxe_dump_port_state_locked
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"------------------------------"
literal|" Port State "
literal|"------------------------------\n"
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"        %2d - (port) pmf\n"
argument_list|,
name|sc
operator|->
name|port
operator|.
name|pmf
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"0x%08X - (port) link_config\n"
argument_list|,
name|sc
operator|->
name|port
operator|.
name|link_config
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"0x%08X - (port) supported\n"
argument_list|,
name|sc
operator|->
name|port
operator|.
name|supported
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"0x%08X - (port) advertising\n"
argument_list|,
name|sc
operator|->
name|port
operator|.
name|advertising
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"0x%08X - (port) port_stx\n"
argument_list|,
name|sc
operator|->
name|port
operator|.
name|port_stx
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"----------------"
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|__noinline
name|void
name|bxe_dump_link_vars_state_locked
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"---------------------------"
literal|" Link Vars State "
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|link_vars
operator|.
name|mac_type
condition|)
block|{
case|case
name|MAC_TYPE_NONE
case|:
name|BXE_PRINTF
argument_list|(
literal|"      NONE"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MAC_TYPE_EMAC
case|:
name|BXE_PRINTF
argument_list|(
literal|"      EMAC"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MAC_TYPE_BMAC
case|:
name|BXE_PRINTF
argument_list|(
literal|"      BMAC"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|BXE_PRINTF
argument_list|(
literal|"      UNKN"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" - (link_vars->mac_type)\n"
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"        %2d - (link_vars->phy_link_up)\n"
argument_list|,
name|sc
operator|->
name|link_vars
operator|.
name|phy_link_up
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"        %2d - (link_vars->link_up)\n"
argument_list|,
name|sc
operator|->
name|link_vars
operator|.
name|link_up
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"        %2d - (link_vars->duplex)\n"
argument_list|,
name|sc
operator|->
name|link_vars
operator|.
name|duplex
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"    0x%04X - (link_vars->flow_ctrl)\n"
argument_list|,
name|sc
operator|->
name|link_vars
operator|.
name|flow_ctrl
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"    0x%04X - (link_vars->line_speed)\n"
argument_list|,
name|sc
operator|->
name|link_vars
operator|.
name|line_speed
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"0x%08X - (link_vars->ieee_fc)\n"
argument_list|,
name|sc
operator|->
name|link_vars
operator|.
name|ieee_fc
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"0x%08X - (link_vars->autoneg)\n"
argument_list|,
name|sc
operator|->
name|link_vars
operator|.
name|autoneg
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"0x%08X - (link_vars->phy_flags)\n"
argument_list|,
name|sc
operator|->
name|link_vars
operator|.
name|phy_flags
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"0x%08X - (link_vars->link_status)\n"
argument_list|,
name|sc
operator|->
name|link_vars
operator|.
name|link_status
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"----------------"
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|__noinline
name|void
name|bxe_dump_link_params_state_locked
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"--------------------------"
literal|" Link Params State "
literal|"---------------------------\n"
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"        %2d - (link_params->port)\n"
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|port
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"        %2d - (link_params->loopback_mode)\n"
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|loopback_mode
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"       %3d - (link_params->phy_addr)\n"
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|phy_addr
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"    0x%04X - (link_params->req_duplex)\n"
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|req_duplex
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"    0x%04X - (link_params->req_flow_ctrl)\n"
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|req_flow_ctrl
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"    0x%04X - (link_params->req_line_speed)\n"
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|req_line_speed
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"     %5d - (link_params->ether_mtu)\n"
argument_list|,
name|sc
operator|->
name|port
operator|.
name|ether_mtu
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"0x%08X - (link_params->shmem_base) shared memory base address\n"
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|shmem_base
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"0x%08X - (link_params->speed_cap_mask)\n"
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|speed_cap_mask
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"0x%08X - (link_params->ext_phy_config)\n"
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|ext_phy_config
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"0x%08X - (link_params->switch_cfg)\n"
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|switch_cfg
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"----------------"
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Prints out a summary of the driver state.  *  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|__noinline
name|void
name|bxe_dump_driver_state
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|val_hi
decl_stmt|,
name|val_lo
decl_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"-----------------------------"
literal|" Driver State "
literal|"-----------------------------\n"
argument_list|)
expr_stmt|;
name|val_hi
operator|=
name|U64_HI
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|val_lo
operator|=
name|U64_LO
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"0x%08X:%08X - (sc) driver softc structure virtual address\n"
argument_list|,
name|val_hi
argument_list|,
name|val_lo
argument_list|)
expr_stmt|;
name|val_hi
operator|=
name|U64_HI
argument_list|(
name|sc
operator|->
name|bxe_vhandle
argument_list|)
expr_stmt|;
name|val_lo
operator|=
name|U64_LO
argument_list|(
name|sc
operator|->
name|bxe_vhandle
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"0x%08X:%08X - (sc->bxe_vhandle) PCI BAR0 virtual address\n"
argument_list|,
name|val_hi
argument_list|,
name|val_lo
argument_list|)
expr_stmt|;
name|val_hi
operator|=
name|U64_HI
argument_list|(
name|sc
operator|->
name|bxe_db_vhandle
argument_list|)
expr_stmt|;
name|val_lo
operator|=
name|U64_LO
argument_list|(
name|sc
operator|->
name|bxe_db_vhandle
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"0x%08X:%08X - (sc->bxe_db_vhandle) PCI BAR2 virtual address\n"
argument_list|,
name|val_hi
argument_list|,
name|val_lo
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"         0x%08X - (sc->num_queues) Fastpath queues\n"
argument_list|,
name|sc
operator|->
name|num_queues
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"         0x%08X - (sc->rx_lane_swap) RX XAUI lane swap\n"
argument_list|,
name|sc
operator|->
name|rx_lane_swap
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"         0x%08X - (sc->tx_lane_swap) TX XAUI lane swap\n"
argument_list|,
name|sc
operator|->
name|tx_lane_swap
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"   %16lu - (sc->debug_sim_mbuf_alloc_failed)\n"
argument_list|,
name|sc
operator|->
name|debug_sim_mbuf_alloc_failed
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"   %16lu - (sc->debug_sim_mbuf_map_failed)\n"
argument_list|,
name|sc
operator|->
name|debug_sim_mbuf_map_failed
argument_list|)
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"----------------"
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
name|bxe_dump_port_state_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_dump_link_params_state_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_dump_link_vars_state_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dump bootcode (MCP) debug buffer to the console.  *  * Returns:  *   None  */
end_comment

begin_function
specifier|static
name|__noinline
name|void
name|bxe_dump_fw
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|addr
decl_stmt|,
name|mark
decl_stmt|,
name|data
index|[
literal|9
index|]
decl_stmt|,
name|offset
decl_stmt|;
name|int
name|word
decl_stmt|;
name|addr
operator|=
name|sc
operator|->
name|common
operator|.
name|shmem_base
operator|-
literal|0x0800
operator|+
literal|4
expr_stmt|;
name|mark
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|mark
operator|=
name|MCP_REG_MCPR_SCRATCH
operator|+
operator|(
operator|(
name|mark
operator|+
literal|0x3
operator|)
operator|&
operator|~
literal|0x3
operator|)
operator|-
literal|0x08000000
expr_stmt|;
name|BXE_PRINTF
argument_list|(
literal|"---------------------------"
literal|" MCP Debug Buffer "
literal|"---------------------------\n"
argument_list|)
expr_stmt|;
comment|/* Read from "mark" to the end of the buffer. */
for|for
control|(
name|offset
operator|=
name|mark
init|;
name|offset
operator|<=
name|sc
operator|->
name|common
operator|.
name|shmem_base
condition|;
name|offset
operator|+=
operator|(
literal|0x8
operator|*
literal|4
operator|)
control|)
block|{
for|for
control|(
name|word
operator|=
literal|0
init|;
name|word
operator|<
literal|8
condition|;
name|word
operator|++
control|)
name|data
index|[
name|word
index|]
operator|=
name|htonl
argument_list|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|offset
operator|+
literal|4
operator|*
name|word
argument_list|)
argument_list|)
expr_stmt|;
name|data
index|[
literal|8
index|]
operator|=
literal|0x0
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
block|}
comment|/* Read from the start of the buffer to "mark". */
for|for
control|(
name|offset
operator|=
name|addr
operator|+
literal|4
init|;
name|offset
operator|<=
name|mark
condition|;
name|offset
operator|+=
operator|(
literal|0x8
operator|*
literal|4
operator|)
control|)
block|{
for|for
control|(
name|word
operator|=
literal|0
init|;
name|word
operator|<
literal|8
condition|;
name|word
operator|++
control|)
name|data
index|[
name|word
index|]
operator|=
name|htonl
argument_list|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|offset
operator|+
literal|4
operator|*
name|word
argument_list|)
argument_list|)
expr_stmt|;
name|data
index|[
literal|8
index|]
operator|=
literal|0x0
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
block|}
name|BXE_PRINTF
argument_list|(
literal|"----------------------------"
literal|"----------------"
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Decode firmware messages.  *  * Returns:  *   None  */
end_comment

begin_function
specifier|static
name|void
name|bxe_decode_mb_msgs
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|drv_mb_header
parameter_list|,
name|uint32_t
name|fw_mb_header
parameter_list|)
block|{
if|if
condition|(
name|drv_mb_header
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"Driver message is "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|drv_mb_header
operator|&
name|DRV_MSG_CODE_MASK
condition|)
block|{
case|case
name|DRV_MSG_CODE_LOAD_REQ
case|:
name|printf
argument_list|(
literal|"LOAD_REQ (0x%08X)"
argument_list|,
operator|(
name|uint32_t
operator|)
name|DRV_MSG_CODE_LOAD_REQ
argument_list|)
expr_stmt|;
break|break;
case|case
name|DRV_MSG_CODE_LOAD_DONE
case|:
name|printf
argument_list|(
literal|"LOAD_DONE (0x%08X)"
argument_list|,
operator|(
name|uint32_t
operator|)
name|DRV_MSG_CODE_LOAD_DONE
argument_list|)
expr_stmt|;
break|break;
case|case
name|DRV_MSG_CODE_UNLOAD_REQ_WOL_EN
case|:
name|printf
argument_list|(
literal|"UNLOAD_REQ_WOL_EN (0x%08X)"
argument_list|,
operator|(
name|uint32_t
operator|)
name|DRV_MSG_CODE_UNLOAD_REQ_WOL_EN
argument_list|)
expr_stmt|;
break|break;
case|case
name|DRV_MSG_CODE_UNLOAD_REQ_WOL_DIS
case|:
name|printf
argument_list|(
literal|"UNLOAD_REQ_WOL_DIS (0x%08X)"
argument_list|,
operator|(
name|uint32_t
operator|)
name|DRV_MSG_CODE_UNLOAD_REQ_WOL_DIS
argument_list|)
expr_stmt|;
break|break;
case|case
name|DRV_MSG_CODE_UNLOAD_REQ_WOL_MCP
case|:
name|printf
argument_list|(
literal|"UNLOADREQ_WOL_MCP (0x%08X)"
argument_list|,
operator|(
name|uint32_t
operator|)
name|DRV_MSG_CODE_UNLOAD_REQ_WOL_MCP
argument_list|)
expr_stmt|;
break|break;
case|case
name|DRV_MSG_CODE_UNLOAD_DONE
case|:
name|printf
argument_list|(
literal|"UNLOAD_DONE (0x%08X)"
argument_list|,
operator|(
name|uint32_t
operator|)
name|DRV_MSG_CODE_UNLOAD_DONE
argument_list|)
expr_stmt|;
break|break;
case|case
name|DRV_MSG_CODE_DIAG_ENTER_REQ
case|:
name|printf
argument_list|(
literal|"DIAG_ENTER_REQ (0x%08X)"
argument_list|,
operator|(
name|uint32_t
operator|)
name|DRV_MSG_CODE_DIAG_ENTER_REQ
argument_list|)
expr_stmt|;
break|break;
case|case
name|DRV_MSG_CODE_DIAG_EXIT_REQ
case|:
name|printf
argument_list|(
literal|"DIAG_EXIT_REQ (0x%08X)"
argument_list|,
operator|(
name|uint32_t
operator|)
name|DRV_MSG_CODE_DIAG_EXIT_REQ
argument_list|)
expr_stmt|;
break|break;
case|case
name|DRV_MSG_CODE_VALIDATE_KEY
case|:
name|printf
argument_list|(
literal|"CODE_VALIDITY_KEY (0x%08X)"
argument_list|,
operator|(
name|uint32_t
operator|)
name|DRV_MSG_CODE_VALIDATE_KEY
argument_list|)
expr_stmt|;
break|break;
case|case
name|DRV_MSG_CODE_GET_CURR_KEY
case|:
name|printf
argument_list|(
literal|"GET_CURR_KEY (0x%08X)"
argument_list|,
operator|(
name|uint32_t
operator|)
name|DRV_MSG_CODE_GET_CURR_KEY
argument_list|)
expr_stmt|;
break|break;
case|case
name|DRV_MSG_CODE_GET_UPGRADE_KEY
case|:
name|printf
argument_list|(
literal|"GET_UPGRADE_KEY (0x%08X)"
argument_list|,
operator|(
name|uint32_t
operator|)
name|DRV_MSG_CODE_GET_UPGRADE_KEY
argument_list|)
expr_stmt|;
break|break;
case|case
name|DRV_MSG_CODE_GET_MANUF_KEY
case|:
name|printf
argument_list|(
literal|"GET_MANUF_KEY (0x%08X)"
argument_list|,
operator|(
name|uint32_t
operator|)
name|DRV_MSG_CODE_GET_MANUF_KEY
argument_list|)
expr_stmt|;
break|break;
case|case
name|DRV_MSG_CODE_LOAD_L2B_PRAM
case|:
name|printf
argument_list|(
literal|"LOAD_L2B_PRAM (0x%08X)"
argument_list|,
operator|(
name|uint32_t
operator|)
name|DRV_MSG_CODE_LOAD_L2B_PRAM
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIOS_MSG_CODE_LIC_CHALLENGE
case|:
name|printf
argument_list|(
literal|"LIC_CHALLENGE (0x%08X)"
argument_list|,
operator|(
name|uint32_t
operator|)
name|BIOS_MSG_CODE_LIC_CHALLENGE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIOS_MSG_CODE_LIC_RESPONSE
case|:
name|printf
argument_list|(
literal|"LIC_RESPONSE (0x%08X)"
argument_list|,
operator|(
name|uint32_t
operator|)
name|BIOS_MSG_CODE_LIC_RESPONSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIOS_MSG_CODE_VIRT_MAC_PRIM
case|:
name|printf
argument_list|(
literal|"VIRT_MAC_PRIM (0x%08X)"
argument_list|,
operator|(
name|uint32_t
operator|)
name|BIOS_MSG_CODE_VIRT_MAC_PRIM
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIOS_MSG_CODE_VIRT_MAC_ISCSI
case|:
name|printf
argument_list|(
literal|"VIRT_MAC_ISCSI (0x%08X)"
argument_list|,
operator|(
name|uint32_t
operator|)
name|BIOS_MSG_CODE_VIRT_MAC_ISCSI
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Unknown command (0x%08X)!"
argument_list|,
operator|(
name|drv_mb_header
operator|&
name|DRV_MSG_CODE_MASK
operator|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" (seq = 0x%04X)\n"
argument_list|,
operator|(
name|drv_mb_header
operator|&
name|DRV_MSG_SEQ_NUMBER_MASK
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fw_mb_header
condition|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"Firmware response is "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fw_mb_header
operator|&
name|FW_MSG_CODE_MASK
condition|)
block|{
case|case
name|FW_MSG_CODE_DRV_LOAD_COMMON
case|:
name|printf
argument_list|(
literal|"DRV_LOAD_COMMON (0x%08X)"
argument_list|,
operator|(
name|uint32_t
operator|)
name|FW_MSG_CODE_DRV_LOAD_COMMON
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_MSG_CODE_DRV_LOAD_PORT
case|:
name|printf
argument_list|(
literal|"DRV_LOAD_PORT (0x%08X)"
argument_list|,
operator|(
name|uint32_t
operator|)
name|FW_MSG_CODE_DRV_LOAD_PORT
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_MSG_CODE_DRV_LOAD_FUNCTION
case|:
name|printf
argument_list|(
literal|"DRV_LOAD_FUNCTION (0x%08X)"
argument_list|,
operator|(
name|uint32_t
operator|)
name|FW_MSG_CODE_DRV_LOAD_FUNCTION
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_MSG_CODE_DRV_LOAD_REFUSED
case|:
name|printf
argument_list|(
literal|"DRV_LOAD_REFUSED (0x%08X)"
argument_list|,
operator|(
name|uint32_t
operator|)
name|FW_MSG_CODE_DRV_LOAD_REFUSED
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_MSG_CODE_DRV_LOAD_DONE
case|:
name|printf
argument_list|(
literal|"DRV_LOAD_DONE (0x%08X)"
argument_list|,
operator|(
name|uint32_t
operator|)
name|FW_MSG_CODE_DRV_LOAD_DONE
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_MSG_CODE_DRV_UNLOAD_COMMON
case|:
name|printf
argument_list|(
literal|"DRV_UNLOAD_COMMON (0x%08X)"
argument_list|,
operator|(
name|uint32_t
operator|)
name|FW_MSG_CODE_DRV_UNLOAD_COMMON
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_MSG_CODE_DRV_UNLOAD_PORT
case|:
name|printf
argument_list|(
literal|"DRV_UNLOAD_PORT (0x%08X)"
argument_list|,
operator|(
name|uint32_t
operator|)
name|FW_MSG_CODE_DRV_UNLOAD_PORT
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_MSG_CODE_DRV_UNLOAD_FUNCTION
case|:
name|printf
argument_list|(
literal|"DRV_UNLOAD_FUNCTION (0x%08X)"
argument_list|,
operator|(
name|uint32_t
operator|)
name|FW_MSG_CODE_DRV_UNLOAD_FUNCTION
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_MSG_CODE_DRV_UNLOAD_DONE
case|:
name|printf
argument_list|(
literal|"DRV_UNLOAD_DONE (0x%08X)"
argument_list|,
operator|(
name|uint32_t
operator|)
name|FW_MSG_CODE_DRV_UNLOAD_DONE
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_MSG_CODE_DIAG_ENTER_DONE
case|:
name|printf
argument_list|(
literal|"DIAG_ENTER_DONE (0x%08X)"
argument_list|,
operator|(
name|uint32_t
operator|)
name|FW_MSG_CODE_DIAG_ENTER_DONE
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_MSG_CODE_DIAG_REFUSE
case|:
name|printf
argument_list|(
literal|"DIAG_REFUSE (0x%08X)"
argument_list|,
operator|(
name|uint32_t
operator|)
name|FW_MSG_CODE_DIAG_REFUSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_MSG_CODE_DIAG_EXIT_DONE
case|:
name|printf
argument_list|(
literal|"DIAG_EXIT_DONE (0x%08X)"
argument_list|,
operator|(
name|uint32_t
operator|)
name|FW_MSG_CODE_DIAG_EXIT_DONE
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_MSG_CODE_VALIDATE_KEY_SUCCESS
case|:
name|printf
argument_list|(
literal|"VALIDATE_KEY_SUCCESS (0x%08X)"
argument_list|,
operator|(
name|uint32_t
operator|)
name|FW_MSG_CODE_VALIDATE_KEY_SUCCESS
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_MSG_CODE_VALIDATE_KEY_FAILURE
case|:
name|printf
argument_list|(
literal|"VALIDATE_KEY_FAILURE (0x%08X)"
argument_list|,
operator|(
name|uint32_t
operator|)
name|FW_MSG_CODE_VALIDATE_KEY_FAILURE
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_MSG_CODE_GET_KEY_DONE
case|:
name|printf
argument_list|(
literal|"GET_KEY_DONE (0x%08X)"
argument_list|,
operator|(
name|uint32_t
operator|)
name|FW_MSG_CODE_GET_KEY_DONE
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_MSG_CODE_NO_KEY
case|:
name|printf
argument_list|(
literal|"NO_KEY (0x%08X)"
argument_list|,
operator|(
name|uint32_t
operator|)
name|FW_MSG_CODE_NO_KEY
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"unknown value (0x%08X)!"
argument_list|,
operator|(
name|fw_mb_header
operator|&
name|FW_MSG_CODE_MASK
operator|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" (seq = 0x%04X)\n"
argument_list|,
operator|(
name|fw_mb_header
operator|&
name|FW_MSG_SEQ_NUMBER_MASK
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Prints a text string for the ramrod command.  *  * Returns:  *   None  */
end_comment

begin_function
specifier|static
name|void
name|bxe_decode_ramrod_cmd
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|command
parameter_list|)
block|{
name|BXE_PRINTF
argument_list|(
literal|"Ramrod command = "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|RAMROD_CMD_ID_ETH_PORT_SETUP
case|:
name|printf
argument_list|(
literal|"ETH_PORT_SETUP\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAMROD_CMD_ID_ETH_CLIENT_SETUP
case|:
name|printf
argument_list|(
literal|"ETH_CLIENT_SETUP\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAMROD_CMD_ID_ETH_STAT_QUERY
case|:
name|printf
argument_list|(
literal|"ETH_STAT_QUERY\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAMROD_CMD_ID_ETH_UPDATE
case|:
name|printf
argument_list|(
literal|"ETH_UPDATE\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAMROD_CMD_ID_ETH_HALT
case|:
name|printf
argument_list|(
literal|"ETH_HALT\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAMROD_CMD_ID_ETH_SET_MAC
case|:
name|printf
argument_list|(
literal|"ETH_SET_MAC\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAMROD_CMD_ID_ETH_CFC_DEL
case|:
name|printf
argument_list|(
literal|"ETH_CFC_DEL\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAMROD_CMD_ID_ETH_PORT_DEL
case|:
name|printf
argument_list|(
literal|"ETH_PORT_DEL\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|RAMROD_CMD_ID_ETH_FORWARD_SETUP
case|:
name|printf
argument_list|(
literal|"ETH_FORWARD_SETUP\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Unknown ramrod command!\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Prints out driver information and forces a kernel breakpoint.  *  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_breakpoint
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
literal|0
index|]
expr_stmt|;
comment|/* Unreachable code to silence the compiler about unused functions. */
if|if
condition|(
literal|0
condition|)
block|{
name|bxe_reg_read16
argument_list|(
name|sc
argument_list|,
name|PCICFG_OFFSET
argument_list|)
expr_stmt|;
name|bxe_dump_tx_mbuf_chain
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|USABLE_TX_BD
argument_list|)
expr_stmt|;
name|bxe_dump_rx_mbuf_chain
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|USABLE_RX_BD
argument_list|)
expr_stmt|;
name|bxe_dump_tx_chain
argument_list|(
name|fp
argument_list|,
literal|0
argument_list|,
name|USABLE_TX_BD
argument_list|)
expr_stmt|;
name|bxe_dump_rx_cq_chain
argument_list|(
name|fp
argument_list|,
literal|0
argument_list|,
name|USABLE_RCQ_ENTRIES
argument_list|)
expr_stmt|;
name|bxe_dump_rx_bd_chain
argument_list|(
name|fp
argument_list|,
literal|0
argument_list|,
name|USABLE_RX_BD
argument_list|)
expr_stmt|;
name|bxe_dump_status_block
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_dump_stats_block
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_dump_fp_state
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|bxe_dump_driver_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_dump_hw_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_dump_fw
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Do some device sanity checking.  Run it twice in case 	 * the hardware is still running so we can identify any 	 * transient conditions. 	 */
name|bxe_idle_chk
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_idle_chk
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_dump_driver_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
name|bxe_dump_fp_state
argument_list|(
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bxe_dump_status_block
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_dump_fw
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Call the OS debugger. */
name|breakpoint
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

