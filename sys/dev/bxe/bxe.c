begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2007-2014 QLogic Corporation. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS'  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|BXE_DRIVER_VERSION
value|"1.78.90"
end_define

begin_include
include|#
directive|include
file|"bxe.h"
end_include

begin_include
include|#
directive|include
file|"ecore_sp.h"
end_include

begin_include
include|#
directive|include
file|"ecore_init.h"
end_include

begin_include
include|#
directive|include
file|"ecore_init_ops.h"
end_include

begin_include
include|#
directive|include
file|"57710_int_offsets.h"
end_include

begin_include
include|#
directive|include
file|"57711_int_offsets.h"
end_include

begin_include
include|#
directive|include
file|"57712_int_offsets.h"
end_include

begin_comment
comment|/*  * CTLTYPE_U64 and sysctl_handle_64 were added in r217616. Define these  * explicitly here for older kernels that don't include this changeset.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CTLTYPE_U64
end_ifndef

begin_define
define|#
directive|define
name|CTLTYPE_U64
value|CTLTYPE_QUAD
end_define

begin_define
define|#
directive|define
name|sysctl_handle_64
value|sysctl_handle_quad
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * CSUM_TCP_IPV6 and CSUM_UDP_IPV6 were added in r236170. Define these  * here as zero(0) for older kernels that don't include this changeset  * thereby masking the functionality.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CSUM_TCP_IPV6
end_ifndef

begin_define
define|#
directive|define
name|CSUM_TCP_IPV6
value|0
end_define

begin_define
define|#
directive|define
name|CSUM_UDP_IPV6
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * pci_find_cap was added in r219865. Re-define this at pci_find_extcap  * for older kernels that don't include this changeset.  */
end_comment

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|900035
end_if

begin_define
define|#
directive|define
name|pci_find_cap
value|pci_find_extcap
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|BXE_DEF_SB_ATT_IDX
value|0x0001
end_define

begin_define
define|#
directive|define
name|BXE_DEF_SB_IDX
value|0x0002
end_define

begin_comment
comment|/*  * FLR Support - bxe_pf_flr_clnup() is called during nic_load in the per  * function HW initialization.  */
end_comment

begin_define
define|#
directive|define
name|FLR_WAIT_USEC
value|10000
end_define

begin_comment
comment|/* 10 msecs */
end_comment

begin_define
define|#
directive|define
name|FLR_WAIT_INTERVAL
value|50
end_define

begin_comment
comment|/* usecs */
end_comment

begin_define
define|#
directive|define
name|FLR_POLL_CNT
value|(FLR_WAIT_USEC / FLR_WAIT_INTERVAL)
end_define

begin_comment
comment|/* 200 */
end_comment

begin_struct
struct|struct
name|pbf_pN_buf_regs
block|{
name|int
name|pN
decl_stmt|;
name|uint32_t
name|init_crd
decl_stmt|;
name|uint32_t
name|crd
decl_stmt|;
name|uint32_t
name|crd_freed
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|pbf_pN_cmd_regs
block|{
name|int
name|pN
decl_stmt|;
name|uint32_t
name|lines_occup
decl_stmt|;
name|uint32_t
name|lines_freed
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * PCI Device ID Table used by bxe_probe().  */
end_comment

begin_define
define|#
directive|define
name|BXE_DEVDESC_MAX
value|64
end_define

begin_decl_stmt
specifier|static
name|struct
name|bxe_device_type
name|bxe_devs
index|[]
init|=
block|{
block|{
name|BRCM_VENDORID
block|,
name|CHIP_NUM_57710
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|"QLogic NetXtreme II BCM57710 10GbE"
block|}
block|,
block|{
name|BRCM_VENDORID
block|,
name|CHIP_NUM_57711
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|"QLogic NetXtreme II BCM57711 10GbE"
block|}
block|,
block|{
name|BRCM_VENDORID
block|,
name|CHIP_NUM_57711E
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|"QLogic NetXtreme II BCM57711E 10GbE"
block|}
block|,
block|{
name|BRCM_VENDORID
block|,
name|CHIP_NUM_57712
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|"QLogic NetXtreme II BCM57712 10GbE"
block|}
block|,
block|{
name|BRCM_VENDORID
block|,
name|CHIP_NUM_57712_MF
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|"QLogic NetXtreme II BCM57712 MF 10GbE"
block|}
block|,
block|{
name|BRCM_VENDORID
block|,
name|CHIP_NUM_57800
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|"QLogic NetXtreme II BCM57800 10GbE"
block|}
block|,
block|{
name|BRCM_VENDORID
block|,
name|CHIP_NUM_57800_MF
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|"QLogic NetXtreme II BCM57800 MF 10GbE"
block|}
block|,
block|{
name|BRCM_VENDORID
block|,
name|CHIP_NUM_57810
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|"QLogic NetXtreme II BCM57810 10GbE"
block|}
block|,
block|{
name|BRCM_VENDORID
block|,
name|CHIP_NUM_57810_MF
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|"QLogic NetXtreme II BCM57810 MF 10GbE"
block|}
block|,
block|{
name|BRCM_VENDORID
block|,
name|CHIP_NUM_57811
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|"QLogic NetXtreme II BCM57811 10GbE"
block|}
block|,
block|{
name|BRCM_VENDORID
block|,
name|CHIP_NUM_57811_MF
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|"QLogic NetXtreme II BCM57811 MF 10GbE"
block|}
block|,
block|{
name|BRCM_VENDORID
block|,
name|CHIP_NUM_57840_4_10
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|"QLogic NetXtreme II BCM57840 4x10GbE"
block|}
block|,
block|{
name|QLOGIC_VENDORID
block|,
name|CHIP_NUM_57840_4_10
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|"QLogic NetXtreme II BCM57840 4x10GbE"
block|}
block|,
block|{
name|BRCM_VENDORID
block|,
name|CHIP_NUM_57840_2_20
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|"QLogic NetXtreme II BCM57840 2x20GbE"
block|}
block|,
block|{
name|BRCM_VENDORID
block|,
name|CHIP_NUM_57840_MF
block|,
name|PCI_ANY_ID
block|,
name|PCI_ANY_ID
block|,
literal|"QLogic NetXtreme II BCM57840 MF 10GbE"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MALLOC_DECLARE
argument_list|(
name|M_BXE_ILT
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_BXE_ILT
argument_list|,
literal|"bxe_ilt"
argument_list|,
literal|"bxe ILT pointer"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * FreeBSD device entry points.  */
end_comment

begin_function_decl
specifier|static
name|int
name|bxe_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_shutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * FreeBSD KLD module/device interface event handler method.  */
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|bxe_methods
index|[]
init|=
block|{
comment|/* Device interface (device_if.h) */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|bxe_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|bxe_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|bxe_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bxe_shutdown
argument_list|)
block|,
comment|/* Bus interface (bus_if.h) */
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|bus_generic_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_driver_added
argument_list|,
name|bus_generic_driver_added
argument_list|)
block|,
name|KOBJMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * FreeBSD KLD Module data declaration  */
end_comment

begin_decl_stmt
specifier|static
name|driver_t
name|bxe_driver
init|=
block|{
literal|"bxe"
block|,
comment|/* module name */
name|bxe_methods
block|,
comment|/* event handler */
expr|sizeof
operator|(
expr|struct
name|bxe_softc
operator|)
comment|/* extra data */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * FreeBSD dev class is needed to manage dev instances and  * to associate with a bus type  */
end_comment

begin_decl_stmt
specifier|static
name|devclass_t
name|bxe_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|bxe
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|bxe
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|bxe
argument_list|,
name|pci
argument_list|,
name|bxe_driver
argument_list|,
name|bxe_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* resources needed for unloading a previously loaded device */
end_comment

begin_define
define|#
directive|define
name|BXE_PREV_WAIT_NEEDED
value|1
end_define

begin_decl_stmt
name|struct
name|mtx
name|bxe_prev_mtx
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MTX_SYSINIT
argument_list|(
name|bxe_prev_mtx
argument_list|,
operator|&
name|bxe_prev_mtx
argument_list|,
literal|"bxe_prev_lock"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|bxe_prev_list_node
block|{
name|LIST_ENTRY
argument_list|(
argument|bxe_prev_list_node
argument_list|)
name|node
expr_stmt|;
name|uint8_t
name|bus
decl_stmt|;
name|uint8_t
name|slot
decl_stmt|;
name|uint8_t
name|path
decl_stmt|;
name|uint8_t
name|aer
decl_stmt|;
comment|/* XXX automatic error recovery */
name|uint8_t
name|undi
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|bxe_prev_list_node
argument_list|)
name|bxe_prev_list
operator|=
name|LIST_HEAD_INITIALIZER
argument_list|(
name|bxe_prev_list
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|load_count
index|[
literal|2
index|]
index|[
literal|3
index|]
init|=
block|{
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* per-path: 0-common, 1-port0, 2-port1 */
end_comment

begin_comment
comment|/* Tunable device values... */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|bxe
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"bxe driver parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Debug */
end_comment

begin_decl_stmt
name|unsigned
name|long
name|bxe_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_hw_bxe
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|bxe_debug
argument_list|,
literal|0
argument_list|,
literal|"Debug logging mode"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Interrupt Mode: 0 (IRQ), 1 (MSI/IRQ), and 2 (MSI-X/MSI/IRQ) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bxe_interrupt_mode
init|=
name|INTR_MODE_MSIX
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_bxe
argument_list|,
name|OID_AUTO
argument_list|,
name|interrupt_mode
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|bxe_interrupt_mode
argument_list|,
literal|0
argument_list|,
literal|"Interrupt (MSI-X/MSI/INTx) mode"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Number of Queues: 0 (Auto) or 1 to 16 (fixed queue number) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bxe_queue_count
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_bxe
argument_list|,
name|OID_AUTO
argument_list|,
name|queue_count
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|bxe_queue_count
argument_list|,
literal|0
argument_list|,
literal|"Multi-Queue queue count"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* max number of buffers per queue (default RX_BD_USABLE) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bxe_max_rx_bufs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_bxe
argument_list|,
name|OID_AUTO
argument_list|,
name|max_rx_bufs
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|bxe_max_rx_bufs
argument_list|,
literal|0
argument_list|,
literal|"Maximum Number of Rx Buffers Per Queue"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Host interrupt coalescing RX tick timer (usecs) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bxe_hc_rx_ticks
init|=
literal|25
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_bxe
argument_list|,
name|OID_AUTO
argument_list|,
name|hc_rx_ticks
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|bxe_hc_rx_ticks
argument_list|,
literal|0
argument_list|,
literal|"Host Coalescing Rx ticks"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Host interrupt coalescing TX tick timer (usecs) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bxe_hc_tx_ticks
init|=
literal|50
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_bxe
argument_list|,
name|OID_AUTO
argument_list|,
name|hc_tx_ticks
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|bxe_hc_tx_ticks
argument_list|,
literal|0
argument_list|,
literal|"Host Coalescing Tx ticks"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Maximum number of Rx packets to process at a time */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bxe_rx_budget
init|=
literal|0xffffffff
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_bxe
argument_list|,
name|OID_AUTO
argument_list|,
name|rx_budget
argument_list|,
name|CTLFLAG_TUN
argument_list|,
operator|&
name|bxe_rx_budget
argument_list|,
literal|0
argument_list|,
literal|"Rx processing budget"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Maximum LRO aggregation size */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bxe_max_aggregation_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_bxe
argument_list|,
name|OID_AUTO
argument_list|,
name|max_aggregation_size
argument_list|,
name|CTLFLAG_TUN
argument_list|,
operator|&
name|bxe_max_aggregation_size
argument_list|,
literal|0
argument_list|,
literal|"max aggregation size"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* PCI MRRS: -1 (Auto), 0 (128B), 1 (256B), 2 (512B), 3 (1KB) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bxe_mrrs
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_bxe
argument_list|,
name|OID_AUTO
argument_list|,
name|mrrs
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|bxe_mrrs
argument_list|,
literal|0
argument_list|,
literal|"PCIe maximum read request size"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* AutoGrEEEn: 0 (hardware default), 1 (force on), 2 (force off) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bxe_autogreeen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_bxe
argument_list|,
name|OID_AUTO
argument_list|,
name|autogreeen
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|bxe_autogreeen
argument_list|,
literal|0
argument_list|,
literal|"AutoGrEEEn support"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 4-tuple RSS support for UDP: 0 (disabled), 1 (enabled) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bxe_udp_rss
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_bxe
argument_list|,
name|OID_AUTO
argument_list|,
name|udp_rss
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|bxe_udp_rss
argument_list|,
literal|0
argument_list|,
literal|"UDP RSS support"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|STAT_NAME_LEN
value|32
end_define

begin_comment
comment|/* no stat names below can be longer than this */
end_comment

begin_define
define|#
directive|define
name|STATS_OFFSET32
parameter_list|(
name|stat_name
parameter_list|)
define|\
value|(offsetof(struct bxe_eth_stats, stat_name) / 4)
end_define

begin_define
define|#
directive|define
name|Q_STATS_OFFSET32
parameter_list|(
name|stat_name
parameter_list|)
define|\
value|(offsetof(struct bxe_eth_q_stats, stat_name) / 4)
end_define

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|uint32_t
name|offset
decl_stmt|;
name|uint32_t
name|size
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
define|#
directive|define
name|STATS_FLAGS_PORT
value|1
define|#
directive|define
name|STATS_FLAGS_FUNC
value|2
comment|/* MF only cares about function stats */
define|#
directive|define
name|STATS_FLAGS_BOTH
value|(STATS_FLAGS_FUNC | STATS_FLAGS_PORT)
name|char
name|string
index|[
name|STAT_NAME_LEN
index|]
decl_stmt|;
block|}
name|bxe_eth_stats_arr
index|[]
init|=
block|{
block|{
name|STATS_OFFSET32
argument_list|(
name|total_bytes_received_hi
argument_list|)
block|,
literal|8
block|,
name|STATS_FLAGS_BOTH
block|,
literal|"rx_bytes"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|error_bytes_received_hi
argument_list|)
block|,
literal|8
block|,
name|STATS_FLAGS_BOTH
block|,
literal|"rx_error_bytes"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|total_unicast_packets_received_hi
argument_list|)
block|,
literal|8
block|,
name|STATS_FLAGS_BOTH
block|,
literal|"rx_ucast_packets"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|total_multicast_packets_received_hi
argument_list|)
block|,
literal|8
block|,
name|STATS_FLAGS_BOTH
block|,
literal|"rx_mcast_packets"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|total_broadcast_packets_received_hi
argument_list|)
block|,
literal|8
block|,
name|STATS_FLAGS_BOTH
block|,
literal|"rx_bcast_packets"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|rx_stat_dot3statsfcserrors_hi
argument_list|)
block|,
literal|8
block|,
name|STATS_FLAGS_PORT
block|,
literal|"rx_crc_errors"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|rx_stat_dot3statsalignmenterrors_hi
argument_list|)
block|,
literal|8
block|,
name|STATS_FLAGS_PORT
block|,
literal|"rx_align_errors"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|rx_stat_etherstatsundersizepkts_hi
argument_list|)
block|,
literal|8
block|,
name|STATS_FLAGS_PORT
block|,
literal|"rx_undersize_packets"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|etherstatsoverrsizepkts_hi
argument_list|)
block|,
literal|8
block|,
name|STATS_FLAGS_PORT
block|,
literal|"rx_oversize_packets"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|rx_stat_etherstatsfragments_hi
argument_list|)
block|,
literal|8
block|,
name|STATS_FLAGS_PORT
block|,
literal|"rx_fragments"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|rx_stat_etherstatsjabbers_hi
argument_list|)
block|,
literal|8
block|,
name|STATS_FLAGS_PORT
block|,
literal|"rx_jabbers"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|no_buff_discard_hi
argument_list|)
block|,
literal|8
block|,
name|STATS_FLAGS_BOTH
block|,
literal|"rx_discards"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|mac_filter_discard
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_PORT
block|,
literal|"rx_filtered_packets"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|mf_tag_discard
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_PORT
block|,
literal|"rx_mf_tag_discard"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|pfc_frames_received_hi
argument_list|)
block|,
literal|8
block|,
name|STATS_FLAGS_PORT
block|,
literal|"pfc_frames_received"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|pfc_frames_sent_hi
argument_list|)
block|,
literal|8
block|,
name|STATS_FLAGS_PORT
block|,
literal|"pfc_frames_sent"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|brb_drop_hi
argument_list|)
block|,
literal|8
block|,
name|STATS_FLAGS_PORT
block|,
literal|"rx_brb_discard"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|brb_truncate_hi
argument_list|)
block|,
literal|8
block|,
name|STATS_FLAGS_PORT
block|,
literal|"rx_brb_truncate"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|pause_frames_received_hi
argument_list|)
block|,
literal|8
block|,
name|STATS_FLAGS_PORT
block|,
literal|"rx_pause_frames"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|rx_stat_maccontrolframesreceived_hi
argument_list|)
block|,
literal|8
block|,
name|STATS_FLAGS_PORT
block|,
literal|"rx_mac_ctrl_frames"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|nig_timer_max
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_PORT
block|,
literal|"rx_constant_pause_events"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|total_bytes_transmitted_hi
argument_list|)
block|,
literal|8
block|,
name|STATS_FLAGS_BOTH
block|,
literal|"tx_bytes"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|tx_stat_ifhcoutbadoctets_hi
argument_list|)
block|,
literal|8
block|,
name|STATS_FLAGS_PORT
block|,
literal|"tx_error_bytes"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|total_unicast_packets_transmitted_hi
argument_list|)
block|,
literal|8
block|,
name|STATS_FLAGS_BOTH
block|,
literal|"tx_ucast_packets"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|total_multicast_packets_transmitted_hi
argument_list|)
block|,
literal|8
block|,
name|STATS_FLAGS_BOTH
block|,
literal|"tx_mcast_packets"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|total_broadcast_packets_transmitted_hi
argument_list|)
block|,
literal|8
block|,
name|STATS_FLAGS_BOTH
block|,
literal|"tx_bcast_packets"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|tx_stat_dot3statsinternalmactransmiterrors_hi
argument_list|)
block|,
literal|8
block|,
name|STATS_FLAGS_PORT
block|,
literal|"tx_mac_errors"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|rx_stat_dot3statscarriersenseerrors_hi
argument_list|)
block|,
literal|8
block|,
name|STATS_FLAGS_PORT
block|,
literal|"tx_carrier_errors"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|tx_stat_dot3statssinglecollisionframes_hi
argument_list|)
block|,
literal|8
block|,
name|STATS_FLAGS_PORT
block|,
literal|"tx_single_collisions"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|tx_stat_dot3statsmultiplecollisionframes_hi
argument_list|)
block|,
literal|8
block|,
name|STATS_FLAGS_PORT
block|,
literal|"tx_multi_collisions"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|tx_stat_dot3statsdeferredtransmissions_hi
argument_list|)
block|,
literal|8
block|,
name|STATS_FLAGS_PORT
block|,
literal|"tx_deferred"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|tx_stat_dot3statsexcessivecollisions_hi
argument_list|)
block|,
literal|8
block|,
name|STATS_FLAGS_PORT
block|,
literal|"tx_excess_collisions"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|tx_stat_dot3statslatecollisions_hi
argument_list|)
block|,
literal|8
block|,
name|STATS_FLAGS_PORT
block|,
literal|"tx_late_collisions"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|tx_stat_etherstatscollisions_hi
argument_list|)
block|,
literal|8
block|,
name|STATS_FLAGS_PORT
block|,
literal|"tx_total_collisions"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|tx_stat_etherstatspkts64octets_hi
argument_list|)
block|,
literal|8
block|,
name|STATS_FLAGS_PORT
block|,
literal|"tx_64_byte_packets"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|tx_stat_etherstatspkts65octetsto127octets_hi
argument_list|)
block|,
literal|8
block|,
name|STATS_FLAGS_PORT
block|,
literal|"tx_65_to_127_byte_packets"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|tx_stat_etherstatspkts128octetsto255octets_hi
argument_list|)
block|,
literal|8
block|,
name|STATS_FLAGS_PORT
block|,
literal|"tx_128_to_255_byte_packets"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|tx_stat_etherstatspkts256octetsto511octets_hi
argument_list|)
block|,
literal|8
block|,
name|STATS_FLAGS_PORT
block|,
literal|"tx_256_to_511_byte_packets"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|tx_stat_etherstatspkts512octetsto1023octets_hi
argument_list|)
block|,
literal|8
block|,
name|STATS_FLAGS_PORT
block|,
literal|"tx_512_to_1023_byte_packets"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|etherstatspkts1024octetsto1522octets_hi
argument_list|)
block|,
literal|8
block|,
name|STATS_FLAGS_PORT
block|,
literal|"tx_1024_to_1522_byte_packets"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|etherstatspktsover1522octets_hi
argument_list|)
block|,
literal|8
block|,
name|STATS_FLAGS_PORT
block|,
literal|"tx_1523_to_9022_byte_packets"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|pause_frames_sent_hi
argument_list|)
block|,
literal|8
block|,
name|STATS_FLAGS_PORT
block|,
literal|"tx_pause_frames"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|total_tpa_aggregations_hi
argument_list|)
block|,
literal|8
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"tpa_aggregations"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|total_tpa_aggregated_frames_hi
argument_list|)
block|,
literal|8
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"tpa_aggregated_frames"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|total_tpa_bytes_hi
argument_list|)
block|,
literal|8
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"tpa_bytes"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|eee_tx_lpi
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_PORT
block|,
literal|"eee_tx_lpi"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|rx_calls
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"rx_calls"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|rx_pkts
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"rx_pkts"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|rx_tpa_pkts
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"rx_tpa_pkts"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|rx_erroneous_jumbo_sge_pkts
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"rx_erroneous_jumbo_sge_pkts"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|rx_bxe_service_rxsgl
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"rx_bxe_service_rxsgl"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|rx_jumbo_sge_pkts
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"rx_jumbo_sge_pkts"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|rx_soft_errors
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"rx_soft_errors"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|rx_hw_csum_errors
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"rx_hw_csum_errors"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|rx_ofld_frames_csum_ip
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"rx_ofld_frames_csum_ip"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|rx_ofld_frames_csum_tcp_udp
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"rx_ofld_frames_csum_tcp_udp"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|rx_budget_reached
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"rx_budget_reached"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|tx_pkts
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"tx_pkts"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|tx_soft_errors
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"tx_soft_errors"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|tx_ofld_frames_csum_ip
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"tx_ofld_frames_csum_ip"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|tx_ofld_frames_csum_tcp
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"tx_ofld_frames_csum_tcp"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|tx_ofld_frames_csum_udp
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"tx_ofld_frames_csum_udp"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|tx_ofld_frames_lso
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"tx_ofld_frames_lso"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|tx_ofld_frames_lso_hdr_splits
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"tx_ofld_frames_lso_hdr_splits"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|tx_encap_failures
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"tx_encap_failures"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|tx_hw_queue_full
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"tx_hw_queue_full"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|tx_hw_max_queue_depth
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"tx_hw_max_queue_depth"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|tx_dma_mapping_failure
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"tx_dma_mapping_failure"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|tx_max_drbr_queue_depth
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"tx_max_drbr_queue_depth"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|tx_window_violation_std
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"tx_window_violation_std"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|tx_window_violation_tso
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"tx_window_violation_tso"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|tx_chain_lost_mbuf
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"tx_chain_lost_mbuf"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|tx_frames_deferred
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"tx_frames_deferred"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|tx_queue_xoff
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"tx_queue_xoff"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|mbuf_defrag_attempts
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"mbuf_defrag_attempts"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|mbuf_defrag_failures
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"mbuf_defrag_failures"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|mbuf_rx_bd_alloc_failed
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"mbuf_rx_bd_alloc_failed"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|mbuf_rx_bd_mapping_failed
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"mbuf_rx_bd_mapping_failed"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|mbuf_rx_tpa_alloc_failed
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"mbuf_rx_tpa_alloc_failed"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|mbuf_rx_tpa_mapping_failed
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"mbuf_rx_tpa_mapping_failed"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|mbuf_rx_sge_alloc_failed
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"mbuf_rx_sge_alloc_failed"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|mbuf_rx_sge_mapping_failed
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"mbuf_rx_sge_mapping_failed"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|mbuf_alloc_tx
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"mbuf_alloc_tx"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|mbuf_alloc_rx
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"mbuf_alloc_rx"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|mbuf_alloc_sge
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"mbuf_alloc_sge"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|mbuf_alloc_tpa
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"mbuf_alloc_tpa"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|tx_queue_full_return
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"tx_queue_full_return"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|bxe_tx_mq_sc_state_failures
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"bxe_tx_mq_sc_state_failures"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|tx_request_link_down_failures
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"tx_request_link_down_failures"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|bd_avail_too_less_failures
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"bd_avail_too_less_failures"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|tx_mq_not_empty
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"tx_mq_not_empty"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|nsegs_path1_errors
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"nsegs_path1_errors"
block|}
block|,
block|{
name|STATS_OFFSET32
argument_list|(
name|nsegs_path2_errors
argument_list|)
block|,
literal|4
block|,
name|STATS_FLAGS_FUNC
block|,
literal|"nsegs_path2_errors"
block|}
block|}
struct|;
end_struct

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|uint32_t
name|offset
decl_stmt|;
name|uint32_t
name|size
decl_stmt|;
name|char
name|string
index|[
name|STAT_NAME_LEN
index|]
decl_stmt|;
block|}
name|bxe_eth_q_stats_arr
index|[]
init|=
block|{
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|total_bytes_received_hi
argument_list|)
block|,
literal|8
block|,
literal|"rx_bytes"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|total_unicast_packets_received_hi
argument_list|)
block|,
literal|8
block|,
literal|"rx_ucast_packets"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|total_multicast_packets_received_hi
argument_list|)
block|,
literal|8
block|,
literal|"rx_mcast_packets"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|total_broadcast_packets_received_hi
argument_list|)
block|,
literal|8
block|,
literal|"rx_bcast_packets"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|no_buff_discard_hi
argument_list|)
block|,
literal|8
block|,
literal|"rx_discards"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|total_bytes_transmitted_hi
argument_list|)
block|,
literal|8
block|,
literal|"tx_bytes"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|total_unicast_packets_transmitted_hi
argument_list|)
block|,
literal|8
block|,
literal|"tx_ucast_packets"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|total_multicast_packets_transmitted_hi
argument_list|)
block|,
literal|8
block|,
literal|"tx_mcast_packets"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|total_broadcast_packets_transmitted_hi
argument_list|)
block|,
literal|8
block|,
literal|"tx_bcast_packets"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|total_tpa_aggregations_hi
argument_list|)
block|,
literal|8
block|,
literal|"tpa_aggregations"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|total_tpa_aggregated_frames_hi
argument_list|)
block|,
literal|8
block|,
literal|"tpa_aggregated_frames"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|total_tpa_bytes_hi
argument_list|)
block|,
literal|8
block|,
literal|"tpa_bytes"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|rx_calls
argument_list|)
block|,
literal|4
block|,
literal|"rx_calls"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|rx_pkts
argument_list|)
block|,
literal|4
block|,
literal|"rx_pkts"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|rx_tpa_pkts
argument_list|)
block|,
literal|4
block|,
literal|"rx_tpa_pkts"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|rx_erroneous_jumbo_sge_pkts
argument_list|)
block|,
literal|4
block|,
literal|"rx_erroneous_jumbo_sge_pkts"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|rx_bxe_service_rxsgl
argument_list|)
block|,
literal|4
block|,
literal|"rx_bxe_service_rxsgl"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|rx_jumbo_sge_pkts
argument_list|)
block|,
literal|4
block|,
literal|"rx_jumbo_sge_pkts"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|rx_soft_errors
argument_list|)
block|,
literal|4
block|,
literal|"rx_soft_errors"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|rx_hw_csum_errors
argument_list|)
block|,
literal|4
block|,
literal|"rx_hw_csum_errors"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|rx_ofld_frames_csum_ip
argument_list|)
block|,
literal|4
block|,
literal|"rx_ofld_frames_csum_ip"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|rx_ofld_frames_csum_tcp_udp
argument_list|)
block|,
literal|4
block|,
literal|"rx_ofld_frames_csum_tcp_udp"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|rx_budget_reached
argument_list|)
block|,
literal|4
block|,
literal|"rx_budget_reached"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|tx_pkts
argument_list|)
block|,
literal|4
block|,
literal|"tx_pkts"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|tx_soft_errors
argument_list|)
block|,
literal|4
block|,
literal|"tx_soft_errors"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|tx_ofld_frames_csum_ip
argument_list|)
block|,
literal|4
block|,
literal|"tx_ofld_frames_csum_ip"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|tx_ofld_frames_csum_tcp
argument_list|)
block|,
literal|4
block|,
literal|"tx_ofld_frames_csum_tcp"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|tx_ofld_frames_csum_udp
argument_list|)
block|,
literal|4
block|,
literal|"tx_ofld_frames_csum_udp"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|tx_ofld_frames_lso
argument_list|)
block|,
literal|4
block|,
literal|"tx_ofld_frames_lso"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|tx_ofld_frames_lso_hdr_splits
argument_list|)
block|,
literal|4
block|,
literal|"tx_ofld_frames_lso_hdr_splits"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|tx_encap_failures
argument_list|)
block|,
literal|4
block|,
literal|"tx_encap_failures"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|tx_hw_queue_full
argument_list|)
block|,
literal|4
block|,
literal|"tx_hw_queue_full"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|tx_hw_max_queue_depth
argument_list|)
block|,
literal|4
block|,
literal|"tx_hw_max_queue_depth"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|tx_dma_mapping_failure
argument_list|)
block|,
literal|4
block|,
literal|"tx_dma_mapping_failure"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|tx_max_drbr_queue_depth
argument_list|)
block|,
literal|4
block|,
literal|"tx_max_drbr_queue_depth"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|tx_window_violation_std
argument_list|)
block|,
literal|4
block|,
literal|"tx_window_violation_std"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|tx_window_violation_tso
argument_list|)
block|,
literal|4
block|,
literal|"tx_window_violation_tso"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|tx_chain_lost_mbuf
argument_list|)
block|,
literal|4
block|,
literal|"tx_chain_lost_mbuf"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|tx_frames_deferred
argument_list|)
block|,
literal|4
block|,
literal|"tx_frames_deferred"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|tx_queue_xoff
argument_list|)
block|,
literal|4
block|,
literal|"tx_queue_xoff"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|mbuf_defrag_attempts
argument_list|)
block|,
literal|4
block|,
literal|"mbuf_defrag_attempts"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|mbuf_defrag_failures
argument_list|)
block|,
literal|4
block|,
literal|"mbuf_defrag_failures"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|mbuf_rx_bd_alloc_failed
argument_list|)
block|,
literal|4
block|,
literal|"mbuf_rx_bd_alloc_failed"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|mbuf_rx_bd_mapping_failed
argument_list|)
block|,
literal|4
block|,
literal|"mbuf_rx_bd_mapping_failed"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|mbuf_rx_tpa_alloc_failed
argument_list|)
block|,
literal|4
block|,
literal|"mbuf_rx_tpa_alloc_failed"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|mbuf_rx_tpa_mapping_failed
argument_list|)
block|,
literal|4
block|,
literal|"mbuf_rx_tpa_mapping_failed"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|mbuf_rx_sge_alloc_failed
argument_list|)
block|,
literal|4
block|,
literal|"mbuf_rx_sge_alloc_failed"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|mbuf_rx_sge_mapping_failed
argument_list|)
block|,
literal|4
block|,
literal|"mbuf_rx_sge_mapping_failed"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|mbuf_alloc_tx
argument_list|)
block|,
literal|4
block|,
literal|"mbuf_alloc_tx"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|mbuf_alloc_rx
argument_list|)
block|,
literal|4
block|,
literal|"mbuf_alloc_rx"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|mbuf_alloc_sge
argument_list|)
block|,
literal|4
block|,
literal|"mbuf_alloc_sge"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|mbuf_alloc_tpa
argument_list|)
block|,
literal|4
block|,
literal|"mbuf_alloc_tpa"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|tx_queue_full_return
argument_list|)
block|,
literal|4
block|,
literal|"tx_queue_full_return"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|bxe_tx_mq_sc_state_failures
argument_list|)
block|,
literal|4
block|,
literal|"bxe_tx_mq_sc_state_failures"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|tx_request_link_down_failures
argument_list|)
block|,
literal|4
block|,
literal|"tx_request_link_down_failures"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|bd_avail_too_less_failures
argument_list|)
block|,
literal|4
block|,
literal|"bd_avail_too_less_failures"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|tx_mq_not_empty
argument_list|)
block|,
literal|4
block|,
literal|"tx_mq_not_empty"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|nsegs_path1_errors
argument_list|)
block|,
literal|4
block|,
literal|"nsegs_path1_errors"
block|}
block|,
block|{
name|Q_STATS_OFFSET32
argument_list|(
name|nsegs_path2_errors
argument_list|)
block|,
literal|4
block|,
literal|"nsegs_path2_errors"
block|}
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|BXE_NUM_ETH_STATS
value|ARRAY_SIZE(bxe_eth_stats_arr)
end_define

begin_define
define|#
directive|define
name|BXE_NUM_ETH_Q_STATS
value|ARRAY_SIZE(bxe_eth_q_stats_arr)
end_define

begin_function_decl
specifier|static
name|void
name|bxe_cmng_fns_init
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|read_cfg
parameter_list|,
name|uint8_t
name|cmng_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_get_cmng_fns_mode
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|storm_memset_cmng
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cmng_init
modifier|*
name|cmng
parameter_list|,
name|uint8_t
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_set_reset_global
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_set_reset_in_progress
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|bxe_reset_is_done
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|engine
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|bxe_clear_pf_load
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|bxe_chk_parity_attn
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
modifier|*
name|global
parameter_list|,
name|uint8_t
name|print
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_int_disable
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_release_leader_lock
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_pf_disable
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_free_fp_buffers
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|bxe_update_rx_prod
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|uint16_t
name|rx_bd_prod
parameter_list|,
name|uint16_t
name|rx_cq_prod
parameter_list|,
name|uint16_t
name|rx_sge_prod
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_link_report_locked
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_link_report
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_link_status_update
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_periodic_callout_func
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_periodic_start
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_periodic_stop
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_alloc_rx_bd_mbuf
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|uint16_t
name|prev_index
parameter_list|,
name|uint16_t
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_alloc_rx_tpa_mbuf
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|int
name|queue
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_alloc_rx_sge_mbuf
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|uint16_t
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|bxe_txeof
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_task_fp
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__noinline
name|void
name|bxe_dump_mbuf
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint8_t
name|contents
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_alloc_mem
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_free_mem
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_alloc_fw_stats_mem
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_free_fw_stats_mem
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_interrupt_attach
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_interrupt_detach
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_set_rx_mode
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_init_locked
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_stop_locked
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__noinline
name|int
name|bxe_nic_load
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|load_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__noinline
name|int
name|bxe_nic_unload
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|unload_mode
parameter_list|,
name|uint8_t
name|keep_link
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_handle_sp_tq
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_handle_fp_tq
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_add_cdev
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_del_cdev
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bxe_grc_dump
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_alloc_buf_rings
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_free_buf_rings
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* calculate crc32 on a buffer (NOTE: crc32_length MUST be aligned to 8) */
end_comment

begin_function
name|uint32_t
name|calc_crc32
parameter_list|(
name|uint8_t
modifier|*
name|crc32_packet
parameter_list|,
name|uint32_t
name|crc32_length
parameter_list|,
name|uint32_t
name|crc32_seed
parameter_list|,
name|uint8_t
name|complement
parameter_list|)
block|{
name|uint32_t
name|byte
init|=
literal|0
decl_stmt|;
name|uint32_t
name|bit
init|=
literal|0
decl_stmt|;
name|uint8_t
name|msb
init|=
literal|0
decl_stmt|;
name|uint32_t
name|temp
init|=
literal|0
decl_stmt|;
name|uint32_t
name|shft
init|=
literal|0
decl_stmt|;
name|uint8_t
name|current_byte
init|=
literal|0
decl_stmt|;
name|uint32_t
name|crc32_result
init|=
name|crc32_seed
decl_stmt|;
specifier|const
name|uint32_t
name|CRC32_POLY
init|=
literal|0x1edc6f41
decl_stmt|;
if|if
condition|(
operator|(
name|crc32_packet
operator|==
name|NULL
operator|)
operator|||
operator|(
name|crc32_length
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|crc32_length
operator|%
literal|8
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
return|return
operator|(
name|crc32_result
operator|)
return|;
block|}
for|for
control|(
name|byte
operator|=
literal|0
init|;
name|byte
operator|<
name|crc32_length
condition|;
name|byte
operator|=
name|byte
operator|+
literal|1
control|)
block|{
name|current_byte
operator|=
name|crc32_packet
index|[
name|byte
index|]
expr_stmt|;
for|for
control|(
name|bit
operator|=
literal|0
init|;
name|bit
operator|<
literal|8
condition|;
name|bit
operator|=
name|bit
operator|+
literal|1
control|)
block|{
comment|/* msb = crc32_result[31]; */
name|msb
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|crc32_result
operator|>>
literal|31
argument_list|)
expr_stmt|;
name|crc32_result
operator|=
name|crc32_result
operator|<<
literal|1
expr_stmt|;
comment|/* it (msb != current_byte[bit]) */
if|if
condition|(
name|msb
operator|!=
operator|(
literal|0x1
operator|&
operator|(
name|current_byte
operator|>>
name|bit
operator|)
operator|)
condition|)
block|{
name|crc32_result
operator|=
name|crc32_result
operator|^
name|CRC32_POLY
expr_stmt|;
comment|/* crc32_result[0] = 1 */
name|crc32_result
operator||=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* Last step is to:      * 1. "mirror" every bit      * 2. swap the 4 bytes      * 3. complement each bit      */
comment|/* Mirror */
name|temp
operator|=
name|crc32_result
expr_stmt|;
name|shft
operator|=
sizeof|sizeof
argument_list|(
name|crc32_result
argument_list|)
operator|*
literal|8
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|crc32_result
operator|>>=
literal|1
init|;
name|crc32_result
condition|;
name|crc32_result
operator|>>=
literal|1
control|)
block|{
name|temp
operator|<<=
literal|1
expr_stmt|;
name|temp
operator||=
name|crc32_result
operator|&
literal|1
expr_stmt|;
name|shft
operator|--
expr_stmt|;
block|}
comment|/* temp[31-bit] = crc32_result[bit] */
name|temp
operator|<<=
name|shft
expr_stmt|;
comment|/* Swap */
comment|/* crc32_result = {temp[7:0], temp[15:8], temp[23:16], temp[31:24]} */
block|{
name|uint32_t
name|t0
decl_stmt|,
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|;
name|t0
operator|=
operator|(
literal|0x000000ff
operator|&
operator|(
name|temp
operator|>>
literal|24
operator|)
operator|)
expr_stmt|;
name|t1
operator|=
operator|(
literal|0x0000ff00
operator|&
operator|(
name|temp
operator|>>
literal|8
operator|)
operator|)
expr_stmt|;
name|t2
operator|=
operator|(
literal|0x00ff0000
operator|&
operator|(
name|temp
operator|<<
literal|8
operator|)
operator|)
expr_stmt|;
name|t3
operator|=
operator|(
literal|0xff000000
operator|&
operator|(
name|temp
operator|<<
literal|24
operator|)
operator|)
expr_stmt|;
name|crc32_result
operator|=
name|t0
operator||
name|t1
operator||
name|t2
operator||
name|t3
expr_stmt|;
block|}
comment|/* Complement */
if|if
condition|(
name|complement
condition|)
block|{
name|crc32_result
operator|=
operator|~
name|crc32_result
expr_stmt|;
block|}
return|return
operator|(
name|crc32_result
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bxe_test_bit
parameter_list|(
name|int
name|nr
parameter_list|,
specifier|volatile
name|unsigned
name|long
modifier|*
name|addr
parameter_list|)
block|{
return|return
operator|(
operator|(
name|atomic_load_acq_long
argument_list|(
name|addr
argument_list|)
operator|&
operator|(
literal|1
operator|<<
name|nr
operator|)
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|bxe_set_bit
parameter_list|(
name|unsigned
name|int
name|nr
parameter_list|,
specifier|volatile
name|unsigned
name|long
modifier|*
name|addr
parameter_list|)
block|{
name|atomic_set_acq_long
argument_list|(
name|addr
argument_list|,
operator|(
literal|1
operator|<<
name|nr
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bxe_clear_bit
parameter_list|(
name|int
name|nr
parameter_list|,
specifier|volatile
name|unsigned
name|long
modifier|*
name|addr
parameter_list|)
block|{
name|atomic_clear_acq_long
argument_list|(
name|addr
argument_list|,
operator|(
literal|1
operator|<<
name|nr
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|bxe_test_and_set_bit
parameter_list|(
name|int
name|nr
parameter_list|,
specifier|volatile
name|unsigned
name|long
modifier|*
name|addr
parameter_list|)
block|{
name|unsigned
name|long
name|x
decl_stmt|;
name|nr
operator|=
operator|(
literal|1
operator|<<
name|nr
operator|)
expr_stmt|;
do|do
block|{
name|x
operator|=
operator|*
name|addr
expr_stmt|;
block|}
do|while
condition|(
name|atomic_cmpset_acq_long
argument_list|(
name|addr
argument_list|,
name|x
argument_list|,
name|x
operator||
name|nr
argument_list|)
operator|==
literal|0
condition|)
do|;
comment|// if (x& nr) bit_was_set; else bit_was_not_set;
return|return
operator|(
name|x
operator|&
name|nr
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bxe_test_and_clear_bit
parameter_list|(
name|int
name|nr
parameter_list|,
specifier|volatile
name|unsigned
name|long
modifier|*
name|addr
parameter_list|)
block|{
name|unsigned
name|long
name|x
decl_stmt|;
name|nr
operator|=
operator|(
literal|1
operator|<<
name|nr
operator|)
expr_stmt|;
do|do
block|{
name|x
operator|=
operator|*
name|addr
expr_stmt|;
block|}
do|while
condition|(
name|atomic_cmpset_acq_long
argument_list|(
name|addr
argument_list|,
name|x
argument_list|,
name|x
operator|&
operator|~
name|nr
argument_list|)
operator|==
literal|0
condition|)
do|;
comment|// if (x& nr) bit_was_set; else bit_was_not_set;
return|return
operator|(
name|x
operator|&
name|nr
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bxe_cmpxchg
parameter_list|(
specifier|volatile
name|int
modifier|*
name|addr
parameter_list|,
name|int
name|old
parameter_list|,
name|int
name|new
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
do|do
block|{
name|x
operator|=
operator|*
name|addr
expr_stmt|;
block|}
do|while
condition|(
name|atomic_cmpset_acq_int
argument_list|(
name|addr
argument_list|,
name|old
argument_list|,
name|new
argument_list|)
operator|==
literal|0
condition|)
do|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get DMA memory from the OS.  *  * Validates that the OS has provided DMA buffers in response to a  * bus_dmamap_load call and saves the physical address of those buffers.  * When the callback is used the OS will return 0 for the mapping function  * (bus_dmamap_load) so we use the value of map_arg->maxsegs to pass any  * failures back to the caller.  *  * Returns:  *   Nothing.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_dma_map_addr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|bxe_dma
modifier|*
name|dma
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dma
operator|->
name|paddr
operator|=
literal|0
expr_stmt|;
name|dma
operator|->
name|nseg
operator|=
literal|0
expr_stmt|;
name|BLOGE
argument_list|(
name|dma
operator|->
name|sc
argument_list|,
literal|"Failed DMA alloc '%s' (%d)!\n"
argument_list|,
name|dma
operator|->
name|msg
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dma
operator|->
name|paddr
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
name|dma
operator|->
name|nseg
operator|=
name|nseg
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Allocate a block of memory and map it for DMA. No partial completions  * allowed and release any resources acquired if we can't acquire all  * resources.  *  * Returns:  *   0 = Success, !0 = Failure  */
end_comment

begin_function
name|int
name|bxe_dma_alloc
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|size
parameter_list|,
name|struct
name|bxe_dma
modifier|*
name|dma
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|dma
operator|->
name|size
operator|>
literal|0
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"dma block '%s' already has size %lu\n"
argument_list|,
name|msg
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|dma
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|memset
argument_list|(
name|dma
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dma
argument_list|)
argument_list|)
expr_stmt|;
comment|/* sanity */
name|dma
operator|->
name|sc
operator|=
name|sc
expr_stmt|;
name|dma
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|snprintf
argument_list|(
name|dma
operator|->
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|dma
operator|->
name|msg
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|rc
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_dma_tag
argument_list|,
comment|/* parent tag */
name|BCM_PAGE_SIZE
argument_list|,
comment|/* alignment */
literal|0
argument_list|,
comment|/* boundary limit */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* restricted low */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* restricted hi */
name|NULL
argument_list|,
comment|/* addr filter() */
name|NULL
argument_list|,
comment|/* addr filter() arg */
name|size
argument_list|,
comment|/* max map size */
literal|1
argument_list|,
comment|/* num discontinuous */
name|size
argument_list|,
comment|/* max seg size */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lock() */
name|NULL
argument_list|,
comment|/* lock() arg */
operator|&
name|dma
operator|->
name|tag
argument_list|)
expr_stmt|;
comment|/* returned dma tag */
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to create dma tag for '%s' (%d)\n"
argument_list|,
name|msg
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|dma
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dma
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|rc
operator|=
name|bus_dmamem_alloc
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|dma
operator|->
name|vaddr
argument_list|,
operator|(
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_ZERO
operator|)
argument_list|,
operator|&
name|dma
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to alloc dma mem for '%s' (%d)\n"
argument_list|,
name|msg
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|dma
operator|->
name|tag
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|dma
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dma
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|rc
operator|=
name|bus_dmamap_load
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|,
name|dma
operator|->
name|vaddr
argument_list|,
name|size
argument_list|,
name|bxe_dma_map_addr
argument_list|,
comment|/* BLOGD in here */
name|dma
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to load dma map for '%s' (%d)\n"
argument_list|,
name|msg
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|vaddr
argument_list|,
name|dma
operator|->
name|map
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|dma
operator|->
name|tag
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|dma
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dma
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|bxe_dma_free
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bxe_dma
modifier|*
name|dma
parameter_list|)
block|{
if|if
condition|(
name|dma
operator|->
name|size
operator|>
literal|0
condition|)
block|{
name|DBASSERT
argument_list|(
name|sc
argument_list|,
operator|(
name|dma
operator|->
name|tag
operator|!=
name|NULL
operator|)
argument_list|,
operator|(
literal|"dma tag is NULL"
operator|)
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|,
operator|(
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
operator|)
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|vaddr
argument_list|,
name|dma
operator|->
name|map
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|dma
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|dma
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dma
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * These indirect read and write routines are only during init.  * The locking is handled by the MCP.  */
end_comment

begin_function
name|void
name|bxe_reg_wr_ind
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|pci_write_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|PCICFG_GRC_ADDRESS
argument_list|,
name|addr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|PCICFG_GRC_DATA
argument_list|,
name|val
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|PCICFG_GRC_ADDRESS
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint32_t
name|bxe_reg_rd_ind
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|PCICFG_GRC_ADDRESS
argument_list|,
name|addr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|val
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|PCICFG_GRC_DATA
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|PCICFG_GRC_ADDRESS
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_acquire_hw_lock
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|resource
parameter_list|)
block|{
name|uint32_t
name|lock_status
decl_stmt|;
name|uint32_t
name|resource_bit
init|=
operator|(
literal|1
operator|<<
name|resource
operator|)
decl_stmt|;
name|int
name|func
init|=
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|uint32_t
name|hw_lock_control_reg
decl_stmt|;
name|int
name|cnt
decl_stmt|;
comment|/* validate the resource is within range */
if|if
condition|(
name|resource
operator|>
name|HW_LOCK_MAX_RESOURCE_VALUE
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"(resource 0x%x> HW_LOCK_MAX_RESOURCE_VALUE)"
literal|" resource_bit 0x%x\n"
argument_list|,
name|resource
argument_list|,
name|resource_bit
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|func
operator|<=
literal|5
condition|)
block|{
name|hw_lock_control_reg
operator|=
operator|(
name|MISC_REG_DRIVER_CONTROL_1
operator|+
operator|(
name|func
operator|*
literal|8
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|hw_lock_control_reg
operator|=
operator|(
name|MISC_REG_DRIVER_CONTROL_7
operator|+
operator|(
operator|(
name|func
operator|-
literal|6
operator|)
operator|*
literal|8
operator|)
operator|)
expr_stmt|;
block|}
comment|/* validate the resource is not already taken */
name|lock_status
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|hw_lock_control_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock_status
operator|&
name|resource_bit
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"resource (0x%x) in use (status 0x%x bit 0x%x)\n"
argument_list|,
name|resource
argument_list|,
name|lock_status
argument_list|,
name|resource_bit
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* try every 5ms for 5 seconds */
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
literal|1000
condition|;
name|cnt
operator|++
control|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|hw_lock_control_reg
operator|+
literal|4
operator|)
argument_list|,
name|resource_bit
argument_list|)
expr_stmt|;
name|lock_status
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|hw_lock_control_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock_status
operator|&
name|resource_bit
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
block|}
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Resource 0x%x resource_bit 0x%x lock timeout!\n"
argument_list|,
name|resource
argument_list|,
name|resource_bit
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_release_hw_lock
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|resource
parameter_list|)
block|{
name|uint32_t
name|lock_status
decl_stmt|;
name|uint32_t
name|resource_bit
init|=
operator|(
literal|1
operator|<<
name|resource
operator|)
decl_stmt|;
name|int
name|func
init|=
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|uint32_t
name|hw_lock_control_reg
decl_stmt|;
comment|/* validate the resource is within range */
if|if
condition|(
name|resource
operator|>
name|HW_LOCK_MAX_RESOURCE_VALUE
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"(resource 0x%x> HW_LOCK_MAX_RESOURCE_VALUE)"
literal|" resource_bit 0x%x\n"
argument_list|,
name|resource
argument_list|,
name|resource_bit
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|func
operator|<=
literal|5
condition|)
block|{
name|hw_lock_control_reg
operator|=
operator|(
name|MISC_REG_DRIVER_CONTROL_1
operator|+
operator|(
name|func
operator|*
literal|8
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|hw_lock_control_reg
operator|=
operator|(
name|MISC_REG_DRIVER_CONTROL_7
operator|+
operator|(
operator|(
name|func
operator|-
literal|6
operator|)
operator|*
literal|8
operator|)
operator|)
expr_stmt|;
block|}
comment|/* validate the resource is currently taken */
name|lock_status
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|hw_lock_control_reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|lock_status
operator|&
name|resource_bit
operator|)
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"resource (0x%x) not in use (status 0x%x bit 0x%x)\n"
argument_list|,
name|resource
argument_list|,
name|lock_status
argument_list|,
name|resource_bit
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|hw_lock_control_reg
argument_list|,
name|resource_bit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_acquire_phy_lock
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|BXE_PHY_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_acquire_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_MDIO
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_release_phy_lock
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|bxe_release_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_MDIO
argument_list|)
expr_stmt|;
name|BXE_PHY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Per pf misc lock must be acquired before the per port mcp lock. Otherwise,  * had we done things the other way around, if two pfs from the same port  * would attempt to access nvram at the same time, we could run into a  * scenario such as:  * pf A takes the port lock.  * pf B succeeds in taking the same lock since they are from the same port.  * pf A takes the per pf misc lock. Performs eeprom access.  * pf A finishes. Unlocks the per pf misc lock.  * Pf B takes the lock and proceeds to perform it's own access.  * pf A unlocks the per port lock, while pf B is still working (!).  * mcp takes the per port lock and corrupts pf B's access (and/or has it's own  * access corrupted by pf B).*  */
end_comment

begin_function
specifier|static
name|int
name|bxe_acquire_nvram_lock
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|port
init|=
name|SC_PORT
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|int
name|count
decl_stmt|,
name|i
decl_stmt|;
name|uint32_t
name|val
init|=
literal|0
decl_stmt|;
comment|/* acquire HW lock: protect against other PFs in PF Direct Assignment */
name|bxe_acquire_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_NVRAM
argument_list|)
expr_stmt|;
comment|/* adjust timeout for emulation/FPGA */
name|count
operator|=
name|NVRAM_TIMEOUT_COUNT
expr_stmt|;
if|if
condition|(
name|CHIP_REV_IS_SLOW
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|count
operator|*=
literal|100
expr_stmt|;
block|}
comment|/* request access to nvram interface */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_NVM_SW_ARB
argument_list|,
operator|(
name|MCPR_NVM_SW_ARB_ARB_REQ_SET1
operator|<<
name|port
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
operator|*
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_NVM_SW_ARB
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
operator|(
name|MCPR_NVM_SW_ARB_ARB_ARB1
operator|<<
name|port
operator|)
condition|)
block|{
break|break;
block|}
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|val
operator|&
operator|(
name|MCPR_NVM_SW_ARB_ARB_ARB1
operator|<<
name|port
operator|)
operator|)
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Cannot get access to nvram interface "
literal|"port %d val 0x%x (MCPR_NVM_SW_ARB_ARB_ARB1<< port)\n"
argument_list|,
name|port
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_release_nvram_lock
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|port
init|=
name|SC_PORT
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|int
name|count
decl_stmt|,
name|i
decl_stmt|;
name|uint32_t
name|val
init|=
literal|0
decl_stmt|;
comment|/* adjust timeout for emulation/FPGA */
name|count
operator|=
name|NVRAM_TIMEOUT_COUNT
expr_stmt|;
if|if
condition|(
name|CHIP_REV_IS_SLOW
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|count
operator|*=
literal|100
expr_stmt|;
block|}
comment|/* relinquish nvram interface */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_NVM_SW_ARB
argument_list|,
operator|(
name|MCPR_NVM_SW_ARB_ARB_REQ_CLR1
operator|<<
name|port
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
operator|*
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_NVM_SW_ARB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|&
operator|(
name|MCPR_NVM_SW_ARB_ARB_ARB1
operator|<<
name|port
operator|)
operator|)
condition|)
block|{
break|break;
block|}
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
operator|(
name|MCPR_NVM_SW_ARB_ARB_ARB1
operator|<<
name|port
operator|)
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Cannot free access to nvram interface "
literal|"port %d val 0x%x (MCPR_NVM_SW_ARB_ARB_ARB1<< port)\n"
argument_list|,
name|port
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* release HW lock: protect against other PFs in PF Direct Assignment */
name|bxe_release_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_NVRAM
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_enable_nvram_access
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_NVM_ACCESS_ENABLE
argument_list|)
expr_stmt|;
comment|/* enable both bits, even on read */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_NVM_ACCESS_ENABLE
argument_list|,
operator|(
name|val
operator||
name|MCPR_NVM_ACCESS_ENABLE_EN
operator||
name|MCPR_NVM_ACCESS_ENABLE_WR_EN
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_disable_nvram_access
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_NVM_ACCESS_ENABLE
argument_list|)
expr_stmt|;
comment|/* disable both bits, even after read */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_NVM_ACCESS_ENABLE
argument_list|,
operator|(
name|val
operator|&
operator|~
operator|(
name|MCPR_NVM_ACCESS_ENABLE_EN
operator||
name|MCPR_NVM_ACCESS_ENABLE_WR_EN
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_nvram_read_dword
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint32_t
modifier|*
name|ret_val
parameter_list|,
name|uint32_t
name|cmd_flags
parameter_list|)
block|{
name|int
name|count
decl_stmt|,
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
comment|/* build the command word */
name|cmd_flags
operator||=
name|MCPR_NVM_COMMAND_DOIT
expr_stmt|;
comment|/* need to clear DONE bit separately */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_NVM_COMMAND
argument_list|,
name|MCPR_NVM_COMMAND_DONE
argument_list|)
expr_stmt|;
comment|/* address of the NVRAM to read from */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_NVM_ADDR
argument_list|,
operator|(
name|offset
operator|&
name|MCPR_NVM_ADDR_NVM_ADDR_VALUE
operator|)
argument_list|)
expr_stmt|;
comment|/* issue a read command */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_NVM_COMMAND
argument_list|,
name|cmd_flags
argument_list|)
expr_stmt|;
comment|/* adjust timeout for emulation/FPGA */
name|count
operator|=
name|NVRAM_TIMEOUT_COUNT
expr_stmt|;
if|if
condition|(
name|CHIP_REV_IS_SLOW
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|count
operator|*=
literal|100
expr_stmt|;
block|}
comment|/* wait for completion */
operator|*
name|ret_val
operator|=
literal|0
expr_stmt|;
name|rc
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_NVM_COMMAND
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|MCPR_NVM_COMMAND_DONE
condition|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_NVM_READ
argument_list|)
expr_stmt|;
comment|/* we read nvram data in cpu order              * but ethtool sees it as an array of bytes              * converting to big-endian will do the work              */
operator|*
name|ret_val
operator|=
name|htobe32
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|rc
operator|==
operator|-
literal|1
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"nvram read timeout expired "
literal|"(offset 0x%x cmd_flags 0x%x val 0x%x)\n"
argument_list|,
name|offset
argument_list|,
name|cmd_flags
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_nvram_read
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint8_t
modifier|*
name|ret_buf
parameter_list|,
name|int
name|buf_size
parameter_list|)
block|{
name|uint32_t
name|cmd_flags
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
operator|(
name|offset
operator|&
literal|0x03
operator|)
operator|||
operator|(
name|buf_size
operator|&
literal|0x03
operator|)
operator|||
operator|(
name|buf_size
operator|==
literal|0
operator|)
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Invalid parameter, offset 0x%x buf_size 0x%x\n"
argument_list|,
name|offset
argument_list|,
name|buf_size
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|offset
operator|+
name|buf_size
operator|)
operator|>
name|sc
operator|->
name|devinfo
operator|.
name|flash_size
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Invalid parameter, "
literal|"offset 0x%x + buf_size 0x%x> flash_size 0x%x\n"
argument_list|,
name|offset
argument_list|,
name|buf_size
argument_list|,
name|sc
operator|->
name|devinfo
operator|.
name|flash_size
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* request access to nvram interface */
name|rc
operator|=
name|bxe_acquire_nvram_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
return|return
operator|(
name|rc
operator|)
return|;
block|}
comment|/* enable access to nvram interface */
name|bxe_enable_nvram_access
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* read the first word(s) */
name|cmd_flags
operator|=
name|MCPR_NVM_COMMAND_FIRST
expr_stmt|;
while|while
condition|(
operator|(
name|buf_size
operator|>
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
operator|&&
operator|(
name|rc
operator|==
literal|0
operator|)
condition|)
block|{
name|rc
operator|=
name|bxe_nvram_read_dword
argument_list|(
name|sc
argument_list|,
name|offset
argument_list|,
operator|&
name|val
argument_list|,
name|cmd_flags
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ret_buf
argument_list|,
operator|&
name|val
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* advance to the next dword */
name|offset
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|ret_buf
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|buf_size
operator|-=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|cmd_flags
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
name|cmd_flags
operator||=
name|MCPR_NVM_COMMAND_LAST
expr_stmt|;
name|rc
operator|=
name|bxe_nvram_read_dword
argument_list|(
name|sc
argument_list|,
name|offset
argument_list|,
operator|&
name|val
argument_list|,
name|cmd_flags
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ret_buf
argument_list|,
operator|&
name|val
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* disable access to nvram interface */
name|bxe_disable_nvram_access
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_release_nvram_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_nvram_write_dword
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint32_t
name|val
parameter_list|,
name|uint32_t
name|cmd_flags
parameter_list|)
block|{
name|int
name|count
decl_stmt|,
name|i
decl_stmt|,
name|rc
decl_stmt|;
comment|/* build the command word */
name|cmd_flags
operator||=
operator|(
name|MCPR_NVM_COMMAND_DOIT
operator||
name|MCPR_NVM_COMMAND_WR
operator|)
expr_stmt|;
comment|/* need to clear DONE bit separately */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_NVM_COMMAND
argument_list|,
name|MCPR_NVM_COMMAND_DONE
argument_list|)
expr_stmt|;
comment|/* write the data */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_NVM_WRITE
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* address of the NVRAM to write to */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_NVM_ADDR
argument_list|,
operator|(
name|offset
operator|&
name|MCPR_NVM_ADDR_NVM_ADDR_VALUE
operator|)
argument_list|)
expr_stmt|;
comment|/* issue the write command */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_NVM_COMMAND
argument_list|,
name|cmd_flags
argument_list|)
expr_stmt|;
comment|/* adjust timeout for emulation/FPGA */
name|count
operator|=
name|NVRAM_TIMEOUT_COUNT
expr_stmt|;
if|if
condition|(
name|CHIP_REV_IS_SLOW
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|count
operator|*=
literal|100
expr_stmt|;
block|}
comment|/* wait for completion */
name|rc
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_NVM_COMMAND
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|MCPR_NVM_COMMAND_DONE
condition|)
block|{
name|rc
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|rc
operator|==
operator|-
literal|1
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"nvram write timeout expired "
literal|"(offset 0x%x cmd_flags 0x%x val 0x%x)\n"
argument_list|,
name|offset
argument_list|,
name|cmd_flags
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|BYTE_OFFSET
parameter_list|(
name|offset
parameter_list|)
value|(8 * (offset& 0x03))
end_define

begin_function
specifier|static
name|int
name|bxe_nvram_write1
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint8_t
modifier|*
name|data_buf
parameter_list|,
name|int
name|buf_size
parameter_list|)
block|{
name|uint32_t
name|cmd_flags
decl_stmt|;
name|uint32_t
name|align_offset
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
operator|(
name|offset
operator|+
name|buf_size
operator|)
operator|>
name|sc
operator|->
name|devinfo
operator|.
name|flash_size
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Invalid parameter, "
literal|"offset 0x%x + buf_size 0x%x> flash_size 0x%x\n"
argument_list|,
name|offset
argument_list|,
name|buf_size
argument_list|,
name|sc
operator|->
name|devinfo
operator|.
name|flash_size
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* request access to nvram interface */
name|rc
operator|=
name|bxe_acquire_nvram_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
return|return
operator|(
name|rc
operator|)
return|;
block|}
comment|/* enable access to nvram interface */
name|bxe_enable_nvram_access
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cmd_flags
operator|=
operator|(
name|MCPR_NVM_COMMAND_FIRST
operator||
name|MCPR_NVM_COMMAND_LAST
operator|)
expr_stmt|;
name|align_offset
operator|=
operator|(
name|offset
operator|&
operator|~
literal|0x03
operator|)
expr_stmt|;
name|rc
operator|=
name|bxe_nvram_read_dword
argument_list|(
name|sc
argument_list|,
name|align_offset
argument_list|,
operator|&
name|val
argument_list|,
name|cmd_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
name|val
operator|&=
operator|~
operator|(
literal|0xff
operator|<<
name|BYTE_OFFSET
argument_list|(
name|offset
argument_list|)
operator|)
expr_stmt|;
name|val
operator||=
operator|(
operator|*
name|data_buf
operator|<<
name|BYTE_OFFSET
argument_list|(
name|offset
argument_list|)
operator|)
expr_stmt|;
comment|/* nvram data is returned as an array of bytes          * convert it back to cpu order          */
name|val
operator|=
name|be32toh
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|rc
operator|=
name|bxe_nvram_write_dword
argument_list|(
name|sc
argument_list|,
name|align_offset
argument_list|,
name|val
argument_list|,
name|cmd_flags
argument_list|)
expr_stmt|;
block|}
comment|/* disable access to nvram interface */
name|bxe_disable_nvram_access
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_release_nvram_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_nvram_write
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint8_t
modifier|*
name|data_buf
parameter_list|,
name|int
name|buf_size
parameter_list|)
block|{
name|uint32_t
name|cmd_flags
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|uint32_t
name|written_so_far
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|buf_size
operator|==
literal|1
condition|)
block|{
return|return
operator|(
name|bxe_nvram_write1
argument_list|(
name|sc
argument_list|,
name|offset
argument_list|,
name|data_buf
argument_list|,
name|buf_size
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|offset
operator|&
literal|0x03
operator|)
operator|||
operator|(
name|buf_size
operator|&
literal|0x03
operator|)
comment|/* || (buf_size == 0) */
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Invalid parameter, offset 0x%x buf_size 0x%x\n"
argument_list|,
name|offset
argument_list|,
name|buf_size
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|buf_size
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* nothing to do */
block|}
if|if
condition|(
operator|(
name|offset
operator|+
name|buf_size
operator|)
operator|>
name|sc
operator|->
name|devinfo
operator|.
name|flash_size
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Invalid parameter, "
literal|"offset 0x%x + buf_size 0x%x> flash_size 0x%x\n"
argument_list|,
name|offset
argument_list|,
name|buf_size
argument_list|,
name|sc
operator|->
name|devinfo
operator|.
name|flash_size
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* request access to nvram interface */
name|rc
operator|=
name|bxe_acquire_nvram_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
return|return
operator|(
name|rc
operator|)
return|;
block|}
comment|/* enable access to nvram interface */
name|bxe_enable_nvram_access
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|written_so_far
operator|=
literal|0
expr_stmt|;
name|cmd_flags
operator|=
name|MCPR_NVM_COMMAND_FIRST
expr_stmt|;
while|while
condition|(
operator|(
name|written_so_far
operator|<
name|buf_size
operator|)
operator|&&
operator|(
name|rc
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|written_so_far
operator|==
operator|(
name|buf_size
operator|-
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
condition|)
block|{
name|cmd_flags
operator||=
name|MCPR_NVM_COMMAND_LAST
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|offset
operator|+
literal|4
operator|)
operator|%
name|NVRAM_PAGE_SIZE
operator|)
operator|==
literal|0
condition|)
block|{
name|cmd_flags
operator||=
name|MCPR_NVM_COMMAND_LAST
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|offset
operator|%
name|NVRAM_PAGE_SIZE
operator|)
operator|==
literal|0
condition|)
block|{
name|cmd_flags
operator||=
name|MCPR_NVM_COMMAND_FIRST
expr_stmt|;
block|}
name|memcpy
argument_list|(
operator|&
name|val
argument_list|,
name|data_buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|rc
operator|=
name|bxe_nvram_write_dword
argument_list|(
name|sc
argument_list|,
name|offset
argument_list|,
name|val
argument_list|,
name|cmd_flags
argument_list|)
expr_stmt|;
comment|/* advance to the next dword */
name|offset
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|data_buf
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|written_so_far
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|cmd_flags
operator|=
literal|0
expr_stmt|;
block|}
comment|/* disable access to nvram interface */
name|bxe_disable_nvram_access
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_release_nvram_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* copy command into DMAE command memory and set DMAE command Go */
end_comment

begin_function
name|void
name|bxe_post_dmae
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|dmae_cmd
modifier|*
name|dmae
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|uint32_t
name|cmd_offset
decl_stmt|;
name|int
name|i
decl_stmt|;
name|cmd_offset
operator|=
operator|(
name|DMAE_REG_CMD_MEM
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|dmae_cmd
argument_list|)
operator|*
name|idx
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|dmae_cmd
argument_list|)
operator|/
literal|4
operator|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|cmd_offset
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
operator|)
argument_list|,
operator|*
operator|(
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|dmae
operator|)
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|dmae_reg_go_c
index|[
name|idx
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint32_t
name|bxe_dmae_opcode_add_comp
parameter_list|(
name|uint32_t
name|opcode
parameter_list|,
name|uint8_t
name|comp_type
parameter_list|)
block|{
return|return
operator|(
name|opcode
operator||
operator|(
operator|(
name|comp_type
operator|<<
name|DMAE_CMD_C_DST_SHIFT
operator|)
operator||
name|DMAE_CMD_C_TYPE_ENABLE
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|bxe_dmae_opcode_clr_src_reset
parameter_list|(
name|uint32_t
name|opcode
parameter_list|)
block|{
return|return
operator|(
name|opcode
operator|&
operator|~
name|DMAE_CMD_SRC_RESET
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|bxe_dmae_opcode
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|src_type
parameter_list|,
name|uint8_t
name|dst_type
parameter_list|,
name|uint8_t
name|with_comp
parameter_list|,
name|uint8_t
name|comp_type
parameter_list|)
block|{
name|uint32_t
name|opcode
init|=
literal|0
decl_stmt|;
name|opcode
operator||=
operator|(
operator|(
name|src_type
operator|<<
name|DMAE_CMD_SRC_SHIFT
operator|)
operator||
operator|(
name|dst_type
operator|<<
name|DMAE_CMD_DST_SHIFT
operator|)
operator|)
expr_stmt|;
name|opcode
operator||=
operator|(
name|DMAE_CMD_SRC_RESET
operator||
name|DMAE_CMD_DST_RESET
operator|)
expr_stmt|;
name|opcode
operator||=
operator|(
name|SC_PORT
argument_list|(
name|sc
argument_list|)
condition|?
name|DMAE_CMD_PORT_1
else|:
name|DMAE_CMD_PORT_0
operator|)
expr_stmt|;
name|opcode
operator||=
operator|(
operator|(
name|SC_VN
argument_list|(
name|sc
argument_list|)
operator|<<
name|DMAE_CMD_E1HVN_SHIFT
operator|)
operator||
operator|(
name|SC_VN
argument_list|(
name|sc
argument_list|)
operator|<<
name|DMAE_CMD_DST_VN_SHIFT
operator|)
operator|)
expr_stmt|;
name|opcode
operator||=
operator|(
name|DMAE_COM_SET_ERR
operator|<<
name|DMAE_CMD_ERR_POLICY_SHIFT
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__BIG_ENDIAN
name|opcode
operator||=
name|DMAE_CMD_ENDIANITY_B_DW_SWAP
expr_stmt|;
else|#
directive|else
name|opcode
operator||=
name|DMAE_CMD_ENDIANITY_DW_SWAP
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|with_comp
condition|)
block|{
name|opcode
operator|=
name|bxe_dmae_opcode_add_comp
argument_list|(
name|opcode
argument_list|,
name|comp_type
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|opcode
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_prep_dmae_with_comp
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|dmae_cmd
modifier|*
name|dmae
parameter_list|,
name|uint8_t
name|src_type
parameter_list|,
name|uint8_t
name|dst_type
parameter_list|)
block|{
name|memset
argument_list|(
name|dmae
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dmae_cmd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set the opcode */
name|dmae
operator|->
name|opcode
operator|=
name|bxe_dmae_opcode
argument_list|(
name|sc
argument_list|,
name|src_type
argument_list|,
name|dst_type
argument_list|,
name|TRUE
argument_list|,
name|DMAE_COMP_PCI
argument_list|)
expr_stmt|;
comment|/* fill in the completion parameters */
name|dmae
operator|->
name|comp_addr_lo
operator|=
name|U64_LO
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|wb_comp
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|comp_addr_hi
operator|=
name|U64_HI
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|wb_comp
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|->
name|comp_val
operator|=
name|DMAE_COMP_VAL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* issue a DMAE command over the init channel and wait for completion */
end_comment

begin_function
specifier|static
name|int
name|bxe_issue_dmae_with_comp
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|dmae_cmd
modifier|*
name|dmae
parameter_list|)
block|{
name|uint32_t
modifier|*
name|wb_comp
init|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|wb_comp
argument_list|)
decl_stmt|;
name|int
name|timeout
init|=
name|CHIP_REV_IS_SLOW
argument_list|(
name|sc
argument_list|)
condition|?
literal|400000
else|:
literal|4000
decl_stmt|;
name|BXE_DMAE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* reset completion */
operator|*
name|wb_comp
operator|=
literal|0
expr_stmt|;
comment|/* post the command on the channel used for initializations */
name|bxe_post_dmae
argument_list|(
name|sc
argument_list|,
name|dmae
argument_list|,
name|INIT_DMAE_C
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* wait for completion */
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|wb_comp
operator|&
operator|~
name|DMAE_PCI_ERR_FLAG
operator|)
operator|!=
name|DMAE_COMP_VAL
condition|)
block|{
if|if
condition|(
operator|!
name|timeout
operator|||
operator|(
name|sc
operator|->
name|recovery_state
operator|!=
name|BXE_RECOVERY_DONE
operator|&&
name|sc
operator|->
name|recovery_state
operator|!=
name|BXE_RECOVERY_NIC_LOADING
operator|)
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"DMAE timeout! *wb_comp 0x%x recovery_state 0x%x\n"
argument_list|,
operator|*
name|wb_comp
argument_list|,
name|sc
operator|->
name|recovery_state
argument_list|)
expr_stmt|;
name|BXE_DMAE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|DMAE_TIMEOUT
operator|)
return|;
block|}
name|timeout
operator|--
expr_stmt|;
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|wb_comp
operator|&
name|DMAE_PCI_ERR_FLAG
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"DMAE PCI error! *wb_comp 0x%x recovery_state 0x%x\n"
argument_list|,
operator|*
name|wb_comp
argument_list|,
name|sc
operator|->
name|recovery_state
argument_list|)
expr_stmt|;
name|BXE_DMAE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|DMAE_PCI_ERROR
operator|)
return|;
block|}
name|BXE_DMAE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|bxe_read_dmae
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|src_addr
parameter_list|,
name|uint32_t
name|len32
parameter_list|)
block|{
name|struct
name|dmae_cmd
name|dmae
decl_stmt|;
name|uint32_t
modifier|*
name|data
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|DBASSERT
argument_list|(
name|sc
argument_list|,
operator|(
name|len32
operator|<=
literal|4
operator|)
argument_list|,
operator|(
literal|"DMAE read length is %d"
operator|,
name|len32
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|dmae_ready
condition|)
block|{
name|data
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|wb_data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len32
condition|;
name|i
operator|++
control|)
block|{
name|data
index|[
name|i
index|]
operator|=
operator|(
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
operator|)
condition|?
name|bxe_reg_rd_ind
argument_list|(
name|sc
argument_list|,
operator|(
name|src_addr
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
operator|)
argument_list|)
else|:
name|REG_RD
argument_list|(
name|sc
argument_list|,
operator|(
name|src_addr
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* set opcode and fixed command fields */
name|bxe_prep_dmae_with_comp
argument_list|(
name|sc
argument_list|,
operator|&
name|dmae
argument_list|,
name|DMAE_SRC_GRC
argument_list|,
name|DMAE_DST_PCI
argument_list|)
expr_stmt|;
comment|/* fill in addresses and len */
name|dmae
operator|.
name|src_addr_lo
operator|=
operator|(
name|src_addr
operator|>>
literal|2
operator|)
expr_stmt|;
comment|/* GRC addr has dword resolution */
name|dmae
operator|.
name|src_addr_hi
operator|=
literal|0
expr_stmt|;
name|dmae
operator|.
name|dst_addr_lo
operator|=
name|U64_LO
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|wb_data
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|.
name|dst_addr_hi
operator|=
name|U64_HI
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|wb_data
argument_list|)
argument_list|)
expr_stmt|;
name|dmae
operator|.
name|len
operator|=
name|len32
expr_stmt|;
comment|/* issue the command and wait for completion */
if|if
condition|(
operator|(
name|rc
operator|=
name|bxe_issue_dmae_with_comp
argument_list|(
name|sc
argument_list|,
operator|&
name|dmae
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|bxe_panic
argument_list|(
name|sc
argument_list|,
operator|(
literal|"DMAE failed (%d)\n"
operator|,
name|rc
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|bxe_write_dmae
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|bus_addr_t
name|dma_addr
parameter_list|,
name|uint32_t
name|dst_addr
parameter_list|,
name|uint32_t
name|len32
parameter_list|)
block|{
name|struct
name|dmae_cmd
name|dmae
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|dmae_ready
condition|)
block|{
name|DBASSERT
argument_list|(
name|sc
argument_list|,
operator|(
name|len32
operator|<=
literal|4
operator|)
argument_list|,
operator|(
literal|"DMAE not ready and length is %d"
operator|,
name|len32
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|ecore_init_ind_wr
argument_list|(
name|sc
argument_list|,
name|dst_addr
argument_list|,
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|wb_data
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|len32
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ecore_init_str_wr
argument_list|(
name|sc
argument_list|,
name|dst_addr
argument_list|,
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|wb_data
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|len32
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* set opcode and fixed command fields */
name|bxe_prep_dmae_with_comp
argument_list|(
name|sc
argument_list|,
operator|&
name|dmae
argument_list|,
name|DMAE_SRC_PCI
argument_list|,
name|DMAE_DST_GRC
argument_list|)
expr_stmt|;
comment|/* fill in addresses and len */
name|dmae
operator|.
name|src_addr_lo
operator|=
name|U64_LO
argument_list|(
name|dma_addr
argument_list|)
expr_stmt|;
name|dmae
operator|.
name|src_addr_hi
operator|=
name|U64_HI
argument_list|(
name|dma_addr
argument_list|)
expr_stmt|;
name|dmae
operator|.
name|dst_addr_lo
operator|=
operator|(
name|dst_addr
operator|>>
literal|2
operator|)
expr_stmt|;
comment|/* GRC addr has dword resolution */
name|dmae
operator|.
name|dst_addr_hi
operator|=
literal|0
expr_stmt|;
name|dmae
operator|.
name|len
operator|=
name|len32
expr_stmt|;
comment|/* issue the command and wait for completion */
if|if
condition|(
operator|(
name|rc
operator|=
name|bxe_issue_dmae_with_comp
argument_list|(
name|sc
argument_list|,
operator|&
name|dmae
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|bxe_panic
argument_list|(
name|sc
argument_list|,
operator|(
literal|"DMAE failed (%d)\n"
operator|,
name|rc
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|bxe_write_dmae_phys_len
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|bus_addr_t
name|phys_addr
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|len
parameter_list|)
block|{
name|int
name|dmae_wr_max
init|=
name|DMAE_LEN32_WR_MAX
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|len
operator|>
name|dmae_wr_max
condition|)
block|{
name|bxe_write_dmae
argument_list|(
name|sc
argument_list|,
operator|(
name|phys_addr
operator|+
name|offset
operator|)
argument_list|,
comment|/* src DMA address */
operator|(
name|addr
operator|+
name|offset
operator|)
argument_list|,
comment|/* dst GRC address */
name|dmae_wr_max
argument_list|)
expr_stmt|;
name|offset
operator|+=
operator|(
name|dmae_wr_max
operator|*
literal|4
operator|)
expr_stmt|;
name|len
operator|-=
name|dmae_wr_max
expr_stmt|;
block|}
name|bxe_write_dmae
argument_list|(
name|sc
argument_list|,
operator|(
name|phys_addr
operator|+
name|offset
operator|)
argument_list|,
comment|/* src DMA address */
operator|(
name|addr
operator|+
name|offset
operator|)
argument_list|,
comment|/* dst GRC address */
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bxe_set_ctx_validation
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|eth_context
modifier|*
name|cxt
parameter_list|,
name|uint32_t
name|cid
parameter_list|)
block|{
comment|/* ustorm cxt validation */
name|cxt
operator|->
name|ustorm_ag_context
operator|.
name|cdu_usage
operator|=
name|CDU_RSRVD_VALUE_TYPE_A
argument_list|(
name|HW_CID
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|)
argument_list|,
name|CDU_REGION_NUMBER_UCM_AG
argument_list|,
name|ETH_CONNECTION_TYPE
argument_list|)
expr_stmt|;
comment|/* xcontext validation */
name|cxt
operator|->
name|xstorm_ag_context
operator|.
name|cdu_reserved
operator|=
name|CDU_RSRVD_VALUE_TYPE_A
argument_list|(
name|HW_CID
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|)
argument_list|,
name|CDU_REGION_NUMBER_XCM_AG
argument_list|,
name|ETH_CONNECTION_TYPE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_storm_memset_hc_timeout
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|port
parameter_list|,
name|uint8_t
name|fw_sb_id
parameter_list|,
name|uint8_t
name|sb_index
parameter_list|,
name|uint8_t
name|ticks
parameter_list|)
block|{
name|uint32_t
name|addr
init|=
operator|(
name|BAR_CSTRORM_INTMEM
operator|+
name|CSTORM_STATUS_BLOCK_DATA_TIMEOUT_OFFSET
argument_list|(
name|fw_sb_id
argument_list|,
name|sb_index
argument_list|)
operator|)
decl_stmt|;
name|REG_WR8
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|ticks
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"port %d fw_sb_id %d sb_index %d ticks %d\n"
argument_list|,
name|port
argument_list|,
name|fw_sb_id
argument_list|,
name|sb_index
argument_list|,
name|ticks
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_storm_memset_hc_disable
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|port
parameter_list|,
name|uint16_t
name|fw_sb_id
parameter_list|,
name|uint8_t
name|sb_index
parameter_list|,
name|uint8_t
name|disable
parameter_list|)
block|{
name|uint32_t
name|enable_flag
init|=
operator|(
name|disable
operator|)
condition|?
literal|0
else|:
operator|(
literal|1
operator|<<
name|HC_INDEX_DATA_HC_ENABLED_SHIFT
operator|)
decl_stmt|;
name|uint32_t
name|addr
init|=
operator|(
name|BAR_CSTRORM_INTMEM
operator|+
name|CSTORM_STATUS_BLOCK_DATA_FLAGS_OFFSET
argument_list|(
name|fw_sb_id
argument_list|,
name|sb_index
argument_list|)
operator|)
decl_stmt|;
name|uint8_t
name|flags
decl_stmt|;
comment|/* clear and set */
name|flags
operator|=
name|REG_RD8
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|HC_INDEX_DATA_HC_ENABLED
expr_stmt|;
name|flags
operator||=
name|enable_flag
expr_stmt|;
name|REG_WR8
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"port %d fw_sb_id %d sb_index %d disable %d\n"
argument_list|,
name|port
argument_list|,
name|fw_sb_id
argument_list|,
name|sb_index
argument_list|,
name|disable
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bxe_update_coalesce_sb_index
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|fw_sb_id
parameter_list|,
name|uint8_t
name|sb_index
parameter_list|,
name|uint8_t
name|disable
parameter_list|,
name|uint16_t
name|usec
parameter_list|)
block|{
name|int
name|port
init|=
name|SC_PORT
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|uint8_t
name|ticks
init|=
operator|(
name|usec
operator|/
literal|4
operator|)
decl_stmt|;
comment|/* XXX ??? */
name|bxe_storm_memset_hc_timeout
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|fw_sb_id
argument_list|,
name|sb_index
argument_list|,
name|ticks
argument_list|)
expr_stmt|;
name|disable
operator|=
operator|(
name|disable
operator|)
condition|?
literal|1
else|:
operator|(
operator|(
name|usec
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
name|bxe_storm_memset_hc_disable
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|fw_sb_id
argument_list|,
name|sb_index
argument_list|,
name|disable
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|elink_cb_udelay
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|usecs
parameter_list|)
block|{
name|DELAY
argument_list|(
name|usecs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint32_t
name|elink_cb_reg_read
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|reg_addr
parameter_list|)
block|{
return|return
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|reg_addr
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|elink_cb_reg_write
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|reg_addr
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|reg_addr
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|elink_cb_reg_wb_write
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint32_t
modifier|*
name|wb_write
parameter_list|,
name|uint16_t
name|len
parameter_list|)
block|{
name|REG_WR_DMAE
argument_list|(
name|sc
argument_list|,
name|offset
argument_list|,
name|wb_write
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|elink_cb_reg_wb_read
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint32_t
modifier|*
name|wb_write
parameter_list|,
name|uint16_t
name|len
parameter_list|)
block|{
name|REG_RD_DMAE
argument_list|(
name|sc
argument_list|,
name|offset
argument_list|,
name|wb_write
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint8_t
name|elink_cb_path_id
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
name|SC_PATH
argument_list|(
name|sc
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|elink_cb_event_log
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|elink_log_id_t
name|elink_log_id
parameter_list|,
modifier|...
parameter_list|)
block|{
comment|/* XXX */
name|BLOGI
argument_list|(
name|sc
argument_list|,
literal|"ELINK EVENT LOG (%d)\n"
argument_list|,
name|elink_log_id
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_set_spio
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|spio
parameter_list|,
name|uint32_t
name|mode
parameter_list|)
block|{
name|uint32_t
name|spio_reg
decl_stmt|;
comment|/* Only 2 SPIOs are configurable */
if|if
condition|(
operator|(
name|spio
operator|!=
name|MISC_SPIO_SPIO4
operator|)
operator|&&
operator|(
name|spio
operator|!=
name|MISC_SPIO_SPIO5
operator|)
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Invalid SPIO 0x%x mode 0x%x\n"
argument_list|,
name|spio
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|bxe_acquire_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_SPIO
argument_list|)
expr_stmt|;
comment|/* read SPIO and mask except the float bits */
name|spio_reg
operator|=
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_SPIO
argument_list|)
operator|&
name|MISC_SPIO_FLOAT
operator|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|MISC_SPIO_OUTPUT_LOW
case|:
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Set SPIO 0x%x -> output low\n"
argument_list|,
name|spio
argument_list|)
expr_stmt|;
comment|/* clear FLOAT and set CLR */
name|spio_reg
operator|&=
operator|~
operator|(
name|spio
operator|<<
name|MISC_SPIO_FLOAT_POS
operator|)
expr_stmt|;
name|spio_reg
operator||=
operator|(
name|spio
operator|<<
name|MISC_SPIO_CLR_POS
operator|)
expr_stmt|;
break|break;
case|case
name|MISC_SPIO_OUTPUT_HIGH
case|:
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Set SPIO 0x%x -> output high\n"
argument_list|,
name|spio
argument_list|)
expr_stmt|;
comment|/* clear FLOAT and set SET */
name|spio_reg
operator|&=
operator|~
operator|(
name|spio
operator|<<
name|MISC_SPIO_FLOAT_POS
operator|)
expr_stmt|;
name|spio_reg
operator||=
operator|(
name|spio
operator|<<
name|MISC_SPIO_SET_POS
operator|)
expr_stmt|;
break|break;
case|case
name|MISC_SPIO_INPUT_HI_Z
case|:
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Set SPIO 0x%x -> input\n"
argument_list|,
name|spio
argument_list|)
expr_stmt|;
comment|/* set FLOAT */
name|spio_reg
operator||=
operator|(
name|spio
operator|<<
name|MISC_SPIO_FLOAT_POS
operator|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_SPIO
argument_list|,
name|spio_reg
argument_list|)
expr_stmt|;
name|bxe_release_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_SPIO
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_gpio_read
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|gpio_num
parameter_list|,
name|uint8_t
name|port
parameter_list|)
block|{
comment|/* The GPIO should be swapped if swap register is set and active */
name|int
name|gpio_port
init|=
operator|(
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_PORT_SWAP
argument_list|)
operator|&&
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_STRAP_OVERRIDE
argument_list|)
operator|)
operator|^
name|port
operator|)
decl_stmt|;
name|int
name|gpio_shift
init|=
operator|(
name|gpio_num
operator|+
operator|(
name|gpio_port
condition|?
name|MISC_REGISTERS_GPIO_PORT_SHIFT
else|:
literal|0
operator|)
operator|)
decl_stmt|;
name|uint32_t
name|gpio_mask
init|=
operator|(
literal|1
operator|<<
name|gpio_shift
operator|)
decl_stmt|;
name|uint32_t
name|gpio_reg
decl_stmt|;
if|if
condition|(
name|gpio_num
operator|>
name|MISC_REGISTERS_GPIO_3
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Invalid GPIO %d port 0x%x gpio_port %d gpio_shift %d"
literal|" gpio_mask 0x%x\n"
argument_list|,
name|gpio_num
argument_list|,
name|port
argument_list|,
name|gpio_port
argument_list|,
name|gpio_shift
argument_list|,
name|gpio_mask
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* read GPIO value */
name|gpio_reg
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_GPIO
argument_list|)
expr_stmt|;
comment|/* get the requested pin value */
return|return
operator|(
operator|(
name|gpio_reg
operator|&
name|gpio_mask
operator|)
operator|==
name|gpio_mask
operator|)
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_gpio_write
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|gpio_num
parameter_list|,
name|uint32_t
name|mode
parameter_list|,
name|uint8_t
name|port
parameter_list|)
block|{
comment|/* The GPIO should be swapped if swap register is set and active */
name|int
name|gpio_port
init|=
operator|(
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_PORT_SWAP
argument_list|)
operator|&&
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_STRAP_OVERRIDE
argument_list|)
operator|)
operator|^
name|port
operator|)
decl_stmt|;
name|int
name|gpio_shift
init|=
operator|(
name|gpio_num
operator|+
operator|(
name|gpio_port
condition|?
name|MISC_REGISTERS_GPIO_PORT_SHIFT
else|:
literal|0
operator|)
operator|)
decl_stmt|;
name|uint32_t
name|gpio_mask
init|=
operator|(
literal|1
operator|<<
name|gpio_shift
operator|)
decl_stmt|;
name|uint32_t
name|gpio_reg
decl_stmt|;
if|if
condition|(
name|gpio_num
operator|>
name|MISC_REGISTERS_GPIO_3
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Invalid GPIO %d mode 0x%x port 0x%x gpio_port %d"
literal|" gpio_shift %d gpio_mask 0x%x\n"
argument_list|,
name|gpio_num
argument_list|,
name|mode
argument_list|,
name|port
argument_list|,
name|gpio_port
argument_list|,
name|gpio_shift
argument_list|,
name|gpio_mask
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|bxe_acquire_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_GPIO
argument_list|)
expr_stmt|;
comment|/* read GPIO and mask except the float bits */
name|gpio_reg
operator|=
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_GPIO
argument_list|)
operator|&
name|MISC_REGISTERS_GPIO_FLOAT
operator|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|MISC_REGISTERS_GPIO_OUTPUT_LOW
case|:
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_PHY
argument_list|,
literal|"Set GPIO %d (shift %d) -> output low\n"
argument_list|,
name|gpio_num
argument_list|,
name|gpio_shift
argument_list|)
expr_stmt|;
comment|/* clear FLOAT and set CLR */
name|gpio_reg
operator|&=
operator|~
operator|(
name|gpio_mask
operator|<<
name|MISC_REGISTERS_GPIO_FLOAT_POS
operator|)
expr_stmt|;
name|gpio_reg
operator||=
operator|(
name|gpio_mask
operator|<<
name|MISC_REGISTERS_GPIO_CLR_POS
operator|)
expr_stmt|;
break|break;
case|case
name|MISC_REGISTERS_GPIO_OUTPUT_HIGH
case|:
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_PHY
argument_list|,
literal|"Set GPIO %d (shift %d) -> output high\n"
argument_list|,
name|gpio_num
argument_list|,
name|gpio_shift
argument_list|)
expr_stmt|;
comment|/* clear FLOAT and set SET */
name|gpio_reg
operator|&=
operator|~
operator|(
name|gpio_mask
operator|<<
name|MISC_REGISTERS_GPIO_FLOAT_POS
operator|)
expr_stmt|;
name|gpio_reg
operator||=
operator|(
name|gpio_mask
operator|<<
name|MISC_REGISTERS_GPIO_SET_POS
operator|)
expr_stmt|;
break|break;
case|case
name|MISC_REGISTERS_GPIO_INPUT_HI_Z
case|:
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_PHY
argument_list|,
literal|"Set GPIO %d (shift %d) -> input\n"
argument_list|,
name|gpio_num
argument_list|,
name|gpio_shift
argument_list|)
expr_stmt|;
comment|/* set FLOAT */
name|gpio_reg
operator||=
operator|(
name|gpio_mask
operator|<<
name|MISC_REGISTERS_GPIO_FLOAT_POS
operator|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_GPIO
argument_list|,
name|gpio_reg
argument_list|)
expr_stmt|;
name|bxe_release_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_GPIO
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_gpio_mult_write
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|pins
parameter_list|,
name|uint32_t
name|mode
parameter_list|)
block|{
name|uint32_t
name|gpio_reg
decl_stmt|;
comment|/* any port swapping should be handled by caller */
name|bxe_acquire_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_GPIO
argument_list|)
expr_stmt|;
comment|/* read GPIO and mask except the float bits */
name|gpio_reg
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_GPIO
argument_list|)
expr_stmt|;
name|gpio_reg
operator|&=
operator|~
operator|(
name|pins
operator|<<
name|MISC_REGISTERS_GPIO_FLOAT_POS
operator|)
expr_stmt|;
name|gpio_reg
operator|&=
operator|~
operator|(
name|pins
operator|<<
name|MISC_REGISTERS_GPIO_CLR_POS
operator|)
expr_stmt|;
name|gpio_reg
operator|&=
operator|~
operator|(
name|pins
operator|<<
name|MISC_REGISTERS_GPIO_SET_POS
operator|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|MISC_REGISTERS_GPIO_OUTPUT_LOW
case|:
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_PHY
argument_list|,
literal|"Set GPIO 0x%x -> output low\n"
argument_list|,
name|pins
argument_list|)
expr_stmt|;
comment|/* set CLR */
name|gpio_reg
operator||=
operator|(
name|pins
operator|<<
name|MISC_REGISTERS_GPIO_CLR_POS
operator|)
expr_stmt|;
break|break;
case|case
name|MISC_REGISTERS_GPIO_OUTPUT_HIGH
case|:
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_PHY
argument_list|,
literal|"Set GPIO 0x%x -> output high\n"
argument_list|,
name|pins
argument_list|)
expr_stmt|;
comment|/* set SET */
name|gpio_reg
operator||=
operator|(
name|pins
operator|<<
name|MISC_REGISTERS_GPIO_SET_POS
operator|)
expr_stmt|;
break|break;
case|case
name|MISC_REGISTERS_GPIO_INPUT_HI_Z
case|:
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_PHY
argument_list|,
literal|"Set GPIO 0x%x -> input\n"
argument_list|,
name|pins
argument_list|)
expr_stmt|;
comment|/* set FLOAT */
name|gpio_reg
operator||=
operator|(
name|pins
operator|<<
name|MISC_REGISTERS_GPIO_FLOAT_POS
operator|)
expr_stmt|;
break|break;
default|default:
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Invalid GPIO mode assignment pins 0x%x mode 0x%x"
literal|" gpio_reg 0x%x\n"
argument_list|,
name|pins
argument_list|,
name|mode
argument_list|,
name|gpio_reg
argument_list|)
expr_stmt|;
name|bxe_release_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_GPIO
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_GPIO
argument_list|,
name|gpio_reg
argument_list|)
expr_stmt|;
name|bxe_release_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_GPIO
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_gpio_int_write
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|gpio_num
parameter_list|,
name|uint32_t
name|mode
parameter_list|,
name|uint8_t
name|port
parameter_list|)
block|{
comment|/* The GPIO should be swapped if swap register is set and active */
name|int
name|gpio_port
init|=
operator|(
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_PORT_SWAP
argument_list|)
operator|&&
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_STRAP_OVERRIDE
argument_list|)
operator|)
operator|^
name|port
operator|)
decl_stmt|;
name|int
name|gpio_shift
init|=
operator|(
name|gpio_num
operator|+
operator|(
name|gpio_port
condition|?
name|MISC_REGISTERS_GPIO_PORT_SHIFT
else|:
literal|0
operator|)
operator|)
decl_stmt|;
name|uint32_t
name|gpio_mask
init|=
operator|(
literal|1
operator|<<
name|gpio_shift
operator|)
decl_stmt|;
name|uint32_t
name|gpio_reg
decl_stmt|;
if|if
condition|(
name|gpio_num
operator|>
name|MISC_REGISTERS_GPIO_3
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Invalid GPIO %d mode 0x%x port 0x%x gpio_port %d"
literal|" gpio_shift %d gpio_mask 0x%x\n"
argument_list|,
name|gpio_num
argument_list|,
name|mode
argument_list|,
name|port
argument_list|,
name|gpio_port
argument_list|,
name|gpio_shift
argument_list|,
name|gpio_mask
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|bxe_acquire_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_GPIO
argument_list|)
expr_stmt|;
comment|/* read GPIO int */
name|gpio_reg
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_GPIO_INT
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|MISC_REGISTERS_GPIO_INT_OUTPUT_CLR
case|:
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_PHY
argument_list|,
literal|"Clear GPIO INT %d (shift %d) -> output low\n"
argument_list|,
name|gpio_num
argument_list|,
name|gpio_shift
argument_list|)
expr_stmt|;
comment|/* clear SET and set CLR */
name|gpio_reg
operator|&=
operator|~
operator|(
name|gpio_mask
operator|<<
name|MISC_REGISTERS_GPIO_INT_SET_POS
operator|)
expr_stmt|;
name|gpio_reg
operator||=
operator|(
name|gpio_mask
operator|<<
name|MISC_REGISTERS_GPIO_INT_CLR_POS
operator|)
expr_stmt|;
break|break;
case|case
name|MISC_REGISTERS_GPIO_INT_OUTPUT_SET
case|:
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_PHY
argument_list|,
literal|"Set GPIO INT %d (shift %d) -> output high\n"
argument_list|,
name|gpio_num
argument_list|,
name|gpio_shift
argument_list|)
expr_stmt|;
comment|/* clear CLR and set SET */
name|gpio_reg
operator|&=
operator|~
operator|(
name|gpio_mask
operator|<<
name|MISC_REGISTERS_GPIO_INT_CLR_POS
operator|)
expr_stmt|;
name|gpio_reg
operator||=
operator|(
name|gpio_mask
operator|<<
name|MISC_REGISTERS_GPIO_INT_SET_POS
operator|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_GPIO_INT
argument_list|,
name|gpio_reg
argument_list|)
expr_stmt|;
name|bxe_release_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_GPIO
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|elink_cb_gpio_read
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|gpio_num
parameter_list|,
name|uint8_t
name|port
parameter_list|)
block|{
return|return
operator|(
name|bxe_gpio_read
argument_list|(
name|sc
argument_list|,
name|gpio_num
argument_list|,
name|port
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|uint8_t
name|elink_cb_gpio_write
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|gpio_num
parameter_list|,
name|uint8_t
name|mode
parameter_list|,
comment|/* 0=low 1=high */
name|uint8_t
name|port
parameter_list|)
block|{
return|return
operator|(
name|bxe_gpio_write
argument_list|(
name|sc
argument_list|,
name|gpio_num
argument_list|,
name|mode
argument_list|,
name|port
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|uint8_t
name|elink_cb_gpio_mult_write
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|pins
parameter_list|,
name|uint8_t
name|mode
parameter_list|)
comment|/* 0=low 1=high */
block|{
return|return
operator|(
name|bxe_gpio_mult_write
argument_list|(
name|sc
argument_list|,
name|pins
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|uint8_t
name|elink_cb_gpio_int_write
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|gpio_num
parameter_list|,
name|uint8_t
name|mode
parameter_list|,
comment|/* 0=low 1=high */
name|uint8_t
name|port
parameter_list|)
block|{
return|return
operator|(
name|bxe_gpio_int_write
argument_list|(
name|sc
argument_list|,
name|gpio_num
argument_list|,
name|mode
argument_list|,
name|port
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|elink_cb_notify_link_changed
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|MISC_REG_AEU_GENERAL_ATTN_12
operator|+
operator|(
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* send the MCP a request, block until there is a reply */
end_comment

begin_function
name|uint32_t
name|elink_cb_fw_command
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|command
parameter_list|,
name|uint32_t
name|param
parameter_list|)
block|{
name|int
name|mb_idx
init|=
name|SC_FW_MB_IDX
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|uint32_t
name|seq
decl_stmt|;
name|uint32_t
name|rc
init|=
literal|0
decl_stmt|;
name|uint32_t
name|cnt
init|=
literal|1
decl_stmt|;
name|uint8_t
name|delay
init|=
name|CHIP_REV_IS_SLOW
argument_list|(
name|sc
argument_list|)
condition|?
literal|100
else|:
literal|10
decl_stmt|;
name|BXE_FWMB_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|seq
operator|=
operator|++
name|sc
operator|->
name|fw_seq
expr_stmt|;
name|SHMEM_WR
argument_list|(
name|sc
argument_list|,
name|func_mb
index|[
name|mb_idx
index|]
operator|.
name|drv_mb_param
argument_list|,
name|param
argument_list|)
expr_stmt|;
name|SHMEM_WR
argument_list|(
name|sc
argument_list|,
name|func_mb
index|[
name|mb_idx
index|]
operator|.
name|drv_mb_header
argument_list|,
operator|(
name|command
operator||
name|seq
operator|)
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_PHY
argument_list|,
literal|"wrote command 0x%08x to FW MB param 0x%08x\n"
argument_list|,
operator|(
name|command
operator||
name|seq
operator|)
argument_list|,
name|param
argument_list|)
expr_stmt|;
comment|/* Let the FW do it's magic. GIve it up to 5 seconds... */
do|do
block|{
name|DELAY
argument_list|(
name|delay
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|rc
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|func_mb
index|[
name|mb_idx
index|]
operator|.
name|fw_mb_header
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|seq
operator|!=
operator|(
name|rc
operator|&
name|FW_MSG_SEQ_NUMBER_MASK
operator|)
operator|)
operator|&&
operator|(
name|cnt
operator|++
operator|<
literal|500
operator|)
condition|)
do|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_PHY
argument_list|,
literal|"[after %d ms] read 0x%x seq 0x%x from FW MB\n"
argument_list|,
name|cnt
operator|*
name|delay
argument_list|,
name|rc
argument_list|,
name|seq
argument_list|)
expr_stmt|;
comment|/* is this a reply to our command? */
if|if
condition|(
name|seq
operator|==
operator|(
name|rc
operator|&
name|FW_MSG_SEQ_NUMBER_MASK
operator|)
condition|)
block|{
name|rc
operator|&=
name|FW_MSG_CODE_MASK
expr_stmt|;
block|}
else|else
block|{
comment|/* Ruh-roh! */
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"FW failed to respond!\n"
argument_list|)
expr_stmt|;
comment|// XXX bxe_fw_dump(sc);
name|rc
operator|=
literal|0
expr_stmt|;
block|}
name|BXE_FWMB_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|bxe_fw_command
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|command
parameter_list|,
name|uint32_t
name|param
parameter_list|)
block|{
return|return
operator|(
name|elink_cb_fw_command
argument_list|(
name|sc
argument_list|,
name|command
argument_list|,
name|param
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|__storm_memset_dma_mapping
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|bus_addr_t
name|mapping
parameter_list|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|U64_LO
argument_list|(
name|mapping
argument_list|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|addr
operator|+
literal|4
operator|)
argument_list|,
name|U64_HI
argument_list|(
name|mapping
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|storm_memset_spq_addr
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|bus_addr_t
name|mapping
parameter_list|,
name|uint16_t
name|abs_fid
parameter_list|)
block|{
name|uint32_t
name|addr
init|=
operator|(
name|XSEM_REG_FAST_MEMORY
operator|+
name|XSTORM_SPQ_PAGE_BASE_OFFSET
argument_list|(
name|abs_fid
argument_list|)
operator|)
decl_stmt|;
name|__storm_memset_dma_mapping
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|mapping
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|storm_memset_vf_to_pf
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|abs_fid
parameter_list|,
name|uint16_t
name|pf_id
parameter_list|)
block|{
name|REG_WR8
argument_list|(
name|sc
argument_list|,
operator|(
name|BAR_XSTRORM_INTMEM
operator|+
name|XSTORM_VF_TO_PF_OFFSET
argument_list|(
name|abs_fid
argument_list|)
operator|)
argument_list|,
name|pf_id
argument_list|)
expr_stmt|;
name|REG_WR8
argument_list|(
name|sc
argument_list|,
operator|(
name|BAR_CSTRORM_INTMEM
operator|+
name|CSTORM_VF_TO_PF_OFFSET
argument_list|(
name|abs_fid
argument_list|)
operator|)
argument_list|,
name|pf_id
argument_list|)
expr_stmt|;
name|REG_WR8
argument_list|(
name|sc
argument_list|,
operator|(
name|BAR_TSTRORM_INTMEM
operator|+
name|TSTORM_VF_TO_PF_OFFSET
argument_list|(
name|abs_fid
argument_list|)
operator|)
argument_list|,
name|pf_id
argument_list|)
expr_stmt|;
name|REG_WR8
argument_list|(
name|sc
argument_list|,
operator|(
name|BAR_USTRORM_INTMEM
operator|+
name|USTORM_VF_TO_PF_OFFSET
argument_list|(
name|abs_fid
argument_list|)
operator|)
argument_list|,
name|pf_id
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|storm_memset_func_en
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|abs_fid
parameter_list|,
name|uint8_t
name|enable
parameter_list|)
block|{
name|REG_WR8
argument_list|(
name|sc
argument_list|,
operator|(
name|BAR_XSTRORM_INTMEM
operator|+
name|XSTORM_FUNC_EN_OFFSET
argument_list|(
name|abs_fid
argument_list|)
operator|)
argument_list|,
name|enable
argument_list|)
expr_stmt|;
name|REG_WR8
argument_list|(
name|sc
argument_list|,
operator|(
name|BAR_CSTRORM_INTMEM
operator|+
name|CSTORM_FUNC_EN_OFFSET
argument_list|(
name|abs_fid
argument_list|)
operator|)
argument_list|,
name|enable
argument_list|)
expr_stmt|;
name|REG_WR8
argument_list|(
name|sc
argument_list|,
operator|(
name|BAR_TSTRORM_INTMEM
operator|+
name|TSTORM_FUNC_EN_OFFSET
argument_list|(
name|abs_fid
argument_list|)
operator|)
argument_list|,
name|enable
argument_list|)
expr_stmt|;
name|REG_WR8
argument_list|(
name|sc
argument_list|,
operator|(
name|BAR_USTRORM_INTMEM
operator|+
name|USTORM_FUNC_EN_OFFSET
argument_list|(
name|abs_fid
argument_list|)
operator|)
argument_list|,
name|enable
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|storm_memset_eq_data
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|event_ring_data
modifier|*
name|eq_data
parameter_list|,
name|uint16_t
name|pfid
parameter_list|)
block|{
name|uint32_t
name|addr
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|addr
operator|=
operator|(
name|BAR_CSTRORM_INTMEM
operator|+
name|CSTORM_EVENT_RING_DATA_OFFSET
argument_list|(
name|pfid
argument_list|)
operator|)
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|event_ring_data
argument_list|)
expr_stmt|;
name|ecore_storm_memset_struct
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
name|eq_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|storm_memset_eq_prod
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|eq_prod
parameter_list|,
name|uint16_t
name|pfid
parameter_list|)
block|{
name|uint32_t
name|addr
init|=
operator|(
name|BAR_CSTRORM_INTMEM
operator|+
name|CSTORM_EVENT_RING_PROD_OFFSET
argument_list|(
name|pfid
argument_list|)
operator|)
decl_stmt|;
name|REG_WR16
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|eq_prod
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Post a slowpath command.  *  * A slowpath command is used to propagate a configuration change through  * the controller in a controlled manner, allowing each STORM processor and  * other H/W blocks to phase in the change.  The commands sent on the  * slowpath are referred to as ramrods.  Depending on the ramrod used the  * completion of the ramrod will occur in different ways.  Here's a  * breakdown of ramrods and how they complete:  *  * RAMROD_CMD_ID_ETH_PORT_SETUP  *   Used to setup the leading connection on a port.  Completes on the  *   Receive Completion Queue (RCQ) of that port (typically fp[0]).  *  * RAMROD_CMD_ID_ETH_CLIENT_SETUP  *   Used to setup an additional connection on a port.  Completes on the  *   RCQ of the multi-queue/RSS connection being initialized.  *  * RAMROD_CMD_ID_ETH_STAT_QUERY  *   Used to force the storm processors to update the statistics database  *   in host memory.  This ramrod is send on the leading connection CID and  *   completes as an index increment of the CSTORM on the default status  *   block.  *  * RAMROD_CMD_ID_ETH_UPDATE  *   Used to update the state of the leading connection, usually to udpate  *   the RSS indirection table.  Completes on the RCQ of the leading  *   connection. (Not currently used under FreeBSD until OS support becomes  *   available.)  *  * RAMROD_CMD_ID_ETH_HALT  *   Used when tearing down a connection prior to driver unload.  Completes  *   on the RCQ of the multi-queue/RSS connection being torn down.  Don't  *   use this on the leading connection.  *  * RAMROD_CMD_ID_ETH_SET_MAC  *   Sets the Unicast/Broadcast/Multicast used by the port.  Completes on  *   the RCQ of the leading connection.  *  * RAMROD_CMD_ID_ETH_CFC_DEL  *   Used when tearing down a conneciton prior to driver unload.  Completes  *   on the RCQ of the leading connection (since the current connection  *   has been completely removed from controller memory).  *  * RAMROD_CMD_ID_ETH_PORT_DEL  *   Used to tear down the leading connection prior to driver unload,  *   typically fp[0].  Completes as an index increment of the CSTORM on the  *   default status block.  *  * RAMROD_CMD_ID_ETH_FORWARD_SETUP  *   Used for connection offload.  Completes on the RCQ of the multi-queue  *   RSS connection that is being offloaded.  (Not currently used under  *   FreeBSD.)  *  * There can only be one command pending per function.  *  * Returns:  *   0 = Success, !0 = Failure.  */
end_comment

begin_comment
comment|/* must be called under the spq lock */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|eth_spe
modifier|*
name|bxe_sp_get_next
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|eth_spe
modifier|*
name|next_spe
init|=
name|sc
operator|->
name|spq_prod_bd
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|spq_prod_bd
operator|==
name|sc
operator|->
name|spq_last_bd
condition|)
block|{
comment|/* wrap back to the first eth_spq */
name|sc
operator|->
name|spq_prod_bd
operator|=
name|sc
operator|->
name|spq
expr_stmt|;
name|sc
operator|->
name|spq_prod_idx
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|spq_prod_bd
operator|++
expr_stmt|;
name|sc
operator|->
name|spq_prod_idx
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|next_spe
operator|)
return|;
block|}
end_function

begin_comment
comment|/* must be called under the spq lock */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|bxe_sp_prod_update
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|func
init|=
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
decl_stmt|;
comment|/*      * Make sure that BD data is updated before writing the producer.      * BD data is written to the memory, the producer is read from the      * memory, thus we need a full memory barrier to ensure the ordering.      */
name|mb
argument_list|()
expr_stmt|;
name|REG_WR16
argument_list|(
name|sc
argument_list|,
operator|(
name|BAR_XSTRORM_INTMEM
operator|+
name|XSTORM_SPQ_PROD_OFFSET
argument_list|(
name|func
argument_list|)
operator|)
argument_list|,
name|sc
operator|->
name|spq_prod_idx
argument_list|)
expr_stmt|;
name|bus_space_barrier
argument_list|(
name|sc
operator|->
name|bar
index|[
name|BAR0
index|]
operator|.
name|tag
argument_list|,
name|sc
operator|->
name|bar
index|[
name|BAR0
index|]
operator|.
name|handle
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * bxe_is_contextless_ramrod - check if the current command ends on EQ  *  * @cmd:      command to check  * @cmd_type: command type  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|bxe_is_contextless_ramrod
parameter_list|(
name|int
name|cmd
parameter_list|,
name|int
name|cmd_type
parameter_list|)
block|{
if|if
condition|(
operator|(
name|cmd_type
operator|==
name|NONE_CONNECTION_TYPE
operator|)
operator|||
operator|(
name|cmd
operator|==
name|RAMROD_CMD_ID_ETH_FORWARD_SETUP
operator|)
operator|||
operator|(
name|cmd
operator|==
name|RAMROD_CMD_ID_ETH_CLASSIFICATION_RULES
operator|)
operator|||
operator|(
name|cmd
operator|==
name|RAMROD_CMD_ID_ETH_FILTER_RULES
operator|)
operator|||
operator|(
name|cmd
operator|==
name|RAMROD_CMD_ID_ETH_MULTICAST_RULES
operator|)
operator|||
operator|(
name|cmd
operator|==
name|RAMROD_CMD_ID_ETH_SET_MAC
operator|)
operator|||
operator|(
name|cmd
operator|==
name|RAMROD_CMD_ID_ETH_RSS_UPDATE
operator|)
condition|)
block|{
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * bxe_sp_post - place a single command on an SP ring  *  * @sc:         driver handle  * @command:    command to place (e.g. SETUP, FILTER_RULES, etc.)  * @cid:        SW CID the command is related to  * @data_hi:    command private data address (high 32 bits)  * @data_lo:    command private data address (low 32 bits)  * @cmd_type:   command type (e.g. NONE, ETH)  *  * SP data is handled as if it's always an address pair, thus data fields are  * not swapped to little endian in upper functions. Instead this function swaps  * data as if it's two uint32 fields.  */
end_comment

begin_function
name|int
name|bxe_sp_post
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|command
parameter_list|,
name|int
name|cid
parameter_list|,
name|uint32_t
name|data_hi
parameter_list|,
name|uint32_t
name|data_lo
parameter_list|,
name|int
name|cmd_type
parameter_list|)
block|{
name|struct
name|eth_spe
modifier|*
name|spe
decl_stmt|;
name|uint16_t
name|type
decl_stmt|;
name|int
name|common
decl_stmt|;
name|common
operator|=
name|bxe_is_contextless_ramrod
argument_list|(
name|command
argument_list|,
name|cmd_type
argument_list|)
expr_stmt|;
name|BXE_SP_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
condition|)
block|{
if|if
condition|(
operator|!
name|atomic_load_acq_long
argument_list|(
operator|&
name|sc
operator|->
name|eq_spq_left
argument_list|)
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"EQ ring is full!\n"
argument_list|)
expr_stmt|;
name|BXE_SP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|atomic_load_acq_long
argument_list|(
operator|&
name|sc
operator|->
name|cq_spq_left
argument_list|)
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"SPQ ring is full!\n"
argument_list|)
expr_stmt|;
name|BXE_SP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|spe
operator|=
name|bxe_sp_get_next
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* CID needs port number to be encoded int it */
name|spe
operator|->
name|hdr
operator|.
name|conn_and_cmd_data
operator|=
name|htole32
argument_list|(
operator|(
name|command
operator|<<
name|SPE_HDR_T_CMD_ID_SHIFT
operator|)
operator||
name|HW_CID
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
operator|(
name|cmd_type
operator|<<
name|SPE_HDR_T_CONN_TYPE_SHIFT
operator|)
operator|&
name|SPE_HDR_T_CONN_TYPE
expr_stmt|;
comment|/* TBD: Check if it works for VFs */
name|type
operator||=
operator|(
operator|(
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
operator|<<
name|SPE_HDR_T_FUNCTION_ID_SHIFT
operator|)
operator|&
name|SPE_HDR_T_FUNCTION_ID
operator|)
expr_stmt|;
name|spe
operator|->
name|hdr
operator|.
name|type
operator|=
name|htole16
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|spe
operator|->
name|data
operator|.
name|update_data_addr
operator|.
name|hi
operator|=
name|htole32
argument_list|(
name|data_hi
argument_list|)
expr_stmt|;
name|spe
operator|->
name|data
operator|.
name|update_data_addr
operator|.
name|lo
operator|=
name|htole32
argument_list|(
name|data_lo
argument_list|)
expr_stmt|;
comment|/*      * It's ok if the actual decrement is issued towards the memory      * somewhere between the lock and unlock. Thus no more explict      * memory barrier is needed.      */
if|if
condition|(
name|common
condition|)
block|{
name|atomic_subtract_acq_long
argument_list|(
operator|&
name|sc
operator|->
name|eq_spq_left
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|atomic_subtract_acq_long
argument_list|(
operator|&
name|sc
operator|->
name|cq_spq_left
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_SP
argument_list|,
literal|"SPQE -> %#jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|spq_dma
operator|.
name|paddr
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_SP
argument_list|,
literal|"FUNC_RDATA -> %p / %#jx\n"
argument_list|,
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|func_rdata
argument_list|)
argument_list|,
operator|(
name|uintmax_t
operator|)
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|func_rdata
argument_list|)
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_SP
argument_list|,
literal|"SPQE[%x] (%x:%x) (cmd, common?) (%d,%d) hw_cid %x data (%x:%x) type(0x%x) left (CQ, EQ) (%lx,%lx)\n"
argument_list|,
name|sc
operator|->
name|spq_prod_idx
argument_list|,
operator|(
name|uint32_t
operator|)
name|U64_HI
argument_list|(
name|sc
operator|->
name|spq_dma
operator|.
name|paddr
argument_list|)
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|U64_LO
argument_list|(
name|sc
operator|->
name|spq_dma
operator|.
name|paddr
argument_list|)
operator|+
operator|(
name|uint8_t
operator|*
operator|)
name|sc
operator|->
name|spq_prod_bd
operator|-
operator|(
name|uint8_t
operator|*
operator|)
name|sc
operator|->
name|spq
argument_list|)
argument_list|,
name|command
argument_list|,
name|common
argument_list|,
name|HW_CID
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|)
argument_list|,
name|data_hi
argument_list|,
name|data_lo
argument_list|,
name|type
argument_list|,
name|atomic_load_acq_long
argument_list|(
operator|&
name|sc
operator|->
name|cq_spq_left
argument_list|)
argument_list|,
name|atomic_load_acq_long
argument_list|(
operator|&
name|sc
operator|->
name|eq_spq_left
argument_list|)
argument_list|)
expr_stmt|;
name|bxe_sp_prod_update
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BXE_SP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * bxe_debug_print_ind_table - prints the indirection table configuration.  *  * @sc: driver hanlde  * @p:  pointer to rss configuration  */
end_comment

begin_comment
comment|/*  * FreeBSD Device probe function.  *  * Compares the device found to the driver's list of supported devices and  * reports back to the bsd loader whether this is the right driver for the device.  * This is the driver entry function called from the "kldload" command.  *  * Returns:  *   BUS_PROBE_DEFAULT on success, positive value on failure.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bxe_device_type
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|descbuf
decl_stmt|;
name|uint16_t
name|did
decl_stmt|,
name|sdid
decl_stmt|,
name|svid
decl_stmt|,
name|vid
decl_stmt|;
comment|/* Find our device structure */
name|t
operator|=
name|bxe_devs
expr_stmt|;
comment|/* Get the data for the device to be probed. */
name|vid
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|did
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|svid
operator|=
name|pci_get_subvendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sdid
operator|=
name|pci_get_subdevice
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Look through the list of known devices for a match. */
while|while
condition|(
name|t
operator|->
name|bxe_name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|vid
operator|==
name|t
operator|->
name|bxe_vid
operator|)
operator|&&
operator|(
name|did
operator|==
name|t
operator|->
name|bxe_did
operator|)
operator|&&
operator|(
operator|(
name|svid
operator|==
name|t
operator|->
name|bxe_svid
operator|)
operator|||
operator|(
name|t
operator|->
name|bxe_svid
operator|==
name|PCI_ANY_ID
operator|)
operator|)
operator|&&
operator|(
operator|(
name|sdid
operator|==
name|t
operator|->
name|bxe_sdid
operator|)
operator|||
operator|(
name|t
operator|->
name|bxe_sdid
operator|==
name|PCI_ANY_ID
operator|)
operator|)
condition|)
block|{
name|descbuf
operator|=
name|malloc
argument_list|(
name|BXE_DEVDESC_MAX
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|descbuf
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* Print out the device identity. */
name|snprintf
argument_list|(
name|descbuf
argument_list|,
name|BXE_DEVDESC_MAX
argument_list|,
literal|"%s (%c%d) BXE v:%s\n"
argument_list|,
name|t
operator|->
name|bxe_name
argument_list|,
operator|(
operator|(
operator|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_REVID
argument_list|,
literal|4
argument_list|)
operator|&
literal|0xf0
operator|)
operator|>>
literal|4
operator|)
operator|+
literal|'A'
operator|)
argument_list|,
operator|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_REVID
argument_list|,
literal|4
argument_list|)
operator|&
literal|0xf
operator|)
argument_list|,
name|BXE_DRIVER_VERSION
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|descbuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|descbuf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
name|t
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_init_mutexes
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|BXE_CORE_LOCK_SX
name|snprintf
argument_list|(
name|sc
operator|->
name|core_sx_name
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|core_sx_name
argument_list|)
argument_list|,
literal|"bxe%d_core_lock"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|sc
operator|->
name|core_sx
argument_list|,
name|sc
operator|->
name|core_sx_name
argument_list|)
expr_stmt|;
else|#
directive|else
name|snprintf
argument_list|(
name|sc
operator|->
name|core_mtx_name
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|core_mtx_name
argument_list|)
argument_list|,
literal|"bxe%d_core_lock"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|core_mtx
argument_list|,
name|sc
operator|->
name|core_mtx_name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|snprintf
argument_list|(
name|sc
operator|->
name|sp_mtx_name
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sp_mtx_name
argument_list|)
argument_list|,
literal|"bxe%d_sp_lock"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sp_mtx
argument_list|,
name|sc
operator|->
name|sp_mtx_name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|sc
operator|->
name|dmae_mtx_name
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|dmae_mtx_name
argument_list|)
argument_list|,
literal|"bxe%d_dmae_lock"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|dmae_mtx
argument_list|,
name|sc
operator|->
name|dmae_mtx_name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|sc
operator|->
name|port
operator|.
name|phy_mtx_name
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|port
operator|.
name|phy_mtx_name
argument_list|)
argument_list|,
literal|"bxe%d_phy_lock"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|port
operator|.
name|phy_mtx
argument_list|,
name|sc
operator|->
name|port
operator|.
name|phy_mtx_name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|sc
operator|->
name|fwmb_mtx_name
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|fwmb_mtx_name
argument_list|)
argument_list|,
literal|"bxe%d_fwmb_lock"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|fwmb_mtx
argument_list|,
name|sc
operator|->
name|fwmb_mtx_name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|sc
operator|->
name|print_mtx_name
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|print_mtx_name
argument_list|)
argument_list|,
literal|"bxe%d_print_lock"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|print_mtx
operator|)
argument_list|,
name|sc
operator|->
name|print_mtx_name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|sc
operator|->
name|stats_mtx_name
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|stats_mtx_name
argument_list|)
argument_list|,
literal|"bxe%d_stats_lock"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|stats_mtx
operator|)
argument_list|,
name|sc
operator|->
name|stats_mtx_name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|sc
operator|->
name|mcast_mtx_name
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|mcast_mtx_name
argument_list|)
argument_list|,
literal|"bxe%d_mcast_lock"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|mcast_mtx
operator|)
argument_list|,
name|sc
operator|->
name|mcast_mtx_name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_release_mutexes
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|BXE_CORE_LOCK_SX
name|sx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|core_sx
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|sc
operator|->
name|core_mtx
argument_list|)
condition|)
block|{
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|core_mtx
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|sc
operator|->
name|sp_mtx
argument_list|)
condition|)
block|{
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sp_mtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|sc
operator|->
name|dmae_mtx
argument_list|)
condition|)
block|{
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|dmae_mtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|sc
operator|->
name|port
operator|.
name|phy_mtx
argument_list|)
condition|)
block|{
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|port
operator|.
name|phy_mtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|sc
operator|->
name|fwmb_mtx
argument_list|)
condition|)
block|{
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|fwmb_mtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|sc
operator|->
name|print_mtx
argument_list|)
condition|)
block|{
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|print_mtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|sc
operator|->
name|stats_mtx
argument_list|)
condition|)
block|{
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|stats_mtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|sc
operator|->
name|mcast_mtx
argument_list|)
condition|)
block|{
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|mcast_mtx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_tx_disable
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|if_t
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
comment|/* tell the stack the driver is stopped and TX queue is full */
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
block|{
name|if_setdrvflags
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_drv_pulse
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|SHMEM_WR
argument_list|(
name|sc
argument_list|,
name|func_mb
index|[
name|SC_FW_MB_IDX
argument_list|(
name|sc
argument_list|)
index|]
operator|.
name|drv_pulse_mb
argument_list|,
name|sc
operator|->
name|fw_drv_pulse_wr_seq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint16_t
name|bxe_tx_avail
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|)
block|{
name|int16_t
name|used
decl_stmt|;
name|uint16_t
name|prod
decl_stmt|;
name|uint16_t
name|cons
decl_stmt|;
name|prod
operator|=
name|fp
operator|->
name|tx_bd_prod
expr_stmt|;
name|cons
operator|=
name|fp
operator|->
name|tx_bd_cons
expr_stmt|;
name|used
operator|=
name|SUB_S16
argument_list|(
name|prod
argument_list|,
name|cons
argument_list|)
expr_stmt|;
return|return
call|(
name|int16_t
call|)
argument_list|(
name|sc
operator|->
name|tx_ring_size
argument_list|)
operator|-
name|used
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|bxe_tx_queue_has_work
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|)
block|{
name|uint16_t
name|hw_cons
decl_stmt|;
name|mb
argument_list|()
expr_stmt|;
comment|/* status block fields can change */
name|hw_cons
operator|=
name|le16toh
argument_list|(
operator|*
name|fp
operator|->
name|tx_cons_sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|hw_cons
operator|!=
name|fp
operator|->
name|tx_pkt_cons
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint8_t
name|bxe_has_tx_work
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|)
block|{
comment|/* expand this for multi-cos if ever supported */
return|return
operator|(
name|bxe_tx_queue_has_work
argument_list|(
name|fp
argument_list|)
operator|)
condition|?
name|TRUE
else|:
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|bxe_has_rx_work
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|)
block|{
name|uint16_t
name|rx_cq_cons_sb
decl_stmt|;
name|mb
argument_list|()
expr_stmt|;
comment|/* status block fields can change */
name|rx_cq_cons_sb
operator|=
name|le16toh
argument_list|(
operator|*
name|fp
operator|->
name|rx_cq_cons_sb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rx_cq_cons_sb
operator|&
name|RCQ_MAX
operator|)
operator|==
name|RCQ_MAX
condition|)
name|rx_cq_cons_sb
operator|++
expr_stmt|;
return|return
operator|(
name|fp
operator|->
name|rx_cq_cons
operator|!=
name|rx_cq_cons_sb
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_sp_event
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|union
name|eth_rx_cqe
modifier|*
name|rr_cqe
parameter_list|)
block|{
name|int
name|cid
init|=
name|SW_CID
argument_list|(
name|rr_cqe
operator|->
name|ramrod_cqe
operator|.
name|conn_and_cmd_data
argument_list|)
decl_stmt|;
name|int
name|command
init|=
name|CQE_CMD
argument_list|(
name|rr_cqe
operator|->
name|ramrod_cqe
operator|.
name|conn_and_cmd_data
argument_list|)
decl_stmt|;
name|enum
name|ecore_queue_cmd
name|drv_cmd
init|=
name|ECORE_Q_CMD_MAX
decl_stmt|;
name|struct
name|ecore_queue_sp_obj
modifier|*
name|q_obj
init|=
operator|&
name|BXE_SP_OBJ
argument_list|(
name|sc
argument_list|,
name|fp
argument_list|)
operator|.
name|q_obj
decl_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_SP
argument_list|,
literal|"fp=%d cid=%d got ramrod #%d state is %x type is %d\n"
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|cid
argument_list|,
name|command
argument_list|,
name|sc
operator|->
name|state
argument_list|,
name|rr_cqe
operator|->
name|ramrod_cqe
operator|.
name|ramrod_type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
operator|(
name|RAMROD_CMD_ID_ETH_CLIENT_UPDATE
operator|)
case|:
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_SP
argument_list|,
literal|"got UPDATE ramrod. CID %d\n"
argument_list|,
name|cid
argument_list|)
expr_stmt|;
name|drv_cmd
operator|=
name|ECORE_Q_CMD_UPDATE
expr_stmt|;
break|break;
case|case
operator|(
name|RAMROD_CMD_ID_ETH_CLIENT_SETUP
operator|)
case|:
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_SP
argument_list|,
literal|"got MULTI[%d] setup ramrod\n"
argument_list|,
name|cid
argument_list|)
expr_stmt|;
name|drv_cmd
operator|=
name|ECORE_Q_CMD_SETUP
expr_stmt|;
break|break;
case|case
operator|(
name|RAMROD_CMD_ID_ETH_TX_QUEUE_SETUP
operator|)
case|:
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_SP
argument_list|,
literal|"got MULTI[%d] tx-only setup ramrod\n"
argument_list|,
name|cid
argument_list|)
expr_stmt|;
name|drv_cmd
operator|=
name|ECORE_Q_CMD_SETUP_TX_ONLY
expr_stmt|;
break|break;
case|case
operator|(
name|RAMROD_CMD_ID_ETH_HALT
operator|)
case|:
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_SP
argument_list|,
literal|"got MULTI[%d] halt ramrod\n"
argument_list|,
name|cid
argument_list|)
expr_stmt|;
name|drv_cmd
operator|=
name|ECORE_Q_CMD_HALT
expr_stmt|;
break|break;
case|case
operator|(
name|RAMROD_CMD_ID_ETH_TERMINATE
operator|)
case|:
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_SP
argument_list|,
literal|"got MULTI[%d] teminate ramrod\n"
argument_list|,
name|cid
argument_list|)
expr_stmt|;
name|drv_cmd
operator|=
name|ECORE_Q_CMD_TERMINATE
expr_stmt|;
break|break;
case|case
operator|(
name|RAMROD_CMD_ID_ETH_EMPTY
operator|)
case|:
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_SP
argument_list|,
literal|"got MULTI[%d] empty ramrod\n"
argument_list|,
name|cid
argument_list|)
expr_stmt|;
name|drv_cmd
operator|=
name|ECORE_Q_CMD_EMPTY
expr_stmt|;
break|break;
default|default:
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_SP
argument_list|,
literal|"ERROR: unexpected MC reply (%d) on fp[%d]\n"
argument_list|,
name|command
argument_list|,
name|fp
operator|->
name|index
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|drv_cmd
operator|!=
name|ECORE_Q_CMD_MAX
operator|)
operator|&&
name|q_obj
operator|->
name|complete_cmd
argument_list|(
name|sc
argument_list|,
name|q_obj
argument_list|,
name|drv_cmd
argument_list|)
condition|)
block|{
comment|/*          * q_obj->complete_cmd() failure means that this was          * an unexpected completion.          *          * In this case we don't want to increase the sc->spq_left          * because apparently we haven't sent this command the first          * place.          */
comment|// bxe_panic(sc, ("Unexpected SP completion\n"));
return|return;
block|}
name|atomic_add_acq_long
argument_list|(
operator|&
name|sc
operator|->
name|cq_spq_left
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_SP
argument_list|,
literal|"sc->cq_spq_left 0x%lx\n"
argument_list|,
name|atomic_load_acq_long
argument_list|(
operator|&
name|sc
operator|->
name|cq_spq_left
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The current mbuf is part of an aggregation. Move the mbuf into the TPA  * aggregation queue, put an empty mbuf back onto the receive chain, and mark  * the current aggregation queue as in-progress.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_tpa_start
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|uint16_t
name|queue
parameter_list|,
name|uint16_t
name|cons
parameter_list|,
name|uint16_t
name|prod
parameter_list|,
name|struct
name|eth_fast_path_rx_cqe
modifier|*
name|cqe
parameter_list|)
block|{
name|struct
name|bxe_sw_rx_bd
name|tmp_bd
decl_stmt|;
name|struct
name|bxe_sw_rx_bd
modifier|*
name|rx_buf
decl_stmt|;
name|struct
name|eth_rx_bd
modifier|*
name|rx_bd
decl_stmt|;
name|int
name|max_agg_queues
decl_stmt|;
name|struct
name|bxe_sw_tpa_info
modifier|*
name|tpa_info
init|=
operator|&
name|fp
operator|->
name|rx_tpa_info
index|[
name|queue
index|]
decl_stmt|;
name|uint16_t
name|index
decl_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LRO
argument_list|,
literal|"fp[%02d].tpa[%02d] TPA START "
literal|"cons=%d prod=%d\n"
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|queue
argument_list|,
name|cons
argument_list|,
name|prod
argument_list|)
expr_stmt|;
name|max_agg_queues
operator|=
name|MAX_AGG_QS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|queue
operator|<
name|max_agg_queues
operator|)
argument_list|,
operator|(
literal|"fp[%02d] invalid aggr queue (%d>= %d)!"
operator|,
name|fp
operator|->
name|index
operator|,
name|queue
operator|,
name|max_agg_queues
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|tpa_info
operator|->
name|state
operator|==
name|BXE_TPA_STATE_STOP
operator|)
argument_list|,
operator|(
literal|"fp[%02d].tpa[%02d] starting aggr on queue not stopped!"
operator|,
name|fp
operator|->
name|index
operator|,
name|queue
operator|)
argument_list|)
expr_stmt|;
comment|/* copy the existing mbuf and mapping from the TPA pool */
name|tmp_bd
operator|=
name|tpa_info
operator|->
name|bd
expr_stmt|;
if|if
condition|(
name|tmp_bd
operator|.
name|m
operator|==
name|NULL
condition|)
block|{
name|uint32_t
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|cqe
expr_stmt|;
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"fp[%02d].tpa[%02d] cons[%d] prod[%d]mbuf not allocated!\n"
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|queue
argument_list|,
name|cons
argument_list|,
name|prod
argument_list|)
expr_stmt|;
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"cqe [0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x]\n"
argument_list|,
operator|*
name|tmp
argument_list|,
operator|*
operator|(
name|tmp
operator|+
literal|1
operator|)
argument_list|,
operator|*
operator|(
name|tmp
operator|+
literal|2
operator|)
argument_list|,
operator|*
operator|(
name|tmp
operator|+
literal|3
operator|)
argument_list|,
operator|*
operator|(
name|tmp
operator|+
literal|4
operator|)
argument_list|,
operator|*
operator|(
name|tmp
operator|+
literal|5
operator|)
argument_list|,
operator|*
operator|(
name|tmp
operator|+
literal|6
operator|)
argument_list|,
operator|*
operator|(
name|tmp
operator|+
literal|7
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX Error handling? */
return|return;
block|}
comment|/* change the TPA queue to the start state */
name|tpa_info
operator|->
name|state
operator|=
name|BXE_TPA_STATE_START
expr_stmt|;
name|tpa_info
operator|->
name|placement_offset
operator|=
name|cqe
operator|->
name|placement_offset
expr_stmt|;
name|tpa_info
operator|->
name|parsing_flags
operator|=
name|le16toh
argument_list|(
name|cqe
operator|->
name|pars_flags
operator|.
name|flags
argument_list|)
expr_stmt|;
name|tpa_info
operator|->
name|vlan_tag
operator|=
name|le16toh
argument_list|(
name|cqe
operator|->
name|vlan_tag
argument_list|)
expr_stmt|;
name|tpa_info
operator|->
name|len_on_bd
operator|=
name|le16toh
argument_list|(
name|cqe
operator|->
name|len_on_bd
argument_list|)
expr_stmt|;
name|fp
operator|->
name|rx_tpa_queue_used
operator||=
operator|(
literal|1
operator|<<
name|queue
operator|)
expr_stmt|;
comment|/*      * If all the buffer descriptors are filled with mbufs then fill in      * the current consumer index with a new BD. Else if a maximum Rx      * buffer limit is imposed then fill in the next producer index.      */
name|index
operator|=
operator|(
name|sc
operator|->
name|max_rx_bufs
operator|!=
name|RX_BD_USABLE
operator|)
condition|?
name|prod
else|:
name|cons
expr_stmt|;
comment|/* move the received mbuf and mapping to TPA pool */
name|tpa_info
operator|->
name|bd
operator|=
name|fp
operator|->
name|rx_mbuf_chain
index|[
name|cons
index|]
expr_stmt|;
comment|/* release any existing RX BD mbuf mappings */
if|if
condition|(
name|cons
operator|!=
name|index
condition|)
block|{
name|rx_buf
operator|=
operator|&
name|fp
operator|->
name|rx_mbuf_chain
index|[
name|cons
index|]
expr_stmt|;
if|if
condition|(
name|rx_buf
operator|->
name|m_map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|rx_buf
operator|->
name|m_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|rx_buf
operator|->
name|m_map
argument_list|)
expr_stmt|;
block|}
comment|/*          * We get here when the maximum number of rx buffers is less than          * RX_BD_USABLE. The mbuf is already saved above so it's OK to NULL          * it out here without concern of a memory leak.          */
name|fp
operator|->
name|rx_mbuf_chain
index|[
name|cons
index|]
operator|.
name|m
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* update the Rx SW BD with the mbuf info from the TPA pool */
name|fp
operator|->
name|rx_mbuf_chain
index|[
name|index
index|]
operator|=
name|tmp_bd
expr_stmt|;
comment|/* update the Rx BD with the empty mbuf phys address from the TPA pool */
name|rx_bd
operator|=
operator|&
name|fp
operator|->
name|rx_chain
index|[
name|index
index|]
expr_stmt|;
name|rx_bd
operator|->
name|addr_hi
operator|=
name|htole32
argument_list|(
name|U64_HI
argument_list|(
name|tpa_info
operator|->
name|seg
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|rx_bd
operator|->
name|addr_lo
operator|=
name|htole32
argument_list|(
name|U64_LO
argument_list|(
name|tpa_info
operator|->
name|seg
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * When a TPA aggregation is completed, loop through the individual mbufs  * of the aggregation, combining them into a single mbuf which will be sent  * up the stack. Refill all freed SGEs with mbufs as we go along.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_fill_frag_mbuf
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|struct
name|bxe_sw_tpa_info
modifier|*
name|tpa_info
parameter_list|,
name|uint16_t
name|queue
parameter_list|,
name|uint16_t
name|pages
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|eth_end_agg_rx_cqe
modifier|*
name|cqe
parameter_list|,
name|uint16_t
name|cqe_idx
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_frag
decl_stmt|;
name|uint32_t
name|frag_len
decl_stmt|,
name|frag_size
decl_stmt|,
name|i
decl_stmt|;
name|uint16_t
name|sge_idx
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|int
name|j
decl_stmt|;
name|frag_size
operator|=
name|le16toh
argument_list|(
name|cqe
operator|->
name|pkt_len
argument_list|)
operator|-
name|tpa_info
operator|->
name|len_on_bd
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LRO
argument_list|,
literal|"fp[%02d].tpa[%02d] TPA fill len_on_bd=%d frag_size=%d pages=%d\n"
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|queue
argument_list|,
name|tpa_info
operator|->
name|len_on_bd
argument_list|,
name|frag_size
argument_list|,
name|pages
argument_list|)
expr_stmt|;
comment|/* make sure the aggregated frame is not too big to handle */
if|if
condition|(
name|pages
operator|>
literal|8
operator|*
name|PAGES_PER_SGE
condition|)
block|{
name|uint32_t
modifier|*
name|tmp
init|=
operator|(
name|uint32_t
operator|*
operator|)
name|cqe
decl_stmt|;
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"fp[%02d].sge[0x%04x] has too many pages (%d)! "
literal|"pkt_len=%d len_on_bd=%d frag_size=%d\n"
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|cqe_idx
argument_list|,
name|pages
argument_list|,
name|le16toh
argument_list|(
name|cqe
operator|->
name|pkt_len
argument_list|)
argument_list|,
name|tpa_info
operator|->
name|len_on_bd
argument_list|,
name|frag_size
argument_list|)
expr_stmt|;
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"cqe [0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x]\n"
argument_list|,
operator|*
name|tmp
argument_list|,
operator|*
operator|(
name|tmp
operator|+
literal|1
operator|)
argument_list|,
operator|*
operator|(
name|tmp
operator|+
literal|2
operator|)
argument_list|,
operator|*
operator|(
name|tmp
operator|+
literal|3
operator|)
argument_list|,
operator|*
operator|(
name|tmp
operator|+
literal|4
operator|)
argument_list|,
operator|*
operator|(
name|tmp
operator|+
literal|5
operator|)
argument_list|,
operator|*
operator|(
name|tmp
operator|+
literal|6
operator|)
argument_list|,
operator|*
operator|(
name|tmp
operator|+
literal|7
operator|)
argument_list|)
expr_stmt|;
name|bxe_panic
argument_list|(
name|sc
argument_list|,
operator|(
literal|"sge page count error\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/*      * Scan through the scatter gather list pulling individual mbufs into a      * single mbuf for the host stack.      */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|pages
condition|;
name|i
operator|+=
name|PAGES_PER_SGE
operator|,
name|j
operator|++
control|)
block|{
name|sge_idx
operator|=
name|RX_SGE
argument_list|(
name|le16toh
argument_list|(
name|cqe
operator|->
name|sgl_or_raw_data
operator|.
name|sgl
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/*          * Firmware gives the indices of the SGE as if the ring is an array          * (meaning that the "next" element will consume 2 indices).          */
name|frag_len
operator|=
name|min
argument_list|(
name|frag_size
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|SGE_PAGES
argument_list|)
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LRO
argument_list|,
literal|"fp[%02d].tpa[%02d] TPA fill i=%d j=%d "
literal|"sge_idx=%d frag_size=%d frag_len=%d\n"
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|queue
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|sge_idx
argument_list|,
name|frag_size
argument_list|,
name|frag_len
argument_list|)
expr_stmt|;
name|m_frag
operator|=
name|fp
operator|->
name|rx_sge_mbuf_chain
index|[
name|sge_idx
index|]
operator|.
name|m
expr_stmt|;
comment|/* allocate a new mbuf for the SGE */
name|rc
operator|=
name|bxe_alloc_rx_sge_mbuf
argument_list|(
name|fp
argument_list|,
name|sge_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
comment|/* Leave all remaining SGEs in the ring! */
return|return
operator|(
name|rc
operator|)
return|;
block|}
comment|/* update the fragment length */
name|m_frag
operator|->
name|m_len
operator|=
name|frag_len
expr_stmt|;
comment|/* concatenate the fragment to the head mbuf */
name|m_cat
argument_list|(
name|m
argument_list|,
name|m_frag
argument_list|)
expr_stmt|;
name|fp
operator|->
name|eth_q_stats
operator|.
name|mbuf_alloc_sge
operator|--
expr_stmt|;
comment|/* update the TPA mbuf size and remaining fragment size */
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|frag_len
expr_stmt|;
name|frag_size
operator|-=
name|frag_len
expr_stmt|;
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LRO
argument_list|,
literal|"fp[%02d].tpa[%02d] TPA fill done frag_size=%d\n"
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|queue
argument_list|,
name|frag_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|bxe_clear_sge_mask_next_elems
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|RX_SGE_NUM_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|int
name|idx
init|=
name|RX_SGE_TOTAL_PER_PAGE
operator|*
name|i
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
block|{
name|BIT_VEC64_CLEAR_BIT
argument_list|(
name|fp
operator|->
name|sge_mask
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|idx
operator|--
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|bxe_init_sge_ring_bit_mask
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|)
block|{
comment|/* set the mask to all 1's, it's faster to compare to 0 than to 0xf's */
name|memset
argument_list|(
name|fp
operator|->
name|sge_mask
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|fp
operator|->
name|sge_mask
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Clear the two last indices in the page to 1. These are the indices that      * correspond to the "next" element, hence will never be indicated and      * should be removed from the calculations.      */
name|bxe_clear_sge_mask_next_elems
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|bxe_update_last_max_sge
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|uint16_t
name|idx
parameter_list|)
block|{
name|uint16_t
name|last_max
init|=
name|fp
operator|->
name|last_max_sge
decl_stmt|;
if|if
condition|(
name|SUB_S16
argument_list|(
name|idx
argument_list|,
name|last_max
argument_list|)
operator|>
literal|0
condition|)
block|{
name|fp
operator|->
name|last_max_sge
operator|=
name|idx
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|bxe_update_sge_prod
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|uint16_t
name|sge_len
parameter_list|,
name|union
name|eth_sgl_or_raw_data
modifier|*
name|cqe
parameter_list|)
block|{
name|uint16_t
name|last_max
decl_stmt|,
name|last_elem
decl_stmt|,
name|first_elem
decl_stmt|;
name|uint16_t
name|delta
init|=
literal|0
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|sge_len
condition|)
block|{
return|return;
block|}
comment|/* first mark all used pages */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sge_len
condition|;
name|i
operator|++
control|)
block|{
name|BIT_VEC64_CLEAR_BIT
argument_list|(
name|fp
operator|->
name|sge_mask
argument_list|,
name|RX_SGE
argument_list|(
name|le16toh
argument_list|(
name|cqe
operator|->
name|sgl
index|[
name|i
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LRO
argument_list|,
literal|"fp[%02d] fp_cqe->sgl[%d] = %d\n"
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|sge_len
operator|-
literal|1
argument_list|,
name|le16toh
argument_list|(
name|cqe
operator|->
name|sgl
index|[
name|sge_len
operator|-
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* assume that the last SGE index is the biggest */
name|bxe_update_last_max_sge
argument_list|(
name|fp
argument_list|,
name|le16toh
argument_list|(
name|cqe
operator|->
name|sgl
index|[
name|sge_len
operator|-
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|last_max
operator|=
name|RX_SGE
argument_list|(
name|fp
operator|->
name|last_max_sge
argument_list|)
expr_stmt|;
name|last_elem
operator|=
name|last_max
operator|>>
name|BIT_VEC64_ELEM_SHIFT
expr_stmt|;
name|first_elem
operator|=
name|RX_SGE
argument_list|(
name|fp
operator|->
name|rx_sge_prod
argument_list|)
operator|>>
name|BIT_VEC64_ELEM_SHIFT
expr_stmt|;
comment|/* if ring is not full */
if|if
condition|(
name|last_elem
operator|+
literal|1
operator|!=
name|first_elem
condition|)
block|{
name|last_elem
operator|++
expr_stmt|;
block|}
comment|/* now update the prod */
for|for
control|(
name|i
operator|=
name|first_elem
init|;
name|i
operator|!=
name|last_elem
condition|;
name|i
operator|=
name|RX_SGE_NEXT_MASK_ELEM
argument_list|(
name|i
argument_list|)
control|)
block|{
if|if
condition|(
name|__predict_true
argument_list|(
name|fp
operator|->
name|sge_mask
index|[
name|i
index|]
argument_list|)
condition|)
block|{
break|break;
block|}
name|fp
operator|->
name|sge_mask
index|[
name|i
index|]
operator|=
name|BIT_VEC64_ELEM_ONE_MASK
expr_stmt|;
name|delta
operator|+=
name|BIT_VEC64_ELEM_SZ
expr_stmt|;
block|}
if|if
condition|(
name|delta
operator|>
literal|0
condition|)
block|{
name|fp
operator|->
name|rx_sge_prod
operator|+=
name|delta
expr_stmt|;
comment|/* clear page-end entries */
name|bxe_clear_sge_mask_next_elems
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LRO
argument_list|,
literal|"fp[%02d] fp->last_max_sge=%d fp->rx_sge_prod=%d\n"
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|fp
operator|->
name|last_max_sge
argument_list|,
name|fp
operator|->
name|rx_sge_prod
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The aggregation on the current TPA queue has completed. Pull the individual  * mbuf fragments together into a single mbuf, perform all necessary checksum  * calculations, and send the resuting mbuf to the stack.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_tpa_stop
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|struct
name|bxe_sw_tpa_info
modifier|*
name|tpa_info
parameter_list|,
name|uint16_t
name|queue
parameter_list|,
name|uint16_t
name|pages
parameter_list|,
name|struct
name|eth_end_agg_rx_cqe
modifier|*
name|cqe
parameter_list|,
name|uint16_t
name|cqe_idx
parameter_list|)
block|{
name|if_t
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LRO
argument_list|,
literal|"fp[%02d].tpa[%02d] pad=%d pkt_len=%d pages=%d vlan=%d\n"
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|queue
argument_list|,
name|tpa_info
operator|->
name|placement_offset
argument_list|,
name|le16toh
argument_list|(
name|cqe
operator|->
name|pkt_len
argument_list|)
argument_list|,
name|pages
argument_list|,
name|tpa_info
operator|->
name|vlan_tag
argument_list|)
expr_stmt|;
name|m
operator|=
name|tpa_info
operator|->
name|bd
operator|.
name|m
expr_stmt|;
comment|/* allocate a replacement before modifying existing mbuf */
name|rc
operator|=
name|bxe_alloc_rx_tpa_mbuf
argument_list|(
name|fp
argument_list|,
name|queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
comment|/* drop the frame and log an error */
name|fp
operator|->
name|eth_q_stats
operator|.
name|rx_soft_errors
operator|++
expr_stmt|;
goto|goto
name|bxe_tpa_stop_exit
goto|;
block|}
comment|/* we have a replacement, fixup the current mbuf */
name|m_adj
argument_list|(
name|m
argument_list|,
name|tpa_info
operator|->
name|placement_offset
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|tpa_info
operator|->
name|len_on_bd
expr_stmt|;
comment|/* mark the checksums valid (taken care of by the firmware) */
name|fp
operator|->
name|eth_q_stats
operator|.
name|rx_ofld_frames_csum_ip
operator|++
expr_stmt|;
name|fp
operator|->
name|eth_q_stats
operator|.
name|rx_ofld_frames_csum_tcp_udp
operator|++
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xffff
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
operator|(
name|CSUM_IP_CHECKED
operator||
name|CSUM_IP_VALID
operator||
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
expr_stmt|;
comment|/* aggregate all of the SGEs into a single mbuf */
name|rc
operator|=
name|bxe_fill_frag_mbuf
argument_list|(
name|sc
argument_list|,
name|fp
argument_list|,
name|tpa_info
argument_list|,
name|queue
argument_list|,
name|pages
argument_list|,
name|m
argument_list|,
name|cqe
argument_list|,
name|cqe_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
comment|/* drop the packet and log an error */
name|fp
operator|->
name|eth_q_stats
operator|.
name|rx_soft_errors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|tpa_info
operator|->
name|parsing_flags
operator|&
name|PARSING_FLAGS_INNER_VLAN_EXIST
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|=
name|tpa_info
operator|->
name|vlan_tag
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_VLANTAG
expr_stmt|;
block|}
comment|/* assign packet to this interface interface */
name|if_setrcvif
argument_list|(
name|m
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
comment|/* specify what RSS queue was used for this flow */
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
name|fp
operator|->
name|index
expr_stmt|;
name|BXE_SET_FLOWID
argument_list|(
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_IPACKETS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fp
operator|->
name|eth_q_stats
operator|.
name|rx_tpa_pkts
operator|++
expr_stmt|;
comment|/* pass the frame to the stack */
name|if_input
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* we passed an mbuf up the stack or dropped the frame */
name|fp
operator|->
name|eth_q_stats
operator|.
name|mbuf_alloc_tpa
operator|--
expr_stmt|;
name|bxe_tpa_stop_exit
label|:
name|fp
operator|->
name|rx_tpa_info
index|[
name|queue
index|]
operator|.
name|state
operator|=
name|BXE_TPA_STATE_STOP
expr_stmt|;
name|fp
operator|->
name|rx_tpa_queue_used
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|queue
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|bxe_service_rxsgl
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|uint16_t
name|len
parameter_list|,
name|uint16_t
name|lenonbd
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|eth_fast_path_rx_cqe
modifier|*
name|cqe_fp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_frag
decl_stmt|;
name|uint16_t
name|frags
decl_stmt|,
name|frag_len
decl_stmt|;
name|uint16_t
name|sge_idx
init|=
literal|0
decl_stmt|;
name|uint16_t
name|j
decl_stmt|;
name|uint8_t
name|i
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
name|uint32_t
name|frag_size
decl_stmt|;
comment|/* adjust the mbuf */
name|m
operator|->
name|m_len
operator|=
name|lenonbd
expr_stmt|;
name|frag_size
operator|=
name|len
operator|-
name|lenonbd
expr_stmt|;
name|frags
operator|=
name|SGE_PAGE_ALIGN
argument_list|(
name|frag_size
argument_list|)
operator|>>
name|SGE_PAGE_SHIFT
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|frags
condition|;
name|i
operator|+=
name|PAGES_PER_SGE
operator|,
name|j
operator|++
control|)
block|{
name|sge_idx
operator|=
name|RX_SGE
argument_list|(
name|le16toh
argument_list|(
name|cqe_fp
operator|->
name|sgl_or_raw_data
operator|.
name|sgl
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|m_frag
operator|=
name|fp
operator|->
name|rx_sge_mbuf_chain
index|[
name|sge_idx
index|]
operator|.
name|m
expr_stmt|;
name|frag_len
operator|=
name|min
argument_list|(
name|frag_size
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|SGE_PAGE_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|m_frag
operator|->
name|m_len
operator|=
name|frag_len
expr_stmt|;
comment|/* allocate a new mbuf for the SGE */
name|rc
operator|=
name|bxe_alloc_rx_sge_mbuf
argument_list|(
name|fp
argument_list|,
name|sge_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
comment|/* Leave all remaining SGEs in the ring! */
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|fp
operator|->
name|eth_q_stats
operator|.
name|mbuf_alloc_sge
operator|--
expr_stmt|;
comment|/* concatenate the fragment to the head mbuf */
name|m_cat
argument_list|(
name|m
argument_list|,
name|m_frag
argument_list|)
expr_stmt|;
name|frag_size
operator|-=
name|frag_len
expr_stmt|;
block|}
name|bxe_update_sge_prod
argument_list|(
name|fp
operator|->
name|sc
argument_list|,
name|fp
argument_list|,
name|frags
argument_list|,
operator|&
name|cqe_fp
operator|->
name|sgl_or_raw_data
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|bxe_rxeof
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|)
block|{
name|if_t
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|uint16_t
name|bd_cons
decl_stmt|,
name|bd_prod
decl_stmt|,
name|bd_prod_fw
decl_stmt|,
name|comp_ring_cons
decl_stmt|;
name|uint16_t
name|hw_cq_cons
decl_stmt|,
name|sw_cq_cons
decl_stmt|,
name|sw_cq_prod
decl_stmt|;
name|int
name|rx_pkts
init|=
literal|0
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|BXE_FP_RX_LOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* CQ "next element" is of the size of the regular element */
name|hw_cq_cons
operator|=
name|le16toh
argument_list|(
operator|*
name|fp
operator|->
name|rx_cq_cons_sb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hw_cq_cons
operator|&
name|RCQ_USABLE_PER_PAGE
operator|)
operator|==
name|RCQ_USABLE_PER_PAGE
condition|)
block|{
name|hw_cq_cons
operator|++
expr_stmt|;
block|}
name|bd_cons
operator|=
name|fp
operator|->
name|rx_bd_cons
expr_stmt|;
name|bd_prod
operator|=
name|fp
operator|->
name|rx_bd_prod
expr_stmt|;
name|bd_prod_fw
operator|=
name|bd_prod
expr_stmt|;
name|sw_cq_cons
operator|=
name|fp
operator|->
name|rx_cq_cons
expr_stmt|;
name|sw_cq_prod
operator|=
name|fp
operator|->
name|rx_cq_prod
expr_stmt|;
comment|/*      * Memory barrier necessary as speculative reads of the rx      * buffer can be ahead of the index in the status block      */
name|rmb
argument_list|()
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_RX
argument_list|,
literal|"fp[%02d] Rx START hw_cq_cons=%u sw_cq_cons=%u\n"
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|hw_cq_cons
argument_list|,
name|sw_cq_cons
argument_list|)
expr_stmt|;
while|while
condition|(
name|sw_cq_cons
operator|!=
name|hw_cq_cons
condition|)
block|{
name|struct
name|bxe_sw_rx_bd
modifier|*
name|rx_buf
init|=
name|NULL
decl_stmt|;
name|union
name|eth_rx_cqe
modifier|*
name|cqe
decl_stmt|;
name|struct
name|eth_fast_path_rx_cqe
modifier|*
name|cqe_fp
decl_stmt|;
name|uint8_t
name|cqe_fp_flags
decl_stmt|;
name|enum
name|eth_rx_cqe_type
name|cqe_fp_type
decl_stmt|;
name|uint16_t
name|len
decl_stmt|,
name|lenonbd
decl_stmt|,
name|pad
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|comp_ring_cons
operator|=
name|RCQ
argument_list|(
name|sw_cq_cons
argument_list|)
expr_stmt|;
name|bd_prod
operator|=
name|RX_BD
argument_list|(
name|bd_prod
argument_list|)
expr_stmt|;
name|bd_cons
operator|=
name|RX_BD
argument_list|(
name|bd_cons
argument_list|)
expr_stmt|;
name|cqe
operator|=
operator|&
name|fp
operator|->
name|rcq_chain
index|[
name|comp_ring_cons
index|]
expr_stmt|;
name|cqe_fp
operator|=
operator|&
name|cqe
operator|->
name|fast_path_cqe
expr_stmt|;
name|cqe_fp_flags
operator|=
name|cqe_fp
operator|->
name|type_error_flags
expr_stmt|;
name|cqe_fp_type
operator|=
name|cqe_fp_flags
operator|&
name|ETH_FAST_PATH_RX_CQE_TYPE
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_RX
argument_list|,
literal|"fp[%02d] Rx hw_cq_cons=%d hw_sw_cons=%d "
literal|"BD prod=%d cons=%d CQE type=0x%x err=0x%x "
literal|"status=0x%x rss_hash=0x%x vlan=0x%x len=%u lenonbd=%u\n"
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|hw_cq_cons
argument_list|,
name|sw_cq_cons
argument_list|,
name|bd_prod
argument_list|,
name|bd_cons
argument_list|,
name|CQE_TYPE
argument_list|(
name|cqe_fp_flags
argument_list|)
argument_list|,
name|cqe_fp_flags
argument_list|,
name|cqe_fp
operator|->
name|status_flags
argument_list|,
name|le32toh
argument_list|(
name|cqe_fp
operator|->
name|rss_hash_result
argument_list|)
argument_list|,
name|le16toh
argument_list|(
name|cqe_fp
operator|->
name|vlan_tag
argument_list|)
argument_list|,
name|le16toh
argument_list|(
name|cqe_fp
operator|->
name|pkt_len_or_gro_seg_len
argument_list|)
argument_list|,
name|le16toh
argument_list|(
name|cqe_fp
operator|->
name|len_on_bd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* is this a slowpath msg? */
if|if
condition|(
name|__predict_false
argument_list|(
name|CQE_TYPE_SLOW
argument_list|(
name|cqe_fp_type
argument_list|)
argument_list|)
condition|)
block|{
name|bxe_sp_event
argument_list|(
name|sc
argument_list|,
name|fp
argument_list|,
name|cqe
argument_list|)
expr_stmt|;
goto|goto
name|next_cqe
goto|;
block|}
name|rx_buf
operator|=
operator|&
name|fp
operator|->
name|rx_mbuf_chain
index|[
name|bd_cons
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|CQE_TYPE_FAST
argument_list|(
name|cqe_fp_type
argument_list|)
condition|)
block|{
name|struct
name|bxe_sw_tpa_info
modifier|*
name|tpa_info
decl_stmt|;
name|uint16_t
name|frag_size
decl_stmt|,
name|pages
decl_stmt|;
name|uint8_t
name|queue
decl_stmt|;
if|if
condition|(
name|CQE_TYPE_START
argument_list|(
name|cqe_fp_type
argument_list|)
condition|)
block|{
name|bxe_tpa_start
argument_list|(
name|sc
argument_list|,
name|fp
argument_list|,
name|cqe_fp
operator|->
name|queue_index
argument_list|,
name|bd_cons
argument_list|,
name|bd_prod
argument_list|,
name|cqe_fp
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
comment|/* packet not ready yet */
goto|goto
name|next_rx
goto|;
block|}
name|KASSERT
argument_list|(
name|CQE_TYPE_STOP
argument_list|(
name|cqe_fp_type
argument_list|)
argument_list|,
operator|(
literal|"CQE type is not STOP! (0x%x)\n"
operator|,
name|cqe_fp_type
operator|)
argument_list|)
expr_stmt|;
name|queue
operator|=
name|cqe
operator|->
name|end_agg_cqe
operator|.
name|queue_index
expr_stmt|;
name|tpa_info
operator|=
operator|&
name|fp
operator|->
name|rx_tpa_info
index|[
name|queue
index|]
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LRO
argument_list|,
literal|"fp[%02d].tpa[%02d] TPA STOP\n"
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|queue
argument_list|)
expr_stmt|;
name|frag_size
operator|=
operator|(
name|le16toh
argument_list|(
name|cqe
operator|->
name|end_agg_cqe
operator|.
name|pkt_len
argument_list|)
operator|-
name|tpa_info
operator|->
name|len_on_bd
operator|)
expr_stmt|;
name|pages
operator|=
name|SGE_PAGE_ALIGN
argument_list|(
name|frag_size
argument_list|)
operator|>>
name|SGE_PAGE_SHIFT
expr_stmt|;
name|bxe_tpa_stop
argument_list|(
name|sc
argument_list|,
name|fp
argument_list|,
name|tpa_info
argument_list|,
name|queue
argument_list|,
name|pages
argument_list|,
operator|&
name|cqe
operator|->
name|end_agg_cqe
argument_list|,
name|comp_ring_cons
argument_list|)
expr_stmt|;
name|bxe_update_sge_prod
argument_list|(
name|sc
argument_list|,
name|fp
argument_list|,
name|pages
argument_list|,
operator|&
name|cqe
operator|->
name|end_agg_cqe
operator|.
name|sgl_or_raw_data
argument_list|)
expr_stmt|;
goto|goto
name|next_cqe
goto|;
block|}
comment|/* non TPA */
comment|/* is this an error packet? */
if|if
condition|(
name|__predict_false
argument_list|(
name|cqe_fp_flags
operator|&
name|ETH_FAST_PATH_RX_CQE_PHY_DECODE_ERR_FLG
argument_list|)
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"flags 0x%x rx packet %u\n"
argument_list|,
name|cqe_fp_flags
argument_list|,
name|sw_cq_cons
argument_list|)
expr_stmt|;
name|fp
operator|->
name|eth_q_stats
operator|.
name|rx_soft_errors
operator|++
expr_stmt|;
goto|goto
name|next_rx
goto|;
block|}
name|len
operator|=
name|le16toh
argument_list|(
name|cqe_fp
operator|->
name|pkt_len_or_gro_seg_len
argument_list|)
expr_stmt|;
name|lenonbd
operator|=
name|le16toh
argument_list|(
name|cqe_fp
operator|->
name|len_on_bd
argument_list|)
expr_stmt|;
name|pad
operator|=
name|cqe_fp
operator|->
name|placement_offset
expr_stmt|;
name|m
operator|=
name|rx_buf
operator|->
name|m
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"No mbuf in rx chain descriptor %d for fp[%02d]\n"
argument_list|,
name|bd_cons
argument_list|,
name|fp
operator|->
name|index
argument_list|)
expr_stmt|;
goto|goto
name|next_rx
goto|;
block|}
comment|/* XXX double copy if packet length under a threshold */
comment|/*          * If all the buffer descriptors are filled with mbufs then fill in          * the current consumer index with a new BD. Else if a maximum Rx          * buffer limit is imposed then fill in the next producer index.          */
name|rc
operator|=
name|bxe_alloc_rx_bd_mbuf
argument_list|(
name|fp
argument_list|,
name|bd_cons
argument_list|,
operator|(
name|sc
operator|->
name|max_rx_bufs
operator|!=
name|RX_BD_USABLE
operator|)
condition|?
name|bd_prod
else|:
name|bd_cons
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
comment|/* we simply reuse the received mbuf and don't post it to the stack */
name|m
operator|=
name|NULL
expr_stmt|;
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"mbuf alloc fail for fp[%02d] rx chain (%d)\n"
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|fp
operator|->
name|eth_q_stats
operator|.
name|rx_soft_errors
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|max_rx_bufs
operator|!=
name|RX_BD_USABLE
condition|)
block|{
comment|/* copy this consumer index to the producer index */
name|memcpy
argument_list|(
operator|&
name|fp
operator|->
name|rx_mbuf_chain
index|[
name|bd_prod
index|]
argument_list|,
name|rx_buf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bxe_sw_rx_bd
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|rx_buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bxe_sw_rx_bd
argument_list|)
argument_list|)
expr_stmt|;
block|}
goto|goto
name|next_rx
goto|;
block|}
comment|/* current mbuf was detached from the bd */
name|fp
operator|->
name|eth_q_stats
operator|.
name|mbuf_alloc_rx
operator|--
expr_stmt|;
comment|/* we allocated a replacement mbuf, fixup the current one */
name|m_adj
argument_list|(
name|m
argument_list|,
name|pad
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|>
literal|60
operator|)
operator|&&
operator|(
name|len
operator|>
name|lenonbd
operator|)
condition|)
block|{
name|fp
operator|->
name|eth_q_stats
operator|.
name|rx_bxe_service_rxsgl
operator|++
expr_stmt|;
name|rc
operator|=
name|bxe_service_rxsgl
argument_list|(
name|fp
argument_list|,
name|len
argument_list|,
name|lenonbd
argument_list|,
name|m
argument_list|,
name|cqe_fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
break|break;
name|fp
operator|->
name|eth_q_stats
operator|.
name|rx_jumbo_sge_pkts
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lenonbd
operator|<
name|len
condition|)
block|{
name|fp
operator|->
name|eth_q_stats
operator|.
name|rx_erroneous_jumbo_sge_pkts
operator|++
expr_stmt|;
block|}
comment|/* assign packet to this interface interface */
name|if_setrcvif
argument_list|(
name|m
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
comment|/* assume no hardware checksum has complated */
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
literal|0
expr_stmt|;
comment|/* validate checksum if offload enabled */
if|if
condition|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_RXCSUM
condition|)
block|{
comment|/* check for a valid IP frame */
if|if
condition|(
operator|!
operator|(
name|cqe
operator|->
name|fast_path_cqe
operator|.
name|status_flags
operator|&
name|ETH_FAST_PATH_RX_CQE_IP_XSUM_NO_VALIDATION_FLG
operator|)
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_IP_CHECKED
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|cqe_fp_flags
operator|&
name|ETH_FAST_PATH_RX_CQE_IP_BAD_XSUM_FLG
argument_list|)
condition|)
block|{
name|fp
operator|->
name|eth_q_stats
operator|.
name|rx_hw_csum_errors
operator|++
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|->
name|eth_q_stats
operator|.
name|rx_ofld_frames_csum_ip
operator|++
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_IP_VALID
expr_stmt|;
block|}
block|}
comment|/* check for a valid TCP/UDP frame */
if|if
condition|(
operator|!
operator|(
name|cqe
operator|->
name|fast_path_cqe
operator|.
name|status_flags
operator|&
name|ETH_FAST_PATH_RX_CQE_L4_XSUM_NO_VALIDATION_FLG
operator|)
condition|)
block|{
if|if
condition|(
name|__predict_false
argument_list|(
name|cqe_fp_flags
operator|&
name|ETH_FAST_PATH_RX_CQE_L4_BAD_XSUM_FLG
argument_list|)
condition|)
block|{
name|fp
operator|->
name|eth_q_stats
operator|.
name|rx_hw_csum_errors
operator|++
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|->
name|eth_q_stats
operator|.
name|rx_ofld_frames_csum_tcp_udp
operator|++
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xFFFF
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
operator|(
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
expr_stmt|;
block|}
block|}
block|}
comment|/* if there is a VLAN tag then flag that info */
if|if
condition|(
name|cqe
operator|->
name|fast_path_cqe
operator|.
name|pars_flags
operator|.
name|flags
operator|&
name|PARSING_FLAGS_INNER_VLAN_EXIST
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|=
name|cqe
operator|->
name|fast_path_cqe
operator|.
name|vlan_tag
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_VLANTAG
expr_stmt|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
comment|/* specify what RSS queue was used for this flow */
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
name|fp
operator|->
name|index
expr_stmt|;
name|BXE_SET_FLOWID
argument_list|(
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|next_rx
label|:
name|bd_cons
operator|=
name|RX_BD_NEXT
argument_list|(
name|bd_cons
argument_list|)
expr_stmt|;
name|bd_prod
operator|=
name|RX_BD_NEXT
argument_list|(
name|bd_prod
argument_list|)
expr_stmt|;
name|bd_prod_fw
operator|=
name|RX_BD_NEXT
argument_list|(
name|bd_prod_fw
argument_list|)
expr_stmt|;
comment|/* pass the frame to the stack */
if|if
condition|(
name|__predict_true
argument_list|(
name|m
operator|!=
name|NULL
argument_list|)
condition|)
block|{
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_IPACKETS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rx_pkts
operator|++
expr_stmt|;
name|if_input
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|next_cqe
label|:
name|sw_cq_prod
operator|=
name|RCQ_NEXT
argument_list|(
name|sw_cq_prod
argument_list|)
expr_stmt|;
name|sw_cq_cons
operator|=
name|RCQ_NEXT
argument_list|(
name|sw_cq_cons
argument_list|)
expr_stmt|;
comment|/* limit spinning on the queue */
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|rx_pkts
operator|==
name|sc
operator|->
name|rx_budget
condition|)
block|{
name|fp
operator|->
name|eth_q_stats
operator|.
name|rx_budget_reached
operator|++
expr_stmt|;
break|break;
block|}
block|}
comment|/* while work to do */
name|fp
operator|->
name|rx_bd_cons
operator|=
name|bd_cons
expr_stmt|;
name|fp
operator|->
name|rx_bd_prod
operator|=
name|bd_prod_fw
expr_stmt|;
name|fp
operator|->
name|rx_cq_cons
operator|=
name|sw_cq_cons
expr_stmt|;
name|fp
operator|->
name|rx_cq_prod
operator|=
name|sw_cq_prod
expr_stmt|;
comment|/* Update producers */
name|bxe_update_rx_prod
argument_list|(
name|sc
argument_list|,
name|fp
argument_list|,
name|bd_prod_fw
argument_list|,
name|sw_cq_prod
argument_list|,
name|fp
operator|->
name|rx_sge_prod
argument_list|)
expr_stmt|;
name|fp
operator|->
name|eth_q_stats
operator|.
name|rx_pkts
operator|+=
name|rx_pkts
expr_stmt|;
name|fp
operator|->
name|eth_q_stats
operator|.
name|rx_calls
operator|++
expr_stmt|;
name|BXE_FP_RX_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|sw_cq_cons
operator|!=
name|hw_cq_cons
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint16_t
name|bxe_free_tx_pkt
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|uint16_t
name|idx
parameter_list|)
block|{
name|struct
name|bxe_sw_tx_bd
modifier|*
name|tx_buf
init|=
operator|&
name|fp
operator|->
name|tx_mbuf_chain
index|[
name|idx
index|]
decl_stmt|;
name|struct
name|eth_tx_start_bd
modifier|*
name|tx_start_bd
decl_stmt|;
name|uint16_t
name|bd_idx
init|=
name|TX_BD
argument_list|(
name|tx_buf
operator|->
name|first_bd
argument_list|)
decl_stmt|;
name|uint16_t
name|new_cons
decl_stmt|;
name|int
name|nbd
decl_stmt|;
comment|/* unmap the mbuf from non-paged memory */
name|bus_dmamap_unload
argument_list|(
name|fp
operator|->
name|tx_mbuf_tag
argument_list|,
name|tx_buf
operator|->
name|m_map
argument_list|)
expr_stmt|;
name|tx_start_bd
operator|=
operator|&
name|fp
operator|->
name|tx_chain
index|[
name|bd_idx
index|]
operator|.
name|start_bd
expr_stmt|;
name|nbd
operator|=
name|le16toh
argument_list|(
name|tx_start_bd
operator|->
name|nbd
argument_list|)
operator|-
literal|1
expr_stmt|;
name|new_cons
operator|=
operator|(
name|tx_buf
operator|->
name|first_bd
operator|+
name|nbd
operator|)
expr_stmt|;
comment|/* free the mbuf */
if|if
condition|(
name|__predict_true
argument_list|(
name|tx_buf
operator|->
name|m
operator|!=
name|NULL
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|tx_buf
operator|->
name|m
argument_list|)
expr_stmt|;
name|fp
operator|->
name|eth_q_stats
operator|.
name|mbuf_alloc_tx
operator|--
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|->
name|eth_q_stats
operator|.
name|tx_chain_lost_mbuf
operator|++
expr_stmt|;
block|}
name|tx_buf
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|tx_buf
operator|->
name|first_bd
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|new_cons
operator|)
return|;
block|}
end_function

begin_comment
comment|/* transmit timeout watchdog */
end_comment

begin_function
specifier|static
name|int
name|bxe_watchdog
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|)
block|{
name|BXE_FP_TX_LOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|->
name|watchdog_timer
operator|==
literal|0
operator|)
operator|||
operator|(
operator|--
name|fp
operator|->
name|watchdog_timer
operator|)
condition|)
block|{
name|BXE_FP_TX_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"TX watchdog timeout on fp[%02d], resetting!\n"
argument_list|,
name|fp
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|trigger_grcdump
condition|)
block|{
comment|/* taking grcdump */
name|bxe_grc_dump
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|BXE_FP_TX_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|atomic_store_rel_long
argument_list|(
operator|&
name|sc
operator|->
name|chip_tq_flags
argument_list|,
name|CHIP_TQ_REINIT
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|chip_tq
argument_list|,
operator|&
name|sc
operator|->
name|chip_tq_task
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* processes transmit completions */
end_comment

begin_function
specifier|static
name|uint8_t
name|bxe_txeof
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|)
block|{
name|if_t
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|uint16_t
name|bd_cons
decl_stmt|,
name|hw_cons
decl_stmt|,
name|sw_cons
decl_stmt|,
name|pkt_cons
decl_stmt|;
name|uint16_t
name|tx_bd_avail
decl_stmt|;
name|BXE_FP_TX_LOCK_ASSERT
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|bd_cons
operator|=
name|fp
operator|->
name|tx_bd_cons
expr_stmt|;
name|hw_cons
operator|=
name|le16toh
argument_list|(
operator|*
name|fp
operator|->
name|tx_cons_sb
argument_list|)
expr_stmt|;
name|sw_cons
operator|=
name|fp
operator|->
name|tx_pkt_cons
expr_stmt|;
while|while
condition|(
name|sw_cons
operator|!=
name|hw_cons
condition|)
block|{
name|pkt_cons
operator|=
name|TX_BD
argument_list|(
name|sw_cons
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_TX
argument_list|,
literal|"TX: fp[%d]: hw_cons=%u sw_cons=%u pkt_cons=%u\n"
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|hw_cons
argument_list|,
name|sw_cons
argument_list|,
name|pkt_cons
argument_list|)
expr_stmt|;
name|bd_cons
operator|=
name|bxe_free_tx_pkt
argument_list|(
name|sc
argument_list|,
name|fp
argument_list|,
name|pkt_cons
argument_list|)
expr_stmt|;
name|sw_cons
operator|++
expr_stmt|;
block|}
name|fp
operator|->
name|tx_pkt_cons
operator|=
name|sw_cons
expr_stmt|;
name|fp
operator|->
name|tx_bd_cons
operator|=
name|bd_cons
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_TX
argument_list|,
literal|"TX done: fp[%d]: hw_cons=%u sw_cons=%u sw_prod=%u\n"
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|hw_cons
argument_list|,
name|fp
operator|->
name|tx_pkt_cons
argument_list|,
name|fp
operator|->
name|tx_pkt_prod
argument_list|)
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
name|tx_bd_avail
operator|=
name|bxe_tx_avail
argument_list|(
name|sc
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx_bd_avail
operator|<
name|BXE_TX_CLEANUP_THRESHOLD
condition|)
block|{
name|if_setdrvflagbits
argument_list|(
name|ifp
argument_list|,
name|IFF_DRV_OACTIVE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|if_setdrvflagbits
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|,
name|IFF_DRV_OACTIVE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|->
name|tx_pkt_prod
operator|!=
name|fp
operator|->
name|tx_pkt_cons
condition|)
block|{
comment|/* reset the watchdog timer if there are pending transmits */
name|fp
operator|->
name|watchdog_timer
operator|=
name|BXE_TX_TIMEOUT
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
else|else
block|{
comment|/* clear watchdog when there are no pending transmits */
name|fp
operator|->
name|watchdog_timer
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_drain_tx_queues
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count
decl_stmt|;
comment|/* wait until all TX fastpath tasks have completed */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
expr_stmt|;
name|count
operator|=
literal|1000
expr_stmt|;
while|while
condition|(
name|bxe_has_tx_work
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|BXE_FP_TX_LOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|bxe_txeof
argument_list|(
name|sc
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|BXE_FP_TX_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Timeout waiting for fp[%d] "
literal|"transmits to complete!\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|bxe_panic
argument_list|(
name|sc
argument_list|,
operator|(
literal|"tx drain failure\n"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|count
operator|--
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|rmb
argument_list|()
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_del_all_macs
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|mac_obj
parameter_list|,
name|int
name|mac_type
parameter_list|,
name|uint8_t
name|wait_for_comp
parameter_list|)
block|{
name|unsigned
name|long
name|ramrod_flags
init|=
literal|0
decl_stmt|,
name|vlan_mac_flags
init|=
literal|0
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* wait for completion of requested */
if|if
condition|(
name|wait_for_comp
condition|)
block|{
name|bxe_set_bit
argument_list|(
name|RAMROD_COMP_WAIT
argument_list|,
operator|&
name|ramrod_flags
argument_list|)
expr_stmt|;
block|}
comment|/* Set the mac type of addresses we want to clear */
name|bxe_set_bit
argument_list|(
name|mac_type
argument_list|,
operator|&
name|vlan_mac_flags
argument_list|)
expr_stmt|;
name|rc
operator|=
name|mac_obj
operator|->
name|delete_all
argument_list|(
name|sc
argument_list|,
name|mac_obj
argument_list|,
operator|&
name|vlan_mac_flags
argument_list|,
operator|&
name|ramrod_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to delete MACs (%d) mac_type %d wait_for_comp 0x%x\n"
argument_list|,
name|rc
argument_list|,
name|mac_type
argument_list|,
name|wait_for_comp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_fill_accept_flags
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|rx_mode
parameter_list|,
name|unsigned
name|long
modifier|*
name|rx_accept_flags
parameter_list|,
name|unsigned
name|long
modifier|*
name|tx_accept_flags
parameter_list|)
block|{
comment|/* Clear the flags first */
operator|*
name|rx_accept_flags
operator|=
literal|0
expr_stmt|;
operator|*
name|tx_accept_flags
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|rx_mode
condition|)
block|{
case|case
name|BXE_RX_MODE_NONE
case|:
comment|/*          * 'drop all' supersedes any accept flags that may have been          * passed to the function.          */
break|break;
case|case
name|BXE_RX_MODE_NORMAL
case|:
name|bxe_set_bit
argument_list|(
name|ECORE_ACCEPT_UNICAST
argument_list|,
name|rx_accept_flags
argument_list|)
expr_stmt|;
name|bxe_set_bit
argument_list|(
name|ECORE_ACCEPT_MULTICAST
argument_list|,
name|rx_accept_flags
argument_list|)
expr_stmt|;
name|bxe_set_bit
argument_list|(
name|ECORE_ACCEPT_BROADCAST
argument_list|,
name|rx_accept_flags
argument_list|)
expr_stmt|;
comment|/* internal switching mode */
name|bxe_set_bit
argument_list|(
name|ECORE_ACCEPT_UNICAST
argument_list|,
name|tx_accept_flags
argument_list|)
expr_stmt|;
name|bxe_set_bit
argument_list|(
name|ECORE_ACCEPT_MULTICAST
argument_list|,
name|tx_accept_flags
argument_list|)
expr_stmt|;
name|bxe_set_bit
argument_list|(
name|ECORE_ACCEPT_BROADCAST
argument_list|,
name|tx_accept_flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|BXE_RX_MODE_ALLMULTI
case|:
name|bxe_set_bit
argument_list|(
name|ECORE_ACCEPT_UNICAST
argument_list|,
name|rx_accept_flags
argument_list|)
expr_stmt|;
name|bxe_set_bit
argument_list|(
name|ECORE_ACCEPT_ALL_MULTICAST
argument_list|,
name|rx_accept_flags
argument_list|)
expr_stmt|;
name|bxe_set_bit
argument_list|(
name|ECORE_ACCEPT_BROADCAST
argument_list|,
name|rx_accept_flags
argument_list|)
expr_stmt|;
comment|/* internal switching mode */
name|bxe_set_bit
argument_list|(
name|ECORE_ACCEPT_UNICAST
argument_list|,
name|tx_accept_flags
argument_list|)
expr_stmt|;
name|bxe_set_bit
argument_list|(
name|ECORE_ACCEPT_ALL_MULTICAST
argument_list|,
name|tx_accept_flags
argument_list|)
expr_stmt|;
name|bxe_set_bit
argument_list|(
name|ECORE_ACCEPT_BROADCAST
argument_list|,
name|tx_accept_flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|BXE_RX_MODE_PROMISC
case|:
comment|/*          * According to deffinition of SI mode, iface in promisc mode          * should receive matched and unmatched (in resolution of port)          * unicast packets.          */
name|bxe_set_bit
argument_list|(
name|ECORE_ACCEPT_UNMATCHED
argument_list|,
name|rx_accept_flags
argument_list|)
expr_stmt|;
name|bxe_set_bit
argument_list|(
name|ECORE_ACCEPT_UNICAST
argument_list|,
name|rx_accept_flags
argument_list|)
expr_stmt|;
name|bxe_set_bit
argument_list|(
name|ECORE_ACCEPT_ALL_MULTICAST
argument_list|,
name|rx_accept_flags
argument_list|)
expr_stmt|;
name|bxe_set_bit
argument_list|(
name|ECORE_ACCEPT_BROADCAST
argument_list|,
name|rx_accept_flags
argument_list|)
expr_stmt|;
comment|/* internal switching mode */
name|bxe_set_bit
argument_list|(
name|ECORE_ACCEPT_ALL_MULTICAST
argument_list|,
name|tx_accept_flags
argument_list|)
expr_stmt|;
name|bxe_set_bit
argument_list|(
name|ECORE_ACCEPT_BROADCAST
argument_list|,
name|tx_accept_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_MF_SI
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|bxe_set_bit
argument_list|(
name|ECORE_ACCEPT_ALL_UNICAST
argument_list|,
name|tx_accept_flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bxe_set_bit
argument_list|(
name|ECORE_ACCEPT_UNICAST
argument_list|,
name|tx_accept_flags
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Unknown rx_mode (0x%x)\n"
argument_list|,
name|rx_mode
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Set ACCEPT_ANY_VLAN as we do not enable filtering by VLAN */
if|if
condition|(
name|rx_mode
operator|!=
name|BXE_RX_MODE_NONE
condition|)
block|{
name|bxe_set_bit
argument_list|(
name|ECORE_ACCEPT_ANY_VLAN
argument_list|,
name|rx_accept_flags
argument_list|)
expr_stmt|;
name|bxe_set_bit
argument_list|(
name|ECORE_ACCEPT_ANY_VLAN
argument_list|,
name|tx_accept_flags
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_set_q_rx_mode
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|cl_id
parameter_list|,
name|unsigned
name|long
name|rx_mode_flags
parameter_list|,
name|unsigned
name|long
name|rx_accept_flags
parameter_list|,
name|unsigned
name|long
name|tx_accept_flags
parameter_list|,
name|unsigned
name|long
name|ramrod_flags
parameter_list|)
block|{
name|struct
name|ecore_rx_mode_ramrod_params
name|ramrod_param
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ramrod_param
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ramrod_param
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Prepare ramrod parameters */
name|ramrod_param
operator|.
name|cid
operator|=
literal|0
expr_stmt|;
name|ramrod_param
operator|.
name|cl_id
operator|=
name|cl_id
expr_stmt|;
name|ramrod_param
operator|.
name|rx_mode_obj
operator|=
operator|&
name|sc
operator|->
name|rx_mode_obj
expr_stmt|;
name|ramrod_param
operator|.
name|func_id
operator|=
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ramrod_param
operator|.
name|pstate
operator|=
operator|&
name|sc
operator|->
name|sp_state
expr_stmt|;
name|ramrod_param
operator|.
name|state
operator|=
name|ECORE_FILTER_RX_MODE_PENDING
expr_stmt|;
name|ramrod_param
operator|.
name|rdata
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|rx_mode_rdata
argument_list|)
expr_stmt|;
name|ramrod_param
operator|.
name|rdata_mapping
operator|=
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|rx_mode_rdata
argument_list|)
expr_stmt|;
name|bxe_set_bit
argument_list|(
name|ECORE_FILTER_RX_MODE_PENDING
argument_list|,
operator|&
name|sc
operator|->
name|sp_state
argument_list|)
expr_stmt|;
name|ramrod_param
operator|.
name|ramrod_flags
operator|=
name|ramrod_flags
expr_stmt|;
name|ramrod_param
operator|.
name|rx_mode_flags
operator|=
name|rx_mode_flags
expr_stmt|;
name|ramrod_param
operator|.
name|rx_accept_flags
operator|=
name|rx_accept_flags
expr_stmt|;
name|ramrod_param
operator|.
name|tx_accept_flags
operator|=
name|tx_accept_flags
expr_stmt|;
name|rc
operator|=
name|ecore_config_rx_mode
argument_list|(
name|sc
argument_list|,
operator|&
name|ramrod_param
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Set rx_mode %d cli_id 0x%x rx_mode_flags 0x%x "
literal|"rx_accept_flags 0x%x tx_accept_flags 0x%x "
literal|"ramrod_flags 0x%x rc %d failed\n"
argument_list|,
name|sc
operator|->
name|rx_mode
argument_list|,
name|cl_id
argument_list|,
operator|(
name|uint32_t
operator|)
name|rx_mode_flags
argument_list|,
operator|(
name|uint32_t
operator|)
name|rx_accept_flags
argument_list|,
operator|(
name|uint32_t
operator|)
name|tx_accept_flags
argument_list|,
operator|(
name|uint32_t
operator|)
name|ramrod_flags
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_set_storm_rx_mode
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|unsigned
name|long
name|rx_mode_flags
init|=
literal|0
decl_stmt|,
name|ramrod_flags
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|rx_accept_flags
init|=
literal|0
decl_stmt|,
name|tx_accept_flags
init|=
literal|0
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|bxe_fill_accept_flags
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|rx_mode
argument_list|,
operator|&
name|rx_accept_flags
argument_list|,
operator|&
name|tx_accept_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|bxe_set_bit
argument_list|(
name|RAMROD_RX
argument_list|,
operator|&
name|ramrod_flags
argument_list|)
expr_stmt|;
name|bxe_set_bit
argument_list|(
name|RAMROD_TX
argument_list|,
operator|&
name|ramrod_flags
argument_list|)
expr_stmt|;
comment|/* XXX ensure all fastpath have same cl_id and/or move it to bxe_softc */
return|return
operator|(
name|bxe_set_q_rx_mode
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|fp
index|[
literal|0
index|]
operator|.
name|cl_id
argument_list|,
name|rx_mode_flags
argument_list|,
name|rx_accept_flags
argument_list|,
name|tx_accept_flags
argument_list|,
name|ramrod_flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* returns the "mcp load_code" according to global load_count array */
end_comment

begin_function
specifier|static
name|int
name|bxe_nic_load_no_mcp
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|path
init|=
name|SC_PATH
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|int
name|port
init|=
name|SC_PORT
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|BLOGI
argument_list|(
name|sc
argument_list|,
literal|"NO MCP - load counts[%d]      %d, %d, %d\n"
argument_list|,
name|path
argument_list|,
name|load_count
index|[
name|path
index|]
index|[
literal|0
index|]
argument_list|,
name|load_count
index|[
name|path
index|]
index|[
literal|1
index|]
argument_list|,
name|load_count
index|[
name|path
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|load_count
index|[
name|path
index|]
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|load_count
index|[
name|path
index|]
index|[
literal|1
operator|+
name|port
index|]
operator|++
expr_stmt|;
name|BLOGI
argument_list|(
name|sc
argument_list|,
literal|"NO MCP - new load counts[%d]  %d, %d, %d\n"
argument_list|,
name|path
argument_list|,
name|load_count
index|[
name|path
index|]
index|[
literal|0
index|]
argument_list|,
name|load_count
index|[
name|path
index|]
index|[
literal|1
index|]
argument_list|,
name|load_count
index|[
name|path
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|load_count
index|[
name|path
index|]
index|[
literal|0
index|]
operator|==
literal|1
condition|)
block|{
return|return
operator|(
name|FW_MSG_CODE_DRV_LOAD_COMMON
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|load_count
index|[
name|path
index|]
index|[
literal|1
operator|+
name|port
index|]
operator|==
literal|1
condition|)
block|{
return|return
operator|(
name|FW_MSG_CODE_DRV_LOAD_PORT
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|FW_MSG_CODE_DRV_LOAD_FUNCTION
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* returns the "mcp load_code" according to global load_count array */
end_comment

begin_function
specifier|static
name|int
name|bxe_nic_unload_no_mcp
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|port
init|=
name|SC_PORT
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|int
name|path
init|=
name|SC_PATH
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|BLOGI
argument_list|(
name|sc
argument_list|,
literal|"NO MCP - load counts[%d]      %d, %d, %d\n"
argument_list|,
name|path
argument_list|,
name|load_count
index|[
name|path
index|]
index|[
literal|0
index|]
argument_list|,
name|load_count
index|[
name|path
index|]
index|[
literal|1
index|]
argument_list|,
name|load_count
index|[
name|path
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|load_count
index|[
name|path
index|]
index|[
literal|0
index|]
operator|--
expr_stmt|;
name|load_count
index|[
name|path
index|]
index|[
literal|1
operator|+
name|port
index|]
operator|--
expr_stmt|;
name|BLOGI
argument_list|(
name|sc
argument_list|,
literal|"NO MCP - new load counts[%d]  %d, %d, %d\n"
argument_list|,
name|path
argument_list|,
name|load_count
index|[
name|path
index|]
index|[
literal|0
index|]
argument_list|,
name|load_count
index|[
name|path
index|]
index|[
literal|1
index|]
argument_list|,
name|load_count
index|[
name|path
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|load_count
index|[
name|path
index|]
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|FW_MSG_CODE_DRV_UNLOAD_COMMON
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|load_count
index|[
name|path
index|]
index|[
literal|1
operator|+
name|port
index|]
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|FW_MSG_CODE_DRV_UNLOAD_PORT
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|FW_MSG_CODE_DRV_UNLOAD_FUNCTION
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* request unload mode from the MCP: COMMON, PORT or FUNCTION */
end_comment

begin_function
specifier|static
name|uint32_t
name|bxe_send_unload_req
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|unload_mode
parameter_list|)
block|{
name|uint32_t
name|reset_code
init|=
literal|0
decl_stmt|;
comment|/* Select the UNLOAD request mode */
if|if
condition|(
name|unload_mode
operator|==
name|UNLOAD_NORMAL
condition|)
block|{
name|reset_code
operator|=
name|DRV_MSG_CODE_UNLOAD_REQ_WOL_DIS
expr_stmt|;
block|}
else|else
block|{
name|reset_code
operator|=
name|DRV_MSG_CODE_UNLOAD_REQ_WOL_DIS
expr_stmt|;
block|}
comment|/* Send the request to the MCP */
if|if
condition|(
operator|!
name|BXE_NOMCP
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|reset_code
operator|=
name|bxe_fw_command
argument_list|(
name|sc
argument_list|,
name|reset_code
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reset_code
operator|=
name|bxe_nic_unload_no_mcp
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|reset_code
operator|)
return|;
block|}
end_function

begin_comment
comment|/* send UNLOAD_DONE command to the MCP */
end_comment

begin_function
specifier|static
name|void
name|bxe_send_unload_done
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|keep_link
parameter_list|)
block|{
name|uint32_t
name|reset_param
init|=
name|keep_link
condition|?
name|DRV_MSG_CODE_UNLOAD_SKIP_LINK_RESET
else|:
literal|0
decl_stmt|;
comment|/* Report UNLOAD_DONE to MCP */
if|if
condition|(
operator|!
name|BXE_NOMCP
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|bxe_fw_command
argument_list|(
name|sc
argument_list|,
name|DRV_MSG_CODE_UNLOAD_DONE
argument_list|,
name|reset_param
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_func_wait_started
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|tout
init|=
literal|50
decl_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|port
operator|.
name|pmf
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*      * (assumption: No Attention from MCP at this stage)      * PMF probably in the middle of TX disable/enable transaction      * 1. Sync IRS for default SB      * 2. Sync SP queue - this guarantees us that attention handling started      * 3. Wait, that TX disable/enable transaction completes      *      * 1+2 guarantee that if DCBX attention was scheduled it already changed      * pending bit of transaction from STARTED-->TX_STOPPED, if we already      * received completion for the transaction the state is TX_STOPPED.      * State will return to STARTED after completion of TX_STOPPED-->STARTED      * transaction.      */
comment|/* XXX make sure default SB ISR is done */
comment|/* need a way to synchronize an irq (intr_mtx?) */
comment|/* XXX flush any work queues */
while|while
condition|(
name|ecore_func_get_state
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|func_obj
argument_list|)
operator|!=
name|ECORE_F_STATE_STARTED
operator|&&
name|tout
operator|--
condition|)
block|{
name|DELAY
argument_list|(
literal|20000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ecore_func_get_state
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|func_obj
argument_list|)
operator|!=
name|ECORE_F_STATE_STARTED
condition|)
block|{
comment|/*          * Failed to complete the transaction in a "good way"          * Force both transactions with CLR bit.          */
name|struct
name|ecore_func_state_params
name|func_params
init|=
block|{
name|NULL
block|}
decl_stmt|;
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Unexpected function state! "
literal|"Forcing STARTED-->TX_STOPPED-->STARTED\n"
argument_list|)
expr_stmt|;
name|func_params
operator|.
name|f_obj
operator|=
operator|&
name|sc
operator|->
name|func_obj
expr_stmt|;
name|bxe_set_bit
argument_list|(
name|RAMROD_DRV_CLR_ONLY
argument_list|,
operator|&
name|func_params
operator|.
name|ramrod_flags
argument_list|)
expr_stmt|;
comment|/* STARTED-->TX_STOPPED */
name|func_params
operator|.
name|cmd
operator|=
name|ECORE_F_CMD_TX_STOP
expr_stmt|;
name|ecore_func_state_change
argument_list|(
name|sc
argument_list|,
operator|&
name|func_params
argument_list|)
expr_stmt|;
comment|/* TX_STOPPED-->STARTED */
name|func_params
operator|.
name|cmd
operator|=
name|ECORE_F_CMD_TX_START
expr_stmt|;
return|return
operator|(
name|ecore_func_state_change
argument_list|(
name|sc
argument_list|,
operator|&
name|func_params
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_stop_queue
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|struct
name|bxe_fastpath
modifier|*
name|fp
init|=
operator|&
name|sc
operator|->
name|fp
index|[
name|index
index|]
decl_stmt|;
name|struct
name|ecore_queue_state_params
name|q_params
init|=
block|{
name|NULL
block|}
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"stopping queue %d cid %d\n"
argument_list|,
name|index
argument_list|,
name|fp
operator|->
name|index
argument_list|)
expr_stmt|;
name|q_params
operator|.
name|q_obj
operator|=
operator|&
name|sc
operator|->
name|sp_objs
index|[
name|fp
operator|->
name|index
index|]
operator|.
name|q_obj
expr_stmt|;
comment|/* We want to wait for completion in this context */
name|bxe_set_bit
argument_list|(
name|RAMROD_COMP_WAIT
argument_list|,
operator|&
name|q_params
operator|.
name|ramrod_flags
argument_list|)
expr_stmt|;
comment|/* Stop the primary connection: */
comment|/* ...halt the connection */
name|q_params
operator|.
name|cmd
operator|=
name|ECORE_Q_CMD_HALT
expr_stmt|;
name|rc
operator|=
name|ecore_queue_state_change
argument_list|(
name|sc
argument_list|,
operator|&
name|q_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
return|return
operator|(
name|rc
operator|)
return|;
block|}
comment|/* ...terminate the connection */
name|q_params
operator|.
name|cmd
operator|=
name|ECORE_Q_CMD_TERMINATE
expr_stmt|;
name|memset
argument_list|(
operator|&
name|q_params
operator|.
name|params
operator|.
name|terminate
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|q_params
operator|.
name|params
operator|.
name|terminate
argument_list|)
argument_list|)
expr_stmt|;
name|q_params
operator|.
name|params
operator|.
name|terminate
operator|.
name|cid_index
operator|=
name|FIRST_TX_COS_INDEX
expr_stmt|;
name|rc
operator|=
name|ecore_queue_state_change
argument_list|(
name|sc
argument_list|,
operator|&
name|q_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
return|return
operator|(
name|rc
operator|)
return|;
block|}
comment|/* ...delete cfc entry */
name|q_params
operator|.
name|cmd
operator|=
name|ECORE_Q_CMD_CFC_DEL
expr_stmt|;
name|memset
argument_list|(
operator|&
name|q_params
operator|.
name|params
operator|.
name|cfc_del
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|q_params
operator|.
name|params
operator|.
name|cfc_del
argument_list|)
argument_list|)
expr_stmt|;
name|q_params
operator|.
name|params
operator|.
name|cfc_del
operator|.
name|cid_index
operator|=
name|FIRST_TX_COS_INDEX
expr_stmt|;
return|return
operator|(
name|ecore_queue_state_change
argument_list|(
name|sc
argument_list|,
operator|&
name|q_params
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* wait for the outstanding SP commands */
end_comment

begin_function
specifier|static
specifier|inline
name|uint8_t
name|bxe_wait_sp_comp
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|unsigned
name|long
name|mask
parameter_list|)
block|{
name|unsigned
name|long
name|tmp
decl_stmt|;
name|int
name|tout
init|=
literal|5000
decl_stmt|;
comment|/* wait for 5 secs tops */
while|while
condition|(
name|tout
operator|--
condition|)
block|{
name|mb
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|atomic_load_acq_long
argument_list|(
operator|&
name|sc
operator|->
name|sp_state
argument_list|)
operator|&
name|mask
operator|)
condition|)
block|{
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
name|mb
argument_list|()
expr_stmt|;
name|tmp
operator|=
name|atomic_load_acq_long
argument_list|(
operator|&
name|sc
operator|->
name|sp_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&
name|mask
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Filtering completion timed out: "
literal|"sp_state 0x%lx, mask 0x%lx\n"
argument_list|,
name|tmp
argument_list|,
name|mask
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_func_stop
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ecore_func_state_params
name|func_params
init|=
block|{
name|NULL
block|}
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* prepare parameters for function state transitions */
name|bxe_set_bit
argument_list|(
name|RAMROD_COMP_WAIT
argument_list|,
operator|&
name|func_params
operator|.
name|ramrod_flags
argument_list|)
expr_stmt|;
name|func_params
operator|.
name|f_obj
operator|=
operator|&
name|sc
operator|->
name|func_obj
expr_stmt|;
name|func_params
operator|.
name|cmd
operator|=
name|ECORE_F_CMD_STOP
expr_stmt|;
comment|/*      * Try to stop the function the 'good way'. If it fails (in case      * of a parity error during bxe_chip_cleanup()) and we are      * not in a debug mode, perform a state transaction in order to      * enable further HW_RESET transaction.      */
name|rc
operator|=
name|ecore_func_state_change
argument_list|(
name|sc
argument_list|,
operator|&
name|func_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"FUNC_STOP ramrod failed. "
literal|"Running a dry transaction (%d)\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|bxe_set_bit
argument_list|(
name|RAMROD_DRV_CLR_ONLY
argument_list|,
operator|&
name|func_params
operator|.
name|ramrod_flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|ecore_func_state_change
argument_list|(
name|sc
argument_list|,
operator|&
name|func_params
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_reset_hw
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|load_code
parameter_list|)
block|{
name|struct
name|ecore_func_state_params
name|func_params
init|=
block|{
name|NULL
block|}
decl_stmt|;
comment|/* Prepare parameters for function state transitions */
name|bxe_set_bit
argument_list|(
name|RAMROD_COMP_WAIT
argument_list|,
operator|&
name|func_params
operator|.
name|ramrod_flags
argument_list|)
expr_stmt|;
name|func_params
operator|.
name|f_obj
operator|=
operator|&
name|sc
operator|->
name|func_obj
expr_stmt|;
name|func_params
operator|.
name|cmd
operator|=
name|ECORE_F_CMD_HW_RESET
expr_stmt|;
name|func_params
operator|.
name|params
operator|.
name|hw_init
operator|.
name|load_phase
operator|=
name|load_code
expr_stmt|;
return|return
operator|(
name|ecore_func_state_change
argument_list|(
name|sc
argument_list|,
operator|&
name|func_params
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_int_disable_sync
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|disable_hw
parameter_list|)
block|{
if|if
condition|(
name|disable_hw
condition|)
block|{
comment|/* prevent the HW from sending interrupts */
name|bxe_int_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* XXX need a way to synchronize ALL irqs (intr_mtx?) */
comment|/* make sure all ISRs are done */
comment|/* XXX make sure sp_task is not running */
comment|/* cancel and flush work queues */
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_chip_cleanup
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|unload_mode
parameter_list|,
name|uint8_t
name|keep_link
parameter_list|)
block|{
name|int
name|port
init|=
name|SC_PORT
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|struct
name|ecore_mcast_ramrod_params
name|rparam
init|=
block|{
name|NULL
block|}
decl_stmt|;
name|uint32_t
name|reset_code
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
name|bxe_drain_tx_queues
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* give HW time to discard old tx messages */
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* Clean all ETH MACs */
name|rc
operator|=
name|bxe_del_all_macs
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sp_objs
index|[
literal|0
index|]
operator|.
name|mac_obj
argument_list|,
name|ECORE_ETH_MAC
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to delete all ETH MACs (%d)\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
comment|/* Clean up UC list  */
name|rc
operator|=
name|bxe_del_all_macs
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sp_objs
index|[
literal|0
index|]
operator|.
name|mac_obj
argument_list|,
name|ECORE_UC_LIST_MAC
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to delete UC MACs list (%d)\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
comment|/* Disable LLH */
if|if
condition|(
operator|!
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LLH0_FUNC_EN
operator|+
name|port
operator|*
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Set "drop all" to stop Rx */
comment|/*      * We need to take the BXE_MCAST_LOCK() here in order to prevent      * a race between the completion code and this code.      */
name|BXE_MCAST_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bxe_test_bit
argument_list|(
name|ECORE_FILTER_RX_MODE_PENDING
argument_list|,
operator|&
name|sc
operator|->
name|sp_state
argument_list|)
condition|)
block|{
name|bxe_set_bit
argument_list|(
name|ECORE_FILTER_RX_MODE_SCHED
argument_list|,
operator|&
name|sc
operator|->
name|sp_state
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bxe_set_storm_rx_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* Clean up multicast configuration */
name|rparam
operator|.
name|mcast_obj
operator|=
operator|&
name|sc
operator|->
name|mcast_obj
expr_stmt|;
name|rc
operator|=
name|ecore_config_mcast
argument_list|(
name|sc
argument_list|,
operator|&
name|rparam
argument_list|,
name|ECORE_MCAST_CMD_DEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to send DEL MCAST command (%d)\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
name|BXE_MCAST_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|// XXX bxe_iov_chip_cleanup(sc);
comment|/*      * Send the UNLOAD_REQUEST to the MCP. This will return if      * this function should perform FUNCTION, PORT, or COMMON HW      * reset.      */
name|reset_code
operator|=
name|bxe_send_unload_req
argument_list|(
name|sc
argument_list|,
name|unload_mode
argument_list|)
expr_stmt|;
comment|/*      * (assumption: No Attention from MCP at this stage)      * PMF probably in the middle of TX disable/enable transaction      */
name|rc
operator|=
name|bxe_func_wait_started
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"bxe_func_wait_started failed (%d)\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
comment|/*      * Close multi and leading connections      * Completions for ramrods are collected in a synchronous way      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bxe_stop_queue
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
condition|)
block|{
goto|goto
name|unload_error
goto|;
block|}
block|}
comment|/*      * If SP settings didn't get completed so far - something      * very wrong has happen.      */
if|if
condition|(
operator|!
name|bxe_wait_sp_comp
argument_list|(
name|sc
argument_list|,
operator|~
literal|0x0UL
argument_list|)
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Common slow path ramrods got stuck!(%d)\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
name|unload_error
label|:
name|rc
operator|=
name|bxe_func_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Function stop failed!(%d)\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
comment|/* disable HW interrupts */
name|bxe_int_disable_sync
argument_list|(
name|sc
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* detach interrupts */
name|bxe_interrupt_detach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Reset the chip */
name|rc
operator|=
name|bxe_reset_hw
argument_list|(
name|sc
argument_list|,
name|reset_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Hardware reset failed(%d)\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
comment|/* Report UNLOAD_DONE to MCP */
name|bxe_send_unload_done
argument_list|(
name|sc
argument_list|,
name|keep_link
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_disable_close_the_gate
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|int
name|port
init|=
name|SC_PORT
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Disabling 'close the gates'\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|uint32_t
name|addr
init|=
name|port
condition|?
name|MISC_REG_AEU_MASK_ATTN_FUNC_1
else|:
name|MISC_REG_AEU_MASK_ATTN_FUNC_0
decl_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
literal|0x300
operator|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_GENERAL_MASK
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
name|MISC_AEU_GENERAL_MASK_REG_AEU_PXP_CLOSE_MASK
operator||
name|MISC_AEU_GENERAL_MASK_REG_AEU_NIG_CLOSE_MASK
operator|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_GENERAL_MASK
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Cleans the object that have internal lists without sending  * ramrods. Should be run when interrutps are disabled.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_squeeze_objects
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|unsigned
name|long
name|ramrod_flags
init|=
literal|0
decl_stmt|,
name|vlan_mac_flags
init|=
literal|0
decl_stmt|;
name|struct
name|ecore_mcast_ramrod_params
name|rparam
init|=
block|{
name|NULL
block|}
decl_stmt|;
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|mac_obj
init|=
operator|&
name|sc
operator|->
name|sp_objs
operator|->
name|mac_obj
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* Cleanup MACs' object first... */
comment|/* Wait for completion of requested */
name|bxe_set_bit
argument_list|(
name|RAMROD_COMP_WAIT
argument_list|,
operator|&
name|ramrod_flags
argument_list|)
expr_stmt|;
comment|/* Perform a dry cleanup */
name|bxe_set_bit
argument_list|(
name|RAMROD_DRV_CLR_ONLY
argument_list|,
operator|&
name|ramrod_flags
argument_list|)
expr_stmt|;
comment|/* Clean ETH primary MAC */
name|bxe_set_bit
argument_list|(
name|ECORE_ETH_MAC
argument_list|,
operator|&
name|vlan_mac_flags
argument_list|)
expr_stmt|;
name|rc
operator|=
name|mac_obj
operator|->
name|delete_all
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sp_objs
operator|->
name|mac_obj
argument_list|,
operator|&
name|vlan_mac_flags
argument_list|,
operator|&
name|ramrod_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to clean ETH MACs (%d)\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
comment|/* Cleanup UC list */
name|vlan_mac_flags
operator|=
literal|0
expr_stmt|;
name|bxe_set_bit
argument_list|(
name|ECORE_UC_LIST_MAC
argument_list|,
operator|&
name|vlan_mac_flags
argument_list|)
expr_stmt|;
name|rc
operator|=
name|mac_obj
operator|->
name|delete_all
argument_list|(
name|sc
argument_list|,
name|mac_obj
argument_list|,
operator|&
name|vlan_mac_flags
argument_list|,
operator|&
name|ramrod_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to clean UC list MACs (%d)\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
comment|/* Now clean mcast object... */
name|rparam
operator|.
name|mcast_obj
operator|=
operator|&
name|sc
operator|->
name|mcast_obj
expr_stmt|;
name|bxe_set_bit
argument_list|(
name|RAMROD_DRV_CLR_ONLY
argument_list|,
operator|&
name|rparam
operator|.
name|ramrod_flags
argument_list|)
expr_stmt|;
comment|/* Add a DEL command... */
name|rc
operator|=
name|ecore_config_mcast
argument_list|(
name|sc
argument_list|,
operator|&
name|rparam
argument_list|,
name|ECORE_MCAST_CMD_DEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to send DEL MCAST command (%d)\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
comment|/* now wait until all pending commands are cleared */
name|rc
operator|=
name|ecore_config_mcast
argument_list|(
name|sc
argument_list|,
operator|&
name|rparam
argument_list|,
name|ECORE_MCAST_CMD_CONT
argument_list|)
expr_stmt|;
while|while
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to clean MCAST object (%d)\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return;
block|}
name|rc
operator|=
name|ecore_config_mcast
argument_list|(
name|sc
argument_list|,
operator|&
name|rparam
argument_list|,
name|ECORE_MCAST_CMD_CONT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* stop the controller */
end_comment

begin_function
specifier|static
name|__noinline
name|int
name|bxe_nic_unload
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|unload_mode
parameter_list|,
name|uint8_t
name|keep_link
parameter_list|)
block|{
name|uint8_t
name|global
init|=
name|FALSE
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|int
name|i
decl_stmt|;
name|BXE_CORE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|if_setdrvflagbits
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|0
argument_list|,
name|IFF_DRV_RUNNING
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
expr_stmt|;
name|BXE_FP_TX_LOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|BXE_FP_TX_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Starting NIC unload...\n"
argument_list|)
expr_stmt|;
comment|/* mark driver as unloaded in shmem2 */
if|if
condition|(
name|IS_PF
argument_list|(
name|sc
argument_list|)
operator|&&
name|SHMEM2_HAS
argument_list|(
name|sc
argument_list|,
name|drv_capabilities_flag
argument_list|)
condition|)
block|{
name|val
operator|=
name|SHMEM2_RD
argument_list|(
name|sc
argument_list|,
name|drv_capabilities_flag
index|[
name|SC_FW_MB_IDX
argument_list|(
name|sc
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|SHMEM2_WR
argument_list|(
name|sc
argument_list|,
name|drv_capabilities_flag
index|[
name|SC_FW_MB_IDX
argument_list|(
name|sc
argument_list|)
index|]
argument_list|,
name|val
operator|&
operator|~
name|DRV_FLAGS_CAPABILITIES_LOADED_L2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IS_PF
argument_list|(
name|sc
argument_list|)
operator|&&
name|sc
operator|->
name|recovery_state
operator|!=
name|BXE_RECOVERY_DONE
operator|&&
operator|(
name|sc
operator|->
name|state
operator|==
name|BXE_STATE_CLOSED
operator|||
name|sc
operator|->
name|state
operator|==
name|BXE_STATE_ERROR
operator|)
condition|)
block|{
comment|/*          * We can get here if the driver has been unloaded          * during parity error recovery and is either waiting for a          * leader to complete or for other functions to unload and          * then ifconfig down has been issued. In this case we want to          * unload and let other functions to complete a recovery          * process.          */
name|sc
operator|->
name|recovery_state
operator|=
name|BXE_RECOVERY_DONE
expr_stmt|;
name|sc
operator|->
name|is_leader
operator|=
literal|0
expr_stmt|;
name|bxe_release_leader_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Releasing a leadership...\n"
argument_list|)
expr_stmt|;
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Can't unload in closed or error state recover_state 0x%x"
literal|" state = 0x%x\n"
argument_list|,
name|sc
operator|->
name|recovery_state
argument_list|,
name|sc
operator|->
name|state
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/*      * Nothing to do during unload if previous bxe_nic_load()      * did not completed successfully - all resourses are released.      */
if|if
condition|(
operator|(
name|sc
operator|->
name|state
operator|==
name|BXE_STATE_CLOSED
operator|)
operator|||
operator|(
name|sc
operator|->
name|state
operator|==
name|BXE_STATE_ERROR
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sc
operator|->
name|state
operator|=
name|BXE_STATE_CLOSING_WAITING_HALT
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
comment|/* stop tx */
name|bxe_tx_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx_mode
operator|=
name|BXE_RX_MODE_NONE
expr_stmt|;
comment|/* XXX set rx mode ??? */
if|if
condition|(
name|IS_PF
argument_list|(
name|sc
argument_list|)
operator|&&
operator|!
name|sc
operator|->
name|grcdump_done
condition|)
block|{
comment|/* set ALWAYS_ALIVE bit in shmem */
name|sc
operator|->
name|fw_drv_pulse_wr_seq
operator||=
name|DRV_PULSE_ALWAYS_ALIVE
expr_stmt|;
name|bxe_drv_pulse
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_stats_handle
argument_list|(
name|sc
argument_list|,
name|STATS_EVENT_STOP
argument_list|)
expr_stmt|;
name|bxe_save_statistics
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* wait till consumers catch up with producers in all queues */
name|bxe_drain_tx_queues
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* if VF indicate to PF this function is going down (PF will delete sp      * elements and clear initializations      */
if|if
condition|(
name|IS_VF
argument_list|(
name|sc
argument_list|)
condition|)
block|{
empty_stmt|;
comment|/* bxe_vfpf_close_vf(sc); */
block|}
elseif|else
if|if
condition|(
name|unload_mode
operator|!=
name|UNLOAD_RECOVERY
condition|)
block|{
comment|/* if this is a normal/close unload need to clean up chip */
if|if
condition|(
operator|!
name|sc
operator|->
name|grcdump_done
condition|)
name|bxe_chip_cleanup
argument_list|(
name|sc
argument_list|,
name|unload_mode
argument_list|,
name|keep_link
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Send the UNLOAD_REQUEST to the MCP */
name|bxe_send_unload_req
argument_list|(
name|sc
argument_list|,
name|unload_mode
argument_list|)
expr_stmt|;
comment|/*          * Prevent transactions to host from the functions on the          * engine that doesn't reset global blocks in case of global          * attention once gloabl blocks are reset and gates are opened          * (the engine which leader will perform the recovery          * last).          */
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|bxe_pf_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* disable HW interrupts */
name|bxe_int_disable_sync
argument_list|(
name|sc
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* detach interrupts */
name|bxe_interrupt_detach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Report UNLOAD_DONE to MCP */
name|bxe_send_unload_done
argument_list|(
name|sc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/*      * At this stage no more interrupts will arrive so we may safely clean      * the queue'able objects here in case they failed to get cleaned so far.      */
if|if
condition|(
name|IS_PF
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|bxe_squeeze_objects
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* There should be no more pending SP commands at this stage */
name|sc
operator|->
name|sp_state
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|port
operator|.
name|pmf
operator|=
literal|0
expr_stmt|;
name|bxe_free_fp_buffers
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_PF
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|bxe_free_mem
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|bxe_free_fw_stats_mem
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|state
operator|=
name|BXE_STATE_CLOSED
expr_stmt|;
comment|/*      * Check if there are pending parity attentions. If there are - set      * RECOVERY_IN_PROGRESS.      */
if|if
condition|(
name|IS_PF
argument_list|(
name|sc
argument_list|)
operator|&&
name|bxe_chk_parity_attn
argument_list|(
name|sc
argument_list|,
operator|&
name|global
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
name|bxe_set_reset_in_progress
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Set RESET_IS_GLOBAL if needed */
if|if
condition|(
name|global
condition|)
block|{
name|bxe_set_reset_global
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * The last driver must disable a "close the gate" if there is no      * parity attention or "process kill" pending.      */
if|if
condition|(
name|IS_PF
argument_list|(
name|sc
argument_list|)
operator|&&
operator|!
name|bxe_clear_pf_load
argument_list|(
name|sc
argument_list|)
operator|&&
name|bxe_reset_is_done
argument_list|(
name|sc
argument_list|,
name|SC_PATH
argument_list|(
name|sc
argument_list|)
argument_list|)
condition|)
block|{
name|bxe_disable_close_the_gate
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Ended NIC unload\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called by the OS to set various media options (i.e. link, speed, etc.) when  * the user runs "ifconfig bxe media ..." or "ifconfig bxe mediaopt ...".  */
end_comment

begin_function
specifier|static
name|int
name|bxe_ifmedia_update
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|bxe_softc
operator|*
operator|)
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|ifmedia
modifier|*
name|ifm
decl_stmt|;
name|ifm
operator|=
operator|&
name|sc
operator|->
name|ifmedia
expr_stmt|;
comment|/* We only support Ethernet media type. */
if|if
condition|(
name|IFM_TYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
operator|!=
name|IFM_ETHER
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
switch|switch
condition|(
name|IFM_SUBTYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
condition|)
block|{
case|case
name|IFM_AUTO
case|:
break|break;
case|case
name|IFM_10G_CX4
case|:
case|case
name|IFM_10G_SR
case|:
case|case
name|IFM_10G_T
case|:
case|case
name|IFM_10G_TWINAX
case|:
default|default:
comment|/* We don't support changing the media type. */
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Invalid media type (%d)\n"
argument_list|,
name|IFM_SUBTYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called by the OS to get the current media status (i.e. link, speed, etc.).  */
end_comment

begin_function
specifier|static
name|void
name|bxe_ifmedia_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
comment|/* Report link down if the driver isn't running. */
if|if
condition|(
operator|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_NONE
expr_stmt|;
return|return;
block|}
comment|/* Setup the default interface info. */
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|link_vars
operator|.
name|link_up
condition|)
block|{
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
block|}
else|else
block|{
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_NONE
expr_stmt|;
return|return;
block|}
name|ifmr
operator|->
name|ifm_active
operator||=
name|sc
operator|->
name|media
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|link_vars
operator|.
name|duplex
operator|==
name|DUPLEX_FULL
condition|)
block|{
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_FDX
expr_stmt|;
block|}
else|else
block|{
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_HDX
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_handle_chip_tq
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|bxe_softc
operator|*
operator|)
name|context
decl_stmt|;
name|long
name|work
init|=
name|atomic_load_acq_long
argument_list|(
operator|&
name|sc
operator|->
name|chip_tq_flags
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|work
condition|)
block|{
case|case
name|CHIP_TQ_REINIT
case|:
if|if
condition|(
name|if_getdrvflags
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
comment|/* restart the interface */
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Restarting the interface...\n"
argument_list|)
expr_stmt|;
name|bxe_periodic_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BXE_CORE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BXE_CORE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Handles any IOCTL calls from the operating system.  *  * Returns:  *   0 = Success,>0 Failure  */
end_comment

begin_function
specifier|static
name|int
name|bxe_ioctl
parameter_list|(
name|if_t
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|mask
init|=
literal|0
decl_stmt|;
name|int
name|reinit
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|mtu_min
init|=
operator|(
name|ETH_MIN_PACKET_SIZE
operator|-
name|ETH_HLEN
operator|)
decl_stmt|;
name|int
name|mtu_max
init|=
operator|(
name|MJUM9BYTES
operator|-
name|ETH_OVERHEAD
operator|-
name|IP_HEADER_ALIGNMENT_PADDING
operator|)
decl_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFMTU
case|:
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_IOCTL
argument_list|,
literal|"Received SIOCSIFMTU ioctl (mtu=%d)\n"
argument_list|,
name|ifr
operator|->
name|ifr_mtu
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mtu
operator|==
name|ifr
operator|->
name|ifr_mtu
condition|)
block|{
comment|/* nothing to change */
break|break;
block|}
if|if
condition|(
operator|(
name|ifr
operator|->
name|ifr_mtu
operator|<
name|mtu_min
operator|)
operator|||
operator|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|mtu_max
operator|)
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Unsupported MTU size %d (range is %d-%d)\n"
argument_list|,
name|ifr
operator|->
name|ifr_mtu
argument_list|,
name|mtu_min
argument_list|,
name|mtu_max
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|atomic_store_rel_int
argument_list|(
operator|(
specifier|volatile
name|unsigned
name|int
operator|*
operator|)
operator|&
name|sc
operator|->
name|mtu
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ifr
operator|->
name|ifr_mtu
argument_list|)
expr_stmt|;
comment|/*          atomic_store_rel_long((volatile unsigned long *)&if_getmtu(ifp),                               (unsigned long)ifr->ifr_mtu); 	XXX - Not sure why it needs to be atomic 	*/
name|if_setmtu
argument_list|(
name|ifp
argument_list|,
name|ifr
operator|->
name|ifr_mtu
argument_list|)
expr_stmt|;
name|reinit
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
comment|/* toggle the interface state up or down */
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_IOCTL
argument_list|,
literal|"Received SIOCSIFFLAGS ioctl\n"
argument_list|)
expr_stmt|;
name|BXE_CORE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* check if the interface is up */
if|if
condition|(
name|if_getflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
comment|/* set the receive mode flags */
name|bxe_set_rx_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|state
operator|!=
name|BXE_STATE_DISABLED
condition|)
block|{
name|bxe_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|bxe_periodic_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
name|BXE_CORE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
comment|/* add/delete multicast addresses */
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_IOCTL
argument_list|,
literal|"Received SIOCADDMULTI/SIOCDELMULTI ioctl\n"
argument_list|)
expr_stmt|;
comment|/* check if the interface is up */
if|if
condition|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
comment|/* set the receive mode flags */
name|BXE_CORE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_set_rx_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BXE_CORE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFCAP
case|:
comment|/* find out which capabilities have changed */
name|mask
operator|=
operator|(
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_IOCTL
argument_list|,
literal|"Received SIOCSIFCAP ioctl (mask=0x%08x)\n"
argument_list|,
name|mask
argument_list|)
expr_stmt|;
comment|/* toggle the LRO capabilites enable flag */
if|if
condition|(
name|mask
operator|&
name|IFCAP_LRO
condition|)
block|{
name|if_togglecapenable
argument_list|(
name|ifp
argument_list|,
name|IFCAP_LRO
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_IOCTL
argument_list|,
literal|"Turning LRO %s\n"
argument_list|,
operator|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_LRO
operator|)
condition|?
literal|"ON"
else|:
literal|"OFF"
argument_list|)
expr_stmt|;
name|reinit
operator|=
literal|1
expr_stmt|;
block|}
comment|/* toggle the TXCSUM checksum capabilites enable flag */
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
name|if_togglecapenable
argument_list|(
name|ifp
argument_list|,
name|IFCAP_TXCSUM
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_IOCTL
argument_list|,
literal|"Turning TXCSUM %s\n"
argument_list|,
operator|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_TXCSUM
operator|)
condition|?
literal|"ON"
else|:
literal|"OFF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
name|if_sethwassistbits
argument_list|(
name|ifp
argument_list|,
operator|(
name|CSUM_IP
operator||
name|CSUM_TCP
operator||
name|CSUM_UDP
operator||
name|CSUM_TSO
operator||
name|CSUM_TCP_IPV6
operator||
name|CSUM_UDP_IPV6
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|if_clearhwassist
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* XXX */
block|}
block|}
comment|/* toggle the RXCSUM checksum capabilities enable flag */
if|if
condition|(
name|mask
operator|&
name|IFCAP_RXCSUM
condition|)
block|{
name|if_togglecapenable
argument_list|(
name|ifp
argument_list|,
name|IFCAP_RXCSUM
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_IOCTL
argument_list|,
literal|"Turning RXCSUM %s\n"
argument_list|,
operator|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_RXCSUM
operator|)
condition|?
literal|"ON"
else|:
literal|"OFF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_RXCSUM
condition|)
block|{
name|if_sethwassistbits
argument_list|(
name|ifp
argument_list|,
operator|(
name|CSUM_IP
operator||
name|CSUM_TCP
operator||
name|CSUM_UDP
operator||
name|CSUM_TSO
operator||
name|CSUM_TCP_IPV6
operator||
name|CSUM_UDP_IPV6
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|if_clearhwassist
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* XXX */
block|}
block|}
comment|/* toggle TSO4 capabilities enabled flag */
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO4
condition|)
block|{
name|if_togglecapenable
argument_list|(
name|ifp
argument_list|,
name|IFCAP_TSO4
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_IOCTL
argument_list|,
literal|"Turning TSO4 %s\n"
argument_list|,
operator|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_TSO4
operator|)
condition|?
literal|"ON"
else|:
literal|"OFF"
argument_list|)
expr_stmt|;
block|}
comment|/* toggle TSO6 capabilities enabled flag */
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO6
condition|)
block|{
name|if_togglecapenable
argument_list|(
name|ifp
argument_list|,
name|IFCAP_TSO6
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_IOCTL
argument_list|,
literal|"Turning TSO6 %s\n"
argument_list|,
operator|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_TSO6
operator|)
condition|?
literal|"ON"
else|:
literal|"OFF"
argument_list|)
expr_stmt|;
block|}
comment|/* toggle VLAN_HWTSO capabilities enabled flag */
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWTSO
condition|)
block|{
name|if_togglecapenable
argument_list|(
name|ifp
argument_list|,
name|IFCAP_VLAN_HWTSO
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_IOCTL
argument_list|,
literal|"Turning VLAN_HWTSO %s\n"
argument_list|,
operator|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_VLAN_HWTSO
operator|)
condition|?
literal|"ON"
else|:
literal|"OFF"
argument_list|)
expr_stmt|;
block|}
comment|/* toggle VLAN_HWCSUM capabilities enabled flag */
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWCSUM
condition|)
block|{
comment|/* XXX investigate this... */
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Changing VLAN_HWCSUM is not supported!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
comment|/* toggle VLAN_MTU capabilities enable flag */
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_MTU
condition|)
block|{
comment|/* XXX investigate this... */
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Changing VLAN_MTU is not supported!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
comment|/* toggle VLAN_HWTAGGING capabilities enabled flag */
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWTAGGING
condition|)
block|{
comment|/* XXX investigate this... */
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Changing VLAN_HWTAGGING is not supported!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
comment|/* toggle VLAN_HWFILTER capabilities enabled flag */
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWFILTER
condition|)
block|{
comment|/* XXX investigate this... */
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Changing VLAN_HWFILTER is not supported!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
comment|/* XXX not yet...          * IFCAP_WOL_MAGIC          */
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
comment|/* set/get interface media */
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_IOCTL
argument_list|,
literal|"Received SIOCSIFMEDIA/SIOCGIFMEDIA ioctl (cmd=%lu)\n"
argument_list|,
operator|(
name|command
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
default|default:
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_IOCTL
argument_list|,
literal|"Received Unknown Ioctl (cmd=%lu)\n"
argument_list|,
operator|(
name|command
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|reinit
operator|&&
operator|(
name|if_getdrvflags
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
operator||
name|DBG_IOCTL
argument_list|,
literal|"Re-initializing hardware from IOCTL change\n"
argument_list|)
expr_stmt|;
name|bxe_periodic_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BXE_CORE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BXE_CORE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__noinline
name|void
name|bxe_dump_mbuf
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint8_t
name|contents
parameter_list|)
block|{
name|char
modifier|*
name|type
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|debug
operator|&
name|DBG_MBUF
operator|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_MBUF
argument_list|,
literal|"mbuf: null pointer\n"
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|m
condition|)
block|{
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|1000000
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_MBUF
argument_list|,
literal|"%02d: mbuf=%p m_len=%d m_flags=0x%b m_data=%p\n"
argument_list|,
name|i
argument_list|,
name|m
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|m
operator|->
name|m_flags
argument_list|,
name|M_FLAG_BITS
argument_list|,
name|m
operator|->
name|m_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_MBUF
argument_list|,
literal|"%02d: - m_pkthdr: tot_len=%d flags=0x%b csum_flags=%b\n"
argument_list|,
name|i
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|m
operator|->
name|m_flags
argument_list|,
name|M_FLAG_BITS
argument_list|,
operator|(
name|int
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
argument_list|,
name|CSUM_BITS
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_MBUF
argument_list|,
literal|"%02d: mbuf=%p m_len=%d m_flags=0x%b m_data=%p\n"
argument_list|,
name|i
argument_list|,
name|m
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|m
operator|->
name|m_flags
argument_list|,
literal|"\20\1M_EXT\2M_PKTHDR\3M_EOR\4M_RDONLY"
argument_list|,
name|m
operator|->
name|m_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_MBUF
argument_list|,
literal|"%02d: - m_pkthdr: tot_len=%d flags=0x%b csum_flags=%b\n"
argument_list|,
name|i
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|m
operator|->
name|m_flags
argument_list|,
literal|"\20\12M_BCAST\13M_MCAST\14M_FRAG"
literal|"\15M_FIRSTFRAG\16M_LASTFRAG\21M_VLANTAG"
literal|"\22M_PROMISC\23M_NOFREE"
argument_list|,
operator|(
name|int
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
argument_list|,
literal|"\20\1CSUM_IP\2CSUM_TCP\3CSUM_UDP\4CSUM_IP_FRAGS"
literal|"\5CSUM_FRAGMENT\6CSUM_TSO\11CSUM_IP_CHECKED"
literal|"\12CSUM_IP_VALID\13CSUM_DATA_VALID"
literal|"\14CSUM_PSEUDO_HDR"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* #if __FreeBSD_version>= 1000000 */
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
block|{
switch|switch
condition|(
name|m
operator|->
name|m_ext
operator|.
name|ext_type
condition|)
block|{
case|case
name|EXT_CLUSTER
case|:
name|type
operator|=
literal|"EXT_CLUSTER"
expr_stmt|;
break|break;
case|case
name|EXT_SFBUF
case|:
name|type
operator|=
literal|"EXT_SFBUF"
expr_stmt|;
break|break;
case|case
name|EXT_JUMBOP
case|:
name|type
operator|=
literal|"EXT_JUMBOP"
expr_stmt|;
break|break;
case|case
name|EXT_JUMBO9
case|:
name|type
operator|=
literal|"EXT_JUMBO9"
expr_stmt|;
break|break;
case|case
name|EXT_JUMBO16
case|:
name|type
operator|=
literal|"EXT_JUMBO16"
expr_stmt|;
break|break;
case|case
name|EXT_PACKET
case|:
name|type
operator|=
literal|"EXT_PACKET"
expr_stmt|;
break|break;
case|case
name|EXT_MBUF
case|:
name|type
operator|=
literal|"EXT_MBUF"
expr_stmt|;
break|break;
case|case
name|EXT_NET_DRV
case|:
name|type
operator|=
literal|"EXT_NET_DRV"
expr_stmt|;
break|break;
case|case
name|EXT_MOD_TYPE
case|:
name|type
operator|=
literal|"EXT_MOD_TYPE"
expr_stmt|;
break|break;
case|case
name|EXT_DISPOSABLE
case|:
name|type
operator|=
literal|"EXT_DISPOSABLE"
expr_stmt|;
break|break;
case|case
name|EXT_EXTREF
case|:
name|type
operator|=
literal|"EXT_EXTREF"
expr_stmt|;
break|break;
default|default:
name|type
operator|=
literal|"UNKNOWN"
expr_stmt|;
break|break;
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_MBUF
argument_list|,
literal|"%02d: - m_ext: %p ext_size=%d type=%s\n"
argument_list|,
name|i
argument_list|,
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
argument_list|,
name|m
operator|->
name|m_ext
operator|.
name|ext_size
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|contents
condition|)
block|{
name|bxe_dump_mbuf_data
argument_list|(
name|sc
argument_list|,
literal|"mbuf data"
argument_list|,
name|m
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Checks to ensure the 13 bd sliding window is>= MSS for TSO.  * Check that (13 total bds - 3 bds) = 10 bd window>= MSS.  * The window: 3 bds are = 1 for headers BD + 2 for parse BD and last BD  * The headers comes in a separate bd in FreeBSD so 13-3=10.  * Returns: 0 if OK to send, 1 if packet needs further defragmentation  */
end_comment

begin_function
specifier|static
name|int
name|bxe_chktso_window
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|uint32_t
name|num_wnds
decl_stmt|,
name|wnd_size
decl_stmt|,
name|wnd_sum
decl_stmt|;
name|int32_t
name|frag_idx
decl_stmt|,
name|wnd_idx
decl_stmt|;
name|unsigned
name|short
name|lso_mss
decl_stmt|;
name|int
name|defrag
decl_stmt|;
name|defrag
operator|=
literal|0
expr_stmt|;
name|wnd_sum
operator|=
literal|0
expr_stmt|;
name|wnd_size
operator|=
literal|10
expr_stmt|;
name|num_wnds
operator|=
name|nsegs
operator|-
name|wnd_size
expr_stmt|;
name|lso_mss
operator|=
name|htole16
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
argument_list|)
expr_stmt|;
comment|/*      * Total header lengths Eth+IP+TCP in first FreeBSD mbuf so calculate the      * first window sum of data while skipping the first assuming it is the      * header in FreeBSD.      */
for|for
control|(
name|frag_idx
operator|=
literal|1
init|;
operator|(
name|frag_idx
operator|<=
name|wnd_size
operator|)
condition|;
name|frag_idx
operator|++
control|)
block|{
name|wnd_sum
operator|+=
name|htole16
argument_list|(
name|segs
index|[
name|frag_idx
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
block|}
comment|/* check the first 10 bd window size */
if|if
condition|(
name|wnd_sum
operator|<
name|lso_mss
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* run through the windows */
for|for
control|(
name|wnd_idx
operator|=
literal|0
init|;
name|wnd_idx
operator|<
name|num_wnds
condition|;
name|wnd_idx
operator|++
operator|,
name|frag_idx
operator|++
control|)
block|{
comment|/* subtract the first mbuf->m_len of the last wndw(-header) */
name|wnd_sum
operator|-=
name|htole16
argument_list|(
name|segs
index|[
name|wnd_idx
operator|+
literal|1
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
comment|/* add the next mbuf len to the len of our new window */
name|wnd_sum
operator|+=
name|htole16
argument_list|(
name|segs
index|[
name|frag_idx
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|wnd_sum
operator|<
name|lso_mss
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|bxe_set_pbd_csum_e2
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint32_t
modifier|*
name|parsing_data
parameter_list|)
block|{
name|struct
name|ether_vlan_header
modifier|*
name|eh
init|=
name|NULL
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip4
init|=
name|NULL
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
init|=
name|NULL
decl_stmt|;
name|caddr_t
name|ip
init|=
name|NULL
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|th
init|=
name|NULL
decl_stmt|;
name|int
name|e_hlen
decl_stmt|,
name|ip_hlen
decl_stmt|,
name|l4_off
decl_stmt|;
name|uint16_t
name|proto
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|==
name|CSUM_IP
condition|)
block|{
comment|/* no L4 checksum offload needed */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* get the Ethernet header */
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
expr_stmt|;
comment|/* handle VLAN encapsulation if present */
if|if
condition|(
name|eh
operator|->
name|evl_encap_proto
operator|==
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
condition|)
block|{
name|e_hlen
operator|=
operator|(
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
operator|)
expr_stmt|;
name|proto
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|evl_proto
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|e_hlen
operator|=
name|ETHER_HDR_LEN
expr_stmt|;
name|proto
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|evl_encap_proto
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|ETHERTYPE_IP
case|:
comment|/* get the IP header, if mbuf len< 20 then header in next mbuf */
name|ip4
operator|=
operator|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|)
condition|?
operator|(
expr|struct
name|ip
operator|*
operator|)
name|m
operator|->
name|m_next
operator|->
name|m_data
else|:
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|m
operator|->
name|m_data
operator|+
name|e_hlen
operator|)
expr_stmt|;
comment|/* ip_hl is number of 32-bit words */
name|ip_hlen
operator|=
operator|(
name|ip4
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
expr_stmt|;
name|ip
operator|=
operator|(
name|caddr_t
operator|)
name|ip4
expr_stmt|;
break|break;
case|case
name|ETHERTYPE_IPV6
case|:
comment|/* get the IPv6 header, if mbuf len< 40 then header in next mbuf */
name|ip6
operator|=
operator|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|)
condition|?
operator|(
expr|struct
name|ip6_hdr
operator|*
operator|)
name|m
operator|->
name|m_next
operator|->
name|m_data
else|:
operator|(
expr|struct
name|ip6_hdr
operator|*
operator|)
operator|(
name|m
operator|->
name|m_data
operator|+
name|e_hlen
operator|)
expr_stmt|;
comment|/* XXX cannot support offload with IPv6 extensions */
name|ip_hlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
name|ip
operator|=
operator|(
name|caddr_t
operator|)
name|ip6
expr_stmt|;
break|break;
default|default:
comment|/* We can't offload in this case... */
comment|/* XXX error stat ??? */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* XXX assuming L4 header is contiguous to IPv4/IPv6 in the same mbuf */
name|l4_off
operator|=
operator|(
name|e_hlen
operator|+
name|ip_hlen
operator|)
expr_stmt|;
operator|*
name|parsing_data
operator||=
operator|(
operator|(
operator|(
name|l4_off
operator|>>
literal|1
operator|)
operator|<<
name|ETH_TX_PARSE_BD_E2_L4_HDR_START_OFFSET_W_SHIFT
operator|)
operator|&
name|ETH_TX_PARSE_BD_E2_L4_HDR_START_OFFSET_W
operator|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_TCP
operator||
name|CSUM_TSO
operator||
name|CSUM_TCP_IPV6
operator|)
condition|)
block|{
name|fp
operator|->
name|eth_q_stats
operator|.
name|tx_ofld_frames_csum_tcp
operator|++
expr_stmt|;
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
name|ip
operator|+
name|ip_hlen
operator|)
expr_stmt|;
comment|/* th_off is number of 32-bit words */
operator|*
name|parsing_data
operator||=
operator|(
operator|(
name|th
operator|->
name|th_off
operator|<<
name|ETH_TX_PARSE_BD_E2_TCP_HDR_LENGTH_DW_SHIFT
operator|)
operator|&
name|ETH_TX_PARSE_BD_E2_TCP_HDR_LENGTH_DW
operator|)
expr_stmt|;
return|return
operator|(
name|l4_off
operator|+
operator|(
name|th
operator|->
name|th_off
operator|<<
literal|2
operator|)
operator|)
return|;
comment|/* entire header length */
block|}
elseif|else
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_UDP
operator||
name|CSUM_UDP_IPV6
operator|)
condition|)
block|{
name|fp
operator|->
name|eth_q_stats
operator|.
name|tx_ofld_frames_csum_udp
operator|++
expr_stmt|;
return|return
operator|(
name|l4_off
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
operator|)
return|;
comment|/* entire header length */
block|}
else|else
block|{
comment|/* XXX error stat ??? */
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|bxe_set_pbd_csum
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|eth_tx_parse_bd_e1x
modifier|*
name|pbd
parameter_list|)
block|{
name|struct
name|ether_vlan_header
modifier|*
name|eh
init|=
name|NULL
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip4
init|=
name|NULL
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
init|=
name|NULL
decl_stmt|;
name|caddr_t
name|ip
init|=
name|NULL
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|th
init|=
name|NULL
decl_stmt|;
name|struct
name|udphdr
modifier|*
name|uh
init|=
name|NULL
decl_stmt|;
name|int
name|e_hlen
decl_stmt|,
name|ip_hlen
decl_stmt|;
name|uint16_t
name|proto
decl_stmt|;
name|uint8_t
name|hlen
decl_stmt|;
name|uint16_t
name|tmp_csum
decl_stmt|;
name|uint32_t
modifier|*
name|tmp_uh
decl_stmt|;
comment|/* get the Ethernet header */
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
expr_stmt|;
comment|/* handle VLAN encapsulation if present */
if|if
condition|(
name|eh
operator|->
name|evl_encap_proto
operator|==
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
condition|)
block|{
name|e_hlen
operator|=
operator|(
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
operator|)
expr_stmt|;
name|proto
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|evl_proto
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|e_hlen
operator|=
name|ETHER_HDR_LEN
expr_stmt|;
name|proto
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|evl_encap_proto
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|ETHERTYPE_IP
case|:
comment|/* get the IP header, if mbuf len< 20 then header in next mbuf */
name|ip4
operator|=
operator|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|)
condition|?
operator|(
expr|struct
name|ip
operator|*
operator|)
name|m
operator|->
name|m_next
operator|->
name|m_data
else|:
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|m
operator|->
name|m_data
operator|+
name|e_hlen
operator|)
expr_stmt|;
comment|/* ip_hl is number of 32-bit words */
name|ip_hlen
operator|=
operator|(
name|ip4
operator|->
name|ip_hl
operator|<<
literal|1
operator|)
expr_stmt|;
name|ip
operator|=
operator|(
name|caddr_t
operator|)
name|ip4
expr_stmt|;
break|break;
case|case
name|ETHERTYPE_IPV6
case|:
comment|/* get the IPv6 header, if mbuf len< 40 then header in next mbuf */
name|ip6
operator|=
operator|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|)
condition|?
operator|(
expr|struct
name|ip6_hdr
operator|*
operator|)
name|m
operator|->
name|m_next
operator|->
name|m_data
else|:
operator|(
expr|struct
name|ip6_hdr
operator|*
operator|)
operator|(
name|m
operator|->
name|m_data
operator|+
name|e_hlen
operator|)
expr_stmt|;
comment|/* XXX cannot support offload with IPv6 extensions */
name|ip_hlen
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|>>
literal|1
operator|)
expr_stmt|;
name|ip
operator|=
operator|(
name|caddr_t
operator|)
name|ip6
expr_stmt|;
break|break;
default|default:
comment|/* We can't offload in this case... */
comment|/* XXX error stat ??? */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|hlen
operator|=
operator|(
name|e_hlen
operator|>>
literal|1
operator|)
expr_stmt|;
comment|/* note that rest of global_data is indirectly zeroed here */
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_VLANTAG
condition|)
block|{
name|pbd
operator|->
name|global_data
operator|=
name|htole16
argument_list|(
name|hlen
operator||
operator|(
literal|1
operator|<<
name|ETH_TX_PARSE_BD_E1X_LLC_SNAP_EN_SHIFT
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pbd
operator|->
name|global_data
operator|=
name|htole16
argument_list|(
name|hlen
argument_list|)
expr_stmt|;
block|}
name|pbd
operator|->
name|ip_hlen_w
operator|=
name|ip_hlen
expr_stmt|;
name|hlen
operator|+=
name|pbd
operator|->
name|ip_hlen_w
expr_stmt|;
comment|/* XXX assuming L4 header is contiguous to IPv4/IPv6 in the same mbuf */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_TCP
operator||
name|CSUM_TSO
operator||
name|CSUM_TCP_IPV6
operator|)
condition|)
block|{
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
name|ip
operator|+
operator|(
name|ip_hlen
operator|<<
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* th_off is number of 32-bit words */
name|hlen
operator|+=
call|(
name|uint16_t
call|)
argument_list|(
name|th
operator|->
name|th_off
operator|<<
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_UDP
operator||
name|CSUM_UDP_IPV6
operator|)
condition|)
block|{
name|uh
operator|=
operator|(
expr|struct
name|udphdr
operator|*
operator|)
operator|(
name|ip
operator|+
operator|(
name|ip_hlen
operator|<<
literal|1
operator|)
operator|)
expr_stmt|;
name|hlen
operator|+=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
operator|/
literal|2
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* valid case as only CSUM_IP was set */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pbd
operator|->
name|total_hlen_w
operator|=
name|htole16
argument_list|(
name|hlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_TCP
operator||
name|CSUM_TSO
operator||
name|CSUM_TCP_IPV6
operator|)
condition|)
block|{
name|fp
operator|->
name|eth_q_stats
operator|.
name|tx_ofld_frames_csum_tcp
operator|++
expr_stmt|;
name|pbd
operator|->
name|tcp_pseudo_csum
operator|=
name|ntohs
argument_list|(
name|th
operator|->
name|th_sum
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_UDP
operator||
name|CSUM_UDP_IPV6
operator|)
condition|)
block|{
name|fp
operator|->
name|eth_q_stats
operator|.
name|tx_ofld_frames_csum_udp
operator|++
expr_stmt|;
comment|/*          * Everest1 (i.e. 57710, 57711, 57711E) does not natively support UDP          * checksums and does not know anything about the UDP header and where          * the checksum field is located. It only knows about TCP. Therefore          * we "lie" to the hardware for outgoing UDP packets w/ checksum          * offload. Since the checksum field offset for TCP is 16 bytes and          * for UDP it is 6 bytes we pass a pointer to the hardware that is 10          * bytes less than the start of the UDP header. This allows the          * hardware to write the checksum in the correct spot. But the          * hardware will compute a checksum which includes the last 10 bytes          * of the IP header. To correct this we tweak the stack computed          * pseudo checksum by folding in the calculation of the inverse          * checksum for those final 10 bytes of the IP header. This allows          * the correct checksum to be computed by the hardware.          */
comment|/* set pointer 10 bytes before UDP header */
name|tmp_uh
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|uh
operator|-
literal|10
operator|)
expr_stmt|;
comment|/* calculate a pseudo header checksum over the first 10 bytes */
name|tmp_csum
operator|=
name|in_pseudo
argument_list|(
operator|*
name|tmp_uh
argument_list|,
operator|*
operator|(
name|tmp_uh
operator|+
literal|1
operator|)
argument_list|,
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|tmp_uh
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|pbd
operator|->
name|tcp_pseudo_csum
operator|=
name|ntohs
argument_list|(
name|in_addword
argument_list|(
name|uh
operator|->
name|uh_sum
argument_list|,
operator|~
name|tmp_csum
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|hlen
operator|*
literal|2
operator|)
return|;
comment|/* entire header length, number of bytes */
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_set_pbd_lso_e2
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint32_t
modifier|*
name|parsing_data
parameter_list|)
block|{
operator|*
name|parsing_data
operator||=
operator|(
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
operator|<<
name|ETH_TX_PARSE_BD_E2_LSO_MSS_SHIFT
operator|)
operator|&
name|ETH_TX_PARSE_BD_E2_LSO_MSS
operator|)
expr_stmt|;
comment|/* XXX test for IPv6 with extension header... */
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_set_pbd_lso
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|eth_tx_parse_bd_e1x
modifier|*
name|pbd
parameter_list|)
block|{
name|struct
name|ether_vlan_header
modifier|*
name|eh
init|=
name|NULL
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
init|=
name|NULL
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|th
init|=
name|NULL
decl_stmt|;
name|int
name|e_hlen
decl_stmt|;
comment|/* get the Ethernet header */
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
expr_stmt|;
comment|/* handle VLAN encapsulation if present */
name|e_hlen
operator|=
operator|(
name|eh
operator|->
name|evl_encap_proto
operator|==
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
operator|)
condition|?
operator|(
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
operator|)
else|:
name|ETHER_HDR_LEN
expr_stmt|;
comment|/* get the IP and TCP header, with LSO entire header in first mbuf */
comment|/* XXX assuming IPv4 */
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|m
operator|->
name|m_data
operator|+
name|e_hlen
operator|)
expr_stmt|;
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
name|pbd
operator|->
name|lso_mss
operator|=
name|htole16
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
argument_list|)
expr_stmt|;
name|pbd
operator|->
name|tcp_send_seq
operator|=
name|ntohl
argument_list|(
name|th
operator|->
name|th_seq
argument_list|)
expr_stmt|;
name|pbd
operator|->
name|tcp_flags
operator|=
operator|(
operator|(
name|ntohl
argument_list|(
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|th
operator|)
index|[
literal|3
index|]
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* XXX IPv4 */
name|pbd
operator|->
name|ip_id
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_id
argument_list|)
expr_stmt|;
name|pbd
operator|->
name|tcp_pseudo_csum
operator|=
name|ntohs
argument_list|(
name|in_pseudo
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|,
name|htons
argument_list|(
name|IPPROTO_TCP
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* XXX IPv6 */
name|pbd
operator|->
name|tcp_pseudo_csum
operator|=
name|ntohs
argument_list|(
name|in_pseudo
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|,
name|htons
argument_list|(
name|IPPROTO_TCP
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pbd
operator|->
name|global_data
operator||=
name|htole16
argument_list|(
name|ETH_TX_PARSE_BD_E1X_PSEUDO_CS_WITHOUT_LEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Encapsulte an mbuf cluster into the tx bd chain and makes the memory  * visible to the controller.  *  * If an mbuf is submitted to this routine and cannot be given to the  * controller (e.g. it has too many fragments) then the function may free  * the mbuf and return to the caller.  *  * Returns:  *   0 = Success, !0 = Failure  *   Note the side effect that an mbuf may be freed if it causes a problem.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_tx_encap
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m_head
parameter_list|)
block|{
name|bus_dma_segment_t
name|segs
index|[
literal|32
index|]
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|struct
name|bxe_sw_tx_bd
modifier|*
name|tx_buf
decl_stmt|;
name|struct
name|eth_tx_parse_bd_e1x
modifier|*
name|pbd_e1x
init|=
name|NULL
decl_stmt|;
name|struct
name|eth_tx_parse_bd_e2
modifier|*
name|pbd_e2
init|=
name|NULL
decl_stmt|;
comment|/* struct eth_tx_parse_2nd_bd *pbd2 = NULL; */
name|struct
name|eth_tx_bd
modifier|*
name|tx_data_bd
decl_stmt|;
name|struct
name|eth_tx_bd
modifier|*
name|tx_total_pkt_size_bd
decl_stmt|;
name|struct
name|eth_tx_start_bd
modifier|*
name|tx_start_bd
decl_stmt|;
name|uint16_t
name|bd_prod
decl_stmt|,
name|pkt_prod
decl_stmt|,
name|total_pkt_size
decl_stmt|;
name|uint8_t
name|mac_type
decl_stmt|;
name|int
name|defragged
decl_stmt|,
name|error
decl_stmt|,
name|nsegs
decl_stmt|,
name|rc
decl_stmt|,
name|nbds
decl_stmt|,
name|vlan_off
decl_stmt|,
name|ovlan
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|uint16_t
name|tx_bd_avail
decl_stmt|;
name|struct
name|ether_vlan_header
modifier|*
name|eh
decl_stmt|;
name|uint32_t
name|pbd_e2_parsing_data
init|=
literal|0
decl_stmt|;
name|uint8_t
name|hlen
init|=
literal|0
decl_stmt|;
name|int
name|tmp_bd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|fp
operator|->
name|sc
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
name|M_ASSERTPKTHDR
argument_list|(
operator|*
name|m_head
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* #if __FreeBSD_version>= 800000 */
name|m0
operator|=
operator|*
name|m_head
expr_stmt|;
name|rc
operator|=
name|defragged
operator|=
name|nbds
operator|=
name|ovlan
operator|=
name|vlan_off
operator|=
name|total_pkt_size
operator|=
literal|0
expr_stmt|;
name|tx_start_bd
operator|=
name|NULL
expr_stmt|;
name|tx_data_bd
operator|=
name|NULL
expr_stmt|;
name|tx_total_pkt_size_bd
operator|=
name|NULL
expr_stmt|;
comment|/* get the H/W pointer for packets and BDs */
name|pkt_prod
operator|=
name|fp
operator|->
name|tx_pkt_prod
expr_stmt|;
name|bd_prod
operator|=
name|fp
operator|->
name|tx_bd_prod
expr_stmt|;
name|mac_type
operator|=
name|UNICAST_ADDRESS
expr_stmt|;
comment|/* map the mbuf into the next open DMAable memory */
name|tx_buf
operator|=
operator|&
name|fp
operator|->
name|tx_mbuf_chain
index|[
name|TX_BD
argument_list|(
name|pkt_prod
argument_list|)
index|]
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|fp
operator|->
name|tx_mbuf_tag
argument_list|,
name|tx_buf
operator|->
name|m_map
argument_list|,
name|m0
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
comment|/* mapping errors */
if|if
condition|(
name|__predict_false
argument_list|(
name|error
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|fp
operator|->
name|eth_q_stats
operator|.
name|tx_dma_mapping_failure
operator|++
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOMEM
condition|)
block|{
comment|/* resource issue, try again later */
name|rc
operator|=
name|ENOMEM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|EFBIG
condition|)
block|{
comment|/* possibly recoverable with defragmentation */
name|fp
operator|->
name|eth_q_stats
operator|.
name|mbuf_defrag_attempts
operator|++
expr_stmt|;
name|m0
operator|=
name|m_defrag
argument_list|(
operator|*
name|m_head
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|fp
operator|->
name|eth_q_stats
operator|.
name|mbuf_defrag_failures
operator|++
expr_stmt|;
name|rc
operator|=
name|ENOBUFS
expr_stmt|;
block|}
else|else
block|{
comment|/* defrag successful, try mapping again */
operator|*
name|m_head
operator|=
name|m0
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|fp
operator|->
name|tx_mbuf_tag
argument_list|,
name|tx_buf
operator|->
name|m_map
argument_list|,
name|m0
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|fp
operator|->
name|eth_q_stats
operator|.
name|tx_dma_mapping_failure
operator|++
expr_stmt|;
name|rc
operator|=
name|error
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* unknown, unrecoverable mapping error */
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Unknown TX mapping error rc=%d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|bxe_dump_mbuf
argument_list|(
name|sc
argument_list|,
name|m0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|rc
operator|=
name|error
expr_stmt|;
block|}
goto|goto
name|bxe_tx_encap_continue
goto|;
block|}
name|tx_bd_avail
operator|=
name|bxe_tx_avail
argument_list|(
name|sc
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* make sure there is enough room in the send queue */
if|if
condition|(
name|__predict_false
argument_list|(
name|tx_bd_avail
operator|<
operator|(
name|nsegs
operator|+
literal|2
operator|)
argument_list|)
condition|)
block|{
comment|/* Recoverable, try again later. */
name|fp
operator|->
name|eth_q_stats
operator|.
name|tx_hw_queue_full
operator|++
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|fp
operator|->
name|tx_mbuf_tag
argument_list|,
name|tx_buf
operator|->
name|m_map
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bxe_tx_encap_continue
goto|;
block|}
comment|/* capture the current H/W TX chain high watermark */
if|if
condition|(
name|__predict_false
argument_list|(
name|fp
operator|->
name|eth_q_stats
operator|.
name|tx_hw_max_queue_depth
operator|<
operator|(
name|TX_BD_USABLE
operator|-
name|tx_bd_avail
operator|)
argument_list|)
condition|)
block|{
name|fp
operator|->
name|eth_q_stats
operator|.
name|tx_hw_max_queue_depth
operator|=
operator|(
name|TX_BD_USABLE
operator|-
name|tx_bd_avail
operator|)
expr_stmt|;
block|}
comment|/* make sure it fits in the packet window */
if|if
condition|(
name|__predict_false
argument_list|(
name|nsegs
operator|>
name|BXE_MAX_SEGMENTS
argument_list|)
condition|)
block|{
comment|/*          * The mbuf may be to big for the controller to handle. If the frame          * is a TSO frame we'll need to do an additional check.          */
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
condition|)
block|{
if|if
condition|(
name|bxe_chktso_window
argument_list|(
name|sc
argument_list|,
name|nsegs
argument_list|,
name|segs
argument_list|,
name|m0
argument_list|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|bxe_tx_encap_continue
goto|;
comment|/* OK to send */
block|}
else|else
block|{
name|fp
operator|->
name|eth_q_stats
operator|.
name|tx_window_violation_tso
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|fp
operator|->
name|eth_q_stats
operator|.
name|tx_window_violation_std
operator|++
expr_stmt|;
block|}
comment|/* lets try to defragment this mbuf and remap it */
name|fp
operator|->
name|eth_q_stats
operator|.
name|mbuf_defrag_attempts
operator|++
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|fp
operator|->
name|tx_mbuf_tag
argument_list|,
name|tx_buf
operator|->
name|m_map
argument_list|)
expr_stmt|;
name|m0
operator|=
name|m_defrag
argument_list|(
operator|*
name|m_head
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|fp
operator|->
name|eth_q_stats
operator|.
name|mbuf_defrag_failures
operator|++
expr_stmt|;
comment|/* Ugh, just drop the frame... :( */
name|rc
operator|=
name|ENOBUFS
expr_stmt|;
block|}
else|else
block|{
comment|/* defrag successful, try mapping again */
operator|*
name|m_head
operator|=
name|m0
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|fp
operator|->
name|tx_mbuf_tag
argument_list|,
name|tx_buf
operator|->
name|m_map
argument_list|,
name|m0
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|fp
operator|->
name|eth_q_stats
operator|.
name|tx_dma_mapping_failure
operator|++
expr_stmt|;
comment|/* No sense in trying to defrag/copy chain, drop it. :( */
name|rc
operator|=
name|error
expr_stmt|;
block|}
else|else
block|{
comment|/* if the chain is still too long then drop it */
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
condition|)
block|{
comment|/*                      * in case TSO is enabled nsegs should be checked against                      * BXE_TSO_MAX_SEGMENTS                      */
if|if
condition|(
name|__predict_false
argument_list|(
name|nsegs
operator|>
name|BXE_TSO_MAX_SEGMENTS
argument_list|)
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|fp
operator|->
name|tx_mbuf_tag
argument_list|,
name|tx_buf
operator|->
name|m_map
argument_list|)
expr_stmt|;
name|fp
operator|->
name|eth_q_stats
operator|.
name|nsegs_path1_errors
operator|++
expr_stmt|;
name|rc
operator|=
name|ENODEV
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|__predict_false
argument_list|(
name|nsegs
operator|>
name|BXE_MAX_SEGMENTS
argument_list|)
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|fp
operator|->
name|tx_mbuf_tag
argument_list|,
name|tx_buf
operator|->
name|m_map
argument_list|)
expr_stmt|;
name|fp
operator|->
name|eth_q_stats
operator|.
name|nsegs_path2_errors
operator|++
expr_stmt|;
name|rc
operator|=
name|ENODEV
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|bxe_tx_encap_continue
label|:
comment|/* Check for errors */
if|if
condition|(
name|rc
condition|)
block|{
if|if
condition|(
name|rc
operator|==
name|ENOMEM
condition|)
block|{
comment|/* recoverable try again later  */
block|}
else|else
block|{
name|fp
operator|->
name|eth_q_stats
operator|.
name|tx_soft_errors
operator|++
expr_stmt|;
name|fp
operator|->
name|eth_q_stats
operator|.
name|mbuf_alloc_tx
operator|--
expr_stmt|;
name|m_freem
argument_list|(
operator|*
name|m_head
argument_list|)
expr_stmt|;
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
comment|/* set flag according to packet type (UNICAST_ADDRESS is default) */
if|if
condition|(
name|m0
operator|->
name|m_flags
operator|&
name|M_BCAST
condition|)
block|{
name|mac_type
operator|=
name|BROADCAST_ADDRESS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m0
operator|->
name|m_flags
operator|&
name|M_MCAST
condition|)
block|{
name|mac_type
operator|=
name|MULTICAST_ADDRESS
expr_stmt|;
block|}
comment|/* store the mbuf into the mbuf ring */
name|tx_buf
operator|->
name|m
operator|=
name|m0
expr_stmt|;
name|tx_buf
operator|->
name|first_bd
operator|=
name|fp
operator|->
name|tx_bd_prod
expr_stmt|;
name|tx_buf
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* prepare the first transmit (start) BD for the mbuf */
name|tx_start_bd
operator|=
operator|&
name|fp
operator|->
name|tx_chain
index|[
name|TX_BD
argument_list|(
name|bd_prod
argument_list|)
index|]
operator|.
name|start_bd
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_TX
argument_list|,
literal|"sending pkt_prod=%u tx_buf=%p next_idx=%u bd=%u tx_start_bd=%p\n"
argument_list|,
name|pkt_prod
argument_list|,
name|tx_buf
argument_list|,
name|fp
operator|->
name|tx_pkt_prod
argument_list|,
name|bd_prod
argument_list|,
name|tx_start_bd
argument_list|)
expr_stmt|;
name|tx_start_bd
operator|->
name|addr_lo
operator|=
name|htole32
argument_list|(
name|U64_LO
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|tx_start_bd
operator|->
name|addr_hi
operator|=
name|htole32
argument_list|(
name|U64_HI
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|tx_start_bd
operator|->
name|nbytes
operator|=
name|htole16
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
name|total_pkt_size
operator|+=
name|tx_start_bd
operator|->
name|nbytes
expr_stmt|;
name|tx_start_bd
operator|->
name|bd_flags
operator|.
name|as_bitfield
operator|=
name|ETH_TX_BD_FLAGS_START_BD
expr_stmt|;
name|tx_start_bd
operator|->
name|general_data
operator|=
operator|(
literal|1
operator|<<
name|ETH_TX_START_BD_HDR_NBDS_SHIFT
operator|)
expr_stmt|;
comment|/* all frames have at least Start BD + Parsing BD */
name|nbds
operator|=
name|nsegs
operator|+
literal|1
expr_stmt|;
name|tx_start_bd
operator|->
name|nbd
operator|=
name|htole16
argument_list|(
name|nbds
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|->
name|m_flags
operator|&
name|M_VLANTAG
condition|)
block|{
name|tx_start_bd
operator|->
name|vlan_or_ethertype
operator|=
name|htole16
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
argument_list|)
expr_stmt|;
name|tx_start_bd
operator|->
name|bd_flags
operator|.
name|as_bitfield
operator||=
operator|(
name|X_ETH_OUTBAND_VLAN
operator|<<
name|ETH_TX_BD_FLAGS_VLAN_MODE_SHIFT
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* vf tx, start bd must hold the ethertype for fw to enforce it */
if|if
condition|(
name|IS_VF
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* map ethernet header to find type and header length */
name|eh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
expr_stmt|;
name|tx_start_bd
operator|->
name|vlan_or_ethertype
operator|=
name|eh
operator|->
name|evl_encap_proto
expr_stmt|;
block|}
else|else
block|{
comment|/* used by FW for packet accounting */
name|tx_start_bd
operator|->
name|vlan_or_ethertype
operator|=
name|htole16
argument_list|(
name|fp
operator|->
name|tx_pkt_prod
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * add a parsing BD from the chain. The parsing BD is always added      * though it is only used for TSO and chksum      */
name|bd_prod
operator|=
name|TX_BD_NEXT
argument_list|(
name|bd_prod
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
condition|)
block|{
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_IP
condition|)
block|{
name|fp
operator|->
name|eth_q_stats
operator|.
name|tx_ofld_frames_csum_ip
operator|++
expr_stmt|;
name|tx_start_bd
operator|->
name|bd_flags
operator|.
name|as_bitfield
operator||=
name|ETH_TX_BD_FLAGS_IP_CSUM
expr_stmt|;
block|}
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TCP_IPV6
condition|)
block|{
name|tx_start_bd
operator|->
name|bd_flags
operator|.
name|as_bitfield
operator||=
operator|(
name|ETH_TX_BD_FLAGS_IPV6
operator||
name|ETH_TX_BD_FLAGS_L4_CSUM
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_UDP_IPV6
condition|)
block|{
name|tx_start_bd
operator|->
name|bd_flags
operator|.
name|as_bitfield
operator||=
operator|(
name|ETH_TX_BD_FLAGS_IPV6
operator||
name|ETH_TX_BD_FLAGS_IS_UDP
operator||
name|ETH_TX_BD_FLAGS_L4_CSUM
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TCP
operator|)
operator|||
operator|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
operator|)
condition|)
block|{
name|tx_start_bd
operator|->
name|bd_flags
operator|.
name|as_bitfield
operator||=
name|ETH_TX_BD_FLAGS_L4_CSUM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_UDP
condition|)
block|{
name|tx_start_bd
operator|->
name|bd_flags
operator|.
name|as_bitfield
operator||=
operator|(
name|ETH_TX_BD_FLAGS_L4_CSUM
operator||
name|ETH_TX_BD_FLAGS_IS_UDP
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|pbd_e2
operator|=
operator|&
name|fp
operator|->
name|tx_chain
index|[
name|TX_BD
argument_list|(
name|bd_prod
argument_list|)
index|]
operator|.
name|parse_bd_e2
expr_stmt|;
name|memset
argument_list|(
name|pbd_e2
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|eth_tx_parse_bd_e2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
condition|)
block|{
name|hlen
operator|=
name|bxe_set_pbd_csum_e2
argument_list|(
name|fp
argument_list|,
name|m0
argument_list|,
operator|&
name|pbd_e2_parsing_data
argument_list|)
expr_stmt|;
block|}
name|SET_FLAG
argument_list|(
name|pbd_e2_parsing_data
argument_list|,
name|ETH_TX_PARSE_BD_E2_ETH_ADDR_TYPE
argument_list|,
name|mac_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uint16_t
name|global_data
init|=
literal|0
decl_stmt|;
name|pbd_e1x
operator|=
operator|&
name|fp
operator|->
name|tx_chain
index|[
name|TX_BD
argument_list|(
name|bd_prod
argument_list|)
index|]
operator|.
name|parse_bd_e1x
expr_stmt|;
name|memset
argument_list|(
name|pbd_e1x
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|eth_tx_parse_bd_e1x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
condition|)
block|{
name|hlen
operator|=
name|bxe_set_pbd_csum
argument_list|(
name|fp
argument_list|,
name|m0
argument_list|,
name|pbd_e1x
argument_list|)
expr_stmt|;
block|}
name|SET_FLAG
argument_list|(
name|global_data
argument_list|,
name|ETH_TX_PARSE_BD_E1X_ETH_ADDR_TYPE
argument_list|,
name|mac_type
argument_list|)
expr_stmt|;
name|pbd_e1x
operator|->
name|global_data
operator||=
name|htole16
argument_list|(
name|global_data
argument_list|)
expr_stmt|;
block|}
comment|/* setup the parsing BD with TSO specific info */
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
condition|)
block|{
name|fp
operator|->
name|eth_q_stats
operator|.
name|tx_ofld_frames_lso
operator|++
expr_stmt|;
name|tx_start_bd
operator|->
name|bd_flags
operator|.
name|as_bitfield
operator||=
name|ETH_TX_BD_FLAGS_SW_LSO
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|tx_start_bd
operator|->
name|nbytes
operator|>
name|hlen
argument_list|)
condition|)
block|{
name|fp
operator|->
name|eth_q_stats
operator|.
name|tx_ofld_frames_lso_hdr_splits
operator|++
expr_stmt|;
comment|/* split the first BD into header/data making the fw job easy */
name|nbds
operator|++
expr_stmt|;
name|tx_start_bd
operator|->
name|nbd
operator|=
name|htole16
argument_list|(
name|nbds
argument_list|)
expr_stmt|;
name|tx_start_bd
operator|->
name|nbytes
operator|=
name|htole16
argument_list|(
name|hlen
argument_list|)
expr_stmt|;
name|bd_prod
operator|=
name|TX_BD_NEXT
argument_list|(
name|bd_prod
argument_list|)
expr_stmt|;
comment|/* new transmit BD after the tx_parse_bd */
name|tx_data_bd
operator|=
operator|&
name|fp
operator|->
name|tx_chain
index|[
name|TX_BD
argument_list|(
name|bd_prod
argument_list|)
index|]
operator|.
name|reg_bd
expr_stmt|;
name|tx_data_bd
operator|->
name|addr_hi
operator|=
name|htole32
argument_list|(
name|U64_HI
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
operator|+
name|hlen
argument_list|)
argument_list|)
expr_stmt|;
name|tx_data_bd
operator|->
name|addr_lo
operator|=
name|htole32
argument_list|(
name|U64_LO
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
operator|+
name|hlen
argument_list|)
argument_list|)
expr_stmt|;
name|tx_data_bd
operator|->
name|nbytes
operator|=
name|htole16
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_len
operator|-
name|hlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx_total_pkt_size_bd
operator|==
name|NULL
condition|)
block|{
name|tx_total_pkt_size_bd
operator|=
name|tx_data_bd
expr_stmt|;
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_TX
argument_list|,
literal|"TSO split header size is %d (%x:%x) nbds %d\n"
argument_list|,
name|le16toh
argument_list|(
name|tx_start_bd
operator|->
name|nbytes
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|tx_start_bd
operator|->
name|addr_hi
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|tx_start_bd
operator|->
name|addr_lo
argument_list|)
argument_list|,
name|nbds
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|bxe_set_pbd_lso_e2
argument_list|(
name|m0
argument_list|,
operator|&
name|pbd_e2_parsing_data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bxe_set_pbd_lso
argument_list|(
name|m0
argument_list|,
name|pbd_e1x
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pbd_e2_parsing_data
condition|)
block|{
name|pbd_e2
operator|->
name|parsing_data
operator|=
name|htole32
argument_list|(
name|pbd_e2_parsing_data
argument_list|)
expr_stmt|;
block|}
comment|/* prepare remaining BDs, start tx bd contains first seg/frag */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
name|bd_prod
operator|=
name|TX_BD_NEXT
argument_list|(
name|bd_prod
argument_list|)
expr_stmt|;
name|tx_data_bd
operator|=
operator|&
name|fp
operator|->
name|tx_chain
index|[
name|TX_BD
argument_list|(
name|bd_prod
argument_list|)
index|]
operator|.
name|reg_bd
expr_stmt|;
name|tx_data_bd
operator|->
name|addr_lo
operator|=
name|htole32
argument_list|(
name|U64_LO
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|tx_data_bd
operator|->
name|addr_hi
operator|=
name|htole32
argument_list|(
name|U64_HI
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|tx_data_bd
operator|->
name|nbytes
operator|=
name|htole16
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx_total_pkt_size_bd
operator|==
name|NULL
condition|)
block|{
name|tx_total_pkt_size_bd
operator|=
name|tx_data_bd
expr_stmt|;
block|}
name|total_pkt_size
operator|+=
name|tx_data_bd
operator|->
name|nbytes
expr_stmt|;
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_TX
argument_list|,
literal|"last bd %p\n"
argument_list|,
name|tx_data_bd
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx_total_pkt_size_bd
operator|!=
name|NULL
condition|)
block|{
name|tx_total_pkt_size_bd
operator|->
name|total_pkt_bytes
operator|=
name|total_pkt_size
expr_stmt|;
block|}
if|if
condition|(
name|__predict_false
argument_list|(
name|sc
operator|->
name|debug
operator|&
name|DBG_TX
argument_list|)
condition|)
block|{
name|tmp_bd
operator|=
name|tx_buf
operator|->
name|first_bd
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbds
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_TX
argument_list|,
literal|"TX Strt: %p bd=%d nbd=%d vlan=0x%x "
literal|"bd_flags=0x%x hdr_nbds=%d\n"
argument_list|,
name|tx_start_bd
argument_list|,
name|tmp_bd
argument_list|,
name|le16toh
argument_list|(
name|tx_start_bd
operator|->
name|nbd
argument_list|)
argument_list|,
name|le16toh
argument_list|(
name|tx_start_bd
operator|->
name|vlan_or_ethertype
argument_list|)
argument_list|,
name|tx_start_bd
operator|->
name|bd_flags
operator|.
name|as_bitfield
argument_list|,
operator|(
name|tx_start_bd
operator|->
name|general_data
operator|&
name|ETH_TX_START_BD_HDR_NBDS
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|pbd_e1x
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_TX
argument_list|,
literal|"-> Prse: %p bd=%d global=0x%x ip_hlen_w=%u "
literal|"ip_id=%u lso_mss=%u tcp_flags=0x%x csum=0x%x "
literal|"tcp_seq=%u total_hlen_w=%u\n"
argument_list|,
name|pbd_e1x
argument_list|,
name|tmp_bd
argument_list|,
name|pbd_e1x
operator|->
name|global_data
argument_list|,
name|pbd_e1x
operator|->
name|ip_hlen_w
argument_list|,
name|pbd_e1x
operator|->
name|ip_id
argument_list|,
name|pbd_e1x
operator|->
name|lso_mss
argument_list|,
name|pbd_e1x
operator|->
name|tcp_flags
argument_list|,
name|pbd_e1x
operator|->
name|tcp_pseudo_csum
argument_list|,
name|pbd_e1x
operator|->
name|tcp_send_seq
argument_list|,
name|le16toh
argument_list|(
name|pbd_e1x
operator|->
name|total_hlen_w
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* if (pbd_e2) */
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_TX
argument_list|,
literal|"-> Parse: %p bd=%d dst=%02x:%02x:%02x "
literal|"src=%02x:%02x:%02x parsing_data=0x%x\n"
argument_list|,
name|pbd_e2
argument_list|,
name|tmp_bd
argument_list|,
name|pbd_e2
operator|->
name|data
operator|.
name|mac_addr
operator|.
name|dst_hi
argument_list|,
name|pbd_e2
operator|->
name|data
operator|.
name|mac_addr
operator|.
name|dst_mid
argument_list|,
name|pbd_e2
operator|->
name|data
operator|.
name|mac_addr
operator|.
name|dst_lo
argument_list|,
name|pbd_e2
operator|->
name|data
operator|.
name|mac_addr
operator|.
name|src_hi
argument_list|,
name|pbd_e2
operator|->
name|data
operator|.
name|mac_addr
operator|.
name|src_mid
argument_list|,
name|pbd_e2
operator|->
name|data
operator|.
name|mac_addr
operator|.
name|src_lo
argument_list|,
name|pbd_e2
operator|->
name|parsing_data
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|!=
literal|1
condition|)
block|{
comment|/* skip parse db as it doesn't hold data */
name|tx_data_bd
operator|=
operator|&
name|fp
operator|->
name|tx_chain
index|[
name|TX_BD
argument_list|(
name|tmp_bd
argument_list|)
index|]
operator|.
name|reg_bd
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_TX
argument_list|,
literal|"-> Frag: %p bd=%d nbytes=%d hi=0x%x lo: 0x%x\n"
argument_list|,
name|tx_data_bd
argument_list|,
name|tmp_bd
argument_list|,
name|le16toh
argument_list|(
name|tx_data_bd
operator|->
name|nbytes
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|tx_data_bd
operator|->
name|addr_hi
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|tx_data_bd
operator|->
name|addr_lo
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tmp_bd
operator|=
name|TX_BD_NEXT
argument_list|(
name|tmp_bd
argument_list|)
expr_stmt|;
block|}
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_TX
argument_list|,
literal|"doorbell: nbds=%d bd=%u\n"
argument_list|,
name|nbds
argument_list|,
name|bd_prod
argument_list|)
expr_stmt|;
comment|/* update TX BD producer index value for next TX */
name|bd_prod
operator|=
name|TX_BD_NEXT
argument_list|(
name|bd_prod
argument_list|)
expr_stmt|;
comment|/*      * If the chain of tx_bd's describing this frame is adjacent to or spans      * an eth_tx_next_bd element then we need to increment the nbds value.      */
if|if
condition|(
name|TX_BD_IDX
argument_list|(
name|bd_prod
argument_list|)
operator|<
name|nbds
condition|)
block|{
name|nbds
operator|++
expr_stmt|;
block|}
comment|/* don't allow reordering of writes for nbd and packets */
name|mb
argument_list|()
expr_stmt|;
name|fp
operator|->
name|tx_db
operator|.
name|data
operator|.
name|prod
operator|+=
name|nbds
expr_stmt|;
comment|/* producer points to the next free tx_bd at this point */
name|fp
operator|->
name|tx_pkt_prod
operator|++
expr_stmt|;
name|fp
operator|->
name|tx_bd_prod
operator|=
name|bd_prod
expr_stmt|;
name|DOORBELL
argument_list|(
name|sc
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|fp
operator|->
name|tx_db
operator|.
name|raw
argument_list|)
expr_stmt|;
name|fp
operator|->
name|eth_q_stats
operator|.
name|tx_pkts
operator|++
expr_stmt|;
comment|/* Prevent speculative reads from getting ahead of the status block. */
name|bus_space_barrier
argument_list|(
name|sc
operator|->
name|bar
index|[
name|BAR0
index|]
operator|.
name|tag
argument_list|,
name|sc
operator|->
name|bar
index|[
name|BAR0
index|]
operator|.
name|handle
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_BARRIER_READ
argument_list|)
expr_stmt|;
comment|/* Prevent speculative reads from getting ahead of the doorbell. */
name|bus_space_barrier
argument_list|(
name|sc
operator|->
name|bar
index|[
name|BAR2
index|]
operator|.
name|tag
argument_list|,
name|sc
operator|->
name|bar
index|[
name|BAR2
index|]
operator|.
name|handle
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_BARRIER_READ
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_tx_start_locked
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|if_t
name|ifp
parameter_list|,
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|int
name|tx_count
init|=
literal|0
decl_stmt|;
name|uint16_t
name|tx_bd_avail
decl_stmt|;
name|BXE_FP_TX_LOCK_ASSERT
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* keep adding entries while there are frames to send */
while|while
condition|(
operator|!
name|if_sendq_empty
argument_list|(
name|ifp
argument_list|)
condition|)
block|{
comment|/*          * check for any frames to send          * dequeue can still be NULL even if queue is not empty          */
name|m
operator|=
name|if_dequeue
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|==
name|NULL
argument_list|)
condition|)
block|{
break|break;
block|}
comment|/* the mbuf now belongs to us */
name|fp
operator|->
name|eth_q_stats
operator|.
name|mbuf_alloc_tx
operator|++
expr_stmt|;
comment|/*          * Put the frame into the transmit ring. If we don't have room,          * place the mbuf back at the head of the TX queue, set the          * OACTIVE flag, and wait for the NIC to drain the chain.          */
if|if
condition|(
name|__predict_false
argument_list|(
name|bxe_tx_encap
argument_list|(
name|fp
argument_list|,
operator|&
name|m
argument_list|)
argument_list|)
condition|)
block|{
name|fp
operator|->
name|eth_q_stats
operator|.
name|tx_encap_failures
operator|++
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
comment|/* mark the TX queue as full and return the frame */
name|if_setdrvflagbits
argument_list|(
name|ifp
argument_list|,
name|IFF_DRV_OACTIVE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|if_sendq_prepend
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|fp
operator|->
name|eth_q_stats
operator|.
name|mbuf_alloc_tx
operator|--
expr_stmt|;
name|fp
operator|->
name|eth_q_stats
operator|.
name|tx_queue_xoff
operator|++
expr_stmt|;
block|}
comment|/* stop looking for more work */
break|break;
block|}
comment|/* the frame was enqueued successfully */
name|tx_count
operator|++
expr_stmt|;
comment|/* send a copy of the frame to any BPF listeners. */
name|if_etherbpfmtap
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|tx_bd_avail
operator|=
name|bxe_tx_avail
argument_list|(
name|sc
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* handle any completions if we're running low */
if|if
condition|(
name|tx_bd_avail
operator|<
name|BXE_TX_CLEANUP_THRESHOLD
condition|)
block|{
comment|/* bxe_txeof will set IFF_DRV_OACTIVE appropriately */
name|bxe_txeof
argument_list|(
name|sc
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_OACTIVE
condition|)
block|{
break|break;
block|}
block|}
block|}
comment|/* all TX packets were dequeued and/or the tx ring is full */
if|if
condition|(
name|tx_count
operator|>
literal|0
condition|)
block|{
comment|/* reset the TX watchdog timeout timer */
name|fp
operator|->
name|watchdog_timer
operator|=
name|BXE_TX_TIMEOUT
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Legacy (non-RSS) dispatch routine */
end_comment

begin_function
specifier|static
name|void
name|bxe_tx_start
parameter_list|(
name|if_t
name|ifp
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|sc
operator|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|BLOGW
argument_list|(
name|sc
argument_list|,
literal|"Interface not running, ignoring transmit request\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|sc
operator|->
name|link_vars
operator|.
name|link_up
condition|)
block|{
name|BLOGW
argument_list|(
name|sc
argument_list|,
literal|"Interface link is down, ignoring transmit request\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_OACTIVE
condition|)
block|{
name|fp
operator|->
name|eth_q_stats
operator|.
name|tx_queue_full_return
operator|++
expr_stmt|;
return|return;
block|}
name|BXE_FP_TX_LOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|bxe_tx_start_locked
argument_list|(
name|sc
argument_list|,
name|ifp
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|BXE_FP_TX_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|901504
end_if

begin_function
specifier|static
name|int
name|bxe_tx_mq_start_locked
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|if_t
name|ifp
parameter_list|,
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|buf_ring
modifier|*
name|tx_br
init|=
name|fp
operator|->
name|tx_br
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|next
decl_stmt|;
name|int
name|depth
decl_stmt|,
name|rc
decl_stmt|,
name|tx_count
decl_stmt|;
name|uint16_t
name|tx_bd_avail
decl_stmt|;
name|rc
operator|=
name|tx_count
operator|=
literal|0
expr_stmt|;
name|BXE_FP_TX_LOCK_ASSERT
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|state
operator|!=
name|BXE_STATE_OPEN
condition|)
block|{
name|fp
operator|->
name|eth_q_stats
operator|.
name|bxe_tx_mq_sc_state_failures
operator|++
expr_stmt|;
return|return
name|ENETDOWN
return|;
block|}
if|if
condition|(
operator|!
name|tx_br
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Multiqueue TX and no buf_ring!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|rc
operator|=
name|drbr_enqueue
argument_list|(
name|ifp
argument_list|,
name|tx_br
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|fp
operator|->
name|eth_q_stats
operator|.
name|tx_soft_errors
operator|++
expr_stmt|;
goto|goto
name|bxe_tx_mq_start_locked_exit
goto|;
block|}
block|}
if|if
condition|(
operator|!
name|sc
operator|->
name|link_vars
operator|.
name|link_up
operator|||
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|fp
operator|->
name|eth_q_stats
operator|.
name|tx_request_link_down_failures
operator|++
expr_stmt|;
goto|goto
name|bxe_tx_mq_start_locked_exit
goto|;
block|}
comment|/* fetch the depth of the driver queue */
name|depth
operator|=
name|drbr_inuse_drv
argument_list|(
name|ifp
argument_list|,
name|tx_br
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth
operator|>
name|fp
operator|->
name|eth_q_stats
operator|.
name|tx_max_drbr_queue_depth
condition|)
block|{
name|fp
operator|->
name|eth_q_stats
operator|.
name|tx_max_drbr_queue_depth
operator|=
name|depth
expr_stmt|;
block|}
comment|/* keep adding entries while there are frames to send */
while|while
condition|(
operator|(
name|next
operator|=
name|drbr_peek
argument_list|(
name|ifp
argument_list|,
name|tx_br
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* handle any completions if we're running low */
name|tx_bd_avail
operator|=
name|bxe_tx_avail
argument_list|(
name|sc
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx_bd_avail
operator|<
name|BXE_TX_CLEANUP_THRESHOLD
condition|)
block|{
comment|/* bxe_txeof will set IFF_DRV_OACTIVE appropriately */
name|bxe_txeof
argument_list|(
name|sc
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|tx_bd_avail
operator|=
name|bxe_tx_avail
argument_list|(
name|sc
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx_bd_avail
operator|<
operator|(
name|BXE_TSO_MAX_SEGMENTS
operator|+
literal|1
operator|)
condition|)
block|{
name|fp
operator|->
name|eth_q_stats
operator|.
name|bd_avail_too_less_failures
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|drbr_advance
argument_list|(
name|ifp
argument_list|,
name|tx_br
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOBUFS
expr_stmt|;
break|break;
block|}
block|}
comment|/* the mbuf now belongs to us */
name|fp
operator|->
name|eth_q_stats
operator|.
name|mbuf_alloc_tx
operator|++
expr_stmt|;
comment|/*          * Put the frame into the transmit ring. If we don't have room,          * place the mbuf back at the head of the TX queue, set the          * OACTIVE flag, and wait for the NIC to drain the chain.          */
name|rc
operator|=
name|bxe_tx_encap
argument_list|(
name|fp
argument_list|,
operator|&
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|rc
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|fp
operator|->
name|eth_q_stats
operator|.
name|tx_encap_failures
operator|++
expr_stmt|;
if|if
condition|(
name|next
operator|!=
name|NULL
condition|)
block|{
comment|/* mark the TX queue as full and save the frame */
name|if_setdrvflagbits
argument_list|(
name|ifp
argument_list|,
name|IFF_DRV_OACTIVE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|drbr_putback
argument_list|(
name|ifp
argument_list|,
name|tx_br
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|fp
operator|->
name|eth_q_stats
operator|.
name|mbuf_alloc_tx
operator|--
expr_stmt|;
name|fp
operator|->
name|eth_q_stats
operator|.
name|tx_frames_deferred
operator|++
expr_stmt|;
block|}
else|else
name|drbr_advance
argument_list|(
name|ifp
argument_list|,
name|tx_br
argument_list|)
expr_stmt|;
comment|/* stop looking for more work */
break|break;
block|}
comment|/* the transmit frame was enqueued successfully */
name|tx_count
operator|++
expr_stmt|;
comment|/* send a copy of the frame to any BPF listeners */
name|if_etherbpfmtap
argument_list|(
name|ifp
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|drbr_advance
argument_list|(
name|ifp
argument_list|,
name|tx_br
argument_list|)
expr_stmt|;
block|}
comment|/* all TX packets were dequeued and/or the tx ring is full */
if|if
condition|(
name|tx_count
operator|>
literal|0
condition|)
block|{
comment|/* reset the TX watchdog timeout timer */
name|fp
operator|->
name|watchdog_timer
operator|=
name|BXE_TX_TIMEOUT
expr_stmt|;
block|}
name|bxe_tx_mq_start_locked_exit
label|:
comment|/* If we didn't drain the drbr, enqueue a task in the future to do it. */
if|if
condition|(
operator|!
name|drbr_empty
argument_list|(
name|ifp
argument_list|,
name|tx_br
argument_list|)
condition|)
block|{
name|fp
operator|->
name|eth_q_stats
operator|.
name|tx_mq_not_empty
operator|++
expr_stmt|;
name|taskqueue_enqueue_timeout
argument_list|(
name|fp
operator|->
name|tq
argument_list|,
operator|&
name|fp
operator|->
name|tx_timeout_task
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_tx_mq_start_deferred
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|bxe_fastpath
modifier|*
name|fp
init|=
operator|(
expr|struct
name|bxe_fastpath
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|fp
operator|->
name|sc
decl_stmt|;
name|if_t
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|BXE_FP_TX_LOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|bxe_tx_mq_start_locked
argument_list|(
name|sc
argument_list|,
name|ifp
argument_list|,
name|fp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|BXE_FP_TX_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Multiqueue (TSS) dispatch routine. */
end_comment

begin_function
specifier|static
name|int
name|bxe_tx_mq_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|int
name|fp_index
decl_stmt|,
name|rc
decl_stmt|;
name|fp_index
operator|=
literal|0
expr_stmt|;
comment|/* default is the first queue */
comment|/* check if flowid is set */
if|if
condition|(
name|BXE_VALID_FLOWID
argument_list|(
name|m
argument_list|)
condition|)
name|fp_index
operator|=
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|%
name|sc
operator|->
name|num_queues
operator|)
expr_stmt|;
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|fp_index
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|state
operator|!=
name|BXE_STATE_OPEN
condition|)
block|{
name|fp
operator|->
name|eth_q_stats
operator|.
name|bxe_tx_mq_sc_state_failures
operator|++
expr_stmt|;
return|return
name|ENETDOWN
return|;
block|}
if|if
condition|(
name|BXE_FP_TX_TRYLOCK
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|rc
operator|=
name|bxe_tx_mq_start_locked
argument_list|(
name|sc
argument_list|,
name|ifp
argument_list|,
name|fp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|BXE_FP_TX_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
name|drbr_enqueue
argument_list|(
name|ifp
argument_list|,
name|fp
operator|->
name|tx_br
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|fp
operator|->
name|tq
argument_list|,
operator|&
name|fp
operator|->
name|tx_task
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_mq_flush
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|state
operator|!=
name|BXE_FP_STATE_IRQ
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Not clearing fp[%02d] buf_ring (state=%d)\n"
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|fp
operator|->
name|state
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|fp
operator|->
name|tx_br
operator|!=
name|NULL
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Clearing fp[%02d] buf_ring\n"
argument_list|,
name|fp
operator|->
name|index
argument_list|)
expr_stmt|;
name|BXE_FP_TX_LOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|buf_ring_dequeue_sc
argument_list|(
name|fp
operator|->
name|tx_br
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|BXE_FP_TX_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
name|if_qflush
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FreeBSD_version>= 901504 */
end_comment

begin_function
specifier|static
name|uint16_t
name|bxe_cid_ilt_lines
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|IS_SRIOV
argument_list|(
name|sc
argument_list|)
condition|)
block|{
return|return
operator|(
operator|(
name|BXE_FIRST_VF_CID
operator|+
name|BXE_VF_CIDS
operator|)
operator|/
name|ILT_PAGE_CIDS
operator|)
return|;
block|}
return|return
operator|(
name|L2_ILT_LINES
argument_list|(
name|sc
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_ilt_set_info
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ilt_client_info
modifier|*
name|ilt_client
decl_stmt|;
name|struct
name|ecore_ilt
modifier|*
name|ilt
init|=
name|sc
operator|->
name|ilt
decl_stmt|;
name|uint16_t
name|line
init|=
literal|0
decl_stmt|;
name|ilt
operator|->
name|start_line
operator|=
name|FUNC_ILT_BASE
argument_list|(
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"ilt starts at line %d\n"
argument_list|,
name|ilt
operator|->
name|start_line
argument_list|)
expr_stmt|;
comment|/* CDU */
name|ilt_client
operator|=
operator|&
name|ilt
operator|->
name|clients
index|[
name|ILT_CLIENT_CDU
index|]
expr_stmt|;
name|ilt_client
operator|->
name|client_num
operator|=
name|ILT_CLIENT_CDU
expr_stmt|;
name|ilt_client
operator|->
name|page_size
operator|=
name|CDU_ILT_PAGE_SZ
expr_stmt|;
name|ilt_client
operator|->
name|flags
operator|=
name|ILT_CLIENT_SKIP_MEM
expr_stmt|;
name|ilt_client
operator|->
name|start
operator|=
name|line
expr_stmt|;
name|line
operator|+=
name|bxe_cid_ilt_lines
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|CNIC_SUPPORT
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|line
operator|+=
name|CNIC_ILT_LINES
expr_stmt|;
block|}
name|ilt_client
operator|->
name|end
operator|=
operator|(
name|line
operator|-
literal|1
operator|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"ilt client[CDU]: start %d, end %d, "
literal|"psz 0x%x, flags 0x%x, hw psz %d\n"
argument_list|,
name|ilt_client
operator|->
name|start
argument_list|,
name|ilt_client
operator|->
name|end
argument_list|,
name|ilt_client
operator|->
name|page_size
argument_list|,
name|ilt_client
operator|->
name|flags
argument_list|,
name|ilog2
argument_list|(
name|ilt_client
operator|->
name|page_size
operator|>>
literal|12
argument_list|)
argument_list|)
expr_stmt|;
comment|/* QM */
if|if
condition|(
name|QM_INIT
argument_list|(
name|sc
operator|->
name|qm_cid_count
argument_list|)
condition|)
block|{
name|ilt_client
operator|=
operator|&
name|ilt
operator|->
name|clients
index|[
name|ILT_CLIENT_QM
index|]
expr_stmt|;
name|ilt_client
operator|->
name|client_num
operator|=
name|ILT_CLIENT_QM
expr_stmt|;
name|ilt_client
operator|->
name|page_size
operator|=
name|QM_ILT_PAGE_SZ
expr_stmt|;
name|ilt_client
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|ilt_client
operator|->
name|start
operator|=
name|line
expr_stmt|;
comment|/* 4 bytes for each cid */
name|line
operator|+=
name|DIV_ROUND_UP
argument_list|(
name|sc
operator|->
name|qm_cid_count
operator|*
name|QM_QUEUES_PER_FUNC
operator|*
literal|4
argument_list|,
name|QM_ILT_PAGE_SZ
argument_list|)
expr_stmt|;
name|ilt_client
operator|->
name|end
operator|=
operator|(
name|line
operator|-
literal|1
operator|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"ilt client[QM]: start %d, end %d, "
literal|"psz 0x%x, flags 0x%x, hw psz %d\n"
argument_list|,
name|ilt_client
operator|->
name|start
argument_list|,
name|ilt_client
operator|->
name|end
argument_list|,
name|ilt_client
operator|->
name|page_size
argument_list|,
name|ilt_client
operator|->
name|flags
argument_list|,
name|ilog2
argument_list|(
name|ilt_client
operator|->
name|page_size
operator|>>
literal|12
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CNIC_SUPPORT
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* SRC */
name|ilt_client
operator|=
operator|&
name|ilt
operator|->
name|clients
index|[
name|ILT_CLIENT_SRC
index|]
expr_stmt|;
name|ilt_client
operator|->
name|client_num
operator|=
name|ILT_CLIENT_SRC
expr_stmt|;
name|ilt_client
operator|->
name|page_size
operator|=
name|SRC_ILT_PAGE_SZ
expr_stmt|;
name|ilt_client
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|ilt_client
operator|->
name|start
operator|=
name|line
expr_stmt|;
name|line
operator|+=
name|SRC_ILT_LINES
expr_stmt|;
name|ilt_client
operator|->
name|end
operator|=
operator|(
name|line
operator|-
literal|1
operator|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"ilt client[SRC]: start %d, end %d, "
literal|"psz 0x%x, flags 0x%x, hw psz %d\n"
argument_list|,
name|ilt_client
operator|->
name|start
argument_list|,
name|ilt_client
operator|->
name|end
argument_list|,
name|ilt_client
operator|->
name|page_size
argument_list|,
name|ilt_client
operator|->
name|flags
argument_list|,
name|ilog2
argument_list|(
name|ilt_client
operator|->
name|page_size
operator|>>
literal|12
argument_list|)
argument_list|)
expr_stmt|;
comment|/* TM */
name|ilt_client
operator|=
operator|&
name|ilt
operator|->
name|clients
index|[
name|ILT_CLIENT_TM
index|]
expr_stmt|;
name|ilt_client
operator|->
name|client_num
operator|=
name|ILT_CLIENT_TM
expr_stmt|;
name|ilt_client
operator|->
name|page_size
operator|=
name|TM_ILT_PAGE_SZ
expr_stmt|;
name|ilt_client
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|ilt_client
operator|->
name|start
operator|=
name|line
expr_stmt|;
name|line
operator|+=
name|TM_ILT_LINES
expr_stmt|;
name|ilt_client
operator|->
name|end
operator|=
operator|(
name|line
operator|-
literal|1
operator|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"ilt client[TM]: start %d, end %d, "
literal|"psz 0x%x, flags 0x%x, hw psz %d\n"
argument_list|,
name|ilt_client
operator|->
name|start
argument_list|,
name|ilt_client
operator|->
name|end
argument_list|,
name|ilt_client
operator|->
name|page_size
argument_list|,
name|ilt_client
operator|->
name|flags
argument_list|,
name|ilog2
argument_list|(
name|ilt_client
operator|->
name|page_size
operator|>>
literal|12
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|KASSERT
argument_list|(
operator|(
name|line
operator|<=
name|ILT_MAX_LINES
operator|)
argument_list|,
operator|(
literal|"Invalid number of ILT lines!"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_set_fp_rx_buf_size
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint32_t
name|rx_buf_size
decl_stmt|;
name|rx_buf_size
operator|=
operator|(
name|IP_HEADER_ALIGNMENT_PADDING
operator|+
name|ETH_OVERHEAD
operator|+
name|sc
operator|->
name|mtu
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rx_buf_size
operator|<=
name|MCLBYTES
condition|)
block|{
name|sc
operator|->
name|fp
index|[
name|i
index|]
operator|.
name|rx_buf_size
operator|=
name|rx_buf_size
expr_stmt|;
name|sc
operator|->
name|fp
index|[
name|i
index|]
operator|.
name|mbuf_alloc_size
operator|=
name|MCLBYTES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rx_buf_size
operator|<=
name|MJUMPAGESIZE
condition|)
block|{
name|sc
operator|->
name|fp
index|[
name|i
index|]
operator|.
name|rx_buf_size
operator|=
name|rx_buf_size
expr_stmt|;
name|sc
operator|->
name|fp
index|[
name|i
index|]
operator|.
name|mbuf_alloc_size
operator|=
name|MJUMPAGESIZE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rx_buf_size
operator|<=
operator|(
name|MJUMPAGESIZE
operator|+
name|MCLBYTES
operator|)
condition|)
block|{
name|sc
operator|->
name|fp
index|[
name|i
index|]
operator|.
name|rx_buf_size
operator|=
name|MCLBYTES
expr_stmt|;
name|sc
operator|->
name|fp
index|[
name|i
index|]
operator|.
name|mbuf_alloc_size
operator|=
name|MCLBYTES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rx_buf_size
operator|<=
operator|(
literal|2
operator|*
name|MJUMPAGESIZE
operator|)
condition|)
block|{
name|sc
operator|->
name|fp
index|[
name|i
index|]
operator|.
name|rx_buf_size
operator|=
name|MJUMPAGESIZE
expr_stmt|;
name|sc
operator|->
name|fp
index|[
name|i
index|]
operator|.
name|mbuf_alloc_size
operator|=
name|MJUMPAGESIZE
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|fp
index|[
name|i
index|]
operator|.
name|rx_buf_size
operator|=
name|MCLBYTES
expr_stmt|;
name|sc
operator|->
name|fp
index|[
name|i
index|]
operator|.
name|mbuf_alloc_size
operator|=
name|MCLBYTES
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_alloc_ilt_mem
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|ilt
operator|=
operator|(
expr|struct
name|ecore_ilt
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ecore_ilt
argument_list|)
argument_list|,
name|M_BXE_ILT
argument_list|,
operator|(
name|M_NOWAIT
operator||
name|M_ZERO
operator|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|rc
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_alloc_ilt_lines_mem
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|ilt
operator|->
name|lines
operator|=
operator|(
expr|struct
name|ilt_line
operator|*
operator|)
name|malloc
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ilt_line
argument_list|)
operator|*
name|ILT_MAX_LINES
operator|)
argument_list|,
name|M_BXE_ILT
argument_list|,
operator|(
name|M_NOWAIT
operator||
name|M_ZERO
operator|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|rc
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_free_ilt_mem
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|ilt
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sc
operator|->
name|ilt
argument_list|,
name|M_BXE_ILT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ilt
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_free_ilt_lines_mem
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|ilt
operator|->
name|lines
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sc
operator|->
name|ilt
operator|->
name|lines
argument_list|,
name|M_BXE_ILT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ilt
operator|->
name|lines
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_free_mem
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|L2_ILT_LINES
argument_list|(
name|sc
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|bxe_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|context
index|[
name|i
index|]
operator|.
name|vcxt_dma
argument_list|)
expr_stmt|;
name|sc
operator|->
name|context
index|[
name|i
index|]
operator|.
name|vcxt
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|context
index|[
name|i
index|]
operator|.
name|size
operator|=
literal|0
expr_stmt|;
block|}
name|ecore_ilt_mem_op
argument_list|(
name|sc
argument_list|,
name|ILT_MEMOP_FREE
argument_list|)
expr_stmt|;
name|bxe_free_ilt_lines_mem
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_alloc_mem
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|context_size
decl_stmt|;
name|int
name|allocated
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/*      * Allocate memory for CDU context:      * This memory is allocated separately and not in the generic ILT      * functions because CDU differs in few aspects:      * 1. There can be multiple entities allocating memory for context -      * regular L2, CNIC, and SRIOV drivers. Each separately controls      * its own ILT lines.      * 2. Since CDU page-size is not a single 4KB page (which is the case      * for the other ILT clients), to be efficient we want to support      * allocation of sub-page-size in the last entry.      * 3. Context pointers are used by the driver to pass to FW / update      * the context (for the other ILT clients the pointers are used just to      * free the memory during unload).      */
name|context_size
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|union
name|cdu_context
argument_list|)
operator|*
name|BXE_L2_CID_COUNT
argument_list|(
name|sc
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|allocated
operator|=
literal|0
init|;
name|allocated
operator|<
name|context_size
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|context
index|[
name|i
index|]
operator|.
name|size
operator|=
name|min
argument_list|(
name|CDU_ILT_PAGE_SZ
argument_list|,
operator|(
name|context_size
operator|-
name|allocated
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bxe_dma_alloc
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|context
index|[
name|i
index|]
operator|.
name|size
argument_list|,
operator|&
name|sc
operator|->
name|context
index|[
name|i
index|]
operator|.
name|vcxt_dma
argument_list|,
literal|"cdu context"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bxe_free_mem
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|sc
operator|->
name|context
index|[
name|i
index|]
operator|.
name|vcxt
operator|=
operator|(
expr|union
name|cdu_context
operator|*
operator|)
name|sc
operator|->
name|context
index|[
name|i
index|]
operator|.
name|vcxt_dma
operator|.
name|vaddr
expr_stmt|;
name|allocated
operator|+=
name|sc
operator|->
name|context
index|[
name|i
index|]
operator|.
name|size
expr_stmt|;
block|}
name|bxe_alloc_ilt_lines_mem
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"ilt=%p start_line=%u lines=%p\n"
argument_list|,
name|sc
operator|->
name|ilt
argument_list|,
name|sc
operator|->
name|ilt
operator|->
name|start_line
argument_list|,
name|sc
operator|->
name|ilt
operator|->
name|lines
argument_list|)
expr_stmt|;
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"c%d page_size=%u start=%u end=%u num=%u flags=0x%x\n"
argument_list|,
name|i
argument_list|,
name|sc
operator|->
name|ilt
operator|->
name|clients
index|[
name|i
index|]
operator|.
name|page_size
argument_list|,
name|sc
operator|->
name|ilt
operator|->
name|clients
index|[
name|i
index|]
operator|.
name|start
argument_list|,
name|sc
operator|->
name|ilt
operator|->
name|clients
index|[
name|i
index|]
operator|.
name|end
argument_list|,
name|sc
operator|->
name|ilt
operator|->
name|clients
index|[
name|i
index|]
operator|.
name|client_num
argument_list|,
name|sc
operator|->
name|ilt
operator|->
name|clients
index|[
name|i
index|]
operator|.
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ecore_ilt_mem_op
argument_list|(
name|sc
argument_list|,
name|ILT_MEMOP_ALLOC
argument_list|)
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"ecore_ilt_mem_op ILT_MEMOP_ALLOC failed\n"
argument_list|)
expr_stmt|;
name|bxe_free_mem
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_free_rx_bd_chain
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|fp
operator|->
name|sc
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|rx_mbuf_tag
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
comment|/* free all mbufs and unload all maps */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RX_BD_TOTAL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fp
operator|->
name|rx_mbuf_chain
index|[
name|i
index|]
operator|.
name|m_map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|fp
operator|->
name|rx_mbuf_chain
index|[
name|i
index|]
operator|.
name|m_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|fp
operator|->
name|rx_mbuf_chain
index|[
name|i
index|]
operator|.
name|m_map
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|->
name|rx_mbuf_chain
index|[
name|i
index|]
operator|.
name|m
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|fp
operator|->
name|rx_mbuf_chain
index|[
name|i
index|]
operator|.
name|m
argument_list|)
expr_stmt|;
name|fp
operator|->
name|rx_mbuf_chain
index|[
name|i
index|]
operator|.
name|m
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|eth_q_stats
operator|.
name|mbuf_alloc_rx
operator|--
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_free_tpa_pool
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|max_agg_queues
decl_stmt|;
name|sc
operator|=
name|fp
operator|->
name|sc
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|rx_mbuf_tag
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|max_agg_queues
operator|=
name|MAX_AGG_QS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* release all mbufs and unload all DMA maps in the TPA pool */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_agg_queues
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fp
operator|->
name|rx_tpa_info
index|[
name|i
index|]
operator|.
name|bd
operator|.
name|m_map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|fp
operator|->
name|rx_tpa_info
index|[
name|i
index|]
operator|.
name|bd
operator|.
name|m_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|fp
operator|->
name|rx_tpa_info
index|[
name|i
index|]
operator|.
name|bd
operator|.
name|m_map
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|->
name|rx_tpa_info
index|[
name|i
index|]
operator|.
name|bd
operator|.
name|m
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|fp
operator|->
name|rx_tpa_info
index|[
name|i
index|]
operator|.
name|bd
operator|.
name|m
argument_list|)
expr_stmt|;
name|fp
operator|->
name|rx_tpa_info
index|[
name|i
index|]
operator|.
name|bd
operator|.
name|m
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|eth_q_stats
operator|.
name|mbuf_alloc_tpa
operator|--
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_free_sge_chain
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|fp
operator|->
name|sc
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|rx_sge_mbuf_tag
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
comment|/* rree all mbufs and unload all maps */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RX_SGE_TOTAL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fp
operator|->
name|rx_sge_mbuf_chain
index|[
name|i
index|]
operator|.
name|m_map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|fp
operator|->
name|rx_sge_mbuf_tag
argument_list|,
name|fp
operator|->
name|rx_sge_mbuf_chain
index|[
name|i
index|]
operator|.
name|m_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|fp
operator|->
name|rx_sge_mbuf_tag
argument_list|,
name|fp
operator|->
name|rx_sge_mbuf_chain
index|[
name|i
index|]
operator|.
name|m_map
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|->
name|rx_sge_mbuf_chain
index|[
name|i
index|]
operator|.
name|m
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|fp
operator|->
name|rx_sge_mbuf_chain
index|[
name|i
index|]
operator|.
name|m
argument_list|)
expr_stmt|;
name|fp
operator|->
name|rx_sge_mbuf_chain
index|[
name|i
index|]
operator|.
name|m
operator|=
name|NULL
expr_stmt|;
name|fp
operator|->
name|eth_q_stats
operator|.
name|mbuf_alloc_sge
operator|--
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_free_fp_buffers
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|901504
if|if
condition|(
name|fp
operator|->
name|tx_br
operator|!=
name|NULL
condition|)
block|{
comment|/* just in case bxe_mq_flush() wasn't called */
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|fp
operator|->
name|tx_mtx
argument_list|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|BXE_FP_TX_LOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|buf_ring_dequeue_sc
argument_list|(
name|fp
operator|->
name|tx_br
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|BXE_FP_TX_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* free all RX buffers */
name|bxe_free_rx_bd_chain
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|bxe_free_tpa_pool
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|bxe_free_sge_chain
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|eth_q_stats
operator|.
name|mbuf_alloc_rx
operator|!=
literal|0
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"failed to claim all rx mbufs (%d left)\n"
argument_list|,
name|fp
operator|->
name|eth_q_stats
operator|.
name|mbuf_alloc_rx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|->
name|eth_q_stats
operator|.
name|mbuf_alloc_sge
operator|!=
literal|0
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"failed to claim all sge mbufs (%d left)\n"
argument_list|,
name|fp
operator|->
name|eth_q_stats
operator|.
name|mbuf_alloc_sge
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|->
name|eth_q_stats
operator|.
name|mbuf_alloc_tpa
operator|!=
literal|0
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"failed to claim all sge mbufs (%d left)\n"
argument_list|,
name|fp
operator|->
name|eth_q_stats
operator|.
name|mbuf_alloc_tpa
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|->
name|eth_q_stats
operator|.
name|mbuf_alloc_tx
operator|!=
literal|0
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"failed to release tx mbufs (%d left)\n"
argument_list|,
name|fp
operator|->
name|eth_q_stats
operator|.
name|mbuf_alloc_tx
argument_list|)
expr_stmt|;
block|}
comment|/* XXX verify all mbufs were reclaimed */
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_alloc_rx_bd_mbuf
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|uint16_t
name|prev_index
parameter_list|,
name|uint16_t
name|index
parameter_list|)
block|{
name|struct
name|bxe_sw_rx_bd
modifier|*
name|rx_buf
decl_stmt|;
name|struct
name|eth_rx_bd
modifier|*
name|rx_bd
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
literal|1
index|]
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|nsegs
decl_stmt|,
name|rc
decl_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
comment|/* allocate the new RX BD mbuf */
name|m
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|fp
operator|->
name|mbuf_alloc_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|fp
operator|->
name|eth_q_stats
operator|.
name|mbuf_rx_bd_alloc_failed
operator|++
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|fp
operator|->
name|eth_q_stats
operator|.
name|mbuf_alloc_rx
operator|++
expr_stmt|;
comment|/* initialize the mbuf buffer length */
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|fp
operator|->
name|rx_buf_size
expr_stmt|;
comment|/* map the mbuf into non-paged pool */
name|rc
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|fp
operator|->
name|rx_mbuf_spare_map
argument_list|,
name|m
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|rc
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|fp
operator|->
name|eth_q_stats
operator|.
name|mbuf_rx_bd_mapping_failed
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|fp
operator|->
name|eth_q_stats
operator|.
name|mbuf_alloc_rx
operator|--
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
comment|/* all mbufs must map to a single segment */
name|KASSERT
argument_list|(
operator|(
name|nsegs
operator|==
literal|1
operator|)
argument_list|,
operator|(
literal|"Too many segments, %d returned!"
operator|,
name|nsegs
operator|)
argument_list|)
expr_stmt|;
comment|/* release any existing RX BD mbuf mappings */
if|if
condition|(
name|prev_index
operator|!=
name|index
condition|)
block|{
name|rx_buf
operator|=
operator|&
name|fp
operator|->
name|rx_mbuf_chain
index|[
name|prev_index
index|]
expr_stmt|;
if|if
condition|(
name|rx_buf
operator|->
name|m_map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|rx_buf
operator|->
name|m_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|rx_buf
operator|->
name|m_map
argument_list|)
expr_stmt|;
block|}
comment|/*          * We only get here from bxe_rxeof() when the maximum number          * of rx buffers is less than RX_BD_USABLE. bxe_rxeof() already          * holds the mbuf in the prev_index so it's OK to NULL it out          * here without concern of a memory leak.          */
name|fp
operator|->
name|rx_mbuf_chain
index|[
name|prev_index
index|]
operator|.
name|m
operator|=
name|NULL
expr_stmt|;
block|}
name|rx_buf
operator|=
operator|&
name|fp
operator|->
name|rx_mbuf_chain
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|rx_buf
operator|->
name|m_map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|rx_buf
operator|->
name|m_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|rx_buf
operator|->
name|m_map
argument_list|)
expr_stmt|;
block|}
comment|/* save the mbuf and mapping info for a future packet */
name|map
operator|=
operator|(
name|prev_index
operator|!=
name|index
operator|)
condition|?
name|fp
operator|->
name|rx_mbuf_chain
index|[
name|prev_index
index|]
operator|.
name|m_map
else|:
name|rx_buf
operator|->
name|m_map
expr_stmt|;
name|rx_buf
operator|->
name|m_map
operator|=
name|fp
operator|->
name|rx_mbuf_spare_map
expr_stmt|;
name|fp
operator|->
name|rx_mbuf_spare_map
operator|=
name|map
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|rx_buf
operator|->
name|m_map
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|rx_buf
operator|->
name|m
operator|=
name|m
expr_stmt|;
name|rx_bd
operator|=
operator|&
name|fp
operator|->
name|rx_chain
index|[
name|index
index|]
expr_stmt|;
name|rx_bd
operator|->
name|addr_hi
operator|=
name|htole32
argument_list|(
name|U64_HI
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|rx_bd
operator|->
name|addr_lo
operator|=
name|htole32
argument_list|(
name|U64_LO
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_alloc_rx_tpa_mbuf
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|int
name|queue
parameter_list|)
block|{
name|struct
name|bxe_sw_tpa_info
modifier|*
name|tpa_info
init|=
operator|&
name|fp
operator|->
name|rx_tpa_info
index|[
name|queue
index|]
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
literal|1
index|]
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|nsegs
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
comment|/* allocate the new TPA mbuf */
name|m
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|fp
operator|->
name|mbuf_alloc_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|fp
operator|->
name|eth_q_stats
operator|.
name|mbuf_rx_tpa_alloc_failed
operator|++
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|fp
operator|->
name|eth_q_stats
operator|.
name|mbuf_alloc_tpa
operator|++
expr_stmt|;
comment|/* initialize the mbuf buffer length */
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|fp
operator|->
name|rx_buf_size
expr_stmt|;
comment|/* map the mbuf into non-paged pool */
name|rc
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|fp
operator|->
name|rx_tpa_info_mbuf_spare_map
argument_list|,
name|m
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|rc
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|fp
operator|->
name|eth_q_stats
operator|.
name|mbuf_rx_tpa_mapping_failed
operator|++
expr_stmt|;
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|fp
operator|->
name|eth_q_stats
operator|.
name|mbuf_alloc_tpa
operator|--
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
comment|/* all mbufs must map to a single segment */
name|KASSERT
argument_list|(
operator|(
name|nsegs
operator|==
literal|1
operator|)
argument_list|,
operator|(
literal|"Too many segments, %d returned!"
operator|,
name|nsegs
operator|)
argument_list|)
expr_stmt|;
comment|/* release any existing TPA mbuf mapping */
if|if
condition|(
name|tpa_info
operator|->
name|bd
operator|.
name|m_map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|tpa_info
operator|->
name|bd
operator|.
name|m_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|tpa_info
operator|->
name|bd
operator|.
name|m_map
argument_list|)
expr_stmt|;
block|}
comment|/* save the mbuf and mapping info for the TPA mbuf */
name|map
operator|=
name|tpa_info
operator|->
name|bd
operator|.
name|m_map
expr_stmt|;
name|tpa_info
operator|->
name|bd
operator|.
name|m_map
operator|=
name|fp
operator|->
name|rx_tpa_info_mbuf_spare_map
expr_stmt|;
name|fp
operator|->
name|rx_tpa_info_mbuf_spare_map
operator|=
name|map
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|tpa_info
operator|->
name|bd
operator|.
name|m_map
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|tpa_info
operator|->
name|bd
operator|.
name|m
operator|=
name|m
expr_stmt|;
name|tpa_info
operator|->
name|seg
operator|=
name|segs
index|[
literal|0
index|]
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate an mbuf and assign it to the receive scatter gather chain. The  * caller must take care to save a copy of the existing mbuf in the SG mbuf  * chain.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_alloc_rx_sge_mbuf
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|uint16_t
name|index
parameter_list|)
block|{
name|struct
name|bxe_sw_rx_bd
modifier|*
name|sge_buf
decl_stmt|;
name|struct
name|eth_rx_sge
modifier|*
name|sge
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
literal|1
index|]
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|nsegs
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
comment|/* allocate a new SGE mbuf */
name|m
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|SGE_PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|fp
operator|->
name|eth_q_stats
operator|.
name|mbuf_rx_sge_alloc_failed
operator|++
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|fp
operator|->
name|eth_q_stats
operator|.
name|mbuf_alloc_sge
operator|++
expr_stmt|;
comment|/* initialize the mbuf buffer length */
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|SGE_PAGE_SIZE
expr_stmt|;
comment|/* map the SGE mbuf into non-paged pool */
name|rc
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|fp
operator|->
name|rx_sge_mbuf_tag
argument_list|,
name|fp
operator|->
name|rx_sge_mbuf_spare_map
argument_list|,
name|m
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|rc
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|fp
operator|->
name|eth_q_stats
operator|.
name|mbuf_rx_sge_mapping_failed
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|fp
operator|->
name|eth_q_stats
operator|.
name|mbuf_alloc_sge
operator|--
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
comment|/* all mbufs must map to a single segment */
name|KASSERT
argument_list|(
operator|(
name|nsegs
operator|==
literal|1
operator|)
argument_list|,
operator|(
literal|"Too many segments, %d returned!"
operator|,
name|nsegs
operator|)
argument_list|)
expr_stmt|;
name|sge_buf
operator|=
operator|&
name|fp
operator|->
name|rx_sge_mbuf_chain
index|[
name|index
index|]
expr_stmt|;
comment|/* release any existing SGE mbuf mapping */
if|if
condition|(
name|sge_buf
operator|->
name|m_map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|fp
operator|->
name|rx_sge_mbuf_tag
argument_list|,
name|sge_buf
operator|->
name|m_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|fp
operator|->
name|rx_sge_mbuf_tag
argument_list|,
name|sge_buf
operator|->
name|m_map
argument_list|)
expr_stmt|;
block|}
comment|/* save the mbuf and mapping info for a future packet */
name|map
operator|=
name|sge_buf
operator|->
name|m_map
expr_stmt|;
name|sge_buf
operator|->
name|m_map
operator|=
name|fp
operator|->
name|rx_sge_mbuf_spare_map
expr_stmt|;
name|fp
operator|->
name|rx_sge_mbuf_spare_map
operator|=
name|map
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|fp
operator|->
name|rx_sge_mbuf_tag
argument_list|,
name|sge_buf
operator|->
name|m_map
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|sge_buf
operator|->
name|m
operator|=
name|m
expr_stmt|;
name|sge
operator|=
operator|&
name|fp
operator|->
name|rx_sge_chain
index|[
name|index
index|]
expr_stmt|;
name|sge
operator|->
name|addr_hi
operator|=
name|htole32
argument_list|(
name|U64_HI
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|sge
operator|->
name|addr_lo
operator|=
name|htole32
argument_list|(
name|U64_LO
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__noinline
name|int
name|bxe_alloc_fp_buffers
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
name|int
name|ring_prod
decl_stmt|,
name|cqe_ring_prod
decl_stmt|;
name|int
name|max_agg_queues
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
expr_stmt|;
name|ring_prod
operator|=
name|cqe_ring_prod
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|rx_bd_cons
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|rx_cq_cons
operator|=
literal|0
expr_stmt|;
comment|/* allocate buffers for the RX BDs in RX BD chain */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sc
operator|->
name|max_rx_bufs
condition|;
name|j
operator|++
control|)
block|{
name|rc
operator|=
name|bxe_alloc_rx_bd_mbuf
argument_list|(
name|fp
argument_list|,
name|ring_prod
argument_list|,
name|ring_prod
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"mbuf alloc fail for fp[%02d] rx chain (%d)\n"
argument_list|,
name|i
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|bxe_alloc_fp_buffers_error
goto|;
block|}
name|ring_prod
operator|=
name|RX_BD_NEXT
argument_list|(
name|ring_prod
argument_list|)
expr_stmt|;
name|cqe_ring_prod
operator|=
name|RCQ_NEXT
argument_list|(
name|cqe_ring_prod
argument_list|)
expr_stmt|;
block|}
name|fp
operator|->
name|rx_bd_prod
operator|=
name|ring_prod
expr_stmt|;
name|fp
operator|->
name|rx_cq_prod
operator|=
name|cqe_ring_prod
expr_stmt|;
name|fp
operator|->
name|eth_q_stats
operator|.
name|rx_calls
operator|=
name|fp
operator|->
name|eth_q_stats
operator|.
name|rx_pkts
operator|=
literal|0
expr_stmt|;
name|max_agg_queues
operator|=
name|MAX_AGG_QS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|fp
operator|->
name|tpa_enable
operator|=
name|TRUE
expr_stmt|;
comment|/* fill the TPA pool */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|max_agg_queues
condition|;
name|j
operator|++
control|)
block|{
name|rc
operator|=
name|bxe_alloc_rx_tpa_mbuf
argument_list|(
name|fp
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"mbuf alloc fail for fp[%02d] TPA queue %d\n"
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|fp
operator|->
name|tpa_enable
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|bxe_alloc_fp_buffers_error
goto|;
block|}
name|fp
operator|->
name|rx_tpa_info
index|[
name|j
index|]
operator|.
name|state
operator|=
name|BXE_TPA_STATE_STOP
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|->
name|tpa_enable
condition|)
block|{
comment|/* fill the RX SGE chain */
name|ring_prod
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|RX_SGE_USABLE
condition|;
name|j
operator|++
control|)
block|{
name|rc
operator|=
name|bxe_alloc_rx_sge_mbuf
argument_list|(
name|fp
argument_list|,
name|ring_prod
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"mbuf alloc fail for fp[%02d] SGE %d\n"
argument_list|,
name|i
argument_list|,
name|ring_prod
argument_list|)
expr_stmt|;
name|fp
operator|->
name|tpa_enable
operator|=
name|FALSE
expr_stmt|;
name|ring_prod
operator|=
literal|0
expr_stmt|;
goto|goto
name|bxe_alloc_fp_buffers_error
goto|;
block|}
name|ring_prod
operator|=
name|RX_SGE_NEXT
argument_list|(
name|ring_prod
argument_list|)
expr_stmt|;
block|}
name|fp
operator|->
name|rx_sge_prod
operator|=
name|ring_prod
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|bxe_alloc_fp_buffers_error
label|:
comment|/* unwind what was already allocated */
name|bxe_free_rx_bd_chain
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|bxe_free_tpa_pool
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|bxe_free_sge_chain
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_free_fw_stats_mem
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|bxe_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|fw_stats_dma
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fw_stats_num
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|fw_stats_req_size
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|fw_stats_req
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|fw_stats_req_mapping
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|fw_stats_data_size
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|fw_stats_data
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|fw_stats_data_mapping
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_alloc_fw_stats_mem
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint8_t
name|num_queue_stats
decl_stmt|;
name|int
name|num_groups
decl_stmt|;
comment|/* number of queues for statistics is number of eth queues */
name|num_queue_stats
operator|=
name|BXE_NUM_ETH_QUEUES
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*      * Total number of FW statistics requests =      *   1 for port stats + 1 for PF stats + num of queues      */
name|sc
operator|->
name|fw_stats_num
operator|=
operator|(
literal|2
operator|+
name|num_queue_stats
operator|)
expr_stmt|;
comment|/*      * Request is built from stats_query_header and an array of      * stats_query_cmd_group each of which contains STATS_QUERY_CMD_COUNT      * rules. The real number or requests is configured in the      * stats_query_header.      */
name|num_groups
operator|=
operator|(
operator|(
name|sc
operator|->
name|fw_stats_num
operator|/
name|STATS_QUERY_CMD_COUNT
operator|)
operator|+
operator|(
operator|(
name|sc
operator|->
name|fw_stats_num
operator|%
name|STATS_QUERY_CMD_COUNT
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
operator|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"stats fw_stats_num %d num_groups %d\n"
argument_list|,
name|sc
operator|->
name|fw_stats_num
argument_list|,
name|num_groups
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fw_stats_req_size
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|stats_query_header
argument_list|)
operator|+
operator|(
name|num_groups
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|stats_query_cmd_group
argument_list|)
operator|)
operator|)
expr_stmt|;
comment|/*      * Data for statistics requests + stats_counter.      * stats_counter holds per-STORM counters that are incremented when      * STORM has finished with the current request. Memory for FCoE      * offloaded statistics are counted anyway, even if they will not be sent.      * VF stats are not accounted for here as the data of VF stats is stored      * in memory allocated by the VF, not here.      */
name|sc
operator|->
name|fw_stats_data_size
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|stats_counter
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|per_port_stats
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|per_pf_stats
argument_list|)
operator|+
comment|/* sizeof(struct fcoe_statistics_params) + */
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|per_queue_stats
argument_list|)
operator|*
name|num_queue_stats
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|bxe_dma_alloc
argument_list|(
name|sc
argument_list|,
operator|(
name|sc
operator|->
name|fw_stats_req_size
operator|+
name|sc
operator|->
name|fw_stats_data_size
operator|)
argument_list|,
operator|&
name|sc
operator|->
name|fw_stats_dma
argument_list|,
literal|"fw stats"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bxe_free_fw_stats_mem
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* set up the shortcuts */
name|sc
operator|->
name|fw_stats_req
operator|=
operator|(
expr|struct
name|bxe_fw_stats_req
operator|*
operator|)
name|sc
operator|->
name|fw_stats_dma
operator|.
name|vaddr
expr_stmt|;
name|sc
operator|->
name|fw_stats_req_mapping
operator|=
name|sc
operator|->
name|fw_stats_dma
operator|.
name|paddr
expr_stmt|;
name|sc
operator|->
name|fw_stats_data
operator|=
operator|(
expr|struct
name|bxe_fw_stats_data
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|sc
operator|->
name|fw_stats_dma
operator|.
name|vaddr
operator|+
name|sc
operator|->
name|fw_stats_req_size
operator|)
expr_stmt|;
name|sc
operator|->
name|fw_stats_data_mapping
operator|=
operator|(
name|sc
operator|->
name|fw_stats_dma
operator|.
name|paddr
operator|+
name|sc
operator|->
name|fw_stats_req_size
operator|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"statistics request base address set to %#jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|fw_stats_req_mapping
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"statistics data base address set to %#jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|fw_stats_data_mapping
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Bits map:  * 0-7  - Engine0 load counter.  * 8-15 - Engine1 load counter.  * 16   - Engine0 RESET_IN_PROGRESS bit.  * 17   - Engine1 RESET_IN_PROGRESS bit.  * 18   - Engine0 ONE_IS_LOADED. Set when there is at least one active  *        function on the engine  * 19   - Engine1 ONE_IS_LOADED.  * 20   - Chip reset flow bit. When set none-leader must wait for both engines  *        leader to complete (check for both RESET_IN_PROGRESS bits and not  *        for just the one belonging to its engine).  */
end_comment

begin_define
define|#
directive|define
name|BXE_RECOVERY_GLOB_REG
value|MISC_REG_GENERIC_POR_1
end_define

begin_define
define|#
directive|define
name|BXE_PATH0_LOAD_CNT_MASK
value|0x000000ff
end_define

begin_define
define|#
directive|define
name|BXE_PATH0_LOAD_CNT_SHIFT
value|0
end_define

begin_define
define|#
directive|define
name|BXE_PATH1_LOAD_CNT_MASK
value|0x0000ff00
end_define

begin_define
define|#
directive|define
name|BXE_PATH1_LOAD_CNT_SHIFT
value|8
end_define

begin_define
define|#
directive|define
name|BXE_PATH0_RST_IN_PROG_BIT
value|0x00010000
end_define

begin_define
define|#
directive|define
name|BXE_PATH1_RST_IN_PROG_BIT
value|0x00020000
end_define

begin_define
define|#
directive|define
name|BXE_GLOBAL_RESET_BIT
value|0x00040000
end_define

begin_comment
comment|/* set the GLOBAL_RESET bit, should be run under rtnl lock */
end_comment

begin_function
specifier|static
name|void
name|bxe_set_reset_global
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|bxe_acquire_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_RECOVERY_REG
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BXE_RECOVERY_GLOB_REG
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BXE_RECOVERY_GLOB_REG
argument_list|,
name|val
operator||
name|BXE_GLOBAL_RESET_BIT
argument_list|)
expr_stmt|;
name|bxe_release_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_RECOVERY_REG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* clear the GLOBAL_RESET bit, should be run under rtnl lock */
end_comment

begin_function
specifier|static
name|void
name|bxe_clear_reset_global
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|bxe_acquire_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_RECOVERY_REG
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BXE_RECOVERY_GLOB_REG
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BXE_RECOVERY_GLOB_REG
argument_list|,
name|val
operator|&
operator|(
operator|~
name|BXE_GLOBAL_RESET_BIT
operator|)
argument_list|)
expr_stmt|;
name|bxe_release_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_RECOVERY_REG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* checks the GLOBAL_RESET bit, should be run under rtnl lock */
end_comment

begin_function
specifier|static
name|uint8_t
name|bxe_reset_is_global
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|val
init|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BXE_RECOVERY_GLOB_REG
argument_list|)
decl_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"GLOB_REG=0x%08x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|&
name|BXE_GLOBAL_RESET_BIT
operator|)
condition|?
name|TRUE
else|:
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* clear RESET_IN_PROGRESS bit for the engine, should be run under rtnl lock */
end_comment

begin_function
specifier|static
name|void
name|bxe_set_reset_done
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|uint32_t
name|bit
init|=
name|SC_PATH
argument_list|(
name|sc
argument_list|)
condition|?
name|BXE_PATH1_RST_IN_PROG_BIT
else|:
name|BXE_PATH0_RST_IN_PROG_BIT
decl_stmt|;
name|bxe_acquire_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_RECOVERY_REG
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BXE_RECOVERY_GLOB_REG
argument_list|)
expr_stmt|;
comment|/* Clear the bit */
name|val
operator|&=
operator|~
name|bit
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BXE_RECOVERY_GLOB_REG
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|bxe_release_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_RECOVERY_REG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* set RESET_IN_PROGRESS for the engine, should be run under rtnl lock */
end_comment

begin_function
specifier|static
name|void
name|bxe_set_reset_in_progress
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|uint32_t
name|bit
init|=
name|SC_PATH
argument_list|(
name|sc
argument_list|)
condition|?
name|BXE_PATH1_RST_IN_PROG_BIT
else|:
name|BXE_PATH0_RST_IN_PROG_BIT
decl_stmt|;
name|bxe_acquire_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_RECOVERY_REG
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BXE_RECOVERY_GLOB_REG
argument_list|)
expr_stmt|;
comment|/* Set the bit */
name|val
operator||=
name|bit
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BXE_RECOVERY_GLOB_REG
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|bxe_release_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_RECOVERY_REG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* check RESET_IN_PROGRESS bit for an engine, should be run under rtnl lock */
end_comment

begin_function
specifier|static
name|uint8_t
name|bxe_reset_is_done
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|engine
parameter_list|)
block|{
name|uint32_t
name|val
init|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BXE_RECOVERY_GLOB_REG
argument_list|)
decl_stmt|;
name|uint32_t
name|bit
init|=
name|engine
condition|?
name|BXE_PATH1_RST_IN_PROG_BIT
else|:
name|BXE_PATH0_RST_IN_PROG_BIT
decl_stmt|;
comment|/* return false if bit is set */
return|return
operator|(
name|val
operator|&
name|bit
operator|)
condition|?
name|FALSE
else|:
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* get the load status for an engine, should be run under rtnl lock */
end_comment

begin_function
specifier|static
name|uint8_t
name|bxe_get_load_status
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|engine
parameter_list|)
block|{
name|uint32_t
name|mask
init|=
name|engine
condition|?
name|BXE_PATH1_LOAD_CNT_MASK
else|:
name|BXE_PATH0_LOAD_CNT_MASK
decl_stmt|;
name|uint32_t
name|shift
init|=
name|engine
condition|?
name|BXE_PATH1_LOAD_CNT_SHIFT
else|:
name|BXE_PATH0_LOAD_CNT_SHIFT
decl_stmt|;
name|uint32_t
name|val
init|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BXE_RECOVERY_GLOB_REG
argument_list|)
decl_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Old value for GLOB_REG=0x%08x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|val
operator|&
name|mask
operator|)
operator|>>
name|shift
operator|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Load mask engine %d = 0x%08x\n"
argument_list|,
name|engine
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* set pf load mark */
end_comment

begin_comment
comment|/* XXX needs to be under rtnl lock */
end_comment

begin_function
specifier|static
name|void
name|bxe_set_pf_load
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|uint32_t
name|val1
decl_stmt|;
name|uint32_t
name|mask
init|=
name|SC_PATH
argument_list|(
name|sc
argument_list|)
condition|?
name|BXE_PATH1_LOAD_CNT_MASK
else|:
name|BXE_PATH0_LOAD_CNT_MASK
decl_stmt|;
name|uint32_t
name|shift
init|=
name|SC_PATH
argument_list|(
name|sc
argument_list|)
condition|?
name|BXE_PATH1_LOAD_CNT_SHIFT
else|:
name|BXE_PATH0_LOAD_CNT_SHIFT
decl_stmt|;
name|bxe_acquire_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_RECOVERY_REG
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BXE_RECOVERY_GLOB_REG
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Old value for GLOB_REG=0x%08x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* get the current counter value */
name|val1
operator|=
operator|(
operator|(
name|val
operator|&
name|mask
operator|)
operator|>>
name|shift
operator|)
expr_stmt|;
comment|/* set bit of this PF */
name|val1
operator||=
operator|(
literal|1
operator|<<
name|SC_ABS_FUNC
argument_list|(
name|sc
argument_list|)
operator|)
expr_stmt|;
comment|/* clear the old value */
name|val
operator|&=
operator|~
name|mask
expr_stmt|;
comment|/* set the new one */
name|val
operator||=
operator|(
operator|(
name|val1
operator|<<
name|shift
operator|)
operator|&
name|mask
operator|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BXE_RECOVERY_GLOB_REG
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|bxe_release_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_RECOVERY_REG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* clear pf load mark */
end_comment

begin_comment
comment|/* XXX needs to be under rtnl lock */
end_comment

begin_function
specifier|static
name|uint8_t
name|bxe_clear_pf_load
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|val1
decl_stmt|,
name|val
decl_stmt|;
name|uint32_t
name|mask
init|=
name|SC_PATH
argument_list|(
name|sc
argument_list|)
condition|?
name|BXE_PATH1_LOAD_CNT_MASK
else|:
name|BXE_PATH0_LOAD_CNT_MASK
decl_stmt|;
name|uint32_t
name|shift
init|=
name|SC_PATH
argument_list|(
name|sc
argument_list|)
condition|?
name|BXE_PATH1_LOAD_CNT_SHIFT
else|:
name|BXE_PATH0_LOAD_CNT_SHIFT
decl_stmt|;
name|bxe_acquire_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_RECOVERY_REG
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BXE_RECOVERY_GLOB_REG
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Old GEN_REG_VAL=0x%08x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* get the current counter value */
name|val1
operator|=
operator|(
name|val
operator|&
name|mask
operator|)
operator|>>
name|shift
expr_stmt|;
comment|/* clear bit of that PF */
name|val1
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|SC_ABS_FUNC
argument_list|(
name|sc
argument_list|)
operator|)
expr_stmt|;
comment|/* clear the old value */
name|val
operator|&=
operator|~
name|mask
expr_stmt|;
comment|/* set the new one */
name|val
operator||=
operator|(
operator|(
name|val1
operator|<<
name|shift
operator|)
operator|&
name|mask
operator|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BXE_RECOVERY_GLOB_REG
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|bxe_release_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_RECOVERY_REG
argument_list|)
expr_stmt|;
return|return
operator|(
name|val1
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* send load requrest to mcp and analyze response */
end_comment

begin_function
specifier|static
name|int
name|bxe_nic_load_request
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
modifier|*
name|load_code
parameter_list|)
block|{
comment|/* init fw_seq */
name|sc
operator|->
name|fw_seq
operator|=
operator|(
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|func_mb
index|[
name|SC_FW_MB_IDX
argument_list|(
name|sc
argument_list|)
index|]
operator|.
name|drv_mb_header
argument_list|)
operator|&
name|DRV_MSG_SEQ_NUMBER_MASK
operator|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"initial fw_seq 0x%04x\n"
argument_list|,
name|sc
operator|->
name|fw_seq
argument_list|)
expr_stmt|;
comment|/* get the current FW pulse sequence */
name|sc
operator|->
name|fw_drv_pulse_wr_seq
operator|=
operator|(
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|func_mb
index|[
name|SC_FW_MB_IDX
argument_list|(
name|sc
argument_list|)
index|]
operator|.
name|drv_pulse_mb
argument_list|)
operator|&
name|DRV_PULSE_SEQ_MASK
operator|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"initial drv_pulse 0x%04x\n"
argument_list|,
name|sc
operator|->
name|fw_drv_pulse_wr_seq
argument_list|)
expr_stmt|;
comment|/* load request */
operator|(
operator|*
name|load_code
operator|)
operator|=
name|bxe_fw_command
argument_list|(
name|sc
argument_list|,
name|DRV_MSG_CODE_LOAD_REQ
argument_list|,
name|DRV_MSG_CODE_LOAD_REQ_WITH_LFA
argument_list|)
expr_stmt|;
comment|/* if the MCP fails to respond we must abort */
if|if
condition|(
operator|!
operator|(
operator|*
name|load_code
operator|)
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"MCP response failure!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* if MCP refused then must abort */
if|if
condition|(
operator|(
operator|*
name|load_code
operator|)
operator|==
name|FW_MSG_CODE_DRV_LOAD_REFUSED
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"MCP refused load request\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check whether another PF has already loaded FW to chip. In virtualized  * environments a pf from anoth VM may have already initialized the device  * including loading FW.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_nic_load_analyze_req
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|load_code
parameter_list|)
block|{
name|uint32_t
name|my_fw
decl_stmt|,
name|loaded_fw
decl_stmt|;
comment|/* is another pf loaded on this engine? */
if|if
condition|(
operator|(
name|load_code
operator|!=
name|FW_MSG_CODE_DRV_LOAD_COMMON_CHIP
operator|)
operator|&&
operator|(
name|load_code
operator|!=
name|FW_MSG_CODE_DRV_LOAD_COMMON
operator|)
condition|)
block|{
comment|/* build my FW version dword */
name|my_fw
operator|=
operator|(
name|BCM_5710_FW_MAJOR_VERSION
operator|+
operator|(
name|BCM_5710_FW_MINOR_VERSION
operator|<<
literal|8
operator|)
operator|+
operator|(
name|BCM_5710_FW_REVISION_VERSION
operator|<<
literal|16
operator|)
operator|+
operator|(
name|BCM_5710_FW_ENGINEERING_VERSION
operator|<<
literal|24
operator|)
operator|)
expr_stmt|;
comment|/* read loaded FW from chip */
name|loaded_fw
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|XSEM_REG_PRAM
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"loaded FW 0x%08x / my FW 0x%08x\n"
argument_list|,
name|loaded_fw
argument_list|,
name|my_fw
argument_list|)
expr_stmt|;
comment|/* abort nic load if version mismatch */
if|if
condition|(
name|my_fw
operator|!=
name|loaded_fw
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"FW 0x%08x already loaded (mine is 0x%08x)"
argument_list|,
name|loaded_fw
argument_list|,
name|my_fw
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* mark PMF if applicable */
end_comment

begin_function
specifier|static
name|void
name|bxe_nic_load_pmf
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|load_code
parameter_list|)
block|{
name|uint32_t
name|ncsi_oem_data_addr
decl_stmt|;
if|if
condition|(
operator|(
name|load_code
operator|==
name|FW_MSG_CODE_DRV_LOAD_COMMON
operator|)
operator|||
operator|(
name|load_code
operator|==
name|FW_MSG_CODE_DRV_LOAD_COMMON_CHIP
operator|)
operator|||
operator|(
name|load_code
operator|==
name|FW_MSG_CODE_DRV_LOAD_PORT
operator|)
condition|)
block|{
comment|/*          * Barrier here for ordering between the writing to sc->port.pmf here          * and reading it from the periodic task.          */
name|sc
operator|->
name|port
operator|.
name|pmf
operator|=
literal|1
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|port
operator|.
name|pmf
operator|=
literal|0
expr_stmt|;
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"pmf %d\n"
argument_list|,
name|sc
operator|->
name|port
operator|.
name|pmf
argument_list|)
expr_stmt|;
comment|/* XXX needed? */
if|if
condition|(
name|load_code
operator|==
name|FW_MSG_CODE_DRV_LOAD_COMMON_CHIP
condition|)
block|{
if|if
condition|(
name|SHMEM2_HAS
argument_list|(
name|sc
argument_list|,
name|ncsi_oem_data_addr
argument_list|)
condition|)
block|{
name|ncsi_oem_data_addr
operator|=
name|SHMEM2_RD
argument_list|(
name|sc
argument_list|,
name|ncsi_oem_data_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ncsi_oem_data_addr
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|ncsi_oem_data_addr
operator|+
name|offsetof
argument_list|(
expr|struct
name|glob_ncsi_oem_data
argument_list|,
name|driver_version
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_read_mf_cfg
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|n
init|=
operator|(
name|CHIP_IS_MODE_4_PORT
argument_list|(
name|sc
argument_list|)
condition|?
literal|2
else|:
literal|1
operator|)
decl_stmt|;
name|int
name|abs_func
decl_stmt|;
name|int
name|vn
decl_stmt|;
if|if
condition|(
name|BXE_NOMCP
argument_list|(
name|sc
argument_list|)
condition|)
block|{
return|return;
comment|/* what should be the default bvalue in this case */
block|}
comment|/*      * The formula for computing the absolute function number is...      * For 2 port configuration (4 functions per port):      *   abs_func = 2 * vn + SC_PORT + SC_PATH      * For 4 port configuration (2 functions per port):      *   abs_func = 4 * vn + 2 * SC_PORT + SC_PATH      */
for|for
control|(
name|vn
operator|=
name|VN_0
init|;
name|vn
operator|<
name|SC_MAX_VN_NUM
argument_list|(
name|sc
argument_list|)
condition|;
name|vn
operator|++
control|)
block|{
name|abs_func
operator|=
operator|(
name|n
operator|*
operator|(
literal|2
operator|*
name|vn
operator|+
name|SC_PORT
argument_list|(
name|sc
argument_list|)
operator|)
operator|+
name|SC_PATH
argument_list|(
name|sc
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|abs_func
operator|>=
name|E1H_FUNC_MAX
condition|)
block|{
break|break;
block|}
name|sc
operator|->
name|devinfo
operator|.
name|mf_info
operator|.
name|mf_config
index|[
name|vn
index|]
operator|=
name|MFCFG_RD
argument_list|(
name|sc
argument_list|,
name|func_mf_config
index|[
name|abs_func
index|]
operator|.
name|config
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|devinfo
operator|.
name|mf_info
operator|.
name|mf_config
index|[
name|SC_VN
argument_list|(
name|sc
argument_list|)
index|]
operator|&
name|FUNC_MF_CFG_FUNC_DISABLED
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"mf_cfg function disabled\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|BXE_MF_FUNC_DIS
expr_stmt|;
block|}
else|else
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"mf_cfg function enabled\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator|&=
operator|~
name|BXE_MF_FUNC_DIS
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* acquire split MCP access lock register */
end_comment

begin_function
specifier|static
name|int
name|bxe_acquire_alr
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|j
decl_stmt|,
name|val
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|1000
condition|;
name|j
operator|++
control|)
block|{
name|val
operator|=
operator|(
literal|1UL
operator|<<
literal|31
operator|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MCP
operator|+
literal|0x9c
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MCP
operator|+
literal|0x9c
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
operator|(
literal|1L
operator|<<
literal|31
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|val
operator|&
operator|(
literal|1L
operator|<<
literal|31
operator|)
operator|)
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Cannot acquire MCP access lock register\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* release split MCP access lock register */
end_comment

begin_function
specifier|static
name|void
name|bxe_release_alr
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MCP
operator|+
literal|0x9c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_fan_failure
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|port
init|=
name|SC_PORT
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|uint32_t
name|ext_phy_config
decl_stmt|;
comment|/* mark the failure */
name|ext_phy_config
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|port
index|]
operator|.
name|external_phy_config
argument_list|)
expr_stmt|;
name|ext_phy_config
operator|&=
operator|~
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_MASK
expr_stmt|;
name|ext_phy_config
operator||=
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_FAILURE
expr_stmt|;
name|SHMEM_WR
argument_list|(
name|sc
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|port
index|]
operator|.
name|external_phy_config
argument_list|,
name|ext_phy_config
argument_list|)
expr_stmt|;
comment|/* log the failure */
name|BLOGW
argument_list|(
name|sc
argument_list|,
literal|"Fan Failure has caused the driver to shutdown "
literal|"the card to prevent permanent damage. "
literal|"Please contact OEM Support for assistance\n"
argument_list|)
expr_stmt|;
comment|/* XXX */
if|#
directive|if
literal|1
name|bxe_panic
argument_list|(
name|sc
argument_list|,
operator|(
literal|"Schedule task to handle fan failure\n"
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/*      * Schedule device reset (unload)      * This is due to some boards consuming sufficient power when driver is      * up to overheat if fan fails.      */
name|bxe_set_bit
argument_list|(
name|BXE_SP_RTNL_FAN_FAILURE
argument_list|,
operator|&
name|sc
operator|->
name|sp_rtnl_state
argument_list|)
expr_stmt|;
name|schedule_delayed_work
argument_list|(
operator|&
name|sc
operator|->
name|sp_rtnl_task
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* this function is called upon a link interrupt */
end_comment

begin_function
specifier|static
name|void
name|bxe_link_attn
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|pause_enabled
init|=
literal|0
decl_stmt|;
name|struct
name|host_port_stats
modifier|*
name|pstats
decl_stmt|;
name|int
name|cmng_fns
decl_stmt|;
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Make sure that we are synced with the current statistics */
name|bxe_stats_handle
argument_list|(
name|sc
argument_list|,
name|STATS_EVENT_STOP
argument_list|)
expr_stmt|;
name|BLOGI
argument_list|(
name|sc
argument_list|,
literal|"link_vars phy_flags : %x\n"
argument_list|,
name|sc
operator|->
name|link_vars
operator|.
name|phy_flags
argument_list|)
expr_stmt|;
name|elink_link_update
argument_list|(
operator|&
name|sc
operator|->
name|link_params
argument_list|,
operator|&
name|sc
operator|->
name|link_vars
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|link_vars
operator|.
name|link_up
condition|)
block|{
comment|/* dropless flow control */
if|if
condition|(
operator|!
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
operator|&&
name|sc
operator|->
name|dropless_fc
condition|)
block|{
name|pause_enabled
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|link_vars
operator|.
name|flow_ctrl
operator|&
name|ELINK_FLOW_CTRL_TX
condition|)
block|{
name|pause_enabled
operator|=
literal|1
expr_stmt|;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|BAR_USTRORM_INTMEM
operator|+
name|USTORM_ETH_PAUSE_ENABLED_OFFSET
argument_list|(
name|SC_PORT
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|)
argument_list|,
name|pause_enabled
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|link_vars
operator|.
name|mac_type
operator|!=
name|ELINK_MAC_TYPE_EMAC
condition|)
block|{
name|pstats
operator|=
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|port_stats
argument_list|)
expr_stmt|;
comment|/* reset old mac stats */
name|memset
argument_list|(
operator|&
operator|(
name|pstats
operator|->
name|mac_stx
index|[
literal|0
index|]
operator|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mac_stx
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|state
operator|==
name|BXE_STATE_OPEN
condition|)
block|{
name|bxe_stats_handle
argument_list|(
name|sc
argument_list|,
name|STATS_EVENT_LINK_UP
argument_list|)
expr_stmt|;
block|}
comment|/* Restart tx when the link comes back. */
name|FOR_EACH_ETH_QUEUE
argument_list|(
argument|sc
argument_list|,
argument|i
argument_list|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|fp
operator|->
name|tq
argument_list|,
operator|&
name|fp
operator|->
name|tx_task
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|link_vars
operator|.
name|link_up
operator|&&
name|sc
operator|->
name|link_vars
operator|.
name|line_speed
condition|)
block|{
name|cmng_fns
operator|=
name|bxe_get_cmng_fns_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmng_fns
operator|!=
name|CMNG_FNS_NONE
condition|)
block|{
name|bxe_cmng_fns_init
argument_list|(
name|sc
argument_list|,
name|FALSE
argument_list|,
name|cmng_fns
argument_list|)
expr_stmt|;
name|storm_memset_cmng
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|cmng
argument_list|,
name|SC_PORT
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* rate shaping and fairness are disabled */
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"single function mode without fairness\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|bxe_link_report_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_MF
argument_list|(
name|sc
argument_list|)
condition|)
block|{
empty_stmt|;
comment|// XXX bxe_link_sync_notify(sc);
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_attn_int_asserted
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|asserted
parameter_list|)
block|{
name|int
name|port
init|=
name|SC_PORT
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|uint32_t
name|aeu_addr
init|=
name|port
condition|?
name|MISC_REG_AEU_MASK_ATTN_FUNC_1
else|:
name|MISC_REG_AEU_MASK_ATTN_FUNC_0
decl_stmt|;
name|uint32_t
name|nig_int_mask_addr
init|=
name|port
condition|?
name|NIG_REG_MASK_INTERRUPT_PORT1
else|:
name|NIG_REG_MASK_INTERRUPT_PORT0
decl_stmt|;
name|uint32_t
name|aeu_mask
decl_stmt|;
name|uint32_t
name|nig_mask
init|=
literal|0
decl_stmt|;
name|uint32_t
name|reg_addr
decl_stmt|;
name|uint32_t
name|igu_acked
decl_stmt|;
name|uint32_t
name|cnt
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|attn_state
operator|&
name|asserted
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"IGU ERROR attn=0x%08x\n"
argument_list|,
name|asserted
argument_list|)
expr_stmt|;
block|}
name|bxe_acquire_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_PORT0_ATT_MASK
operator|+
name|port
argument_list|)
expr_stmt|;
name|aeu_mask
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|aeu_addr
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_INTR
argument_list|,
literal|"aeu_mask 0x%08x newly asserted 0x%08x\n"
argument_list|,
name|aeu_mask
argument_list|,
name|asserted
argument_list|)
expr_stmt|;
name|aeu_mask
operator|&=
operator|~
operator|(
name|asserted
operator|&
literal|0x3ff
operator|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_INTR
argument_list|,
literal|"new mask 0x%08x\n"
argument_list|,
name|aeu_mask
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|aeu_addr
argument_list|,
name|aeu_mask
argument_list|)
expr_stmt|;
name|bxe_release_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_PORT0_ATT_MASK
operator|+
name|port
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_INTR
argument_list|,
literal|"attn_state 0x%08x\n"
argument_list|,
name|sc
operator|->
name|attn_state
argument_list|)
expr_stmt|;
name|sc
operator|->
name|attn_state
operator||=
name|asserted
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_INTR
argument_list|,
literal|"new state 0x%08x\n"
argument_list|,
name|sc
operator|->
name|attn_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|asserted
operator|&
name|ATTN_HARD_WIRED_MASK
condition|)
block|{
if|if
condition|(
name|asserted
operator|&
name|ATTN_NIG_FOR_FUNC
condition|)
block|{
name|bxe_acquire_phy_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* save nig interrupt mask */
name|nig_mask
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|nig_int_mask_addr
argument_list|)
expr_stmt|;
comment|/* If nig_mask is not set, no need to call the update function */
if|if
condition|(
name|nig_mask
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|nig_int_mask_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bxe_link_attn
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* handle unicore attn? */
block|}
if|if
condition|(
name|asserted
operator|&
name|ATTN_SW_TIMER_4_FUNC
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_INTR
argument_list|,
literal|"ATTN_SW_TIMER_4_FUNC!\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|asserted
operator|&
name|GPIO_2_FUNC
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_INTR
argument_list|,
literal|"GPIO_2_FUNC!\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|asserted
operator|&
name|GPIO_3_FUNC
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_INTR
argument_list|,
literal|"GPIO_3_FUNC!\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|asserted
operator|&
name|GPIO_4_FUNC
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_INTR
argument_list|,
literal|"GPIO_4_FUNC!\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|port
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|asserted
operator|&
name|ATTN_GENERAL_ATTN_1
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_INTR
argument_list|,
literal|"ATTN_GENERAL_ATTN_1!\n"
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_GENERAL_ATTN_1
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|asserted
operator|&
name|ATTN_GENERAL_ATTN_2
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_INTR
argument_list|,
literal|"ATTN_GENERAL_ATTN_2!\n"
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_GENERAL_ATTN_2
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|asserted
operator|&
name|ATTN_GENERAL_ATTN_3
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_INTR
argument_list|,
literal|"ATTN_GENERAL_ATTN_3!\n"
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_GENERAL_ATTN_3
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|asserted
operator|&
name|ATTN_GENERAL_ATTN_4
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_INTR
argument_list|,
literal|"ATTN_GENERAL_ATTN_4!\n"
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_GENERAL_ATTN_4
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|asserted
operator|&
name|ATTN_GENERAL_ATTN_5
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_INTR
argument_list|,
literal|"ATTN_GENERAL_ATTN_5!\n"
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_GENERAL_ATTN_5
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|asserted
operator|&
name|ATTN_GENERAL_ATTN_6
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_INTR
argument_list|,
literal|"ATTN_GENERAL_ATTN_6!\n"
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_GENERAL_ATTN_6
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* hardwired */
if|if
condition|(
name|sc
operator|->
name|devinfo
operator|.
name|int_block
operator|==
name|INT_BLOCK_HC
condition|)
block|{
name|reg_addr
operator|=
operator|(
name|HC_REG_COMMAND_REG
operator|+
name|port
operator|*
literal|32
operator|+
name|COMMAND_REG_ATTN_BITS_SET
operator|)
expr_stmt|;
block|}
else|else
block|{
name|reg_addr
operator|=
operator|(
name|BAR_IGU_INTMEM
operator|+
name|IGU_CMD_ATTN_BIT_SET_UPPER
operator|*
literal|8
operator|)
expr_stmt|;
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_INTR
argument_list|,
literal|"about to mask 0x%08x at %s addr 0x%08x\n"
argument_list|,
name|asserted
argument_list|,
operator|(
name|sc
operator|->
name|devinfo
operator|.
name|int_block
operator|==
name|INT_BLOCK_HC
operator|)
condition|?
literal|"HC"
else|:
literal|"IGU"
argument_list|,
name|reg_addr
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|reg_addr
argument_list|,
name|asserted
argument_list|)
expr_stmt|;
comment|/* now set back the mask */
if|if
condition|(
name|asserted
operator|&
name|ATTN_NIG_FOR_FUNC
condition|)
block|{
comment|/*          * Verify that IGU ack through BAR was written before restoring          * NIG mask. This loop should exit after 2-3 iterations max.          */
if|if
condition|(
name|sc
operator|->
name|devinfo
operator|.
name|int_block
operator|!=
name|INT_BLOCK_HC
condition|)
block|{
name|cnt
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|igu_acked
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|IGU_REG_ATTENTION_ACK_BITS
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
operator|(
name|igu_acked
operator|&
name|ATTN_NIG_FOR_FUNC
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|++
name|cnt
operator|<
name|MAX_IGU_ATTN_ACK_TO
operator|)
condition|)
do|;
if|if
condition|(
operator|!
name|igu_acked
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to verify IGU ack on time\n"
argument_list|)
expr_stmt|;
block|}
name|mb
argument_list|()
expr_stmt|;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|nig_int_mask_addr
argument_list|,
name|nig_mask
argument_list|)
expr_stmt|;
name|bxe_release_phy_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_print_next_block
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|idx
parameter_list|,
specifier|const
name|char
modifier|*
name|blk
parameter_list|)
block|{
name|BLOGI
argument_list|(
name|sc
argument_list|,
literal|"%s%s"
argument_list|,
name|idx
condition|?
literal|", "
else|:
literal|""
argument_list|,
name|blk
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_check_blocks_with_parity0
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|sig
parameter_list|,
name|int
name|par_num
parameter_list|,
name|uint8_t
name|print
parameter_list|)
block|{
name|uint32_t
name|cur_bit
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|sig
condition|;
name|i
operator|++
control|)
block|{
name|cur_bit
operator|=
operator|(
operator|(
name|uint32_t
operator|)
literal|0x1
operator|<<
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|sig
operator|&
name|cur_bit
condition|)
block|{
switch|switch
condition|(
name|cur_bit
condition|)
block|{
case|case
name|AEU_INPUTS_ATTN_BITS_BRB_PARITY_ERROR
case|:
if|if
condition|(
name|print
condition|)
name|bxe_print_next_block
argument_list|(
name|sc
argument_list|,
name|par_num
operator|++
argument_list|,
literal|"BRB"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AEU_INPUTS_ATTN_BITS_PARSER_PARITY_ERROR
case|:
if|if
condition|(
name|print
condition|)
name|bxe_print_next_block
argument_list|(
name|sc
argument_list|,
name|par_num
operator|++
argument_list|,
literal|"PARSER"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AEU_INPUTS_ATTN_BITS_TSDM_PARITY_ERROR
case|:
if|if
condition|(
name|print
condition|)
name|bxe_print_next_block
argument_list|(
name|sc
argument_list|,
name|par_num
operator|++
argument_list|,
literal|"TSDM"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AEU_INPUTS_ATTN_BITS_SEARCHER_PARITY_ERROR
case|:
if|if
condition|(
name|print
condition|)
name|bxe_print_next_block
argument_list|(
name|sc
argument_list|,
name|par_num
operator|++
argument_list|,
literal|"SEARCHER"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AEU_INPUTS_ATTN_BITS_TCM_PARITY_ERROR
case|:
if|if
condition|(
name|print
condition|)
name|bxe_print_next_block
argument_list|(
name|sc
argument_list|,
name|par_num
operator|++
argument_list|,
literal|"TCM"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AEU_INPUTS_ATTN_BITS_TSEMI_PARITY_ERROR
case|:
if|if
condition|(
name|print
condition|)
name|bxe_print_next_block
argument_list|(
name|sc
argument_list|,
name|par_num
operator|++
argument_list|,
literal|"TSEMI"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AEU_INPUTS_ATTN_BITS_PBCLIENT_PARITY_ERROR
case|:
if|if
condition|(
name|print
condition|)
name|bxe_print_next_block
argument_list|(
name|sc
argument_list|,
name|par_num
operator|++
argument_list|,
literal|"XPB"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Clear the bit */
name|sig
operator|&=
operator|~
name|cur_bit
expr_stmt|;
block|}
block|}
return|return
operator|(
name|par_num
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_check_blocks_with_parity1
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|sig
parameter_list|,
name|int
name|par_num
parameter_list|,
name|uint8_t
modifier|*
name|global
parameter_list|,
name|uint8_t
name|print
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|uint32_t
name|cur_bit
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|sig
condition|;
name|i
operator|++
control|)
block|{
name|cur_bit
operator|=
operator|(
operator|(
name|uint32_t
operator|)
literal|0x1
operator|<<
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|sig
operator|&
name|cur_bit
condition|)
block|{
switch|switch
condition|(
name|cur_bit
condition|)
block|{
case|case
name|AEU_INPUTS_ATTN_BITS_PBF_PARITY_ERROR
case|:
if|if
condition|(
name|print
condition|)
name|bxe_print_next_block
argument_list|(
name|sc
argument_list|,
name|par_num
operator|++
argument_list|,
literal|"PBF"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AEU_INPUTS_ATTN_BITS_QM_PARITY_ERROR
case|:
if|if
condition|(
name|print
condition|)
name|bxe_print_next_block
argument_list|(
name|sc
argument_list|,
name|par_num
operator|++
argument_list|,
literal|"QM"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AEU_INPUTS_ATTN_BITS_TIMERS_PARITY_ERROR
case|:
if|if
condition|(
name|print
condition|)
name|bxe_print_next_block
argument_list|(
name|sc
argument_list|,
name|par_num
operator|++
argument_list|,
literal|"TM"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AEU_INPUTS_ATTN_BITS_XSDM_PARITY_ERROR
case|:
if|if
condition|(
name|print
condition|)
name|bxe_print_next_block
argument_list|(
name|sc
argument_list|,
name|par_num
operator|++
argument_list|,
literal|"XSDM"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AEU_INPUTS_ATTN_BITS_XCM_PARITY_ERROR
case|:
if|if
condition|(
name|print
condition|)
name|bxe_print_next_block
argument_list|(
name|sc
argument_list|,
name|par_num
operator|++
argument_list|,
literal|"XCM"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AEU_INPUTS_ATTN_BITS_XSEMI_PARITY_ERROR
case|:
if|if
condition|(
name|print
condition|)
name|bxe_print_next_block
argument_list|(
name|sc
argument_list|,
name|par_num
operator|++
argument_list|,
literal|"XSEMI"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AEU_INPUTS_ATTN_BITS_DOORBELLQ_PARITY_ERROR
case|:
if|if
condition|(
name|print
condition|)
name|bxe_print_next_block
argument_list|(
name|sc
argument_list|,
name|par_num
operator|++
argument_list|,
literal|"DOORBELLQ"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AEU_INPUTS_ATTN_BITS_NIG_PARITY_ERROR
case|:
if|if
condition|(
name|print
condition|)
name|bxe_print_next_block
argument_list|(
name|sc
argument_list|,
name|par_num
operator|++
argument_list|,
literal|"NIG"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AEU_INPUTS_ATTN_BITS_VAUX_PCI_CORE_PARITY_ERROR
case|:
if|if
condition|(
name|print
condition|)
name|bxe_print_next_block
argument_list|(
name|sc
argument_list|,
name|par_num
operator|++
argument_list|,
literal|"VAUX PCI CORE"
argument_list|)
expr_stmt|;
operator|*
name|global
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|AEU_INPUTS_ATTN_BITS_DEBUG_PARITY_ERROR
case|:
if|if
condition|(
name|print
condition|)
name|bxe_print_next_block
argument_list|(
name|sc
argument_list|,
name|par_num
operator|++
argument_list|,
literal|"DEBUG"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AEU_INPUTS_ATTN_BITS_USDM_PARITY_ERROR
case|:
if|if
condition|(
name|print
condition|)
name|bxe_print_next_block
argument_list|(
name|sc
argument_list|,
name|par_num
operator|++
argument_list|,
literal|"USDM"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AEU_INPUTS_ATTN_BITS_UCM_PARITY_ERROR
case|:
if|if
condition|(
name|print
condition|)
name|bxe_print_next_block
argument_list|(
name|sc
argument_list|,
name|par_num
operator|++
argument_list|,
literal|"UCM"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AEU_INPUTS_ATTN_BITS_USEMI_PARITY_ERROR
case|:
if|if
condition|(
name|print
condition|)
name|bxe_print_next_block
argument_list|(
name|sc
argument_list|,
name|par_num
operator|++
argument_list|,
literal|"USEMI"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AEU_INPUTS_ATTN_BITS_UPB_PARITY_ERROR
case|:
if|if
condition|(
name|print
condition|)
name|bxe_print_next_block
argument_list|(
name|sc
argument_list|,
name|par_num
operator|++
argument_list|,
literal|"UPB"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AEU_INPUTS_ATTN_BITS_CSDM_PARITY_ERROR
case|:
if|if
condition|(
name|print
condition|)
name|bxe_print_next_block
argument_list|(
name|sc
argument_list|,
name|par_num
operator|++
argument_list|,
literal|"CSDM"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AEU_INPUTS_ATTN_BITS_CCM_PARITY_ERROR
case|:
if|if
condition|(
name|print
condition|)
name|bxe_print_next_block
argument_list|(
name|sc
argument_list|,
name|par_num
operator|++
argument_list|,
literal|"CCM"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Clear the bit */
name|sig
operator|&=
operator|~
name|cur_bit
expr_stmt|;
block|}
block|}
return|return
operator|(
name|par_num
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_check_blocks_with_parity2
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|sig
parameter_list|,
name|int
name|par_num
parameter_list|,
name|uint8_t
name|print
parameter_list|)
block|{
name|uint32_t
name|cur_bit
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|sig
condition|;
name|i
operator|++
control|)
block|{
name|cur_bit
operator|=
operator|(
operator|(
name|uint32_t
operator|)
literal|0x1
operator|<<
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|sig
operator|&
name|cur_bit
condition|)
block|{
switch|switch
condition|(
name|cur_bit
condition|)
block|{
case|case
name|AEU_INPUTS_ATTN_BITS_CSEMI_PARITY_ERROR
case|:
if|if
condition|(
name|print
condition|)
name|bxe_print_next_block
argument_list|(
name|sc
argument_list|,
name|par_num
operator|++
argument_list|,
literal|"CSEMI"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AEU_INPUTS_ATTN_BITS_PXP_PARITY_ERROR
case|:
if|if
condition|(
name|print
condition|)
name|bxe_print_next_block
argument_list|(
name|sc
argument_list|,
name|par_num
operator|++
argument_list|,
literal|"PXP"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AEU_IN_ATTN_BITS_PXPPCICLOCKCLIENT_PARITY_ERROR
case|:
if|if
condition|(
name|print
condition|)
name|bxe_print_next_block
argument_list|(
name|sc
argument_list|,
name|par_num
operator|++
argument_list|,
literal|"PXPPCICLOCKCLIENT"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AEU_INPUTS_ATTN_BITS_CFC_PARITY_ERROR
case|:
if|if
condition|(
name|print
condition|)
name|bxe_print_next_block
argument_list|(
name|sc
argument_list|,
name|par_num
operator|++
argument_list|,
literal|"CFC"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AEU_INPUTS_ATTN_BITS_CDU_PARITY_ERROR
case|:
if|if
condition|(
name|print
condition|)
name|bxe_print_next_block
argument_list|(
name|sc
argument_list|,
name|par_num
operator|++
argument_list|,
literal|"CDU"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AEU_INPUTS_ATTN_BITS_DMAE_PARITY_ERROR
case|:
if|if
condition|(
name|print
condition|)
name|bxe_print_next_block
argument_list|(
name|sc
argument_list|,
name|par_num
operator|++
argument_list|,
literal|"DMAE"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AEU_INPUTS_ATTN_BITS_IGU_PARITY_ERROR
case|:
if|if
condition|(
name|print
condition|)
name|bxe_print_next_block
argument_list|(
name|sc
argument_list|,
name|par_num
operator|++
argument_list|,
literal|"IGU"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AEU_INPUTS_ATTN_BITS_MISC_PARITY_ERROR
case|:
if|if
condition|(
name|print
condition|)
name|bxe_print_next_block
argument_list|(
name|sc
argument_list|,
name|par_num
operator|++
argument_list|,
literal|"MISC"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Clear the bit */
name|sig
operator|&=
operator|~
name|cur_bit
expr_stmt|;
block|}
block|}
return|return
operator|(
name|par_num
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_check_blocks_with_parity3
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|sig
parameter_list|,
name|int
name|par_num
parameter_list|,
name|uint8_t
modifier|*
name|global
parameter_list|,
name|uint8_t
name|print
parameter_list|)
block|{
name|uint32_t
name|cur_bit
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|sig
condition|;
name|i
operator|++
control|)
block|{
name|cur_bit
operator|=
operator|(
operator|(
name|uint32_t
operator|)
literal|0x1
operator|<<
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|sig
operator|&
name|cur_bit
condition|)
block|{
switch|switch
condition|(
name|cur_bit
condition|)
block|{
case|case
name|AEU_INPUTS_ATTN_BITS_MCP_LATCHED_ROM_PARITY
case|:
if|if
condition|(
name|print
condition|)
name|bxe_print_next_block
argument_list|(
name|sc
argument_list|,
name|par_num
operator|++
argument_list|,
literal|"MCP ROM"
argument_list|)
expr_stmt|;
operator|*
name|global
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|AEU_INPUTS_ATTN_BITS_MCP_LATCHED_UMP_RX_PARITY
case|:
if|if
condition|(
name|print
condition|)
name|bxe_print_next_block
argument_list|(
name|sc
argument_list|,
name|par_num
operator|++
argument_list|,
literal|"MCP UMP RX"
argument_list|)
expr_stmt|;
operator|*
name|global
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|AEU_INPUTS_ATTN_BITS_MCP_LATCHED_UMP_TX_PARITY
case|:
if|if
condition|(
name|print
condition|)
name|bxe_print_next_block
argument_list|(
name|sc
argument_list|,
name|par_num
operator|++
argument_list|,
literal|"MCP UMP TX"
argument_list|)
expr_stmt|;
operator|*
name|global
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|AEU_INPUTS_ATTN_BITS_MCP_LATCHED_SCPAD_PARITY
case|:
if|if
condition|(
name|print
condition|)
name|bxe_print_next_block
argument_list|(
name|sc
argument_list|,
name|par_num
operator|++
argument_list|,
literal|"MCP SCPAD"
argument_list|)
expr_stmt|;
operator|*
name|global
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
comment|/* Clear the bit */
name|sig
operator|&=
operator|~
name|cur_bit
expr_stmt|;
block|}
block|}
return|return
operator|(
name|par_num
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_check_blocks_with_parity4
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|sig
parameter_list|,
name|int
name|par_num
parameter_list|,
name|uint8_t
name|print
parameter_list|)
block|{
name|uint32_t
name|cur_bit
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|sig
condition|;
name|i
operator|++
control|)
block|{
name|cur_bit
operator|=
operator|(
operator|(
name|uint32_t
operator|)
literal|0x1
operator|<<
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|sig
operator|&
name|cur_bit
condition|)
block|{
switch|switch
condition|(
name|cur_bit
condition|)
block|{
case|case
name|AEU_INPUTS_ATTN_BITS_PGLUE_PARITY_ERROR
case|:
if|if
condition|(
name|print
condition|)
name|bxe_print_next_block
argument_list|(
name|sc
argument_list|,
name|par_num
operator|++
argument_list|,
literal|"PGLUE_B"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AEU_INPUTS_ATTN_BITS_ATC_PARITY_ERROR
case|:
if|if
condition|(
name|print
condition|)
name|bxe_print_next_block
argument_list|(
name|sc
argument_list|,
name|par_num
operator|++
argument_list|,
literal|"ATC"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Clear the bit */
name|sig
operator|&=
operator|~
name|cur_bit
expr_stmt|;
block|}
block|}
return|return
operator|(
name|par_num
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|bxe_parity_attn
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
modifier|*
name|global
parameter_list|,
name|uint8_t
name|print
parameter_list|,
name|uint32_t
modifier|*
name|sig
parameter_list|)
block|{
name|int
name|par_num
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|sig
index|[
literal|0
index|]
operator|&
name|HW_PRTY_ASSERT_SET_0
operator|)
operator|||
operator|(
name|sig
index|[
literal|1
index|]
operator|&
name|HW_PRTY_ASSERT_SET_1
operator|)
operator|||
operator|(
name|sig
index|[
literal|2
index|]
operator|&
name|HW_PRTY_ASSERT_SET_2
operator|)
operator|||
operator|(
name|sig
index|[
literal|3
index|]
operator|&
name|HW_PRTY_ASSERT_SET_3
operator|)
operator|||
operator|(
name|sig
index|[
literal|4
index|]
operator|&
name|HW_PRTY_ASSERT_SET_4
operator|)
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Parity error: HW block parity attention:\n"
literal|"[0]:0x%08x [1]:0x%08x [2]:0x%08x [3]:0x%08x [4]:0x%08x\n"
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|sig
index|[
literal|0
index|]
operator|&
name|HW_PRTY_ASSERT_SET_0
argument_list|)
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|sig
index|[
literal|1
index|]
operator|&
name|HW_PRTY_ASSERT_SET_1
argument_list|)
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|sig
index|[
literal|2
index|]
operator|&
name|HW_PRTY_ASSERT_SET_2
argument_list|)
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|sig
index|[
literal|3
index|]
operator|&
name|HW_PRTY_ASSERT_SET_3
argument_list|)
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|sig
index|[
literal|4
index|]
operator|&
name|HW_PRTY_ASSERT_SET_4
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|print
condition|)
name|BLOGI
argument_list|(
name|sc
argument_list|,
literal|"Parity errors detected in blocks: "
argument_list|)
expr_stmt|;
name|par_num
operator|=
name|bxe_check_blocks_with_parity0
argument_list|(
name|sc
argument_list|,
name|sig
index|[
literal|0
index|]
operator|&
name|HW_PRTY_ASSERT_SET_0
argument_list|,
name|par_num
argument_list|,
name|print
argument_list|)
expr_stmt|;
name|par_num
operator|=
name|bxe_check_blocks_with_parity1
argument_list|(
name|sc
argument_list|,
name|sig
index|[
literal|1
index|]
operator|&
name|HW_PRTY_ASSERT_SET_1
argument_list|,
name|par_num
argument_list|,
name|global
argument_list|,
name|print
argument_list|)
expr_stmt|;
name|par_num
operator|=
name|bxe_check_blocks_with_parity2
argument_list|(
name|sc
argument_list|,
name|sig
index|[
literal|2
index|]
operator|&
name|HW_PRTY_ASSERT_SET_2
argument_list|,
name|par_num
argument_list|,
name|print
argument_list|)
expr_stmt|;
name|par_num
operator|=
name|bxe_check_blocks_with_parity3
argument_list|(
name|sc
argument_list|,
name|sig
index|[
literal|3
index|]
operator|&
name|HW_PRTY_ASSERT_SET_3
argument_list|,
name|par_num
argument_list|,
name|global
argument_list|,
name|print
argument_list|)
expr_stmt|;
name|par_num
operator|=
name|bxe_check_blocks_with_parity4
argument_list|(
name|sc
argument_list|,
name|sig
index|[
literal|4
index|]
operator|&
name|HW_PRTY_ASSERT_SET_4
argument_list|,
name|par_num
argument_list|,
name|print
argument_list|)
expr_stmt|;
if|if
condition|(
name|print
condition|)
name|BLOGI
argument_list|(
name|sc
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|bxe_chk_parity_attn
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
modifier|*
name|global
parameter_list|,
name|uint8_t
name|print
parameter_list|)
block|{
name|struct
name|attn_route
name|attn
init|=
block|{
block|{
literal|0
block|}
block|}
decl_stmt|;
name|int
name|port
init|=
name|SC_PORT
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|attn
operator|.
name|sig
index|[
literal|0
index|]
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_AFTER_INVERT_1_FUNC_0
operator|+
name|port
operator|*
literal|4
argument_list|)
expr_stmt|;
name|attn
operator|.
name|sig
index|[
literal|1
index|]
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_AFTER_INVERT_2_FUNC_0
operator|+
name|port
operator|*
literal|4
argument_list|)
expr_stmt|;
name|attn
operator|.
name|sig
index|[
literal|2
index|]
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_AFTER_INVERT_3_FUNC_0
operator|+
name|port
operator|*
literal|4
argument_list|)
expr_stmt|;
name|attn
operator|.
name|sig
index|[
literal|3
index|]
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_AFTER_INVERT_4_FUNC_0
operator|+
name|port
operator|*
literal|4
argument_list|)
expr_stmt|;
comment|/*      * Since MCP attentions can't be disabled inside the block, we need to      * read AEU registers to see whether they're currently disabled      */
name|attn
operator|.
name|sig
index|[
literal|3
index|]
operator|&=
operator|(
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
operator|(
operator|!
name|port
condition|?
name|MISC_REG_AEU_ENABLE4_FUNC_0_OUT_0
else|:
name|MISC_REG_AEU_ENABLE4_FUNC_1_OUT_0
operator|)
argument_list|)
operator|&
name|MISC_AEU_ENABLE_MCP_PRTY_BITS
operator|)
operator||
operator|~
name|MISC_AEU_ENABLE_MCP_PRTY_BITS
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
name|attn
operator|.
name|sig
index|[
literal|4
index|]
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_AFTER_INVERT_5_FUNC_0
operator|+
name|port
operator|*
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
name|bxe_parity_attn
argument_list|(
name|sc
argument_list|,
name|global
argument_list|,
name|print
argument_list|,
name|attn
operator|.
name|sig
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_attn_int_deasserted4
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|attn
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
if|if
condition|(
name|attn
operator|&
name|AEU_INPUTS_ATTN_BITS_PGLUE_HW_INTERRUPT
condition|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|PGLUE_B_REG_PGLUE_B_INT_STS_CLR
argument_list|)
expr_stmt|;
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"PGLUE hw attention 0x%08x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|PGLUE_B_PGLUE_B_INT_STS_REG_ADDRESS_ERROR
condition|)
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"PGLUE_B_PGLUE_B_INT_STS_REG_ADDRESS_ERROR\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|PGLUE_B_PGLUE_B_INT_STS_REG_INCORRECT_RCV_BEHAVIOR
condition|)
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"PGLUE_B_PGLUE_B_INT_STS_REG_INCORRECT_RCV_BEHAVIOR\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|PGLUE_B_PGLUE_B_INT_STS_REG_WAS_ERROR_ATTN
condition|)
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"PGLUE_B_PGLUE_B_INT_STS_REG_WAS_ERROR_ATTN\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|PGLUE_B_PGLUE_B_INT_STS_REG_VF_LENGTH_VIOLATION_ATTN
condition|)
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"PGLUE_B_PGLUE_B_INT_STS_REG_VF_LENGTH_VIOLATION_ATTN\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|PGLUE_B_PGLUE_B_INT_STS_REG_VF_GRC_SPACE_VIOLATION_ATTN
condition|)
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"PGLUE_B_PGLUE_B_INT_STS_REG_VF_GRC_SPACE_VIOLATION_ATTN\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|PGLUE_B_PGLUE_B_INT_STS_REG_VF_MSIX_BAR_VIOLATION_ATTN
condition|)
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"PGLUE_B_PGLUE_B_INT_STS_REG_VF_MSIX_BAR_VIOLATION_ATTN\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|PGLUE_B_PGLUE_B_INT_STS_REG_TCPL_ERROR_ATTN
condition|)
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"PGLUE_B_PGLUE_B_INT_STS_REG_TCPL_ERROR_ATTN\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|PGLUE_B_PGLUE_B_INT_STS_REG_TCPL_IN_TWO_RCBS_ATTN
condition|)
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"PGLUE_B_PGLUE_B_INT_STS_REG_TCPL_IN_TWO_RCBS_ATTN\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|PGLUE_B_PGLUE_B_INT_STS_REG_CSSNOOP_FIFO_OVERFLOW
condition|)
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"PGLUE_B_PGLUE_B_INT_STS_REG_CSSNOOP_FIFO_OVERFLOW\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|attn
operator|&
name|AEU_INPUTS_ATTN_BITS_ATC_HW_INTERRUPT
condition|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|ATC_REG_ATC_INT_STS_CLR
argument_list|)
expr_stmt|;
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"ATC hw attention 0x%08x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|ATC_ATC_INT_STS_REG_ADDRESS_ERROR
condition|)
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"ATC_ATC_INT_STS_REG_ADDRESS_ERROR\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|ATC_ATC_INT_STS_REG_ATC_TCPL_TO_NOT_PEND
condition|)
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"ATC_ATC_INT_STS_REG_ATC_TCPL_TO_NOT_PEND\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|ATC_ATC_INT_STS_REG_ATC_GPA_MULTIPLE_HITS
condition|)
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"ATC_ATC_INT_STS_REG_ATC_GPA_MULTIPLE_HITS\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|ATC_ATC_INT_STS_REG_ATC_RCPL_TO_EMPTY_CNT
condition|)
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"ATC_ATC_INT_STS_REG_ATC_RCPL_TO_EMPTY_CNT\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|ATC_ATC_INT_STS_REG_ATC_TCPL_ERROR
condition|)
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"ATC_ATC_INT_STS_REG_ATC_TCPL_ERROR\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|ATC_ATC_INT_STS_REG_ATC_IREQ_LESS_THAN_STU
condition|)
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"ATC_ATC_INT_STS_REG_ATC_IREQ_LESS_THAN_STU\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|attn
operator|&
operator|(
name|AEU_INPUTS_ATTN_BITS_PGLUE_PARITY_ERROR
operator||
name|AEU_INPUTS_ATTN_BITS_ATC_PARITY_ERROR
operator|)
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"FATAL parity attention set4 0x%08x\n"
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|attn
operator|&
operator|(
name|AEU_INPUTS_ATTN_BITS_PGLUE_PARITY_ERROR
operator||
name|AEU_INPUTS_ATTN_BITS_ATC_PARITY_ERROR
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_e1h_disable
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|port
init|=
name|SC_PORT
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|bxe_tx_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LLH0_FUNC_EN
operator|+
name|port
operator|*
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_e1h_enable
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|port
init|=
name|SC_PORT
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LLH0_FUNC_EN
operator|+
name|port
operator|*
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// XXX bxe_tx_enable(sc);
block|}
end_function

begin_comment
comment|/*  * called due to MCP event (on pmf):  *   reread new bandwidth configuration  *   configure FW  *   notify others function about the change  */
end_comment

begin_function
specifier|static
name|void
name|bxe_config_mf_bw
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|link_vars
operator|.
name|link_up
condition|)
block|{
name|bxe_cmng_fns_init
argument_list|(
name|sc
argument_list|,
name|TRUE
argument_list|,
name|CMNG_FNS_MINMAX
argument_list|)
expr_stmt|;
comment|// XXX bxe_link_sync_notify(sc);
block|}
name|storm_memset_cmng
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|cmng
argument_list|,
name|SC_PORT
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_set_mf_bw
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|bxe_config_mf_bw
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_fw_command
argument_list|(
name|sc
argument_list|,
name|DRV_MSG_CODE_SET_MF_BW_ACK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_handle_eee_event
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_INTR
argument_list|,
literal|"EEE - LLDP event\n"
argument_list|)
expr_stmt|;
name|bxe_fw_command
argument_list|(
name|sc
argument_list|,
name|DRV_MSG_CODE_EEE_RESULTS_ACK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|DRV_INFO_ETH_STAT_NUM_MACS_REQUIRED
value|3
end_define

begin_function
specifier|static
name|void
name|bxe_drv_info_ether_stat
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|eth_stats_info
modifier|*
name|ether_stat
init|=
operator|&
name|sc
operator|->
name|sp
operator|->
name|drv_info_to_mcp
operator|.
name|ether_stat
decl_stmt|;
name|strlcpy
argument_list|(
name|ether_stat
operator|->
name|version
argument_list|,
name|BXE_DRIVER_VERSION
argument_list|,
name|ETH_STAT_INFO_VERSION_LEN
argument_list|)
expr_stmt|;
comment|/* XXX (+ MAC_PAD) taken from other driver... verify this is right */
name|sc
operator|->
name|sp_objs
index|[
literal|0
index|]
operator|.
name|mac_obj
operator|.
name|get_n_elements
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sp_objs
index|[
literal|0
index|]
operator|.
name|mac_obj
argument_list|,
name|DRV_INFO_ETH_STAT_NUM_MACS_REQUIRED
argument_list|,
name|ether_stat
operator|->
name|mac_local
operator|+
name|MAC_PAD
argument_list|,
name|MAC_PAD
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
name|ether_stat
operator|->
name|mtu_size
operator|=
name|sc
operator|->
name|mtu
expr_stmt|;
name|ether_stat
operator|->
name|feature_flags
operator||=
name|FEATURE_ETH_CHKSUM_OFFLOAD_MASK
expr_stmt|;
if|if
condition|(
name|if_getcapenable
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|&
operator|(
name|IFCAP_TSO4
operator||
name|IFCAP_TSO6
operator|)
condition|)
block|{
name|ether_stat
operator|->
name|feature_flags
operator||=
name|FEATURE_ETH_LSO_MASK
expr_stmt|;
block|}
comment|// XXX ether_stat->feature_flags |= ???;
name|ether_stat
operator|->
name|promiscuous_mode
operator|=
literal|0
expr_stmt|;
comment|// (flags& PROMISC) ? 1 : 0;
name|ether_stat
operator|->
name|txq_size
operator|=
name|sc
operator|->
name|tx_ring_size
expr_stmt|;
name|ether_stat
operator|->
name|rxq_size
operator|=
name|sc
operator|->
name|rx_ring_size
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_handle_drv_info_req
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|enum
name|drv_info_opcode
name|op_code
decl_stmt|;
name|uint32_t
name|drv_info_ctl
init|=
name|SHMEM2_RD
argument_list|(
name|sc
argument_list|,
name|drv_info_control
argument_list|)
decl_stmt|;
comment|/* if drv_info version supported by MFW doesn't match - send NACK */
if|if
condition|(
operator|(
name|drv_info_ctl
operator|&
name|DRV_INFO_CONTROL_VER_MASK
operator|)
operator|!=
name|DRV_INFO_CUR_VER
condition|)
block|{
name|bxe_fw_command
argument_list|(
name|sc
argument_list|,
name|DRV_MSG_CODE_DRV_INFO_NACK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|op_code
operator|=
operator|(
operator|(
name|drv_info_ctl
operator|&
name|DRV_INFO_CONTROL_OP_CODE_MASK
operator|)
operator|>>
name|DRV_INFO_CONTROL_OP_CODE_SHIFT
operator|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sc
operator|->
name|sp
operator|->
name|drv_info_to_mcp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|drv_info_to_mcp
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op_code
condition|)
block|{
case|case
name|ETH_STATS_OPCODE
case|:
name|bxe_drv_info_ether_stat
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|FCOE_STATS_OPCODE
case|:
case|case
name|ISCSI_STATS_OPCODE
case|:
default|default:
comment|/* if op code isn't supported - send NACK */
name|bxe_fw_command
argument_list|(
name|sc
argument_list|,
name|DRV_MSG_CODE_DRV_INFO_NACK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * If we got drv_info attn from MFW then these fields are defined in      * shmem2 for sure      */
name|SHMEM2_WR
argument_list|(
name|sc
argument_list|,
name|drv_info_host_addr_lo
argument_list|,
name|U64_LO
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|drv_info_to_mcp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SHMEM2_WR
argument_list|(
name|sc
argument_list|,
name|drv_info_host_addr_hi
argument_list|,
name|U64_HI
argument_list|(
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|drv_info_to_mcp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|bxe_fw_command
argument_list|(
name|sc
argument_list|,
name|DRV_MSG_CODE_DRV_INFO_ACK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_dcc_event
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|dcc_event
parameter_list|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_INTR
argument_list|,
literal|"dcc_event 0x%08x\n"
argument_list|,
name|dcc_event
argument_list|)
expr_stmt|;
if|if
condition|(
name|dcc_event
operator|&
name|DRV_STATUS_DCC_DISABLE_ENABLE_PF
condition|)
block|{
comment|/*          * This is the only place besides the function initialization          * where the sc->flags can change so it is done without any          * locks          */
if|if
condition|(
name|sc
operator|->
name|devinfo
operator|.
name|mf_info
operator|.
name|mf_config
index|[
name|SC_VN
argument_list|(
name|sc
argument_list|)
index|]
operator|&
name|FUNC_MF_CFG_FUNC_DISABLED
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_INTR
argument_list|,
literal|"mf_cfg function disabled\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|BXE_MF_FUNC_DIS
expr_stmt|;
name|bxe_e1h_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_INTR
argument_list|,
literal|"mf_cfg function enabled\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator|&=
operator|~
name|BXE_MF_FUNC_DIS
expr_stmt|;
name|bxe_e1h_enable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|dcc_event
operator|&=
operator|~
name|DRV_STATUS_DCC_DISABLE_ENABLE_PF
expr_stmt|;
block|}
if|if
condition|(
name|dcc_event
operator|&
name|DRV_STATUS_DCC_BANDWIDTH_ALLOCATION
condition|)
block|{
name|bxe_config_mf_bw
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|dcc_event
operator|&=
operator|~
name|DRV_STATUS_DCC_BANDWIDTH_ALLOCATION
expr_stmt|;
block|}
comment|/* Report results to MCP */
if|if
condition|(
name|dcc_event
condition|)
name|bxe_fw_command
argument_list|(
name|sc
argument_list|,
name|DRV_MSG_CODE_DCC_FAILURE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|bxe_fw_command
argument_list|(
name|sc
argument_list|,
name|DRV_MSG_CODE_DCC_OK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_pmf_update
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|port
init|=
name|SC_PORT
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|sc
operator|->
name|port
operator|.
name|pmf
operator|=
literal|1
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_INTR
argument_list|,
literal|"pmf %d\n"
argument_list|,
name|sc
operator|->
name|port
operator|.
name|pmf
argument_list|)
expr_stmt|;
comment|/*      * We need the mb() to ensure the ordering between the writing to      * sc->port.pmf here and reading it from the bxe_periodic_task().      */
name|mb
argument_list|()
expr_stmt|;
comment|/* queue a periodic task */
comment|// XXX schedule task...
comment|// XXX bxe_dcbx_pmf_update(sc);
comment|/* enable nig attention */
name|val
operator|=
operator|(
literal|0xff0f
operator||
operator|(
literal|1
operator|<<
operator|(
name|SC_VN
argument_list|(
name|sc
argument_list|)
operator|+
literal|4
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|devinfo
operator|.
name|int_block
operator|==
name|INT_BLOCK_HC
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|HC_REG_TRAILING_EDGE_0
operator|+
name|port
operator|*
literal|8
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|HC_REG_LEADING_EDGE_0
operator|+
name|port
operator|*
literal|8
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|IGU_REG_TRAILING_EDGE_LATCH
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|IGU_REG_LEADING_EDGE_LATCH
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|bxe_stats_handle
argument_list|(
name|sc
argument_list|,
name|STATS_EVENT_PMF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_mc_assert
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|char
name|last_idx
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
name|uint32_t
name|row0
decl_stmt|,
name|row1
decl_stmt|,
name|row2
decl_stmt|,
name|row3
decl_stmt|;
comment|/* XSTORM */
name|last_idx
operator|=
name|REG_RD8
argument_list|(
name|sc
argument_list|,
name|BAR_XSTRORM_INTMEM
operator|+
name|XSTORM_ASSERT_LIST_INDEX_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_idx
condition|)
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"XSTORM_ASSERT_LIST_INDEX 0x%x\n"
argument_list|,
name|last_idx
argument_list|)
expr_stmt|;
comment|/* print the asserts */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STORM_ASSERT_ARRAY_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|row0
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BAR_XSTRORM_INTMEM
operator|+
name|XSTORM_ASSERT_LIST_OFFSET
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|row1
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BAR_XSTRORM_INTMEM
operator|+
name|XSTORM_ASSERT_LIST_OFFSET
argument_list|(
name|i
argument_list|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|row2
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BAR_XSTRORM_INTMEM
operator|+
name|XSTORM_ASSERT_LIST_OFFSET
argument_list|(
name|i
argument_list|)
operator|+
literal|8
argument_list|)
expr_stmt|;
name|row3
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BAR_XSTRORM_INTMEM
operator|+
name|XSTORM_ASSERT_LIST_OFFSET
argument_list|(
name|i
argument_list|)
operator|+
literal|12
argument_list|)
expr_stmt|;
if|if
condition|(
name|row0
operator|!=
name|COMMON_ASM_INVALID_ASSERT_OPCODE
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"XSTORM_ASSERT_INDEX 0x%x = 0x%08x 0x%08x 0x%08x 0x%08x\n"
argument_list|,
name|i
argument_list|,
name|row3
argument_list|,
name|row2
argument_list|,
name|row1
argument_list|,
name|row0
argument_list|)
expr_stmt|;
name|rc
operator|++
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
comment|/* TSTORM */
name|last_idx
operator|=
name|REG_RD8
argument_list|(
name|sc
argument_list|,
name|BAR_TSTRORM_INTMEM
operator|+
name|TSTORM_ASSERT_LIST_INDEX_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_idx
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"TSTORM_ASSERT_LIST_INDEX 0x%x\n"
argument_list|,
name|last_idx
argument_list|)
expr_stmt|;
block|}
comment|/* print the asserts */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STORM_ASSERT_ARRAY_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|row0
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BAR_TSTRORM_INTMEM
operator|+
name|TSTORM_ASSERT_LIST_OFFSET
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|row1
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BAR_TSTRORM_INTMEM
operator|+
name|TSTORM_ASSERT_LIST_OFFSET
argument_list|(
name|i
argument_list|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|row2
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BAR_TSTRORM_INTMEM
operator|+
name|TSTORM_ASSERT_LIST_OFFSET
argument_list|(
name|i
argument_list|)
operator|+
literal|8
argument_list|)
expr_stmt|;
name|row3
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BAR_TSTRORM_INTMEM
operator|+
name|TSTORM_ASSERT_LIST_OFFSET
argument_list|(
name|i
argument_list|)
operator|+
literal|12
argument_list|)
expr_stmt|;
if|if
condition|(
name|row0
operator|!=
name|COMMON_ASM_INVALID_ASSERT_OPCODE
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"TSTORM_ASSERT_INDEX 0x%x = 0x%08x 0x%08x 0x%08x 0x%08x\n"
argument_list|,
name|i
argument_list|,
name|row3
argument_list|,
name|row2
argument_list|,
name|row1
argument_list|,
name|row0
argument_list|)
expr_stmt|;
name|rc
operator|++
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
comment|/* CSTORM */
name|last_idx
operator|=
name|REG_RD8
argument_list|(
name|sc
argument_list|,
name|BAR_CSTRORM_INTMEM
operator|+
name|CSTORM_ASSERT_LIST_INDEX_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_idx
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"CSTORM_ASSERT_LIST_INDEX 0x%x\n"
argument_list|,
name|last_idx
argument_list|)
expr_stmt|;
block|}
comment|/* print the asserts */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STORM_ASSERT_ARRAY_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|row0
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BAR_CSTRORM_INTMEM
operator|+
name|CSTORM_ASSERT_LIST_OFFSET
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|row1
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BAR_CSTRORM_INTMEM
operator|+
name|CSTORM_ASSERT_LIST_OFFSET
argument_list|(
name|i
argument_list|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|row2
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BAR_CSTRORM_INTMEM
operator|+
name|CSTORM_ASSERT_LIST_OFFSET
argument_list|(
name|i
argument_list|)
operator|+
literal|8
argument_list|)
expr_stmt|;
name|row3
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BAR_CSTRORM_INTMEM
operator|+
name|CSTORM_ASSERT_LIST_OFFSET
argument_list|(
name|i
argument_list|)
operator|+
literal|12
argument_list|)
expr_stmt|;
if|if
condition|(
name|row0
operator|!=
name|COMMON_ASM_INVALID_ASSERT_OPCODE
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"CSTORM_ASSERT_INDEX 0x%x = 0x%08x 0x%08x 0x%08x 0x%08x\n"
argument_list|,
name|i
argument_list|,
name|row3
argument_list|,
name|row2
argument_list|,
name|row1
argument_list|,
name|row0
argument_list|)
expr_stmt|;
name|rc
operator|++
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
comment|/* USTORM */
name|last_idx
operator|=
name|REG_RD8
argument_list|(
name|sc
argument_list|,
name|BAR_USTRORM_INTMEM
operator|+
name|USTORM_ASSERT_LIST_INDEX_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_idx
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"USTORM_ASSERT_LIST_INDEX 0x%x\n"
argument_list|,
name|last_idx
argument_list|)
expr_stmt|;
block|}
comment|/* print the asserts */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STORM_ASSERT_ARRAY_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|row0
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BAR_USTRORM_INTMEM
operator|+
name|USTORM_ASSERT_LIST_OFFSET
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|row1
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BAR_USTRORM_INTMEM
operator|+
name|USTORM_ASSERT_LIST_OFFSET
argument_list|(
name|i
argument_list|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|row2
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BAR_USTRORM_INTMEM
operator|+
name|USTORM_ASSERT_LIST_OFFSET
argument_list|(
name|i
argument_list|)
operator|+
literal|8
argument_list|)
expr_stmt|;
name|row3
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BAR_USTRORM_INTMEM
operator|+
name|USTORM_ASSERT_LIST_OFFSET
argument_list|(
name|i
argument_list|)
operator|+
literal|12
argument_list|)
expr_stmt|;
if|if
condition|(
name|row0
operator|!=
name|COMMON_ASM_INVALID_ASSERT_OPCODE
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"USTORM_ASSERT_INDEX 0x%x = 0x%08x 0x%08x 0x%08x 0x%08x\n"
argument_list|,
name|i
argument_list|,
name|row3
argument_list|,
name|row2
argument_list|,
name|row1
argument_list|,
name|row0
argument_list|)
expr_stmt|;
name|rc
operator|++
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_attn_int_deasserted3
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|attn
parameter_list|)
block|{
name|int
name|func
init|=
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
if|if
condition|(
name|attn
operator|&
name|EVEREST_GEN_ATTN_IN_USE_MASK
condition|)
block|{
if|if
condition|(
name|attn
operator|&
name|BXE_PMF_LINK_ASSERT
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_GENERAL_ATTN_12
operator|+
name|func
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bxe_read_mf_cfg
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|devinfo
operator|.
name|mf_info
operator|.
name|mf_config
index|[
name|SC_VN
argument_list|(
name|sc
argument_list|)
index|]
operator|=
name|MFCFG_RD
argument_list|(
name|sc
argument_list|,
name|func_mf_config
index|[
name|SC_ABS_FUNC
argument_list|(
name|sc
argument_list|)
index|]
operator|.
name|config
argument_list|)
expr_stmt|;
name|val
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|func_mb
index|[
name|SC_FW_MB_IDX
argument_list|(
name|sc
argument_list|)
index|]
operator|.
name|drv_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|DRV_STATUS_DCC_EVENT_MASK
condition|)
name|bxe_dcc_event
argument_list|(
name|sc
argument_list|,
operator|(
name|val
operator|&
name|DRV_STATUS_DCC_EVENT_MASK
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|DRV_STATUS_SET_MF_BW
condition|)
name|bxe_set_mf_bw
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|DRV_STATUS_DRV_INFO_REQ
condition|)
name|bxe_handle_drv_info_req
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|port
operator|.
name|pmf
operator|==
literal|0
operator|)
operator|&&
operator|(
name|val
operator|&
name|DRV_STATUS_PMF
operator|)
condition|)
name|bxe_pmf_update
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|DRV_STATUS_EEE_NEGOTIATION_RESULTS
condition|)
name|bxe_handle_eee_event
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|link_vars
operator|.
name|periodic_flags
operator|&
name|ELINK_PERIODIC_FLAGS_LINK_EVENT
condition|)
block|{
comment|/* sync with link */
name|bxe_acquire_phy_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|link_vars
operator|.
name|periodic_flags
operator|&=
operator|~
name|ELINK_PERIODIC_FLAGS_LINK_EVENT
expr_stmt|;
name|bxe_release_phy_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_MF
argument_list|(
name|sc
argument_list|)
condition|)
empty_stmt|;
comment|// XXX bxe_link_sync_notify(sc);
name|bxe_link_report
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/*              * Always call it here: bxe_link_report() will              * prevent the link indication duplication.              */
name|bxe_link_status_update
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|attn
operator|&
name|BXE_MC_ASSERT_BITS
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"MC assert!\n"
argument_list|)
expr_stmt|;
name|bxe_mc_assert
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_GENERAL_ATTN_10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_GENERAL_ATTN_9
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_GENERAL_ATTN_8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_GENERAL_ATTN_7
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bxe_panic
argument_list|(
name|sc
argument_list|,
operator|(
literal|"MC assert!\n"
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|attn
operator|&
name|BXE_MCP_ASSERT
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"MCP assert!\n"
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_GENERAL_ATTN_11
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// XXX bxe_fw_dump(sc);
block|}
else|else
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Unknown HW assert! (attn 0x%08x)\n"
argument_list|,
name|attn
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|attn
operator|&
name|EVEREST_LATCHED_ATTN_IN_USE_MASK
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"LATCHED attention 0x%08x (masked)\n"
argument_list|,
name|attn
argument_list|)
expr_stmt|;
if|if
condition|(
name|attn
operator|&
name|BXE_GRC_TIMEOUT
condition|)
block|{
name|val
operator|=
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|?
literal|0
else|:
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_GRC_TIMEOUT_ATTN
argument_list|)
expr_stmt|;
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"GRC time-out 0x%08x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|attn
operator|&
name|BXE_GRC_RSV
condition|)
block|{
name|val
operator|=
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|?
literal|0
else|:
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_GRC_RSV_ATTN
argument_list|)
expr_stmt|;
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"GRC reserved 0x%08x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_CLR_LATCH_SIGNAL
argument_list|,
literal|0x7ff
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_attn_int_deasserted2
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|attn
parameter_list|)
block|{
name|int
name|port
init|=
name|SC_PORT
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|int
name|reg_offset
decl_stmt|;
name|uint32_t
name|val0
decl_stmt|,
name|mask0
decl_stmt|,
name|val1
decl_stmt|,
name|mask1
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
if|if
condition|(
name|attn
operator|&
name|AEU_INPUTS_ATTN_BITS_CFC_HW_INTERRUPT
condition|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|CFC_REG_CFC_INT_STS_CLR
argument_list|)
expr_stmt|;
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"CFC hw attention 0x%08x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* CFC error attention */
if|if
condition|(
name|val
operator|&
literal|0x2
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"FATAL error from CFC\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|attn
operator|&
name|AEU_INPUTS_ATTN_BITS_PXP_HW_INTERRUPT
condition|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|PXP_REG_PXP_INT_STS_CLR_0
argument_list|)
expr_stmt|;
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"PXP hw attention-0 0x%08x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* RQ_USDMDP_FIFO_OVERFLOW */
if|if
condition|(
name|val
operator|&
literal|0x18000
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"FATAL error from PXP\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|PXP_REG_PXP_INT_STS_CLR_1
argument_list|)
expr_stmt|;
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"PXP hw attention-1 0x%08x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
define|#
directive|define
name|PXP2_EOP_ERROR_BIT
value|PXP2_PXP2_INT_STS_CLR_0_REG_WR_PGLUE_EOP_ERROR
define|#
directive|define
name|AEU_PXP2_HW_INT_BIT
value|AEU_INPUTS_ATTN_BITS_PXPPCICLOCKCLIENT_HW_INTERRUPT
if|if
condition|(
name|attn
operator|&
name|AEU_PXP2_HW_INT_BIT
condition|)
block|{
comment|/*  CQ47854 workaround do not panic on          *  PXP2_PXP2_INT_STS_0_REG_WR_PGLUE_EOP_ERROR          */
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|mask0
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_PXP2_INT_MASK_0
argument_list|)
expr_stmt|;
name|val1
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_PXP2_INT_STS_1
argument_list|)
expr_stmt|;
name|mask1
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_PXP2_INT_MASK_1
argument_list|)
expr_stmt|;
name|val0
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_PXP2_INT_STS_0
argument_list|)
expr_stmt|;
comment|/*              * If the only PXP2_EOP_ERROR_BIT is set in              * STS0 and STS1 - clear it              *              * probably we lose additional attentions between              * STS0 and STS_CLR0, in this case user will not              * be notified about them              */
if|if
condition|(
name|val0
operator|&
name|mask0
operator|&
name|PXP2_EOP_ERROR_BIT
operator|&&
operator|!
operator|(
name|val1
operator|&
name|mask1
operator|)
condition|)
name|val0
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_PXP2_INT_STS_CLR_0
argument_list|)
expr_stmt|;
comment|/* print the register, since no one can restore it */
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"PXP2_REG_PXP2_INT_STS_CLR_0 0x%08x\n"
argument_list|,
name|val0
argument_list|)
expr_stmt|;
comment|/*              * if PXP2_PXP2_INT_STS_0_REG_WR_PGLUE_EOP_ERROR              * then notify              */
if|if
condition|(
name|val0
operator|&
name|PXP2_EOP_ERROR_BIT
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"PXP2_WR_PGLUE_EOP_ERROR\n"
argument_list|)
expr_stmt|;
comment|/*                  * if only PXP2_PXP2_INT_STS_0_REG_WR_PGLUE_EOP_ERROR is                  * set then clear attention from PXP2 block without panic                  */
if|if
condition|(
operator|(
operator|(
name|val0
operator|&
name|mask0
operator|)
operator|==
name|PXP2_EOP_ERROR_BIT
operator|)
operator|&&
operator|(
operator|(
name|val1
operator|&
name|mask1
operator|)
operator|==
literal|0
operator|)
condition|)
name|attn
operator|&=
operator|~
name|AEU_PXP2_HW_INT_BIT
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|attn
operator|&
name|HW_INTERRUT_ASSERT_SET_2
condition|)
block|{
name|reg_offset
operator|=
operator|(
name|port
condition|?
name|MISC_REG_AEU_ENABLE1_FUNC_1_OUT_2
else|:
name|MISC_REG_AEU_ENABLE1_FUNC_0_OUT_2
operator|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|reg_offset
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
name|attn
operator|&
name|HW_INTERRUT_ASSERT_SET_2
operator|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|reg_offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"FATAL HW block attention set2 0x%x\n"
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|attn
operator|&
name|HW_INTERRUT_ASSERT_SET_2
argument_list|)
argument_list|)
expr_stmt|;
name|bxe_panic
argument_list|(
name|sc
argument_list|,
operator|(
literal|"HW block attention set2\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_attn_int_deasserted1
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|attn
parameter_list|)
block|{
name|int
name|port
init|=
name|SC_PORT
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|int
name|reg_offset
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
if|if
condition|(
name|attn
operator|&
name|AEU_INPUTS_ATTN_BITS_DOORBELLQ_HW_INTERRUPT
condition|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|DORQ_REG_DORQ_INT_STS_CLR
argument_list|)
expr_stmt|;
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"DB hw attention 0x%08x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* DORQ discard attention */
if|if
condition|(
name|val
operator|&
literal|0x2
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"FATAL error from DORQ\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|attn
operator|&
name|HW_INTERRUT_ASSERT_SET_1
condition|)
block|{
name|reg_offset
operator|=
operator|(
name|port
condition|?
name|MISC_REG_AEU_ENABLE1_FUNC_1_OUT_1
else|:
name|MISC_REG_AEU_ENABLE1_FUNC_0_OUT_1
operator|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|reg_offset
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
name|attn
operator|&
name|HW_INTERRUT_ASSERT_SET_1
operator|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|reg_offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"FATAL HW block attention set1 0x%08x\n"
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|attn
operator|&
name|HW_INTERRUT_ASSERT_SET_1
argument_list|)
argument_list|)
expr_stmt|;
name|bxe_panic
argument_list|(
name|sc
argument_list|,
operator|(
literal|"HW block attention set1\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_attn_int_deasserted0
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|attn
parameter_list|)
block|{
name|int
name|port
init|=
name|SC_PORT
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|int
name|reg_offset
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|reg_offset
operator|=
operator|(
name|port
operator|)
condition|?
name|MISC_REG_AEU_ENABLE1_FUNC_1_OUT_0
else|:
name|MISC_REG_AEU_ENABLE1_FUNC_0_OUT_0
expr_stmt|;
if|if
condition|(
name|attn
operator|&
name|AEU_INPUTS_ATTN_BITS_SPIO5
condition|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|reg_offset
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|AEU_INPUTS_ATTN_BITS_SPIO5
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|reg_offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|BLOGW
argument_list|(
name|sc
argument_list|,
literal|"SPIO5 hw attention\n"
argument_list|)
expr_stmt|;
comment|/* Fan failure attention */
name|elink_hw_reset_phy
argument_list|(
operator|&
name|sc
operator|->
name|link_params
argument_list|)
expr_stmt|;
name|bxe_fan_failure
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|attn
operator|&
name|sc
operator|->
name|link_vars
operator|.
name|aeu_int_mask
operator|)
operator|&&
name|sc
operator|->
name|port
operator|.
name|pmf
condition|)
block|{
name|bxe_acquire_phy_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|elink_handle_module_detect_int
argument_list|(
operator|&
name|sc
operator|->
name|link_params
argument_list|)
expr_stmt|;
name|bxe_release_phy_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|attn
operator|&
name|HW_INTERRUT_ASSERT_SET_0
condition|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|reg_offset
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
name|attn
operator|&
name|HW_INTERRUT_ASSERT_SET_0
operator|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|reg_offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|bxe_panic
argument_list|(
name|sc
argument_list|,
operator|(
literal|"FATAL HW block attention set0 0x%lx\n"
operator|,
operator|(
name|attn
operator|&
name|HW_INTERRUT_ASSERT_SET_0
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_attn_int_deasserted
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|deasserted
parameter_list|)
block|{
name|struct
name|attn_route
name|attn
decl_stmt|;
name|struct
name|attn_route
modifier|*
name|group_mask
decl_stmt|;
name|int
name|port
init|=
name|SC_PORT
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|int
name|index
decl_stmt|;
name|uint32_t
name|reg_addr
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|uint32_t
name|aeu_mask
decl_stmt|;
name|uint8_t
name|global
init|=
name|FALSE
decl_stmt|;
comment|/*      * Need to take HW lock because MCP or other port might also      * try to handle this event.      */
name|bxe_acquire_alr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bxe_chk_parity_attn
argument_list|(
name|sc
argument_list|,
operator|&
name|global
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
comment|/* XXX          * In case of parity errors don't handle attentions so that          * other function would "see" parity errors.          */
name|sc
operator|->
name|recovery_state
operator|=
name|BXE_RECOVERY_INIT
expr_stmt|;
comment|// XXX schedule a recovery task...
comment|/* disable HW interrupts */
name|bxe_int_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_release_alr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|attn
operator|.
name|sig
index|[
literal|0
index|]
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_AFTER_INVERT_1_FUNC_0
operator|+
name|port
operator|*
literal|4
argument_list|)
expr_stmt|;
name|attn
operator|.
name|sig
index|[
literal|1
index|]
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_AFTER_INVERT_2_FUNC_0
operator|+
name|port
operator|*
literal|4
argument_list|)
expr_stmt|;
name|attn
operator|.
name|sig
index|[
literal|2
index|]
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_AFTER_INVERT_3_FUNC_0
operator|+
name|port
operator|*
literal|4
argument_list|)
expr_stmt|;
name|attn
operator|.
name|sig
index|[
literal|3
index|]
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_AFTER_INVERT_4_FUNC_0
operator|+
name|port
operator|*
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|attn
operator|.
name|sig
index|[
literal|4
index|]
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_AFTER_INVERT_5_FUNC_0
operator|+
name|port
operator|*
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|attn
operator|.
name|sig
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_INTR
argument_list|,
literal|"attn: 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\n"
argument_list|,
name|attn
operator|.
name|sig
index|[
literal|0
index|]
argument_list|,
name|attn
operator|.
name|sig
index|[
literal|1
index|]
argument_list|,
name|attn
operator|.
name|sig
index|[
literal|2
index|]
argument_list|,
name|attn
operator|.
name|sig
index|[
literal|3
index|]
argument_list|,
name|attn
operator|.
name|sig
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|MAX_DYNAMIC_ATTN_GRPS
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
name|deasserted
operator|&
operator|(
literal|1
operator|<<
name|index
operator|)
condition|)
block|{
name|group_mask
operator|=
operator|&
name|sc
operator|->
name|attn_group
index|[
name|index
index|]
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_INTR
argument_list|,
literal|"group[%d]: 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\n"
argument_list|,
name|index
argument_list|,
name|group_mask
operator|->
name|sig
index|[
literal|0
index|]
argument_list|,
name|group_mask
operator|->
name|sig
index|[
literal|1
index|]
argument_list|,
name|group_mask
operator|->
name|sig
index|[
literal|2
index|]
argument_list|,
name|group_mask
operator|->
name|sig
index|[
literal|3
index|]
argument_list|,
name|group_mask
operator|->
name|sig
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|bxe_attn_int_deasserted4
argument_list|(
name|sc
argument_list|,
name|attn
operator|.
name|sig
index|[
literal|4
index|]
operator|&
name|group_mask
operator|->
name|sig
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|bxe_attn_int_deasserted3
argument_list|(
name|sc
argument_list|,
name|attn
operator|.
name|sig
index|[
literal|3
index|]
operator|&
name|group_mask
operator|->
name|sig
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|bxe_attn_int_deasserted1
argument_list|(
name|sc
argument_list|,
name|attn
operator|.
name|sig
index|[
literal|1
index|]
operator|&
name|group_mask
operator|->
name|sig
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|bxe_attn_int_deasserted2
argument_list|(
name|sc
argument_list|,
name|attn
operator|.
name|sig
index|[
literal|2
index|]
operator|&
name|group_mask
operator|->
name|sig
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|bxe_attn_int_deasserted0
argument_list|(
name|sc
argument_list|,
name|attn
operator|.
name|sig
index|[
literal|0
index|]
operator|&
name|group_mask
operator|->
name|sig
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|bxe_release_alr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|devinfo
operator|.
name|int_block
operator|==
name|INT_BLOCK_HC
condition|)
block|{
name|reg_addr
operator|=
operator|(
name|HC_REG_COMMAND_REG
operator|+
name|port
operator|*
literal|32
operator|+
name|COMMAND_REG_ATTN_BITS_CLR
operator|)
expr_stmt|;
block|}
else|else
block|{
name|reg_addr
operator|=
operator|(
name|BAR_IGU_INTMEM
operator|+
name|IGU_CMD_ATTN_BIT_CLR_UPPER
operator|*
literal|8
operator|)
expr_stmt|;
block|}
name|val
operator|=
operator|~
name|deasserted
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_INTR
argument_list|,
literal|"about to mask 0x%08x at %s addr 0x%08x\n"
argument_list|,
name|val
argument_list|,
operator|(
name|sc
operator|->
name|devinfo
operator|.
name|int_block
operator|==
name|INT_BLOCK_HC
operator|)
condition|?
literal|"HC"
else|:
literal|"IGU"
argument_list|,
name|reg_addr
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|reg_addr
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|~
name|sc
operator|->
name|attn_state
operator|&
name|deasserted
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"IGU error\n"
argument_list|)
expr_stmt|;
block|}
name|reg_addr
operator|=
name|port
condition|?
name|MISC_REG_AEU_MASK_ATTN_FUNC_1
else|:
name|MISC_REG_AEU_MASK_ATTN_FUNC_0
expr_stmt|;
name|bxe_acquire_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_PORT0_ATT_MASK
operator|+
name|port
argument_list|)
expr_stmt|;
name|aeu_mask
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|reg_addr
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_INTR
argument_list|,
literal|"aeu_mask 0x%08x newly deasserted 0x%08x\n"
argument_list|,
name|aeu_mask
argument_list|,
name|deasserted
argument_list|)
expr_stmt|;
name|aeu_mask
operator||=
operator|(
name|deasserted
operator|&
literal|0x3ff
operator|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_INTR
argument_list|,
literal|"new mask 0x%08x\n"
argument_list|,
name|aeu_mask
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|reg_addr
argument_list|,
name|aeu_mask
argument_list|)
expr_stmt|;
name|bxe_release_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_PORT0_ATT_MASK
operator|+
name|port
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_INTR
argument_list|,
literal|"attn_state 0x%08x\n"
argument_list|,
name|sc
operator|->
name|attn_state
argument_list|)
expr_stmt|;
name|sc
operator|->
name|attn_state
operator|&=
operator|~
name|deasserted
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_INTR
argument_list|,
literal|"new state 0x%08x\n"
argument_list|,
name|sc
operator|->
name|attn_state
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_attn_int
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* read local copy of bits */
name|uint32_t
name|attn_bits
init|=
name|le32toh
argument_list|(
name|sc
operator|->
name|def_sb
operator|->
name|atten_status_block
operator|.
name|attn_bits
argument_list|)
decl_stmt|;
name|uint32_t
name|attn_ack
init|=
name|le32toh
argument_list|(
name|sc
operator|->
name|def_sb
operator|->
name|atten_status_block
operator|.
name|attn_bits_ack
argument_list|)
decl_stmt|;
name|uint32_t
name|attn_state
init|=
name|sc
operator|->
name|attn_state
decl_stmt|;
comment|/* look for changed bits */
name|uint32_t
name|asserted
init|=
name|attn_bits
operator|&
operator|~
name|attn_ack
operator|&
operator|~
name|attn_state
decl_stmt|;
name|uint32_t
name|deasserted
init|=
operator|~
name|attn_bits
operator|&
name|attn_ack
operator|&
name|attn_state
decl_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_INTR
argument_list|,
literal|"attn_bits 0x%08x attn_ack 0x%08x asserted 0x%08x deasserted 0x%08x\n"
argument_list|,
name|attn_bits
argument_list|,
name|attn_ack
argument_list|,
name|asserted
argument_list|,
name|deasserted
argument_list|)
expr_stmt|;
if|if
condition|(
operator|~
operator|(
name|attn_bits
operator|^
name|attn_ack
operator|)
operator|&
operator|(
name|attn_bits
operator|^
name|attn_state
operator|)
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"BAD attention state\n"
argument_list|)
expr_stmt|;
block|}
comment|/* handle bits that were raised */
if|if
condition|(
name|asserted
condition|)
block|{
name|bxe_attn_int_asserted
argument_list|(
name|sc
argument_list|,
name|asserted
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|deasserted
condition|)
block|{
name|bxe_attn_int_deasserted
argument_list|(
name|sc
argument_list|,
name|deasserted
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|uint16_t
name|bxe_update_dsb_idx
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|host_sp_status_block
modifier|*
name|def_sb
init|=
name|sc
operator|->
name|def_sb
decl_stmt|;
name|uint16_t
name|rc
init|=
literal|0
decl_stmt|;
name|mb
argument_list|()
expr_stmt|;
comment|/* status block is written to by the chip */
if|if
condition|(
name|sc
operator|->
name|def_att_idx
operator|!=
name|def_sb
operator|->
name|atten_status_block
operator|.
name|attn_bits_index
condition|)
block|{
name|sc
operator|->
name|def_att_idx
operator|=
name|def_sb
operator|->
name|atten_status_block
operator|.
name|attn_bits_index
expr_stmt|;
name|rc
operator||=
name|BXE_DEF_SB_ATT_IDX
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|def_idx
operator|!=
name|def_sb
operator|->
name|sp_sb
operator|.
name|running_index
condition|)
block|{
name|sc
operator|->
name|def_idx
operator|=
name|def_sb
operator|->
name|sp_sb
operator|.
name|running_index
expr_stmt|;
name|rc
operator||=
name|BXE_DEF_SB_IDX
expr_stmt|;
block|}
name|mb
argument_list|()
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|ecore_queue_sp_obj
modifier|*
name|bxe_cid_to_q_obj
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|cid
parameter_list|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_SP
argument_list|,
literal|"retrieving fp from cid %d\n"
argument_list|,
name|cid
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|sc
operator|->
name|sp_objs
index|[
name|CID_TO_FP
argument_list|(
name|cid
argument_list|,
name|sc
argument_list|)
index|]
operator|.
name|q_obj
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_handle_mcast_eqe
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ecore_mcast_ramrod_params
name|rparam
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|memset
argument_list|(
operator|&
name|rparam
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rparam
argument_list|)
argument_list|)
expr_stmt|;
name|rparam
operator|.
name|mcast_obj
operator|=
operator|&
name|sc
operator|->
name|mcast_obj
expr_stmt|;
name|BXE_MCAST_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* clear pending state for the last command */
name|sc
operator|->
name|mcast_obj
operator|.
name|raw
operator|.
name|clear_pending
argument_list|(
operator|&
name|sc
operator|->
name|mcast_obj
operator|.
name|raw
argument_list|)
expr_stmt|;
comment|/* if there are pending mcast commands - send them */
if|if
condition|(
name|sc
operator|->
name|mcast_obj
operator|.
name|check_pending
argument_list|(
operator|&
name|sc
operator|->
name|mcast_obj
argument_list|)
condition|)
block|{
name|rc
operator|=
name|ecore_config_mcast
argument_list|(
name|sc
argument_list|,
operator|&
name|rparam
argument_list|,
name|ECORE_MCAST_CMD_CONT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_SP
argument_list|,
literal|"ERROR: Failed to send pending mcast commands (%d)\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
block|}
name|BXE_MCAST_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_handle_classification_eqe
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|union
name|event_ring_elem
modifier|*
name|elem
parameter_list|)
block|{
name|unsigned
name|long
name|ramrod_flags
init|=
literal|0
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|uint32_t
name|cid
init|=
name|elem
operator|->
name|message
operator|.
name|data
operator|.
name|eth_event
operator|.
name|echo
operator|&
name|BXE_SWCID_MASK
decl_stmt|;
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|vlan_mac_obj
decl_stmt|;
comment|/* always push next commands out, don't wait here */
name|bit_set
argument_list|(
operator|&
name|ramrod_flags
argument_list|,
name|RAMROD_CONT
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|le32toh
argument_list|(
name|elem
operator|->
name|message
operator|.
name|data
operator|.
name|eth_event
operator|.
name|echo
argument_list|)
operator|>>
name|BXE_SWCID_SHIFT
condition|)
block|{
case|case
name|ECORE_FILTER_MAC_PENDING
case|:
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_SP
argument_list|,
literal|"Got SETUP_MAC completions\n"
argument_list|)
expr_stmt|;
name|vlan_mac_obj
operator|=
operator|&
name|sc
operator|->
name|sp_objs
index|[
name|cid
index|]
operator|.
name|mac_obj
expr_stmt|;
break|break;
case|case
name|ECORE_FILTER_MCAST_PENDING
case|:
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_SP
argument_list|,
literal|"Got SETUP_MCAST completions\n"
argument_list|)
expr_stmt|;
comment|/*          * This is only relevant for 57710 where multicast MACs are          * configured as unicast MACs using the same ramrod.          */
name|bxe_handle_mcast_eqe
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
default|default:
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Unsupported classification command: %d\n"
argument_list|,
name|elem
operator|->
name|message
operator|.
name|data
operator|.
name|eth_event
operator|.
name|echo
argument_list|)
expr_stmt|;
return|return;
block|}
name|rc
operator|=
name|vlan_mac_obj
operator|->
name|complete
argument_list|(
name|sc
argument_list|,
name|vlan_mac_obj
argument_list|,
name|elem
argument_list|,
operator|&
name|ramrod_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to schedule new commands (%d)\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rc
operator|>
literal|0
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_SP
argument_list|,
literal|"Scheduled next pending commands...\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_handle_rx_mode_eqe
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|union
name|event_ring_elem
modifier|*
name|elem
parameter_list|)
block|{
name|bxe_clear_bit
argument_list|(
name|ECORE_FILTER_RX_MODE_PENDING
argument_list|,
operator|&
name|sc
operator|->
name|sp_state
argument_list|)
expr_stmt|;
comment|/* send rx_mode command again if was requested */
if|if
condition|(
name|bxe_test_and_clear_bit
argument_list|(
name|ECORE_FILTER_RX_MODE_SCHED
argument_list|,
operator|&
name|sc
operator|->
name|sp_state
argument_list|)
condition|)
block|{
name|bxe_set_storm_rx_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_update_eq_prod
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|prod
parameter_list|)
block|{
name|storm_memset_eq_prod
argument_list|(
name|sc
argument_list|,
name|prod
argument_list|,
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
comment|/* keep prod updates ordered */
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_eq_int
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint16_t
name|hw_cons
decl_stmt|,
name|sw_cons
decl_stmt|,
name|sw_prod
decl_stmt|;
name|union
name|event_ring_elem
modifier|*
name|elem
decl_stmt|;
name|uint8_t
name|echo
decl_stmt|;
name|uint32_t
name|cid
decl_stmt|;
name|uint8_t
name|opcode
decl_stmt|;
name|int
name|spqe_cnt
init|=
literal|0
decl_stmt|;
name|struct
name|ecore_queue_sp_obj
modifier|*
name|q_obj
decl_stmt|;
name|struct
name|ecore_func_sp_obj
modifier|*
name|f_obj
init|=
operator|&
name|sc
operator|->
name|func_obj
decl_stmt|;
name|struct
name|ecore_raw_obj
modifier|*
name|rss_raw
init|=
operator|&
name|sc
operator|->
name|rss_conf_obj
operator|.
name|raw
decl_stmt|;
name|hw_cons
operator|=
name|le16toh
argument_list|(
operator|*
name|sc
operator|->
name|eq_cons_sb
argument_list|)
expr_stmt|;
comment|/*      * The hw_cons range is 1-255, 257 - the sw_cons range is 0-254, 256.      * when we get to the next-page we need to adjust so the loop      * condition below will be met. The next element is the size of a      * regular element and hence incrementing by 1      */
if|if
condition|(
operator|(
name|hw_cons
operator|&
name|EQ_DESC_MAX_PAGE
operator|)
operator|==
name|EQ_DESC_MAX_PAGE
condition|)
block|{
name|hw_cons
operator|++
expr_stmt|;
block|}
comment|/*      * This function may never run in parallel with itself for a      * specific sc and no need for a read memory barrier here.      */
name|sw_cons
operator|=
name|sc
operator|->
name|eq_cons
expr_stmt|;
name|sw_prod
operator|=
name|sc
operator|->
name|eq_prod
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_SP
argument_list|,
literal|"EQ: hw_cons=%u sw_cons=%u eq_spq_left=0x%lx\n"
argument_list|,
name|hw_cons
argument_list|,
name|sw_cons
argument_list|,
name|atomic_load_acq_long
argument_list|(
operator|&
name|sc
operator|->
name|eq_spq_left
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|sw_cons
operator|!=
name|hw_cons
condition|;
name|sw_prod
operator|=
name|NEXT_EQ_IDX
argument_list|(
name|sw_prod
argument_list|)
operator|,
name|sw_cons
operator|=
name|NEXT_EQ_IDX
argument_list|(
name|sw_cons
argument_list|)
control|)
block|{
name|elem
operator|=
operator|&
name|sc
operator|->
name|eq
index|[
name|EQ_DESC
argument_list|(
name|sw_cons
argument_list|)
index|]
expr_stmt|;
comment|/* elem CID originates from FW, actually LE */
name|cid
operator|=
name|SW_CID
argument_list|(
name|elem
operator|->
name|message
operator|.
name|data
operator|.
name|cfc_del_event
operator|.
name|cid
argument_list|)
expr_stmt|;
name|opcode
operator|=
name|elem
operator|->
name|message
operator|.
name|opcode
expr_stmt|;
comment|/* handle eq element */
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|EVENT_RING_OPCODE_STAT_QUERY
case|:
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_SP
argument_list|,
literal|"got statistics completion event %d\n"
argument_list|,
name|sc
operator|->
name|stats_comp
operator|++
argument_list|)
expr_stmt|;
comment|/* nothing to do with stats comp */
goto|goto
name|next_spqe
goto|;
case|case
name|EVENT_RING_OPCODE_CFC_DEL
case|:
comment|/* handle according to cid range */
comment|/* we may want to verify here that the sc state is HALTING */
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_SP
argument_list|,
literal|"got delete ramrod for MULTI[%d]\n"
argument_list|,
name|cid
argument_list|)
expr_stmt|;
name|q_obj
operator|=
name|bxe_cid_to_q_obj
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|)
expr_stmt|;
if|if
condition|(
name|q_obj
operator|->
name|complete_cmd
argument_list|(
name|sc
argument_list|,
name|q_obj
argument_list|,
name|ECORE_Q_CMD_CFC_DEL
argument_list|)
condition|)
block|{
break|break;
block|}
goto|goto
name|next_spqe
goto|;
case|case
name|EVENT_RING_OPCODE_STOP_TRAFFIC
case|:
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_SP
argument_list|,
literal|"got STOP TRAFFIC\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f_obj
operator|->
name|complete_cmd
argument_list|(
name|sc
argument_list|,
name|f_obj
argument_list|,
name|ECORE_F_CMD_TX_STOP
argument_list|)
condition|)
block|{
break|break;
block|}
comment|// XXX bxe_dcbx_set_params(sc, BXE_DCBX_STATE_TX_PAUSED);
goto|goto
name|next_spqe
goto|;
case|case
name|EVENT_RING_OPCODE_START_TRAFFIC
case|:
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_SP
argument_list|,
literal|"got START TRAFFIC\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f_obj
operator|->
name|complete_cmd
argument_list|(
name|sc
argument_list|,
name|f_obj
argument_list|,
name|ECORE_F_CMD_TX_START
argument_list|)
condition|)
block|{
break|break;
block|}
comment|// XXX bxe_dcbx_set_params(sc, BXE_DCBX_STATE_TX_RELEASED);
goto|goto
name|next_spqe
goto|;
case|case
name|EVENT_RING_OPCODE_FUNCTION_UPDATE
case|:
name|echo
operator|=
name|elem
operator|->
name|message
operator|.
name|data
operator|.
name|function_update_event
operator|.
name|echo
expr_stmt|;
if|if
condition|(
name|echo
operator|==
name|SWITCH_UPDATE
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_SP
argument_list|,
literal|"got FUNC_SWITCH_UPDATE ramrod\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f_obj
operator|->
name|complete_cmd
argument_list|(
name|sc
argument_list|,
name|f_obj
argument_list|,
name|ECORE_F_CMD_SWITCH_UPDATE
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
else|else
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_SP
argument_list|,
literal|"AFEX: ramrod completed FUNCTION_UPDATE\n"
argument_list|)
expr_stmt|;
block|}
goto|goto
name|next_spqe
goto|;
case|case
name|EVENT_RING_OPCODE_FORWARD_SETUP
case|:
name|q_obj
operator|=
operator|&
name|bxe_fwd_sp_obj
argument_list|(
name|sc
argument_list|,
name|q_obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|q_obj
operator|->
name|complete_cmd
argument_list|(
name|sc
argument_list|,
name|q_obj
argument_list|,
name|ECORE_Q_CMD_SETUP_TX_ONLY
argument_list|)
condition|)
block|{
break|break;
block|}
goto|goto
name|next_spqe
goto|;
case|case
name|EVENT_RING_OPCODE_FUNCTION_START
case|:
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_SP
argument_list|,
literal|"got FUNC_START ramrod\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f_obj
operator|->
name|complete_cmd
argument_list|(
name|sc
argument_list|,
name|f_obj
argument_list|,
name|ECORE_F_CMD_START
argument_list|)
condition|)
block|{
break|break;
block|}
goto|goto
name|next_spqe
goto|;
case|case
name|EVENT_RING_OPCODE_FUNCTION_STOP
case|:
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_SP
argument_list|,
literal|"got FUNC_STOP ramrod\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f_obj
operator|->
name|complete_cmd
argument_list|(
name|sc
argument_list|,
name|f_obj
argument_list|,
name|ECORE_F_CMD_STOP
argument_list|)
condition|)
block|{
break|break;
block|}
goto|goto
name|next_spqe
goto|;
block|}
switch|switch
condition|(
name|opcode
operator||
name|sc
operator|->
name|state
condition|)
block|{
case|case
operator|(
name|EVENT_RING_OPCODE_RSS_UPDATE_RULES
operator||
name|BXE_STATE_OPEN
operator|)
case|:
case|case
operator|(
name|EVENT_RING_OPCODE_RSS_UPDATE_RULES
operator||
name|BXE_STATE_OPENING_WAITING_PORT
operator|)
case|:
name|cid
operator|=
name|elem
operator|->
name|message
operator|.
name|data
operator|.
name|eth_event
operator|.
name|echo
operator|&
name|BXE_SWCID_MASK
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_SP
argument_list|,
literal|"got RSS_UPDATE ramrod. CID %d\n"
argument_list|,
name|cid
argument_list|)
expr_stmt|;
name|rss_raw
operator|->
name|clear_pending
argument_list|(
name|rss_raw
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|EVENT_RING_OPCODE_SET_MAC
operator||
name|BXE_STATE_OPEN
operator|)
case|:
case|case
operator|(
name|EVENT_RING_OPCODE_SET_MAC
operator||
name|BXE_STATE_DIAG
operator|)
case|:
case|case
operator|(
name|EVENT_RING_OPCODE_SET_MAC
operator||
name|BXE_STATE_CLOSING_WAITING_HALT
operator|)
case|:
case|case
operator|(
name|EVENT_RING_OPCODE_CLASSIFICATION_RULES
operator||
name|BXE_STATE_OPEN
operator|)
case|:
case|case
operator|(
name|EVENT_RING_OPCODE_CLASSIFICATION_RULES
operator||
name|BXE_STATE_DIAG
operator|)
case|:
case|case
operator|(
name|EVENT_RING_OPCODE_CLASSIFICATION_RULES
operator||
name|BXE_STATE_CLOSING_WAITING_HALT
operator|)
case|:
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_SP
argument_list|,
literal|"got (un)set mac ramrod\n"
argument_list|)
expr_stmt|;
name|bxe_handle_classification_eqe
argument_list|(
name|sc
argument_list|,
name|elem
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|EVENT_RING_OPCODE_MULTICAST_RULES
operator||
name|BXE_STATE_OPEN
operator|)
case|:
case|case
operator|(
name|EVENT_RING_OPCODE_MULTICAST_RULES
operator||
name|BXE_STATE_DIAG
operator|)
case|:
case|case
operator|(
name|EVENT_RING_OPCODE_MULTICAST_RULES
operator||
name|BXE_STATE_CLOSING_WAITING_HALT
operator|)
case|:
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_SP
argument_list|,
literal|"got mcast ramrod\n"
argument_list|)
expr_stmt|;
name|bxe_handle_mcast_eqe
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|EVENT_RING_OPCODE_FILTERS_RULES
operator||
name|BXE_STATE_OPEN
operator|)
case|:
case|case
operator|(
name|EVENT_RING_OPCODE_FILTERS_RULES
operator||
name|BXE_STATE_DIAG
operator|)
case|:
case|case
operator|(
name|EVENT_RING_OPCODE_FILTERS_RULES
operator||
name|BXE_STATE_CLOSING_WAITING_HALT
operator|)
case|:
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_SP
argument_list|,
literal|"got rx_mode ramrod\n"
argument_list|)
expr_stmt|;
name|bxe_handle_rx_mode_eqe
argument_list|(
name|sc
argument_list|,
name|elem
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* unknown event log error and continue */
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Unknown EQ event %d, sc->state 0x%x\n"
argument_list|,
name|elem
operator|->
name|message
operator|.
name|opcode
argument_list|,
name|sc
operator|->
name|state
argument_list|)
expr_stmt|;
block|}
name|next_spqe
label|:
name|spqe_cnt
operator|++
expr_stmt|;
block|}
comment|/* for */
name|mb
argument_list|()
expr_stmt|;
name|atomic_add_acq_long
argument_list|(
operator|&
name|sc
operator|->
name|eq_spq_left
argument_list|,
name|spqe_cnt
argument_list|)
expr_stmt|;
name|sc
operator|->
name|eq_cons
operator|=
name|sw_cons
expr_stmt|;
name|sc
operator|->
name|eq_prod
operator|=
name|sw_prod
expr_stmt|;
comment|/* make sure that above mem writes were issued towards the memory */
name|wmb
argument_list|()
expr_stmt|;
comment|/* update producer */
name|bxe_update_eq_prod
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|eq_prod
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_handle_sp_tq
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|bxe_softc
operator|*
operator|)
name|context
decl_stmt|;
name|uint16_t
name|status
decl_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_SP
argument_list|,
literal|"---> SP TASK<---\n"
argument_list|)
expr_stmt|;
comment|/* what work needs to be performed? */
name|status
operator|=
name|bxe_update_dsb_idx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_SP
argument_list|,
literal|"dsb status 0x%04x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* HW attentions */
if|if
condition|(
name|status
operator|&
name|BXE_DEF_SB_ATT_IDX
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_SP
argument_list|,
literal|"---> ATTN INTR<---\n"
argument_list|)
expr_stmt|;
name|bxe_attn_int
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|status
operator|&=
operator|~
name|BXE_DEF_SB_ATT_IDX
expr_stmt|;
block|}
comment|/* SP events: STAT_QUERY and others */
if|if
condition|(
name|status
operator|&
name|BXE_DEF_SB_IDX
condition|)
block|{
comment|/* handle EQ completions */
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_SP
argument_list|,
literal|"---> EQ INTR<---\n"
argument_list|)
expr_stmt|;
name|bxe_eq_int
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_ack_sb
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|igu_dsb_id
argument_list|,
name|USTORM_ID
argument_list|,
name|le16toh
argument_list|(
name|sc
operator|->
name|def_idx
argument_list|)
argument_list|,
name|IGU_INT_NOP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|status
operator|&=
operator|~
name|BXE_DEF_SB_IDX
expr_stmt|;
block|}
comment|/* if status is non zero then something went wrong */
if|if
condition|(
name|__predict_false
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Got an unknown SP interrupt! (0x%04x)\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
comment|/* ack status block only if something was actually handled */
name|bxe_ack_sb
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|igu_dsb_id
argument_list|,
name|ATTENTION_ID
argument_list|,
name|le16toh
argument_list|(
name|sc
operator|->
name|def_att_idx
argument_list|)
argument_list|,
name|IGU_INT_ENABLE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*      * Must be called after the EQ processing (since eq leads to sriov      * ramrod completion flows).      * This flow may have been scheduled by the arrival of a ramrod      * completion, or by the sriov code rescheduling itself.      */
comment|// XXX bxe_iov_sp_task(sc);
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_handle_fp_tq
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|bxe_fastpath
modifier|*
name|fp
init|=
operator|(
expr|struct
name|bxe_fastpath
operator|*
operator|)
name|context
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|fp
operator|->
name|sc
decl_stmt|;
name|uint8_t
name|more_tx
init|=
name|FALSE
decl_stmt|;
name|uint8_t
name|more_rx
init|=
name|FALSE
decl_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_INTR
argument_list|,
literal|"---> FP TASK QUEUE (%d)<---\n"
argument_list|,
name|fp
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* XXX      * IFF_DRV_RUNNING state can't be checked here since we process      * slowpath events on a client queue during setup. Instead      * we need to add a "process/continue" flag here that the driver      * can use to tell the task here not to do anything.      */
if|#
directive|if
literal|0
block|if (!(if_getdrvflags(sc->ifp)& IFF_DRV_RUNNING)) {         return;     }
endif|#
directive|endif
comment|/* update the fastpath index */
name|bxe_update_fp_sb_idx
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* XXX add loop here if ever support multiple tx CoS */
comment|/* fp->txdata[cos] */
if|if
condition|(
name|bxe_has_tx_work
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|BXE_FP_TX_LOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|more_tx
operator|=
name|bxe_txeof
argument_list|(
name|sc
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|BXE_FP_TX_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bxe_has_rx_work
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|more_rx
operator|=
name|bxe_rxeof
argument_list|(
name|sc
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|more_rx
comment|/*|| more_tx*/
condition|)
block|{
comment|/* still more work to do */
name|taskqueue_enqueue
argument_list|(
name|fp
operator|->
name|tq
argument_list|,
operator|&
name|fp
operator|->
name|tq_task
argument_list|)
expr_stmt|;
return|return;
block|}
name|bxe_ack_sb
argument_list|(
name|sc
argument_list|,
name|fp
operator|->
name|igu_sb_id
argument_list|,
name|USTORM_ID
argument_list|,
name|le16toh
argument_list|(
name|fp
operator|->
name|fp_hc_idx
argument_list|)
argument_list|,
name|IGU_INT_ENABLE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_task_fp
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|fp
operator|->
name|sc
decl_stmt|;
name|uint8_t
name|more_tx
init|=
name|FALSE
decl_stmt|;
name|uint8_t
name|more_rx
init|=
name|FALSE
decl_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_INTR
argument_list|,
literal|"---> FP TASK ISR (%d)<---\n"
argument_list|,
name|fp
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* update the fastpath index */
name|bxe_update_fp_sb_idx
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* XXX add loop here if ever support multiple tx CoS */
comment|/* fp->txdata[cos] */
if|if
condition|(
name|bxe_has_tx_work
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|BXE_FP_TX_LOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|more_tx
operator|=
name|bxe_txeof
argument_list|(
name|sc
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|BXE_FP_TX_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bxe_has_rx_work
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|more_rx
operator|=
name|bxe_rxeof
argument_list|(
name|sc
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|more_rx
comment|/*|| more_tx*/
condition|)
block|{
comment|/* still more work to do, bail out if this ISR and process later */
name|taskqueue_enqueue
argument_list|(
name|fp
operator|->
name|tq
argument_list|,
operator|&
name|fp
operator|->
name|tq_task
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * Here we write the fastpath index taken before doing any tx or rx work.      * It is very well possible other hw events occurred up to this point and      * they were actually processed accordingly above. Since we're going to      * write an older fastpath index, an interrupt is coming which we might      * not do any work in.      */
name|bxe_ack_sb
argument_list|(
name|sc
argument_list|,
name|fp
operator|->
name|igu_sb_id
argument_list|,
name|USTORM_ID
argument_list|,
name|le16toh
argument_list|(
name|fp
operator|->
name|fp_hc_idx
argument_list|)
argument_list|,
name|IGU_INT_ENABLE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Legacy interrupt entry point.  *  * Verifies that the controller generated the interrupt and  * then calls a separate routine to handle the various  * interrupt causes: link, RX, and TX.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_intr_legacy
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|bxe_softc
operator|*
operator|)
name|xsc
decl_stmt|;
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|uint16_t
name|status
decl_stmt|,
name|mask
decl_stmt|;
name|int
name|i
decl_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_INTR
argument_list|,
literal|"---> BXE INTx<---\n"
argument_list|)
expr_stmt|;
comment|/*      * 0 for ustorm, 1 for cstorm      * the bits returned from ack_int() are 0-15      * bit 0 = attention status block      * bit 1 = fast path status block      * a mask of 0x2 or more = tx/rx event      * a mask of 1 = slow path event      */
name|status
operator|=
name|bxe_ack_int
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* the interrupt is not for us */
if|if
condition|(
name|__predict_false
argument_list|(
name|status
operator|==
literal|0
argument_list|)
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_INTR
argument_list|,
literal|"Not our interrupt!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_INTR
argument_list|,
literal|"Interrupt status 0x%04x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|FOR_EACH_ETH_QUEUE
argument_list|(
argument|sc
argument_list|,
argument|i
argument_list|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
expr_stmt|;
name|mask
operator|=
operator|(
literal|0x2
operator|<<
operator|(
name|fp
operator|->
name|index
operator|+
name|CNIC_SUPPORT
argument_list|(
name|sc
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|mask
condition|)
block|{
comment|/* acknowledge and disable further fastpath interrupts */
name|bxe_ack_sb
argument_list|(
name|sc
argument_list|,
name|fp
operator|->
name|igu_sb_id
argument_list|,
name|USTORM_ID
argument_list|,
literal|0
argument_list|,
name|IGU_INT_DISABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bxe_task_fp
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|status
operator|&=
operator|~
name|mask
expr_stmt|;
block|}
block|}
if|if
condition|(
name|__predict_false
argument_list|(
name|status
operator|&
literal|0x1
argument_list|)
condition|)
block|{
comment|/* acknowledge and disable further slowpath interrupts */
name|bxe_ack_sb
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|igu_dsb_id
argument_list|,
name|USTORM_ID
argument_list|,
literal|0
argument_list|,
name|IGU_INT_DISABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* schedule slowpath handler */
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sp_tq
argument_list|,
operator|&
name|sc
operator|->
name|sp_tq_task
argument_list|)
expr_stmt|;
name|status
operator|&=
operator|~
literal|0x1
expr_stmt|;
block|}
if|if
condition|(
name|__predict_false
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|BLOGW
argument_list|(
name|sc
argument_list|,
literal|"Unexpected fastpath status (0x%08x)!\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* slowpath interrupt entry point */
end_comment

begin_function
specifier|static
name|void
name|bxe_intr_sp
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|bxe_softc
operator|*
operator|)
name|xsc
decl_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
operator|(
name|DBG_INTR
operator||
name|DBG_SP
operator|)
argument_list|,
literal|"---> SP INTR<---\n"
argument_list|)
expr_stmt|;
comment|/* acknowledge and disable further slowpath interrupts */
name|bxe_ack_sb
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|igu_dsb_id
argument_list|,
name|USTORM_ID
argument_list|,
literal|0
argument_list|,
name|IGU_INT_DISABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* schedule slowpath handler */
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sp_tq
argument_list|,
operator|&
name|sc
operator|->
name|sp_tq_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* fastpath interrupt entry point */
end_comment

begin_function
specifier|static
name|void
name|bxe_intr_fp
parameter_list|(
name|void
modifier|*
name|xfp
parameter_list|)
block|{
name|struct
name|bxe_fastpath
modifier|*
name|fp
init|=
operator|(
expr|struct
name|bxe_fastpath
operator|*
operator|)
name|xfp
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|fp
operator|->
name|sc
decl_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_INTR
argument_list|,
literal|"---> FP INTR %d<---\n"
argument_list|,
name|fp
operator|->
name|index
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_INTR
argument_list|,
literal|"(cpu=%d) MSI-X fp=%d fw_sb=%d igu_sb=%d\n"
argument_list|,
name|curcpu
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|fp
operator|->
name|fw_sb_id
argument_list|,
name|fp
operator|->
name|igu_sb_id
argument_list|)
expr_stmt|;
comment|/* acknowledge and disable further fastpath interrupts */
name|bxe_ack_sb
argument_list|(
name|sc
argument_list|,
name|fp
operator|->
name|igu_sb_id
argument_list|,
name|USTORM_ID
argument_list|,
literal|0
argument_list|,
name|IGU_INT_DISABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bxe_task_fp
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Release all interrupts allocated by the driver. */
end_comment

begin_function
specifier|static
name|void
name|bxe_interrupt_free
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|interrupt_mode
condition|)
block|{
case|case
name|INTR_MODE_INTX
case|:
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Releasing legacy INTx vector\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|intr
index|[
literal|0
index|]
operator|.
name|resource
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|intr
index|[
literal|0
index|]
operator|.
name|rid
argument_list|,
name|sc
operator|->
name|intr
index|[
literal|0
index|]
operator|.
name|resource
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|INTR_MODE_MSI
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|intr_count
condition|;
name|i
operator|++
control|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Releasing MSI vector %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|intr
index|[
name|i
index|]
operator|.
name|resource
operator|&&
name|sc
operator|->
name|intr
index|[
name|i
index|]
operator|.
name|rid
condition|)
block|{
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|intr
index|[
name|i
index|]
operator|.
name|rid
argument_list|,
name|sc
operator|->
name|intr
index|[
name|i
index|]
operator|.
name|resource
argument_list|)
expr_stmt|;
block|}
block|}
name|pci_release_msi
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTR_MODE_MSIX
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|intr_count
condition|;
name|i
operator|++
control|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Releasing MSI-X vector %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|intr
index|[
name|i
index|]
operator|.
name|resource
operator|&&
name|sc
operator|->
name|intr
index|[
name|i
index|]
operator|.
name|rid
condition|)
block|{
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|intr
index|[
name|i
index|]
operator|.
name|rid
argument_list|,
name|sc
operator|->
name|intr
index|[
name|i
index|]
operator|.
name|resource
argument_list|)
expr_stmt|;
block|}
block|}
name|pci_release_msi
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* nothing to do as initial allocation failed */
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * This function determines and allocates the appropriate  * interrupt based on system capabilites and user request.  *  * The user may force a particular interrupt mode, specify  * the number of receive queues, specify the method for  * distribuitng received frames to receive queues, or use  * the default settings which will automatically select the  * best supported combination.  In addition, the OS may or  * may not support certain combinations of these settings.  * This routine attempts to reconcile the settings requested  * by the user with the capabilites available from the system  * to select the optimal combination of features.  *  * Returns:  *   0 = Success, !0 = Failure.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_interrupt_alloc
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|msix_count
init|=
literal|0
decl_stmt|;
name|int
name|msi_count
init|=
literal|0
decl_stmt|;
name|int
name|num_requested
init|=
literal|0
decl_stmt|;
name|int
name|num_allocated
init|=
literal|0
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* get the number of available MSI/MSI-X interrupts from the OS */
if|if
condition|(
name|sc
operator|->
name|interrupt_mode
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|devinfo
operator|.
name|pcie_cap_flags
operator|&
name|BXE_MSIX_CAPABLE_FLAG
condition|)
block|{
name|msix_count
operator|=
name|pci_msix_count
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|devinfo
operator|.
name|pcie_cap_flags
operator|&
name|BXE_MSI_CAPABLE_FLAG
condition|)
block|{
name|msi_count
operator|=
name|pci_msi_count
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"%d MSI and %d MSI-X vectors available\n"
argument_list|,
name|msi_count
argument_list|,
name|msix_count
argument_list|)
expr_stmt|;
block|}
do|do
block|{
comment|/* try allocating MSI-X interrupt resources (at least 2) */
if|if
condition|(
name|sc
operator|->
name|interrupt_mode
operator|!=
name|INTR_MODE_MSIX
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|(
operator|(
name|sc
operator|->
name|devinfo
operator|.
name|pcie_cap_flags
operator|&
name|BXE_MSIX_CAPABLE_FLAG
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|msix_count
operator|<
literal|2
operator|)
condition|)
block|{
name|sc
operator|->
name|interrupt_mode
operator|=
name|INTR_MODE_MSI
expr_stmt|;
comment|/* try MSI next */
break|break;
block|}
comment|/* ask for the necessary number of MSI-X vectors */
name|num_requested
operator|=
name|min
argument_list|(
operator|(
name|sc
operator|->
name|num_queues
operator|+
literal|1
operator|)
argument_list|,
name|msix_count
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Requesting %d MSI-X vectors\n"
argument_list|,
name|num_requested
argument_list|)
expr_stmt|;
name|num_allocated
operator|=
name|num_requested
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|pci_alloc_msix
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
operator|&
name|num_allocated
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"MSI-X alloc failed! (%d)\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|interrupt_mode
operator|=
name|INTR_MODE_MSI
expr_stmt|;
comment|/* try MSI next */
break|break;
block|}
if|if
condition|(
name|num_allocated
operator|<
literal|2
condition|)
block|{
comment|/* possible? */
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"MSI-X allocation less than 2!\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|interrupt_mode
operator|=
name|INTR_MODE_MSI
expr_stmt|;
comment|/* try MSI next */
name|pci_release_msi
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
break|break;
block|}
name|BLOGI
argument_list|(
name|sc
argument_list|,
literal|"MSI-X vectors Requested %d and Allocated %d\n"
argument_list|,
name|num_requested
argument_list|,
name|num_allocated
argument_list|)
expr_stmt|;
comment|/* best effort so use the number of vectors allocated to us */
name|sc
operator|->
name|intr_count
operator|=
name|num_allocated
expr_stmt|;
name|sc
operator|->
name|num_queues
operator|=
name|num_allocated
operator|-
literal|1
expr_stmt|;
name|rid
operator|=
literal|1
expr_stmt|;
comment|/* initial resource identifier */
comment|/* allocate the MSI-X vectors */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_allocated
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|intr
index|[
name|i
index|]
operator|.
name|rid
operator|=
operator|(
name|rid
operator|+
name|i
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|intr
index|[
name|i
index|]
operator|.
name|resource
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|intr
index|[
name|i
index|]
operator|.
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to map MSI-X[%d] (rid=%d)!\n"
argument_list|,
name|i
argument_list|,
operator|(
name|rid
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
operator|(
name|i
operator|-
literal|1
operator|)
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|intr
index|[
name|j
index|]
operator|.
name|rid
argument_list|,
name|sc
operator|->
name|intr
index|[
name|j
index|]
operator|.
name|resource
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|intr_count
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|num_queues
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|interrupt_mode
operator|=
name|INTR_MODE_MSI
expr_stmt|;
comment|/* try MSI next */
name|pci_release_msi
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
break|break;
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Mapped MSI-X[%d] (rid=%d)\n"
argument_list|,
name|i
argument_list|,
operator|(
name|rid
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
literal|0
condition|)
do|;
do|do
block|{
comment|/* try allocating MSI vector resources (at least 2) */
if|if
condition|(
name|sc
operator|->
name|interrupt_mode
operator|!=
name|INTR_MODE_MSI
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|(
operator|(
name|sc
operator|->
name|devinfo
operator|.
name|pcie_cap_flags
operator|&
name|BXE_MSI_CAPABLE_FLAG
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|msi_count
operator|<
literal|1
operator|)
condition|)
block|{
name|sc
operator|->
name|interrupt_mode
operator|=
name|INTR_MODE_INTX
expr_stmt|;
comment|/* try INTx next */
break|break;
block|}
comment|/* ask for a single MSI vector */
name|num_requested
operator|=
literal|1
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Requesting %d MSI vectors\n"
argument_list|,
name|num_requested
argument_list|)
expr_stmt|;
name|num_allocated
operator|=
name|num_requested
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|pci_alloc_msi
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
operator|&
name|num_allocated
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"MSI alloc failed (%d)!\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|interrupt_mode
operator|=
name|INTR_MODE_INTX
expr_stmt|;
comment|/* try INTx next */
break|break;
block|}
if|if
condition|(
name|num_allocated
operator|!=
literal|1
condition|)
block|{
comment|/* possible? */
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"MSI allocation is not 1!\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|interrupt_mode
operator|=
name|INTR_MODE_INTX
expr_stmt|;
comment|/* try INTx next */
name|pci_release_msi
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
break|break;
block|}
name|BLOGI
argument_list|(
name|sc
argument_list|,
literal|"MSI vectors Requested %d and Allocated %d\n"
argument_list|,
name|num_requested
argument_list|,
name|num_allocated
argument_list|)
expr_stmt|;
comment|/* best effort so use the number of vectors allocated to us */
name|sc
operator|->
name|intr_count
operator|=
name|num_allocated
expr_stmt|;
name|sc
operator|->
name|num_queues
operator|=
name|num_allocated
expr_stmt|;
name|rid
operator|=
literal|1
expr_stmt|;
comment|/* initial resource identifier */
name|sc
operator|->
name|intr
index|[
literal|0
index|]
operator|.
name|rid
operator|=
name|rid
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|intr
index|[
literal|0
index|]
operator|.
name|resource
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|intr
index|[
literal|0
index|]
operator|.
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to map MSI[0] (rid=%d)!\n"
argument_list|,
name|rid
argument_list|)
expr_stmt|;
name|sc
operator|->
name|intr_count
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|num_queues
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|interrupt_mode
operator|=
name|INTR_MODE_INTX
expr_stmt|;
comment|/* try INTx next */
name|pci_release_msi
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
break|break;
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Mapped MSI[0] (rid=%d)\n"
argument_list|,
name|rid
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
do|do
block|{
comment|/* try allocating INTx vector resources */
if|if
condition|(
name|sc
operator|->
name|interrupt_mode
operator|!=
name|INTR_MODE_INTX
condition|)
block|{
break|break;
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Requesting legacy INTx interrupt\n"
argument_list|)
expr_stmt|;
comment|/* only one vector for INTx */
name|sc
operator|->
name|intr_count
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|num_queues
operator|=
literal|1
expr_stmt|;
name|rid
operator|=
literal|0
expr_stmt|;
comment|/* initial resource identifier */
name|sc
operator|->
name|intr
index|[
literal|0
index|]
operator|.
name|rid
operator|=
name|rid
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|intr
index|[
literal|0
index|]
operator|.
name|resource
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|intr
index|[
literal|0
index|]
operator|.
name|rid
argument_list|,
operator|(
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
operator|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to map INTx (rid=%d)!\n"
argument_list|,
name|rid
argument_list|)
expr_stmt|;
name|sc
operator|->
name|intr_count
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|num_queues
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|interrupt_mode
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Failed! */
break|break;
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Mapped INTx (rid=%d)\n"
argument_list|,
name|rid
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
if|if
condition|(
name|sc
operator|->
name|interrupt_mode
operator|==
operator|-
literal|1
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Interrupt Allocation: FAILED!!!\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Interrupt Allocation: interrupt_mode=%d, num_queues=%d\n"
argument_list|,
name|sc
operator|->
name|interrupt_mode
argument_list|,
name|sc
operator|->
name|num_queues
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_interrupt_detach
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* release interrupt resources */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|intr_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|intr
index|[
name|i
index|]
operator|.
name|resource
operator|&&
name|sc
operator|->
name|intr
index|[
name|i
index|]
operator|.
name|tag
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Disabling interrupt vector %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|intr
index|[
name|i
index|]
operator|.
name|resource
argument_list|,
name|sc
operator|->
name|intr
index|[
name|i
index|]
operator|.
name|tag
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|tq
condition|)
block|{
name|taskqueue_drain
argument_list|(
name|fp
operator|->
name|tq
argument_list|,
operator|&
name|fp
operator|->
name|tq_task
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|fp
operator|->
name|tq
argument_list|,
operator|&
name|fp
operator|->
name|tx_task
argument_list|)
expr_stmt|;
while|while
condition|(
name|taskqueue_cancel_timeout
argument_list|(
name|fp
operator|->
name|tq
argument_list|,
operator|&
name|fp
operator|->
name|tx_timeout_task
argument_list|,
name|NULL
argument_list|)
condition|)
name|taskqueue_drain_timeout
argument_list|(
name|fp
operator|->
name|tq
argument_list|,
operator|&
name|fp
operator|->
name|tx_timeout_task
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|fp
operator|->
name|tq
argument_list|)
expr_stmt|;
name|fp
operator|->
name|tq
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|sp_tq
condition|)
block|{
name|taskqueue_drain
argument_list|(
name|sc
operator|->
name|sp_tq
argument_list|,
operator|&
name|sc
operator|->
name|sp_tq_task
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|sc
operator|->
name|sp_tq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sp_tq
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Enables interrupts and attach to the ISR.  *  * When using multiple MSI/MSI-X vectors the first vector  * is used for slowpath operations while all remaining  * vectors are used for fastpath operations.  If only a  * single MSI/MSI-X vector is used (SINGLE_ISR) then the  * ISR must look for both slowpath and fastpath completions.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_interrupt_attach
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|snprintf
argument_list|(
name|sc
operator|->
name|sp_tq_name
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sp_tq_name
argument_list|)
argument_list|,
literal|"bxe%d_sp_tq"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sp_tq_task
argument_list|,
literal|0
argument_list|,
name|bxe_handle_sp_tq
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sp_tq
operator|=
name|taskqueue_create
argument_list|(
name|sc
operator|->
name|sp_tq_name
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|sc
operator|->
name|sp_tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|sc
operator|->
name|sp_tq
argument_list|,
literal|1
argument_list|,
name|PWAIT
argument_list|,
comment|/* lower priority */
literal|"%s"
argument_list|,
name|sc
operator|->
name|sp_tq_name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
expr_stmt|;
name|snprintf
argument_list|(
name|fp
operator|->
name|tq_name
argument_list|,
sizeof|sizeof
argument_list|(
name|fp
operator|->
name|tq_name
argument_list|)
argument_list|,
literal|"bxe%d_fp%d_tq"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|fp
operator|->
name|tq_task
argument_list|,
literal|0
argument_list|,
name|bxe_handle_fp_tq
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|fp
operator|->
name|tx_task
argument_list|,
literal|0
argument_list|,
name|bxe_tx_mq_start_deferred
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|tq
operator|=
name|taskqueue_create
argument_list|(
name|fp
operator|->
name|tq_name
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|fp
operator|->
name|tq
argument_list|)
expr_stmt|;
name|TIMEOUT_TASK_INIT
argument_list|(
name|fp
operator|->
name|tq
argument_list|,
operator|&
name|fp
operator|->
name|tx_timeout_task
argument_list|,
literal|0
argument_list|,
name|bxe_tx_mq_start_deferred
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|fp
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
comment|/* higher priority */
literal|"%s"
argument_list|,
name|fp
operator|->
name|tq_name
argument_list|)
expr_stmt|;
block|}
comment|/* setup interrupt handlers */
if|if
condition|(
name|sc
operator|->
name|interrupt_mode
operator|==
name|INTR_MODE_MSIX
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Enabling slowpath MSI-X[0] vector\n"
argument_list|)
expr_stmt|;
comment|/*          * Setup the interrupt handler. Note that we pass the driver instance          * to the interrupt handler for the slowpath.          */
if|if
condition|(
operator|(
name|rc
operator|=
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|intr
index|[
literal|0
index|]
operator|.
name|resource
argument_list|,
operator|(
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
operator|)
argument_list|,
name|NULL
argument_list|,
name|bxe_intr_sp
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|intr
index|[
literal|0
index|]
operator|.
name|tag
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to allocate MSI-X[0] vector (%d)\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|bxe_interrupt_attach_exit
goto|;
block|}
name|bus_describe_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|intr
index|[
literal|0
index|]
operator|.
name|resource
argument_list|,
name|sc
operator|->
name|intr
index|[
literal|0
index|]
operator|.
name|tag
argument_list|,
literal|"sp"
argument_list|)
expr_stmt|;
comment|/* bus_bind_intr(sc->dev, sc->intr[0].resource, 0); */
comment|/* initialize the fastpath vectors (note the first was used for sp) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Enabling MSI-X[%d] vector\n"
argument_list|,
operator|(
name|i
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/*              * Setup the interrupt handler. Note that we pass the              * fastpath context to the interrupt handler in this              * case.              */
if|if
condition|(
operator|(
name|rc
operator|=
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|intr
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|resource
argument_list|,
operator|(
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
operator|)
argument_list|,
name|NULL
argument_list|,
name|bxe_intr_fp
argument_list|,
name|fp
argument_list|,
operator|&
name|sc
operator|->
name|intr
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|tag
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to allocate MSI-X[%d] vector (%d)\n"
argument_list|,
operator|(
name|i
operator|+
literal|1
operator|)
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|bxe_interrupt_attach_exit
goto|;
block|}
name|bus_describe_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|intr
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|resource
argument_list|,
name|sc
operator|->
name|intr
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|tag
argument_list|,
literal|"fp%02d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* bind the fastpath instance to a cpu */
if|if
condition|(
name|sc
operator|->
name|num_queues
operator|>
literal|1
condition|)
block|{
name|bus_bind_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|intr
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|resource
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|fp
operator|->
name|state
operator|=
name|BXE_FP_STATE_IRQ
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|interrupt_mode
operator|==
name|INTR_MODE_MSI
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Enabling MSI[0] vector\n"
argument_list|)
expr_stmt|;
comment|/*          * Setup the interrupt handler. Note that we pass the          * driver instance to the interrupt handler which          * will handle both the slowpath and fastpath.          */
if|if
condition|(
operator|(
name|rc
operator|=
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|intr
index|[
literal|0
index|]
operator|.
name|resource
argument_list|,
operator|(
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
operator|)
argument_list|,
name|NULL
argument_list|,
name|bxe_intr_legacy
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|intr
index|[
literal|0
index|]
operator|.
name|tag
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to allocate MSI[0] vector (%d)\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|bxe_interrupt_attach_exit
goto|;
block|}
block|}
else|else
block|{
comment|/* (sc->interrupt_mode == INTR_MODE_INTX) */
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Enabling INTx interrupts\n"
argument_list|)
expr_stmt|;
comment|/*          * Setup the interrupt handler. Note that we pass the          * driver instance to the interrupt handler which          * will handle both the slowpath and fastpath.          */
if|if
condition|(
operator|(
name|rc
operator|=
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|intr
index|[
literal|0
index|]
operator|.
name|resource
argument_list|,
operator|(
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
operator|)
argument_list|,
name|NULL
argument_list|,
name|bxe_intr_legacy
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|intr
index|[
literal|0
index|]
operator|.
name|tag
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to allocate INTx interrupt (%d)\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|bxe_interrupt_attach_exit
goto|;
block|}
block|}
name|bxe_interrupt_attach_exit
label|:
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|int
name|bxe_init_hw_common_chip
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_init_hw_common
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_init_hw_port
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_init_hw_func
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_reset_common
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_reset_port
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_reset_func
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_gunzip_init
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_gunzip_end
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bxe_init_firmware
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bxe_release_firmware
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|ecore_func_sp_drv_ops
name|bxe_func_sp_drv
init|=
block|{
operator|.
name|init_hw_cmn_chip
operator|=
name|bxe_init_hw_common_chip
block|,
operator|.
name|init_hw_cmn
operator|=
name|bxe_init_hw_common
block|,
operator|.
name|init_hw_port
operator|=
name|bxe_init_hw_port
block|,
operator|.
name|init_hw_func
operator|=
name|bxe_init_hw_func
block|,
operator|.
name|reset_hw_cmn
operator|=
name|bxe_reset_common
block|,
operator|.
name|reset_hw_port
operator|=
name|bxe_reset_port
block|,
operator|.
name|reset_hw_func
operator|=
name|bxe_reset_func
block|,
operator|.
name|gunzip_init
operator|=
name|bxe_gunzip_init
block|,
operator|.
name|gunzip_end
operator|=
name|bxe_gunzip_end
block|,
operator|.
name|init_fw
operator|=
name|bxe_init_firmware
block|,
operator|.
name|release_fw
operator|=
name|bxe_release_firmware
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|bxe_init_func_obj
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|dmae_ready
operator|=
literal|0
expr_stmt|;
name|ecore_init_func_obj
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|func_obj
argument_list|,
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|func_rdata
argument_list|)
argument_list|,
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|func_rdata
argument_list|)
argument_list|,
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|func_afex_rdata
argument_list|)
argument_list|,
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|func_afex_rdata
argument_list|)
argument_list|,
operator|&
name|bxe_func_sp_drv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_init_hw
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|load_code
parameter_list|)
block|{
name|struct
name|ecore_func_state_params
name|func_params
init|=
block|{
name|NULL
block|}
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* prepare the parameters for function state transitions */
name|bit_set
argument_list|(
operator|&
name|func_params
operator|.
name|ramrod_flags
argument_list|,
name|RAMROD_COMP_WAIT
argument_list|)
expr_stmt|;
name|func_params
operator|.
name|f_obj
operator|=
operator|&
name|sc
operator|->
name|func_obj
expr_stmt|;
name|func_params
operator|.
name|cmd
operator|=
name|ECORE_F_CMD_HW_INIT
expr_stmt|;
name|func_params
operator|.
name|params
operator|.
name|hw_init
operator|.
name|load_phase
operator|=
name|load_code
expr_stmt|;
comment|/*      * Via a plethora of function pointers, we will eventually reach      * bxe_init_hw_common(), bxe_init_hw_port(), or bxe_init_hw_func().      */
name|rc
operator|=
name|ecore_func_state_change
argument_list|(
name|sc
argument_list|,
operator|&
name|func_params
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_fill
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|int
name|fill
parameter_list|,
name|uint32_t
name|len
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|len
operator|%
literal|4
operator|)
operator|&&
operator|!
operator|(
name|addr
operator|%
literal|4
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|addr
operator|+
name|i
operator|)
argument_list|,
name|fill
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|REG_WR8
argument_list|(
name|sc
argument_list|,
operator|(
name|addr
operator|+
name|i
operator|)
argument_list|,
name|fill
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* writes FP SP data to FW - data_size in dwords */
end_comment

begin_function
specifier|static
name|void
name|bxe_wr_fp_sb_data
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|fw_sb_id
parameter_list|,
name|uint32_t
modifier|*
name|sb_data_p
parameter_list|,
name|uint32_t
name|data_size
parameter_list|)
block|{
name|int
name|index
decl_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|data_size
condition|;
name|index
operator|++
control|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|BAR_CSTRORM_INTMEM
operator|+
name|CSTORM_STATUS_BLOCK_DATA_OFFSET
argument_list|(
name|fw_sb_id
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
name|index
operator|)
operator|)
argument_list|,
operator|*
operator|(
name|sb_data_p
operator|+
name|index
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_zero_fp_sb
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|fw_sb_id
parameter_list|)
block|{
name|struct
name|hc_status_block_data_e2
name|sb_data_e2
decl_stmt|;
name|struct
name|hc_status_block_data_e1x
name|sb_data_e1x
decl_stmt|;
name|uint32_t
modifier|*
name|sb_data_p
decl_stmt|;
name|uint32_t
name|data_size
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|memset
argument_list|(
operator|&
name|sb_data_e2
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hc_status_block_data_e2
argument_list|)
argument_list|)
expr_stmt|;
name|sb_data_e2
operator|.
name|common
operator|.
name|state
operator|=
name|SB_DISABLED
expr_stmt|;
name|sb_data_e2
operator|.
name|common
operator|.
name|p_func
operator|.
name|vf_valid
operator|=
name|FALSE
expr_stmt|;
name|sb_data_p
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|sb_data_e2
expr_stmt|;
name|data_size
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|hc_status_block_data_e2
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
operator|&
name|sb_data_e1x
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hc_status_block_data_e1x
argument_list|)
argument_list|)
expr_stmt|;
name|sb_data_e1x
operator|.
name|common
operator|.
name|state
operator|=
name|SB_DISABLED
expr_stmt|;
name|sb_data_e1x
operator|.
name|common
operator|.
name|p_func
operator|.
name|vf_valid
operator|=
name|FALSE
expr_stmt|;
name|sb_data_p
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|sb_data_e1x
expr_stmt|;
name|data_size
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|hc_status_block_data_e1x
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
block|}
name|bxe_wr_fp_sb_data
argument_list|(
name|sc
argument_list|,
name|fw_sb_id
argument_list|,
name|sb_data_p
argument_list|,
name|data_size
argument_list|)
expr_stmt|;
name|bxe_fill
argument_list|(
name|sc
argument_list|,
operator|(
name|BAR_CSTRORM_INTMEM
operator|+
name|CSTORM_STATUS_BLOCK_OFFSET
argument_list|(
name|fw_sb_id
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|CSTORM_STATUS_BLOCK_SIZE
argument_list|)
expr_stmt|;
name|bxe_fill
argument_list|(
name|sc
argument_list|,
operator|(
name|BAR_CSTRORM_INTMEM
operator|+
name|CSTORM_SYNC_BLOCK_OFFSET
argument_list|(
name|fw_sb_id
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|CSTORM_SYNC_BLOCK_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_wr_sp_sb_data
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|hc_sp_status_block_data
modifier|*
name|sp_sb_data
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|hc_sp_status_block_data
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|BAR_CSTRORM_INTMEM
operator|+
name|CSTORM_SP_STATUS_BLOCK_DATA_OFFSET
argument_list|(
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|+
operator|(
name|i
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
operator|)
argument_list|,
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|sp_sb_data
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_zero_sp_sb
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|hc_sp_status_block_data
name|sp_sb_data
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sp_sb_data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hc_sp_status_block_data
argument_list|)
argument_list|)
expr_stmt|;
name|sp_sb_data
operator|.
name|state
operator|=
name|SB_DISABLED
expr_stmt|;
name|sp_sb_data
operator|.
name|p_func
operator|.
name|vf_valid
operator|=
name|FALSE
expr_stmt|;
name|bxe_wr_sp_sb_data
argument_list|(
name|sc
argument_list|,
operator|&
name|sp_sb_data
argument_list|)
expr_stmt|;
name|bxe_fill
argument_list|(
name|sc
argument_list|,
operator|(
name|BAR_CSTRORM_INTMEM
operator|+
name|CSTORM_SP_STATUS_BLOCK_OFFSET
argument_list|(
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|CSTORM_SP_STATUS_BLOCK_SIZE
argument_list|)
expr_stmt|;
name|bxe_fill
argument_list|(
name|sc
argument_list|,
operator|(
name|BAR_CSTRORM_INTMEM
operator|+
name|CSTORM_SP_SYNC_BLOCK_OFFSET
argument_list|(
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|CSTORM_SP_SYNC_BLOCK_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_setup_ndsb_state_machine
parameter_list|(
name|struct
name|hc_status_block_sm
modifier|*
name|hc_sm
parameter_list|,
name|int
name|igu_sb_id
parameter_list|,
name|int
name|igu_seg_id
parameter_list|)
block|{
name|hc_sm
operator|->
name|igu_sb_id
operator|=
name|igu_sb_id
expr_stmt|;
name|hc_sm
operator|->
name|igu_seg_id
operator|=
name|igu_seg_id
expr_stmt|;
name|hc_sm
operator|->
name|timer_value
operator|=
literal|0xFF
expr_stmt|;
name|hc_sm
operator|->
name|time_to_expire
operator|=
literal|0xFFFFFFFF
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_map_sb_state_machines
parameter_list|(
name|struct
name|hc_index_data
modifier|*
name|index_data
parameter_list|)
block|{
comment|/* zero out state machine indices */
comment|/* rx indices */
name|index_data
index|[
name|HC_INDEX_ETH_RX_CQ_CONS
index|]
operator|.
name|flags
operator|&=
operator|~
name|HC_INDEX_DATA_SM_ID
expr_stmt|;
comment|/* tx indices */
name|index_data
index|[
name|HC_INDEX_OOO_TX_CQ_CONS
index|]
operator|.
name|flags
operator|&=
operator|~
name|HC_INDEX_DATA_SM_ID
expr_stmt|;
name|index_data
index|[
name|HC_INDEX_ETH_TX_CQ_CONS_COS0
index|]
operator|.
name|flags
operator|&=
operator|~
name|HC_INDEX_DATA_SM_ID
expr_stmt|;
name|index_data
index|[
name|HC_INDEX_ETH_TX_CQ_CONS_COS1
index|]
operator|.
name|flags
operator|&=
operator|~
name|HC_INDEX_DATA_SM_ID
expr_stmt|;
name|index_data
index|[
name|HC_INDEX_ETH_TX_CQ_CONS_COS2
index|]
operator|.
name|flags
operator|&=
operator|~
name|HC_INDEX_DATA_SM_ID
expr_stmt|;
comment|/* map indices */
comment|/* rx indices */
name|index_data
index|[
name|HC_INDEX_ETH_RX_CQ_CONS
index|]
operator|.
name|flags
operator||=
operator|(
name|SM_RX_ID
operator|<<
name|HC_INDEX_DATA_SM_ID_SHIFT
operator|)
expr_stmt|;
comment|/* tx indices */
name|index_data
index|[
name|HC_INDEX_OOO_TX_CQ_CONS
index|]
operator|.
name|flags
operator||=
operator|(
name|SM_TX_ID
operator|<<
name|HC_INDEX_DATA_SM_ID_SHIFT
operator|)
expr_stmt|;
name|index_data
index|[
name|HC_INDEX_ETH_TX_CQ_CONS_COS0
index|]
operator|.
name|flags
operator||=
operator|(
name|SM_TX_ID
operator|<<
name|HC_INDEX_DATA_SM_ID_SHIFT
operator|)
expr_stmt|;
name|index_data
index|[
name|HC_INDEX_ETH_TX_CQ_CONS_COS1
index|]
operator|.
name|flags
operator||=
operator|(
name|SM_TX_ID
operator|<<
name|HC_INDEX_DATA_SM_ID_SHIFT
operator|)
expr_stmt|;
name|index_data
index|[
name|HC_INDEX_ETH_TX_CQ_CONS_COS2
index|]
operator|.
name|flags
operator||=
operator|(
name|SM_TX_ID
operator|<<
name|HC_INDEX_DATA_SM_ID_SHIFT
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_init_sb
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|bus_addr_t
name|busaddr
parameter_list|,
name|int
name|vfid
parameter_list|,
name|uint8_t
name|vf_valid
parameter_list|,
name|int
name|fw_sb_id
parameter_list|,
name|int
name|igu_sb_id
parameter_list|)
block|{
name|struct
name|hc_status_block_data_e2
name|sb_data_e2
decl_stmt|;
name|struct
name|hc_status_block_data_e1x
name|sb_data_e1x
decl_stmt|;
name|struct
name|hc_status_block_sm
modifier|*
name|hc_sm_p
decl_stmt|;
name|uint32_t
modifier|*
name|sb_data_p
decl_stmt|;
name|int
name|igu_seg_id
decl_stmt|;
name|int
name|data_size
decl_stmt|;
if|if
condition|(
name|CHIP_INT_MODE_IS_BC
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|igu_seg_id
operator|=
name|HC_SEG_ACCESS_NORM
expr_stmt|;
block|}
else|else
block|{
name|igu_seg_id
operator|=
name|IGU_SEG_ACCESS_NORM
expr_stmt|;
block|}
name|bxe_zero_fp_sb
argument_list|(
name|sc
argument_list|,
name|fw_sb_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|memset
argument_list|(
operator|&
name|sb_data_e2
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hc_status_block_data_e2
argument_list|)
argument_list|)
expr_stmt|;
name|sb_data_e2
operator|.
name|common
operator|.
name|state
operator|=
name|SB_ENABLED
expr_stmt|;
name|sb_data_e2
operator|.
name|common
operator|.
name|p_func
operator|.
name|pf_id
operator|=
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sb_data_e2
operator|.
name|common
operator|.
name|p_func
operator|.
name|vf_id
operator|=
name|vfid
expr_stmt|;
name|sb_data_e2
operator|.
name|common
operator|.
name|p_func
operator|.
name|vf_valid
operator|=
name|vf_valid
expr_stmt|;
name|sb_data_e2
operator|.
name|common
operator|.
name|p_func
operator|.
name|vnic_id
operator|=
name|SC_VN
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sb_data_e2
operator|.
name|common
operator|.
name|same_igu_sb_1b
operator|=
name|TRUE
expr_stmt|;
name|sb_data_e2
operator|.
name|common
operator|.
name|host_sb_addr
operator|.
name|hi
operator|=
name|U64_HI
argument_list|(
name|busaddr
argument_list|)
expr_stmt|;
name|sb_data_e2
operator|.
name|common
operator|.
name|host_sb_addr
operator|.
name|lo
operator|=
name|U64_LO
argument_list|(
name|busaddr
argument_list|)
expr_stmt|;
name|hc_sm_p
operator|=
name|sb_data_e2
operator|.
name|common
operator|.
name|state_machine
expr_stmt|;
name|sb_data_p
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|sb_data_e2
expr_stmt|;
name|data_size
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|hc_status_block_data_e2
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
name|bxe_map_sb_state_machines
argument_list|(
name|sb_data_e2
operator|.
name|index_data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
operator|&
name|sb_data_e1x
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hc_status_block_data_e1x
argument_list|)
argument_list|)
expr_stmt|;
name|sb_data_e1x
operator|.
name|common
operator|.
name|state
operator|=
name|SB_ENABLED
expr_stmt|;
name|sb_data_e1x
operator|.
name|common
operator|.
name|p_func
operator|.
name|pf_id
operator|=
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sb_data_e1x
operator|.
name|common
operator|.
name|p_func
operator|.
name|vf_id
operator|=
literal|0xff
expr_stmt|;
name|sb_data_e1x
operator|.
name|common
operator|.
name|p_func
operator|.
name|vf_valid
operator|=
name|FALSE
expr_stmt|;
name|sb_data_e1x
operator|.
name|common
operator|.
name|p_func
operator|.
name|vnic_id
operator|=
name|SC_VN
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sb_data_e1x
operator|.
name|common
operator|.
name|same_igu_sb_1b
operator|=
name|TRUE
expr_stmt|;
name|sb_data_e1x
operator|.
name|common
operator|.
name|host_sb_addr
operator|.
name|hi
operator|=
name|U64_HI
argument_list|(
name|busaddr
argument_list|)
expr_stmt|;
name|sb_data_e1x
operator|.
name|common
operator|.
name|host_sb_addr
operator|.
name|lo
operator|=
name|U64_LO
argument_list|(
name|busaddr
argument_list|)
expr_stmt|;
name|hc_sm_p
operator|=
name|sb_data_e1x
operator|.
name|common
operator|.
name|state_machine
expr_stmt|;
name|sb_data_p
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|sb_data_e1x
expr_stmt|;
name|data_size
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|hc_status_block_data_e1x
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
name|bxe_map_sb_state_machines
argument_list|(
name|sb_data_e1x
operator|.
name|index_data
argument_list|)
expr_stmt|;
block|}
name|bxe_setup_ndsb_state_machine
argument_list|(
operator|&
name|hc_sm_p
index|[
name|SM_RX_ID
index|]
argument_list|,
name|igu_sb_id
argument_list|,
name|igu_seg_id
argument_list|)
expr_stmt|;
name|bxe_setup_ndsb_state_machine
argument_list|(
operator|&
name|hc_sm_p
index|[
name|SM_TX_ID
index|]
argument_list|,
name|igu_sb_id
argument_list|,
name|igu_seg_id
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Init FW SB %d\n"
argument_list|,
name|fw_sb_id
argument_list|)
expr_stmt|;
comment|/* write indices to HW - PCI guarantees endianity of regpairs */
name|bxe_wr_fp_sb_data
argument_list|(
name|sc
argument_list|,
name|fw_sb_id
argument_list|,
name|sb_data_p
argument_list|,
name|data_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint8_t
name|bxe_fp_qzone_id
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|CHIP_IS_E1x
argument_list|(
name|fp
operator|->
name|sc
argument_list|)
condition|)
block|{
return|return
operator|(
name|fp
operator|->
name|cl_id
operator|+
name|SC_PORT
argument_list|(
name|fp
operator|->
name|sc
argument_list|)
operator|*
name|ETH_MAX_RX_CLIENTS_E1H
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|fp
operator|->
name|cl_id
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint32_t
name|bxe_rx_ustorm_prods_offset
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|)
block|{
name|uint32_t
name|offset
init|=
name|BAR_USTRORM_INTMEM
decl_stmt|;
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|offset
operator|+=
name|USTORM_RX_PRODS_E2_OFFSET
argument_list|(
name|fp
operator|->
name|cl_qzone_id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|+=
name|USTORM_RX_PRODS_E1X_OFFSET
argument_list|(
name|SC_PORT
argument_list|(
name|sc
argument_list|)
argument_list|,
name|fp
operator|->
name|cl_id
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|offset
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_init_eth_fp
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|struct
name|bxe_fastpath
modifier|*
name|fp
init|=
operator|&
name|sc
operator|->
name|fp
index|[
name|idx
index|]
decl_stmt|;
name|uint32_t
name|cids
index|[
name|ECORE_MULTI_TX_COS
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|unsigned
name|long
name|q_type
init|=
literal|0
decl_stmt|;
name|int
name|cos
decl_stmt|;
name|fp
operator|->
name|sc
operator|=
name|sc
expr_stmt|;
name|fp
operator|->
name|index
operator|=
name|idx
expr_stmt|;
name|fp
operator|->
name|igu_sb_id
operator|=
operator|(
name|sc
operator|->
name|igu_base_sb
operator|+
name|idx
operator|+
name|CNIC_SUPPORT
argument_list|(
name|sc
argument_list|)
operator|)
expr_stmt|;
name|fp
operator|->
name|fw_sb_id
operator|=
operator|(
name|sc
operator|->
name|base_fw_ndsb
operator|+
name|idx
operator|+
name|CNIC_SUPPORT
argument_list|(
name|sc
argument_list|)
operator|)
expr_stmt|;
name|fp
operator|->
name|cl_id
operator|=
operator|(
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
operator|)
condition|?
operator|(
name|SC_L_ID
argument_list|(
name|sc
argument_list|)
operator|+
name|idx
operator|)
else|:
comment|/* want client ID same as IGU SB ID for non-E1 */
name|fp
operator|->
name|igu_sb_id
expr_stmt|;
name|fp
operator|->
name|cl_qzone_id
operator|=
name|bxe_fp_qzone_id
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* setup sb indices */
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|fp
operator|->
name|sb_index_values
operator|=
name|fp
operator|->
name|status_block
operator|.
name|e2_sb
operator|->
name|sb
operator|.
name|index_values
expr_stmt|;
name|fp
operator|->
name|sb_running_index
operator|=
name|fp
operator|->
name|status_block
operator|.
name|e2_sb
operator|->
name|sb
operator|.
name|running_index
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|->
name|sb_index_values
operator|=
name|fp
operator|->
name|status_block
operator|.
name|e1x_sb
operator|->
name|sb
operator|.
name|index_values
expr_stmt|;
name|fp
operator|->
name|sb_running_index
operator|=
name|fp
operator|->
name|status_block
operator|.
name|e1x_sb
operator|->
name|sb
operator|.
name|running_index
expr_stmt|;
block|}
comment|/* init shortcut */
name|fp
operator|->
name|ustorm_rx_prods_offset
operator|=
name|bxe_rx_ustorm_prods_offset
argument_list|(
name|sc
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|rx_cq_cons_sb
operator|=
operator|&
name|fp
operator|->
name|sb_index_values
index|[
name|HC_INDEX_ETH_RX_CQ_CONS
index|]
expr_stmt|;
comment|/*      * XXX If multiple CoS is ever supported then each fastpath structure      * will need to maintain tx producer/consumer/dma/etc values *per* CoS.      */
for|for
control|(
name|cos
operator|=
literal|0
init|;
name|cos
operator|<
name|sc
operator|->
name|max_cos
condition|;
name|cos
operator|++
control|)
block|{
name|cids
index|[
name|cos
index|]
operator|=
name|idx
expr_stmt|;
block|}
name|fp
operator|->
name|tx_cons_sb
operator|=
operator|&
name|fp
operator|->
name|sb_index_values
index|[
name|HC_INDEX_ETH_TX_CQ_CONS_COS0
index|]
expr_stmt|;
comment|/* nothing more for a VF to do */
if|if
condition|(
name|IS_VF
argument_list|(
name|sc
argument_list|)
condition|)
block|{
return|return;
block|}
name|bxe_init_sb
argument_list|(
name|sc
argument_list|,
name|fp
operator|->
name|sb_dma
operator|.
name|paddr
argument_list|,
name|BXE_VF_ID_INVALID
argument_list|,
name|FALSE
argument_list|,
name|fp
operator|->
name|fw_sb_id
argument_list|,
name|fp
operator|->
name|igu_sb_id
argument_list|)
expr_stmt|;
name|bxe_update_fp_sb_idx
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* Configure Queue State object */
name|bit_set
argument_list|(
operator|&
name|q_type
argument_list|,
name|ECORE_Q_TYPE_HAS_RX
argument_list|)
expr_stmt|;
name|bit_set
argument_list|(
operator|&
name|q_type
argument_list|,
name|ECORE_Q_TYPE_HAS_TX
argument_list|)
expr_stmt|;
name|ecore_init_queue_obj
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sp_objs
index|[
name|idx
index|]
operator|.
name|q_obj
argument_list|,
name|fp
operator|->
name|cl_id
argument_list|,
name|cids
argument_list|,
name|sc
operator|->
name|max_cos
argument_list|,
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
argument_list|,
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|q_rdata
argument_list|)
argument_list|,
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|q_rdata
argument_list|)
argument_list|,
name|q_type
argument_list|)
expr_stmt|;
comment|/* configure classification DBs */
name|ecore_init_mac_obj
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sp_objs
index|[
name|idx
index|]
operator|.
name|mac_obj
argument_list|,
name|fp
operator|->
name|cl_id
argument_list|,
name|idx
argument_list|,
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
argument_list|,
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|mac_rdata
argument_list|)
argument_list|,
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|mac_rdata
argument_list|)
argument_list|,
name|ECORE_FILTER_MAC_PENDING
argument_list|,
operator|&
name|sc
operator|->
name|sp_state
argument_list|,
name|ECORE_OBJ_TYPE_RX_TX
argument_list|,
operator|&
name|sc
operator|->
name|macs_pool
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"fp[%d]: sb=%p cl_id=%d fw_sb=%d igu_sb=%d\n"
argument_list|,
name|idx
argument_list|,
name|fp
operator|->
name|status_block
operator|.
name|e2_sb
argument_list|,
name|fp
operator|->
name|cl_id
argument_list|,
name|fp
operator|->
name|fw_sb_id
argument_list|,
name|fp
operator|->
name|igu_sb_id
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|bxe_update_rx_prod
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|uint16_t
name|rx_bd_prod
parameter_list|,
name|uint16_t
name|rx_cq_prod
parameter_list|,
name|uint16_t
name|rx_sge_prod
parameter_list|)
block|{
name|struct
name|ustorm_eth_rx_producers
name|rx_prods
init|=
block|{
literal|0
block|}
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
comment|/* update producers */
name|rx_prods
operator|.
name|bd_prod
operator|=
name|rx_bd_prod
expr_stmt|;
name|rx_prods
operator|.
name|cqe_prod
operator|=
name|rx_cq_prod
expr_stmt|;
name|rx_prods
operator|.
name|sge_prod
operator|=
name|rx_sge_prod
expr_stmt|;
comment|/*      * Make sure that the BD and SGE data is updated before updating the      * producers since FW might read the BD/SGE right after the producer      * is updated.      * This is only applicable for weak-ordered memory model archs such      * as IA-64. The following barrier is also mandatory since FW will      * assumes BDs must have buffers.      */
name|wmb
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|rx_prods
argument_list|)
operator|/
literal|4
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|fp
operator|->
name|ustorm_rx_prods_offset
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
operator|)
argument_list|,
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|rx_prods
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|wmb
argument_list|()
expr_stmt|;
comment|/* keep prod updates ordered */
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_RX
argument_list|,
literal|"RX fp[%d]: wrote prods bd_prod=%u cqe_prod=%u sge_prod=%u\n"
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|rx_bd_prod
argument_list|,
name|rx_cq_prod
argument_list|,
name|rx_sge_prod
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_init_rx_rings
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
expr_stmt|;
name|fp
operator|->
name|rx_bd_cons
operator|=
literal|0
expr_stmt|;
comment|/*          * Activate the BD ring...          * Warning, this will generate an interrupt (to the TSTORM)          * so this can only be done after the chip is initialized          */
name|bxe_update_rx_prod
argument_list|(
name|sc
argument_list|,
name|fp
argument_list|,
name|fp
operator|->
name|rx_bd_prod
argument_list|,
name|fp
operator|->
name|rx_cq_prod
argument_list|,
name|fp
operator|->
name|rx_sge_prod
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|BAR_USTRORM_INTMEM
operator|+
name|USTORM_MEM_WORKAROUND_ADDRESS_OFFSET
argument_list|(
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|)
argument_list|,
name|U64_LO
argument_list|(
name|fp
operator|->
name|rcq_dma
operator|.
name|paddr
argument_list|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|BAR_USTRORM_INTMEM
operator|+
name|USTORM_MEM_WORKAROUND_ADDRESS_OFFSET
argument_list|(
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|+
literal|4
operator|)
argument_list|,
name|U64_HI
argument_list|(
name|fp
operator|->
name|rcq_dma
operator|.
name|paddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_init_tx_ring_one
parameter_list|(
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|)
block|{
name|SET_FLAG
argument_list|(
name|fp
operator|->
name|tx_db
operator|.
name|data
operator|.
name|header
operator|.
name|data
argument_list|,
name|DOORBELL_HDR_T_DB_TYPE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fp
operator|->
name|tx_db
operator|.
name|data
operator|.
name|zero_fill1
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|tx_db
operator|.
name|data
operator|.
name|prod
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|tx_pkt_prod
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|tx_pkt_cons
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|tx_bd_prod
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|tx_bd_cons
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|eth_q_stats
operator|.
name|tx_pkts
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|bxe_init_tx_rings
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|bxe_init_tx_ring_one
argument_list|(
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_init_def_sb
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|host_sp_status_block
modifier|*
name|def_sb
init|=
name|sc
operator|->
name|def_sb
decl_stmt|;
name|bus_addr_t
name|mapping
init|=
name|sc
operator|->
name|def_sb_dma
operator|.
name|paddr
decl_stmt|;
name|int
name|igu_sp_sb_index
decl_stmt|;
name|int
name|igu_seg_id
decl_stmt|;
name|int
name|port
init|=
name|SC_PORT
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|int
name|func
init|=
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|int
name|reg_offset
decl_stmt|,
name|reg_offset_en5
decl_stmt|;
name|uint64_t
name|section
decl_stmt|;
name|int
name|index
decl_stmt|,
name|sindex
decl_stmt|;
name|struct
name|hc_sp_status_block_data
name|sp_sb_data
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sp_sb_data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hc_sp_status_block_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_INT_MODE_IS_BC
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|igu_sp_sb_index
operator|=
name|DEF_SB_IGU_ID
expr_stmt|;
name|igu_seg_id
operator|=
name|HC_SEG_ACCESS_DEF
expr_stmt|;
block|}
else|else
block|{
name|igu_sp_sb_index
operator|=
name|sc
operator|->
name|igu_dsb_id
expr_stmt|;
name|igu_seg_id
operator|=
name|IGU_SEG_ACCESS_DEF
expr_stmt|;
block|}
comment|/* attentions */
name|section
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|mapping
operator|+
name|offsetof
argument_list|(
expr|struct
name|host_sp_status_block
argument_list|,
name|atten_status_block
argument_list|)
operator|)
expr_stmt|;
name|def_sb
operator|->
name|atten_status_block
operator|.
name|status_block_id
operator|=
name|igu_sp_sb_index
expr_stmt|;
name|sc
operator|->
name|attn_state
operator|=
literal|0
expr_stmt|;
name|reg_offset
operator|=
operator|(
name|port
operator|)
condition|?
name|MISC_REG_AEU_ENABLE1_FUNC_1_OUT_0
else|:
name|MISC_REG_AEU_ENABLE1_FUNC_0_OUT_0
expr_stmt|;
name|reg_offset_en5
operator|=
operator|(
name|port
operator|)
condition|?
name|MISC_REG_AEU_ENABLE5_FUNC_1_OUT_0
else|:
name|MISC_REG_AEU_ENABLE5_FUNC_0_OUT_0
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|MAX_DYNAMIC_ATTN_GRPS
condition|;
name|index
operator|++
control|)
block|{
comment|/* take care of sig[0]..sig[4] */
for|for
control|(
name|sindex
operator|=
literal|0
init|;
name|sindex
operator|<
literal|4
condition|;
name|sindex
operator|++
control|)
block|{
name|sc
operator|->
name|attn_group
index|[
name|index
index|]
operator|.
name|sig
index|[
name|sindex
index|]
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
operator|(
name|reg_offset
operator|+
operator|(
name|sindex
operator|*
literal|0x4
operator|)
operator|+
operator|(
literal|0x10
operator|*
name|index
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/*              * enable5 is separate from the rest of the registers,              * and the address skip is 4 and not 16 between the              * different groups              */
name|sc
operator|->
name|attn_group
index|[
name|index
index|]
operator|.
name|sig
index|[
literal|4
index|]
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
operator|(
name|reg_offset_en5
operator|+
operator|(
literal|0x4
operator|*
name|index
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|attn_group
index|[
name|index
index|]
operator|.
name|sig
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|devinfo
operator|.
name|int_block
operator|==
name|INT_BLOCK_HC
condition|)
block|{
name|reg_offset
operator|=
operator|(
name|port
operator|)
condition|?
name|HC_REG_ATTN_MSG1_ADDR_L
else|:
name|HC_REG_ATTN_MSG0_ADDR_L
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|reg_offset
argument_list|,
name|U64_LO
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|reg_offset
operator|+
literal|4
operator|)
argument_list|,
name|U64_HI
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|IGU_REG_ATTN_MSG_ADDR_L
argument_list|,
name|U64_LO
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|IGU_REG_ATTN_MSG_ADDR_H
argument_list|,
name|U64_HI
argument_list|(
name|section
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|section
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|mapping
operator|+
name|offsetof
argument_list|(
expr|struct
name|host_sp_status_block
argument_list|,
name|sp_sb
argument_list|)
operator|)
expr_stmt|;
name|bxe_zero_sp_sb
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* PCI guarantees endianity of regpair */
name|sp_sb_data
operator|.
name|state
operator|=
name|SB_ENABLED
expr_stmt|;
name|sp_sb_data
operator|.
name|host_sb_addr
operator|.
name|lo
operator|=
name|U64_LO
argument_list|(
name|section
argument_list|)
expr_stmt|;
name|sp_sb_data
operator|.
name|host_sb_addr
operator|.
name|hi
operator|=
name|U64_HI
argument_list|(
name|section
argument_list|)
expr_stmt|;
name|sp_sb_data
operator|.
name|igu_sb_id
operator|=
name|igu_sp_sb_index
expr_stmt|;
name|sp_sb_data
operator|.
name|igu_seg_id
operator|=
name|igu_seg_id
expr_stmt|;
name|sp_sb_data
operator|.
name|p_func
operator|.
name|pf_id
operator|=
name|func
expr_stmt|;
name|sp_sb_data
operator|.
name|p_func
operator|.
name|vnic_id
operator|=
name|SC_VN
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sp_sb_data
operator|.
name|p_func
operator|.
name|vf_id
operator|=
literal|0xff
expr_stmt|;
name|bxe_wr_sp_sb_data
argument_list|(
name|sc
argument_list|,
operator|&
name|sp_sb_data
argument_list|)
expr_stmt|;
name|bxe_ack_sb
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|igu_dsb_id
argument_list|,
name|USTORM_ID
argument_list|,
literal|0
argument_list|,
name|IGU_INT_ENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_init_sp_ring
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|atomic_store_rel_long
argument_list|(
operator|&
name|sc
operator|->
name|cq_spq_left
argument_list|,
name|MAX_SPQ_PENDING
argument_list|)
expr_stmt|;
name|sc
operator|->
name|spq_prod_idx
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|dsb_sp_prod
operator|=
operator|&
name|sc
operator|->
name|def_sb
operator|->
name|sp_sb
operator|.
name|index_values
index|[
name|HC_SP_INDEX_ETH_DEF_CONS
index|]
expr_stmt|;
name|sc
operator|->
name|spq_prod_bd
operator|=
name|sc
operator|->
name|spq
expr_stmt|;
name|sc
operator|->
name|spq_last_bd
operator|=
operator|(
name|sc
operator|->
name|spq_prod_bd
operator|+
name|MAX_SP_DESC_CNT
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_init_eq_ring
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|union
name|event_ring_elem
modifier|*
name|elem
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|NUM_EQ_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|elem
operator|=
operator|&
name|sc
operator|->
name|eq
index|[
name|EQ_DESC_CNT_PAGE
operator|*
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|elem
operator|->
name|next_page
operator|.
name|addr
operator|.
name|hi
operator|=
name|htole32
argument_list|(
name|U64_HI
argument_list|(
name|sc
operator|->
name|eq_dma
operator|.
name|paddr
operator|+
name|BCM_PAGE_SIZE
operator|*
operator|(
name|i
operator|%
name|NUM_EQ_PAGES
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|elem
operator|->
name|next_page
operator|.
name|addr
operator|.
name|lo
operator|=
name|htole32
argument_list|(
name|U64_LO
argument_list|(
name|sc
operator|->
name|eq_dma
operator|.
name|paddr
operator|+
name|BCM_PAGE_SIZE
operator|*
operator|(
name|i
operator|%
name|NUM_EQ_PAGES
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|eq_cons
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|eq_prod
operator|=
name|NUM_EQ_DESC
expr_stmt|;
name|sc
operator|->
name|eq_cons_sb
operator|=
operator|&
name|sc
operator|->
name|def_sb
operator|->
name|sp_sb
operator|.
name|index_values
index|[
name|HC_SP_INDEX_EQ_CONS
index|]
expr_stmt|;
name|atomic_store_rel_long
argument_list|(
operator|&
name|sc
operator|->
name|eq_spq_left
argument_list|,
operator|(
name|min
argument_list|(
operator|(
name|MAX_SP_DESC_CNT
operator|-
name|MAX_SPQ_PENDING
operator|)
argument_list|,
name|NUM_EQ_DESC
argument_list|)
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_init_internal_common
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/*      * Zero this manually as its initialization is currently missing      * in the initTool.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|USTORM_AGG_DATA_SIZE
operator|>>
literal|2
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|BAR_USTRORM_INTMEM
operator|+
name|USTORM_AGG_DATA_OFFSET
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|REG_WR8
argument_list|(
name|sc
argument_list|,
operator|(
name|BAR_CSTRORM_INTMEM
operator|+
name|CSTORM_IGU_MODE_OFFSET
operator|)
argument_list|,
name|CHIP_INT_MODE_IS_BC
argument_list|(
name|sc
argument_list|)
condition|?
name|HC_IGU_BC_MODE
else|:
name|HC_IGU_NBC_MODE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_init_internal
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|load_code
parameter_list|)
block|{
switch|switch
condition|(
name|load_code
condition|)
block|{
case|case
name|FW_MSG_CODE_DRV_LOAD_COMMON
case|:
case|case
name|FW_MSG_CODE_DRV_LOAD_COMMON_CHIP
case|:
name|bxe_init_internal_common
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* no break */
case|case
name|FW_MSG_CODE_DRV_LOAD_PORT
case|:
comment|/* nothing to do */
comment|/* no break */
case|case
name|FW_MSG_CODE_DRV_LOAD_FUNCTION
case|:
comment|/* internal memory per function is initialized inside bxe_pf_init */
break|break;
default|default:
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Unknown load_code (0x%x) from MCP\n"
argument_list|,
name|load_code
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|storm_memset_func_cfg
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|tstorm_eth_function_common_config
modifier|*
name|tcfg
parameter_list|,
name|uint16_t
name|abs_fid
parameter_list|)
block|{
name|uint32_t
name|addr
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|addr
operator|=
operator|(
name|BAR_TSTRORM_INTMEM
operator|+
name|TSTORM_FUNCTION_COMMON_CONFIG_OFFSET
argument_list|(
name|abs_fid
argument_list|)
operator|)
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|tstorm_eth_function_common_config
argument_list|)
expr_stmt|;
name|ecore_storm_memset_struct
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
name|tcfg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_func_init
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bxe_func_init_params
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|tstorm_eth_function_common_config
name|tcfg
init|=
block|{
literal|0
block|}
decl_stmt|;
if|if
condition|(
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|storm_memset_func_cfg
argument_list|(
name|sc
argument_list|,
operator|&
name|tcfg
argument_list|,
name|p
operator|->
name|func_id
argument_list|)
expr_stmt|;
block|}
comment|/* Enable the function in the FW */
name|storm_memset_vf_to_pf
argument_list|(
name|sc
argument_list|,
name|p
operator|->
name|func_id
argument_list|,
name|p
operator|->
name|pf_id
argument_list|)
expr_stmt|;
name|storm_memset_func_en
argument_list|(
name|sc
argument_list|,
name|p
operator|->
name|func_id
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* spq */
if|if
condition|(
name|p
operator|->
name|func_flgs
operator|&
name|FUNC_FLG_SPQ
condition|)
block|{
name|storm_memset_spq_addr
argument_list|(
name|sc
argument_list|,
name|p
operator|->
name|spq_map
argument_list|,
name|p
operator|->
name|func_id
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|XSEM_REG_FAST_MEMORY
operator|+
name|XSTORM_SPQ_PROD_OFFSET
argument_list|(
name|p
operator|->
name|func_id
argument_list|)
operator|)
argument_list|,
name|p
operator|->
name|spq_prod
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Calculates the sum of vn_min_rates.  * It's needed for further normalizing of the min_rates.  * Returns:  *   sum of vn_min_rates.  *     or  *   0 - if all the min_rates are 0.  * In the later case fainess algorithm should be deactivated.  * If all min rates are not zero then those that are zeroes will be set to 1.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_calc_vn_min
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cmng_init_input
modifier|*
name|input
parameter_list|)
block|{
name|uint32_t
name|vn_cfg
decl_stmt|;
name|uint32_t
name|vn_min_rate
decl_stmt|;
name|int
name|all_zero
init|=
literal|1
decl_stmt|;
name|int
name|vn
decl_stmt|;
for|for
control|(
name|vn
operator|=
name|VN_0
init|;
name|vn
operator|<
name|SC_MAX_VN_NUM
argument_list|(
name|sc
argument_list|)
condition|;
name|vn
operator|++
control|)
block|{
name|vn_cfg
operator|=
name|sc
operator|->
name|devinfo
operator|.
name|mf_info
operator|.
name|mf_config
index|[
name|vn
index|]
expr_stmt|;
name|vn_min_rate
operator|=
operator|(
operator|(
operator|(
name|vn_cfg
operator|&
name|FUNC_MF_CFG_MIN_BW_MASK
operator|)
operator|>>
name|FUNC_MF_CFG_MIN_BW_SHIFT
operator|)
operator|*
literal|100
operator|)
expr_stmt|;
if|if
condition|(
name|vn_cfg
operator|&
name|FUNC_MF_CFG_FUNC_HIDE
condition|)
block|{
comment|/* skip hidden VNs */
name|vn_min_rate
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|vn_min_rate
condition|)
block|{
comment|/* If min rate is zero - set it to 100 */
name|vn_min_rate
operator|=
name|DEF_MIN_RATE
expr_stmt|;
block|}
else|else
block|{
name|all_zero
operator|=
literal|0
expr_stmt|;
block|}
name|input
operator|->
name|vnic_min_rate
index|[
name|vn
index|]
operator|=
name|vn_min_rate
expr_stmt|;
block|}
comment|/* if ETS or all min rates are zeros - disable fairness */
if|if
condition|(
name|BXE_IS_ETS_ENABLED
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|input
operator|->
name|flags
operator|.
name|cmng_enables
operator|&=
operator|~
name|CMNG_FLAGS_PER_PORT_FAIRNESS_VN
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Fairness disabled (ETS)\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|all_zero
condition|)
block|{
name|input
operator|->
name|flags
operator|.
name|cmng_enables
operator|&=
operator|~
name|CMNG_FLAGS_PER_PORT_FAIRNESS_VN
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Fariness disabled (all MIN values are zeroes)\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|input
operator|->
name|flags
operator|.
name|cmng_enables
operator||=
name|CMNG_FLAGS_PER_PORT_FAIRNESS_VN
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint16_t
name|bxe_extract_max_cfg
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|mf_cfg
parameter_list|)
block|{
name|uint16_t
name|max_cfg
init|=
operator|(
operator|(
name|mf_cfg
operator|&
name|FUNC_MF_CFG_MAX_BW_MASK
operator|)
operator|>>
name|FUNC_MF_CFG_MAX_BW_SHIFT
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|max_cfg
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Max BW configured to 0 - using 100 instead\n"
argument_list|)
expr_stmt|;
name|max_cfg
operator|=
literal|100
expr_stmt|;
block|}
return|return
operator|(
name|max_cfg
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_calc_vn_max
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|vn
parameter_list|,
name|struct
name|cmng_init_input
modifier|*
name|input
parameter_list|)
block|{
name|uint16_t
name|vn_max_rate
decl_stmt|;
name|uint32_t
name|vn_cfg
init|=
name|sc
operator|->
name|devinfo
operator|.
name|mf_info
operator|.
name|mf_config
index|[
name|vn
index|]
decl_stmt|;
name|uint32_t
name|max_cfg
decl_stmt|;
if|if
condition|(
name|vn_cfg
operator|&
name|FUNC_MF_CFG_FUNC_HIDE
condition|)
block|{
name|vn_max_rate
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|max_cfg
operator|=
name|bxe_extract_max_cfg
argument_list|(
name|sc
argument_list|,
name|vn_cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_MF_SI
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* max_cfg in percents of linkspeed */
name|vn_max_rate
operator|=
operator|(
operator|(
name|sc
operator|->
name|link_vars
operator|.
name|line_speed
operator|*
name|max_cfg
operator|)
operator|/
literal|100
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* SD modes */
comment|/* max_cfg is absolute in 100Mb units */
name|vn_max_rate
operator|=
operator|(
name|max_cfg
operator|*
literal|100
operator|)
expr_stmt|;
block|}
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"vn %d: vn_max_rate %d\n"
argument_list|,
name|vn
argument_list|,
name|vn_max_rate
argument_list|)
expr_stmt|;
name|input
operator|->
name|vnic_max_rate
index|[
name|vn
index|]
operator|=
name|vn_max_rate
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_cmng_fns_init
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|read_cfg
parameter_list|,
name|uint8_t
name|cmng_type
parameter_list|)
block|{
name|struct
name|cmng_init_input
name|input
decl_stmt|;
name|int
name|vn
decl_stmt|;
name|memset
argument_list|(
operator|&
name|input
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cmng_init_input
argument_list|)
argument_list|)
expr_stmt|;
name|input
operator|.
name|port_rate
operator|=
name|sc
operator|->
name|link_vars
operator|.
name|line_speed
expr_stmt|;
if|if
condition|(
name|cmng_type
operator|==
name|CMNG_FNS_MINMAX
condition|)
block|{
comment|/* read mf conf from shmem */
if|if
condition|(
name|read_cfg
condition|)
block|{
name|bxe_read_mf_cfg
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* get VN min rate and enable fairness if not 0 */
name|bxe_calc_vn_min
argument_list|(
name|sc
argument_list|,
operator|&
name|input
argument_list|)
expr_stmt|;
comment|/* get VN max rate */
if|if
condition|(
name|sc
operator|->
name|port
operator|.
name|pmf
condition|)
block|{
for|for
control|(
name|vn
operator|=
name|VN_0
init|;
name|vn
operator|<
name|SC_MAX_VN_NUM
argument_list|(
name|sc
argument_list|)
condition|;
name|vn
operator|++
control|)
block|{
name|bxe_calc_vn_max
argument_list|(
name|sc
argument_list|,
name|vn
argument_list|,
operator|&
name|input
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* always enable rate shaping and fairness */
name|input
operator|.
name|flags
operator|.
name|cmng_enables
operator||=
name|CMNG_FLAGS_PER_PORT_RATE_SHAPING_VN
expr_stmt|;
name|ecore_init_cmng
argument_list|(
operator|&
name|input
argument_list|,
operator|&
name|sc
operator|->
name|cmng
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* rate shaping and fairness are disabled */
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"rate shaping and fairness have been disabled\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_get_cmng_fns_mode
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|CHIP_REV_IS_SLOW
argument_list|(
name|sc
argument_list|)
condition|)
block|{
return|return
operator|(
name|CMNG_FNS_NONE
operator|)
return|;
block|}
if|if
condition|(
name|IS_MF
argument_list|(
name|sc
argument_list|)
condition|)
block|{
return|return
operator|(
name|CMNG_FNS_MINMAX
operator|)
return|;
block|}
return|return
operator|(
name|CMNG_FNS_NONE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|storm_memset_cmng
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cmng_init
modifier|*
name|cmng
parameter_list|,
name|uint8_t
name|port
parameter_list|)
block|{
name|int
name|vn
decl_stmt|;
name|int
name|func
decl_stmt|;
name|uint32_t
name|addr
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|addr
operator|=
operator|(
name|BAR_XSTRORM_INTMEM
operator|+
name|XSTORM_CMNG_PER_PORT_VARS_OFFSET
argument_list|(
name|port
argument_list|)
operator|)
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|cmng_struct_per_port
argument_list|)
expr_stmt|;
name|ecore_storm_memset_struct
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|cmng
operator|->
name|port
argument_list|)
expr_stmt|;
for|for
control|(
name|vn
operator|=
name|VN_0
init|;
name|vn
operator|<
name|SC_MAX_VN_NUM
argument_list|(
name|sc
argument_list|)
condition|;
name|vn
operator|++
control|)
block|{
name|func
operator|=
name|func_by_vn
argument_list|(
name|sc
argument_list|,
name|vn
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
name|BAR_XSTRORM_INTMEM
operator|+
name|XSTORM_RATE_SHAPING_PER_VN_VARS_OFFSET
argument_list|(
name|func
argument_list|)
operator|)
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|rate_shaping_vars_per_vn
argument_list|)
expr_stmt|;
name|ecore_storm_memset_struct
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|cmng
operator|->
name|vnic
operator|.
name|vnic_max_rate
index|[
name|vn
index|]
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
name|BAR_XSTRORM_INTMEM
operator|+
name|XSTORM_FAIRNESS_PER_VN_VARS_OFFSET
argument_list|(
name|func
argument_list|)
operator|)
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|fairness_vars_per_vn
argument_list|)
expr_stmt|;
name|ecore_storm_memset_struct
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|cmng
operator|->
name|vnic
operator|.
name|vnic_min_rate
index|[
name|vn
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_pf_init
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bxe_func_init_params
name|func_init
init|=
block|{
literal|0
block|}
decl_stmt|;
name|struct
name|event_ring_data
name|eq_data
init|=
block|{
block|{
literal|0
block|}
block|}
decl_stmt|;
name|uint16_t
name|flags
decl_stmt|;
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* reset IGU PF statistics: MSIX + ATTN */
comment|/* PF */
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|IGU_REG_STATISTIC_NUM_MESSAGE_SENT
operator|+
operator|(
name|BXE_IGU_STAS_MSG_VF_CNT
operator|*
literal|4
operator|)
operator|+
operator|(
operator|(
name|CHIP_IS_MODE_4_PORT
argument_list|(
name|sc
argument_list|)
condition|?
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
else|:
name|SC_VN
argument_list|(
name|sc
argument_list|)
operator|)
operator|*
literal|4
operator|)
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ATTN */
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|IGU_REG_STATISTIC_NUM_MESSAGE_SENT
operator|+
operator|(
name|BXE_IGU_STAS_MSG_VF_CNT
operator|*
literal|4
operator|)
operator|+
operator|(
name|BXE_IGU_STAS_MSG_PF_CNT
operator|*
literal|4
operator|)
operator|+
operator|(
operator|(
name|CHIP_IS_MODE_4_PORT
argument_list|(
name|sc
argument_list|)
condition|?
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
else|:
name|SC_VN
argument_list|(
name|sc
argument_list|)
operator|)
operator|*
literal|4
operator|)
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* function setup flags */
name|flags
operator|=
operator|(
name|FUNC_FLG_STATS
operator||
name|FUNC_FLG_LEADING
operator||
name|FUNC_FLG_SPQ
operator|)
expr_stmt|;
comment|/*      * This flag is relevant for E1x only.      * E2 doesn't have a TPA configuration in a function level.      */
name|flags
operator||=
operator|(
name|if_getcapenable
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|&
name|IFCAP_LRO
operator|)
condition|?
name|FUNC_FLG_TPA
else|:
literal|0
expr_stmt|;
name|func_init
operator|.
name|func_flgs
operator|=
name|flags
expr_stmt|;
name|func_init
operator|.
name|pf_id
operator|=
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|func_init
operator|.
name|func_id
operator|=
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|func_init
operator|.
name|spq_map
operator|=
name|sc
operator|->
name|spq_dma
operator|.
name|paddr
expr_stmt|;
name|func_init
operator|.
name|spq_prod
operator|=
name|sc
operator|->
name|spq_prod_idx
expr_stmt|;
name|bxe_func_init
argument_list|(
name|sc
argument_list|,
operator|&
name|func_init
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sc
operator|->
name|cmng
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cmng_struct_per_port
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Congestion management values depend on the link rate.      * There is no active link so initial link rate is set to 10Gbps.      * When the link comes up the congestion management values are      * re-calculated according to the actual link rate.      */
name|sc
operator|->
name|link_vars
operator|.
name|line_speed
operator|=
name|SPEED_10000
expr_stmt|;
name|bxe_cmng_fns_init
argument_list|(
name|sc
argument_list|,
name|TRUE
argument_list|,
name|bxe_get_cmng_fns_mode
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Only the PMF sets the HW */
if|if
condition|(
name|sc
operator|->
name|port
operator|.
name|pmf
condition|)
block|{
name|storm_memset_cmng
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|cmng
argument_list|,
name|SC_PORT
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* init Event Queue - PCI bus guarantees correct endainity */
name|eq_data
operator|.
name|base_addr
operator|.
name|hi
operator|=
name|U64_HI
argument_list|(
name|sc
operator|->
name|eq_dma
operator|.
name|paddr
argument_list|)
expr_stmt|;
name|eq_data
operator|.
name|base_addr
operator|.
name|lo
operator|=
name|U64_LO
argument_list|(
name|sc
operator|->
name|eq_dma
operator|.
name|paddr
argument_list|)
expr_stmt|;
name|eq_data
operator|.
name|producer
operator|=
name|sc
operator|->
name|eq_prod
expr_stmt|;
name|eq_data
operator|.
name|index_id
operator|=
name|HC_SP_INDEX_EQ_CONS
expr_stmt|;
name|eq_data
operator|.
name|sb_id
operator|=
name|DEF_SB_ID
expr_stmt|;
name|storm_memset_eq_data
argument_list|(
name|sc
argument_list|,
operator|&
name|eq_data
argument_list|,
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_hc_int_enable
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|port
init|=
name|SC_PORT
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|uint32_t
name|addr
init|=
operator|(
name|port
operator|)
condition|?
name|HC_REG_CONFIG_1
else|:
name|HC_REG_CONFIG_0
decl_stmt|;
name|uint32_t
name|val
init|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|uint8_t
name|msix
init|=
operator|(
name|sc
operator|->
name|interrupt_mode
operator|==
name|INTR_MODE_MSIX
operator|)
condition|?
name|TRUE
else|:
name|FALSE
decl_stmt|;
name|uint8_t
name|single_msix
init|=
operator|(
operator|(
name|sc
operator|->
name|interrupt_mode
operator|==
name|INTR_MODE_MSIX
operator|)
operator|&&
operator|(
name|sc
operator|->
name|intr_count
operator|==
literal|1
operator|)
operator|)
condition|?
name|TRUE
else|:
name|FALSE
decl_stmt|;
name|uint8_t
name|msi
init|=
operator|(
name|sc
operator|->
name|interrupt_mode
operator|==
name|INTR_MODE_MSI
operator|)
condition|?
name|TRUE
else|:
name|FALSE
decl_stmt|;
if|if
condition|(
name|msix
condition|)
block|{
name|val
operator|&=
operator|~
operator|(
name|HC_CONFIG_0_REG_SINGLE_ISR_EN_0
operator||
name|HC_CONFIG_0_REG_INT_LINE_EN_0
operator|)
expr_stmt|;
name|val
operator||=
operator|(
name|HC_CONFIG_0_REG_MSI_MSIX_INT_EN_0
operator||
name|HC_CONFIG_0_REG_ATTN_BIT_EN_0
operator|)
expr_stmt|;
if|if
condition|(
name|single_msix
condition|)
block|{
name|val
operator||=
name|HC_CONFIG_0_REG_SINGLE_ISR_EN_0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|msi
condition|)
block|{
name|val
operator|&=
operator|~
name|HC_CONFIG_0_REG_INT_LINE_EN_0
expr_stmt|;
name|val
operator||=
operator|(
name|HC_CONFIG_0_REG_SINGLE_ISR_EN_0
operator||
name|HC_CONFIG_0_REG_MSI_MSIX_INT_EN_0
operator||
name|HC_CONFIG_0_REG_ATTN_BIT_EN_0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|val
operator||=
operator|(
name|HC_CONFIG_0_REG_SINGLE_ISR_EN_0
operator||
name|HC_CONFIG_0_REG_MSI_MSIX_INT_EN_0
operator||
name|HC_CONFIG_0_REG_INT_LINE_EN_0
operator||
name|HC_CONFIG_0_REG_ATTN_BIT_EN_0
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_INTR
argument_list|,
literal|"write %x to HC %d (addr 0x%x)\n"
argument_list|,
name|val
argument_list|,
name|port
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|HC_CONFIG_0_REG_MSI_MSIX_INT_EN_0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|HC_REG_INT_MASK
operator|+
name|port
operator|*
literal|4
operator|)
argument_list|,
literal|0x1FFFF
argument_list|)
expr_stmt|;
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_INTR
argument_list|,
literal|"write %x to HC %d (addr 0x%x) mode %s\n"
argument_list|,
name|val
argument_list|,
name|port
argument_list|,
name|addr
argument_list|,
operator|(
operator|(
name|msix
operator|)
condition|?
literal|"MSI-X"
else|:
operator|(
operator|(
name|msi
operator|)
condition|?
literal|"MSI"
else|:
literal|"INTx"
operator|)
operator|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* ensure that HC_CONFIG is written before leading/trailing edge config */
name|mb
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* init leading/trailing edge */
if|if
condition|(
name|IS_MF
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|val
operator|=
operator|(
literal|0xee0f
operator||
operator|(
literal|1
operator|<<
operator|(
name|SC_VN
argument_list|(
name|sc
argument_list|)
operator|+
literal|4
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|port
operator|.
name|pmf
condition|)
block|{
comment|/* enable nig and gpio3 attention */
name|val
operator||=
literal|0x1100
expr_stmt|;
block|}
block|}
else|else
block|{
name|val
operator|=
literal|0xffff
expr_stmt|;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|HC_REG_TRAILING_EDGE_0
operator|+
name|port
operator|*
literal|8
operator|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|HC_REG_LEADING_EDGE_0
operator|+
name|port
operator|*
literal|8
operator|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
comment|/* make sure that interrupts are indeed enabled from here on */
name|mb
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_igu_int_enable
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|uint8_t
name|msix
init|=
operator|(
name|sc
operator|->
name|interrupt_mode
operator|==
name|INTR_MODE_MSIX
operator|)
condition|?
name|TRUE
else|:
name|FALSE
decl_stmt|;
name|uint8_t
name|single_msix
init|=
operator|(
operator|(
name|sc
operator|->
name|interrupt_mode
operator|==
name|INTR_MODE_MSIX
operator|)
operator|&&
operator|(
name|sc
operator|->
name|intr_count
operator|==
literal|1
operator|)
operator|)
condition|?
name|TRUE
else|:
name|FALSE
decl_stmt|;
name|uint8_t
name|msi
init|=
operator|(
name|sc
operator|->
name|interrupt_mode
operator|==
name|INTR_MODE_MSI
operator|)
condition|?
name|TRUE
else|:
name|FALSE
decl_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|IGU_REG_PF_CONFIGURATION
argument_list|)
expr_stmt|;
if|if
condition|(
name|msix
condition|)
block|{
name|val
operator|&=
operator|~
operator|(
name|IGU_PF_CONF_INT_LINE_EN
operator||
name|IGU_PF_CONF_SINGLE_ISR_EN
operator|)
expr_stmt|;
name|val
operator||=
operator|(
name|IGU_PF_CONF_MSI_MSIX_EN
operator||
name|IGU_PF_CONF_ATTN_BIT_EN
operator|)
expr_stmt|;
if|if
condition|(
name|single_msix
condition|)
block|{
name|val
operator||=
name|IGU_PF_CONF_SINGLE_ISR_EN
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|msi
condition|)
block|{
name|val
operator|&=
operator|~
name|IGU_PF_CONF_INT_LINE_EN
expr_stmt|;
name|val
operator||=
operator|(
name|IGU_PF_CONF_MSI_MSIX_EN
operator||
name|IGU_PF_CONF_ATTN_BIT_EN
operator||
name|IGU_PF_CONF_SINGLE_ISR_EN
operator|)
expr_stmt|;
block|}
else|else
block|{
name|val
operator|&=
operator|~
name|IGU_PF_CONF_MSI_MSIX_EN
expr_stmt|;
name|val
operator||=
operator|(
name|IGU_PF_CONF_INT_LINE_EN
operator||
name|IGU_PF_CONF_ATTN_BIT_EN
operator||
name|IGU_PF_CONF_SINGLE_ISR_EN
operator|)
expr_stmt|;
block|}
comment|/* clean previous status - need to configure igu prior to ack*/
if|if
condition|(
operator|(
operator|!
name|msix
operator|)
operator|||
name|single_msix
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|IGU_REG_PF_CONFIGURATION
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|bxe_ack_int
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|val
operator||=
name|IGU_PF_CONF_FUNC_EN
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_INTR
argument_list|,
literal|"write 0x%x to IGU mode %s\n"
argument_list|,
name|val
argument_list|,
operator|(
operator|(
name|msix
operator|)
condition|?
literal|"MSI-X"
else|:
operator|(
operator|(
name|msi
operator|)
condition|?
literal|"MSI"
else|:
literal|"INTx"
operator|)
operator|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|IGU_REG_PF_CONFIGURATION
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
comment|/* init leading/trailing edge */
if|if
condition|(
name|IS_MF
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|val
operator|=
operator|(
literal|0xee0f
operator||
operator|(
literal|1
operator|<<
operator|(
name|SC_VN
argument_list|(
name|sc
argument_list|)
operator|+
literal|4
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|port
operator|.
name|pmf
condition|)
block|{
comment|/* enable nig and gpio3 attention */
name|val
operator||=
literal|0x1100
expr_stmt|;
block|}
block|}
else|else
block|{
name|val
operator|=
literal|0xffff
expr_stmt|;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|IGU_REG_TRAILING_EDGE_LATCH
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|IGU_REG_LEADING_EDGE_LATCH
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* make sure that interrupts are indeed enabled from here on */
name|mb
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_int_enable
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|devinfo
operator|.
name|int_block
operator|==
name|INT_BLOCK_HC
condition|)
block|{
name|bxe_hc_int_enable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bxe_igu_int_enable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_hc_int_disable
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|port
init|=
name|SC_PORT
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|uint32_t
name|addr
init|=
operator|(
name|port
operator|)
condition|?
name|HC_REG_CONFIG_1
else|:
name|HC_REG_CONFIG_0
decl_stmt|;
name|uint32_t
name|val
init|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
decl_stmt|;
comment|/*      * In E1 we must use only PCI configuration space to disable MSI/MSIX      * capablility. It's forbidden to disable IGU_PF_CONF_MSI_MSIX_EN in HC      * block      */
if|if
condition|(
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/*          * Since IGU_PF_CONF_MSI_MSIX_EN still always on use mask register          * to prevent from HC sending interrupts after we exit the function          */
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|HC_REG_INT_MASK
operator|+
name|port
operator|*
literal|4
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
name|HC_CONFIG_0_REG_SINGLE_ISR_EN_0
operator||
name|HC_CONFIG_0_REG_INT_LINE_EN_0
operator||
name|HC_CONFIG_0_REG_ATTN_BIT_EN_0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|val
operator|&=
operator|~
operator|(
name|HC_CONFIG_0_REG_SINGLE_ISR_EN_0
operator||
name|HC_CONFIG_0_REG_MSI_MSIX_INT_EN_0
operator||
name|HC_CONFIG_0_REG_INT_LINE_EN_0
operator||
name|HC_CONFIG_0_REG_ATTN_BIT_EN_0
operator|)
expr_stmt|;
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_INTR
argument_list|,
literal|"write %x to HC %d (addr 0x%x)\n"
argument_list|,
name|val
argument_list|,
name|port
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* flush all outstanding writes */
name|mb
argument_list|()
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
operator|!=
name|val
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"proper val not read from HC IGU!\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_igu_int_disable
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|val
init|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|IGU_REG_PF_CONFIGURATION
argument_list|)
decl_stmt|;
name|val
operator|&=
operator|~
operator|(
name|IGU_PF_CONF_MSI_MSIX_EN
operator||
name|IGU_PF_CONF_INT_LINE_EN
operator||
name|IGU_PF_CONF_ATTN_BIT_EN
operator|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_INTR
argument_list|,
literal|"write %x to IGU\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* flush all outstanding writes */
name|mb
argument_list|()
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|IGU_REG_PF_CONFIGURATION
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|IGU_REG_PF_CONFIGURATION
argument_list|)
operator|!=
name|val
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"proper val not read from IGU!\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_int_disable
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|devinfo
operator|.
name|int_block
operator|==
name|INT_BLOCK_HC
condition|)
block|{
name|bxe_hc_int_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bxe_igu_int_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_nic_init
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|load_code
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|bxe_init_eth_fp
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|rmb
argument_list|()
expr_stmt|;
comment|/* ensure status block indices were read */
name|bxe_init_rx_rings
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_init_tx_rings
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_VF
argument_list|(
name|sc
argument_list|)
condition|)
block|{
return|return;
block|}
comment|/* initialize MOD_ABS interrupts */
name|elink_init_mod_abs_int
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|link_vars
argument_list|,
name|sc
operator|->
name|devinfo
operator|.
name|chip_id
argument_list|,
name|sc
operator|->
name|devinfo
operator|.
name|shmem_base
argument_list|,
name|sc
operator|->
name|devinfo
operator|.
name|shmem2_base
argument_list|,
name|SC_PORT
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|bxe_init_def_sb
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_update_dsb_idx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_init_sp_ring
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_init_eq_ring
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_init_internal
argument_list|(
name|sc
argument_list|,
name|load_code
argument_list|)
expr_stmt|;
name|bxe_pf_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_stats_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* flush all before enabling interrupts */
name|mb
argument_list|()
expr_stmt|;
name|bxe_int_enable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* check for SPIO5 */
name|bxe_attn_int_deasserted0
argument_list|(
name|sc
argument_list|,
name|REG_RD
argument_list|(
name|sc
argument_list|,
operator|(
name|MISC_REG_AEU_AFTER_INVERT_1_FUNC_0
operator|+
name|SC_PORT
argument_list|(
name|sc
argument_list|)
operator|*
literal|4
operator|)
argument_list|)
operator|&
name|AEU_INPUTS_ATTN_BITS_SPIO5
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|bxe_init_objs
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* mcast rules must be added to tx if tx switching is enabled */
name|ecore_obj_type
name|o_type
init|=
operator|(
name|sc
operator|->
name|flags
operator|&
name|BXE_TX_SWITCHING
operator|)
condition|?
name|ECORE_OBJ_TYPE_RX_TX
else|:
name|ECORE_OBJ_TYPE_RX
decl_stmt|;
comment|/* RX_MODE controlling object */
name|ecore_init_rx_mode_obj
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rx_mode_obj
argument_list|)
expr_stmt|;
comment|/* multicast configuration controlling object */
name|ecore_init_mcast_obj
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|mcast_obj
argument_list|,
name|sc
operator|->
name|fp
index|[
literal|0
index|]
operator|.
name|cl_id
argument_list|,
name|sc
operator|->
name|fp
index|[
literal|0
index|]
operator|.
name|index
argument_list|,
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
argument_list|,
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
argument_list|,
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|mcast_rdata
argument_list|)
argument_list|,
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|mcast_rdata
argument_list|)
argument_list|,
name|ECORE_FILTER_MCAST_PENDING
argument_list|,
operator|&
name|sc
operator|->
name|sp_state
argument_list|,
name|o_type
argument_list|)
expr_stmt|;
comment|/* Setup CAM credit pools */
name|ecore_init_mac_credit_pool
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|macs_pool
argument_list|,
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
argument_list|,
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|?
name|VNICS_PER_PORT
argument_list|(
name|sc
argument_list|)
else|:
name|VNICS_PER_PATH
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|ecore_init_vlan_credit_pool
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|vlans_pool
argument_list|,
name|SC_ABS_FUNC
argument_list|(
name|sc
argument_list|)
operator|>>
literal|1
argument_list|,
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|?
name|VNICS_PER_PORT
argument_list|(
name|sc
argument_list|)
else|:
name|VNICS_PER_PATH
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* RSS configuration object */
name|ecore_init_rss_config_obj
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rss_conf_obj
argument_list|,
name|sc
operator|->
name|fp
index|[
literal|0
index|]
operator|.
name|cl_id
argument_list|,
name|sc
operator|->
name|fp
index|[
literal|0
index|]
operator|.
name|index
argument_list|,
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
argument_list|,
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
argument_list|,
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|rss_rdata
argument_list|)
argument_list|,
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|rss_rdata
argument_list|)
argument_list|,
name|ECORE_FILTER_RSS_CONF_PENDING
argument_list|,
operator|&
name|sc
operator|->
name|sp_state
argument_list|,
name|ECORE_OBJ_TYPE_RX
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the function. This must be called before sending CLIENT_SETUP  * for the first client.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|bxe_func_start
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ecore_func_state_params
name|func_params
init|=
block|{
name|NULL
block|}
decl_stmt|;
name|struct
name|ecore_func_start_params
modifier|*
name|start_params
init|=
operator|&
name|func_params
operator|.
name|params
operator|.
name|start
decl_stmt|;
comment|/* Prepare parameters for function state transitions */
name|bit_set
argument_list|(
operator|&
name|func_params
operator|.
name|ramrod_flags
argument_list|,
name|RAMROD_COMP_WAIT
argument_list|)
expr_stmt|;
name|func_params
operator|.
name|f_obj
operator|=
operator|&
name|sc
operator|->
name|func_obj
expr_stmt|;
name|func_params
operator|.
name|cmd
operator|=
name|ECORE_F_CMD_START
expr_stmt|;
comment|/* Function parameters */
name|start_params
operator|->
name|mf_mode
operator|=
name|sc
operator|->
name|devinfo
operator|.
name|mf_info
operator|.
name|mf_mode
expr_stmt|;
name|start_params
operator|->
name|sd_vlan_tag
operator|=
name|OVLAN
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E2
argument_list|(
name|sc
argument_list|)
operator|||
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|start_params
operator|->
name|network_cos_mode
operator|=
name|STATIC_COS
expr_stmt|;
block|}
else|else
block|{
comment|/* CHIP_IS_E1X */
name|start_params
operator|->
name|network_cos_mode
operator|=
name|FW_WRR
expr_stmt|;
block|}
comment|//start_params->gre_tunnel_mode = 0;
comment|//start_params->gre_tunnel_rss  = 0;
return|return
operator|(
name|ecore_func_state_change
argument_list|(
name|sc
argument_list|,
operator|&
name|func_params
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_set_power_state
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|state
parameter_list|)
block|{
name|uint16_t
name|pmcsr
decl_stmt|;
comment|/* If there is no power capability, silently succeed */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|devinfo
operator|.
name|pcie_cap_flags
operator|&
name|BXE_PM_CAPABLE_FLAG
operator|)
condition|)
block|{
name|BLOGW
argument_list|(
name|sc
argument_list|,
literal|"No power capability\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pmcsr
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
operator|(
name|sc
operator|->
name|devinfo
operator|.
name|pcie_pm_cap_reg
operator|+
name|PCIR_POWER_STATUS
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|PCI_PM_D0
case|:
name|pci_write_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
operator|(
name|sc
operator|->
name|devinfo
operator|.
name|pcie_pm_cap_reg
operator|+
name|PCIR_POWER_STATUS
operator|)
argument_list|,
operator|(
operator|(
name|pmcsr
operator|&
operator|~
name|PCIM_PSTAT_DMASK
operator|)
operator||
name|PCIM_PSTAT_PME
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmcsr
operator|&
name|PCIM_PSTAT_DMASK
condition|)
block|{
comment|/* delay required during transition out of D3hot */
name|DELAY
argument_list|(
literal|20000
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PCI_PM_D3hot
case|:
comment|/* XXX if there are other clients above don't shut down the power */
comment|/* don't shut down the power for emulation and FPGA */
if|if
condition|(
name|CHIP_REV_IS_SLOW
argument_list|(
name|sc
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pmcsr
operator|&=
operator|~
name|PCIM_PSTAT_DMASK
expr_stmt|;
name|pmcsr
operator||=
name|PCIM_PSTAT_D3
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|wol
condition|)
block|{
name|pmcsr
operator||=
name|PCIM_PSTAT_PMEENABLE
expr_stmt|;
block|}
name|pci_write_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
operator|(
name|sc
operator|->
name|devinfo
operator|.
name|pcie_pm_cap_reg
operator|+
name|PCIR_POWER_STATUS
operator|)
argument_list|,
name|pmcsr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/*          * No more memory access after this point until device is brought back          * to D0 state.          */
break|break;
default|default:
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Can't support PCI power state = 0x%x pmcsr 0x%x\n"
argument_list|,
name|state
argument_list|,
name|pmcsr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* return true if succeeded to acquire the lock */
end_comment

begin_function
specifier|static
name|uint8_t
name|bxe_trylock_hw_lock
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|resource
parameter_list|)
block|{
name|uint32_t
name|lock_status
decl_stmt|;
name|uint32_t
name|resource_bit
init|=
operator|(
literal|1
operator|<<
name|resource
operator|)
decl_stmt|;
name|int
name|func
init|=
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|uint32_t
name|hw_lock_control_reg
decl_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Trying to take a resource lock 0x%x\n"
argument_list|,
name|resource
argument_list|)
expr_stmt|;
comment|/* Validating that the resource is within range */
if|if
condition|(
name|resource
operator|>
name|HW_LOCK_MAX_RESOURCE_VALUE
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"resource(0x%x)> HW_LOCK_MAX_RESOURCE_VALUE(0x%x)\n"
argument_list|,
name|resource
argument_list|,
name|HW_LOCK_MAX_RESOURCE_VALUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|func
operator|<=
literal|5
condition|)
block|{
name|hw_lock_control_reg
operator|=
operator|(
name|MISC_REG_DRIVER_CONTROL_1
operator|+
name|func
operator|*
literal|8
operator|)
expr_stmt|;
block|}
else|else
block|{
name|hw_lock_control_reg
operator|=
operator|(
name|MISC_REG_DRIVER_CONTROL_7
operator|+
operator|(
name|func
operator|-
literal|6
operator|)
operator|*
literal|8
operator|)
expr_stmt|;
block|}
comment|/* try to acquire the lock */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|hw_lock_control_reg
operator|+
literal|4
argument_list|,
name|resource_bit
argument_list|)
expr_stmt|;
name|lock_status
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|hw_lock_control_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock_status
operator|&
name|resource_bit
condition|)
block|{
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to get a resource lock 0x%x func %d "
literal|"lock_status 0x%x resource_bit 0x%x\n"
argument_list|,
name|resource
argument_list|,
name|func
argument_list|,
name|lock_status
argument_list|,
name|resource_bit
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the recovery leader resource id according to the engine this function  * belongs to. Currently only only 2 engines is supported.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_get_leader_lock_resource
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|SC_PATH
argument_list|(
name|sc
argument_list|)
condition|)
block|{
return|return
operator|(
name|HW_LOCK_RESOURCE_RECOVERY_LEADER_1
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|HW_LOCK_RESOURCE_RECOVERY_LEADER_0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* try to acquire a leader lock for current engine */
end_comment

begin_function
specifier|static
name|uint8_t
name|bxe_trylock_leader_lock
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
name|bxe_trylock_hw_lock
argument_list|(
name|sc
argument_list|,
name|bxe_get_leader_lock_resource
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_release_leader_lock
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
name|bxe_release_hw_lock
argument_list|(
name|sc
argument_list|,
name|bxe_get_leader_lock_resource
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* close gates #2, #3 and #4 */
end_comment

begin_function
specifier|static
name|void
name|bxe_set_234_gates
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|close
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
comment|/* gates #2 and #4a are closed/opened for "not E1" only */
if|if
condition|(
operator|!
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* #4 */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP_REG_HST_DISCARD_DOORBELLS
argument_list|,
operator|!
operator|!
name|close
argument_list|)
expr_stmt|;
comment|/* #2 */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP_REG_HST_DISCARD_INTERNAL_WRITES
argument_list|,
operator|!
operator|!
name|close
argument_list|)
expr_stmt|;
block|}
comment|/* #3 */
if|if
condition|(
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* prevent interrupts from HC on both ports */
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|HC_REG_CONFIG_1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|HC_REG_CONFIG_1
argument_list|,
operator|(
operator|!
name|close
operator|)
condition|?
operator|(
name|val
operator||
name|HC_CONFIG_1_REG_BLOCK_DISABLE_1
operator|)
else|:
operator|(
name|val
operator|&
operator|~
operator|(
name|uint32_t
operator|)
name|HC_CONFIG_1_REG_BLOCK_DISABLE_1
operator|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|HC_REG_CONFIG_0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|HC_REG_CONFIG_0
argument_list|,
operator|(
operator|!
name|close
operator|)
condition|?
operator|(
name|val
operator||
name|HC_CONFIG_0_REG_BLOCK_DISABLE_0
operator|)
else|:
operator|(
name|val
operator|&
operator|~
operator|(
name|uint32_t
operator|)
name|HC_CONFIG_0_REG_BLOCK_DISABLE_0
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Prevent incoming interrupts in IGU */
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|IGU_REG_BLOCK_CONFIGURATION
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|IGU_REG_BLOCK_CONFIGURATION
argument_list|,
operator|(
operator|!
name|close
operator|)
condition|?
operator|(
name|val
operator||
name|IGU_BLOCK_CONFIGURATION_REG_BLOCK_ENABLE
operator|)
else|:
operator|(
name|val
operator|&
operator|~
operator|(
name|uint32_t
operator|)
name|IGU_BLOCK_CONFIGURATION_REG_BLOCK_ENABLE
operator|)
argument_list|)
expr_stmt|;
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"%s gates #2, #3 and #4\n"
argument_list|,
name|close
condition|?
literal|"closing"
else|:
literal|"opening"
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* poll for pending writes bit, it should get cleared in no more than 1s */
end_comment

begin_function
specifier|static
name|int
name|bxe_er_poll_igu_vq
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|cnt
init|=
literal|1000
decl_stmt|;
name|uint32_t
name|pend_bits
init|=
literal|0
decl_stmt|;
do|do
block|{
name|pend_bits
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|IGU_REG_PENDING_BITS_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|pend_bits
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|cnt
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Still pending IGU requests bits=0x%08x!\n"
argument_list|,
name|pend_bits
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SHARED_MF_CLP_MAGIC
value|0x80000000
end_define

begin_comment
comment|/* 'magic' bit */
end_comment

begin_function
specifier|static
name|void
name|bxe_clp_reset_prep
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
modifier|*
name|magic_val
parameter_list|)
block|{
comment|/* Do some magic... */
name|uint32_t
name|val
init|=
name|MFCFG_RD
argument_list|(
name|sc
argument_list|,
name|shared_mf_config
operator|.
name|clp_mb
argument_list|)
decl_stmt|;
operator|*
name|magic_val
operator|=
name|val
operator|&
name|SHARED_MF_CLP_MAGIC
expr_stmt|;
name|MFCFG_WR
argument_list|(
name|sc
argument_list|,
name|shared_mf_config
operator|.
name|clp_mb
argument_list|,
name|val
operator||
name|SHARED_MF_CLP_MAGIC
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* restore the value of the 'magic' bit */
end_comment

begin_function
specifier|static
name|void
name|bxe_clp_reset_done
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|magic_val
parameter_list|)
block|{
comment|/* Restore the 'magic' bit value... */
name|uint32_t
name|val
init|=
name|MFCFG_RD
argument_list|(
name|sc
argument_list|,
name|shared_mf_config
operator|.
name|clp_mb
argument_list|)
decl_stmt|;
name|MFCFG_WR
argument_list|(
name|sc
argument_list|,
name|shared_mf_config
operator|.
name|clp_mb
argument_list|,
operator|(
name|val
operator|&
operator|(
operator|~
name|SHARED_MF_CLP_MAGIC
operator|)
operator|)
operator||
name|magic_val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* prepare for MCP reset, takes care of CLP configurations */
end_comment

begin_function
specifier|static
name|void
name|bxe_reset_mcp_prep
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
modifier|*
name|magic_val
parameter_list|)
block|{
name|uint32_t
name|shmem
decl_stmt|;
name|uint32_t
name|validity_offset
decl_stmt|;
comment|/* set `magic' bit in order to save MF config */
if|if
condition|(
operator|!
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|bxe_clp_reset_prep
argument_list|(
name|sc
argument_list|,
name|magic_val
argument_list|)
expr_stmt|;
block|}
comment|/* get shmem offset */
name|shmem
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_SHARED_MEM_ADDR
argument_list|)
expr_stmt|;
name|validity_offset
operator|=
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|validity_map
index|[
name|SC_PORT
argument_list|(
name|sc
argument_list|)
index|]
argument_list|)
expr_stmt|;
comment|/* Clear validity map flags */
if|if
condition|(
name|shmem
operator|>
literal|0
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|shmem
operator|+
name|validity_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|MCP_TIMEOUT
value|5000
end_define

begin_comment
comment|/* 5 seconds (in ms) */
end_comment

begin_define
define|#
directive|define
name|MCP_ONE_TIMEOUT
value|100
end_define

begin_comment
comment|/* 100 ms */
end_comment

begin_function
specifier|static
name|void
name|bxe_mcp_wait_one
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* special handling for emulation and FPGA (10 times longer) */
if|if
condition|(
name|CHIP_REV_IS_SLOW
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|DELAY
argument_list|(
operator|(
name|MCP_ONE_TIMEOUT
operator|*
literal|10
operator|)
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DELAY
argument_list|(
operator|(
name|MCP_ONE_TIMEOUT
operator|)
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* initialize shmem_base and waits for validity signature to appear */
end_comment

begin_function
specifier|static
name|int
name|bxe_init_shmem
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|cnt
init|=
literal|0
decl_stmt|;
name|uint32_t
name|val
init|=
literal|0
decl_stmt|;
do|do
block|{
name|sc
operator|->
name|devinfo
operator|.
name|shmem_base
operator|=
name|sc
operator|->
name|link_params
operator|.
name|shmem_base
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_SHARED_MEM_ADDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|devinfo
operator|.
name|shmem_base
condition|)
block|{
name|val
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|validity_map
index|[
name|SC_PORT
argument_list|(
name|sc
argument_list|)
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|SHR_MEM_VALIDITY_MB
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|bxe_mcp_wait_one
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|cnt
operator|++
operator|<
operator|(
name|MCP_TIMEOUT
operator|/
name|MCP_ONE_TIMEOUT
operator|)
condition|)
do|;
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"BAD MCP validity signature\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_reset_mcp_comp
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|magic_val
parameter_list|)
block|{
name|int
name|rc
init|=
name|bxe_init_shmem
argument_list|(
name|sc
argument_list|)
decl_stmt|;
comment|/* Restore the `magic' bit value */
if|if
condition|(
operator|!
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|bxe_clp_reset_done
argument_list|(
name|sc
argument_list|,
name|magic_val
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_pxp_prep
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
operator|!
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RD_START_INIT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RQ_RBC_DONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Reset the whole chip except for:  *      - PCIE core  *      - PCI Glue, PSWHST, PXP/PXP2 RF (all controlled by one reset bit)  *      - IGU  *      - MISC (including AEU)  *      - GRC  *      - RBCN, RBCP  */
end_comment

begin_function
specifier|static
name|void
name|bxe_process_kill_chip_reset
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|global
parameter_list|)
block|{
name|uint32_t
name|not_reset_mask1
decl_stmt|,
name|reset_mask1
decl_stmt|,
name|not_reset_mask2
decl_stmt|,
name|reset_mask2
decl_stmt|;
name|uint32_t
name|global_bits2
decl_stmt|,
name|stay_reset2
decl_stmt|;
comment|/*      * Bits that have to be set in reset_mask2 if we want to reset 'global'      * (per chip) blocks.      */
name|global_bits2
operator|=
name|MISC_REGISTERS_RESET_REG_2_RST_MCP_N_RESET_CMN_CPU
operator||
name|MISC_REGISTERS_RESET_REG_2_RST_MCP_N_RESET_CMN_CORE
expr_stmt|;
comment|/*      * Don't reset the following blocks.      * Important: per port blocks (such as EMAC, BMAC, UMAC) can't be      *            reset, as in 4 port device they might still be owned      *            by the MCP (there is only one leader per path).      */
name|not_reset_mask1
operator|=
name|MISC_REGISTERS_RESET_REG_1_RST_HC
operator||
name|MISC_REGISTERS_RESET_REG_1_RST_PXPV
operator||
name|MISC_REGISTERS_RESET_REG_1_RST_PXP
expr_stmt|;
name|not_reset_mask2
operator|=
name|MISC_REGISTERS_RESET_REG_2_RST_PCI_MDIO
operator||
name|MISC_REGISTERS_RESET_REG_2_RST_EMAC0_HARD_CORE
operator||
name|MISC_REGISTERS_RESET_REG_2_RST_EMAC1_HARD_CORE
operator||
name|MISC_REGISTERS_RESET_REG_2_RST_MISC_CORE
operator||
name|MISC_REGISTERS_RESET_REG_2_RST_RBCN
operator||
name|MISC_REGISTERS_RESET_REG_2_RST_GRC
operator||
name|MISC_REGISTERS_RESET_REG_2_RST_MCP_N_RESET_REG_HARD_CORE
operator||
name|MISC_REGISTERS_RESET_REG_2_RST_MCP_N_HARD_CORE_RST_B
operator||
name|MISC_REGISTERS_RESET_REG_2_RST_ATC
operator||
name|MISC_REGISTERS_RESET_REG_2_PGLC
operator||
name|MISC_REGISTERS_RESET_REG_2_RST_BMAC0
operator||
name|MISC_REGISTERS_RESET_REG_2_RST_BMAC1
operator||
name|MISC_REGISTERS_RESET_REG_2_RST_EMAC0
operator||
name|MISC_REGISTERS_RESET_REG_2_RST_EMAC1
operator||
name|MISC_REGISTERS_RESET_REG_2_UMAC0
operator||
name|MISC_REGISTERS_RESET_REG_2_UMAC1
expr_stmt|;
comment|/*      * Keep the following blocks in reset:      *  - all xxMACs are handled by the elink code.      */
name|stay_reset2
operator|=
name|MISC_REGISTERS_RESET_REG_2_XMAC
operator||
name|MISC_REGISTERS_RESET_REG_2_XMAC_SOFT
expr_stmt|;
comment|/* Full reset masks according to the chip */
name|reset_mask1
operator|=
literal|0xffffffff
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
name|reset_mask2
operator|=
literal|0xffff
expr_stmt|;
elseif|else
if|if
condition|(
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
condition|)
name|reset_mask2
operator|=
literal|0x1ffff
expr_stmt|;
elseif|else
if|if
condition|(
name|CHIP_IS_E2
argument_list|(
name|sc
argument_list|)
condition|)
name|reset_mask2
operator|=
literal|0xfffff
expr_stmt|;
else|else
comment|/* CHIP_IS_E3 */
name|reset_mask2
operator|=
literal|0x3ffffff
expr_stmt|;
comment|/* Don't reset global blocks unless we need to */
if|if
condition|(
operator|!
name|global
condition|)
name|reset_mask2
operator|&=
operator|~
name|global_bits2
expr_stmt|;
comment|/*      * In case of attention in the QM, we need to reset PXP      * (MISC_REGISTERS_RESET_REG_2_RST_PXP_RQ_RD_WR) before QM      * because otherwise QM reset would release 'close the gates' shortly      * before resetting the PXP, then the PSWRQ would send a write      * request to PGLUE. Then when PXP is reset, PGLUE would try to      * read the payload data from PSWWR, but PSWWR would not      * respond. The write queue in PGLUE would stuck, dmae commands      * would not return. Therefore it's important to reset the second      * reset register (containing the      * MISC_REGISTERS_RESET_REG_2_RST_PXP_RQ_RD_WR bit) before the      * first one (containing the MISC_REGISTERS_RESET_REG_1_RST_QM      * bit).      */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_2_CLEAR
argument_list|,
name|reset_mask2
operator|&
operator|(
operator|~
name|not_reset_mask2
operator|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_1_CLEAR
argument_list|,
name|reset_mask1
operator|&
operator|(
operator|~
name|not_reset_mask1
operator|)
argument_list|)
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_2_SET
argument_list|,
name|reset_mask2
operator|&
operator|(
operator|~
name|stay_reset2
operator|)
argument_list|)
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_1_SET
argument_list|,
name|reset_mask1
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_process_kill
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|global
parameter_list|)
block|{
name|int
name|cnt
init|=
literal|1000
decl_stmt|;
name|uint32_t
name|val
init|=
literal|0
decl_stmt|;
name|uint32_t
name|sr_cnt
decl_stmt|,
name|blk_cnt
decl_stmt|,
name|port_is_idle_0
decl_stmt|,
name|port_is_idle_1
decl_stmt|,
name|pgl_exp_rom2
decl_stmt|;
name|uint32_t
name|tags_63_32
init|=
literal|0
decl_stmt|;
comment|/* Empty the Tetris buffer, wait for 1s */
do|do
block|{
name|sr_cnt
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RD_SR_CNT
argument_list|)
expr_stmt|;
name|blk_cnt
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RD_BLK_CNT
argument_list|)
expr_stmt|;
name|port_is_idle_0
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RD_PORT_IS_IDLE_0
argument_list|)
expr_stmt|;
name|port_is_idle_1
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RD_PORT_IS_IDLE_1
argument_list|)
expr_stmt|;
name|pgl_exp_rom2
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_PGL_EXP_ROM2
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|tags_63_32
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|PGLUE_B_REG_TAGS_63_32
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sr_cnt
operator|==
literal|0x7e
operator|)
operator|&&
operator|(
name|blk_cnt
operator|==
literal|0xa0
operator|)
operator|&&
operator|(
operator|(
name|port_is_idle_0
operator|&
literal|0x1
operator|)
operator|==
literal|0x1
operator|)
operator|&&
operator|(
operator|(
name|port_is_idle_1
operator|&
literal|0x1
operator|)
operator|==
literal|0x1
operator|)
operator|&&
operator|(
name|pgl_exp_rom2
operator|==
literal|0xffffffff
operator|)
operator|&&
operator|(
operator|!
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
operator|||
operator|(
name|tags_63_32
operator|==
literal|0xffffffff
operator|)
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|cnt
operator|--
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|cnt
operator|<=
literal|0
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"ERROR: Tetris buffer didn't get empty or there "
literal|"are still outstanding read requests after 1s! "
literal|"sr_cnt=0x%08x, blk_cnt=0x%08x, port_is_idle_0=0x%08x, "
literal|"port_is_idle_1=0x%08x, pgl_exp_rom2=0x%08x\n"
argument_list|,
name|sr_cnt
argument_list|,
name|blk_cnt
argument_list|,
name|port_is_idle_0
argument_list|,
name|port_is_idle_1
argument_list|,
name|pgl_exp_rom2
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|mb
argument_list|()
expr_stmt|;
comment|/* Close gates #2, #3 and #4 */
name|bxe_set_234_gates
argument_list|(
name|sc
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Poll for IGU VQs for 57712 and newer chips */
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
operator|&&
name|bxe_er_poll_igu_vq
argument_list|(
name|sc
argument_list|)
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* XXX indicate that "process kill" is in progress to MCP */
comment|/* clear "unprepared" bit */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_UNPREPARED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
comment|/* Make sure all is written to the chip before the reset */
name|wmb
argument_list|()
expr_stmt|;
comment|/*      * Wait for 1ms to empty GLUE and PCI-E core queues,      * PSWHST, GRC and PSWRD Tetris buffer.      */
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* Prepare to chip reset: */
comment|/* MCP */
if|if
condition|(
name|global
condition|)
block|{
name|bxe_reset_mcp_prep
argument_list|(
name|sc
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
block|}
comment|/* PXP */
name|bxe_pxp_prep
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
comment|/* reset the chip */
name|bxe_process_kill_chip_reset
argument_list|(
name|sc
argument_list|,
name|global
argument_list|)
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
comment|/* clear errors in PGB */
if|if
condition|(
operator|!
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PGLUE_B_REG_LATCHED_ERRORS_CLR
argument_list|,
literal|0x7f
argument_list|)
expr_stmt|;
comment|/* Recover after reset: */
comment|/* MCP */
if|if
condition|(
name|global
operator|&&
name|bxe_reset_mcp_comp
argument_list|(
name|sc
argument_list|,
name|val
argument_list|)
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* XXX add resetting the NO_MCP mode DB here */
comment|/* Open the gates #2, #3 and #4 */
name|bxe_set_234_gates
argument_list|(
name|sc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* XXX      * IGU/AEU preparation bring back the AEU/IGU to a reset state      * re-enable attentions      */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_leader_reset
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|uint8_t
name|global
init|=
name|bxe_reset_is_global
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|uint32_t
name|load_code
decl_stmt|;
comment|/*      * If not going to reset MCP, load "fake" driver to reset HW while      * driver is owner of the HW.      */
if|if
condition|(
operator|!
name|global
operator|&&
operator|!
name|BXE_NOMCP
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|load_code
operator|=
name|bxe_fw_command
argument_list|(
name|sc
argument_list|,
name|DRV_MSG_CODE_LOAD_REQ
argument_list|,
name|DRV_MSG_CODE_LOAD_REQ_WITH_LFA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|load_code
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"MCP response failure, aborting\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|exit_leader_reset
goto|;
block|}
if|if
condition|(
operator|(
name|load_code
operator|!=
name|FW_MSG_CODE_DRV_LOAD_COMMON_CHIP
operator|)
operator|&&
operator|(
name|load_code
operator|!=
name|FW_MSG_CODE_DRV_LOAD_COMMON
operator|)
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"MCP unexpected response, aborting\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|exit_leader_reset2
goto|;
block|}
name|load_code
operator|=
name|bxe_fw_command
argument_list|(
name|sc
argument_list|,
name|DRV_MSG_CODE_LOAD_DONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|load_code
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"MCP response failure, aborting\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|exit_leader_reset2
goto|;
block|}
block|}
comment|/* try to recover after the failure */
if|if
condition|(
name|bxe_process_kill
argument_list|(
name|sc
argument_list|,
name|global
argument_list|)
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Something bad occurred on engine %d!\n"
argument_list|,
name|SC_PATH
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|exit_leader_reset2
goto|;
block|}
comment|/*      * Clear the RESET_IN_PROGRESS and RESET_GLOBAL bits and update the driver      * state.      */
name|bxe_set_reset_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|global
condition|)
block|{
name|bxe_clear_reset_global
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|exit_leader_reset2
label|:
comment|/* unload "fake driver" if it was loaded */
if|if
condition|(
operator|!
name|global
operator|&&
operator|!
name|BXE_NOMCP
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|bxe_fw_command
argument_list|(
name|sc
argument_list|,
name|DRV_MSG_CODE_UNLOAD_REQ_WOL_MCP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bxe_fw_command
argument_list|(
name|sc
argument_list|,
name|DRV_MSG_CODE_UNLOAD_DONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|exit_leader_reset
label|:
name|sc
operator|->
name|is_leader
operator|=
literal|0
expr_stmt|;
name|bxe_release_leader_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * prepare INIT transition, parameters configured:  *   - HC configuration  *   - Queue's CDU context  */
end_comment

begin_function
specifier|static
name|void
name|bxe_pf_q_prep_init
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|struct
name|ecore_queue_init_params
modifier|*
name|init_params
parameter_list|)
block|{
name|uint8_t
name|cos
decl_stmt|;
name|int
name|cxt_index
decl_stmt|,
name|cxt_offset
decl_stmt|;
name|bxe_set_bit
argument_list|(
name|ECORE_Q_FLG_HC
argument_list|,
operator|&
name|init_params
operator|->
name|rx
operator|.
name|flags
argument_list|)
expr_stmt|;
name|bxe_set_bit
argument_list|(
name|ECORE_Q_FLG_HC
argument_list|,
operator|&
name|init_params
operator|->
name|tx
operator|.
name|flags
argument_list|)
expr_stmt|;
name|bxe_set_bit
argument_list|(
name|ECORE_Q_FLG_HC_EN
argument_list|,
operator|&
name|init_params
operator|->
name|rx
operator|.
name|flags
argument_list|)
expr_stmt|;
name|bxe_set_bit
argument_list|(
name|ECORE_Q_FLG_HC_EN
argument_list|,
operator|&
name|init_params
operator|->
name|tx
operator|.
name|flags
argument_list|)
expr_stmt|;
comment|/* HC rate */
name|init_params
operator|->
name|rx
operator|.
name|hc_rate
operator|=
name|sc
operator|->
name|hc_rx_ticks
condition|?
operator|(
literal|1000000
operator|/
name|sc
operator|->
name|hc_rx_ticks
operator|)
else|:
literal|0
expr_stmt|;
name|init_params
operator|->
name|tx
operator|.
name|hc_rate
operator|=
name|sc
operator|->
name|hc_tx_ticks
condition|?
operator|(
literal|1000000
operator|/
name|sc
operator|->
name|hc_tx_ticks
operator|)
else|:
literal|0
expr_stmt|;
comment|/* FW SB ID */
name|init_params
operator|->
name|rx
operator|.
name|fw_sb_id
operator|=
name|init_params
operator|->
name|tx
operator|.
name|fw_sb_id
operator|=
name|fp
operator|->
name|fw_sb_id
expr_stmt|;
comment|/* CQ index among the SB indices */
name|init_params
operator|->
name|rx
operator|.
name|sb_cq_index
operator|=
name|HC_INDEX_ETH_RX_CQ_CONS
expr_stmt|;
name|init_params
operator|->
name|tx
operator|.
name|sb_cq_index
operator|=
name|HC_INDEX_ETH_FIRST_TX_CQ_CONS
expr_stmt|;
comment|/* set maximum number of COSs supported by this queue */
name|init_params
operator|->
name|max_cos
operator|=
name|sc
operator|->
name|max_cos
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"fp %d setting queue params max cos to %d\n"
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|init_params
operator|->
name|max_cos
argument_list|)
expr_stmt|;
comment|/* set the context pointers queue object */
for|for
control|(
name|cos
operator|=
name|FIRST_TX_COS_INDEX
init|;
name|cos
operator|<
name|init_params
operator|->
name|max_cos
condition|;
name|cos
operator|++
control|)
block|{
comment|/* XXX change index/cid here if ever support multiple tx CoS */
comment|/* fp->txdata[cos]->cid */
name|cxt_index
operator|=
name|fp
operator|->
name|index
operator|/
name|ILT_PAGE_CIDS
expr_stmt|;
name|cxt_offset
operator|=
name|fp
operator|->
name|index
operator|-
operator|(
name|cxt_index
operator|*
name|ILT_PAGE_CIDS
operator|)
expr_stmt|;
name|init_params
operator|->
name|cxts
index|[
name|cos
index|]
operator|=
operator|&
name|sc
operator|->
name|context
index|[
name|cxt_index
index|]
operator|.
name|vcxt
index|[
name|cxt_offset
index|]
operator|.
name|eth
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* set flags that are common for the Tx-only and not normal connections */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|bxe_get_common_flags
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|uint8_t
name|zero_stats
parameter_list|)
block|{
name|unsigned
name|long
name|flags
init|=
literal|0
decl_stmt|;
comment|/* PF driver will always initialize the Queue to an ACTIVE state */
name|bxe_set_bit
argument_list|(
name|ECORE_Q_FLG_ACTIVE
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
comment|/*      * tx only connections collect statistics (on the same index as the      * parent connection). The statistics are zeroed when the parent      * connection is initialized.      */
name|bxe_set_bit
argument_list|(
name|ECORE_Q_FLG_STATS
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|zero_stats
condition|)
block|{
name|bxe_set_bit
argument_list|(
name|ECORE_Q_FLG_ZERO_STATS
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
block|}
comment|/*      * tx only connections can support tx-switching, though their      * CoS-ness doesn't survive the loopback      */
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|BXE_TX_SWITCHING
condition|)
block|{
name|bxe_set_bit
argument_list|(
name|ECORE_Q_FLG_TX_SWITCH
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
block|}
name|bxe_set_bit
argument_list|(
name|ECORE_Q_FLG_PCSUM_ON_PKT
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|flags
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|long
name|bxe_get_q_flags
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|uint8_t
name|leading
parameter_list|)
block|{
name|unsigned
name|long
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|IS_MF_SD
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|bxe_set_bit
argument_list|(
name|ECORE_Q_FLG_OV
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|if_getcapenable
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|&
name|IFCAP_LRO
condition|)
block|{
name|bxe_set_bit
argument_list|(
name|ECORE_Q_FLG_TPA
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800000
name|bxe_set_bit
argument_list|(
name|ECORE_Q_FLG_TPA_IPV6
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|leading
condition|)
block|{
name|bxe_set_bit
argument_list|(
name|ECORE_Q_FLG_LEADING_RSS
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
name|bxe_set_bit
argument_list|(
name|ECORE_Q_FLG_MCAST
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
block|}
name|bxe_set_bit
argument_list|(
name|ECORE_Q_FLG_VLAN
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
comment|/* merge with common flags */
return|return
operator|(
name|flags
operator||
name|bxe_get_common_flags
argument_list|(
name|sc
argument_list|,
name|fp
argument_list|,
name|TRUE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_pf_q_prep_general
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|struct
name|ecore_general_setup_params
modifier|*
name|gen_init
parameter_list|,
name|uint8_t
name|cos
parameter_list|)
block|{
name|gen_init
operator|->
name|stat_id
operator|=
name|bxe_stats_id
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|gen_init
operator|->
name|spcl_id
operator|=
name|fp
operator|->
name|cl_id
expr_stmt|;
name|gen_init
operator|->
name|mtu
operator|=
name|sc
operator|->
name|mtu
expr_stmt|;
name|gen_init
operator|->
name|cos
operator|=
name|cos
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_pf_rx_q_prep
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|struct
name|rxq_pause_params
modifier|*
name|pause
parameter_list|,
name|struct
name|ecore_rxq_setup_params
modifier|*
name|rxq_init
parameter_list|)
block|{
name|uint8_t
name|max_sge
init|=
literal|0
decl_stmt|;
name|uint16_t
name|sge_sz
init|=
literal|0
decl_stmt|;
name|uint16_t
name|tpa_agg_size
init|=
literal|0
decl_stmt|;
name|pause
operator|->
name|sge_th_lo
operator|=
name|SGE_TH_LO
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|pause
operator|->
name|sge_th_hi
operator|=
name|SGE_TH_HI
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* validate SGE ring has enough to cross high threshold */
if|if
condition|(
name|sc
operator|->
name|dropless_fc
operator|&&
operator|(
name|pause
operator|->
name|sge_th_hi
operator|+
name|FW_PREFETCH_CNT
operator|)
operator|>
operator|(
name|RX_SGE_USABLE_PER_PAGE
operator|*
name|RX_SGE_NUM_PAGES
operator|)
condition|)
block|{
name|BLOGW
argument_list|(
name|sc
argument_list|,
literal|"sge ring threshold limit\n"
argument_list|)
expr_stmt|;
block|}
comment|/* minimum max_aggregation_size is 2*MTU (two full buffers) */
name|tpa_agg_size
operator|=
operator|(
literal|2
operator|*
name|sc
operator|->
name|mtu
operator|)
expr_stmt|;
if|if
condition|(
name|tpa_agg_size
operator|<
name|sc
operator|->
name|max_aggregation_size
condition|)
block|{
name|tpa_agg_size
operator|=
name|sc
operator|->
name|max_aggregation_size
expr_stmt|;
block|}
name|max_sge
operator|=
name|SGE_PAGE_ALIGN
argument_list|(
name|sc
operator|->
name|mtu
argument_list|)
operator|>>
name|SGE_PAGE_SHIFT
expr_stmt|;
name|max_sge
operator|=
operator|(
operator|(
name|max_sge
operator|+
name|PAGES_PER_SGE
operator|-
literal|1
operator|)
operator|&
operator|(
operator|~
operator|(
name|PAGES_PER_SGE
operator|-
literal|1
operator|)
operator|)
operator|)
operator|>>
name|PAGES_PER_SGE_SHIFT
expr_stmt|;
name|sge_sz
operator|=
operator|(
name|uint16_t
operator|)
name|min
argument_list|(
name|SGE_PAGES
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
comment|/* pause - not for e1 */
if|if
condition|(
operator|!
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|pause
operator|->
name|bd_th_lo
operator|=
name|BD_TH_LO
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|pause
operator|->
name|bd_th_hi
operator|=
name|BD_TH_HI
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|pause
operator|->
name|rcq_th_lo
operator|=
name|RCQ_TH_LO
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|pause
operator|->
name|rcq_th_hi
operator|=
name|RCQ_TH_HI
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* validate rings have enough entries to cross high thresholds */
if|if
condition|(
name|sc
operator|->
name|dropless_fc
operator|&&
name|pause
operator|->
name|bd_th_hi
operator|+
name|FW_PREFETCH_CNT
operator|>
name|sc
operator|->
name|rx_ring_size
condition|)
block|{
name|BLOGW
argument_list|(
name|sc
argument_list|,
literal|"rx bd ring threshold limit\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|dropless_fc
operator|&&
name|pause
operator|->
name|rcq_th_hi
operator|+
name|FW_PREFETCH_CNT
operator|>
name|RCQ_NUM_PAGES
operator|*
name|RCQ_USABLE_PER_PAGE
condition|)
block|{
name|BLOGW
argument_list|(
name|sc
argument_list|,
literal|"rcq ring threshold limit\n"
argument_list|)
expr_stmt|;
block|}
name|pause
operator|->
name|pri_map
operator|=
literal|1
expr_stmt|;
block|}
comment|/* rxq setup */
name|rxq_init
operator|->
name|dscr_map
operator|=
name|fp
operator|->
name|rx_dma
operator|.
name|paddr
expr_stmt|;
name|rxq_init
operator|->
name|sge_map
operator|=
name|fp
operator|->
name|rx_sge_dma
operator|.
name|paddr
expr_stmt|;
name|rxq_init
operator|->
name|rcq_map
operator|=
name|fp
operator|->
name|rcq_dma
operator|.
name|paddr
expr_stmt|;
name|rxq_init
operator|->
name|rcq_np_map
operator|=
operator|(
name|fp
operator|->
name|rcq_dma
operator|.
name|paddr
operator|+
name|BCM_PAGE_SIZE
operator|)
expr_stmt|;
comment|/*      * This should be a maximum number of data bytes that may be      * placed on the BD (not including paddings).      */
name|rxq_init
operator|->
name|buf_sz
operator|=
operator|(
name|fp
operator|->
name|rx_buf_size
operator|-
name|IP_HEADER_ALIGNMENT_PADDING
operator|)
expr_stmt|;
name|rxq_init
operator|->
name|cl_qzone_id
operator|=
name|fp
operator|->
name|cl_qzone_id
expr_stmt|;
name|rxq_init
operator|->
name|tpa_agg_sz
operator|=
name|tpa_agg_size
expr_stmt|;
name|rxq_init
operator|->
name|sge_buf_sz
operator|=
name|sge_sz
expr_stmt|;
name|rxq_init
operator|->
name|max_sges_pkt
operator|=
name|max_sge
expr_stmt|;
name|rxq_init
operator|->
name|rss_engine_id
operator|=
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rxq_init
operator|->
name|mcast_engine_id
operator|=
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*      * Maximum number or simultaneous TPA aggregation for this Queue.      * For PF Clients it should be the maximum available number.      * VF driver(s) may want to define it to a smaller value.      */
name|rxq_init
operator|->
name|max_tpa_queues
operator|=
name|MAX_AGG_QS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rxq_init
operator|->
name|cache_line_log
operator|=
name|BXE_RX_ALIGN_SHIFT
expr_stmt|;
name|rxq_init
operator|->
name|fw_sb_id
operator|=
name|fp
operator|->
name|fw_sb_id
expr_stmt|;
name|rxq_init
operator|->
name|sb_cq_index
operator|=
name|HC_INDEX_ETH_RX_CQ_CONS
expr_stmt|;
comment|/*      * configure silent vlan removal      * if multi function mode is afex, then mask default vlan      */
if|if
condition|(
name|IS_MF_AFEX
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|rxq_init
operator|->
name|silent_removal_value
operator|=
name|sc
operator|->
name|devinfo
operator|.
name|mf_info
operator|.
name|afex_def_vlan_tag
expr_stmt|;
name|rxq_init
operator|->
name|silent_removal_mask
operator|=
name|EVL_VLID_MASK
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_pf_tx_q_prep
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|struct
name|ecore_txq_setup_params
modifier|*
name|txq_init
parameter_list|,
name|uint8_t
name|cos
parameter_list|)
block|{
comment|/*      * XXX If multiple CoS is ever supported then each fastpath structure      * will need to maintain tx producer/consumer/dma/etc values *per* CoS.      * fp->txdata[cos]->tx_dma.paddr;      */
name|txq_init
operator|->
name|dscr_map
operator|=
name|fp
operator|->
name|tx_dma
operator|.
name|paddr
expr_stmt|;
name|txq_init
operator|->
name|sb_cq_index
operator|=
name|HC_INDEX_ETH_FIRST_TX_CQ_CONS
operator|+
name|cos
expr_stmt|;
name|txq_init
operator|->
name|traffic_type
operator|=
name|LLFC_TRAFFIC_TYPE_NW
expr_stmt|;
name|txq_init
operator|->
name|fw_sb_id
operator|=
name|fp
operator|->
name|fw_sb_id
expr_stmt|;
comment|/*      * set the TSS leading client id for TX classfication to the      * leading RSS client id      */
name|txq_init
operator|->
name|tss_leading_cl_id
operator|=
name|BXE_FP
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|cl_id
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function performs 2 steps in a queue state machine:  *   1) RESET->INIT  *   2) INIT->SETUP  */
end_comment

begin_function
specifier|static
name|int
name|bxe_setup_queue
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bxe_fastpath
modifier|*
name|fp
parameter_list|,
name|uint8_t
name|leading
parameter_list|)
block|{
name|struct
name|ecore_queue_state_params
name|q_params
init|=
block|{
name|NULL
block|}
decl_stmt|;
name|struct
name|ecore_queue_setup_params
modifier|*
name|setup_params
init|=
operator|&
name|q_params
operator|.
name|params
operator|.
name|setup
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"setting up queue %d\n"
argument_list|,
name|fp
operator|->
name|index
argument_list|)
expr_stmt|;
name|bxe_ack_sb
argument_list|(
name|sc
argument_list|,
name|fp
operator|->
name|igu_sb_id
argument_list|,
name|USTORM_ID
argument_list|,
literal|0
argument_list|,
name|IGU_INT_ENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|q_params
operator|.
name|q_obj
operator|=
operator|&
name|BXE_SP_OBJ
argument_list|(
name|sc
argument_list|,
name|fp
argument_list|)
operator|.
name|q_obj
expr_stmt|;
comment|/* we want to wait for completion in this context */
name|bxe_set_bit
argument_list|(
name|RAMROD_COMP_WAIT
argument_list|,
operator|&
name|q_params
operator|.
name|ramrod_flags
argument_list|)
expr_stmt|;
comment|/* prepare the INIT parameters */
name|bxe_pf_q_prep_init
argument_list|(
name|sc
argument_list|,
name|fp
argument_list|,
operator|&
name|q_params
operator|.
name|params
operator|.
name|init
argument_list|)
expr_stmt|;
comment|/* Set the command */
name|q_params
operator|.
name|cmd
operator|=
name|ECORE_Q_CMD_INIT
expr_stmt|;
comment|/* Change the state to INIT */
name|rc
operator|=
name|ecore_queue_state_change
argument_list|(
name|sc
argument_list|,
operator|&
name|q_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Queue(%d) INIT failed rc = %d\n"
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"init complete\n"
argument_list|)
expr_stmt|;
comment|/* now move the Queue to the SETUP state */
name|memset
argument_list|(
name|setup_params
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|setup_params
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set Queue flags */
name|setup_params
operator|->
name|flags
operator|=
name|bxe_get_q_flags
argument_list|(
name|sc
argument_list|,
name|fp
argument_list|,
name|leading
argument_list|)
expr_stmt|;
comment|/* set general SETUP parameters */
name|bxe_pf_q_prep_general
argument_list|(
name|sc
argument_list|,
name|fp
argument_list|,
operator|&
name|setup_params
operator|->
name|gen_params
argument_list|,
name|FIRST_TX_COS_INDEX
argument_list|)
expr_stmt|;
name|bxe_pf_rx_q_prep
argument_list|(
name|sc
argument_list|,
name|fp
argument_list|,
operator|&
name|setup_params
operator|->
name|pause_params
argument_list|,
operator|&
name|setup_params
operator|->
name|rxq_params
argument_list|)
expr_stmt|;
name|bxe_pf_tx_q_prep
argument_list|(
name|sc
argument_list|,
name|fp
argument_list|,
operator|&
name|setup_params
operator|->
name|txq_params
argument_list|,
name|FIRST_TX_COS_INDEX
argument_list|)
expr_stmt|;
comment|/* Set the command */
name|q_params
operator|.
name|cmd
operator|=
name|ECORE_Q_CMD_SETUP
expr_stmt|;
comment|/* change the state to SETUP */
name|rc
operator|=
name|ecore_queue_state_change
argument_list|(
name|sc
argument_list|,
operator|&
name|q_params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Queue(%d) SETUP failed (rc = %d)\n"
argument_list|,
name|fp
operator|->
name|index
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_setup_leading
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
name|bxe_setup_queue
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|fp
index|[
literal|0
index|]
argument_list|,
name|TRUE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_config_rss_pf
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_rss_config_obj
modifier|*
name|rss_obj
parameter_list|,
name|uint8_t
name|config_hash
parameter_list|)
block|{
name|struct
name|ecore_config_rss_params
name|params
init|=
block|{
name|NULL
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/*      * Although RSS is meaningless when there is a single HW queue we      * still need it enabled in order to have HW Rx hash generated.      */
name|params
operator|.
name|rss_obj
operator|=
name|rss_obj
expr_stmt|;
name|bxe_set_bit
argument_list|(
name|RAMROD_COMP_WAIT
argument_list|,
operator|&
name|params
operator|.
name|ramrod_flags
argument_list|)
expr_stmt|;
name|bxe_set_bit
argument_list|(
name|ECORE_RSS_MODE_REGULAR
argument_list|,
operator|&
name|params
operator|.
name|rss_flags
argument_list|)
expr_stmt|;
comment|/* RSS configuration */
name|bxe_set_bit
argument_list|(
name|ECORE_RSS_IPV4
argument_list|,
operator|&
name|params
operator|.
name|rss_flags
argument_list|)
expr_stmt|;
name|bxe_set_bit
argument_list|(
name|ECORE_RSS_IPV4_TCP
argument_list|,
operator|&
name|params
operator|.
name|rss_flags
argument_list|)
expr_stmt|;
name|bxe_set_bit
argument_list|(
name|ECORE_RSS_IPV6
argument_list|,
operator|&
name|params
operator|.
name|rss_flags
argument_list|)
expr_stmt|;
name|bxe_set_bit
argument_list|(
name|ECORE_RSS_IPV6_TCP
argument_list|,
operator|&
name|params
operator|.
name|rss_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rss_obj
operator|->
name|udp_rss_v4
condition|)
block|{
name|bxe_set_bit
argument_list|(
name|ECORE_RSS_IPV4_UDP
argument_list|,
operator|&
name|params
operator|.
name|rss_flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rss_obj
operator|->
name|udp_rss_v6
condition|)
block|{
name|bxe_set_bit
argument_list|(
name|ECORE_RSS_IPV6_UDP
argument_list|,
operator|&
name|params
operator|.
name|rss_flags
argument_list|)
expr_stmt|;
block|}
comment|/* Hash bits */
name|params
operator|.
name|rss_result_mask
operator|=
name|MULTI_MASK
expr_stmt|;
name|memcpy
argument_list|(
name|params
operator|.
name|ind_table
argument_list|,
name|rss_obj
operator|->
name|ind_table
argument_list|,
sizeof|sizeof
argument_list|(
name|params
operator|.
name|ind_table
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_hash
condition|)
block|{
comment|/* RSS keys */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|params
operator|.
name|rss_key
argument_list|)
operator|/
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|params
operator|.
name|rss_key
index|[
name|i
index|]
operator|=
name|arc4random
argument_list|()
expr_stmt|;
block|}
name|bxe_set_bit
argument_list|(
name|ECORE_RSS_SET_SRCH
argument_list|,
operator|&
name|params
operator|.
name|rss_flags
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ecore_config_rss
argument_list|(
name|sc
argument_list|,
operator|&
name|params
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_config_rss_eth
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|config_hash
parameter_list|)
block|{
return|return
operator|(
name|bxe_config_rss_pf
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rss_conf_obj
argument_list|,
name|config_hash
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_init_rss_pf
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint8_t
name|num_eth_queues
init|=
name|BXE_NUM_ETH_QUEUES
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/*      * Prepare the initial contents of the indirection table if      * RSS is enabled      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|rss_conf_obj
operator|.
name|ind_table
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|rss_conf_obj
operator|.
name|ind_table
index|[
name|i
index|]
operator|=
operator|(
name|sc
operator|->
name|fp
operator|->
name|cl_id
operator|+
operator|(
name|i
operator|%
name|num_eth_queues
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|udp_rss
condition|)
block|{
name|sc
operator|->
name|rss_conf_obj
operator|.
name|udp_rss_v4
operator|=
name|sc
operator|->
name|rss_conf_obj
operator|.
name|udp_rss_v6
operator|=
literal|1
expr_stmt|;
block|}
comment|/*      * For 57710 and 57711 SEARCHER configuration (rss_keys) is      * per-port, so if explicit configuration is needed, do it only      * for a PMF.      *      * For 57712 and newer it's a per-function configuration.      */
return|return
operator|(
name|bxe_config_rss_eth
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|port
operator|.
name|pmf
operator|||
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_set_mac_one
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
modifier|*
name|mac
parameter_list|,
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|obj
parameter_list|,
name|uint8_t
name|set
parameter_list|,
name|int
name|mac_type
parameter_list|,
name|unsigned
name|long
modifier|*
name|ramrod_flags
parameter_list|)
block|{
name|struct
name|ecore_vlan_mac_ramrod_params
name|ramrod_param
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ramrod_param
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ramrod_param
argument_list|)
argument_list|)
expr_stmt|;
comment|/* fill in general parameters */
name|ramrod_param
operator|.
name|vlan_mac_obj
operator|=
name|obj
expr_stmt|;
name|ramrod_param
operator|.
name|ramrod_flags
operator|=
operator|*
name|ramrod_flags
expr_stmt|;
comment|/* fill a user request section if needed */
if|if
condition|(
operator|!
name|bxe_test_bit
argument_list|(
name|RAMROD_CONT
argument_list|,
name|ramrod_flags
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|ramrod_param
operator|.
name|user_req
operator|.
name|u
operator|.
name|mac
operator|.
name|mac
argument_list|,
name|mac
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
name|bxe_set_bit
argument_list|(
name|mac_type
argument_list|,
operator|&
name|ramrod_param
operator|.
name|user_req
operator|.
name|vlan_mac_flags
argument_list|)
expr_stmt|;
comment|/* Set the command: ADD or DEL */
name|ramrod_param
operator|.
name|user_req
operator|.
name|cmd
operator|=
operator|(
name|set
operator|)
condition|?
name|ECORE_VLAN_MAC_ADD
else|:
name|ECORE_VLAN_MAC_DEL
expr_stmt|;
block|}
name|rc
operator|=
name|ecore_config_vlan_mac
argument_list|(
name|sc
argument_list|,
operator|&
name|ramrod_param
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|ECORE_EXISTS
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_SP
argument_list|,
literal|"Failed to schedule ADD operations (EEXIST)\n"
argument_list|)
expr_stmt|;
comment|/* do not treat adding same MAC as error */
name|rc
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"%s MAC failed (%d)\n"
argument_list|,
operator|(
name|set
condition|?
literal|"Set"
else|:
literal|"Delete"
operator|)
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_set_eth_mac
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|set
parameter_list|)
block|{
name|unsigned
name|long
name|ramrod_flags
init|=
literal|0
decl_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Adding Ethernet MAC\n"
argument_list|)
expr_stmt|;
name|bxe_set_bit
argument_list|(
name|RAMROD_COMP_WAIT
argument_list|,
operator|&
name|ramrod_flags
argument_list|)
expr_stmt|;
comment|/* Eth MAC is set on RSS leading client (fp[0]) */
return|return
operator|(
name|bxe_set_mac_one
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|mac_addr
argument_list|,
operator|&
name|sc
operator|->
name|sp_objs
operator|->
name|mac_obj
argument_list|,
name|set
argument_list|,
name|ECORE_ETH_MAC
argument_list|,
operator|&
name|ramrod_flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_get_cur_phy_idx
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|sel_phy_idx
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|link_params
operator|.
name|num_phys
operator|<=
literal|1
condition|)
block|{
return|return
operator|(
name|ELINK_INT_PHY
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|link_vars
operator|.
name|link_up
condition|)
block|{
name|sel_phy_idx
operator|=
name|ELINK_EXT_PHY1
expr_stmt|;
comment|/* In case link is SERDES, check if the ELINK_EXT_PHY2 is the one */
if|if
condition|(
operator|(
name|sc
operator|->
name|link_vars
operator|.
name|link_status
operator|&
name|LINK_STATUS_SERDES_LINK
operator|)
operator|&&
operator|(
name|sc
operator|->
name|link_params
operator|.
name|phy
index|[
name|ELINK_EXT_PHY2
index|]
operator|.
name|supported
operator|&
name|ELINK_SUPPORTED_FIBRE
operator|)
condition|)
name|sel_phy_idx
operator|=
name|ELINK_EXT_PHY2
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|elink_phy_selection
argument_list|(
operator|&
name|sc
operator|->
name|link_params
argument_list|)
condition|)
block|{
case|case
name|PORT_HW_CFG_PHY_SELECTION_HARDWARE_DEFAULT
case|:
case|case
name|PORT_HW_CFG_PHY_SELECTION_FIRST_PHY
case|:
case|case
name|PORT_HW_CFG_PHY_SELECTION_FIRST_PHY_PRIORITY
case|:
name|sel_phy_idx
operator|=
name|ELINK_EXT_PHY1
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_PHY_SELECTION_SECOND_PHY
case|:
case|case
name|PORT_HW_CFG_PHY_SELECTION_SECOND_PHY_PRIORITY
case|:
name|sel_phy_idx
operator|=
name|ELINK_EXT_PHY2
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|sel_phy_idx
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_get_link_cfg_idx
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|sel_phy_idx
init|=
name|bxe_get_cur_phy_idx
argument_list|(
name|sc
argument_list|)
decl_stmt|;
comment|/*      * The selected activated PHY is always after swapping (in case PHY      * swapping is enabled). So when swapping is enabled, we need to reverse      * the configuration      */
if|if
condition|(
name|sc
operator|->
name|link_params
operator|.
name|multi_phy_config
operator|&
name|PORT_HW_CFG_PHY_SWAPPED_ENABLED
condition|)
block|{
if|if
condition|(
name|sel_phy_idx
operator|==
name|ELINK_EXT_PHY1
condition|)
name|sel_phy_idx
operator|=
name|ELINK_EXT_PHY2
expr_stmt|;
elseif|else
if|if
condition|(
name|sel_phy_idx
operator|==
name|ELINK_EXT_PHY2
condition|)
name|sel_phy_idx
operator|=
name|ELINK_EXT_PHY1
expr_stmt|;
block|}
return|return
operator|(
name|ELINK_LINK_CONFIG_IDX
argument_list|(
name|sel_phy_idx
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_set_requested_fc
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/*      * Initialize link parameters structure variables      * It is recommended to turn off RX FC for jumbo frames      * for better performance      */
if|if
condition|(
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
operator|&&
operator|(
name|sc
operator|->
name|mtu
operator|>
literal|5000
operator|)
condition|)
block|{
name|sc
operator|->
name|link_params
operator|.
name|req_fc_auto_adv
operator|=
name|ELINK_FLOW_CTRL_TX
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|link_params
operator|.
name|req_fc_auto_adv
operator|=
name|ELINK_FLOW_CTRL_BOTH
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_calc_fc_adv
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint8_t
name|cfg_idx
init|=
name|bxe_get_link_cfg_idx
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|sc
operator|->
name|port
operator|.
name|advertising
index|[
name|cfg_idx
index|]
operator|&=
operator|~
operator|(
name|ADVERTISED_Asym_Pause
operator||
name|ADVERTISED_Pause
operator|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|link_vars
operator|.
name|ieee_fc
operator|&
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_MASK
condition|)
block|{
case|case
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH
case|:
name|sc
operator|->
name|port
operator|.
name|advertising
index|[
name|cfg_idx
index|]
operator||=
operator|(
name|ADVERTISED_Asym_Pause
operator||
name|ADVERTISED_Pause
operator|)
expr_stmt|;
break|break;
case|case
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC
case|:
name|sc
operator|->
name|port
operator|.
name|advertising
index|[
name|cfg_idx
index|]
operator||=
name|ADVERTISED_Asym_Pause
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|uint16_t
name|bxe_get_mf_speed
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint16_t
name|line_speed
init|=
name|sc
operator|->
name|link_vars
operator|.
name|line_speed
decl_stmt|;
if|if
condition|(
name|IS_MF
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|uint16_t
name|maxCfg
init|=
name|bxe_extract_max_cfg
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|devinfo
operator|.
name|mf_info
operator|.
name|mf_config
index|[
name|SC_VN
argument_list|(
name|sc
argument_list|)
index|]
argument_list|)
decl_stmt|;
comment|/* calculate the current MAX line speed limit for the MF devices */
if|if
condition|(
name|IS_MF_SI
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|line_speed
operator|=
operator|(
name|line_speed
operator|*
name|maxCfg
operator|)
operator|/
literal|100
expr_stmt|;
block|}
else|else
block|{
comment|/* SD mode */
name|uint16_t
name|vn_max_rate
init|=
name|maxCfg
operator|*
literal|100
decl_stmt|;
if|if
condition|(
name|vn_max_rate
operator|<
name|line_speed
condition|)
block|{
name|line_speed
operator|=
name|vn_max_rate
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|line_speed
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_fill_report_data
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bxe_link_report_data
modifier|*
name|data
parameter_list|)
block|{
name|uint16_t
name|line_speed
init|=
name|bxe_get_mf_speed
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
argument_list|)
expr_stmt|;
comment|/* fill the report data with the effective line speed */
name|data
operator|->
name|line_speed
operator|=
name|line_speed
expr_stmt|;
comment|/* Link is down */
if|if
condition|(
operator|!
name|sc
operator|->
name|link_vars
operator|.
name|link_up
operator|||
operator|(
name|sc
operator|->
name|flags
operator|&
name|BXE_MF_FUNC_DIS
operator|)
condition|)
block|{
name|bxe_set_bit
argument_list|(
name|BXE_LINK_REPORT_LINK_DOWN
argument_list|,
operator|&
name|data
operator|->
name|link_report_flags
argument_list|)
expr_stmt|;
block|}
comment|/* Full DUPLEX */
if|if
condition|(
name|sc
operator|->
name|link_vars
operator|.
name|duplex
operator|==
name|DUPLEX_FULL
condition|)
block|{
name|bxe_set_bit
argument_list|(
name|BXE_LINK_REPORT_FULL_DUPLEX
argument_list|,
operator|&
name|data
operator|->
name|link_report_flags
argument_list|)
expr_stmt|;
block|}
comment|/* Rx Flow Control is ON */
if|if
condition|(
name|sc
operator|->
name|link_vars
operator|.
name|flow_ctrl
operator|&
name|ELINK_FLOW_CTRL_RX
condition|)
block|{
name|bxe_set_bit
argument_list|(
name|BXE_LINK_REPORT_RX_FC_ON
argument_list|,
operator|&
name|data
operator|->
name|link_report_flags
argument_list|)
expr_stmt|;
block|}
comment|/* Tx Flow Control is ON */
if|if
condition|(
name|sc
operator|->
name|link_vars
operator|.
name|flow_ctrl
operator|&
name|ELINK_FLOW_CTRL_TX
condition|)
block|{
name|bxe_set_bit
argument_list|(
name|BXE_LINK_REPORT_TX_FC_ON
argument_list|,
operator|&
name|data
operator|->
name|link_report_flags
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* report link status to OS, should be called under phy_lock */
end_comment

begin_function
specifier|static
name|void
name|bxe_link_report_locked
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bxe_link_report_data
name|cur_data
decl_stmt|;
comment|/* reread mf_cfg */
if|if
condition|(
name|IS_PF
argument_list|(
name|sc
argument_list|)
operator|&&
operator|!
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|bxe_read_mf_cfg
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* Read the current link report info */
name|bxe_fill_report_data
argument_list|(
name|sc
argument_list|,
operator|&
name|cur_data
argument_list|)
expr_stmt|;
comment|/* Don't report link down or exactly the same link status twice */
if|if
condition|(
operator|!
name|memcmp
argument_list|(
operator|&
name|cur_data
argument_list|,
operator|&
name|sc
operator|->
name|last_reported_link
argument_list|,
sizeof|sizeof
argument_list|(
name|cur_data
argument_list|)
argument_list|)
operator|||
operator|(
name|bxe_test_bit
argument_list|(
name|BXE_LINK_REPORT_LINK_DOWN
argument_list|,
operator|&
name|sc
operator|->
name|last_reported_link
operator|.
name|link_report_flags
argument_list|)
operator|&&
name|bxe_test_bit
argument_list|(
name|BXE_LINK_REPORT_LINK_DOWN
argument_list|,
operator|&
name|cur_data
operator|.
name|link_report_flags
argument_list|)
operator|)
condition|)
block|{
return|return;
block|}
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"Change in link status : cur_data = %x, last_reported_link = %x\n"
argument_list|,
name|cur_data
operator|.
name|link_report_flags
argument_list|,
name|sc
operator|->
name|last_reported_link
operator|.
name|link_report_flags
argument_list|)
expr_stmt|;
name|sc
operator|->
name|link_cnt
operator|++
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"link status change count = %x\n"
argument_list|,
name|sc
operator|->
name|link_cnt
argument_list|)
expr_stmt|;
comment|/* report new link params and remember the state for the next time */
name|memcpy
argument_list|(
operator|&
name|sc
operator|->
name|last_reported_link
argument_list|,
operator|&
name|cur_data
argument_list|,
sizeof|sizeof
argument_list|(
name|cur_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bxe_test_bit
argument_list|(
name|BXE_LINK_REPORT_LINK_DOWN
argument_list|,
operator|&
name|cur_data
operator|.
name|link_report_flags
argument_list|)
condition|)
block|{
name|if_link_state_change
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|duplex
decl_stmt|;
specifier|const
name|char
modifier|*
name|flow
decl_stmt|;
if|if
condition|(
name|bxe_test_and_clear_bit
argument_list|(
name|BXE_LINK_REPORT_FULL_DUPLEX
argument_list|,
operator|&
name|cur_data
operator|.
name|link_report_flags
argument_list|)
condition|)
block|{
name|duplex
operator|=
literal|"full"
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"link set to full duplex\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|duplex
operator|=
literal|"half"
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"link set to half duplex\n"
argument_list|)
expr_stmt|;
block|}
comment|/*          * Handle the FC at the end so that only these flags would be          * possibly set. This way we may easily check if there is no FC          * enabled.          */
if|if
condition|(
name|cur_data
operator|.
name|link_report_flags
condition|)
block|{
if|if
condition|(
name|bxe_test_bit
argument_list|(
name|BXE_LINK_REPORT_RX_FC_ON
argument_list|,
operator|&
name|cur_data
operator|.
name|link_report_flags
argument_list|)
operator|&&
name|bxe_test_bit
argument_list|(
name|BXE_LINK_REPORT_TX_FC_ON
argument_list|,
operator|&
name|cur_data
operator|.
name|link_report_flags
argument_list|)
condition|)
block|{
name|flow
operator|=
literal|"ON - receive& transmit"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bxe_test_bit
argument_list|(
name|BXE_LINK_REPORT_RX_FC_ON
argument_list|,
operator|&
name|cur_data
operator|.
name|link_report_flags
argument_list|)
operator|&&
operator|!
name|bxe_test_bit
argument_list|(
name|BXE_LINK_REPORT_TX_FC_ON
argument_list|,
operator|&
name|cur_data
operator|.
name|link_report_flags
argument_list|)
condition|)
block|{
name|flow
operator|=
literal|"ON - receive"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|bxe_test_bit
argument_list|(
name|BXE_LINK_REPORT_RX_FC_ON
argument_list|,
operator|&
name|cur_data
operator|.
name|link_report_flags
argument_list|)
operator|&&
name|bxe_test_bit
argument_list|(
name|BXE_LINK_REPORT_TX_FC_ON
argument_list|,
operator|&
name|cur_data
operator|.
name|link_report_flags
argument_list|)
condition|)
block|{
name|flow
operator|=
literal|"ON - transmit"
expr_stmt|;
block|}
else|else
block|{
name|flow
operator|=
literal|"none"
expr_stmt|;
comment|/* possible? */
block|}
block|}
else|else
block|{
name|flow
operator|=
literal|"none"
expr_stmt|;
block|}
name|if_link_state_change
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
name|BLOGI
argument_list|(
name|sc
argument_list|,
literal|"NIC Link is Up, %d Mbps %s duplex, Flow control: %s\n"
argument_list|,
name|cur_data
operator|.
name|line_speed
argument_list|,
name|duplex
argument_list|,
name|flow
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_link_report
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|bxe_acquire_phy_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_link_report_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_release_phy_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_link_status_update
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|state
operator|!=
name|BXE_STATE_OPEN
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|IS_PF
argument_list|(
name|sc
argument_list|)
operator|&&
operator|!
name|CHIP_REV_IS_SLOW
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|elink_link_status_update
argument_list|(
operator|&
name|sc
operator|->
name|link_params
argument_list|,
operator|&
name|sc
operator|->
name|link_vars
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|port
operator|.
name|supported
index|[
literal|0
index|]
operator||=
operator|(
name|ELINK_SUPPORTED_10baseT_Half
operator||
name|ELINK_SUPPORTED_10baseT_Full
operator||
name|ELINK_SUPPORTED_100baseT_Half
operator||
name|ELINK_SUPPORTED_100baseT_Full
operator||
name|ELINK_SUPPORTED_1000baseT_Full
operator||
name|ELINK_SUPPORTED_2500baseX_Full
operator||
name|ELINK_SUPPORTED_10000baseT_Full
operator||
name|ELINK_SUPPORTED_TP
operator||
name|ELINK_SUPPORTED_FIBRE
operator||
name|ELINK_SUPPORTED_Autoneg
operator||
name|ELINK_SUPPORTED_Pause
operator||
name|ELINK_SUPPORTED_Asym_Pause
operator|)
expr_stmt|;
name|sc
operator|->
name|port
operator|.
name|advertising
index|[
literal|0
index|]
operator|=
name|sc
operator|->
name|port
operator|.
name|supported
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|sc
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|port
operator|=
name|SC_PORT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|req_duplex
index|[
literal|0
index|]
operator|=
name|DUPLEX_FULL
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|req_flow_ctrl
index|[
literal|0
index|]
operator|=
name|ELINK_FLOW_CTRL_NONE
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|req_line_speed
index|[
literal|0
index|]
operator|=
name|SPEED_10000
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|speed_cap_mask
index|[
literal|0
index|]
operator|=
literal|0x7f0000
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|switch_cfg
operator|=
name|ELINK_SWITCH_CFG_10G
expr_stmt|;
if|if
condition|(
name|CHIP_REV_IS_FPGA
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|sc
operator|->
name|link_vars
operator|.
name|mac_type
operator|=
name|ELINK_MAC_TYPE_EMAC
expr_stmt|;
name|sc
operator|->
name|link_vars
operator|.
name|line_speed
operator|=
name|ELINK_SPEED_1000
expr_stmt|;
name|sc
operator|->
name|link_vars
operator|.
name|link_status
operator|=
operator|(
name|LINK_STATUS_LINK_UP
operator||
name|LINK_STATUS_SPEED_AND_DUPLEX_1000TFD
operator|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|link_vars
operator|.
name|mac_type
operator|=
name|ELINK_MAC_TYPE_BMAC
expr_stmt|;
name|sc
operator|->
name|link_vars
operator|.
name|line_speed
operator|=
name|ELINK_SPEED_10000
expr_stmt|;
name|sc
operator|->
name|link_vars
operator|.
name|link_status
operator|=
operator|(
name|LINK_STATUS_LINK_UP
operator||
name|LINK_STATUS_SPEED_AND_DUPLEX_10GTFD
operator|)
expr_stmt|;
block|}
name|sc
operator|->
name|link_vars
operator|.
name|link_up
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|link_vars
operator|.
name|duplex
operator|=
name|DUPLEX_FULL
expr_stmt|;
name|sc
operator|->
name|link_vars
operator|.
name|flow_ctrl
operator|=
name|ELINK_FLOW_CTRL_NONE
expr_stmt|;
if|if
condition|(
name|IS_PF
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_EGRESS_DRAIN0_MODE
operator|+
name|sc
operator|->
name|link_params
operator|.
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bxe_stats_handle
argument_list|(
name|sc
argument_list|,
name|STATS_EVENT_LINK_UP
argument_list|)
expr_stmt|;
name|bxe_link_report
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|IS_PF
argument_list|(
name|sc
argument_list|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|link_vars
operator|.
name|link_up
condition|)
block|{
name|bxe_stats_handle
argument_list|(
name|sc
argument_list|,
name|STATS_EVENT_LINK_UP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bxe_stats_handle
argument_list|(
name|sc
argument_list|,
name|STATS_EVENT_STOP
argument_list|)
expr_stmt|;
block|}
name|bxe_link_report
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bxe_link_report
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_stats_handle
argument_list|(
name|sc
argument_list|,
name|STATS_EVENT_LINK_UP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_initial_phy_init
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|load_mode
parameter_list|)
block|{
name|int
name|rc
decl_stmt|,
name|cfg_idx
init|=
name|bxe_get_link_cfg_idx
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|uint16_t
name|req_line_speed
init|=
name|sc
operator|->
name|link_params
operator|.
name|req_line_speed
index|[
name|cfg_idx
index|]
decl_stmt|;
name|struct
name|elink_params
modifier|*
name|lp
init|=
operator|&
name|sc
operator|->
name|link_params
decl_stmt|;
name|bxe_set_requested_fc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_REV_IS_SLOW
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|uint32_t
name|bond
init|=
name|CHIP_BOND_ID
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|uint32_t
name|feat
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|CHIP_IS_E2
argument_list|(
name|sc
argument_list|)
operator|&&
name|CHIP_IS_MODE_4_PORT
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|feat
operator||=
name|ELINK_FEATURE_CONFIG_EMUL_DISABLE_BMAC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bond
operator|&
literal|0x4
condition|)
block|{
if|if
condition|(
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|feat
operator||=
name|ELINK_FEATURE_CONFIG_EMUL_DISABLE_XMAC
expr_stmt|;
block|}
else|else
block|{
name|feat
operator||=
name|ELINK_FEATURE_CONFIG_EMUL_DISABLE_BMAC
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|bond
operator|&
literal|0x8
condition|)
block|{
if|if
condition|(
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|feat
operator||=
name|ELINK_FEATURE_CONFIG_EMUL_DISABLE_UMAC
expr_stmt|;
block|}
else|else
block|{
name|feat
operator||=
name|ELINK_FEATURE_CONFIG_EMUL_DISABLE_EMAC
expr_stmt|;
block|}
block|}
comment|/* disable EMAC for E3 and above */
if|if
condition|(
name|bond
operator|&
literal|0x2
condition|)
block|{
name|feat
operator||=
name|ELINK_FEATURE_CONFIG_EMUL_DISABLE_EMAC
expr_stmt|;
block|}
name|sc
operator|->
name|link_params
operator|.
name|feature_config_flags
operator||=
name|feat
expr_stmt|;
block|}
name|bxe_acquire_phy_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|load_mode
operator|==
name|LOAD_DIAG
condition|)
block|{
name|lp
operator|->
name|loopback_mode
operator|=
name|ELINK_LOOPBACK_XGXS
expr_stmt|;
comment|/* Prefer doing PHY loopback at 10G speed, if possible */
if|if
condition|(
name|lp
operator|->
name|req_line_speed
index|[
name|cfg_idx
index|]
operator|<
name|ELINK_SPEED_10000
condition|)
block|{
if|if
condition|(
name|lp
operator|->
name|speed_cap_mask
index|[
name|cfg_idx
index|]
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_10G
condition|)
block|{
name|lp
operator|->
name|req_line_speed
index|[
name|cfg_idx
index|]
operator|=
name|ELINK_SPEED_10000
expr_stmt|;
block|}
else|else
block|{
name|lp
operator|->
name|req_line_speed
index|[
name|cfg_idx
index|]
operator|=
name|ELINK_SPEED_1000
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|load_mode
operator|==
name|LOAD_LOOPBACK_EXT
condition|)
block|{
name|lp
operator|->
name|loopback_mode
operator|=
name|ELINK_LOOPBACK_EXT
expr_stmt|;
block|}
name|rc
operator|=
name|elink_phy_init
argument_list|(
operator|&
name|sc
operator|->
name|link_params
argument_list|,
operator|&
name|sc
operator|->
name|link_vars
argument_list|)
expr_stmt|;
name|bxe_release_phy_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_calc_fc_adv
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|link_vars
operator|.
name|link_up
condition|)
block|{
name|bxe_stats_handle
argument_list|(
name|sc
argument_list|,
name|STATS_EVENT_LINK_UP
argument_list|)
expr_stmt|;
name|bxe_link_report
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|CHIP_REV_IS_SLOW
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|bxe_periodic_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|link_params
operator|.
name|req_line_speed
index|[
name|cfg_idx
index|]
operator|=
name|req_line_speed
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* must be called under IF_ADDR_LOCK */
end_comment

begin_function
specifier|static
name|int
name|bxe_set_mc_list
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ecore_mcast_ramrod_params
name|rparam
init|=
block|{
name|NULL
block|}
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|int
name|mc_count
init|=
literal|0
decl_stmt|;
name|int
name|mcnt
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|ecore_mcast_list_elem
modifier|*
name|mc_mac
decl_stmt|,
modifier|*
name|mc_mac_start
decl_stmt|;
name|unsigned
name|char
modifier|*
name|mta
decl_stmt|;
name|if_t
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|mc_count
operator|=
name|if_multiaddr_count
argument_list|(
name|ifp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX they don't have a limit */
if|if
condition|(
operator|!
name|mc_count
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|mta
operator|=
name|malloc
argument_list|(
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
operator|*
name|ETHER_ADDR_LEN
operator|*
name|mc_count
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mta
operator|==
name|NULL
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to allocate temp mcast list\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
name|mta
argument_list|,
operator|(
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
operator|*
name|ETHER_ADDR_LEN
operator|*
name|mc_count
operator|)
argument_list|)
expr_stmt|;
name|mc_mac
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|mc_mac
argument_list|)
operator|*
name|mc_count
argument_list|,
name|M_DEVBUF
argument_list|,
operator|(
name|M_NOWAIT
operator||
name|M_ZERO
operator|)
argument_list|)
expr_stmt|;
name|mc_mac_start
operator|=
name|mc_mac
expr_stmt|;
if|if
condition|(
operator|!
name|mc_mac
condition|)
block|{
name|free
argument_list|(
name|mta
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to allocate temp mcast list\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
name|mc_mac
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|mc_mac
argument_list|)
operator|*
name|mc_count
operator|)
argument_list|)
expr_stmt|;
comment|/* mta and mcnt not expected to be  different */
name|if_multiaddr_array
argument_list|(
name|ifp
argument_list|,
name|mta
argument_list|,
operator|&
name|mcnt
argument_list|,
name|mc_count
argument_list|)
expr_stmt|;
name|rparam
operator|.
name|mcast_obj
operator|=
operator|&
name|sc
operator|->
name|mcast_obj
expr_stmt|;
name|ECORE_LIST_INIT
argument_list|(
operator|&
name|rparam
operator|.
name|mcast_list
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mcnt
condition|;
name|i
operator|++
control|)
block|{
name|mc_mac
operator|->
name|mac
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|mta
operator|+
operator|(
name|i
operator|*
name|ETHER_ADDR_LEN
operator|)
operator|)
expr_stmt|;
name|ECORE_LIST_PUSH_TAIL
argument_list|(
operator|&
name|mc_mac
operator|->
name|link
argument_list|,
operator|&
name|rparam
operator|.
name|mcast_list
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Setting MCAST %02X:%02X:%02X:%02X:%02X:%02X\n"
argument_list|,
name|mc_mac
operator|->
name|mac
index|[
literal|0
index|]
argument_list|,
name|mc_mac
operator|->
name|mac
index|[
literal|1
index|]
argument_list|,
name|mc_mac
operator|->
name|mac
index|[
literal|2
index|]
argument_list|,
name|mc_mac
operator|->
name|mac
index|[
literal|3
index|]
argument_list|,
name|mc_mac
operator|->
name|mac
index|[
literal|4
index|]
argument_list|,
name|mc_mac
operator|->
name|mac
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|mc_mac
operator|++
expr_stmt|;
block|}
name|rparam
operator|.
name|mcast_list_len
operator|=
name|mc_count
expr_stmt|;
name|BXE_MCAST_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* first, clear all configured multicast MACs */
name|rc
operator|=
name|ecore_config_mcast
argument_list|(
name|sc
argument_list|,
operator|&
name|rparam
argument_list|,
name|ECORE_MCAST_CMD_DEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to clear multicast configuration: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|BXE_MCAST_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mc_mac_start
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mta
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
comment|/* Now add the new MACs */
name|rc
operator|=
name|ecore_config_mcast
argument_list|(
name|sc
argument_list|,
operator|&
name|rparam
argument_list|,
name|ECORE_MCAST_CMD_ADD
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to set new mcast config (%d)\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
name|BXE_MCAST_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mc_mac_start
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mta
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_set_uc_list
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|if_t
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|mac_obj
init|=
operator|&
name|sc
operator|->
name|sp_objs
operator|->
name|mac_obj
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|unsigned
name|long
name|ramrod_flags
init|=
literal|0
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|800000
name|IF_ADDR_LOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
else|#
directive|else
name|if_addr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* first schedule a cleanup up of old configuration */
name|rc
operator|=
name|bxe_del_all_macs
argument_list|(
name|sc
argument_list|,
name|mac_obj
argument_list|,
name|ECORE_UC_LIST_MAC
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to schedule delete of all ETH MACs (%d)\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|800000
name|IF_ADDR_UNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
else|#
directive|else
name|if_addr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|ifa
operator|=
name|if_getifaddr
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* XXX Is this structure */
while|while
condition|(
name|ifa
condition|)
block|{
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
block|{
name|ifa
operator|=
name|TAILQ_NEXT
argument_list|(
name|ifa
argument_list|,
name|ifa_link
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|rc
operator|=
name|bxe_set_mac_one
argument_list|(
name|sc
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
argument_list|)
argument_list|,
name|mac_obj
argument_list|,
name|TRUE
argument_list|,
name|ECORE_UC_LIST_MAC
argument_list|,
operator|&
name|ramrod_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
operator|-
name|EEXIST
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_SP
argument_list|,
literal|"Failed to schedule ADD operations (EEXIST)\n"
argument_list|)
expr_stmt|;
comment|/* do not treat adding same MAC as an error */
name|rc
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to schedule ADD operations (%d)\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|800000
name|IF_ADDR_UNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
else|#
directive|else
name|if_addr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|ifa
operator|=
name|TAILQ_NEXT
argument_list|(
name|ifa
argument_list|,
name|ifa_link
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|800000
name|IF_ADDR_UNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
else|#
directive|else
name|if_addr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Execute the pending commands */
name|bit_set
argument_list|(
operator|&
name|ramrod_flags
argument_list|,
name|RAMROD_CONT
argument_list|)
expr_stmt|;
return|return
operator|(
name|bxe_set_mac_one
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|,
name|mac_obj
argument_list|,
name|FALSE
comment|/* don't care */
argument_list|,
name|ECORE_UC_LIST_MAC
argument_list|,
operator|&
name|ramrod_flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_set_rx_mode
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|if_t
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|uint32_t
name|rx_mode
init|=
name|BXE_RX_MODE_NORMAL
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|state
operator|!=
name|BXE_STATE_OPEN
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_SP
argument_list|,
literal|"state is %x, returning\n"
argument_list|,
name|sc
operator|->
name|state
argument_list|)
expr_stmt|;
return|return;
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_SP
argument_list|,
literal|"if_flags(ifp)=0x%x\n"
argument_list|,
name|if_getflags
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|if_getflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_PROMISC
condition|)
block|{
name|rx_mode
operator|=
name|BXE_RX_MODE_PROMISC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|if_getflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_ALLMULTI
operator|)
operator|||
operator|(
operator|(
name|if_getamcount
argument_list|(
name|ifp
argument_list|)
operator|>
name|BXE_MAX_MULTICAST
operator|)
operator|&&
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
block|{
name|rx_mode
operator|=
name|BXE_RX_MODE_ALLMULTI
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|IS_PF
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* some multicasts */
if|if
condition|(
name|bxe_set_mc_list
argument_list|(
name|sc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|rx_mode
operator|=
name|BXE_RX_MODE_ALLMULTI
expr_stmt|;
block|}
if|if
condition|(
name|bxe_set_uc_list
argument_list|(
name|sc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|rx_mode
operator|=
name|BXE_RX_MODE_PROMISC
expr_stmt|;
block|}
block|}
block|}
name|sc
operator|->
name|rx_mode
operator|=
name|rx_mode
expr_stmt|;
comment|/* schedule the rx_mode command */
if|if
condition|(
name|bxe_test_bit
argument_list|(
name|ECORE_FILTER_RX_MODE_PENDING
argument_list|,
operator|&
name|sc
operator|->
name|sp_state
argument_list|)
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Scheduled setting rx_mode with ECORE...\n"
argument_list|)
expr_stmt|;
name|bxe_set_bit
argument_list|(
name|ECORE_FILTER_RX_MODE_SCHED
argument_list|,
operator|&
name|sc
operator|->
name|sp_state
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|IS_PF
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|bxe_set_storm_rx_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* update flags in shmem */
end_comment

begin_function
specifier|static
name|void
name|bxe_update_drv_flags
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|flags
parameter_list|,
name|uint32_t
name|set
parameter_list|)
block|{
name|uint32_t
name|drv_flags
decl_stmt|;
if|if
condition|(
name|SHMEM2_HAS
argument_list|(
name|sc
argument_list|,
name|drv_flags
argument_list|)
condition|)
block|{
name|bxe_acquire_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_DRV_FLAGS
argument_list|)
expr_stmt|;
name|drv_flags
operator|=
name|SHMEM2_RD
argument_list|(
name|sc
argument_list|,
name|drv_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
condition|)
block|{
name|SET_FLAGS
argument_list|(
name|drv_flags
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RESET_FLAGS
argument_list|(
name|drv_flags
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|SHMEM2_WR
argument_list|(
name|sc
argument_list|,
name|drv_flags
argument_list|,
name|drv_flags
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"drv_flags 0x%08x\n"
argument_list|,
name|drv_flags
argument_list|)
expr_stmt|;
name|bxe_release_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_DRV_FLAGS
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* periodic timer callout routine, only runs when the interface is up */
end_comment

begin_function
specifier|static
name|void
name|bxe_periodic_callout_func
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|bxe_softc
operator|*
operator|)
name|xsc
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|BXE_CORE_TRYLOCK
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* just bail and try again next time */
if|if
condition|(
operator|(
name|sc
operator|->
name|state
operator|==
name|BXE_STATE_OPEN
operator|)
operator|&&
operator|(
name|atomic_load_acq_long
argument_list|(
operator|&
name|sc
operator|->
name|periodic_flags
argument_list|)
operator|==
name|PERIODIC_GO
operator|)
condition|)
block|{
comment|/* schedule the next periodic callout */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|periodic_callout
argument_list|,
name|hz
argument_list|,
name|bxe_periodic_callout_func
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|state
operator|!=
name|BXE_STATE_OPEN
operator|)
operator|||
operator|(
name|atomic_load_acq_long
argument_list|(
operator|&
name|sc
operator|->
name|periodic_flags
argument_list|)
operator|==
name|PERIODIC_STOP
operator|)
condition|)
block|{
name|BLOGW
argument_list|(
name|sc
argument_list|,
literal|"periodic callout exit (state=0x%x)\n"
argument_list|,
name|sc
operator|->
name|state
argument_list|)
expr_stmt|;
name|BXE_CORE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check for TX timeouts on any fastpath. */
name|FOR_EACH_QUEUE
argument_list|(
argument|sc
argument_list|,
argument|i
argument_list|)
block|{
if|if
condition|(
name|bxe_watchdog
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Ruh-Roh, chip was reset! */
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|CHIP_REV_IS_SLOW
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/*          * This barrier is needed to ensure the ordering between the writing          * to the sc->port.pmf in the bxe_nic_load() or bxe_pmf_update() and          * the reading here.          */
name|mb
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|port
operator|.
name|pmf
condition|)
block|{
name|bxe_acquire_phy_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|elink_period_func
argument_list|(
operator|&
name|sc
operator|->
name|link_params
argument_list|,
operator|&
name|sc
operator|->
name|link_vars
argument_list|)
expr_stmt|;
name|bxe_release_phy_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|IS_PF
argument_list|(
name|sc
argument_list|)
operator|&&
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|BXE_NO_PULSE
operator|)
condition|)
block|{
name|int
name|mb_idx
init|=
name|SC_FW_MB_IDX
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|uint32_t
name|drv_pulse
decl_stmt|;
name|uint32_t
name|mcp_pulse
decl_stmt|;
operator|++
name|sc
operator|->
name|fw_drv_pulse_wr_seq
expr_stmt|;
name|sc
operator|->
name|fw_drv_pulse_wr_seq
operator|&=
name|DRV_PULSE_SEQ_MASK
expr_stmt|;
name|drv_pulse
operator|=
name|sc
operator|->
name|fw_drv_pulse_wr_seq
expr_stmt|;
name|bxe_drv_pulse
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mcp_pulse
operator|=
operator|(
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|func_mb
index|[
name|mb_idx
index|]
operator|.
name|mcp_pulse_mb
argument_list|)
operator|&
name|MCP_PULSE_SEQ_MASK
operator|)
expr_stmt|;
comment|/*          * The delta between driver pulse and mcp response should          * be 1 (before mcp response) or 0 (after mcp response).          */
if|if
condition|(
operator|(
name|drv_pulse
operator|!=
name|mcp_pulse
operator|)
operator|&&
operator|(
name|drv_pulse
operator|!=
operator|(
operator|(
name|mcp_pulse
operator|+
literal|1
operator|)
operator|&
name|MCP_PULSE_SEQ_MASK
operator|)
operator|)
condition|)
block|{
comment|/* someone lost a heartbeat... */
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"drv_pulse (0x%x) != mcp_pulse (0x%x)\n"
argument_list|,
name|drv_pulse
argument_list|,
name|mcp_pulse
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* state is BXE_STATE_OPEN */
name|bxe_stats_handle
argument_list|(
name|sc
argument_list|,
name|STATS_EVENT_UPDATE
argument_list|)
expr_stmt|;
name|BXE_CORE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|state
operator|==
name|BXE_STATE_OPEN
operator|)
operator|&&
operator|(
name|atomic_load_acq_long
argument_list|(
operator|&
name|sc
operator|->
name|periodic_flags
argument_list|)
operator|==
name|PERIODIC_GO
operator|)
condition|)
block|{
comment|/* schedule the next periodic callout */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|periodic_callout
argument_list|,
name|hz
argument_list|,
name|bxe_periodic_callout_func
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_periodic_start
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|atomic_store_rel_long
argument_list|(
operator|&
name|sc
operator|->
name|periodic_flags
argument_list|,
name|PERIODIC_GO
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|periodic_callout
argument_list|,
name|hz
argument_list|,
name|bxe_periodic_callout_func
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_periodic_stop
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|atomic_store_rel_long
argument_list|(
operator|&
name|sc
operator|->
name|periodic_flags
argument_list|,
name|PERIODIC_STOP
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|periodic_callout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* start the controller */
end_comment

begin_function
specifier|static
name|__noinline
name|int
name|bxe_nic_load
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|load_mode
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|int
name|load_code
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|;
name|BXE_CORE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Starting NIC load...\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|state
operator|=
name|BXE_STATE_OPENING_WAITING_LOAD
expr_stmt|;
if|if
condition|(
name|IS_PF
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* must be called before memory allocation and HW init */
name|bxe_ilt_set_info
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|last_reported_link_state
operator|=
name|LINK_STATE_UNKNOWN
expr_stmt|;
name|bxe_set_fp_rx_buf_size
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bxe_alloc_fp_buffers
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to allocate fastpath memory\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|state
operator|=
name|BXE_STATE_CLOSED
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bxe_nic_load_error0
goto|;
block|}
if|if
condition|(
name|bxe_alloc_mem
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|state
operator|=
name|BXE_STATE_CLOSED
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bxe_nic_load_error0
goto|;
block|}
if|if
condition|(
name|bxe_alloc_fw_stats_mem
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|state
operator|=
name|BXE_STATE_CLOSED
expr_stmt|;
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bxe_nic_load_error0
goto|;
block|}
if|if
condition|(
name|IS_PF
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* set pf load just before approaching the MCP */
name|bxe_set_pf_load
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* if MCP exists send load request and analyze response */
if|if
condition|(
operator|!
name|BXE_NOMCP
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* attempt to load pf */
if|if
condition|(
name|bxe_nic_load_request
argument_list|(
name|sc
argument_list|,
operator|&
name|load_code
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|state
operator|=
name|BXE_STATE_CLOSED
expr_stmt|;
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bxe_nic_load_error1
goto|;
block|}
comment|/* what did the MCP say? */
if|if
condition|(
name|bxe_nic_load_analyze_req
argument_list|(
name|sc
argument_list|,
name|load_code
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bxe_fw_command
argument_list|(
name|sc
argument_list|,
name|DRV_MSG_CODE_LOAD_DONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|state
operator|=
name|BXE_STATE_CLOSED
expr_stmt|;
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bxe_nic_load_error2
goto|;
block|}
block|}
else|else
block|{
name|BLOGI
argument_list|(
name|sc
argument_list|,
literal|"Device has no MCP!\n"
argument_list|)
expr_stmt|;
name|load_code
operator|=
name|bxe_nic_load_no_mcp
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* mark PMF if applicable */
name|bxe_nic_load_pmf
argument_list|(
name|sc
argument_list|,
name|load_code
argument_list|)
expr_stmt|;
comment|/* Init Function state controlling object */
name|bxe_init_func_obj
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Initialize HW */
if|if
condition|(
name|bxe_init_hw
argument_list|(
name|sc
argument_list|,
name|load_code
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"HW init failed\n"
argument_list|)
expr_stmt|;
name|bxe_fw_command
argument_list|(
name|sc
argument_list|,
name|DRV_MSG_CODE_LOAD_DONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|state
operator|=
name|BXE_STATE_CLOSED
expr_stmt|;
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bxe_nic_load_error2
goto|;
block|}
block|}
comment|/* set ALWAYS_ALIVE bit in shmem */
name|sc
operator|->
name|fw_drv_pulse_wr_seq
operator||=
name|DRV_PULSE_ALWAYS_ALIVE
expr_stmt|;
name|bxe_drv_pulse
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|BXE_NO_PULSE
expr_stmt|;
comment|/* attach interrupts */
if|if
condition|(
name|bxe_interrupt_attach
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|state
operator|=
name|BXE_STATE_CLOSED
expr_stmt|;
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bxe_nic_load_error2
goto|;
block|}
name|bxe_nic_init
argument_list|(
name|sc
argument_list|,
name|load_code
argument_list|)
expr_stmt|;
comment|/* Init per-function objects */
if|if
condition|(
name|IS_PF
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|bxe_init_objs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|// XXX bxe_iov_nic_init(sc);
comment|/* set AFEX default VLAN tag to an invalid value */
name|sc
operator|->
name|devinfo
operator|.
name|mf_info
operator|.
name|afex_def_vlan_tag
operator|=
operator|-
literal|1
expr_stmt|;
comment|// XXX bxe_nic_load_afex_dcc(sc, load_code);
name|sc
operator|->
name|state
operator|=
name|BXE_STATE_OPENING_WAITING_PORT
expr_stmt|;
name|rc
operator|=
name|bxe_func_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Function start failed! rc = %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|bxe_fw_command
argument_list|(
name|sc
argument_list|,
name|DRV_MSG_CODE_LOAD_DONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|state
operator|=
name|BXE_STATE_ERROR
expr_stmt|;
goto|goto
name|bxe_nic_load_error3
goto|;
block|}
comment|/* send LOAD_DONE command to MCP */
if|if
condition|(
operator|!
name|BXE_NOMCP
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|load_code
operator|=
name|bxe_fw_command
argument_list|(
name|sc
argument_list|,
name|DRV_MSG_CODE_LOAD_DONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|load_code
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"MCP response failure, aborting\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|state
operator|=
name|BXE_STATE_ERROR
expr_stmt|;
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bxe_nic_load_error3
goto|;
block|}
block|}
name|rc
operator|=
name|bxe_setup_leading
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Setup leading failed! rc = %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|state
operator|=
name|BXE_STATE_ERROR
expr_stmt|;
goto|goto
name|bxe_nic_load_error3
goto|;
block|}
name|FOR_EACH_NONDEFAULT_ETH_QUEUE
argument_list|(
argument|sc
argument_list|,
argument|i
argument_list|)
block|{
name|rc
operator|=
name|bxe_setup_queue
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Queue(%d) setup failed rc = %d\n"
argument_list|,
name|i
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|state
operator|=
name|BXE_STATE_ERROR
expr_stmt|;
goto|goto
name|bxe_nic_load_error3
goto|;
block|}
block|}
name|rc
operator|=
name|bxe_init_rss_pf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"PF RSS init failed\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|state
operator|=
name|BXE_STATE_ERROR
expr_stmt|;
goto|goto
name|bxe_nic_load_error3
goto|;
block|}
block|}
comment|/* XXX VF */
comment|/* now when Clients are configured we are ready to work */
name|sc
operator|->
name|state
operator|=
name|BXE_STATE_OPEN
expr_stmt|;
comment|/* Configure a ucast MAC */
if|if
condition|(
name|IS_PF
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|rc
operator|=
name|bxe_set_eth_mac
argument_list|(
name|sc
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Setting Ethernet MAC failed rc = %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|state
operator|=
name|BXE_STATE_ERROR
expr_stmt|;
goto|goto
name|bxe_nic_load_error3
goto|;
block|}
if|if
condition|(
name|sc
operator|->
name|port
operator|.
name|pmf
condition|)
block|{
name|rc
operator|=
name|bxe_initial_phy_init
argument_list|(
name|sc
argument_list|,
comment|/* XXX load_mode */
name|LOAD_OPEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|sc
operator|->
name|state
operator|=
name|BXE_STATE_ERROR
expr_stmt|;
goto|goto
name|bxe_nic_load_error3
goto|;
block|}
block|}
name|sc
operator|->
name|link_params
operator|.
name|feature_config_flags
operator|&=
operator|~
name|ELINK_FEATURE_CONFIG_BOOT_FROM_SAN
expr_stmt|;
comment|/* start fast path */
comment|/* Initialize Rx filter */
name|bxe_set_rx_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* start the Tx */
switch|switch
condition|(
comment|/* XXX load_mode */
name|LOAD_OPEN
condition|)
block|{
case|case
name|LOAD_NORMAL
case|:
case|case
name|LOAD_OPEN
case|:
break|break;
case|case
name|LOAD_DIAG
case|:
case|case
name|LOAD_LOOPBACK_EXT
case|:
name|sc
operator|->
name|state
operator|=
name|BXE_STATE_DIAG
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|sc
operator|->
name|port
operator|.
name|pmf
condition|)
block|{
name|bxe_update_drv_flags
argument_list|(
name|sc
argument_list|,
literal|1
operator|<<
name|DRV_FLAGS_PORT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bxe_link_status_update
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* start the periodic timer callout */
name|bxe_periodic_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_PF
argument_list|(
name|sc
argument_list|)
operator|&&
name|SHMEM2_HAS
argument_list|(
name|sc
argument_list|,
name|drv_capabilities_flag
argument_list|)
condition|)
block|{
comment|/* mark driver is loaded in shmem2 */
name|val
operator|=
name|SHMEM2_RD
argument_list|(
name|sc
argument_list|,
name|drv_capabilities_flag
index|[
name|SC_FW_MB_IDX
argument_list|(
name|sc
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|SHMEM2_WR
argument_list|(
name|sc
argument_list|,
name|drv_capabilities_flag
index|[
name|SC_FW_MB_IDX
argument_list|(
name|sc
argument_list|)
index|]
argument_list|,
operator|(
name|val
operator||
name|DRV_FLAGS_CAPABILITIES_LOADED_SUPPORTED
operator||
name|DRV_FLAGS_CAPABILITIES_LOADED_L2
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* wait for all pending SP commands to complete */
if|if
condition|(
name|IS_PF
argument_list|(
name|sc
argument_list|)
operator|&&
operator|!
name|bxe_wait_sp_comp
argument_list|(
name|sc
argument_list|,
operator|~
literal|0x0UL
argument_list|)
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Timeout waiting for all SPs to complete!\n"
argument_list|)
expr_stmt|;
name|bxe_periodic_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_nic_unload
argument_list|(
name|sc
argument_list|,
name|UNLOAD_CLOSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Tell the stack the driver is running! */
name|if_setdrvflags
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|IFF_DRV_RUNNING
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"NIC successfully loaded\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bxe_nic_load_error3
label|:
if|if
condition|(
name|IS_PF
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|bxe_int_disable_sync
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* clean out queued objects */
name|bxe_squeeze_objects
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|bxe_interrupt_detach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_nic_load_error2
label|:
if|if
condition|(
name|IS_PF
argument_list|(
name|sc
argument_list|)
operator|&&
operator|!
name|BXE_NOMCP
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|bxe_fw_command
argument_list|(
name|sc
argument_list|,
name|DRV_MSG_CODE_UNLOAD_REQ_WOL_MCP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bxe_fw_command
argument_list|(
name|sc
argument_list|,
name|DRV_MSG_CODE_UNLOAD_DONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|port
operator|.
name|pmf
operator|=
literal|0
expr_stmt|;
name|bxe_nic_load_error1
label|:
comment|/* clear pf_load status, as it was already set */
if|if
condition|(
name|IS_PF
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|bxe_clear_pf_load
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|bxe_nic_load_error0
label|:
name|bxe_free_fw_stats_mem
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_free_fp_buffers
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_free_mem
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_init_locked
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|other_engine
init|=
name|SC_PATH
argument_list|(
name|sc
argument_list|)
condition|?
literal|0
else|:
literal|1
decl_stmt|;
name|uint8_t
name|other_load_status
decl_stmt|,
name|load_status
decl_stmt|;
name|uint8_t
name|global
init|=
name|FALSE
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|BXE_CORE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* check if the driver is already running */
if|if
condition|(
name|if_getdrvflags
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Init called while driver is running!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|bxe_set_power_state
argument_list|(
name|sc
argument_list|,
name|PCI_PM_D0
argument_list|)
expr_stmt|;
comment|/*      * If parity occurred during the unload, then attentions and/or      * RECOVERY_IN_PROGRES may still be set. If so we want the first function      * loaded on the current engine to complete the recovery. Parity recovery      * is only relevant for PF driver.      */
if|if
condition|(
name|IS_PF
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|other_load_status
operator|=
name|bxe_get_load_status
argument_list|(
name|sc
argument_list|,
name|other_engine
argument_list|)
expr_stmt|;
name|load_status
operator|=
name|bxe_get_load_status
argument_list|(
name|sc
argument_list|,
name|SC_PATH
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bxe_reset_is_done
argument_list|(
name|sc
argument_list|,
name|SC_PATH
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|||
name|bxe_chk_parity_attn
argument_list|(
name|sc
argument_list|,
operator|&
name|global
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
do|do
block|{
comment|/*                  * If there are attentions and they are in global blocks, set                  * the GLOBAL_RESET bit regardless whether it will be this                  * function that will complete the recovery or not.                  */
if|if
condition|(
name|global
condition|)
block|{
name|bxe_set_reset_global
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/*                  * Only the first function on the current engine should try                  * to recover in open. In case of attentions in global blocks                  * only the first in the chip should try to recover.                  */
if|if
condition|(
operator|(
operator|!
name|load_status
operator|&&
operator|(
operator|!
name|global
operator|||
operator|!
name|other_load_status
operator|)
operator|)
operator|&&
name|bxe_trylock_leader_lock
argument_list|(
name|sc
argument_list|)
operator|&&
operator|!
name|bxe_leader_reset
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|BLOGI
argument_list|(
name|sc
argument_list|,
literal|"Recovered during init\n"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* recovery has failed... */
name|bxe_set_power_state
argument_list|(
name|sc
argument_list|,
name|PCI_PM_D3hot
argument_list|)
expr_stmt|;
name|sc
operator|->
name|recovery_state
operator|=
name|BXE_RECOVERY_FAILED
expr_stmt|;
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Recovery flow hasn't properly "
literal|"completed yet, try again later. "
literal|"If you still see this message after a "
literal|"few retries then power cycle is required.\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bxe_init_locked_done
goto|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
block|}
block|}
name|sc
operator|->
name|recovery_state
operator|=
name|BXE_RECOVERY_DONE
expr_stmt|;
name|rc
operator|=
name|bxe_nic_load
argument_list|(
name|sc
argument_list|,
name|LOAD_OPEN
argument_list|)
expr_stmt|;
name|bxe_init_locked_done
label|:
if|if
condition|(
name|rc
condition|)
block|{
comment|/* Tell the stack the driver is NOT running! */
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Initialization failed, "
literal|"stack notified driver is NOT running!\n"
argument_list|)
expr_stmt|;
name|if_setdrvflagbits
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|0
argument_list|,
name|IFF_DRV_RUNNING
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_stop_locked
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|BXE_CORE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|bxe_nic_unload
argument_list|(
name|sc
argument_list|,
name|UNLOAD_NORMAL
argument_list|,
name|TRUE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handles controller initialization when called from an unlocked routine.  * ifconfig calls this function.  *  * Returns:  *   void  */
end_comment

begin_function
specifier|static
name|void
name|bxe_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|bxe_softc
operator|*
operator|)
name|xsc
decl_stmt|;
name|BXE_CORE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BXE_CORE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_init_ifnet
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|if_t
name|ifp
decl_stmt|;
name|int
name|capabilities
decl_stmt|;
comment|/* ifconfig entrypoint for media type/status reporting */
name|ifmedia_init
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|IFM_IMASK
argument_list|,
name|bxe_ifmedia_update
argument_list|,
name|bxe_ifmedia_status
argument_list|)
expr_stmt|;
comment|/* set the default interface values */
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
operator|(
name|IFM_ETHER
operator||
name|IFM_FDX
operator||
name|sc
operator|->
name|media
operator|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
operator|(
name|IFM_ETHER
operator||
name|IFM_AUTO
operator|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
operator|(
name|IFM_ETHER
operator||
name|IFM_AUTO
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ifmedia
operator|.
name|ifm_media
operator|=
name|sc
operator|->
name|ifmedia
operator|.
name|ifm_cur
operator|->
name|ifm_media
expr_stmt|;
comment|/* XXX ? */
name|BLOGI
argument_list|(
name|sc
argument_list|,
literal|"IFMEDIA flags : %x\n"
argument_list|,
name|sc
operator|->
name|ifmedia
operator|.
name|ifm_media
argument_list|)
expr_stmt|;
comment|/* allocate the ifnet structure */
if|if
condition|(
operator|(
name|ifp
operator|=
name|if_gethandle
argument_list|(
name|IFT_ETHER
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Interface allocation failed!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|if_setsoftc
argument_list|(
name|ifp
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|if_setflags
argument_list|(
name|ifp
argument_list|,
operator|(
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
operator|)
argument_list|)
expr_stmt|;
name|if_setioctlfn
argument_list|(
name|ifp
argument_list|,
name|bxe_ioctl
argument_list|)
expr_stmt|;
name|if_setstartfn
argument_list|(
name|ifp
argument_list|,
name|bxe_tx_start
argument_list|)
expr_stmt|;
name|if_setgetcounterfn
argument_list|(
name|ifp
argument_list|,
name|bxe_get_counter
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|901504
name|if_settransmitfn
argument_list|(
name|ifp
argument_list|,
name|bxe_tx_mq_start
argument_list|)
expr_stmt|;
name|if_setqflushfn
argument_list|(
name|ifp
argument_list|,
name|bxe_mq_flush
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FreeBSD8_0
name|if_settimer
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|if_setinitfn
argument_list|(
name|ifp
argument_list|,
name|bxe_init
argument_list|)
expr_stmt|;
name|if_setmtu
argument_list|(
name|ifp
argument_list|,
name|sc
operator|->
name|mtu
argument_list|)
expr_stmt|;
name|if_sethwassist
argument_list|(
name|ifp
argument_list|,
operator|(
name|CSUM_IP
operator||
name|CSUM_TCP
operator||
name|CSUM_UDP
operator||
name|CSUM_TSO
operator||
name|CSUM_TCP_IPV6
operator||
name|CSUM_UDP_IPV6
operator|)
argument_list|)
expr_stmt|;
name|capabilities
operator|=
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|700000
operator|(
name|IFCAP_VLAN_MTU
operator||
name|IFCAP_VLAN_HWTAGGING
operator||
name|IFCAP_HWCSUM
operator||
name|IFCAP_JUMBO_MTU
operator||
name|IFCAP_LRO
operator|)
expr_stmt|;
else|#
directive|else
operator|(
name|IFCAP_VLAN_MTU
operator||
name|IFCAP_VLAN_HWTAGGING
operator||
name|IFCAP_VLAN_HWTSO
operator||
name|IFCAP_VLAN_HWFILTER
operator||
name|IFCAP_VLAN_HWCSUM
operator||
name|IFCAP_HWCSUM
operator||
name|IFCAP_JUMBO_MTU
operator||
name|IFCAP_LRO
operator||
name|IFCAP_TSO4
operator||
name|IFCAP_TSO6
operator||
name|IFCAP_WOL_MAGIC
operator|)
expr_stmt|;
endif|#
directive|endif
name|if_setcapabilitiesbit
argument_list|(
name|ifp
argument_list|,
name|capabilities
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX */
name|if_setcapenable
argument_list|(
name|ifp
argument_list|,
name|if_getcapabilities
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
name|if_setbaudrate
argument_list|(
name|ifp
argument_list|,
name|IF_Gbps
argument_list|(
literal|10
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX */
name|if_setsendqlen
argument_list|(
name|ifp
argument_list|,
name|sc
operator|->
name|tx_ring_size
argument_list|)
expr_stmt|;
name|if_setsendqready
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* XXX */
name|sc
operator|->
name|ifp
operator|=
name|ifp
expr_stmt|;
comment|/* attach to the Ethernet interface list */
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|mac_addr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_deallocate_bars
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_BARS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|bar
index|[
name|i
index|]
operator|.
name|resource
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|bar
index|[
name|i
index|]
operator|.
name|rid
argument_list|,
name|sc
operator|->
name|bar
index|[
name|i
index|]
operator|.
name|resource
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Released PCI BAR%d [%02x] memory\n"
argument_list|,
name|i
argument_list|,
name|PCIR_BAR
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_allocate_bars
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int
name|flags
decl_stmt|;
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
name|sc
operator|->
name|bar
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|bar
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_BARS
condition|;
name|i
operator|++
control|)
block|{
comment|/* memory resources reside at BARs 0, 2, 4 */
comment|/* Run `pciconf -lb` to see mappings */
if|if
condition|(
operator|(
name|i
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|i
operator|!=
literal|2
operator|)
operator|&&
operator|(
name|i
operator|!=
literal|4
operator|)
condition|)
block|{
continue|continue;
block|}
name|sc
operator|->
name|bar
index|[
name|i
index|]
operator|.
name|rid
operator|=
name|PCIR_BAR
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|flags
operator|=
name|RF_ACTIVE
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|flags
operator||=
name|RF_SHAREABLE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|bar
index|[
name|i
index|]
operator|.
name|resource
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|bar
index|[
name|i
index|]
operator|.
name|rid
argument_list|,
name|flags
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sc
operator|->
name|bar
index|[
name|i
index|]
operator|.
name|tag
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|bar
index|[
name|i
index|]
operator|.
name|resource
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bar
index|[
name|i
index|]
operator|.
name|handle
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|bar
index|[
name|i
index|]
operator|.
name|resource
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bar
index|[
name|i
index|]
operator|.
name|kva
operator|=
operator|(
name|vm_offset_t
operator|)
name|rman_get_virtual
argument_list|(
name|sc
operator|->
name|bar
index|[
name|i
index|]
operator|.
name|resource
argument_list|)
expr_stmt|;
name|BLOGI
argument_list|(
name|sc
argument_list|,
literal|"PCI BAR%d [%02x] memory allocated: %p-%p (%jd) -> %p\n"
argument_list|,
name|i
argument_list|,
name|PCIR_BAR
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|rman_get_start
argument_list|(
name|sc
operator|->
name|bar
index|[
name|i
index|]
operator|.
name|resource
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|rman_get_end
argument_list|(
name|sc
operator|->
name|bar
index|[
name|i
index|]
operator|.
name|resource
argument_list|)
argument_list|,
name|rman_get_size
argument_list|(
name|sc
operator|->
name|bar
index|[
name|i
index|]
operator|.
name|resource
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
operator|->
name|bar
index|[
name|i
index|]
operator|.
name|kva
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_get_function_num
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|val
init|=
literal|0
decl_stmt|;
comment|/*      * Read the ME register to get the function number. The ME register      * holds the relative-function number and absolute-function number. The      * absolute-function number appears only in E2 and above. Before that      * these bits always contained zero, therefore we cannot blindly use them.      */
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BAR_ME_REGISTER
argument_list|)
expr_stmt|;
name|sc
operator|->
name|pfunc_rel
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|val
operator|&
name|ME_REG_PF_NUM
operator|)
operator|>>
name|ME_REG_PF_NUM_SHIFT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|path_id
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|val
operator|&
name|ME_REG_ABS_PF_NUM
operator|)
operator|>>
name|ME_REG_ABS_PF_NUM_SHIFT
argument_list|)
operator|&
literal|1
expr_stmt|;
if|if
condition|(
name|CHIP_PORT_MODE
argument_list|(
name|sc
argument_list|)
operator|==
name|CHIP_4_PORT_MODE
condition|)
block|{
name|sc
operator|->
name|pfunc_abs
operator|=
operator|(
operator|(
name|sc
operator|->
name|pfunc_rel
operator|<<
literal|1
operator|)
operator||
name|sc
operator|->
name|path_id
operator|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|pfunc_abs
operator|=
operator|(
name|sc
operator|->
name|pfunc_rel
operator||
name|sc
operator|->
name|path_id
operator|)
expr_stmt|;
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Relative function %d, Absolute function %d, Path %d\n"
argument_list|,
name|sc
operator|->
name|pfunc_rel
argument_list|,
name|sc
operator|->
name|pfunc_abs
argument_list|,
name|sc
operator|->
name|path_id
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|bxe_get_shmem_mf_cfg_base
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|shmem2_size
decl_stmt|;
name|uint32_t
name|offset
decl_stmt|;
name|uint32_t
name|mf_cfg_offset_value
decl_stmt|;
comment|/* Non 57712 */
name|offset
operator|=
operator|(
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|func_mb
argument_list|)
operator|+
operator|(
name|MAX_FUNC_NUM
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drv_func_mb
argument_list|)
operator|)
operator|)
expr_stmt|;
comment|/* 57712 plus */
if|if
condition|(
name|sc
operator|->
name|devinfo
operator|.
name|shmem2_base
operator|!=
literal|0
condition|)
block|{
name|shmem2_size
operator|=
name|SHMEM2_RD
argument_list|(
name|sc
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|shmem2_size
operator|>
name|offsetof
argument_list|(
expr|struct
name|shmem2_region
argument_list|,
name|mf_cfg_addr
argument_list|)
condition|)
block|{
name|mf_cfg_offset_value
operator|=
name|SHMEM2_RD
argument_list|(
name|sc
argument_list|,
name|mf_cfg_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|SHMEM_MF_CFG_ADDR_NONE
operator|!=
name|mf_cfg_offset_value
condition|)
block|{
name|offset
operator|=
name|mf_cfg_offset_value
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|offset
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|bxe_pcie_capability_read
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|int
name|pcie_reg
decl_stmt|;
comment|/* ensure PCIe capability is enabled */
if|if
condition|(
name|pci_find_cap
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|PCIY_EXPRESS
argument_list|,
operator|&
name|pcie_reg
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pcie_reg
operator|!=
literal|0
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"PCIe capability at 0x%04x\n"
argument_list|,
name|pcie_reg
argument_list|)
expr_stmt|;
return|return
operator|(
name|pci_read_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
operator|(
name|pcie_reg
operator|+
name|reg
operator|)
argument_list|,
name|width
argument_list|)
operator|)
return|;
block|}
block|}
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"PCIe capability NOT FOUND!!!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|bxe_is_pcie_pending
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
name|bxe_pcie_capability_read
argument_list|(
name|sc
argument_list|,
name|PCIR_EXPRESS_DEVICE_STA
argument_list|,
literal|2
argument_list|)
operator|&
name|PCIM_EXP_STA_TRANSACTION_PND
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Walk the PCI capabiites list for the device to find what features are  * supported. These capabilites may be enabled/disabled by firmware so it's  * best to walk the list rather than make assumptions.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_probe_pci_caps
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint16_t
name|link_status
decl_stmt|;
name|int
name|reg
decl_stmt|;
comment|/* check if PCI Power Management is enabled */
if|if
condition|(
name|pci_find_cap
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|PCIY_PMG
argument_list|,
operator|&
name|reg
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Found PM capability at 0x%04x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|sc
operator|->
name|devinfo
operator|.
name|pcie_cap_flags
operator||=
name|BXE_PM_CAPABLE_FLAG
expr_stmt|;
name|sc
operator|->
name|devinfo
operator|.
name|pcie_pm_cap_reg
operator|=
operator|(
name|uint16_t
operator|)
name|reg
expr_stmt|;
block|}
block|}
name|link_status
operator|=
name|bxe_pcie_capability_read
argument_list|(
name|sc
argument_list|,
name|PCIR_EXPRESS_LINK_STA
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* handle PCIe 2.0 workarounds for 57710 */
if|if
condition|(
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* workaround for 57710 errata E4_57710_27462 */
name|sc
operator|->
name|devinfo
operator|.
name|pcie_link_speed
operator|=
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
literal|0x3d04
argument_list|)
operator|&
operator|(
literal|1
operator|<<
literal|24
operator|)
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
comment|/* workaround for 57710 errata E4_57710_27488 */
name|sc
operator|->
name|devinfo
operator|.
name|pcie_link_width
operator|=
operator|(
operator|(
name|link_status
operator|&
name|PCIM_LINK_STA_WIDTH
operator|)
operator|>>
literal|4
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|devinfo
operator|.
name|pcie_link_speed
operator|>
literal|1
condition|)
block|{
name|sc
operator|->
name|devinfo
operator|.
name|pcie_link_width
operator|=
operator|(
operator|(
name|link_status
operator|&
name|PCIM_LINK_STA_WIDTH
operator|)
operator|>>
literal|4
operator|)
operator|>>
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|sc
operator|->
name|devinfo
operator|.
name|pcie_link_speed
operator|=
operator|(
name|link_status
operator|&
name|PCIM_LINK_STA_SPEED
operator|)
expr_stmt|;
name|sc
operator|->
name|devinfo
operator|.
name|pcie_link_width
operator|=
operator|(
operator|(
name|link_status
operator|&
name|PCIM_LINK_STA_WIDTH
operator|)
operator|>>
literal|4
operator|)
expr_stmt|;
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"PCIe link speed=%d width=%d\n"
argument_list|,
name|sc
operator|->
name|devinfo
operator|.
name|pcie_link_speed
argument_list|,
name|sc
operator|->
name|devinfo
operator|.
name|pcie_link_width
argument_list|)
expr_stmt|;
name|sc
operator|->
name|devinfo
operator|.
name|pcie_cap_flags
operator||=
name|BXE_PCIE_CAPABLE_FLAG
expr_stmt|;
name|sc
operator|->
name|devinfo
operator|.
name|pcie_pcie_cap_reg
operator|=
operator|(
name|uint16_t
operator|)
name|reg
expr_stmt|;
comment|/* check if MSI capability is enabled */
if|if
condition|(
name|pci_find_cap
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|PCIY_MSI
argument_list|,
operator|&
name|reg
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Found MSI capability at 0x%04x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|sc
operator|->
name|devinfo
operator|.
name|pcie_cap_flags
operator||=
name|BXE_MSI_CAPABLE_FLAG
expr_stmt|;
name|sc
operator|->
name|devinfo
operator|.
name|pcie_msi_cap_reg
operator|=
operator|(
name|uint16_t
operator|)
name|reg
expr_stmt|;
block|}
block|}
comment|/* check if MSI-X capability is enabled */
if|if
condition|(
name|pci_find_cap
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|PCIY_MSIX
argument_list|,
operator|&
name|reg
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Found MSI-X capability at 0x%04x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|sc
operator|->
name|devinfo
operator|.
name|pcie_cap_flags
operator||=
name|BXE_MSIX_CAPABLE_FLAG
expr_stmt|;
name|sc
operator|->
name|devinfo
operator|.
name|pcie_msix_cap_reg
operator|=
operator|(
name|uint16_t
operator|)
name|reg
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_get_shmem_mf_cfg_info_sd
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bxe_mf_info
modifier|*
name|mf_info
init|=
operator|&
name|sc
operator|->
name|devinfo
operator|.
name|mf_info
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
comment|/* get the outer vlan if we're in switch-dependent mode */
name|val
operator|=
name|MFCFG_RD
argument_list|(
name|sc
argument_list|,
name|func_mf_config
index|[
name|SC_ABS_FUNC
argument_list|(
name|sc
argument_list|)
index|]
operator|.
name|e1hov_tag
argument_list|)
expr_stmt|;
name|mf_info
operator|->
name|ext_id
operator|=
operator|(
name|uint16_t
operator|)
name|val
expr_stmt|;
name|mf_info
operator|->
name|multi_vnics_mode
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|VALID_OVLAN
argument_list|(
name|mf_info
operator|->
name|ext_id
argument_list|)
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Invalid VLAN (%d)\n"
argument_list|,
name|mf_info
operator|->
name|ext_id
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* get the capabilities */
if|if
condition|(
operator|(
name|mf_info
operator|->
name|mf_config
index|[
name|SC_VN
argument_list|(
name|sc
argument_list|)
index|]
operator|&
name|FUNC_MF_CFG_PROTOCOL_MASK
operator|)
operator|==
name|FUNC_MF_CFG_PROTOCOL_ISCSI
condition|)
block|{
name|mf_info
operator|->
name|mf_protos_supported
operator||=
name|MF_PROTO_SUPPORT_ISCSI
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|mf_info
operator|->
name|mf_config
index|[
name|SC_VN
argument_list|(
name|sc
argument_list|)
index|]
operator|&
name|FUNC_MF_CFG_PROTOCOL_MASK
operator|)
operator|==
name|FUNC_MF_CFG_PROTOCOL_FCOE
condition|)
block|{
name|mf_info
operator|->
name|mf_protos_supported
operator||=
name|MF_PROTO_SUPPORT_FCOE
expr_stmt|;
block|}
else|else
block|{
name|mf_info
operator|->
name|mf_protos_supported
operator||=
name|MF_PROTO_SUPPORT_ETHERNET
expr_stmt|;
block|}
name|mf_info
operator|->
name|vnics_per_port
operator|=
operator|(
name|CHIP_PORT_MODE
argument_list|(
name|sc
argument_list|)
operator|==
name|CHIP_4_PORT_MODE
operator|)
condition|?
literal|2
else|:
literal|4
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|bxe_get_shmem_ext_proto_support_flags
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|retval
init|=
literal|0
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|val
operator|=
name|MFCFG_RD
argument_list|(
name|sc
argument_list|,
name|func_ext_config
index|[
name|SC_ABS_FUNC
argument_list|(
name|sc
argument_list|)
index|]
operator|.
name|func_cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|MACP_FUNC_CFG_FLAGS_ENABLED
condition|)
block|{
if|if
condition|(
name|val
operator|&
name|MACP_FUNC_CFG_FLAGS_ETHERNET
condition|)
block|{
name|retval
operator||=
name|MF_PROTO_SUPPORT_ETHERNET
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|MACP_FUNC_CFG_FLAGS_ISCSI_OFFLOAD
condition|)
block|{
name|retval
operator||=
name|MF_PROTO_SUPPORT_ISCSI
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|MACP_FUNC_CFG_FLAGS_FCOE_OFFLOAD
condition|)
block|{
name|retval
operator||=
name|MF_PROTO_SUPPORT_FCOE
expr_stmt|;
block|}
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_get_shmem_mf_cfg_info_si
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bxe_mf_info
modifier|*
name|mf_info
init|=
operator|&
name|sc
operator|->
name|devinfo
operator|.
name|mf_info
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
comment|/*      * There is no outer vlan if we're in switch-independent mode.      * If the mac is valid then assume multi-function.      */
name|val
operator|=
name|MFCFG_RD
argument_list|(
name|sc
argument_list|,
name|func_ext_config
index|[
name|SC_ABS_FUNC
argument_list|(
name|sc
argument_list|)
index|]
operator|.
name|func_cfg
argument_list|)
expr_stmt|;
name|mf_info
operator|->
name|multi_vnics_mode
operator|=
operator|(
operator|(
name|val
operator|&
name|MACP_FUNC_CFG_FLAGS_MASK
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|mf_info
operator|->
name|mf_protos_supported
operator|=
name|bxe_get_shmem_ext_proto_support_flags
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mf_info
operator|->
name|vnics_per_port
operator|=
operator|(
name|CHIP_PORT_MODE
argument_list|(
name|sc
argument_list|)
operator|==
name|CHIP_4_PORT_MODE
operator|)
condition|?
literal|2
else|:
literal|4
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_get_shmem_mf_cfg_info_niv
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bxe_mf_info
modifier|*
name|mf_info
init|=
operator|&
name|sc
operator|->
name|devinfo
operator|.
name|mf_info
decl_stmt|;
name|uint32_t
name|e1hov_tag
decl_stmt|;
name|uint32_t
name|func_config
decl_stmt|;
name|uint32_t
name|niv_config
decl_stmt|;
name|mf_info
operator|->
name|multi_vnics_mode
operator|=
literal|1
expr_stmt|;
name|e1hov_tag
operator|=
name|MFCFG_RD
argument_list|(
name|sc
argument_list|,
name|func_mf_config
index|[
name|SC_ABS_FUNC
argument_list|(
name|sc
argument_list|)
index|]
operator|.
name|e1hov_tag
argument_list|)
expr_stmt|;
name|func_config
operator|=
name|MFCFG_RD
argument_list|(
name|sc
argument_list|,
name|func_mf_config
index|[
name|SC_ABS_FUNC
argument_list|(
name|sc
argument_list|)
index|]
operator|.
name|config
argument_list|)
expr_stmt|;
name|niv_config
operator|=
name|MFCFG_RD
argument_list|(
name|sc
argument_list|,
name|func_mf_config
index|[
name|SC_ABS_FUNC
argument_list|(
name|sc
argument_list|)
index|]
operator|.
name|afex_config
argument_list|)
expr_stmt|;
name|mf_info
operator|->
name|ext_id
operator|=
call|(
name|uint16_t
call|)
argument_list|(
operator|(
name|e1hov_tag
operator|&
name|FUNC_MF_CFG_E1HOV_TAG_MASK
operator|)
operator|>>
name|FUNC_MF_CFG_E1HOV_TAG_SHIFT
argument_list|)
expr_stmt|;
name|mf_info
operator|->
name|default_vlan
operator|=
call|(
name|uint16_t
call|)
argument_list|(
operator|(
name|e1hov_tag
operator|&
name|FUNC_MF_CFG_AFEX_VLAN_MASK
operator|)
operator|>>
name|FUNC_MF_CFG_AFEX_VLAN_SHIFT
argument_list|)
expr_stmt|;
name|mf_info
operator|->
name|niv_allowed_priorities
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|niv_config
operator|&
name|FUNC_MF_CFG_AFEX_COS_FILTER_MASK
operator|)
operator|>>
name|FUNC_MF_CFG_AFEX_COS_FILTER_SHIFT
argument_list|)
expr_stmt|;
name|mf_info
operator|->
name|niv_default_cos
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|func_config
operator|&
name|FUNC_MF_CFG_TRANSMIT_PRIORITY_MASK
operator|)
operator|>>
name|FUNC_MF_CFG_TRANSMIT_PRIORITY_SHIFT
argument_list|)
expr_stmt|;
name|mf_info
operator|->
name|afex_vlan_mode
operator|=
operator|(
operator|(
name|niv_config
operator|&
name|FUNC_MF_CFG_AFEX_VLAN_MODE_MASK
operator|)
operator|>>
name|FUNC_MF_CFG_AFEX_VLAN_MODE_SHIFT
operator|)
expr_stmt|;
name|mf_info
operator|->
name|niv_mba_enabled
operator|=
operator|(
operator|(
name|niv_config
operator|&
name|FUNC_MF_CFG_AFEX_MBA_ENABLED_MASK
operator|)
operator|>>
name|FUNC_MF_CFG_AFEX_MBA_ENABLED_SHIFT
operator|)
expr_stmt|;
name|mf_info
operator|->
name|mf_protos_supported
operator|=
name|bxe_get_shmem_ext_proto_support_flags
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mf_info
operator|->
name|vnics_per_port
operator|=
operator|(
name|CHIP_PORT_MODE
argument_list|(
name|sc
argument_list|)
operator|==
name|CHIP_4_PORT_MODE
operator|)
condition|?
literal|2
else|:
literal|4
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_check_valid_mf_cfg
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bxe_mf_info
modifier|*
name|mf_info
init|=
operator|&
name|sc
operator|->
name|devinfo
operator|.
name|mf_info
decl_stmt|;
name|uint32_t
name|mf_cfg1
decl_stmt|;
name|uint32_t
name|mf_cfg2
decl_stmt|;
name|uint32_t
name|ovlan1
decl_stmt|;
name|uint32_t
name|ovlan2
decl_stmt|;
name|uint8_t
name|i
decl_stmt|,
name|j
decl_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"MF config parameters for function %d\n"
argument_list|,
name|SC_PORT
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"\tmf_config=0x%x\n"
argument_list|,
name|mf_info
operator|->
name|mf_config
index|[
name|SC_VN
argument_list|(
name|sc
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"\tmulti_vnics_mode=%d\n"
argument_list|,
name|mf_info
operator|->
name|multi_vnics_mode
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"\tvnics_per_port=%d\n"
argument_list|,
name|mf_info
operator|->
name|vnics_per_port
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"\tovlan/vifid=%d\n"
argument_list|,
name|mf_info
operator|->
name|ext_id
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"\tmin_bw=%d/%d/%d/%d\n"
argument_list|,
name|mf_info
operator|->
name|min_bw
index|[
literal|0
index|]
argument_list|,
name|mf_info
operator|->
name|min_bw
index|[
literal|1
index|]
argument_list|,
name|mf_info
operator|->
name|min_bw
index|[
literal|2
index|]
argument_list|,
name|mf_info
operator|->
name|min_bw
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"\tmax_bw=%d/%d/%d/%d\n"
argument_list|,
name|mf_info
operator|->
name|max_bw
index|[
literal|0
index|]
argument_list|,
name|mf_info
operator|->
name|max_bw
index|[
literal|1
index|]
argument_list|,
name|mf_info
operator|->
name|max_bw
index|[
literal|2
index|]
argument_list|,
name|mf_info
operator|->
name|max_bw
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"\tmac_addr: %s\n"
argument_list|,
name|sc
operator|->
name|mac_addr_str
argument_list|)
expr_stmt|;
comment|/* various MF mode sanity checks... */
if|if
condition|(
name|mf_info
operator|->
name|mf_config
index|[
name|SC_VN
argument_list|(
name|sc
argument_list|)
index|]
operator|&
name|FUNC_MF_CFG_FUNC_HIDE
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Enumerated function %d is marked as hidden\n"
argument_list|,
name|SC_PORT
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|mf_info
operator|->
name|vnics_per_port
operator|>
literal|1
operator|)
operator|&&
operator|!
name|mf_info
operator|->
name|multi_vnics_mode
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"vnics_per_port=%d multi_vnics_mode=%d\n"
argument_list|,
name|mf_info
operator|->
name|vnics_per_port
argument_list|,
name|mf_info
operator|->
name|multi_vnics_mode
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|mf_info
operator|->
name|mf_mode
operator|==
name|MULTI_FUNCTION_SD
condition|)
block|{
comment|/* vnic id> 0 must have valid ovlan in switch-dependent mode */
if|if
condition|(
operator|(
name|SC_VN
argument_list|(
name|sc
argument_list|)
operator|>
literal|0
operator|)
operator|&&
operator|!
name|VALID_OVLAN
argument_list|(
name|OVLAN
argument_list|(
name|sc
argument_list|)
argument_list|)
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"mf_mode=SD vnic_id=%d ovlan=%d\n"
argument_list|,
name|SC_VN
argument_list|(
name|sc
argument_list|)
argument_list|,
name|OVLAN
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|VALID_OVLAN
argument_list|(
name|OVLAN
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|&&
name|mf_info
operator|->
name|multi_vnics_mode
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"mf_mode=SD multi_vnics_mode=%d ovlan=%d\n"
argument_list|,
name|mf_info
operator|->
name|multi_vnics_mode
argument_list|,
name|OVLAN
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/*          * Verify all functions are either MF or SF mode. If MF, make sure          * sure that all non-hidden functions have a valid ovlan. If SF,          * make sure that all non-hidden functions have an invalid ovlan.          */
name|FOREACH_ABS_FUNC_IN_PORT
argument_list|(
argument|sc
argument_list|,
argument|i
argument_list|)
block|{
name|mf_cfg1
operator|=
name|MFCFG_RD
argument_list|(
name|sc
argument_list|,
name|func_mf_config
index|[
name|i
index|]
operator|.
name|config
argument_list|)
expr_stmt|;
name|ovlan1
operator|=
name|MFCFG_RD
argument_list|(
name|sc
argument_list|,
name|func_mf_config
index|[
name|i
index|]
operator|.
name|e1hov_tag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mf_cfg1
operator|&
name|FUNC_MF_CFG_FUNC_HIDE
operator|)
operator|&&
operator|(
operator|(
operator|(
name|mf_info
operator|->
name|multi_vnics_mode
operator|)
operator|&&
operator|!
name|VALID_OVLAN
argument_list|(
name|ovlan1
argument_list|)
operator|)
operator|||
operator|(
operator|(
operator|!
name|mf_info
operator|->
name|multi_vnics_mode
operator|)
operator|&&
name|VALID_OVLAN
argument_list|(
name|ovlan1
argument_list|)
operator|)
operator|)
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"mf_mode=SD function %d MF config "
literal|"mismatch, multi_vnics_mode=%d ovlan=%d\n"
argument_list|,
name|i
argument_list|,
name|mf_info
operator|->
name|multi_vnics_mode
argument_list|,
name|ovlan1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* Verify all funcs on the same port each have a different ovlan. */
name|FOREACH_ABS_FUNC_IN_PORT
argument_list|(
argument|sc
argument_list|,
argument|i
argument_list|)
block|{
name|mf_cfg1
operator|=
name|MFCFG_RD
argument_list|(
name|sc
argument_list|,
name|func_mf_config
index|[
name|i
index|]
operator|.
name|config
argument_list|)
expr_stmt|;
name|ovlan1
operator|=
name|MFCFG_RD
argument_list|(
name|sc
argument_list|,
name|func_mf_config
index|[
name|i
index|]
operator|.
name|e1hov_tag
argument_list|)
expr_stmt|;
comment|/* iterate from the next function on the port to the max func */
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|2
init|;
name|j
operator|<
name|MAX_FUNC_NUM
condition|;
name|j
operator|+=
literal|2
control|)
block|{
name|mf_cfg2
operator|=
name|MFCFG_RD
argument_list|(
name|sc
argument_list|,
name|func_mf_config
index|[
name|j
index|]
operator|.
name|config
argument_list|)
expr_stmt|;
name|ovlan2
operator|=
name|MFCFG_RD
argument_list|(
name|sc
argument_list|,
name|func_mf_config
index|[
name|j
index|]
operator|.
name|e1hov_tag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mf_cfg1
operator|&
name|FUNC_MF_CFG_FUNC_HIDE
operator|)
operator|&&
name|VALID_OVLAN
argument_list|(
name|ovlan1
argument_list|)
operator|&&
operator|!
operator|(
name|mf_cfg2
operator|&
name|FUNC_MF_CFG_FUNC_HIDE
operator|)
operator|&&
name|VALID_OVLAN
argument_list|(
name|ovlan2
argument_list|)
operator|&&
operator|(
name|ovlan1
operator|==
name|ovlan2
operator|)
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"mf_mode=SD functions %d and %d "
literal|"have the same ovlan (%d)\n"
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|ovlan1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
block|}
block|}
comment|/* MULTI_FUNCTION_SD */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_get_mf_cfg_info
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bxe_mf_info
modifier|*
name|mf_info
init|=
operator|&
name|sc
operator|->
name|devinfo
operator|.
name|mf_info
decl_stmt|;
name|uint32_t
name|val
decl_stmt|,
name|mac_upper
decl_stmt|;
name|uint8_t
name|i
decl_stmt|,
name|vnic
decl_stmt|;
comment|/* initialize mf_info defaults */
name|mf_info
operator|->
name|vnics_per_port
operator|=
literal|1
expr_stmt|;
name|mf_info
operator|->
name|multi_vnics_mode
operator|=
name|FALSE
expr_stmt|;
name|mf_info
operator|->
name|path_has_ovlan
operator|=
name|FALSE
expr_stmt|;
name|mf_info
operator|->
name|mf_mode
operator|=
name|SINGLE_FUNCTION
expr_stmt|;
if|if
condition|(
operator|!
name|CHIP_IS_MF_CAP
argument_list|(
name|sc
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|devinfo
operator|.
name|mf_cfg_base
operator|==
name|SHMEM_MF_CFG_ADDR_NONE
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Invalid mf_cfg_base!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* get the MF mode (switch dependent / independent / single-function) */
name|val
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|dev_info
operator|.
name|shared_feature_config
operator|.
name|config
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|val
operator|&
name|SHARED_FEAT_CFG_FORCE_SF_MODE_MASK
condition|)
block|{
case|case
name|SHARED_FEAT_CFG_FORCE_SF_MODE_SWITCH_INDEPT
case|:
name|mac_upper
operator|=
name|MFCFG_RD
argument_list|(
name|sc
argument_list|,
name|func_mf_config
index|[
name|SC_ABS_FUNC
argument_list|(
name|sc
argument_list|)
index|]
operator|.
name|mac_upper
argument_list|)
expr_stmt|;
comment|/* check for legal upper mac bytes */
if|if
condition|(
name|mac_upper
operator|!=
name|FUNC_MF_CFG_UPPERMAC_DEFAULT
condition|)
block|{
name|mf_info
operator|->
name|mf_mode
operator|=
name|MULTI_FUNCTION_SI
expr_stmt|;
block|}
else|else
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Invalid config for Switch Independent mode\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SHARED_FEAT_CFG_FORCE_SF_MODE_MF_ALLOWED
case|:
case|case
name|SHARED_FEAT_CFG_FORCE_SF_MODE_SPIO4
case|:
comment|/* get outer vlan configuration */
name|val
operator|=
name|MFCFG_RD
argument_list|(
name|sc
argument_list|,
name|func_mf_config
index|[
name|SC_ABS_FUNC
argument_list|(
name|sc
argument_list|)
index|]
operator|.
name|e1hov_tag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|FUNC_MF_CFG_E1HOV_TAG_MASK
operator|)
operator|!=
name|FUNC_MF_CFG_E1HOV_TAG_DEFAULT
condition|)
block|{
name|mf_info
operator|->
name|mf_mode
operator|=
name|MULTI_FUNCTION_SD
expr_stmt|;
block|}
else|else
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Invalid config for Switch Dependent mode\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SHARED_FEAT_CFG_FORCE_SF_MODE_FORCED_SF
case|:
comment|/* not in MF mode, vnics_per_port=1 and multi_vnics_mode=FALSE */
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|SHARED_FEAT_CFG_FORCE_SF_MODE_AFEX_MODE
case|:
comment|/*          * Mark MF mode as NIV if MCP version includes NPAR-SD support          * and the MAC address is valid.          */
name|mac_upper
operator|=
name|MFCFG_RD
argument_list|(
name|sc
argument_list|,
name|func_mf_config
index|[
name|SC_ABS_FUNC
argument_list|(
name|sc
argument_list|)
index|]
operator|.
name|mac_upper
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SHMEM2_HAS
argument_list|(
name|sc
argument_list|,
name|afex_driver_support
argument_list|)
operator|)
operator|&&
operator|(
name|mac_upper
operator|!=
name|FUNC_MF_CFG_UPPERMAC_DEFAULT
operator|)
condition|)
block|{
name|mf_info
operator|->
name|mf_mode
operator|=
name|MULTI_FUNCTION_AFEX
expr_stmt|;
block|}
else|else
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Invalid config for AFEX mode\n"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Unknown MF mode (0x%08x)\n"
argument_list|,
operator|(
name|val
operator|&
name|SHARED_FEAT_CFG_FORCE_SF_MODE_MASK
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* set path mf_mode (which could be different than function mf_mode) */
if|if
condition|(
name|mf_info
operator|->
name|mf_mode
operator|==
name|MULTI_FUNCTION_SD
condition|)
block|{
name|mf_info
operator|->
name|path_has_ovlan
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mf_info
operator|->
name|mf_mode
operator|==
name|SINGLE_FUNCTION
condition|)
block|{
comment|/*          * Decide on path multi vnics mode. If we're not in MF mode and in          * 4-port mode, this is good enough to check vnic-0 of the other port          * on the same path          */
if|if
condition|(
name|CHIP_PORT_MODE
argument_list|(
name|sc
argument_list|)
operator|==
name|CHIP_4_PORT_MODE
condition|)
block|{
name|uint8_t
name|other_port
init|=
operator|!
operator|(
name|PORT_ID
argument_list|(
name|sc
argument_list|)
operator|&
literal|1
operator|)
decl_stmt|;
name|uint8_t
name|abs_func_other_port
init|=
operator|(
name|SC_PATH
argument_list|(
name|sc
argument_list|)
operator|+
operator|(
literal|2
operator|*
name|other_port
operator|)
operator|)
decl_stmt|;
name|val
operator|=
name|MFCFG_RD
argument_list|(
name|sc
argument_list|,
name|func_mf_config
index|[
name|abs_func_other_port
index|]
operator|.
name|e1hov_tag
argument_list|)
expr_stmt|;
name|mf_info
operator|->
name|path_has_ovlan
operator|=
name|VALID_OVLAN
argument_list|(
operator|(
name|uint16_t
operator|)
name|val
argument_list|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mf_info
operator|->
name|mf_mode
operator|==
name|SINGLE_FUNCTION
condition|)
block|{
comment|/* invalid MF config */
if|if
condition|(
name|SC_VN
argument_list|(
name|sc
argument_list|)
operator|>=
literal|1
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"VNIC ID>= 1 in SF mode\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* get the MF configuration */
name|mf_info
operator|->
name|mf_config
index|[
name|SC_VN
argument_list|(
name|sc
argument_list|)
index|]
operator|=
name|MFCFG_RD
argument_list|(
name|sc
argument_list|,
name|func_mf_config
index|[
name|SC_ABS_FUNC
argument_list|(
name|sc
argument_list|)
index|]
operator|.
name|config
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mf_info
operator|->
name|mf_mode
condition|)
block|{
case|case
name|MULTI_FUNCTION_SD
case|:
name|bxe_get_shmem_mf_cfg_info_sd
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULTI_FUNCTION_SI
case|:
name|bxe_get_shmem_mf_cfg_info_si
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULTI_FUNCTION_AFEX
case|:
name|bxe_get_shmem_mf_cfg_info_niv
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Get MF config failed (mf_mode=0x%08x)\n"
argument_list|,
name|mf_info
operator|->
name|mf_mode
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* get the congestion management parameters */
name|vnic
operator|=
literal|0
expr_stmt|;
name|FOREACH_ABS_FUNC_IN_PORT
argument_list|(
argument|sc
argument_list|,
argument|i
argument_list|)
block|{
comment|/* get min/max bw */
name|val
operator|=
name|MFCFG_RD
argument_list|(
name|sc
argument_list|,
name|func_mf_config
index|[
name|i
index|]
operator|.
name|config
argument_list|)
expr_stmt|;
name|mf_info
operator|->
name|min_bw
index|[
name|vnic
index|]
operator|=
operator|(
operator|(
name|val
operator|&
name|FUNC_MF_CFG_MIN_BW_MASK
operator|)
operator|>>
name|FUNC_MF_CFG_MIN_BW_SHIFT
operator|)
expr_stmt|;
name|mf_info
operator|->
name|max_bw
index|[
name|vnic
index|]
operator|=
operator|(
operator|(
name|val
operator|&
name|FUNC_MF_CFG_MAX_BW_MASK
operator|)
operator|>>
name|FUNC_MF_CFG_MAX_BW_SHIFT
operator|)
expr_stmt|;
name|vnic
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|bxe_check_valid_mf_cfg
argument_list|(
name|sc
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_get_shmem_info
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|port
decl_stmt|;
name|uint32_t
name|mac_hi
decl_stmt|,
name|mac_lo
decl_stmt|,
name|val
decl_stmt|;
name|port
operator|=
name|SC_PORT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mac_hi
operator|=
name|mac_lo
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|sc
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|port
operator|=
name|port
expr_stmt|;
comment|/* get the hardware config info */
name|sc
operator|->
name|devinfo
operator|.
name|hw_config
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|dev_info
operator|.
name|shared_hw_config
operator|.
name|config
argument_list|)
expr_stmt|;
name|sc
operator|->
name|devinfo
operator|.
name|hw_config2
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|dev_info
operator|.
name|shared_hw_config
operator|.
name|config2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|hw_led_mode
operator|=
operator|(
operator|(
name|sc
operator|->
name|devinfo
operator|.
name|hw_config
operator|&
name|SHARED_HW_CFG_LED_MODE_MASK
operator|)
operator|>>
name|SHARED_HW_CFG_LED_MODE_SHIFT
operator|)
expr_stmt|;
comment|/* get the port feature config */
name|sc
operator|->
name|port
operator|.
name|config
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|dev_info
operator|.
name|port_feature_config
index|[
name|port
index|]
operator|.
name|config
argument_list|)
expr_stmt|;
comment|/* get the link params */
name|sc
operator|->
name|link_params
operator|.
name|speed_cap_mask
index|[
literal|0
index|]
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|port
index|]
operator|.
name|speed_capability_mask
argument_list|)
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|speed_cap_mask
index|[
literal|1
index|]
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|port
index|]
operator|.
name|speed_capability_mask2
argument_list|)
expr_stmt|;
comment|/* get the lane config */
name|sc
operator|->
name|link_params
operator|.
name|lane_config
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|port
index|]
operator|.
name|lane_config
argument_list|)
expr_stmt|;
comment|/* get the link config */
name|val
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|dev_info
operator|.
name|port_feature_config
index|[
name|port
index|]
operator|.
name|link_config
argument_list|)
expr_stmt|;
name|sc
operator|->
name|port
operator|.
name|link_config
index|[
name|ELINK_INT_PHY
index|]
operator|=
name|val
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|switch_cfg
operator|=
operator|(
name|val
operator|&
name|PORT_FEATURE_CONNECTED_SWITCH_MASK
operator|)
expr_stmt|;
name|sc
operator|->
name|port
operator|.
name|link_config
index|[
name|ELINK_EXT_PHY1
index|]
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|dev_info
operator|.
name|port_feature_config
index|[
name|port
index|]
operator|.
name|link_config2
argument_list|)
expr_stmt|;
comment|/* get the override preemphasis flag and enable it or turn it off */
name|val
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|dev_info
operator|.
name|shared_feature_config
operator|.
name|config
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|SHARED_FEAT_CFG_OVERRIDE_PREEMPHASIS_CFG_ENABLED
condition|)
block|{
name|sc
operator|->
name|link_params
operator|.
name|feature_config_flags
operator||=
name|ELINK_FEATURE_CONFIG_OVERRIDE_PREEMPHASIS_ENABLED
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|link_params
operator|.
name|feature_config_flags
operator|&=
operator|~
name|ELINK_FEATURE_CONFIG_OVERRIDE_PREEMPHASIS_ENABLED
expr_stmt|;
block|}
comment|/* get the initial value of the link params */
name|sc
operator|->
name|link_params
operator|.
name|multi_phy_config
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|port
index|]
operator|.
name|multi_phy_config
argument_list|)
expr_stmt|;
comment|/* get external phy info */
name|sc
operator|->
name|port
operator|.
name|ext_phy_config
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|port
index|]
operator|.
name|external_phy_config
argument_list|)
expr_stmt|;
comment|/* get the multifunction configuration */
name|bxe_get_mf_cfg_info
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* get the mac address */
if|if
condition|(
name|IS_MF
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|mac_hi
operator|=
name|MFCFG_RD
argument_list|(
name|sc
argument_list|,
name|func_mf_config
index|[
name|SC_ABS_FUNC
argument_list|(
name|sc
argument_list|)
index|]
operator|.
name|mac_upper
argument_list|)
expr_stmt|;
name|mac_lo
operator|=
name|MFCFG_RD
argument_list|(
name|sc
argument_list|,
name|func_mf_config
index|[
name|SC_ABS_FUNC
argument_list|(
name|sc
argument_list|)
index|]
operator|.
name|mac_lower
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mac_hi
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|port
index|]
operator|.
name|mac_upper
argument_list|)
expr_stmt|;
name|mac_lo
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|port
index|]
operator|.
name|mac_lower
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mac_lo
operator|==
literal|0
operator|)
operator|&&
operator|(
name|mac_hi
operator|==
literal|0
operator|)
condition|)
block|{
operator|*
name|sc
operator|->
name|mac_addr_str
operator|=
literal|0
expr_stmt|;
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"No Ethernet address programmed!\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|link_params
operator|.
name|mac_addr
index|[
literal|0
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|mac_hi
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|mac_addr
index|[
literal|1
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|mac_hi
argument_list|)
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|mac_addr
index|[
literal|2
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|mac_lo
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|mac_addr
index|[
literal|3
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|mac_lo
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|mac_addr
index|[
literal|4
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|mac_lo
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|mac_addr
index|[
literal|5
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|mac_lo
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|sc
operator|->
name|mac_addr_str
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|mac_addr_str
argument_list|)
argument_list|,
literal|"%02x:%02x:%02x:%02x:%02x:%02x"
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|mac_addr
index|[
literal|0
index|]
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|mac_addr
index|[
literal|1
index|]
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|mac_addr
index|[
literal|2
index|]
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|mac_addr
index|[
literal|3
index|]
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|mac_addr
index|[
literal|4
index|]
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|mac_addr
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Ethernet address: %s\n"
argument_list|,
name|sc
operator|->
name|mac_addr_str
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_get_tunable_params
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* sanity checks */
if|if
condition|(
operator|(
name|bxe_interrupt_mode
operator|!=
name|INTR_MODE_INTX
operator|)
operator|&&
operator|(
name|bxe_interrupt_mode
operator|!=
name|INTR_MODE_MSI
operator|)
operator|&&
operator|(
name|bxe_interrupt_mode
operator|!=
name|INTR_MODE_MSIX
operator|)
condition|)
block|{
name|BLOGW
argument_list|(
name|sc
argument_list|,
literal|"invalid interrupt_mode value (%d)\n"
argument_list|,
name|bxe_interrupt_mode
argument_list|)
expr_stmt|;
name|bxe_interrupt_mode
operator|=
name|INTR_MODE_MSIX
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|bxe_queue_count
operator|<
literal|0
operator|)
operator|||
operator|(
name|bxe_queue_count
operator|>
name|MAX_RSS_CHAINS
operator|)
condition|)
block|{
name|BLOGW
argument_list|(
name|sc
argument_list|,
literal|"invalid queue_count value (%d)\n"
argument_list|,
name|bxe_queue_count
argument_list|)
expr_stmt|;
name|bxe_queue_count
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|bxe_max_rx_bufs
operator|<
literal|1
operator|)
operator|||
operator|(
name|bxe_max_rx_bufs
operator|>
name|RX_BD_USABLE
operator|)
condition|)
block|{
if|if
condition|(
name|bxe_max_rx_bufs
operator|==
literal|0
condition|)
block|{
name|bxe_max_rx_bufs
operator|=
name|RX_BD_USABLE
expr_stmt|;
block|}
else|else
block|{
name|BLOGW
argument_list|(
name|sc
argument_list|,
literal|"invalid max_rx_bufs (%d)\n"
argument_list|,
name|bxe_max_rx_bufs
argument_list|)
expr_stmt|;
name|bxe_max_rx_bufs
operator|=
literal|2048
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|bxe_hc_rx_ticks
operator|<
literal|1
operator|)
operator|||
operator|(
name|bxe_hc_rx_ticks
operator|>
literal|100
operator|)
condition|)
block|{
name|BLOGW
argument_list|(
name|sc
argument_list|,
literal|"invalid hc_rx_ticks (%d)\n"
argument_list|,
name|bxe_hc_rx_ticks
argument_list|)
expr_stmt|;
name|bxe_hc_rx_ticks
operator|=
literal|25
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|bxe_hc_tx_ticks
operator|<
literal|1
operator|)
operator|||
operator|(
name|bxe_hc_tx_ticks
operator|>
literal|100
operator|)
condition|)
block|{
name|BLOGW
argument_list|(
name|sc
argument_list|,
literal|"invalid hc_tx_ticks (%d)\n"
argument_list|,
name|bxe_hc_tx_ticks
argument_list|)
expr_stmt|;
name|bxe_hc_tx_ticks
operator|=
literal|50
expr_stmt|;
block|}
if|if
condition|(
name|bxe_max_aggregation_size
operator|==
literal|0
condition|)
block|{
name|bxe_max_aggregation_size
operator|=
name|TPA_AGG_SIZE
expr_stmt|;
block|}
if|if
condition|(
name|bxe_max_aggregation_size
operator|>
literal|0xffff
condition|)
block|{
name|BLOGW
argument_list|(
name|sc
argument_list|,
literal|"invalid max_aggregation_size (%d)\n"
argument_list|,
name|bxe_max_aggregation_size
argument_list|)
expr_stmt|;
name|bxe_max_aggregation_size
operator|=
name|TPA_AGG_SIZE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|bxe_mrrs
operator|<
operator|-
literal|1
operator|)
operator|||
operator|(
name|bxe_mrrs
operator|>
literal|3
operator|)
condition|)
block|{
name|BLOGW
argument_list|(
name|sc
argument_list|,
literal|"invalid mrrs (%d)\n"
argument_list|,
name|bxe_mrrs
argument_list|)
expr_stmt|;
name|bxe_mrrs
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|bxe_autogreeen
operator|<
literal|0
operator|)
operator|||
operator|(
name|bxe_autogreeen
operator|>
literal|2
operator|)
condition|)
block|{
name|BLOGW
argument_list|(
name|sc
argument_list|,
literal|"invalid autogreeen (%d)\n"
argument_list|,
name|bxe_autogreeen
argument_list|)
expr_stmt|;
name|bxe_autogreeen
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|bxe_udp_rss
operator|<
literal|0
operator|)
operator|||
operator|(
name|bxe_udp_rss
operator|>
literal|1
operator|)
condition|)
block|{
name|BLOGW
argument_list|(
name|sc
argument_list|,
literal|"invalid udp_rss (%d)\n"
argument_list|,
name|bxe_udp_rss
argument_list|)
expr_stmt|;
name|bxe_udp_rss
operator|=
literal|0
expr_stmt|;
block|}
comment|/* pull in user settings */
name|sc
operator|->
name|interrupt_mode
operator|=
name|bxe_interrupt_mode
expr_stmt|;
name|sc
operator|->
name|max_rx_bufs
operator|=
name|bxe_max_rx_bufs
expr_stmt|;
name|sc
operator|->
name|hc_rx_ticks
operator|=
name|bxe_hc_rx_ticks
expr_stmt|;
name|sc
operator|->
name|hc_tx_ticks
operator|=
name|bxe_hc_tx_ticks
expr_stmt|;
name|sc
operator|->
name|max_aggregation_size
operator|=
name|bxe_max_aggregation_size
expr_stmt|;
name|sc
operator|->
name|mrrs
operator|=
name|bxe_mrrs
expr_stmt|;
name|sc
operator|->
name|autogreeen
operator|=
name|bxe_autogreeen
expr_stmt|;
name|sc
operator|->
name|udp_rss
operator|=
name|bxe_udp_rss
expr_stmt|;
if|if
condition|(
name|bxe_interrupt_mode
operator|==
name|INTR_MODE_INTX
condition|)
block|{
name|sc
operator|->
name|num_queues
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* INTR_MODE_MSI or INTR_MODE_MSIX */
name|sc
operator|->
name|num_queues
operator|=
name|min
argument_list|(
operator|(
name|bxe_queue_count
condition|?
name|bxe_queue_count
else|:
name|mp_ncpus
operator|)
argument_list|,
name|MAX_RSS_CHAINS
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|num_queues
operator|>
name|mp_ncpus
condition|)
block|{
name|sc
operator|->
name|num_queues
operator|=
name|mp_ncpus
expr_stmt|;
block|}
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"User Config: "
literal|"debug=0x%lx "
literal|"interrupt_mode=%d "
literal|"queue_count=%d "
literal|"hc_rx_ticks=%d "
literal|"hc_tx_ticks=%d "
literal|"rx_budget=%d "
literal|"max_aggregation_size=%d "
literal|"mrrs=%d "
literal|"autogreeen=%d "
literal|"udp_rss=%d\n"
argument_list|,
name|bxe_debug
argument_list|,
name|sc
operator|->
name|interrupt_mode
argument_list|,
name|sc
operator|->
name|num_queues
argument_list|,
name|sc
operator|->
name|hc_rx_ticks
argument_list|,
name|sc
operator|->
name|hc_tx_ticks
argument_list|,
name|bxe_rx_budget
argument_list|,
name|sc
operator|->
name|max_aggregation_size
argument_list|,
name|sc
operator|->
name|mrrs
argument_list|,
name|sc
operator|->
name|autogreeen
argument_list|,
name|sc
operator|->
name|udp_rss
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_media_detect
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|port_type
decl_stmt|;
name|uint32_t
name|phy_idx
init|=
name|bxe_get_cur_phy_idx
argument_list|(
name|sc
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|link_params
operator|.
name|phy
index|[
name|phy_idx
index|]
operator|.
name|media_type
condition|)
block|{
case|case
name|ELINK_ETH_PHY_SFPP_10G_FIBER
case|:
case|case
name|ELINK_ETH_PHY_XFP_FIBER
case|:
name|BLOGI
argument_list|(
name|sc
argument_list|,
literal|"Found 10Gb Fiber media.\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|media
operator|=
name|IFM_10G_SR
expr_stmt|;
name|port_type
operator|=
name|PORT_FIBRE
expr_stmt|;
break|break;
case|case
name|ELINK_ETH_PHY_SFP_1G_FIBER
case|:
name|BLOGI
argument_list|(
name|sc
argument_list|,
literal|"Found 1Gb Fiber media.\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|media
operator|=
name|IFM_1000_SX
expr_stmt|;
name|port_type
operator|=
name|PORT_FIBRE
expr_stmt|;
break|break;
case|case
name|ELINK_ETH_PHY_KR
case|:
case|case
name|ELINK_ETH_PHY_CX4
case|:
name|BLOGI
argument_list|(
name|sc
argument_list|,
literal|"Found 10GBase-CX4 media.\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|media
operator|=
name|IFM_10G_CX4
expr_stmt|;
name|port_type
operator|=
name|PORT_FIBRE
expr_stmt|;
break|break;
case|case
name|ELINK_ETH_PHY_DA_TWINAX
case|:
name|BLOGI
argument_list|(
name|sc
argument_list|,
literal|"Found 10Gb Twinax media.\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|media
operator|=
name|IFM_10G_TWINAX
expr_stmt|;
name|port_type
operator|=
name|PORT_DA
expr_stmt|;
break|break;
case|case
name|ELINK_ETH_PHY_BASE_T
case|:
if|if
condition|(
name|sc
operator|->
name|link_params
operator|.
name|speed_cap_mask
index|[
literal|0
index|]
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_10G
condition|)
block|{
name|BLOGI
argument_list|(
name|sc
argument_list|,
literal|"Found 10GBase-T media.\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|media
operator|=
name|IFM_10G_T
expr_stmt|;
name|port_type
operator|=
name|PORT_TP
expr_stmt|;
block|}
else|else
block|{
name|BLOGI
argument_list|(
name|sc
argument_list|,
literal|"Found 1000Base-T media.\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|media
operator|=
name|IFM_1000_T
expr_stmt|;
name|port_type
operator|=
name|PORT_TP
expr_stmt|;
block|}
break|break;
case|case
name|ELINK_ETH_PHY_NOT_PRESENT
case|:
name|BLOGI
argument_list|(
name|sc
argument_list|,
literal|"Media not present.\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|media
operator|=
literal|0
expr_stmt|;
name|port_type
operator|=
name|PORT_OTHER
expr_stmt|;
break|break;
case|case
name|ELINK_ETH_PHY_UNSPECIFIED
case|:
default|default:
name|BLOGI
argument_list|(
name|sc
argument_list|,
literal|"Unknown media!\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|media
operator|=
literal|0
expr_stmt|;
name|port_type
operator|=
name|PORT_OTHER
expr_stmt|;
break|break;
block|}
return|return
name|port_type
return|;
block|}
end_function

begin_define
define|#
directive|define
name|GET_FIELD
parameter_list|(
name|value
parameter_list|,
name|fname
parameter_list|)
define|\
value|(((value)& (fname##_MASK))>> (fname##_SHIFT))
end_define

begin_define
define|#
directive|define
name|IGU_FID
parameter_list|(
name|val
parameter_list|)
value|GET_FIELD((val), IGU_REG_MAPPING_MEMORY_FID)
end_define

begin_define
define|#
directive|define
name|IGU_VEC
parameter_list|(
name|val
parameter_list|)
value|GET_FIELD((val), IGU_REG_MAPPING_MEMORY_VECTOR)
end_define

begin_function
specifier|static
name|int
name|bxe_get_igu_cam_info
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|pfid
init|=
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|int
name|igu_sb_id
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|uint8_t
name|fid
decl_stmt|,
name|igu_sb_cnt
init|=
literal|0
decl_stmt|;
name|sc
operator|->
name|igu_base_sb
operator|=
literal|0xff
expr_stmt|;
if|if
condition|(
name|CHIP_INT_MODE_IS_BC
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|int
name|vn
init|=
name|SC_VN
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|igu_sb_cnt
operator|=
name|sc
operator|->
name|igu_sb_cnt
expr_stmt|;
name|sc
operator|->
name|igu_base_sb
operator|=
operator|(
operator|(
name|CHIP_IS_MODE_4_PORT
argument_list|(
name|sc
argument_list|)
condition|?
name|pfid
else|:
name|vn
operator|)
operator|*
name|FP_SB_MAX_E1x
operator|)
expr_stmt|;
name|sc
operator|->
name|igu_dsb_id
operator|=
operator|(
name|E1HVN_MAX
operator|*
name|FP_SB_MAX_E1x
operator|+
operator|(
name|CHIP_IS_MODE_4_PORT
argument_list|(
name|sc
argument_list|)
condition|?
name|pfid
else|:
name|vn
operator|)
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* IGU in normal mode - read CAM */
for|for
control|(
name|igu_sb_id
operator|=
literal|0
init|;
name|igu_sb_id
operator|<
name|IGU_REG_MAPPING_MEMORY_SIZE
condition|;
name|igu_sb_id
operator|++
control|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|IGU_REG_MAPPING_MEMORY
operator|+
name|igu_sb_id
operator|*
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|&
name|IGU_REG_MAPPING_MEMORY_VALID
operator|)
condition|)
block|{
continue|continue;
block|}
name|fid
operator|=
name|IGU_FID
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fid
operator|&
name|IGU_FID_ENCODE_IS_PF
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|fid
operator|&
name|IGU_FID_PF_NUM_MASK
operator|)
operator|!=
name|pfid
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|IGU_VEC
argument_list|(
name|val
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* default status block */
name|sc
operator|->
name|igu_dsb_id
operator|=
name|igu_sb_id
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|igu_base_sb
operator|==
literal|0xff
condition|)
block|{
name|sc
operator|->
name|igu_base_sb
operator|=
name|igu_sb_id
expr_stmt|;
block|}
name|igu_sb_cnt
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/*      * Due to new PF resource allocation by MFW T7.4 and above, it's optional      * that number of CAM entries will not be equal to the value advertised in      * PCI. Driver should use the minimal value of both as the actual status      * block count      */
name|sc
operator|->
name|igu_sb_cnt
operator|=
name|min
argument_list|(
name|sc
operator|->
name|igu_sb_cnt
argument_list|,
name|igu_sb_cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|igu_sb_cnt
operator|==
literal|0
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"CAM configuration error\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Gather various information from the device config space, the device itself,  * shmem, and the user input.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_get_device_info
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* Get the data for the device */
name|sc
operator|->
name|devinfo
operator|.
name|vendor_id
operator|=
name|pci_get_vendor
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|devinfo
operator|.
name|device_id
operator|=
name|pci_get_device
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|devinfo
operator|.
name|subvendor_id
operator|=
name|pci_get_subvendor
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|devinfo
operator|.
name|subdevice_id
operator|=
name|pci_get_subdevice
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
comment|/* get the chip revision (chip metal comes from pci config space) */
name|sc
operator|->
name|devinfo
operator|.
name|chip_id
operator|=
name|sc
operator|->
name|link_params
operator|.
name|chip_id
operator|=
operator|(
operator|(
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_CHIP_NUM
argument_list|)
operator|&
literal|0xffff
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_CHIP_REV
argument_list|)
operator|&
literal|0xf
operator|)
operator|<<
literal|12
operator|)
operator||
operator|(
operator|(
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|PCICFG_OFFSET
operator|+
name|PCI_ID_VAL3
argument_list|)
operator|>>
literal|24
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_BOND_ID
argument_list|)
operator|&
literal|0xf
operator|)
operator|<<
literal|0
operator|)
operator|)
expr_stmt|;
comment|/* force 57811 according to MISC register */
if|if
condition|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_CHIP_TYPE
argument_list|)
operator|&
name|MISC_REG_CHIP_TYPE_57811_MASK
condition|)
block|{
if|if
condition|(
name|CHIP_IS_57810
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|sc
operator|->
name|devinfo
operator|.
name|chip_id
operator|=
operator|(
operator|(
name|CHIP_NUM_57811
operator|<<
literal|16
operator|)
operator||
operator|(
name|sc
operator|->
name|devinfo
operator|.
name|chip_id
operator|&
literal|0x0000ffff
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CHIP_IS_57810_MF
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|sc
operator|->
name|devinfo
operator|.
name|chip_id
operator|=
operator|(
operator|(
name|CHIP_NUM_57811_MF
operator|<<
literal|16
operator|)
operator||
operator|(
name|sc
operator|->
name|devinfo
operator|.
name|chip_id
operator|&
literal|0x0000ffff
operator|)
operator|)
expr_stmt|;
block|}
name|sc
operator|->
name|devinfo
operator|.
name|chip_id
operator||=
literal|0x1
expr_stmt|;
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"chip_id=0x%08x (num=0x%04x rev=0x%01x metal=0x%02x bond=0x%01x)\n"
argument_list|,
name|sc
operator|->
name|devinfo
operator|.
name|chip_id
argument_list|,
operator|(
operator|(
name|sc
operator|->
name|devinfo
operator|.
name|chip_id
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
argument_list|,
operator|(
operator|(
name|sc
operator|->
name|devinfo
operator|.
name|chip_id
operator|>>
literal|12
operator|)
operator|&
literal|0xf
operator|)
argument_list|,
operator|(
operator|(
name|sc
operator|->
name|devinfo
operator|.
name|chip_id
operator|>>
literal|4
operator|)
operator|&
literal|0xff
operator|)
argument_list|,
operator|(
operator|(
name|sc
operator|->
name|devinfo
operator|.
name|chip_id
operator|>>
literal|0
operator|)
operator|&
literal|0xf
operator|)
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
literal|0x2874
argument_list|)
operator|&
literal|0x55
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|devinfo
operator|.
name|chip_id
operator|&
literal|0x1
operator|)
operator|||
operator|(
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
operator|&&
name|val
operator|)
operator|||
operator|(
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
operator|&&
operator|(
name|val
operator|==
literal|0x55
operator|)
operator|)
condition|)
block|{
name|sc
operator|->
name|flags
operator||=
name|BXE_ONE_PORT_FLAG
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"single port device\n"
argument_list|)
expr_stmt|;
block|}
comment|/* set the doorbell size */
name|sc
operator|->
name|doorbell_size
operator|=
operator|(
literal|1
operator|<<
name|BXE_DB_SHIFT
operator|)
expr_stmt|;
comment|/* determine whether the device is in 2 port or 4 port mode */
name|sc
operator|->
name|devinfo
operator|.
name|chip_port_mode
operator|=
name|CHIP_PORT_MODE_NONE
expr_stmt|;
comment|/* E1& E1h*/
if|if
condition|(
name|CHIP_IS_E2E3
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/*          * Read port4mode_en_ovwr[0]:          *   If 1, four port mode is in port4mode_en_ovwr[1].          *   If 0, four port mode is in port4mode_en[0].          */
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_PORT4MODE_EN_OVWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
literal|1
condition|)
block|{
name|val
operator|=
operator|(
operator|(
name|val
operator|>>
literal|1
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_PORT4MODE_EN
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|devinfo
operator|.
name|chip_port_mode
operator|=
operator|(
name|val
operator|)
condition|?
name|CHIP_4_PORT_MODE
else|:
name|CHIP_2_PORT_MODE
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Port mode = %s\n"
argument_list|,
operator|(
name|val
operator|)
condition|?
literal|"4"
else|:
literal|"2"
argument_list|)
expr_stmt|;
block|}
comment|/* get the function and path info for the device */
name|bxe_get_function_num
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* get the shared memory base address */
name|sc
operator|->
name|devinfo
operator|.
name|shmem_base
operator|=
name|sc
operator|->
name|link_params
operator|.
name|shmem_base
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_SHARED_MEM_ADDR
argument_list|)
expr_stmt|;
name|sc
operator|->
name|devinfo
operator|.
name|shmem2_base
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
operator|(
name|SC_PATH
argument_list|(
name|sc
argument_list|)
condition|?
name|MISC_REG_GENERIC_CR_1
else|:
name|MISC_REG_GENERIC_CR_0
operator|)
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"shmem_base=0x%08x, shmem2_base=0x%08x\n"
argument_list|,
name|sc
operator|->
name|devinfo
operator|.
name|shmem_base
argument_list|,
name|sc
operator|->
name|devinfo
operator|.
name|shmem2_base
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|devinfo
operator|.
name|shmem_base
condition|)
block|{
comment|/* this should ONLY prevent upcoming shmem reads */
name|BLOGI
argument_list|(
name|sc
argument_list|,
literal|"MCP not active\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|BXE_NO_MCP_FLAG
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* make sure the shared memory contents are valid */
name|val
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|validity_map
index|[
name|SC_PORT
argument_list|(
name|sc
argument_list|)
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
operator|(
name|SHR_MEM_VALIDITY_DEV_INFO
operator||
name|SHR_MEM_VALIDITY_MB
operator|)
operator|)
operator|!=
operator|(
name|SHR_MEM_VALIDITY_DEV_INFO
operator||
name|SHR_MEM_VALIDITY_MB
operator|)
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Invalid SHMEM validity signature: 0x%08x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Valid SHMEM validity signature: 0x%08x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* get the bootcode version */
name|sc
operator|->
name|devinfo
operator|.
name|bc_ver
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|dev_info
operator|.
name|bc_rev
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|sc
operator|->
name|devinfo
operator|.
name|bc_ver_str
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|devinfo
operator|.
name|bc_ver_str
argument_list|)
argument_list|,
literal|"%d.%d.%d"
argument_list|,
operator|(
operator|(
name|sc
operator|->
name|devinfo
operator|.
name|bc_ver
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
argument_list|,
operator|(
operator|(
name|sc
operator|->
name|devinfo
operator|.
name|bc_ver
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
argument_list|,
operator|(
operator|(
name|sc
operator|->
name|devinfo
operator|.
name|bc_ver
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Bootcode version: %s\n"
argument_list|,
name|sc
operator|->
name|devinfo
operator|.
name|bc_ver_str
argument_list|)
expr_stmt|;
comment|/* get the bootcode shmem address */
name|sc
operator|->
name|devinfo
operator|.
name|mf_cfg_base
operator|=
name|bxe_get_shmem_mf_cfg_base
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"mf_cfg_base=0x08%x \n"
argument_list|,
name|sc
operator|->
name|devinfo
operator|.
name|mf_cfg_base
argument_list|)
expr_stmt|;
comment|/* clean indirect addresses as they're not used */
name|pci_write_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|PCICFG_GRC_ADDRESS
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_PF
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_PGL_ADDR_88_F0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_PGL_ADDR_8C_F0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_PGL_ADDR_90_F0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_PGL_ADDR_94_F0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_PGL_ADDR_88_F1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_PGL_ADDR_8C_F1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_PGL_ADDR_90_F1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_PGL_ADDR_94_F1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*          * Enable internal target-read (in case we are probed after PF          * FLR). Must be done prior to any BAR read access. Only for          * 57712 and up          */
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PGLUE_B_REG_INTERNAL_PFID_ENABLE_TARGET_READ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* get the nvram size */
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_NVM_CFG4
argument_list|)
expr_stmt|;
name|sc
operator|->
name|devinfo
operator|.
name|flash_size
operator|=
operator|(
name|NVRAM_1MB_SIZE
operator|<<
operator|(
name|val
operator|&
name|MCPR_NVM_CFG4_FLASH_SIZE
operator|)
operator|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"nvram flash size: %d\n"
argument_list|,
name|sc
operator|->
name|devinfo
operator|.
name|flash_size
argument_list|)
expr_stmt|;
comment|/* get PCI capabilites */
name|bxe_probe_pci_caps
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_set_power_state
argument_list|(
name|sc
argument_list|,
name|PCI_PM_D0
argument_list|)
expr_stmt|;
comment|/* get various configuration parameters from shmem */
name|bxe_get_shmem_info
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|devinfo
operator|.
name|pcie_msix_cap_reg
operator|!=
literal|0
condition|)
block|{
name|val
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
operator|(
name|sc
operator|->
name|devinfo
operator|.
name|pcie_msix_cap_reg
operator|+
name|PCIR_MSIX_CTRL
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|igu_sb_cnt
operator|=
operator|(
name|val
operator|&
name|PCIM_MSIXCTRL_TABLE_SIZE
operator|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|igu_sb_cnt
operator|=
literal|1
expr_stmt|;
block|}
name|sc
operator|->
name|igu_base_addr
operator|=
name|BAR_IGU_INTMEM
expr_stmt|;
comment|/* initialize IGU parameters */
if|if
condition|(
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|sc
operator|->
name|devinfo
operator|.
name|int_block
operator|=
name|INT_BLOCK_HC
expr_stmt|;
name|sc
operator|->
name|igu_dsb_id
operator|=
name|DEF_SB_IGU_ID
expr_stmt|;
name|sc
operator|->
name|igu_base_sb
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|devinfo
operator|.
name|int_block
operator|=
name|INT_BLOCK_IGU
expr_stmt|;
comment|/* do not allow device reset during IGU info preocessing */
name|bxe_acquire_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_RESET
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|IGU_REG_BLOCK_CONFIGURATION
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|IGU_BLOCK_CONFIGURATION_REG_BACKWARD_COMP_EN
condition|)
block|{
name|int
name|tout
init|=
literal|5000
decl_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"FORCING IGU Normal Mode\n"
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
name|IGU_BLOCK_CONFIGURATION_REG_BACKWARD_COMP_EN
operator|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|IGU_REG_BLOCK_CONFIGURATION
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|IGU_REG_RESET_MEMORIES
argument_list|,
literal|0x7f
argument_list|)
expr_stmt|;
while|while
condition|(
name|tout
operator|&&
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|IGU_REG_RESET_MEMORIES
argument_list|)
condition|)
block|{
name|tout
operator|--
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|IGU_REG_RESET_MEMORIES
argument_list|)
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"FORCING IGU Normal Mode failed!!!\n"
argument_list|)
expr_stmt|;
name|bxe_release_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_RESET
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|val
operator|&
name|IGU_BLOCK_CONFIGURATION_REG_BACKWARD_COMP_EN
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"IGU Backward Compatible Mode\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|devinfo
operator|.
name|int_block
operator||=
name|INT_BLOCK_MODE_BW_COMP
expr_stmt|;
block|}
else|else
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"IGU Normal Mode\n"
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|bxe_get_igu_cam_info
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_release_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_RESET
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
return|return
operator|(
name|rc
operator|)
return|;
block|}
block|}
comment|/*      * Get base FW non-default (fast path) status block ID. This value is      * used to initialize the fw_sb_id saved on the fp/queue structure to      * determine the id used by the FW.      */
if|if
condition|(
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|sc
operator|->
name|base_fw_ndsb
operator|=
operator|(
operator|(
name|SC_PORT
argument_list|(
name|sc
argument_list|)
operator|*
name|FP_SB_MAX_E1x
operator|)
operator|+
name|SC_L_ID
argument_list|(
name|sc
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/*          * 57712+ - We currently use one FW SB per IGU SB (Rx and Tx of          * the same queue are indicated on the same IGU SB). So we prefer          * FW and IGU SBs to be the same value.          */
name|sc
operator|->
name|base_fw_ndsb
operator|=
name|sc
operator|->
name|igu_base_sb
expr_stmt|;
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"igu_dsb_id=%d igu_base_sb=%d igu_sb_cnt=%d base_fw_ndsb=%d\n"
argument_list|,
name|sc
operator|->
name|igu_dsb_id
argument_list|,
name|sc
operator|->
name|igu_base_sb
argument_list|,
name|sc
operator|->
name|igu_sb_cnt
argument_list|,
name|sc
operator|->
name|base_fw_ndsb
argument_list|)
expr_stmt|;
name|elink_phy_probe
argument_list|(
operator|&
name|sc
operator|->
name|link_params
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_link_settings_supported
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|switch_cfg
parameter_list|)
block|{
name|uint32_t
name|cfg_size
init|=
literal|0
decl_stmt|;
name|uint32_t
name|idx
decl_stmt|;
name|uint8_t
name|port
init|=
name|SC_PORT
argument_list|(
name|sc
argument_list|)
decl_stmt|;
comment|/* aggregation of supported attributes of all external phys */
name|sc
operator|->
name|port
operator|.
name|supported
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|port
operator|.
name|supported
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|link_params
operator|.
name|num_phys
condition|)
block|{
case|case
literal|1
case|:
name|sc
operator|->
name|port
operator|.
name|supported
index|[
literal|0
index|]
operator|=
name|sc
operator|->
name|link_params
operator|.
name|phy
index|[
name|ELINK_INT_PHY
index|]
operator|.
name|supported
expr_stmt|;
name|cfg_size
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|sc
operator|->
name|port
operator|.
name|supported
index|[
literal|0
index|]
operator|=
name|sc
operator|->
name|link_params
operator|.
name|phy
index|[
name|ELINK_EXT_PHY1
index|]
operator|.
name|supported
expr_stmt|;
name|cfg_size
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|sc
operator|->
name|link_params
operator|.
name|multi_phy_config
operator|&
name|PORT_HW_CFG_PHY_SWAPPED_ENABLED
condition|)
block|{
name|sc
operator|->
name|port
operator|.
name|supported
index|[
literal|1
index|]
operator|=
name|sc
operator|->
name|link_params
operator|.
name|phy
index|[
name|ELINK_EXT_PHY1
index|]
operator|.
name|supported
expr_stmt|;
name|sc
operator|->
name|port
operator|.
name|supported
index|[
literal|0
index|]
operator|=
name|sc
operator|->
name|link_params
operator|.
name|phy
index|[
name|ELINK_EXT_PHY2
index|]
operator|.
name|supported
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|port
operator|.
name|supported
index|[
literal|0
index|]
operator|=
name|sc
operator|->
name|link_params
operator|.
name|phy
index|[
name|ELINK_EXT_PHY1
index|]
operator|.
name|supported
expr_stmt|;
name|sc
operator|->
name|port
operator|.
name|supported
index|[
literal|1
index|]
operator|=
name|sc
operator|->
name|link_params
operator|.
name|phy
index|[
name|ELINK_EXT_PHY2
index|]
operator|.
name|supported
expr_stmt|;
block|}
name|cfg_size
operator|=
literal|2
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|port
operator|.
name|supported
index|[
literal|0
index|]
operator|||
name|sc
operator|->
name|port
operator|.
name|supported
index|[
literal|1
index|]
operator|)
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Invalid phy config in NVRAM (PHY1=0x%08x PHY2=0x%08x)\n"
argument_list|,
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|port
index|]
operator|.
name|external_phy_config
argument_list|)
argument_list|,
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|port
index|]
operator|.
name|external_phy_config2
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
name|sc
operator|->
name|port
operator|.
name|phy_addr
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_WC0_CTRL_PHY_ADDR
argument_list|)
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|switch_cfg
condition|)
block|{
case|case
name|ELINK_SWITCH_CFG_1G
case|:
name|sc
operator|->
name|port
operator|.
name|phy_addr
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_SERDES0_CTRL_PHY_ADDR
operator|+
name|port
operator|*
literal|0x10
argument_list|)
expr_stmt|;
break|break;
case|case
name|ELINK_SWITCH_CFG_10G
case|:
name|sc
operator|->
name|port
operator|.
name|phy_addr
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_XGXS0_CTRL_PHY_ADDR
operator|+
name|port
operator|*
literal|0x18
argument_list|)
expr_stmt|;
break|break;
default|default:
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Invalid switch config in link_config=0x%08x\n"
argument_list|,
name|sc
operator|->
name|port
operator|.
name|link_config
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"PHY addr 0x%08x\n"
argument_list|,
name|sc
operator|->
name|port
operator|.
name|phy_addr
argument_list|)
expr_stmt|;
comment|/* mask what we support according to speed_cap_mask per configuration */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|cfg_size
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|link_params
operator|.
name|speed_cap_mask
index|[
name|idx
index|]
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_10M_HALF
operator|)
condition|)
block|{
name|sc
operator|->
name|port
operator|.
name|supported
index|[
name|idx
index|]
operator|&=
operator|~
name|ELINK_SUPPORTED_10baseT_Half
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|link_params
operator|.
name|speed_cap_mask
index|[
name|idx
index|]
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_10M_FULL
operator|)
condition|)
block|{
name|sc
operator|->
name|port
operator|.
name|supported
index|[
name|idx
index|]
operator|&=
operator|~
name|ELINK_SUPPORTED_10baseT_Full
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|link_params
operator|.
name|speed_cap_mask
index|[
name|idx
index|]
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_100M_HALF
operator|)
condition|)
block|{
name|sc
operator|->
name|port
operator|.
name|supported
index|[
name|idx
index|]
operator|&=
operator|~
name|ELINK_SUPPORTED_100baseT_Half
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|link_params
operator|.
name|speed_cap_mask
index|[
name|idx
index|]
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_100M_FULL
operator|)
condition|)
block|{
name|sc
operator|->
name|port
operator|.
name|supported
index|[
name|idx
index|]
operator|&=
operator|~
name|ELINK_SUPPORTED_100baseT_Full
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|link_params
operator|.
name|speed_cap_mask
index|[
name|idx
index|]
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_1G
operator|)
condition|)
block|{
name|sc
operator|->
name|port
operator|.
name|supported
index|[
name|idx
index|]
operator|&=
operator|~
name|ELINK_SUPPORTED_1000baseT_Full
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|link_params
operator|.
name|speed_cap_mask
index|[
name|idx
index|]
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_2_5G
operator|)
condition|)
block|{
name|sc
operator|->
name|port
operator|.
name|supported
index|[
name|idx
index|]
operator|&=
operator|~
name|ELINK_SUPPORTED_2500baseX_Full
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|link_params
operator|.
name|speed_cap_mask
index|[
name|idx
index|]
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_10G
operator|)
condition|)
block|{
name|sc
operator|->
name|port
operator|.
name|supported
index|[
name|idx
index|]
operator|&=
operator|~
name|ELINK_SUPPORTED_10000baseT_Full
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|link_params
operator|.
name|speed_cap_mask
index|[
name|idx
index|]
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_20G
operator|)
condition|)
block|{
name|sc
operator|->
name|port
operator|.
name|supported
index|[
name|idx
index|]
operator|&=
operator|~
name|ELINK_SUPPORTED_20000baseKR2_Full
expr_stmt|;
block|}
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"PHY supported 0=0x%08x 1=0x%08x\n"
argument_list|,
name|sc
operator|->
name|port
operator|.
name|supported
index|[
literal|0
index|]
argument_list|,
name|sc
operator|->
name|port
operator|.
name|supported
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"PHY supported 0=0x%08x 1=0x%08x\n"
argument_list|,
name|sc
operator|->
name|port
operator|.
name|supported
index|[
literal|0
index|]
argument_list|,
name|sc
operator|->
name|port
operator|.
name|supported
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_link_settings_requested
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|link_config
decl_stmt|;
name|uint32_t
name|idx
decl_stmt|;
name|uint32_t
name|cfg_size
init|=
literal|0
decl_stmt|;
name|sc
operator|->
name|port
operator|.
name|advertising
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|port
operator|.
name|advertising
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|link_params
operator|.
name|num_phys
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|2
case|:
name|cfg_size
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|cfg_size
operator|=
literal|2
expr_stmt|;
break|break;
block|}
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|cfg_size
condition|;
name|idx
operator|++
control|)
block|{
name|sc
operator|->
name|link_params
operator|.
name|req_duplex
index|[
name|idx
index|]
operator|=
name|DUPLEX_FULL
expr_stmt|;
name|link_config
operator|=
name|sc
operator|->
name|port
operator|.
name|link_config
index|[
name|idx
index|]
expr_stmt|;
switch|switch
condition|(
name|link_config
operator|&
name|PORT_FEATURE_LINK_SPEED_MASK
condition|)
block|{
case|case
name|PORT_FEATURE_LINK_SPEED_AUTO
case|:
if|if
condition|(
name|sc
operator|->
name|port
operator|.
name|supported
index|[
name|idx
index|]
operator|&
name|ELINK_SUPPORTED_Autoneg
condition|)
block|{
name|sc
operator|->
name|link_params
operator|.
name|req_line_speed
index|[
name|idx
index|]
operator|=
name|ELINK_SPEED_AUTO_NEG
expr_stmt|;
name|sc
operator|->
name|port
operator|.
name|advertising
index|[
name|idx
index|]
operator||=
name|sc
operator|->
name|port
operator|.
name|supported
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|link_params
operator|.
name|phy
index|[
name|ELINK_EXT_PHY1
index|]
operator|.
name|type
operator|==
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84833
condition|)
name|sc
operator|->
name|port
operator|.
name|advertising
index|[
name|idx
index|]
operator||=
operator|(
name|ELINK_SUPPORTED_100baseT_Half
operator||
name|ELINK_SUPPORTED_100baseT_Full
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* force 10G, no AN */
name|sc
operator|->
name|link_params
operator|.
name|req_line_speed
index|[
name|idx
index|]
operator|=
name|ELINK_SPEED_10000
expr_stmt|;
name|sc
operator|->
name|port
operator|.
name|advertising
index|[
name|idx
index|]
operator||=
operator|(
name|ADVERTISED_10000baseT_Full
operator||
name|ADVERTISED_FIBRE
operator|)
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|PORT_FEATURE_LINK_SPEED_10M_FULL
case|:
if|if
condition|(
name|sc
operator|->
name|port
operator|.
name|supported
index|[
name|idx
index|]
operator|&
name|ELINK_SUPPORTED_10baseT_Full
condition|)
block|{
name|sc
operator|->
name|link_params
operator|.
name|req_line_speed
index|[
name|idx
index|]
operator|=
name|ELINK_SPEED_10
expr_stmt|;
name|sc
operator|->
name|port
operator|.
name|advertising
index|[
name|idx
index|]
operator||=
operator|(
name|ADVERTISED_10baseT_Full
operator||
name|ADVERTISED_TP
operator|)
expr_stmt|;
block|}
else|else
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Invalid NVRAM config link_config=0x%08x "
literal|"speed_cap_mask=0x%08x\n"
argument_list|,
name|link_config
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|speed_cap_mask
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|PORT_FEATURE_LINK_SPEED_10M_HALF
case|:
if|if
condition|(
name|sc
operator|->
name|port
operator|.
name|supported
index|[
name|idx
index|]
operator|&
name|ELINK_SUPPORTED_10baseT_Half
condition|)
block|{
name|sc
operator|->
name|link_params
operator|.
name|req_line_speed
index|[
name|idx
index|]
operator|=
name|ELINK_SPEED_10
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|req_duplex
index|[
name|idx
index|]
operator|=
name|DUPLEX_HALF
expr_stmt|;
name|sc
operator|->
name|port
operator|.
name|advertising
index|[
name|idx
index|]
operator||=
operator|(
name|ADVERTISED_10baseT_Half
operator||
name|ADVERTISED_TP
operator|)
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"driver requesting DUPLEX_HALF req_duplex = %x!\n"
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|req_duplex
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Invalid NVRAM config link_config=0x%08x "
literal|"speed_cap_mask=0x%08x\n"
argument_list|,
name|link_config
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|speed_cap_mask
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|PORT_FEATURE_LINK_SPEED_100M_FULL
case|:
if|if
condition|(
name|sc
operator|->
name|port
operator|.
name|supported
index|[
name|idx
index|]
operator|&
name|ELINK_SUPPORTED_100baseT_Full
condition|)
block|{
name|sc
operator|->
name|link_params
operator|.
name|req_line_speed
index|[
name|idx
index|]
operator|=
name|ELINK_SPEED_100
expr_stmt|;
name|sc
operator|->
name|port
operator|.
name|advertising
index|[
name|idx
index|]
operator||=
operator|(
name|ADVERTISED_100baseT_Full
operator||
name|ADVERTISED_TP
operator|)
expr_stmt|;
block|}
else|else
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Invalid NVRAM config link_config=0x%08x "
literal|"speed_cap_mask=0x%08x\n"
argument_list|,
name|link_config
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|speed_cap_mask
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|PORT_FEATURE_LINK_SPEED_100M_HALF
case|:
if|if
condition|(
name|sc
operator|->
name|port
operator|.
name|supported
index|[
name|idx
index|]
operator|&
name|ELINK_SUPPORTED_100baseT_Half
condition|)
block|{
name|sc
operator|->
name|link_params
operator|.
name|req_line_speed
index|[
name|idx
index|]
operator|=
name|ELINK_SPEED_100
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|req_duplex
index|[
name|idx
index|]
operator|=
name|DUPLEX_HALF
expr_stmt|;
name|sc
operator|->
name|port
operator|.
name|advertising
index|[
name|idx
index|]
operator||=
operator|(
name|ADVERTISED_100baseT_Half
operator||
name|ADVERTISED_TP
operator|)
expr_stmt|;
block|}
else|else
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Invalid NVRAM config link_config=0x%08x "
literal|"speed_cap_mask=0x%08x\n"
argument_list|,
name|link_config
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|speed_cap_mask
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|PORT_FEATURE_LINK_SPEED_1G
case|:
if|if
condition|(
name|sc
operator|->
name|port
operator|.
name|supported
index|[
name|idx
index|]
operator|&
name|ELINK_SUPPORTED_1000baseT_Full
condition|)
block|{
name|sc
operator|->
name|link_params
operator|.
name|req_line_speed
index|[
name|idx
index|]
operator|=
name|ELINK_SPEED_1000
expr_stmt|;
name|sc
operator|->
name|port
operator|.
name|advertising
index|[
name|idx
index|]
operator||=
operator|(
name|ADVERTISED_1000baseT_Full
operator||
name|ADVERTISED_TP
operator|)
expr_stmt|;
block|}
else|else
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Invalid NVRAM config link_config=0x%08x "
literal|"speed_cap_mask=0x%08x\n"
argument_list|,
name|link_config
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|speed_cap_mask
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|PORT_FEATURE_LINK_SPEED_2_5G
case|:
if|if
condition|(
name|sc
operator|->
name|port
operator|.
name|supported
index|[
name|idx
index|]
operator|&
name|ELINK_SUPPORTED_2500baseX_Full
condition|)
block|{
name|sc
operator|->
name|link_params
operator|.
name|req_line_speed
index|[
name|idx
index|]
operator|=
name|ELINK_SPEED_2500
expr_stmt|;
name|sc
operator|->
name|port
operator|.
name|advertising
index|[
name|idx
index|]
operator||=
operator|(
name|ADVERTISED_2500baseX_Full
operator||
name|ADVERTISED_TP
operator|)
expr_stmt|;
block|}
else|else
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Invalid NVRAM config link_config=0x%08x "
literal|"speed_cap_mask=0x%08x\n"
argument_list|,
name|link_config
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|speed_cap_mask
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|PORT_FEATURE_LINK_SPEED_10G_CX4
case|:
if|if
condition|(
name|sc
operator|->
name|port
operator|.
name|supported
index|[
name|idx
index|]
operator|&
name|ELINK_SUPPORTED_10000baseT_Full
condition|)
block|{
name|sc
operator|->
name|link_params
operator|.
name|req_line_speed
index|[
name|idx
index|]
operator|=
name|ELINK_SPEED_10000
expr_stmt|;
name|sc
operator|->
name|port
operator|.
name|advertising
index|[
name|idx
index|]
operator||=
operator|(
name|ADVERTISED_10000baseT_Full
operator||
name|ADVERTISED_FIBRE
operator|)
expr_stmt|;
block|}
else|else
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Invalid NVRAM config link_config=0x%08x "
literal|"speed_cap_mask=0x%08x\n"
argument_list|,
name|link_config
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|speed_cap_mask
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|PORT_FEATURE_LINK_SPEED_20G
case|:
name|sc
operator|->
name|link_params
operator|.
name|req_line_speed
index|[
name|idx
index|]
operator|=
name|ELINK_SPEED_20000
expr_stmt|;
break|break;
default|default:
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Invalid NVRAM config link_config=0x%08x "
literal|"speed_cap_mask=0x%08x\n"
argument_list|,
name|link_config
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|speed_cap_mask
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|link_params
operator|.
name|req_line_speed
index|[
name|idx
index|]
operator|=
name|ELINK_SPEED_AUTO_NEG
expr_stmt|;
name|sc
operator|->
name|port
operator|.
name|advertising
index|[
name|idx
index|]
operator|=
name|sc
operator|->
name|port
operator|.
name|supported
index|[
name|idx
index|]
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|link_params
operator|.
name|req_flow_ctrl
index|[
name|idx
index|]
operator|=
operator|(
name|link_config
operator|&
name|PORT_FEATURE_FLOW_CONTROL_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|link_params
operator|.
name|req_flow_ctrl
index|[
name|idx
index|]
operator|==
name|ELINK_FLOW_CTRL_AUTO
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|port
operator|.
name|supported
index|[
name|idx
index|]
operator|&
name|ELINK_SUPPORTED_Autoneg
operator|)
condition|)
block|{
name|sc
operator|->
name|link_params
operator|.
name|req_flow_ctrl
index|[
name|idx
index|]
operator|=
name|ELINK_FLOW_CTRL_NONE
expr_stmt|;
block|}
else|else
block|{
name|bxe_set_requested_fc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"req_line_speed=%d req_duplex=%d "
literal|"req_flow_ctrl=0x%x advertising=0x%x\n"
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|req_line_speed
index|[
name|idx
index|]
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|req_duplex
index|[
name|idx
index|]
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|req_flow_ctrl
index|[
name|idx
index|]
argument_list|,
name|sc
operator|->
name|port
operator|.
name|advertising
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P3
argument_list|(
name|sc
argument_list|,
literal|"req_line_speed=%d req_duplex=%d "
literal|"advertising=0x%x\n"
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|req_line_speed
index|[
name|idx
index|]
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|req_duplex
index|[
name|idx
index|]
argument_list|,
name|sc
operator|->
name|port
operator|.
name|advertising
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_get_phy_info
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint8_t
name|port
init|=
name|SC_PORT
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|uint32_t
name|config
init|=
name|sc
operator|->
name|port
operator|.
name|config
decl_stmt|;
name|uint32_t
name|eee_mode
decl_stmt|;
comment|/* shmem data already read in bxe_get_shmem_info() */
name|ELINK_DEBUG_P3
argument_list|(
name|sc
argument_list|,
literal|"lane_config=0x%08x speed_cap_mask0=0x%08x "
literal|"link_config0=0x%08x\n"
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|lane_config
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|speed_cap_mask
index|[
literal|0
index|]
argument_list|,
name|sc
operator|->
name|port
operator|.
name|link_config
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|bxe_link_settings_supported
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|link_params
operator|.
name|switch_cfg
argument_list|)
expr_stmt|;
name|bxe_link_settings_requested
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|autogreeen
operator|==
name|AUTO_GREEN_FORCE_ON
condition|)
block|{
name|sc
operator|->
name|link_params
operator|.
name|feature_config_flags
operator||=
name|ELINK_FEATURE_CONFIG_AUTOGREEEN_ENABLED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|autogreeen
operator|==
name|AUTO_GREEN_FORCE_OFF
condition|)
block|{
name|sc
operator|->
name|link_params
operator|.
name|feature_config_flags
operator|&=
operator|~
name|ELINK_FEATURE_CONFIG_AUTOGREEEN_ENABLED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|config
operator|&
name|PORT_FEAT_CFG_AUTOGREEEN_ENABLED
condition|)
block|{
name|sc
operator|->
name|link_params
operator|.
name|feature_config_flags
operator||=
name|ELINK_FEATURE_CONFIG_AUTOGREEEN_ENABLED
expr_stmt|;
block|}
comment|/* configure link feature according to nvram value */
name|eee_mode
operator|=
operator|(
operator|(
operator|(
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|dev_info
operator|.
name|port_feature_config
index|[
name|port
index|]
operator|.
name|eee_power_mode
argument_list|)
operator|)
operator|&
name|PORT_FEAT_CFG_EEE_POWER_MODE_MASK
operator|)
operator|>>
name|PORT_FEAT_CFG_EEE_POWER_MODE_SHIFT
operator|)
expr_stmt|;
if|if
condition|(
name|eee_mode
operator|!=
name|PORT_FEAT_CFG_EEE_POWER_MODE_DISABLED
condition|)
block|{
name|sc
operator|->
name|link_params
operator|.
name|eee_mode
operator|=
operator|(
name|ELINK_EEE_MODE_ADV_LPI
operator||
name|ELINK_EEE_MODE_ENABLE_LPI
operator||
name|ELINK_EEE_MODE_OUTPUT_TIME
operator|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|link_params
operator|.
name|eee_mode
operator|=
literal|0
expr_stmt|;
block|}
comment|/* get the media type */
name|bxe_media_detect
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"detected media type\n"
argument_list|,
name|sc
operator|->
name|media
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_get_params
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* get user tunable params */
name|bxe_get_tunable_params
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* select the RX and TX ring sizes */
name|sc
operator|->
name|tx_ring_size
operator|=
name|TX_BD_USABLE
expr_stmt|;
name|sc
operator|->
name|rx_ring_size
operator|=
name|RX_BD_USABLE
expr_stmt|;
comment|/* XXX disable WoL */
name|sc
operator|->
name|wol
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_set_modes_bitmap
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|CHIP_REV_IS_FPGA
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|SET_FLAGS
argument_list|(
name|flags
argument_list|,
name|MODE_FPGA
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CHIP_REV_IS_EMUL
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|SET_FLAGS
argument_list|(
name|flags
argument_list|,
name|MODE_EMUL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SET_FLAGS
argument_list|(
name|flags
argument_list|,
name|MODE_ASIC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CHIP_IS_MODE_4_PORT
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|SET_FLAGS
argument_list|(
name|flags
argument_list|,
name|MODE_PORT4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SET_FLAGS
argument_list|(
name|flags
argument_list|,
name|MODE_PORT2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CHIP_IS_E2
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|SET_FLAGS
argument_list|(
name|flags
argument_list|,
name|MODE_E2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|SET_FLAGS
argument_list|(
name|flags
argument_list|,
name|MODE_E3
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_REV
argument_list|(
name|sc
argument_list|)
operator|==
name|CHIP_REV_Ax
condition|)
block|{
name|SET_FLAGS
argument_list|(
name|flags
argument_list|,
name|MODE_E3_A0
argument_list|)
expr_stmt|;
block|}
else|else
comment|/*if (CHIP_REV(sc) == CHIP_REV_Bx)*/
block|{
name|SET_FLAGS
argument_list|(
name|flags
argument_list|,
name|MODE_E3_B0
operator||
name|MODE_COS3
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|IS_MF
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|SET_FLAGS
argument_list|(
name|flags
argument_list|,
name|MODE_MF
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|devinfo
operator|.
name|mf_info
operator|.
name|mf_mode
condition|)
block|{
case|case
name|MULTI_FUNCTION_SD
case|:
name|SET_FLAGS
argument_list|(
name|flags
argument_list|,
name|MODE_MF_SD
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULTI_FUNCTION_SI
case|:
name|SET_FLAGS
argument_list|(
name|flags
argument_list|,
name|MODE_MF_SI
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULTI_FUNCTION_AFEX
case|:
name|SET_FLAGS
argument_list|(
name|flags
argument_list|,
name|MODE_MF_AFEX
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|SET_FLAGS
argument_list|(
name|flags
argument_list|,
name|MODE_SF
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__LITTLE_ENDIAN
argument_list|)
name|SET_FLAGS
argument_list|(
name|flags
argument_list|,
name|MODE_LITTLE_ENDIAN
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* __BIG_ENDIAN */
name|SET_FLAGS
argument_list|(
name|flags
argument_list|,
name|MODE_BIG_ENDIAN
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|INIT_MODE_FLAGS
argument_list|(
name|sc
argument_list|)
operator|=
name|flags
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_alloc_hsi_mem
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|bus_addr_t
name|busaddr
decl_stmt|;
name|int
name|max_agg_queues
decl_stmt|;
name|int
name|max_segments
decl_stmt|;
name|bus_size_t
name|max_size
decl_stmt|;
name|bus_size_t
name|max_seg_size
decl_stmt|;
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* XXX zero out all vars here and call bxe_alloc_hsi_mem on error */
comment|/* allocate the parent bus DMA tag */
name|rc
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
comment|/* parent tag */
literal|1
argument_list|,
comment|/* alignment */
literal|0
argument_list|,
comment|/* boundary limit */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* restricted low */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* restricted hi */
name|NULL
argument_list|,
comment|/* addr filter() */
name|NULL
argument_list|,
comment|/* addr filter() arg */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* max map size */
name|BUS_SPACE_UNRESTRICTED
argument_list|,
comment|/* num discontinuous */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* max seg size */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lock() */
name|NULL
argument_list|,
comment|/* lock() arg */
operator|&
name|sc
operator|->
name|parent_dma_tag
argument_list|)
expr_stmt|;
comment|/* returned dma tag */
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to alloc parent DMA tag (%d)!\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/************************/
comment|/* DEFAULT STATUS BLOCK */
comment|/************************/
if|if
condition|(
name|bxe_dma_alloc
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|host_sp_status_block
argument_list|)
argument_list|,
operator|&
name|sc
operator|->
name|def_sb_dma
argument_list|,
literal|"default status block"
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* XXX */
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|parent_dma_tag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|sc
operator|->
name|def_sb
operator|=
operator|(
expr|struct
name|host_sp_status_block
operator|*
operator|)
name|sc
operator|->
name|def_sb_dma
operator|.
name|vaddr
expr_stmt|;
comment|/***************/
comment|/* EVENT QUEUE */
comment|/***************/
if|if
condition|(
name|bxe_dma_alloc
argument_list|(
name|sc
argument_list|,
name|BCM_PAGE_SIZE
argument_list|,
operator|&
name|sc
operator|->
name|eq_dma
argument_list|,
literal|"event queue"
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* XXX */
name|bxe_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|def_sb_dma
argument_list|)
expr_stmt|;
name|sc
operator|->
name|def_sb
operator|=
name|NULL
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|parent_dma_tag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|sc
operator|->
name|eq
operator|=
operator|(
expr|union
name|event_ring_elem
operator|*
operator|)
name|sc
operator|->
name|eq_dma
operator|.
name|vaddr
expr_stmt|;
comment|/*************/
comment|/* SLOW PATH */
comment|/*************/
if|if
condition|(
name|bxe_dma_alloc
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bxe_slowpath
argument_list|)
argument_list|,
operator|&
name|sc
operator|->
name|sp_dma
argument_list|,
literal|"slow path"
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* XXX */
name|bxe_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|eq_dma
argument_list|)
expr_stmt|;
name|sc
operator|->
name|eq
operator|=
name|NULL
expr_stmt|;
name|bxe_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|def_sb_dma
argument_list|)
expr_stmt|;
name|sc
operator|->
name|def_sb
operator|=
name|NULL
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|parent_dma_tag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|sc
operator|->
name|sp
operator|=
operator|(
expr|struct
name|bxe_slowpath
operator|*
operator|)
name|sc
operator|->
name|sp_dma
operator|.
name|vaddr
expr_stmt|;
comment|/*******************/
comment|/* SLOW PATH QUEUE */
comment|/*******************/
if|if
condition|(
name|bxe_dma_alloc
argument_list|(
name|sc
argument_list|,
name|BCM_PAGE_SIZE
argument_list|,
operator|&
name|sc
operator|->
name|spq_dma
argument_list|,
literal|"slow path queue"
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* XXX */
name|bxe_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sp_dma
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sp
operator|=
name|NULL
expr_stmt|;
name|bxe_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|eq_dma
argument_list|)
expr_stmt|;
name|sc
operator|->
name|eq
operator|=
name|NULL
expr_stmt|;
name|bxe_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|def_sb_dma
argument_list|)
expr_stmt|;
name|sc
operator|->
name|def_sb
operator|=
name|NULL
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|parent_dma_tag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|sc
operator|->
name|spq
operator|=
operator|(
expr|struct
name|eth_spe
operator|*
operator|)
name|sc
operator|->
name|spq_dma
operator|.
name|vaddr
expr_stmt|;
comment|/***************************/
comment|/* FW DECOMPRESSION BUFFER */
comment|/***************************/
if|if
condition|(
name|bxe_dma_alloc
argument_list|(
name|sc
argument_list|,
name|FW_BUF_SIZE
argument_list|,
operator|&
name|sc
operator|->
name|gz_buf_dma
argument_list|,
literal|"fw decompression buffer"
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* XXX */
name|bxe_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|spq_dma
argument_list|)
expr_stmt|;
name|sc
operator|->
name|spq
operator|=
name|NULL
expr_stmt|;
name|bxe_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sp_dma
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sp
operator|=
name|NULL
expr_stmt|;
name|bxe_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|eq_dma
argument_list|)
expr_stmt|;
name|sc
operator|->
name|eq
operator|=
name|NULL
expr_stmt|;
name|bxe_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|def_sb_dma
argument_list|)
expr_stmt|;
name|sc
operator|->
name|def_sb
operator|=
name|NULL
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|parent_dma_tag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|sc
operator|->
name|gz_buf
operator|=
operator|(
name|void
operator|*
operator|)
name|sc
operator|->
name|gz_buf_dma
operator|.
name|vaddr
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|gz_strm
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|gz_strm
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* XXX */
name|bxe_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|gz_buf_dma
argument_list|)
expr_stmt|;
name|sc
operator|->
name|gz_buf
operator|=
name|NULL
expr_stmt|;
name|bxe_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|spq_dma
argument_list|)
expr_stmt|;
name|sc
operator|->
name|spq
operator|=
name|NULL
expr_stmt|;
name|bxe_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sp_dma
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sp
operator|=
name|NULL
expr_stmt|;
name|bxe_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|eq_dma
argument_list|)
expr_stmt|;
name|sc
operator|->
name|eq
operator|=
name|NULL
expr_stmt|;
name|bxe_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|def_sb_dma
argument_list|)
expr_stmt|;
name|sc
operator|->
name|def_sb
operator|=
name|NULL
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|parent_dma_tag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/*************/
comment|/* FASTPATHS */
comment|/*************/
comment|/* allocate DMA memory for each fastpath structure */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
expr_stmt|;
name|fp
operator|->
name|sc
operator|=
name|sc
expr_stmt|;
name|fp
operator|->
name|index
operator|=
name|i
expr_stmt|;
comment|/*******************/
comment|/* FP STATUS BLOCK */
comment|/*******************/
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"fp %d status block"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|bxe_dma_alloc
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|bxe_host_hc_status_block
argument_list|)
argument_list|,
operator|&
name|fp
operator|->
name|sb_dma
argument_list|,
name|buf
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* XXX unwind and free previous fastpath allocations */
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to alloc %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|CHIP_IS_E2E3
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|fp
operator|->
name|status_block
operator|.
name|e2_sb
operator|=
operator|(
expr|struct
name|host_hc_status_block_e2
operator|*
operator|)
name|fp
operator|->
name|sb_dma
operator|.
name|vaddr
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|->
name|status_block
operator|.
name|e1x_sb
operator|=
operator|(
expr|struct
name|host_hc_status_block_e1x
operator|*
operator|)
name|fp
operator|->
name|sb_dma
operator|.
name|vaddr
expr_stmt|;
block|}
block|}
comment|/******************/
comment|/* FP TX BD CHAIN */
comment|/******************/
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"fp %d tx bd chain"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|bxe_dma_alloc
argument_list|(
name|sc
argument_list|,
operator|(
name|BCM_PAGE_SIZE
operator|*
name|TX_BD_NUM_PAGES
operator|)
argument_list|,
operator|&
name|fp
operator|->
name|tx_dma
argument_list|,
name|buf
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* XXX unwind and free previous fastpath allocations */
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to alloc %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|fp
operator|->
name|tx_chain
operator|=
operator|(
expr|union
name|eth_tx_bd_types
operator|*
operator|)
name|fp
operator|->
name|tx_dma
operator|.
name|vaddr
expr_stmt|;
block|}
comment|/* link together the tx bd chain pages */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|TX_BD_NUM_PAGES
condition|;
name|j
operator|++
control|)
block|{
comment|/* index into the tx bd chain array to last entry per page */
name|struct
name|eth_tx_next_bd
modifier|*
name|tx_next_bd
init|=
operator|&
name|fp
operator|->
name|tx_chain
index|[
name|TX_BD_TOTAL_PER_PAGE
operator|*
name|j
operator|-
literal|1
index|]
operator|.
name|next_bd
decl_stmt|;
comment|/* point to the next page and wrap from last page */
name|busaddr
operator|=
operator|(
name|fp
operator|->
name|tx_dma
operator|.
name|paddr
operator|+
operator|(
name|BCM_PAGE_SIZE
operator|*
operator|(
name|j
operator|%
name|TX_BD_NUM_PAGES
operator|)
operator|)
operator|)
expr_stmt|;
name|tx_next_bd
operator|->
name|addr_hi
operator|=
name|htole32
argument_list|(
name|U64_HI
argument_list|(
name|busaddr
argument_list|)
argument_list|)
expr_stmt|;
name|tx_next_bd
operator|->
name|addr_lo
operator|=
name|htole32
argument_list|(
name|U64_LO
argument_list|(
name|busaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/******************/
comment|/* FP RX BD CHAIN */
comment|/******************/
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"fp %d rx bd chain"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|bxe_dma_alloc
argument_list|(
name|sc
argument_list|,
operator|(
name|BCM_PAGE_SIZE
operator|*
name|RX_BD_NUM_PAGES
operator|)
argument_list|,
operator|&
name|fp
operator|->
name|rx_dma
argument_list|,
name|buf
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* XXX unwind and free previous fastpath allocations */
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to alloc %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|fp
operator|->
name|rx_chain
operator|=
operator|(
expr|struct
name|eth_rx_bd
operator|*
operator|)
name|fp
operator|->
name|rx_dma
operator|.
name|vaddr
expr_stmt|;
block|}
comment|/* link together the rx bd chain pages */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|RX_BD_NUM_PAGES
condition|;
name|j
operator|++
control|)
block|{
comment|/* index into the rx bd chain array to last entry per page */
name|struct
name|eth_rx_bd
modifier|*
name|rx_bd
init|=
operator|&
name|fp
operator|->
name|rx_chain
index|[
name|RX_BD_TOTAL_PER_PAGE
operator|*
name|j
operator|-
literal|2
index|]
decl_stmt|;
comment|/* point to the next page and wrap from last page */
name|busaddr
operator|=
operator|(
name|fp
operator|->
name|rx_dma
operator|.
name|paddr
operator|+
operator|(
name|BCM_PAGE_SIZE
operator|*
operator|(
name|j
operator|%
name|RX_BD_NUM_PAGES
operator|)
operator|)
operator|)
expr_stmt|;
name|rx_bd
operator|->
name|addr_hi
operator|=
name|htole32
argument_list|(
name|U64_HI
argument_list|(
name|busaddr
argument_list|)
argument_list|)
expr_stmt|;
name|rx_bd
operator|->
name|addr_lo
operator|=
name|htole32
argument_list|(
name|U64_LO
argument_list|(
name|busaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*******************/
comment|/* FP RX RCQ CHAIN */
comment|/*******************/
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"fp %d rcq chain"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|bxe_dma_alloc
argument_list|(
name|sc
argument_list|,
operator|(
name|BCM_PAGE_SIZE
operator|*
name|RCQ_NUM_PAGES
operator|)
argument_list|,
operator|&
name|fp
operator|->
name|rcq_dma
argument_list|,
name|buf
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* XXX unwind and free previous fastpath allocations */
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to alloc %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|fp
operator|->
name|rcq_chain
operator|=
operator|(
expr|union
name|eth_rx_cqe
operator|*
operator|)
name|fp
operator|->
name|rcq_dma
operator|.
name|vaddr
expr_stmt|;
block|}
comment|/* link together the rcq chain pages */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|RCQ_NUM_PAGES
condition|;
name|j
operator|++
control|)
block|{
comment|/* index into the rcq chain array to last entry per page */
name|struct
name|eth_rx_cqe_next_page
modifier|*
name|rx_cqe_next
init|=
operator|(
expr|struct
name|eth_rx_cqe_next_page
operator|*
operator|)
operator|&
name|fp
operator|->
name|rcq_chain
index|[
name|RCQ_TOTAL_PER_PAGE
operator|*
name|j
operator|-
literal|1
index|]
decl_stmt|;
comment|/* point to the next page and wrap from last page */
name|busaddr
operator|=
operator|(
name|fp
operator|->
name|rcq_dma
operator|.
name|paddr
operator|+
operator|(
name|BCM_PAGE_SIZE
operator|*
operator|(
name|j
operator|%
name|RCQ_NUM_PAGES
operator|)
operator|)
operator|)
expr_stmt|;
name|rx_cqe_next
operator|->
name|addr_hi
operator|=
name|htole32
argument_list|(
name|U64_HI
argument_list|(
name|busaddr
argument_list|)
argument_list|)
expr_stmt|;
name|rx_cqe_next
operator|->
name|addr_lo
operator|=
name|htole32
argument_list|(
name|U64_LO
argument_list|(
name|busaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*******************/
comment|/* FP RX SGE CHAIN */
comment|/*******************/
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"fp %d sge chain"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|bxe_dma_alloc
argument_list|(
name|sc
argument_list|,
operator|(
name|BCM_PAGE_SIZE
operator|*
name|RX_SGE_NUM_PAGES
operator|)
argument_list|,
operator|&
name|fp
operator|->
name|rx_sge_dma
argument_list|,
name|buf
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* XXX unwind and free previous fastpath allocations */
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to alloc %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|fp
operator|->
name|rx_sge_chain
operator|=
operator|(
expr|struct
name|eth_rx_sge
operator|*
operator|)
name|fp
operator|->
name|rx_sge_dma
operator|.
name|vaddr
expr_stmt|;
block|}
comment|/* link together the sge chain pages */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|RX_SGE_NUM_PAGES
condition|;
name|j
operator|++
control|)
block|{
comment|/* index into the rcq chain array to last entry per page */
name|struct
name|eth_rx_sge
modifier|*
name|rx_sge
init|=
operator|&
name|fp
operator|->
name|rx_sge_chain
index|[
name|RX_SGE_TOTAL_PER_PAGE
operator|*
name|j
operator|-
literal|2
index|]
decl_stmt|;
comment|/* point to the next page and wrap from last page */
name|busaddr
operator|=
operator|(
name|fp
operator|->
name|rx_sge_dma
operator|.
name|paddr
operator|+
operator|(
name|BCM_PAGE_SIZE
operator|*
operator|(
name|j
operator|%
name|RX_SGE_NUM_PAGES
operator|)
operator|)
operator|)
expr_stmt|;
name|rx_sge
operator|->
name|addr_hi
operator|=
name|htole32
argument_list|(
name|U64_HI
argument_list|(
name|busaddr
argument_list|)
argument_list|)
expr_stmt|;
name|rx_sge
operator|->
name|addr_lo
operator|=
name|htole32
argument_list|(
name|U64_LO
argument_list|(
name|busaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/***********************/
comment|/* FP TX MBUF DMA MAPS */
comment|/***********************/
comment|/* set required sizes before mapping to conserve resources */
if|if
condition|(
name|if_getcapenable
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|&
operator|(
name|IFCAP_TSO4
operator||
name|IFCAP_TSO6
operator|)
condition|)
block|{
name|max_size
operator|=
name|BXE_TSO_MAX_SIZE
expr_stmt|;
name|max_segments
operator|=
name|BXE_TSO_MAX_SEGMENTS
expr_stmt|;
name|max_seg_size
operator|=
name|BXE_TSO_MAX_SEG_SIZE
expr_stmt|;
block|}
else|else
block|{
name|max_size
operator|=
operator|(
name|MCLBYTES
operator|*
name|BXE_MAX_SEGMENTS
operator|)
expr_stmt|;
name|max_segments
operator|=
name|BXE_MAX_SEGMENTS
expr_stmt|;
name|max_seg_size
operator|=
name|MCLBYTES
expr_stmt|;
block|}
comment|/* create a dma tag for the tx mbufs */
name|rc
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_dma_tag
argument_list|,
comment|/* parent tag */
literal|1
argument_list|,
comment|/* alignment */
literal|0
argument_list|,
comment|/* boundary limit */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* restricted low */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* restricted hi */
name|NULL
argument_list|,
comment|/* addr filter() */
name|NULL
argument_list|,
comment|/* addr filter() arg */
name|max_size
argument_list|,
comment|/* max map size */
name|max_segments
argument_list|,
comment|/* num discontinuous */
name|max_seg_size
argument_list|,
comment|/* max seg size */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lock() */
name|NULL
argument_list|,
comment|/* lock() arg */
operator|&
name|fp
operator|->
name|tx_mbuf_tag
argument_list|)
expr_stmt|;
comment|/* returned dma tag */
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
comment|/* XXX unwind and free previous fastpath allocations */
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to create dma tag for "
literal|"'fp %d tx mbufs' (%d)\n"
argument_list|,
name|i
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* create dma maps for each of the tx mbuf clusters */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|TX_BD_TOTAL
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|fp
operator|->
name|tx_mbuf_tag
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|fp
operator|->
name|tx_mbuf_chain
index|[
name|j
index|]
operator|.
name|m_map
argument_list|)
condition|)
block|{
comment|/* XXX unwind and free previous fastpath allocations */
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to create dma map for "
literal|"'fp %d tx mbuf %d' (%d)\n"
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/***********************/
comment|/* FP RX MBUF DMA MAPS */
comment|/***********************/
comment|/* create a dma tag for the rx mbufs */
name|rc
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_dma_tag
argument_list|,
comment|/* parent tag */
literal|1
argument_list|,
comment|/* alignment */
literal|0
argument_list|,
comment|/* boundary limit */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* restricted low */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* restricted hi */
name|NULL
argument_list|,
comment|/* addr filter() */
name|NULL
argument_list|,
comment|/* addr filter() arg */
name|MJUM9BYTES
argument_list|,
comment|/* max map size */
literal|1
argument_list|,
comment|/* num discontinuous */
name|MJUM9BYTES
argument_list|,
comment|/* max seg size */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lock() */
name|NULL
argument_list|,
comment|/* lock() arg */
operator|&
name|fp
operator|->
name|rx_mbuf_tag
argument_list|)
expr_stmt|;
comment|/* returned dma tag */
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
comment|/* XXX unwind and free previous fastpath allocations */
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to create dma tag for "
literal|"'fp %d rx mbufs' (%d)\n"
argument_list|,
name|i
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* create dma maps for each of the rx mbuf clusters */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|RX_BD_TOTAL
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|fp
operator|->
name|rx_mbuf_chain
index|[
name|j
index|]
operator|.
name|m_map
argument_list|)
condition|)
block|{
comment|/* XXX unwind and free previous fastpath allocations */
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to create dma map for "
literal|"'fp %d rx mbuf %d' (%d)\n"
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* create dma map for the spare rx mbuf cluster */
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|fp
operator|->
name|rx_mbuf_spare_map
argument_list|)
condition|)
block|{
comment|/* XXX unwind and free previous fastpath allocations */
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to create dma map for "
literal|"'fp %d spare rx mbuf' (%d)\n"
argument_list|,
name|i
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/***************************/
comment|/* FP RX SGE MBUF DMA MAPS */
comment|/***************************/
comment|/* create a dma tag for the rx sge mbufs */
name|rc
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_dma_tag
argument_list|,
comment|/* parent tag */
literal|1
argument_list|,
comment|/* alignment */
literal|0
argument_list|,
comment|/* boundary limit */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* restricted low */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* restricted hi */
name|NULL
argument_list|,
comment|/* addr filter() */
name|NULL
argument_list|,
comment|/* addr filter() arg */
name|BCM_PAGE_SIZE
argument_list|,
comment|/* max map size */
literal|1
argument_list|,
comment|/* num discontinuous */
name|BCM_PAGE_SIZE
argument_list|,
comment|/* max seg size */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lock() */
name|NULL
argument_list|,
comment|/* lock() arg */
operator|&
name|fp
operator|->
name|rx_sge_mbuf_tag
argument_list|)
expr_stmt|;
comment|/* returned dma tag */
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
comment|/* XXX unwind and free previous fastpath allocations */
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to create dma tag for "
literal|"'fp %d rx sge mbufs' (%d)\n"
argument_list|,
name|i
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* create dma maps for the rx sge mbuf clusters */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|RX_SGE_TOTAL
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|fp
operator|->
name|rx_sge_mbuf_tag
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|fp
operator|->
name|rx_sge_mbuf_chain
index|[
name|j
index|]
operator|.
name|m_map
argument_list|)
condition|)
block|{
comment|/* XXX unwind and free previous fastpath allocations */
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to create dma map for "
literal|"'fp %d rx sge mbuf %d' (%d)\n"
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* create dma map for the spare rx sge mbuf cluster */
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|fp
operator|->
name|rx_sge_mbuf_tag
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|fp
operator|->
name|rx_sge_mbuf_spare_map
argument_list|)
condition|)
block|{
comment|/* XXX unwind and free previous fastpath allocations */
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to create dma map for "
literal|"'fp %d spare rx sge mbuf' (%d)\n"
argument_list|,
name|i
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/***************************/
comment|/* FP RX TPA MBUF DMA MAPS */
comment|/***************************/
comment|/* create dma maps for the rx tpa mbuf clusters */
name|max_agg_queues
operator|=
name|MAX_AGG_QS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|max_agg_queues
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|fp
operator|->
name|rx_tpa_info
index|[
name|j
index|]
operator|.
name|bd
operator|.
name|m_map
argument_list|)
condition|)
block|{
comment|/* XXX unwind and free previous fastpath allocations */
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to create dma map for "
literal|"'fp %d rx tpa mbuf %d' (%d)\n"
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* create dma map for the spare rx tpa mbuf cluster */
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|fp
operator|->
name|rx_tpa_info_mbuf_spare_map
argument_list|)
condition|)
block|{
comment|/* XXX unwind and free previous fastpath allocations */
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to create dma map for "
literal|"'fp %d spare rx tpa mbuf' (%d)\n"
argument_list|,
name|i
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|bxe_init_sge_ring_bit_mask
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_free_hsi_mem
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|int
name|max_agg_queues
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|parent_dma_tag
operator|==
name|NULL
condition|)
block|{
return|return;
comment|/* assume nothing was allocated */
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
expr_stmt|;
comment|/*******************/
comment|/* FP STATUS BLOCK */
comment|/*******************/
name|bxe_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|fp
operator|->
name|sb_dma
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|fp
operator|->
name|status_block
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|fp
operator|->
name|status_block
argument_list|)
argument_list|)
expr_stmt|;
comment|/******************/
comment|/* FP TX BD CHAIN */
comment|/******************/
name|bxe_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|fp
operator|->
name|tx_dma
argument_list|)
expr_stmt|;
name|fp
operator|->
name|tx_chain
operator|=
name|NULL
expr_stmt|;
comment|/******************/
comment|/* FP RX BD CHAIN */
comment|/******************/
name|bxe_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|fp
operator|->
name|rx_dma
argument_list|)
expr_stmt|;
name|fp
operator|->
name|rx_chain
operator|=
name|NULL
expr_stmt|;
comment|/*******************/
comment|/* FP RX RCQ CHAIN */
comment|/*******************/
name|bxe_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|fp
operator|->
name|rcq_dma
argument_list|)
expr_stmt|;
name|fp
operator|->
name|rcq_chain
operator|=
name|NULL
expr_stmt|;
comment|/*******************/
comment|/* FP RX SGE CHAIN */
comment|/*******************/
name|bxe_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|fp
operator|->
name|rx_sge_dma
argument_list|)
expr_stmt|;
name|fp
operator|->
name|rx_sge_chain
operator|=
name|NULL
expr_stmt|;
comment|/***********************/
comment|/* FP TX MBUF DMA MAPS */
comment|/***********************/
if|if
condition|(
name|fp
operator|->
name|tx_mbuf_tag
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|TX_BD_TOTAL
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|fp
operator|->
name|tx_mbuf_chain
index|[
name|j
index|]
operator|.
name|m_map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|fp
operator|->
name|tx_mbuf_tag
argument_list|,
name|fp
operator|->
name|tx_mbuf_chain
index|[
name|j
index|]
operator|.
name|m_map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|fp
operator|->
name|tx_mbuf_tag
argument_list|,
name|fp
operator|->
name|tx_mbuf_chain
index|[
name|j
index|]
operator|.
name|m_map
argument_list|)
expr_stmt|;
block|}
block|}
name|bus_dma_tag_destroy
argument_list|(
name|fp
operator|->
name|tx_mbuf_tag
argument_list|)
expr_stmt|;
name|fp
operator|->
name|tx_mbuf_tag
operator|=
name|NULL
expr_stmt|;
block|}
comment|/***********************/
comment|/* FP RX MBUF DMA MAPS */
comment|/***********************/
if|if
condition|(
name|fp
operator|->
name|rx_mbuf_tag
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|RX_BD_TOTAL
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|fp
operator|->
name|rx_mbuf_chain
index|[
name|j
index|]
operator|.
name|m_map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|fp
operator|->
name|rx_mbuf_chain
index|[
name|j
index|]
operator|.
name|m_map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|fp
operator|->
name|rx_mbuf_chain
index|[
name|j
index|]
operator|.
name|m_map
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fp
operator|->
name|rx_mbuf_spare_map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|fp
operator|->
name|rx_mbuf_spare_map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|fp
operator|->
name|rx_mbuf_spare_map
argument_list|)
expr_stmt|;
block|}
comment|/***************************/
comment|/* FP RX TPA MBUF DMA MAPS */
comment|/***************************/
name|max_agg_queues
operator|=
name|MAX_AGG_QS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|max_agg_queues
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|fp
operator|->
name|rx_tpa_info
index|[
name|j
index|]
operator|.
name|bd
operator|.
name|m_map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|fp
operator|->
name|rx_tpa_info
index|[
name|j
index|]
operator|.
name|bd
operator|.
name|m_map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|fp
operator|->
name|rx_tpa_info
index|[
name|j
index|]
operator|.
name|bd
operator|.
name|m_map
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fp
operator|->
name|rx_tpa_info_mbuf_spare_map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|fp
operator|->
name|rx_tpa_info_mbuf_spare_map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|,
name|fp
operator|->
name|rx_tpa_info_mbuf_spare_map
argument_list|)
expr_stmt|;
block|}
name|bus_dma_tag_destroy
argument_list|(
name|fp
operator|->
name|rx_mbuf_tag
argument_list|)
expr_stmt|;
name|fp
operator|->
name|rx_mbuf_tag
operator|=
name|NULL
expr_stmt|;
block|}
comment|/***************************/
comment|/* FP RX SGE MBUF DMA MAPS */
comment|/***************************/
if|if
condition|(
name|fp
operator|->
name|rx_sge_mbuf_tag
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|RX_SGE_TOTAL
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|fp
operator|->
name|rx_sge_mbuf_chain
index|[
name|j
index|]
operator|.
name|m_map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|fp
operator|->
name|rx_sge_mbuf_tag
argument_list|,
name|fp
operator|->
name|rx_sge_mbuf_chain
index|[
name|j
index|]
operator|.
name|m_map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|fp
operator|->
name|rx_sge_mbuf_tag
argument_list|,
name|fp
operator|->
name|rx_sge_mbuf_chain
index|[
name|j
index|]
operator|.
name|m_map
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fp
operator|->
name|rx_sge_mbuf_spare_map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|fp
operator|->
name|rx_sge_mbuf_tag
argument_list|,
name|fp
operator|->
name|rx_sge_mbuf_spare_map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|fp
operator|->
name|rx_sge_mbuf_tag
argument_list|,
name|fp
operator|->
name|rx_sge_mbuf_spare_map
argument_list|)
expr_stmt|;
block|}
name|bus_dma_tag_destroy
argument_list|(
name|fp
operator|->
name|rx_sge_mbuf_tag
argument_list|)
expr_stmt|;
name|fp
operator|->
name|rx_sge_mbuf_tag
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/***************************/
comment|/* FW DECOMPRESSION BUFFER */
comment|/***************************/
name|bxe_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|gz_buf_dma
argument_list|)
expr_stmt|;
name|sc
operator|->
name|gz_buf
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|gz_strm
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|gz_strm
operator|=
name|NULL
expr_stmt|;
comment|/*******************/
comment|/* SLOW PATH QUEUE */
comment|/*******************/
name|bxe_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|spq_dma
argument_list|)
expr_stmt|;
name|sc
operator|->
name|spq
operator|=
name|NULL
expr_stmt|;
comment|/*************/
comment|/* SLOW PATH */
comment|/*************/
name|bxe_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sp_dma
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sp
operator|=
name|NULL
expr_stmt|;
comment|/***************/
comment|/* EVENT QUEUE */
comment|/***************/
name|bxe_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|eq_dma
argument_list|)
expr_stmt|;
name|sc
operator|->
name|eq
operator|=
name|NULL
expr_stmt|;
comment|/************************/
comment|/* DEFAULT STATUS BLOCK */
comment|/************************/
name|bxe_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|def_sb_dma
argument_list|)
expr_stmt|;
name|sc
operator|->
name|def_sb
operator|=
name|NULL
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|parent_dma_tag
argument_list|)
expr_stmt|;
name|sc
operator|->
name|parent_dma_tag
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Previous driver DMAE transaction may have occurred when pre-boot stage  * ended and boot began. This would invalidate the addresses of the  * transaction, resulting in was-error bit set in the PCI causing all  * hw-to-host PCIe transactions to timeout. If this happened we want to clear  * the interrupt which detected this from the pglueb and the was-done bit  */
end_comment

begin_function
specifier|static
name|void
name|bxe_prev_interrupted_dmae
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|PGLUE_B_REG_PGLUE_B_INT_STS
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|PGLUE_B_PGLUE_B_INT_STS_REG_WAS_ERROR_ATTN
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Clearing 'was-error' bit that was set in pglueb"
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PGLUE_B_REG_WAS_ERROR_PF_7_0_CLR
argument_list|,
literal|1
operator|<<
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_prev_mcp_done
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|rc
init|=
name|bxe_fw_command
argument_list|(
name|sc
argument_list|,
name|DRV_MSG_CODE_UNLOAD_DONE
argument_list|,
name|DRV_MSG_CODE_UNLOAD_SKIP_LINK_RESET
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rc
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"MCP response failure, aborting\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|bxe_prev_list_node
modifier|*
name|bxe_prev_path_get_entry
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bxe_prev_list_node
modifier|*
name|tmp
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|tmp
argument_list|,
argument|&bxe_prev_list
argument_list|,
argument|node
argument_list|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|pcie_bus
operator|==
name|tmp
operator|->
name|bus
operator|)
operator|&&
operator|(
name|sc
operator|->
name|pcie_device
operator|==
name|tmp
operator|->
name|slot
operator|)
operator|&&
operator|(
name|SC_PATH
argument_list|(
name|sc
argument_list|)
operator|==
name|tmp
operator|->
name|path
operator|)
condition|)
block|{
return|return
operator|(
name|tmp
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|bxe_prev_is_path_marked
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bxe_prev_list_node
modifier|*
name|tmp
decl_stmt|;
name|int
name|rc
init|=
name|FALSE
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|bxe_prev_mtx
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|bxe_prev_path_get_entry
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
block|{
if|if
condition|(
name|tmp
operator|->
name|aer
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Path %d/%d/%d was marked by AER\n"
argument_list|,
name|sc
operator|->
name|pcie_bus
argument_list|,
name|sc
operator|->
name|pcie_device
argument_list|,
name|SC_PATH
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
name|TRUE
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Path %d/%d/%d was already cleaned from previous drivers\n"
argument_list|,
name|sc
operator|->
name|pcie_bus
argument_list|,
name|sc
operator|->
name|pcie_device
argument_list|,
name|SC_PATH
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|bxe_prev_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_prev_mark_path
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|after_undi
parameter_list|)
block|{
name|struct
name|bxe_prev_list_node
modifier|*
name|tmp
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|bxe_prev_mtx
argument_list|)
expr_stmt|;
comment|/* Check whether the entry for this path already exists */
name|tmp
operator|=
name|bxe_prev_path_get_entry
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
block|{
if|if
condition|(
operator|!
name|tmp
operator|->
name|aer
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Re-marking AER in path %d/%d/%d\n"
argument_list|,
name|sc
operator|->
name|pcie_bus
argument_list|,
name|sc
operator|->
name|pcie_device
argument_list|,
name|SC_PATH
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Removing AER indication from path %d/%d/%d\n"
argument_list|,
name|sc
operator|->
name|pcie_bus
argument_list|,
name|sc
operator|->
name|pcie_device
argument_list|,
name|SC_PATH
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|aer
operator|=
literal|0
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|bxe_prev_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|bxe_prev_mtx
argument_list|)
expr_stmt|;
comment|/* Create an entry for this path and add it */
name|tmp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bxe_prev_list_node
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
operator|(
name|M_NOWAIT
operator||
name|M_ZERO
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to allocate 'bxe_prev_list_node'\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|tmp
operator|->
name|bus
operator|=
name|sc
operator|->
name|pcie_bus
expr_stmt|;
name|tmp
operator|->
name|slot
operator|=
name|sc
operator|->
name|pcie_device
expr_stmt|;
name|tmp
operator|->
name|path
operator|=
name|SC_PATH
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|aer
operator|=
literal|0
expr_stmt|;
name|tmp
operator|->
name|undi
operator|=
name|after_undi
condition|?
operator|(
literal|1
operator|<<
name|SC_PORT
argument_list|(
name|sc
argument_list|)
operator|)
else|:
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|bxe_prev_mtx
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Marked path %d/%d/%d - finished previous unload\n"
argument_list|,
name|sc
operator|->
name|pcie_bus
argument_list|,
name|sc
operator|->
name|pcie_device
argument_list|,
name|SC_PATH
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|bxe_prev_list
argument_list|,
name|tmp
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|bxe_prev_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_do_flr
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* only E2 and onwards support FLR */
if|if
condition|(
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"FLR not supported in E1/E1H\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* only bootcode REQ_BC_VER_4_INITIATE_FLR and onwards support flr */
if|if
condition|(
name|sc
operator|->
name|devinfo
operator|.
name|bc_ver
operator|<
name|REQ_BC_VER_4_INITIATE_FLR
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"FLR not supported by BC_VER: 0x%08x\n"
argument_list|,
name|sc
operator|->
name|devinfo
operator|.
name|bc_ver
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Wait for Transaction Pending bit clean */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
condition|)
block|{
name|DELAY
argument_list|(
operator|(
operator|(
literal|1
operator|<<
operator|(
name|i
operator|-
literal|1
operator|)
operator|)
operator|*
literal|100
operator|)
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bxe_is_pcie_pending
argument_list|(
name|sc
argument_list|)
condition|)
block|{
goto|goto
name|clear
goto|;
block|}
block|}
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"PCIE transaction is not cleared, "
literal|"proceeding with reset anyway\n"
argument_list|)
expr_stmt|;
name|clear
label|:
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Initiating FLR\n"
argument_list|)
expr_stmt|;
name|bxe_fw_command
argument_list|(
name|sc
argument_list|,
name|DRV_MSG_CODE_INITIATE_FLR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|bxe_mac_vals
block|{
name|uint32_t
name|xmac_addr
decl_stmt|;
name|uint32_t
name|xmac_val
decl_stmt|;
name|uint32_t
name|emac_addr
decl_stmt|;
name|uint32_t
name|emac_val
decl_stmt|;
name|uint32_t
name|umac_addr
decl_stmt|;
name|uint32_t
name|umac_val
decl_stmt|;
name|uint32_t
name|bmac_addr
decl_stmt|;
name|uint32_t
name|bmac_val
index|[
literal|2
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|bxe_prev_unload_close_mac
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bxe_mac_vals
modifier|*
name|vals
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|,
name|base_addr
decl_stmt|,
name|offset
decl_stmt|,
name|mask
decl_stmt|,
name|reset_reg
decl_stmt|;
name|uint8_t
name|mac_stopped
init|=
name|FALSE
decl_stmt|;
name|uint8_t
name|port
init|=
name|SC_PORT
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|uint32_t
name|wb_data
index|[
literal|2
index|]
decl_stmt|;
comment|/* reset addresses as they also mark which values were changed */
name|vals
operator|->
name|bmac_addr
operator|=
literal|0
expr_stmt|;
name|vals
operator|->
name|umac_addr
operator|=
literal|0
expr_stmt|;
name|vals
operator|->
name|xmac_addr
operator|=
literal|0
expr_stmt|;
name|vals
operator|->
name|emac_addr
operator|=
literal|0
expr_stmt|;
name|reset_reg
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_RESET_REG_2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_BMAC0_REGS_OUT_EN
operator|+
name|port
operator|*
literal|4
argument_list|)
expr_stmt|;
name|mask
operator|=
name|MISC_REGISTERS_RESET_REG_2_RST_BMAC0
operator|<<
name|port
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|reset_reg
operator|)
operator|&&
name|val
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Disable BMAC Rx\n"
argument_list|)
expr_stmt|;
name|base_addr
operator|=
name|SC_PORT
argument_list|(
name|sc
argument_list|)
condition|?
name|NIG_REG_INGRESS_BMAC1_MEM
else|:
name|NIG_REG_INGRESS_BMAC0_MEM
expr_stmt|;
name|offset
operator|=
name|CHIP_IS_E2
argument_list|(
name|sc
argument_list|)
condition|?
name|BIGMAC2_REGISTER_BMAC_CONTROL
else|:
name|BIGMAC_REGISTER_BMAC_CONTROL
expr_stmt|;
comment|/*              * use rd/wr since we cannot use dmae. This is safe              * since MCP won't access the bus due to the request              * to unload, and no function on the path can be              * loaded at this time.              */
name|wb_data
index|[
literal|0
index|]
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|base_addr
operator|+
name|offset
argument_list|)
expr_stmt|;
name|wb_data
index|[
literal|1
index|]
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|base_addr
operator|+
name|offset
operator|+
literal|0x4
argument_list|)
expr_stmt|;
name|vals
operator|->
name|bmac_addr
operator|=
name|base_addr
operator|+
name|offset
expr_stmt|;
name|vals
operator|->
name|bmac_val
index|[
literal|0
index|]
operator|=
name|wb_data
index|[
literal|0
index|]
expr_stmt|;
name|vals
operator|->
name|bmac_val
index|[
literal|1
index|]
operator|=
name|wb_data
index|[
literal|1
index|]
expr_stmt|;
name|wb_data
index|[
literal|0
index|]
operator|&=
operator|~
name|ELINK_BMAC_CONTROL_RX_ENABLE
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|vals
operator|->
name|bmac_addr
argument_list|,
name|wb_data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|vals
operator|->
name|bmac_addr
operator|+
literal|0x4
argument_list|,
name|wb_data
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Disable EMAC Rx\n"
argument_list|)
expr_stmt|;
name|vals
operator|->
name|emac_addr
operator|=
name|NIG_REG_NIG_EMAC0_EN
operator|+
name|SC_PORT
argument_list|(
name|sc
argument_list|)
operator|*
literal|4
expr_stmt|;
name|vals
operator|->
name|emac_val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|vals
operator|->
name|emac_addr
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|vals
operator|->
name|emac_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mac_stopped
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|reset_reg
operator|&
name|MISC_REGISTERS_RESET_REG_2_XMAC
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Disable XMAC Rx\n"
argument_list|)
expr_stmt|;
name|base_addr
operator|=
name|SC_PORT
argument_list|(
name|sc
argument_list|)
condition|?
name|GRCBASE_XMAC1
else|:
name|GRCBASE_XMAC0
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|base_addr
operator|+
name|XMAC_REG_PFC_CTRL_HI
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|base_addr
operator|+
name|XMAC_REG_PFC_CTRL_HI
argument_list|,
name|val
operator|&
operator|~
operator|(
literal|1
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|base_addr
operator|+
name|XMAC_REG_PFC_CTRL_HI
argument_list|,
name|val
operator||
operator|(
literal|1
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
name|vals
operator|->
name|xmac_addr
operator|=
name|base_addr
operator|+
name|XMAC_REG_CTRL
expr_stmt|;
name|vals
operator|->
name|xmac_val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|vals
operator|->
name|xmac_addr
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|vals
operator|->
name|xmac_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mac_stopped
operator|=
name|TRUE
expr_stmt|;
block|}
name|mask
operator|=
name|MISC_REGISTERS_RESET_REG_2_UMAC0
operator|<<
name|port
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|reset_reg
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Disable UMAC Rx\n"
argument_list|)
expr_stmt|;
name|base_addr
operator|=
name|SC_PORT
argument_list|(
name|sc
argument_list|)
condition|?
name|GRCBASE_UMAC1
else|:
name|GRCBASE_UMAC0
expr_stmt|;
name|vals
operator|->
name|umac_addr
operator|=
name|base_addr
operator|+
name|UMAC_REG_COMMAND_CONFIG
expr_stmt|;
name|vals
operator|->
name|umac_val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|vals
operator|->
name|umac_addr
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|vals
operator|->
name|umac_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mac_stopped
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mac_stopped
condition|)
block|{
name|DELAY
argument_list|(
literal|20000
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|BXE_PREV_UNDI_PROD_ADDR
parameter_list|(
name|p
parameter_list|)
value|(BAR_TSTRORM_INTMEM + 0x1508 + ((p)<< 4))
end_define

begin_define
define|#
directive|define
name|BXE_PREV_UNDI_RCQ
parameter_list|(
name|val
parameter_list|)
value|((val)& 0xffff)
end_define

begin_define
define|#
directive|define
name|BXE_PREV_UNDI_BD
parameter_list|(
name|val
parameter_list|)
value|((val)>> 16& 0xffff)
end_define

begin_define
define|#
directive|define
name|BXE_PREV_UNDI_PROD
parameter_list|(
name|rcq
parameter_list|,
name|bd
parameter_list|)
value|((bd)<< 16 | (rcq))
end_define

begin_function
specifier|static
name|void
name|bxe_prev_unload_undi_inc
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|port
parameter_list|,
name|uint8_t
name|inc
parameter_list|)
block|{
name|uint16_t
name|rcq
decl_stmt|,
name|bd
decl_stmt|;
name|uint32_t
name|tmp_reg
init|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BXE_PREV_UNDI_PROD_ADDR
argument_list|(
name|port
argument_list|)
argument_list|)
decl_stmt|;
name|rcq
operator|=
name|BXE_PREV_UNDI_RCQ
argument_list|(
name|tmp_reg
argument_list|)
operator|+
name|inc
expr_stmt|;
name|bd
operator|=
name|BXE_PREV_UNDI_BD
argument_list|(
name|tmp_reg
argument_list|)
operator|+
name|inc
expr_stmt|;
name|tmp_reg
operator|=
name|BXE_PREV_UNDI_PROD
argument_list|(
name|rcq
argument_list|,
name|bd
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BXE_PREV_UNDI_PROD_ADDR
argument_list|(
name|port
argument_list|)
argument_list|,
name|tmp_reg
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"UNDI producer [%d] rings bd -> 0x%04x, rcq -> 0x%04x\n"
argument_list|,
name|port
argument_list|,
name|bd
argument_list|,
name|rcq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_prev_unload_common
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|reset_reg
decl_stmt|,
name|tmp_reg
init|=
literal|0
decl_stmt|,
name|rc
decl_stmt|;
name|uint8_t
name|prev_undi
init|=
name|FALSE
decl_stmt|;
name|struct
name|bxe_mac_vals
name|mac_vals
decl_stmt|;
name|uint32_t
name|timer_count
init|=
literal|1000
decl_stmt|;
name|uint32_t
name|prev_brb
decl_stmt|;
comment|/*      * It is possible a previous function received 'common' answer,      * but hasn't loaded yet, therefore creating a scenario of      * multiple functions receiving 'common' on the same path.      */
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Common unload Flow\n"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|mac_vals
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mac_vals
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bxe_prev_is_path_marked
argument_list|(
name|sc
argument_list|)
condition|)
block|{
return|return
operator|(
name|bxe_prev_mcp_done
argument_list|(
name|sc
argument_list|)
operator|)
return|;
block|}
name|reset_reg
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_RESET_REG_1
argument_list|)
expr_stmt|;
comment|/* Reset should be performed after BRB is emptied */
if|if
condition|(
name|reset_reg
operator|&
name|MISC_REGISTERS_RESET_REG_1_RST_BRB1
condition|)
block|{
comment|/* Close the MAC Rx to prevent BRB from filling up */
name|bxe_prev_unload_close_mac
argument_list|(
name|sc
argument_list|,
operator|&
name|mac_vals
argument_list|)
expr_stmt|;
comment|/* close LLH filters towards the BRB */
name|elink_set_rx_filter
argument_list|(
operator|&
name|sc
operator|->
name|link_params
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*          * Check if the UNDI driver was previously loaded.          * UNDI driver initializes CID offset for normal bell to 0x7          */
if|if
condition|(
name|reset_reg
operator|&
name|MISC_REGISTERS_RESET_REG_1_RST_DORQ
condition|)
block|{
name|tmp_reg
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|DORQ_REG_NORM_CID_OFST
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_reg
operator|==
literal|0x7
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"UNDI previously loaded\n"
argument_list|)
expr_stmt|;
name|prev_undi
operator|=
name|TRUE
expr_stmt|;
comment|/* clear the UNDI indication */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|DORQ_REG_NORM_CID_OFST
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* clear possible idle check errors */
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_NIG_INT_STS_CLR_0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* wait until BRB is empty */
name|tmp_reg
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BRB1_REG_NUM_OF_FULL_BLOCKS
argument_list|)
expr_stmt|;
while|while
condition|(
name|timer_count
condition|)
block|{
name|prev_brb
operator|=
name|tmp_reg
expr_stmt|;
name|tmp_reg
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BRB1_REG_NUM_OF_FULL_BLOCKS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp_reg
condition|)
block|{
break|break;
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"BRB still has 0x%08x\n"
argument_list|,
name|tmp_reg
argument_list|)
expr_stmt|;
comment|/* reset timer as long as BRB actually gets emptied */
if|if
condition|(
name|prev_brb
operator|>
name|tmp_reg
condition|)
block|{
name|timer_count
operator|=
literal|1000
expr_stmt|;
block|}
else|else
block|{
name|timer_count
operator|--
expr_stmt|;
block|}
comment|/* If UNDI resides in memory, manually increment it */
if|if
condition|(
name|prev_undi
condition|)
block|{
name|bxe_prev_unload_undi_inc
argument_list|(
name|sc
argument_list|,
name|SC_PORT
argument_list|(
name|sc
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|timer_count
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to empty BRB\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* No packets are in the pipeline, path is ready for reset */
name|bxe_reset_common
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|mac_vals
operator|.
name|xmac_addr
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|mac_vals
operator|.
name|xmac_addr
argument_list|,
name|mac_vals
operator|.
name|xmac_val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mac_vals
operator|.
name|umac_addr
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|mac_vals
operator|.
name|umac_addr
argument_list|,
name|mac_vals
operator|.
name|umac_val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mac_vals
operator|.
name|emac_addr
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|mac_vals
operator|.
name|emac_addr
argument_list|,
name|mac_vals
operator|.
name|emac_val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mac_vals
operator|.
name|bmac_addr
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|mac_vals
operator|.
name|bmac_addr
argument_list|,
name|mac_vals
operator|.
name|bmac_val
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|mac_vals
operator|.
name|bmac_addr
operator|+
literal|4
argument_list|,
name|mac_vals
operator|.
name|bmac_val
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|bxe_prev_mark_path
argument_list|(
name|sc
argument_list|,
name|prev_undi
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|bxe_prev_mcp_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
return|return
operator|(
name|bxe_prev_mcp_done
argument_list|(
name|sc
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_prev_unload_uncommon
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Uncommon unload Flow\n"
argument_list|)
expr_stmt|;
comment|/* Test if previous unload process was already finished for this path */
if|if
condition|(
name|bxe_prev_is_path_marked
argument_list|(
name|sc
argument_list|)
condition|)
block|{
return|return
operator|(
name|bxe_prev_mcp_done
argument_list|(
name|sc
argument_list|)
operator|)
return|;
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Path is unmarked\n"
argument_list|)
expr_stmt|;
comment|/*      * If function has FLR capabilities, and existing FW version matches      * the one required, then FLR will be sufficient to clean any residue      * left by previous driver      */
name|rc
operator|=
name|bxe_nic_load_analyze_req
argument_list|(
name|sc
argument_list|,
name|FW_MSG_CODE_DRV_LOAD_FUNCTION
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rc
condition|)
block|{
comment|/* fw version is good */
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"FW version matches our own, attempting FLR\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|bxe_do_flr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|rc
condition|)
block|{
comment|/* FLR was performed */
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"FLR successful\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Could not FLR\n"
argument_list|)
expr_stmt|;
comment|/* Close the MCP request, return failure*/
name|rc
operator|=
name|bxe_prev_mcp_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rc
condition|)
block|{
name|rc
operator|=
name|BXE_PREV_WAIT_NEEDED
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_prev_unload
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|time_counter
init|=
literal|10
decl_stmt|;
name|uint32_t
name|fw
decl_stmt|,
name|hw_lock_reg
decl_stmt|,
name|hw_lock_val
decl_stmt|;
name|uint32_t
name|rc
init|=
literal|0
decl_stmt|;
comment|/*      * Clear HW from errors which may have resulted from an interrupted      * DMAE transaction.      */
name|bxe_prev_interrupted_dmae
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Release previously held locks */
name|hw_lock_reg
operator|=
operator|(
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
operator|<=
literal|5
operator|)
condition|?
operator|(
name|MISC_REG_DRIVER_CONTROL_1
operator|+
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
operator|*
literal|8
operator|)
else|:
operator|(
name|MISC_REG_DRIVER_CONTROL_7
operator|+
operator|(
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
operator|-
literal|6
operator|)
operator|*
literal|8
operator|)
expr_stmt|;
name|hw_lock_val
operator|=
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|hw_lock_reg
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|hw_lock_val
condition|)
block|{
if|if
condition|(
name|hw_lock_val
operator|&
name|HW_LOCK_RESOURCE_NVRAM
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Releasing previously held NVRAM lock\n"
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_NVM_SW_ARB
argument_list|,
operator|(
name|MCPR_NVM_SW_ARB_ARB_REQ_CLR1
operator|<<
name|SC_PORT
argument_list|(
name|sc
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Releasing previously held HW lock\n"
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|hw_lock_reg
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"No need to release HW/NVRAM locks\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|MCPR_ACCESS_LOCK_LOCK
operator|&
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_ACCESS_LOCK
argument_list|)
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Releasing previously held ALR\n"
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_ACCESS_LOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|do
block|{
comment|/* Lock MCP using an unload request */
name|fw
operator|=
name|bxe_fw_command
argument_list|(
name|sc
argument_list|,
name|DRV_MSG_CODE_UNLOAD_REQ_WOL_DIS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fw
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"MCP response failure, aborting\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fw
operator|==
name|FW_MSG_CODE_DRV_UNLOAD_COMMON
condition|)
block|{
name|rc
operator|=
name|bxe_prev_unload_common
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* non-common reply from MCP night require looping */
name|rc
operator|=
name|bxe_prev_unload_uncommon
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|BXE_PREV_WAIT_NEEDED
condition|)
block|{
break|break;
block|}
name|DELAY
argument_list|(
literal|20000
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|time_counter
condition|)
do|;
if|if
condition|(
operator|!
name|time_counter
operator|||
name|rc
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Failed to unload previous driver!"
literal|" time_counter %d rc %d\n"
argument_list|,
name|time_counter
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|void
name|bxe_dcbx_set_state
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|dcb_on
parameter_list|,
name|uint32_t
name|dcbx_enabled
parameter_list|)
block|{
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|sc
operator|->
name|dcb_state
operator|=
name|dcb_on
expr_stmt|;
name|sc
operator|->
name|dcbx_enabled
operator|=
name|dcbx_enabled
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|dcb_state
operator|=
name|FALSE
expr_stmt|;
name|sc
operator|->
name|dcbx_enabled
operator|=
name|BXE_DCBX_ENABLED_INVALID
expr_stmt|;
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"DCB state [%s:%s]\n"
argument_list|,
name|dcb_on
condition|?
literal|"ON"
else|:
literal|"OFF"
argument_list|,
operator|(
name|dcbx_enabled
operator|==
name|BXE_DCBX_ENABLED_OFF
operator|)
condition|?
literal|"user-mode"
else|:
operator|(
name|dcbx_enabled
operator|==
name|BXE_DCBX_ENABLED_ON_NEG_OFF
operator|)
condition|?
literal|"on-chip static"
else|:
operator|(
name|dcbx_enabled
operator|==
name|BXE_DCBX_ENABLED_ON_NEG_ON
operator|)
condition|?
literal|"on-chip with negotiation"
else|:
literal|"invalid"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* must be called after sriov-enable */
end_comment

begin_function
specifier|static
name|int
name|bxe_set_qm_cid_count
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|cid_count
init|=
name|BXE_L2_MAX_CID
argument_list|(
name|sc
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_SRIOV
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|cid_count
operator|+=
name|BXE_VF_CIDS
expr_stmt|;
block|}
if|if
condition|(
name|CNIC_SUPPORT
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|cid_count
operator|+=
name|CNIC_CID_MAX
expr_stmt|;
block|}
return|return
operator|(
name|roundup
argument_list|(
name|cid_count
argument_list|,
name|QM_CID_ROUND
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_init_multi_cos
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|pri
decl_stmt|,
name|cos
decl_stmt|;
name|uint32_t
name|pri_map
init|=
literal|0
decl_stmt|;
comment|/* XXX change to user config */
for|for
control|(
name|pri
operator|=
literal|0
init|;
name|pri
operator|<
name|BXE_MAX_PRIORITY
condition|;
name|pri
operator|++
control|)
block|{
name|cos
operator|=
operator|(
operator|(
name|pri_map
operator|&
operator|(
literal|0xf
operator|<<
operator|(
name|pri
operator|*
literal|4
operator|)
operator|)
operator|)
operator|>>
operator|(
name|pri
operator|*
literal|4
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|cos
operator|<
name|sc
operator|->
name|max_cos
condition|)
block|{
name|sc
operator|->
name|prio_to_cos
index|[
name|pri
index|]
operator|=
name|cos
expr_stmt|;
block|}
else|else
block|{
name|BLOGW
argument_list|(
name|sc
argument_list|,
literal|"Invalid COS %d for priority %d "
literal|"(max COS is %d), setting to 0\n"
argument_list|,
name|cos
argument_list|,
name|pri
argument_list|,
operator|(
name|sc
operator|->
name|max_cos
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|prio_to_cos
index|[
name|pri
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_sysctl_state
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|result
decl_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|result
operator|==
literal|1
condition|)
block|{
name|uint32_t
name|temp
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|bxe_softc
operator|*
operator|)
name|arg1
expr_stmt|;
name|BLOGI
argument_list|(
name|sc
argument_list|,
literal|"... dumping driver state ...\n"
argument_list|)
expr_stmt|;
name|temp
operator|=
name|SHMEM2_RD
argument_list|(
name|sc
argument_list|,
name|temperature_in_half_celsius
argument_list|)
expr_stmt|;
name|BLOGI
argument_list|(
name|sc
argument_list|,
literal|"\t Device Temperature = %d Celsius\n"
argument_list|,
operator|(
name|temp
operator|/
literal|2
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_sysctl_eth_stat
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|bxe_softc
operator|*
operator|)
name|arg1
decl_stmt|;
name|uint32_t
modifier|*
name|eth_stats
init|=
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|eth_stats
decl_stmt|;
name|uint32_t
modifier|*
name|offset
decl_stmt|;
name|uint64_t
name|value
init|=
literal|0
decl_stmt|;
name|int
name|index
init|=
operator|(
name|int
operator|)
name|arg2
decl_stmt|;
if|if
condition|(
name|index
operator|>=
name|BXE_NUM_ETH_STATS
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"bxe_eth_stats index out of range (%d)\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|offset
operator|=
operator|(
name|eth_stats
operator|+
name|bxe_eth_stats_arr
index|[
name|index
index|]
operator|.
name|offset
operator|)
expr_stmt|;
switch|switch
condition|(
name|bxe_eth_stats_arr
index|[
name|index
index|]
operator|.
name|size
condition|)
block|{
case|case
literal|4
case|:
name|value
operator|=
operator|(
name|uint64_t
operator|)
operator|*
name|offset
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|value
operator|=
name|HILO_U64
argument_list|(
operator|*
name|offset
argument_list|,
operator|*
operator|(
name|offset
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Invalid bxe_eth_stats size (index=%d size=%d)\n"
argument_list|,
name|index
argument_list|,
name|bxe_eth_stats_arr
index|[
name|index
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|sysctl_handle_64
argument_list|(
name|oidp
argument_list|,
operator|&
name|value
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_sysctl_eth_q_stat
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|bxe_softc
operator|*
operator|)
name|arg1
decl_stmt|;
name|uint32_t
modifier|*
name|eth_stats
decl_stmt|;
name|uint32_t
modifier|*
name|offset
decl_stmt|;
name|uint64_t
name|value
init|=
literal|0
decl_stmt|;
name|uint32_t
name|q_stat
init|=
operator|(
name|uint32_t
operator|)
name|arg2
decl_stmt|;
name|uint32_t
name|fp_index
init|=
operator|(
operator|(
name|q_stat
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
decl_stmt|;
name|uint32_t
name|index
init|=
operator|(
name|q_stat
operator|&
literal|0xffff
operator|)
decl_stmt|;
name|eth_stats
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|fp
index|[
name|fp_index
index|]
operator|.
name|eth_q_stats
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|BXE_NUM_ETH_Q_STATS
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"bxe_eth_q_stats index out of range (%d)\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|offset
operator|=
operator|(
name|eth_stats
operator|+
name|bxe_eth_q_stats_arr
index|[
name|index
index|]
operator|.
name|offset
operator|)
expr_stmt|;
switch|switch
condition|(
name|bxe_eth_q_stats_arr
index|[
name|index
index|]
operator|.
name|size
condition|)
block|{
case|case
literal|4
case|:
name|value
operator|=
operator|(
name|uint64_t
operator|)
operator|*
name|offset
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|value
operator|=
name|HILO_U64
argument_list|(
operator|*
name|offset
argument_list|,
operator|*
operator|(
name|offset
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Invalid bxe_eth_q_stats size (index=%d size=%d)\n"
argument_list|,
name|index
argument_list|,
name|bxe_eth_q_stats_arr
index|[
name|index
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|sysctl_handle_64
argument_list|(
name|oidp
argument_list|,
operator|&
name|value
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_force_link_reset
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|bxe_acquire_phy_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|elink_link_reset
argument_list|(
operator|&
name|sc
operator|->
name|link_params
argument_list|,
operator|&
name|sc
operator|->
name|link_vars
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bxe_release_phy_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_sysctl_pauseparam
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|bxe_softc
operator|*
operator|)
name|arg1
decl_stmt|;
empty_stmt|;
name|uint32_t
name|cfg_idx
init|=
name|bxe_get_link_cfg_idx
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|result
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|sc
operator|->
name|bxe_pause_param
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|bxe_pause_param
operator|<
literal|0
operator|)
operator|||
operator|(
name|sc
operator|->
name|bxe_pause_param
operator|>
literal|8
operator|)
condition|)
block|{
name|BLOGW
argument_list|(
name|sc
argument_list|,
literal|"invalid pause param (%d) - use intergers between 1& 8\n"
argument_list|,
name|sc
operator|->
name|bxe_pause_param
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bxe_pause_param
operator|=
literal|8
expr_stmt|;
block|}
name|result
operator|=
operator|(
name|sc
operator|->
name|bxe_pause_param
operator|<<
name|PORT_FEATURE_FLOW_CONTROL_SHIFT
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|result
operator|&
literal|0x400
operator|)
operator|&&
operator|!
operator|(
name|sc
operator|->
name|port
operator|.
name|supported
index|[
name|cfg_idx
index|]
operator|&
name|ELINK_SUPPORTED_Autoneg
operator|)
condition|)
block|{
name|BLOGW
argument_list|(
name|sc
argument_list|,
literal|"Does not support Autoneg pause_param %d\n"
argument_list|,
name|sc
operator|->
name|bxe_pause_param
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|IS_MF
argument_list|(
name|sc
argument_list|)
condition|)
return|return
literal|0
return|;
name|sc
operator|->
name|link_params
operator|.
name|req_flow_ctrl
index|[
name|cfg_idx
index|]
operator|=
name|ELINK_FLOW_CTRL_AUTO
expr_stmt|;
if|if
condition|(
name|result
operator|&
name|ELINK_FLOW_CTRL_RX
condition|)
name|sc
operator|->
name|link_params
operator|.
name|req_flow_ctrl
index|[
name|cfg_idx
index|]
operator||=
name|ELINK_FLOW_CTRL_RX
expr_stmt|;
if|if
condition|(
name|result
operator|&
name|ELINK_FLOW_CTRL_TX
condition|)
name|sc
operator|->
name|link_params
operator|.
name|req_flow_ctrl
index|[
name|cfg_idx
index|]
operator||=
name|ELINK_FLOW_CTRL_TX
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|link_params
operator|.
name|req_flow_ctrl
index|[
name|cfg_idx
index|]
operator|==
name|ELINK_FLOW_CTRL_AUTO
condition|)
name|sc
operator|->
name|link_params
operator|.
name|req_flow_ctrl
index|[
name|cfg_idx
index|]
operator|=
name|ELINK_FLOW_CTRL_NONE
expr_stmt|;
if|if
condition|(
name|result
operator|&
literal|0x400
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|link_params
operator|.
name|req_line_speed
index|[
name|cfg_idx
index|]
operator|==
name|ELINK_SPEED_AUTO_NEG
condition|)
block|{
name|sc
operator|->
name|link_params
operator|.
name|req_flow_ctrl
index|[
name|cfg_idx
index|]
operator|=
name|ELINK_FLOW_CTRL_AUTO
expr_stmt|;
block|}
name|sc
operator|->
name|link_params
operator|.
name|req_fc_auto_adv
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|result
operator|&
name|ELINK_FLOW_CTRL_RX
condition|)
name|sc
operator|->
name|link_params
operator|.
name|req_fc_auto_adv
operator||=
name|ELINK_FLOW_CTRL_RX
expr_stmt|;
if|if
condition|(
name|result
operator|&
name|ELINK_FLOW_CTRL_TX
condition|)
name|sc
operator|->
name|link_params
operator|.
name|req_fc_auto_adv
operator||=
name|ELINK_FLOW_CTRL_TX
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|link_params
operator|.
name|req_fc_auto_adv
condition|)
name|sc
operator|->
name|link_params
operator|.
name|req_fc_auto_adv
operator||=
name|ELINK_FLOW_CTRL_NONE
expr_stmt|;
block|}
if|if
condition|(
name|IS_PF
argument_list|(
name|sc
argument_list|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|link_vars
operator|.
name|link_up
condition|)
block|{
name|bxe_stats_handle
argument_list|(
name|sc
argument_list|,
name|STATS_EVENT_STOP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|if_getdrvflags
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|bxe_force_link_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_acquire_phy_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rc
operator|=
name|elink_phy_init
argument_list|(
operator|&
name|sc
operator|->
name|link_params
argument_list|,
operator|&
name|sc
operator|->
name|link_vars
argument_list|)
expr_stmt|;
name|bxe_release_phy_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_calc_fc_adv
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_add_sysctls
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|children
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|queue_top
decl_stmt|,
modifier|*
name|queue
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|queue_top_children
decl_stmt|,
modifier|*
name|queue_children
decl_stmt|;
name|char
name|queue_num_buf
index|[
literal|32
index|]
decl_stmt|;
name|uint32_t
name|q_stat
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_STRING
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"version"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|BXE_DRIVER_VERSION
argument_list|,
literal|0
argument_list|,
literal|"version"
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|sc
operator|->
name|fw_ver_str
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|fw_ver_str
argument_list|)
argument_list|,
literal|"%d.%d.%d.%d"
argument_list|,
name|BCM_5710_FW_MAJOR_VERSION
argument_list|,
name|BCM_5710_FW_MINOR_VERSION
argument_list|,
name|BCM_5710_FW_REVISION_VERSION
argument_list|,
name|BCM_5710_FW_ENGINEERING_VERSION
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|sc
operator|->
name|mf_mode_str
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|mf_mode_str
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
operator|(
operator|(
name|sc
operator|->
name|devinfo
operator|.
name|mf_info
operator|.
name|mf_mode
operator|==
name|SINGLE_FUNCTION
operator|)
condition|?
literal|"Single"
else|:
operator|(
name|sc
operator|->
name|devinfo
operator|.
name|mf_info
operator|.
name|mf_mode
operator|==
name|MULTI_FUNCTION_SD
operator|)
condition|?
literal|"MF-SD"
else|:
operator|(
name|sc
operator|->
name|devinfo
operator|.
name|mf_info
operator|.
name|mf_mode
operator|==
name|MULTI_FUNCTION_SI
operator|)
condition|?
literal|"MF-SI"
else|:
operator|(
name|sc
operator|->
name|devinfo
operator|.
name|mf_info
operator|.
name|mf_mode
operator|==
name|MULTI_FUNCTION_AFEX
operator|)
condition|?
literal|"MF-AFEX"
else|:
literal|"Unknown"
operator|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mf_vnics"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|devinfo
operator|.
name|mf_info
operator|.
name|vnics_per_port
argument_list|,
literal|0
argument_list|,
literal|"multifunction vnics per port"
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|sc
operator|->
name|pci_link_str
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|pci_link_str
argument_list|)
argument_list|,
literal|"%s x%d"
argument_list|,
operator|(
operator|(
name|sc
operator|->
name|devinfo
operator|.
name|pcie_link_speed
operator|==
literal|1
operator|)
condition|?
literal|"2.5GT/s"
else|:
operator|(
name|sc
operator|->
name|devinfo
operator|.
name|pcie_link_speed
operator|==
literal|2
operator|)
condition|?
literal|"5.0GT/s"
else|:
operator|(
name|sc
operator|->
name|devinfo
operator|.
name|pcie_link_speed
operator|==
literal|4
operator|)
condition|?
literal|"8.0GT/s"
else|:
literal|"???GT/s"
operator|)
argument_list|,
name|sc
operator|->
name|devinfo
operator|.
name|pcie_link_width
argument_list|)
expr_stmt|;
name|sc
operator|->
name|debug
operator|=
name|bxe_debug
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|900000
name|SYSCTL_ADD_STRING
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"bc_version"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|sc
operator|->
name|devinfo
operator|.
name|bc_ver_str
argument_list|,
literal|0
argument_list|,
literal|"bootcode version"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_STRING
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fw_version"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|sc
operator|->
name|fw_ver_str
argument_list|,
literal|0
argument_list|,
literal|"firmware version"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_STRING
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mf_mode"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|sc
operator|->
name|mf_mode_str
argument_list|,
literal|0
argument_list|,
literal|"multifunction mode"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_STRING
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mac_addr"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|sc
operator|->
name|mac_addr_str
argument_list|,
literal|0
argument_list|,
literal|"mac address"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_STRING
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"pci_link"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|sc
operator|->
name|pci_link_str
argument_list|,
literal|0
argument_list|,
literal|"pci link status"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"debug"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|debug
argument_list|,
literal|"debug logging mode"
argument_list|)
expr_stmt|;
else|#
directive|else
name|SYSCTL_ADD_STRING
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"bc_version"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|devinfo
operator|.
name|bc_ver_str
argument_list|,
literal|0
argument_list|,
literal|"bootcode version"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_STRING
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fw_version"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|fw_ver_str
argument_list|,
literal|0
argument_list|,
literal|"firmware version"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_STRING
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mf_mode"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|mf_mode_str
argument_list|,
literal|0
argument_list|,
literal|"multifunction mode"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_STRING
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mac_addr"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|mac_addr_str
argument_list|,
literal|0
argument_list|,
literal|"mac address"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_STRING
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"pci_link"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|pci_link_str
argument_list|,
literal|0
argument_list|,
literal|"pci link status"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"debug"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|debug
argument_list|,
literal|0
argument_list|,
literal|"debug logging mode"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* #if __FreeBSD_version>= 900000 */
name|sc
operator|->
name|trigger_grcdump
operator|=
literal|0
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"trigger_grcdump"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|trigger_grcdump
argument_list|,
literal|0
argument_list|,
literal|"trigger grcdump should be invoked"
literal|"  before collecting grcdump"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|grcdump_started
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|grcdump_done
operator|=
literal|0
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"grcdump_done"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|grcdump_done
argument_list|,
literal|0
argument_list|,
literal|"set by driver when grcdump is done"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx_budget
operator|=
name|bxe_rx_budget
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_budget"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|rx_budget
argument_list|,
literal|0
argument_list|,
literal|"rx processing budget"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"pause_param"
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|bxe_sysctl_pauseparam
argument_list|,
literal|"IU"
argument_list|,
literal|"need pause frames- DEF:0/TX:1/RX:2/BOTH:3/AUTO:4/AUTOTX:5/AUTORX:6/AUTORXTX:7/NONE:8"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"state"
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|bxe_sysctl_state
argument_list|,
literal|"IU"
argument_list|,
literal|"dump driver state"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BXE_NUM_ETH_STATS
condition|;
name|i
operator|++
control|)
block|{
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
name|bxe_eth_stats_arr
index|[
name|i
index|]
operator|.
name|string
argument_list|,
name|CTLTYPE_U64
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
name|i
argument_list|,
name|bxe_sysctl_eth_stat
argument_list|,
literal|"LU"
argument_list|,
name|bxe_eth_stats_arr
index|[
name|i
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
block|}
comment|/* add a new parent node for all queues "dev.bxe.#.queue" */
name|queue_top
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"queue"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"queue"
argument_list|)
expr_stmt|;
name|queue_top_children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|queue_top
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
comment|/* add a new parent node for a single queue "dev.bxe.#.queue.#" */
name|snprintf
argument_list|(
name|queue_num_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|queue_num_buf
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|queue
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|queue_top_children
argument_list|,
name|OID_AUTO
argument_list|,
name|queue_num_buf
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"single queue"
argument_list|)
expr_stmt|;
name|queue_children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|queue
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|BXE_NUM_ETH_Q_STATS
condition|;
name|j
operator|++
control|)
block|{
name|q_stat
operator|=
operator|(
operator|(
name|i
operator|<<
literal|16
operator|)
operator||
name|j
operator|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|queue_children
argument_list|,
name|OID_AUTO
argument_list|,
name|bxe_eth_q_stats_arr
index|[
name|j
index|]
operator|.
name|string
argument_list|,
name|CTLTYPE_U64
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
name|q_stat
argument_list|,
name|bxe_sysctl_eth_q_stat
argument_list|,
literal|"LU"
argument_list|,
name|bxe_eth_q_stats_arr
index|[
name|j
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_alloc_buf_rings
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|901504
name|int
name|i
decl_stmt|;
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
expr_stmt|;
name|fp
operator|->
name|tx_br
operator|=
name|buf_ring_alloc
argument_list|(
name|BXE_BR_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|,
operator|&
name|fp
operator|->
name|tx_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|tx_br
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_free_buf_rings
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|901504
name|int
name|i
decl_stmt|;
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|tx_br
condition|)
block|{
name|buf_ring_free
argument_list|(
name|fp
operator|->
name|tx_br
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|fp
operator|->
name|tx_br
operator|=
name|NULL
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_init_fp_mutexs
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
expr_stmt|;
name|snprintf
argument_list|(
name|fp
operator|->
name|tx_mtx_name
argument_list|,
sizeof|sizeof
argument_list|(
name|fp
operator|->
name|tx_mtx_name
argument_list|)
argument_list|,
literal|"bxe%d_fp%d_tx_lock"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|fp
operator|->
name|tx_mtx
argument_list|,
name|fp
operator|->
name|tx_mtx_name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|fp
operator|->
name|rx_mtx_name
argument_list|,
sizeof|sizeof
argument_list|(
name|fp
operator|->
name|rx_mtx_name
argument_list|)
argument_list|,
literal|"bxe%d_fp%d_rx_lock"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|fp
operator|->
name|rx_mtx
argument_list|,
name|fp
operator|->
name|rx_mtx_name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_destroy_fp_mutexs
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|fp
operator|->
name|tx_mtx
argument_list|)
condition|)
block|{
name|mtx_destroy
argument_list|(
operator|&
name|fp
operator|->
name|tx_mtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|fp
operator|->
name|rx_mtx
argument_list|)
condition|)
block|{
name|mtx_destroy
argument_list|(
operator|&
name|fp
operator|->
name|rx_mtx
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Device attach function.  *  * Allocates device resources, performs secondary chip identification, and  * initializes driver instance variables. This function is called from driver  * load after a successful probe.  *  * Returns:  *   0 = Success,>0 = Failure  */
end_comment

begin_function
specifier|static
name|int
name|bxe_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Starting attach...\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|state
operator|=
name|BXE_STATE_CLOSED
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"softc = %p\n"
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|pcie_bus
operator|=
name|pci_get_bus
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|pcie_device
operator|=
name|pci_get_slot
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|pcie_func
operator|=
name|pci_get_function
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* enable bus master capability */
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* get the BARs */
if|if
condition|(
name|bxe_allocate_bars
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* initialize the mutexes */
name|bxe_init_mutexes
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* prepare the periodic callout */
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|periodic_callout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* prepare the chip taskqueue */
name|sc
operator|->
name|chip_tq_flags
operator|=
name|CHIP_TQ_NONE
expr_stmt|;
name|snprintf
argument_list|(
name|sc
operator|->
name|chip_tq_name
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|chip_tq_name
argument_list|)
argument_list|,
literal|"bxe%d_chip_tq"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|chip_tq_task
argument_list|,
literal|0
argument_list|,
name|bxe_handle_chip_tq
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|chip_tq
operator|=
name|taskqueue_create
argument_list|(
name|sc
operator|->
name|chip_tq_name
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|sc
operator|->
name|chip_tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|sc
operator|->
name|chip_tq
argument_list|,
literal|1
argument_list|,
name|PWAIT
argument_list|,
comment|/* lower priority */
literal|"%s"
argument_list|,
name|sc
operator|->
name|chip_tq_name
argument_list|)
expr_stmt|;
comment|/* get device info and set params */
if|if
condition|(
name|bxe_get_device_info
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"getting device info\n"
argument_list|)
expr_stmt|;
name|bxe_deallocate_bars
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|pci_disable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* get final misc params */
name|bxe_get_params
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* set the default MTU (changed via ifconfig) */
name|sc
operator|->
name|mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|bxe_set_modes_bitmap
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX      * If in AFEX mode and the function is configured for FCoE      * then bail... no L2 allowed.      */
comment|/* get phy settings from shmem and 'and' against admin settings */
name|bxe_get_phy_info
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* initialize the FreeBSD ifnet interface */
if|if
condition|(
name|bxe_init_ifnet
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bxe_release_mutexes
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_deallocate_bars
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|pci_disable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|bxe_add_cdev
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|ifp
operator|!=
name|NULL
condition|)
block|{
name|ether_ifdetach
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
block|}
name|ifmedia_removeall
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|)
expr_stmt|;
name|bxe_release_mutexes
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_deallocate_bars
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|pci_disable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* allocate device interrupts */
if|if
condition|(
name|bxe_interrupt_alloc
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bxe_del_cdev
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ifp
operator|!=
name|NULL
condition|)
block|{
name|ether_ifdetach
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
block|}
name|ifmedia_removeall
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|)
expr_stmt|;
name|bxe_release_mutexes
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_deallocate_bars
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|pci_disable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|bxe_init_fp_mutexs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bxe_alloc_buf_rings
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bxe_free_buf_rings
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_interrupt_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_del_cdev
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ifp
operator|!=
name|NULL
condition|)
block|{
name|ether_ifdetach
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
block|}
name|ifmedia_removeall
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|)
expr_stmt|;
name|bxe_release_mutexes
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_deallocate_bars
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|pci_disable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* allocate ilt */
if|if
condition|(
name|bxe_alloc_ilt_mem
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bxe_free_buf_rings
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_interrupt_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_del_cdev
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ifp
operator|!=
name|NULL
condition|)
block|{
name|ether_ifdetach
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
block|}
name|ifmedia_removeall
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|)
expr_stmt|;
name|bxe_release_mutexes
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_deallocate_bars
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|pci_disable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* allocate the host hardware/software hsi structures */
if|if
condition|(
name|bxe_alloc_hsi_mem
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bxe_free_ilt_mem
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_free_buf_rings
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_interrupt_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_del_cdev
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ifp
operator|!=
name|NULL
condition|)
block|{
name|ether_ifdetach
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
block|}
name|ifmedia_removeall
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|)
expr_stmt|;
name|bxe_release_mutexes
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_deallocate_bars
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|pci_disable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* need to reset chip if UNDI was active */
if|if
condition|(
name|IS_PF
argument_list|(
name|sc
argument_list|)
operator|&&
operator|!
name|BXE_NOMCP
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* init fw_seq */
name|sc
operator|->
name|fw_seq
operator|=
operator|(
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|func_mb
index|[
name|SC_FW_MB_IDX
argument_list|(
name|sc
argument_list|)
index|]
operator|.
name|drv_mb_header
argument_list|)
operator|&
name|DRV_MSG_SEQ_NUMBER_MASK
operator|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"prev unload fw_seq 0x%04x\n"
argument_list|,
name|sc
operator|->
name|fw_seq
argument_list|)
expr_stmt|;
name|bxe_prev_unload
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|1
comment|/* XXX */
name|bxe_dcbx_set_state
argument_list|(
name|sc
argument_list|,
name|FALSE
argument_list|,
name|BXE_DCBX_ENABLED_OFF
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|SHMEM2_HAS
argument_list|(
name|sc
argument_list|,
name|dcbx_lldp_params_offset
argument_list|)
operator|&&
name|SHMEM2_HAS
argument_list|(
name|sc
argument_list|,
name|dcbx_lldp_dcbx_stat_offset
argument_list|)
operator|&&
name|SHMEM2_RD
argument_list|(
name|sc
argument_list|,
name|dcbx_lldp_params_offset
argument_list|)
operator|&&
name|SHMEM2_RD
argument_list|(
name|sc
argument_list|,
name|dcbx_lldp_dcbx_stat_offset
argument_list|)
condition|)
block|{
name|bxe_dcbx_set_state
argument_list|(
name|sc
argument_list|,
name|TRUE
argument_list|,
name|BXE_DCBX_ENABLED_ON_NEG_ON
argument_list|)
expr_stmt|;
name|bxe_dcbx_init_params
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bxe_dcbx_set_state
argument_list|(
name|sc
argument_list|,
name|FALSE
argument_list|,
name|BXE_DCBX_ENABLED_OFF
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* calculate qm_cid_count */
name|sc
operator|->
name|qm_cid_count
operator|=
name|bxe_set_qm_cid_count
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"qm_cid_count=%d\n"
argument_list|,
name|sc
operator|->
name|qm_cid_count
argument_list|)
expr_stmt|;
name|sc
operator|->
name|max_cos
operator|=
literal|1
expr_stmt|;
name|bxe_init_multi_cos
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_add_sysctls
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Device detach function.  *  * Stops the controller, resets the controller, and releases resources.  *  * Returns:  *   0 = Success,>0 = Failure  */
end_comment

begin_function
specifier|static
name|int
name|bxe_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|if_t
name|ifp
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Starting detach...\n"
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
operator|&&
name|if_vlantrunkinuse
argument_list|(
name|ifp
argument_list|)
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Cannot detach while VLANs are in use.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|bxe_del_cdev
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* stop the periodic callout */
name|bxe_periodic_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* stop the chip taskqueue */
name|atomic_store_rel_long
argument_list|(
operator|&
name|sc
operator|->
name|chip_tq_flags
argument_list|,
name|CHIP_TQ_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|chip_tq
condition|)
block|{
name|taskqueue_drain
argument_list|(
name|sc
operator|->
name|chip_tq
argument_list|,
operator|&
name|sc
operator|->
name|chip_tq_task
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|sc
operator|->
name|chip_tq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|chip_tq
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* stop and reset the controller if it was open */
if|if
condition|(
name|sc
operator|->
name|state
operator|!=
name|BXE_STATE_CLOSED
condition|)
block|{
name|BXE_CORE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_nic_unload
argument_list|(
name|sc
argument_list|,
name|UNLOAD_CLOSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|state
operator|=
name|BXE_STATE_DISABLED
expr_stmt|;
name|BXE_CORE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* release the network interface */
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
block|{
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
name|ifmedia_removeall
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|)
expr_stmt|;
comment|/* XXX do the following based on driver state... */
comment|/* free the host hardware/software hsi structures */
name|bxe_free_hsi_mem
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* free ilt */
name|bxe_free_ilt_mem
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_free_buf_rings
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* release the interrupts */
name|bxe_interrupt_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Release the mutexes*/
name|bxe_destroy_fp_mutexs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_release_mutexes
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Release the PCIe BAR mapped memory */
name|bxe_deallocate_bars
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Release the FreeBSD interface. */
if|if
condition|(
name|sc
operator|->
name|ifp
operator|!=
name|NULL
condition|)
block|{
name|if_free
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
block|}
name|pci_disable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Device shutdown function.  *  * Stops and resets the controller.  *  * Returns:  *   Nothing  */
end_comment

begin_function
specifier|static
name|int
name|bxe_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Starting shutdown...\n"
argument_list|)
expr_stmt|;
comment|/* stop the periodic callout */
name|bxe_periodic_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BXE_CORE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_nic_unload
argument_list|(
name|sc
argument_list|,
name|UNLOAD_NORMAL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|BXE_CORE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|bxe_igu_ack_sb
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|igu_sb_id
parameter_list|,
name|uint8_t
name|segment
parameter_list|,
name|uint16_t
name|index
parameter_list|,
name|uint8_t
name|op
parameter_list|,
name|uint8_t
name|update
parameter_list|)
block|{
name|uint32_t
name|igu_addr
init|=
name|sc
operator|->
name|igu_base_addr
decl_stmt|;
name|igu_addr
operator|+=
operator|(
name|IGU_CMD_INT_ACK_BASE
operator|+
name|igu_sb_id
operator|)
operator|*
literal|8
expr_stmt|;
name|bxe_igu_ack_sb_gen
argument_list|(
name|sc
argument_list|,
name|igu_sb_id
argument_list|,
name|segment
argument_list|,
name|index
argument_list|,
name|op
argument_list|,
name|update
argument_list|,
name|igu_addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_igu_clear_sb_gen
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|func
parameter_list|,
name|uint8_t
name|idu_sb_id
parameter_list|,
name|uint8_t
name|is_pf
parameter_list|)
block|{
name|uint32_t
name|data
decl_stmt|,
name|ctl
decl_stmt|,
name|cnt
init|=
literal|100
decl_stmt|;
name|uint32_t
name|igu_addr_data
init|=
name|IGU_REG_COMMAND_REG_32LSB_DATA
decl_stmt|;
name|uint32_t
name|igu_addr_ctl
init|=
name|IGU_REG_COMMAND_REG_CTRL
decl_stmt|;
name|uint32_t
name|igu_addr_ack
init|=
name|IGU_REG_CSTORM_TYPE_0_SB_CLEANUP
operator|+
operator|(
name|idu_sb_id
operator|/
literal|32
operator|)
operator|*
literal|4
decl_stmt|;
name|uint32_t
name|sb_bit
init|=
literal|1
operator|<<
operator|(
name|idu_sb_id
operator|%
literal|32
operator|)
decl_stmt|;
name|uint32_t
name|func_encode
init|=
name|func
operator||
operator|(
name|is_pf
condition|?
literal|1
else|:
literal|0
operator|)
operator|<<
name|IGU_FID_ENCODE_IS_PF_SHIFT
decl_stmt|;
name|uint32_t
name|addr_encode
init|=
name|IGU_CMD_E2_PROD_UPD_BASE
operator|+
name|idu_sb_id
decl_stmt|;
comment|/* Not supported in BC mode */
if|if
condition|(
name|CHIP_INT_MODE_IS_BC
argument_list|(
name|sc
argument_list|)
condition|)
block|{
return|return;
block|}
name|data
operator|=
operator|(
operator|(
name|IGU_USE_REGISTER_cstorm_type_0_sb_cleanup
operator|<<
name|IGU_REGULAR_CLEANUP_TYPE_SHIFT
operator|)
operator||
name|IGU_REGULAR_CLEANUP_SET
operator||
name|IGU_REGULAR_BCLEANUP
operator|)
expr_stmt|;
name|ctl
operator|=
operator|(
operator|(
name|addr_encode
operator|<<
name|IGU_CTRL_REG_ADDRESS_SHIFT
operator|)
operator||
operator|(
name|func_encode
operator|<<
name|IGU_CTRL_REG_FID_SHIFT
operator|)
operator||
operator|(
name|IGU_CTRL_CMD_TYPE_WR
operator|<<
name|IGU_CTRL_REG_TYPE_SHIFT
operator|)
operator|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"write 0x%08x to IGU(via GRC) addr 0x%x\n"
argument_list|,
name|data
argument_list|,
name|igu_addr_data
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|igu_addr_data
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|bus_space_barrier
argument_list|(
name|sc
operator|->
name|bar
index|[
name|BAR0
index|]
operator|.
name|tag
argument_list|,
name|sc
operator|->
name|bar
index|[
name|BAR0
index|]
operator|.
name|handle
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"write 0x%08x to IGU(via GRC) addr 0x%x\n"
argument_list|,
name|ctl
argument_list|,
name|igu_addr_ctl
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|igu_addr_ctl
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
name|bus_space_barrier
argument_list|(
name|sc
operator|->
name|bar
index|[
name|BAR0
index|]
operator|.
name|tag
argument_list|,
name|sc
operator|->
name|bar
index|[
name|BAR0
index|]
operator|.
name|handle
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
comment|/* wait for clean up to finish */
while|while
condition|(
operator|!
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|igu_addr_ack
argument_list|)
operator|&
name|sb_bit
operator|)
operator|&&
operator|--
name|cnt
condition|)
block|{
name|DELAY
argument_list|(
literal|20000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|igu_addr_ack
argument_list|)
operator|&
name|sb_bit
operator|)
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Unable to finish IGU cleanup: "
literal|"idu_sb_id %d offset %d bit %d (cnt %d)\n"
argument_list|,
name|idu_sb_id
argument_list|,
name|idu_sb_id
operator|/
literal|32
argument_list|,
name|idu_sb_id
operator|%
literal|32
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_igu_clear_sb
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|idu_sb_id
parameter_list|)
block|{
name|bxe_igu_clear_sb_gen
argument_list|(
name|sc
argument_list|,
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
argument_list|,
name|idu_sb_id
argument_list|,
name|TRUE
comment|/*PF*/
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************/
end_comment

begin_comment
comment|/* ECORE CALLBACKS */
end_comment

begin_comment
comment|/*******************/
end_comment

begin_function
specifier|static
name|void
name|bxe_reset_common
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|val
init|=
literal|0x1400
decl_stmt|;
comment|/* reset_common */
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_1_CLEAR
operator|)
argument_list|,
literal|0xd3ffff7f
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|val
operator||=
name|MISC_REGISTERS_RESET_REG_2_MSTAT0
expr_stmt|;
name|val
operator||=
name|MISC_REGISTERS_RESET_REG_2_MSTAT1
expr_stmt|;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_2_CLEAR
operator|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_common_init_phy
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|shmem_base
index|[
literal|2
index|]
decl_stmt|;
name|uint32_t
name|shmem2_base
index|[
literal|2
index|]
decl_stmt|;
comment|/* Avoid common init in case MFW supports LFA */
if|if
condition|(
name|SHMEM2_RD
argument_list|(
name|sc
argument_list|,
name|size
argument_list|)
operator|>
operator|(
name|uint32_t
operator|)
name|offsetof
argument_list|(
expr|struct
name|shmem2_region
argument_list|,
name|lfa_host_addr
index|[
name|SC_PORT
argument_list|(
name|sc
argument_list|)
index|]
argument_list|)
condition|)
block|{
return|return;
block|}
name|shmem_base
index|[
literal|0
index|]
operator|=
name|sc
operator|->
name|devinfo
operator|.
name|shmem_base
expr_stmt|;
name|shmem2_base
index|[
literal|0
index|]
operator|=
name|sc
operator|->
name|devinfo
operator|.
name|shmem2_base
expr_stmt|;
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|shmem_base
index|[
literal|1
index|]
operator|=
name|SHMEM2_RD
argument_list|(
name|sc
argument_list|,
name|other_shmem_base_addr
argument_list|)
expr_stmt|;
name|shmem2_base
index|[
literal|1
index|]
operator|=
name|SHMEM2_RD
argument_list|(
name|sc
argument_list|,
name|other_shmem2_base_addr
argument_list|)
expr_stmt|;
block|}
name|bxe_acquire_phy_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|elink_common_init_phy
argument_list|(
name|sc
argument_list|,
name|shmem_base
argument_list|,
name|shmem2_base
argument_list|,
name|sc
operator|->
name|devinfo
operator|.
name|chip_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bxe_release_phy_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_pf_disable
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|val
init|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|IGU_REG_PF_CONFIGURATION
argument_list|)
decl_stmt|;
name|val
operator|&=
operator|~
name|IGU_PF_CONF_FUNC_EN
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|IGU_REG_PF_CONFIGURATION
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PGLUE_B_REG_INTERNAL_PFID_ENABLE_MASTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|CFC_REG_WEAK_ENABLE_PF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_init_pxp
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint16_t
name|devctl
decl_stmt|;
name|int
name|r_order
decl_stmt|,
name|w_order
decl_stmt|;
name|devctl
operator|=
name|bxe_pcie_capability_read
argument_list|(
name|sc
argument_list|,
name|PCIR_EXPRESS_DEVICE_CTL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"read 0x%08x from devctl\n"
argument_list|,
name|devctl
argument_list|)
expr_stmt|;
name|w_order
operator|=
operator|(
operator|(
name|devctl
operator|&
name|PCIM_EXP_CTL_MAX_PAYLOAD
operator|)
operator|>>
literal|5
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mrrs
operator|==
operator|-
literal|1
condition|)
block|{
name|r_order
operator|=
operator|(
operator|(
name|devctl
operator|&
name|PCIM_EXP_CTL_MAX_READ_REQUEST
operator|)
operator|>>
literal|12
operator|)
expr_stmt|;
block|}
else|else
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"forcing read order to %d\n"
argument_list|,
name|sc
operator|->
name|mrrs
argument_list|)
expr_stmt|;
name|r_order
operator|=
name|sc
operator|->
name|mrrs
expr_stmt|;
block|}
name|ecore_init_pxp_arb
argument_list|(
name|sc
argument_list|,
name|r_order
argument_list|,
name|w_order
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|bxe_get_pretend_reg
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|base
init|=
name|PXP2_REG_PGL_PRETEND_FUNC_F0
decl_stmt|;
name|uint32_t
name|stride
init|=
operator|(
name|PXP2_REG_PGL_PRETEND_FUNC_F1
operator|-
name|base
operator|)
decl_stmt|;
return|return
operator|(
name|base
operator|+
operator|(
name|SC_ABS_FUNC
argument_list|(
name|sc
argument_list|)
operator|)
operator|*
name|stride
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called only on E1H or E2.  * When pretending to be PF, the pretend value is the function number 0..7.  * When pretending to be VF, the pretend val is the PF-num:VF-valid:ABS-VFID  * combination.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_pretend_func
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|pretend_func_val
parameter_list|)
block|{
name|uint32_t
name|pretend_reg
decl_stmt|;
if|if
condition|(
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
operator|&&
operator|(
name|pretend_func_val
operator|>
name|E1H_FUNC_MAX
operator|)
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* get my own pretend register */
name|pretend_reg
operator|=
name|bxe_get_pretend_reg
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|pretend_reg
argument_list|,
name|pretend_func_val
argument_list|)
expr_stmt|;
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|pretend_reg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_iov_init_dmae
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_iov_init_dq
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return;
block|}
end_function

begin_comment
comment|/* send a NIG loopback debug packet */
end_comment

begin_function
specifier|static
name|void
name|bxe_lb_pckt
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|wb_write
index|[
literal|3
index|]
decl_stmt|;
comment|/* Ethernet source and destination addresses */
name|wb_write
index|[
literal|0
index|]
operator|=
literal|0x55555555
expr_stmt|;
name|wb_write
index|[
literal|1
index|]
operator|=
literal|0x55555555
expr_stmt|;
name|wb_write
index|[
literal|2
index|]
operator|=
literal|0x20
expr_stmt|;
comment|/* SOP */
name|REG_WR_DMAE
argument_list|(
name|sc
argument_list|,
name|NIG_REG_DEBUG_PACKET_LB
argument_list|,
name|wb_write
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* NON-IP protocol */
name|wb_write
index|[
literal|0
index|]
operator|=
literal|0x09000000
expr_stmt|;
name|wb_write
index|[
literal|1
index|]
operator|=
literal|0x55555555
expr_stmt|;
name|wb_write
index|[
literal|2
index|]
operator|=
literal|0x10
expr_stmt|;
comment|/* EOP, eop_bvalid = 0 */
name|REG_WR_DMAE
argument_list|(
name|sc
argument_list|,
name|NIG_REG_DEBUG_PACKET_LB
argument_list|,
name|wb_write
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Some of the internal memories are not directly readable from the driver.  * To test them we send debug packets.  */
end_comment

begin_function
specifier|static
name|int
name|bxe_int_mem_test
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|factor
decl_stmt|;
name|int
name|count
decl_stmt|,
name|i
decl_stmt|;
name|uint32_t
name|val
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|CHIP_REV_IS_FPGA
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|factor
operator|=
literal|120
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CHIP_REV_IS_EMUL
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|factor
operator|=
literal|200
expr_stmt|;
block|}
else|else
block|{
name|factor
operator|=
literal|1
expr_stmt|;
block|}
comment|/* disable inputs of parser neighbor blocks */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|TSDM_REG_ENABLE_IN1
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|TCM_REG_PRS_IFEN
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|CFC_REG_DEBUG0
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_PRS_REQ_IN_EN
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/*  write 0 to parser credits for CFC search request */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PRS_REG_CFC_SEARCH_INITIAL_CREDIT
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* send Ethernet packet */
name|bxe_lb_pckt
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* TODO do i reset NIG statistic? */
comment|/* Wait until NIG register shows 1 packet of size 0x10 */
name|count
operator|=
literal|1000
operator|*
name|factor
expr_stmt|;
while|while
condition|(
name|count
condition|)
block|{
name|bxe_read_dmae
argument_list|(
name|sc
argument_list|,
name|NIG_REG_STAT2_BRB_OCTET
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|val
operator|=
operator|*
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|wb_data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0x10
condition|)
block|{
break|break;
block|}
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|!=
literal|0x10
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"NIG timeout val=0x%x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* wait until PRS register shows 1 packet */
name|count
operator|=
operator|(
literal|1000
operator|*
name|factor
operator|)
expr_stmt|;
while|while
condition|(
name|count
condition|)
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|PRS_REG_NUM_OF_PACKETS
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|1
condition|)
block|{
break|break;
block|}
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|!=
literal|0x1
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"PRS timeout val=0x%x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
comment|/* Reset and init BRB, PRS */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_1_CLEAR
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_1_SET
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_BRB1
argument_list|,
name|PHASE_COMMON
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_PRS
argument_list|,
name|PHASE_COMMON
argument_list|)
expr_stmt|;
comment|/* Disable inputs of parser neighbor blocks */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|TSDM_REG_ENABLE_IN1
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|TCM_REG_PRS_IFEN
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|CFC_REG_DEBUG0
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_PRS_REQ_IN_EN
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* Write 0 to parser credits for CFC search request */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PRS_REG_CFC_SEARCH_INITIAL_CREDIT
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* send 10 Ethernet packets */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|bxe_lb_pckt
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* Wait until NIG register shows 10+1 packets of size 11*0x10 = 0xb0 */
name|count
operator|=
operator|(
literal|1000
operator|*
name|factor
operator|)
expr_stmt|;
while|while
condition|(
name|count
condition|)
block|{
name|bxe_read_dmae
argument_list|(
name|sc
argument_list|,
name|NIG_REG_STAT2_BRB_OCTET
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|val
operator|=
operator|*
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|wb_data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0xb0
condition|)
block|{
break|break;
block|}
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|!=
literal|0xb0
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"NIG timeout val=0x%x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|3
operator|)
return|;
block|}
comment|/* Wait until PRS register shows 2 packets */
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|PRS_REG_NUM_OF_PACKETS
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|2
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"PRS timeout val=0x%x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
comment|/* Write 1 to parser credits for CFC search request */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PRS_REG_CFC_SEARCH_INITIAL_CREDIT
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
comment|/* Wait until PRS register shows 3 packets */
name|DELAY
argument_list|(
literal|10000
operator|*
name|factor
argument_list|)
expr_stmt|;
comment|/* Wait until NIG register shows 1 packet of size 0x10 */
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|PRS_REG_NUM_OF_PACKETS
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|3
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"PRS timeout val=0x%x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
comment|/* clear NIG EOP FIFO */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|11
condition|;
name|i
operator|++
control|)
block|{
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_INGRESS_EOP_LB_FIFO
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_INGRESS_EOP_LB_EMPTY
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|1
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"clear of NIG failed val=0x%x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|4
operator|)
return|;
block|}
comment|/* Reset and init BRB, PRS, NIG */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_1_CLEAR
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_1_SET
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_BRB1
argument_list|,
name|PHASE_COMMON
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_PRS
argument_list|,
name|PHASE_COMMON
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CNIC_SUPPORT
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* set NIC mode */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PRS_REG_NIC_MODE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Enable inputs of parser neighbor blocks */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|TSDM_REG_ENABLE_IN1
argument_list|,
literal|0x7fffffff
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|TCM_REG_PRS_IFEN
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|CFC_REG_DEBUG0
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_PRS_REQ_IN_EN
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_setup_fan_failure_detection
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|is_required
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|int
name|port
decl_stmt|;
name|is_required
operator|=
literal|0
expr_stmt|;
name|val
operator|=
operator|(
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|dev_info
operator|.
name|shared_hw_config
operator|.
name|config2
argument_list|)
operator|&
name|SHARED_HW_CFG_FAN_FAILURE_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|SHARED_HW_CFG_FAN_FAILURE_ENABLED
condition|)
block|{
name|is_required
operator|=
literal|1
expr_stmt|;
block|}
comment|/*      * The fan failure mechanism is usually related to the PHY type since      * the power consumption of the board is affected by the PHY. Currently,      * fan is required for most designs with SFX7101, BCM8727 and BCM8481.      */
elseif|else
if|if
condition|(
name|val
operator|==
name|SHARED_HW_CFG_FAN_FAILURE_PHY_TYPE
condition|)
block|{
for|for
control|(
name|port
operator|=
name|PORT_0
init|;
name|port
operator|<
name|PORT_MAX
condition|;
name|port
operator|++
control|)
block|{
name|is_required
operator||=
name|elink_fan_failure_det_req
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|devinfo
operator|.
name|shmem_base
argument_list|,
name|sc
operator|->
name|devinfo
operator|.
name|shmem2_base
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"fan detection setting: %d\n"
argument_list|,
name|is_required
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_required
operator|==
literal|0
condition|)
block|{
return|return;
block|}
comment|/* Fan failure is indicated by SPIO 5 */
name|bxe_set_spio
argument_list|(
name|sc
argument_list|,
name|MISC_SPIO_SPIO5
argument_list|,
name|MISC_SPIO_INPUT_HI_Z
argument_list|)
expr_stmt|;
comment|/* set to active low mode */
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_SPIO_INT
argument_list|)
expr_stmt|;
name|val
operator||=
operator|(
name|MISC_SPIO_SPIO5
operator|<<
name|MISC_SPIO_INT_OLD_SET_POS
operator|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_SPIO_INT
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* enable interrupt to signal the IGU */
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_SPIO_EVENT_EN
argument_list|)
expr_stmt|;
name|val
operator||=
name|MISC_SPIO_SPIO5
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_SPIO_EVENT_EN
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_enable_blocks_attention
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP_REG_PXP_INT_MASK_0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP_REG_PXP_INT_MASK_1
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP_REG_PXP_INT_MASK_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|DORQ_REG_DORQ_INT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|CFC_REG_CFC_INT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*      * mask read length error interrupts in brb for parser      * (parsing unit and 'checksum and crc' unit)      * these errors are legal (PU reads fixed length and CAC can cause      * read length error on truncated packets)      */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BRB1_REG_BRB1_INT_MASK
argument_list|,
literal|0xFC00
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|QM_REG_QM_INT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|TM_REG_TM_INT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|XSDM_REG_XSDM_INT_MASK_0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|XSDM_REG_XSDM_INT_MASK_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|XCM_REG_XCM_INT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*      REG_WR(sc, XSEM_REG_XSEM_INT_MASK_0, 0); */
comment|/*      REG_WR(sc, XSEM_REG_XSEM_INT_MASK_1, 0); */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|USDM_REG_USDM_INT_MASK_0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|USDM_REG_USDM_INT_MASK_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|UCM_REG_UCM_INT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*      REG_WR(sc, USEM_REG_USEM_INT_MASK_0, 0); */
comment|/*      REG_WR(sc, USEM_REG_USEM_INT_MASK_1, 0); */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_UPB
operator|+
name|PB_REG_PB_INT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|CSDM_REG_CSDM_INT_MASK_0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|CSDM_REG_CSDM_INT_MASK_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|CCM_REG_CCM_INT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*      REG_WR(sc, CSEM_REG_CSEM_INT_MASK_0, 0); */
comment|/*      REG_WR(sc, CSEM_REG_CSEM_INT_MASK_1, 0); */
name|val
operator|=
operator|(
name|PXP2_PXP2_INT_MASK_0_REG_PGL_CPL_AFT
operator||
name|PXP2_PXP2_INT_MASK_0_REG_PGL_CPL_OF
operator||
name|PXP2_PXP2_INT_MASK_0_REG_PGL_PCIE_ATTN
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|val
operator||=
operator|(
name|PXP2_PXP2_INT_MASK_0_REG_PGL_READ_BLOCKED
operator||
name|PXP2_PXP2_INT_MASK_0_REG_PGL_WRITE_BLOCKED
operator|)
expr_stmt|;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_PXP2_INT_MASK_0
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|TSDM_REG_TSDM_INT_MASK_0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|TSDM_REG_TSDM_INT_MASK_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|TCM_REG_TCM_INT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*      REG_WR(sc, TSEM_REG_TSEM_INT_MASK_0, 0); */
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* enable VFC attentions: bits 11 and 12, bits 31:13 reserved */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|TSEM_REG_TSEM_INT_MASK_1
argument_list|,
literal|0x07ff
argument_list|)
expr_stmt|;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|CDU_REG_CDU_INT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|DMAE_REG_DMAE_INT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*      REG_WR(sc, MISC_REG_MISC_INT_MASK, 0); */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_PBF_INT_MASK
argument_list|,
literal|0x18
argument_list|)
expr_stmt|;
comment|/* bit 3,4 masked */
block|}
end_function

begin_comment
comment|/**  * bxe_init_hw_common - initialize the HW at the COMMON phase.  *  * @sc:     driver handle  */
end_comment

begin_function
specifier|static
name|int
name|bxe_init_hw_common
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint8_t
name|abs_func_id
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"starting common init for func %d\n"
argument_list|,
name|SC_ABS_FUNC
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * take the RESET lock to protect undi_unload flow from accessing      * registers while we are resetting the chip      */
name|bxe_acquire_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_RESET
argument_list|)
expr_stmt|;
name|bxe_reset_common
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_1_SET
operator|)
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0xfffc
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|val
operator||=
name|MISC_REGISTERS_RESET_REG_2_MSTAT0
expr_stmt|;
name|val
operator||=
name|MISC_REGISTERS_RESET_REG_2_MSTAT1
expr_stmt|;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_2_SET
operator|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|bxe_release_hw_lock
argument_list|(
name|sc
argument_list|,
name|HW_LOCK_RESOURCE_RESET
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_MISC
argument_list|,
name|PHASE_COMMON
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"after misc block init\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/*          * 4-port mode or 2-port mode we need to turn off master-enable for          * everyone. After that we turn it back on for self. So, we disregard          * multi-function, and always disable all functions on the given path,          * this means 0,2,4,6 for path 0 and 1,3,5,7 for path 1          */
for|for
control|(
name|abs_func_id
operator|=
name|SC_PATH
argument_list|(
name|sc
argument_list|)
init|;
name|abs_func_id
operator|<
operator|(
name|E2_FUNC_MAX
operator|*
literal|2
operator|)
condition|;
name|abs_func_id
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|abs_func_id
operator|==
name|SC_ABS_FUNC
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PGLUE_B_REG_INTERNAL_PFID_ENABLE_MASTER
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|bxe_pretend_func
argument_list|(
name|sc
argument_list|,
name|abs_func_id
argument_list|)
expr_stmt|;
comment|/* clear pf enable */
name|bxe_pf_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_pretend_func
argument_list|(
name|sc
argument_list|,
name|SC_ABS_FUNC
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"after pf disable\n"
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_PXP
argument_list|,
name|PHASE_COMMON
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/*          * enable HW interrupt from PXP on USDM overflow          * bit 16 on INT_MASK_0          */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP_REG_PXP_INT_MASK_0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_PXP2
argument_list|,
name|PHASE_COMMON
argument_list|)
expr_stmt|;
name|bxe_init_pxp
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__BIG_ENDIAN
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RQ_QM_ENDIAN_M
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RQ_TM_ENDIAN_M
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RQ_SRC_ENDIAN_M
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RQ_CDU_ENDIAN_M
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RQ_DBG_ENDIAN_M
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* make sure this value is 0 */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RQ_HC_ENDIAN_M
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|//REG_WR(sc, PXP2_REG_RD_PBF_SWAP_MODE, 1);
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RD_QM_SWAP_MODE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RD_TM_SWAP_MODE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RD_SRC_SWAP_MODE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RD_CDURD_SWAP_MODE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ecore_ilt_init_page_size
argument_list|(
name|sc
argument_list|,
name|INITOP_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_REV_IS_FPGA
argument_list|(
name|sc
argument_list|)
operator|&&
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_PGL_TAGS_LIMIT
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
block|}
comment|/* let the HW do it's magic... */
name|DELAY
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
comment|/* finish PXP init */
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RQ_CFG_DONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|1
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"PXP2 CFG failed PXP2_REG_RQ_CFG_DONE val = 0x%x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RD_INIT_DONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|1
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"PXP2 RD_INIT failed val = 0x%x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"after pxp init\n"
argument_list|)
expr_stmt|;
comment|/*      * Timer bug workaround for E2 only. We need to set the entire ILT to have      * entries with value "0" and valid bit on. This needs to be done by the      * first PF that is loaded in a path (i.e. common phase)      */
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/*  * In E2 there is a bug in the timers block that can cause function 6 / 7  * (i.e. vnic3) to start even if it is marked as "scan-off".  * This occurs when a different function (func2,3) is being marked  * as "scan-off". Real-life scenario for example: if a driver is being  * load-unloaded while func6,7 are down. This will cause the timer to access  * the ilt, translate to a logical address and send a request to read/write.  * Since the ilt for the function that is down is not valid, this will cause  * a translation error which is unrecoverable.  * The Workaround is intended to make sure that when this happens nothing  * fatal will occur. The workaround:  *  1.  First PF driver which loads on a path will:  *      a.  After taking the chip out of reset, by using pretend,  *          it will write "0" to the following registers of  *          the other vnics.  *          REG_WR(pdev, PGLUE_B_REG_INTERNAL_PFID_ENABLE_MASTER, 0);  *          REG_WR(pdev, CFC_REG_WEAK_ENABLE_PF,0);  *          REG_WR(pdev, CFC_REG_STRONG_ENABLE_PF,0);  *          And for itself it will write '1' to  *          PGLUE_B_REG_INTERNAL_PFID_ENABLE_MASTER to enable  *          dmae-operations (writing to pram for example.)  *          note: can be done for only function 6,7 but cleaner this  *            way.  *      b.  Write zero+valid to the entire ILT.  *      c.  Init the first_timers_ilt_entry, last_timers_ilt_entry of  *          VNIC3 (of that port). The range allocated will be the  *          entire ILT. This is needed to prevent  ILT range error.  *  2.  Any PF driver load flow:  *      a.  ILT update with the physical addresses of the allocated  *          logical pages.  *      b.  Wait 20msec. - note that this timeout is needed to make  *          sure there are no requests in one of the PXP internal  *          queues with "old" ILT addresses.  *      c.  PF enable in the PGLC.  *      d.  Clear the was_error of the PF in the PGLC. (could have  *          occurred while driver was down)  *      e.  PF enable in the CFC (WEAK + STRONG)  *      f.  Timers scan enable  *  3.  PF driver unload flow:  *      a.  Clear the Timers scan_en.  *      b.  Polling for scan_on=0 for that PF.  *      c.  Clear the PF enable bit in the PXP.  *      d.  Clear the PF enable in the CFC (WEAK + STRONG)  *      e.  Write zero+valid to all ILT entries (The valid bit must  *          stay set)  *      f.  If this is VNIC 3 of a port then also init  *          first_timers_ilt_entry to zero and last_timers_ilt_entry  *          to the last enrty in the ILT.  *  *      Notes:  *      Currently the PF error in the PGLC is non recoverable.  *      In the future the there will be a recovery routine for this error.  *      Currently attention is masked.  *      Having an MCP lock on the load/unload process does not guarantee that  *      there is no Timer disable during Func6/7 enable. This is because the  *      Timers scan is currently being cleared by the MCP on FLR.  *      Step 2.d can be done only for PF6/7 and the driver can also check if  *      there is error before clearing it. But the flow above is simpler and  *      more general.  *      All ILT entries are written by zero+valid and not just PF6/7  *      ILT entries since in the future the ILT entries allocation for  *      PF-s might be dynamic.  */
name|struct
name|ilt_client_info
name|ilt_cli
decl_stmt|;
name|struct
name|ecore_ilt
name|ilt
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ilt_cli
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ilt_client_info
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ilt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ecore_ilt
argument_list|)
argument_list|)
expr_stmt|;
comment|/* initialize dummy TM client */
name|ilt_cli
operator|.
name|start
operator|=
literal|0
expr_stmt|;
name|ilt_cli
operator|.
name|end
operator|=
name|ILT_NUM_PAGE_ENTRIES
operator|-
literal|1
expr_stmt|;
name|ilt_cli
operator|.
name|client_num
operator|=
name|ILT_CLIENT_TM
expr_stmt|;
comment|/*          * Step 1: set zeroes to all ilt page entries with valid bit on          * Step 2: set the timers first/last ilt entry to point          * to the entire range to prevent ILT range error for 3rd/4th          * vnic (this code assumes existence of the vnic)          *          * both steps performed by call to ecore_ilt_client_init_op()          * with dummy TM client          *          * we must use pretend since PXP2_REG_RQ_##blk##_FIRST_ILT          * and his brother are split registers          */
name|bxe_pretend_func
argument_list|(
name|sc
argument_list|,
operator|(
name|SC_PATH
argument_list|(
name|sc
argument_list|)
operator|+
literal|6
operator|)
argument_list|)
expr_stmt|;
name|ecore_ilt_client_init_op_ilt
argument_list|(
name|sc
argument_list|,
operator|&
name|ilt
argument_list|,
operator|&
name|ilt_cli
argument_list|,
name|INITOP_CLEAR
argument_list|)
expr_stmt|;
name|bxe_pretend_func
argument_list|(
name|sc
argument_list|,
name|SC_ABS_FUNC
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RQ_DRAM_ALIGN
argument_list|,
name|BXE_PXP_DRAM_ALIGN
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RQ_DRAM_ALIGN_RD
argument_list|,
name|BXE_PXP_DRAM_ALIGN
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RQ_DRAM_ALIGN_SEL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RQ_DISABLE_INPUTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RD_DISABLE_INPUTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|int
name|factor
init|=
name|CHIP_REV_IS_EMUL
argument_list|(
name|sc
argument_list|)
condition|?
literal|1000
else|:
operator|(
name|CHIP_REV_IS_FPGA
argument_list|(
name|sc
argument_list|)
condition|?
literal|400
else|:
literal|0
operator|)
decl_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_PGLUE_B
argument_list|,
name|PHASE_COMMON
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_ATC
argument_list|,
name|PHASE_COMMON
argument_list|)
expr_stmt|;
comment|/* let the HW do it's magic... */
do|do
block|{
name|DELAY
argument_list|(
literal|200000
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|ATC_REG_ATC_INIT_DONE
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|factor
operator|--
operator|&&
operator|(
name|val
operator|!=
literal|1
operator|)
condition|)
do|;
if|if
condition|(
name|val
operator|!=
literal|1
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"ATC_INIT failed val = 0x%x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"after pglue and atc init\n"
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_DMAE
argument_list|,
name|PHASE_COMMON
argument_list|)
expr_stmt|;
name|bxe_iov_init_dmae
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* clean the DMAE memory */
name|sc
operator|->
name|dmae_ready
operator|=
literal|1
expr_stmt|;
name|ecore_init_fill
argument_list|(
name|sc
argument_list|,
name|TSEM_REG_PRAM
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_TCM
argument_list|,
name|PHASE_COMMON
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_UCM
argument_list|,
name|PHASE_COMMON
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_CCM
argument_list|,
name|PHASE_COMMON
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_XCM
argument_list|,
name|PHASE_COMMON
argument_list|)
expr_stmt|;
name|bxe_read_dmae
argument_list|(
name|sc
argument_list|,
name|XSEM_REG_PASSIVE_BUFFER
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|bxe_read_dmae
argument_list|(
name|sc
argument_list|,
name|CSEM_REG_PASSIVE_BUFFER
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|bxe_read_dmae
argument_list|(
name|sc
argument_list|,
name|TSEM_REG_PASSIVE_BUFFER
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|bxe_read_dmae
argument_list|(
name|sc
argument_list|,
name|USEM_REG_PASSIVE_BUFFER
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_QM
argument_list|,
name|PHASE_COMMON
argument_list|)
expr_stmt|;
comment|/* QM queues pointers table */
name|ecore_qm_init_ptr_table
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|qm_cid_count
argument_list|,
name|INITOP_SET
argument_list|)
expr_stmt|;
comment|/* soft reset pulse */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|QM_REG_SOFT_RESET
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|QM_REG_SOFT_RESET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|CNIC_SUPPORT
argument_list|(
name|sc
argument_list|)
condition|)
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_TM
argument_list|,
name|PHASE_COMMON
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_DORQ
argument_list|,
name|PHASE_COMMON
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|DORQ_REG_DPM_CID_OFST
argument_list|,
name|BXE_DB_SHIFT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CHIP_REV_IS_SLOW
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* enable hw interrupt from doorbell Q */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|DORQ_REG_DORQ_INT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_BRB1
argument_list|,
name|PHASE_COMMON
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_PRS
argument_list|,
name|PHASE_COMMON
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PRS_REG_A_PRSU_20
argument_list|,
literal|0xf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PRS_REG_E1HOV_MODE
argument_list|,
name|sc
operator|->
name|devinfo
operator|.
name|mf_info
operator|.
name|path_has_ovlan
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
operator|&&
operator|!
name|CHIP_IS_E3B0
argument_list|(
name|sc
argument_list|)
condition|)
block|{
if|if
condition|(
name|IS_MF_AFEX
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/*              * configure that AFEX and VLAN headers must be              * received in AFEX mode              */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PRS_REG_HDRS_AFTER_BASIC
argument_list|,
literal|0xE
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PRS_REG_MUST_HAVE_HDRS
argument_list|,
literal|0xA
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PRS_REG_HDRS_AFTER_TAG_0
argument_list|,
literal|0x6
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PRS_REG_TAG_ETHERTYPE_0
argument_list|,
literal|0x8926
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PRS_REG_TAG_LEN_0
argument_list|,
literal|0x4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*              * Bit-map indicating which L2 hdrs may appear              * after the basic Ethernet header              */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PRS_REG_HDRS_AFTER_BASIC
argument_list|,
name|sc
operator|->
name|devinfo
operator|.
name|mf_info
operator|.
name|path_has_ovlan
condition|?
literal|7
else|:
literal|6
argument_list|)
expr_stmt|;
block|}
block|}
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_TSDM
argument_list|,
name|PHASE_COMMON
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_CSDM
argument_list|,
name|PHASE_COMMON
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_USDM
argument_list|,
name|PHASE_COMMON
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_XSDM
argument_list|,
name|PHASE_COMMON
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* reset VFC memories */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|TSEM_REG_FAST_MEMORY
operator|+
name|VFC_REG_MEMORIES_RST
argument_list|,
name|VFC_MEMORIES_RST_REG_CAM_RST
operator||
name|VFC_MEMORIES_RST_REG_RAM_RST
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|XSEM_REG_FAST_MEMORY
operator|+
name|VFC_REG_MEMORIES_RST
argument_list|,
name|VFC_MEMORIES_RST_REG_CAM_RST
operator||
name|VFC_MEMORIES_RST_REG_RAM_RST
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|20000
argument_list|)
expr_stmt|;
block|}
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_TSEM
argument_list|,
name|PHASE_COMMON
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_USEM
argument_list|,
name|PHASE_COMMON
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_CSEM
argument_list|,
name|PHASE_COMMON
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_XSEM
argument_list|,
name|PHASE_COMMON
argument_list|)
expr_stmt|;
comment|/* sync semi rtc */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_1_CLEAR
argument_list|,
literal|0x80000000
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_1_SET
argument_list|,
literal|0x80000000
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_UPB
argument_list|,
name|PHASE_COMMON
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_XPB
argument_list|,
name|PHASE_COMMON
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_PBF
argument_list|,
name|PHASE_COMMON
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
if|if
condition|(
name|IS_MF_AFEX
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/*              * configure that AFEX and VLAN headers must be              * sent in AFEX mode              */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_HDRS_AFTER_BASIC
argument_list|,
literal|0xE
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_MUST_HAVE_HDRS
argument_list|,
literal|0xA
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_HDRS_AFTER_TAG_0
argument_list|,
literal|0x6
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_TAG_ETHERTYPE_0
argument_list|,
literal|0x8926
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_TAG_LEN_0
argument_list|,
literal|0x4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_HDRS_AFTER_BASIC
argument_list|,
name|sc
operator|->
name|devinfo
operator|.
name|mf_info
operator|.
name|path_has_ovlan
condition|?
literal|7
else|:
literal|6
argument_list|)
expr_stmt|;
block|}
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|SRC_REG_SOFT_RST
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_SRC
argument_list|,
name|PHASE_COMMON
argument_list|)
expr_stmt|;
if|if
condition|(
name|CNIC_SUPPORT
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|SRC_REG_KEYSEARCH_0
argument_list|,
literal|0x63285672
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|SRC_REG_KEYSEARCH_1
argument_list|,
literal|0x24b8f2cc
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|SRC_REG_KEYSEARCH_2
argument_list|,
literal|0x223aef9b
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|SRC_REG_KEYSEARCH_3
argument_list|,
literal|0x26001e3a
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|SRC_REG_KEYSEARCH_4
argument_list|,
literal|0x7ae91116
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|SRC_REG_KEYSEARCH_5
argument_list|,
literal|0x5ce5230b
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|SRC_REG_KEYSEARCH_6
argument_list|,
literal|0x298d8adf
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|SRC_REG_KEYSEARCH_7
argument_list|,
literal|0x6eb0ff09
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|SRC_REG_KEYSEARCH_8
argument_list|,
literal|0x1830f82f
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|SRC_REG_KEYSEARCH_9
argument_list|,
literal|0x01e46be7
argument_list|)
expr_stmt|;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|SRC_REG_SOFT_RST
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
expr|union
name|cdu_context
argument_list|)
operator|!=
literal|1024
condition|)
block|{
comment|/* we currently assume that a context is 1024 bytes */
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"please adjust the size of cdu_context(%ld)\n"
argument_list|,
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
expr|union
name|cdu_context
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_CDU
argument_list|,
name|PHASE_COMMON
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
literal|4
operator|<<
literal|24
operator|)
operator|+
operator|(
literal|0
operator|<<
literal|12
operator|)
operator|+
literal|1024
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|CDU_REG_CDU_GLOBAL_PARAMS
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_CFC
argument_list|,
name|PHASE_COMMON
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|CFC_REG_INIT_REG
argument_list|,
literal|0x7FF
argument_list|)
expr_stmt|;
comment|/* enable context validation interrupt from CFC */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|CFC_REG_CFC_INT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* set the thresholds to prevent CFC/CDU race */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|CFC_REG_DEBUG0
argument_list|,
literal|0x20020000
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_HC
argument_list|,
name|PHASE_COMMON
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
operator|&&
name|BXE_NOMCP
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|IGU_REG_RESET_MEMORIES
argument_list|,
literal|0x36
argument_list|)
expr_stmt|;
block|}
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_IGU
argument_list|,
name|PHASE_COMMON
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_MISC_AEU
argument_list|,
name|PHASE_COMMON
argument_list|)
expr_stmt|;
comment|/* Reset PCIE errors for debug */
name|REG_WR
argument_list|(
name|sc
argument_list|,
literal|0x2814
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
literal|0x3820
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PCICFG_OFFSET
operator|+
name|PXPCS_TL_CONTROL_5
argument_list|,
operator|(
name|PXPCS_TL_CONTROL_5_ERR_UNSPPORT1
operator||
name|PXPCS_TL_CONTROL_5_ERR_UNSPPORT
operator|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PCICFG_OFFSET
operator|+
name|PXPCS_TL_FUNC345_STAT
argument_list|,
operator|(
name|PXPCS_TL_FUNC345_STAT_ERR_UNSPPORT4
operator||
name|PXPCS_TL_FUNC345_STAT_ERR_UNSPPORT3
operator||
name|PXPCS_TL_FUNC345_STAT_ERR_UNSPPORT2
operator|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PCICFG_OFFSET
operator|+
name|PXPCS_TL_FUNC678_STAT
argument_list|,
operator|(
name|PXPCS_TL_FUNC678_STAT_ERR_UNSPPORT7
operator||
name|PXPCS_TL_FUNC678_STAT_ERR_UNSPPORT6
operator||
name|PXPCS_TL_FUNC678_STAT_ERR_UNSPPORT5
operator|)
argument_list|)
expr_stmt|;
block|}
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_NIG
argument_list|,
name|PHASE_COMMON
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* in E3 this done in per-port section */
if|if
condition|(
operator|!
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LLH_MF_MODE
argument_list|,
name|IS_MF
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* not applicable for E2 (and above ...) */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LLH_E1HOV_MODE
argument_list|,
name|IS_MF_SD
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CHIP_REV_IS_SLOW
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|DELAY
argument_list|(
literal|200000
argument_list|)
expr_stmt|;
block|}
comment|/* finish CFC init */
name|val
operator|=
name|reg_poll
argument_list|(
name|sc
argument_list|,
name|CFC_REG_LL_INIT_DONE
argument_list|,
literal|1
argument_list|,
literal|100
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|1
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"CFC LL_INIT failed val=0x%x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|val
operator|=
name|reg_poll
argument_list|(
name|sc
argument_list|,
name|CFC_REG_AC_INIT_DONE
argument_list|,
literal|1
argument_list|,
literal|100
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|1
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"CFC AC_INIT failed val=0x%x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|val
operator|=
name|reg_poll
argument_list|(
name|sc
argument_list|,
name|CFC_REG_CAM_INIT_DONE
argument_list|,
literal|1
argument_list|,
literal|100
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|1
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"CFC CAM_INIT failed val=0x%x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|CFC_REG_DEBUG0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* read NIG statistic to see if this is our first up since powerup */
name|bxe_read_dmae
argument_list|(
name|sc
argument_list|,
name|NIG_REG_STAT2_BRB_OCTET
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|val
operator|=
operator|*
name|BXE_SP
argument_list|(
name|sc
argument_list|,
name|wb_data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* do internal memory self test */
if|if
condition|(
operator|(
name|val
operator|==
literal|0
operator|)
operator|&&
name|bxe_int_mem_test
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"internal mem self test failed val=0x%x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|bxe_setup_fan_failure_detection
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* clear PXP2 attentions */
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_PXP2_INT_STS_CLR_0
argument_list|)
expr_stmt|;
name|bxe_enable_blocks_attention
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CHIP_REV_IS_SLOW
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|ecore_enable_blocks_parity
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|BXE_NOMCP
argument_list|(
name|sc
argument_list|)
condition|)
block|{
if|if
condition|(
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|bxe_common_init_phy
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * bxe_init_hw_common_chip - init HW at the COMMON_CHIP phase.  *  * @sc:     driver handle  */
end_comment

begin_function
specifier|static
name|int
name|bxe_init_hw_common_chip
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rc
init|=
name|bxe_init_hw_common
argument_list|(
name|sc
argument_list|)
decl_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"bxe_init_hw_common failed rc=%d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
comment|/* In E2 2-PORT mode, same ext phy is used for the two paths */
if|if
condition|(
operator|!
name|BXE_NOMCP
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|bxe_common_init_phy
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_init_hw_port
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|port
init|=
name|SC_PORT
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|int
name|init_phase
init|=
name|port
condition|?
name|PHASE_PORT1
else|:
name|PHASE_PORT0
decl_stmt|;
name|uint32_t
name|low
decl_stmt|,
name|high
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"starting port init for port %d\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_MASK_INTERRUPT_PORT0
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_MISC
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_PXP
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_PXP2
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
comment|/*      * Timers bug workaround: disables the pf_master bit in pglue at      * common phase, we need to enable it here before any dmae access are      * attempted. Therefore we manually added the enable-master to the      * port phase (it also happens in the function phase)      */
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PGLUE_B_REG_INTERNAL_PFID_ENABLE_MASTER
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_ATC
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_DMAE
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_PGLUE_B
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_QM
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_TCM
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_UCM
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_CCM
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_XCM
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
comment|/* QM cid (connection) count */
name|ecore_qm_init_cid_count
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|qm_cid_count
argument_list|,
name|INITOP_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|CNIC_SUPPORT
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_TM
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|TM_REG_LIN0_SCAN_TIME
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|TM_REG_LIN0_MAX_ACTIVE_CID
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|31
argument_list|)
expr_stmt|;
block|}
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_DORQ
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_BRB1
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
operator|||
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
condition|)
block|{
if|if
condition|(
name|IS_MF
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|low
operator|=
operator|(
name|BXE_ONE_PORT
argument_list|(
name|sc
argument_list|)
condition|?
literal|160
else|:
literal|246
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|mtu
operator|>
literal|4096
condition|)
block|{
if|if
condition|(
name|BXE_ONE_PORT
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|low
operator|=
literal|160
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|sc
operator|->
name|mtu
expr_stmt|;
comment|/* (24*1024 + val*4)/256 */
name|low
operator|=
operator|(
literal|96
operator|+
operator|(
name|val
operator|/
literal|64
operator|)
operator|+
operator|(
operator|(
name|val
operator|%
literal|64
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|low
operator|=
operator|(
name|BXE_ONE_PORT
argument_list|(
name|sc
argument_list|)
condition|?
literal|80
else|:
literal|160
operator|)
expr_stmt|;
block|}
name|high
operator|=
operator|(
name|low
operator|+
literal|56
operator|)
expr_stmt|;
comment|/* 14*1024/256 */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BRB1_REG_PAUSE_LOW_THRESHOLD_0
operator|+
name|port
operator|*
literal|4
argument_list|,
name|low
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BRB1_REG_PAUSE_HIGH_THRESHOLD_0
operator|+
name|port
operator|*
literal|4
argument_list|,
name|high
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CHIP_IS_MODE_4_PORT
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|SC_PORT
argument_list|(
name|sc
argument_list|)
condition|?
name|BRB1_REG_MAC_GUARANTIED_1
else|:
name|BRB1_REG_MAC_GUARANTIED_0
argument_list|,
literal|40
argument_list|)
expr_stmt|;
block|}
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_PRS
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E3B0
argument_list|(
name|sc
argument_list|)
condition|)
block|{
if|if
condition|(
name|IS_MF_AFEX
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* configure headers for AFEX mode */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|SC_PORT
argument_list|(
name|sc
argument_list|)
condition|?
name|PRS_REG_HDRS_AFTER_BASIC_PORT_1
else|:
name|PRS_REG_HDRS_AFTER_BASIC_PORT_0
argument_list|,
literal|0xE
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|SC_PORT
argument_list|(
name|sc
argument_list|)
condition|?
name|PRS_REG_HDRS_AFTER_TAG_0_PORT_1
else|:
name|PRS_REG_HDRS_AFTER_TAG_0_PORT_0
argument_list|,
literal|0x6
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|SC_PORT
argument_list|(
name|sc
argument_list|)
condition|?
name|PRS_REG_MUST_HAVE_HDRS_PORT_1
else|:
name|PRS_REG_MUST_HAVE_HDRS_PORT_0
argument_list|,
literal|0xA
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Ovlan exists only if we are in multi-function +              * switch-dependent mode, in switch-independent there              * is no ovlan headers              */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|SC_PORT
argument_list|(
name|sc
argument_list|)
condition|?
name|PRS_REG_HDRS_AFTER_BASIC_PORT_1
else|:
name|PRS_REG_HDRS_AFTER_BASIC_PORT_0
argument_list|,
operator|(
name|sc
operator|->
name|devinfo
operator|.
name|mf_info
operator|.
name|path_has_ovlan
condition|?
literal|7
else|:
literal|6
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_TSDM
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_CSDM
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_USDM
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_XSDM
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_TSEM
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_USEM
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_CSEM
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_XSEM
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_UPB
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_XPB
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_PBF
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* configure PBF to work without PAUSE mtu 9000 */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_P0_PAUSE_ENABLE
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* update threshold */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_P0_ARB_THRSH
operator|+
name|port
operator|*
literal|4
argument_list|,
operator|(
literal|9040
operator|/
literal|16
operator|)
argument_list|)
expr_stmt|;
comment|/* update init credit */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_P0_INIT_CRD
operator|+
name|port
operator|*
literal|4
argument_list|,
operator|(
literal|9040
operator|/
literal|16
operator|)
operator|+
literal|553
operator|-
literal|22
argument_list|)
expr_stmt|;
comment|/* probe changes */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_INIT_P0
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_INIT_P0
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CNIC_SUPPORT
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_SRC
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
block|}
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_CDU
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_CFC
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|HC_REG_LEADING_EDGE_0
operator|+
name|port
operator|*
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|HC_REG_TRAILING_EDGE_0
operator|+
name|port
operator|*
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_HC
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_IGU
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_MISC_AEU
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
comment|/* init aeu_mask_attn_func_0/1:      *  - SF mode: bits 3-7 are masked. only bits 0-2 are in use      *  - MF mode: bit 3 is masked. bits 0-2 are in use as in SF      *             bits 4-7 are used for "per vn group attention" */
name|val
operator|=
name|IS_MF
argument_list|(
name|sc
argument_list|)
condition|?
literal|0xF7
else|:
literal|0x7
expr_stmt|;
comment|/* Enable DCBX attention for all but E1 */
name|val
operator||=
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|?
literal|0
else|:
literal|0x10
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_MASK_ATTN_FUNC_0
operator|+
name|port
operator|*
literal|4
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_NIG
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* Bit-map indicating which L2 hdrs may appear after the          * basic Ethernet header          */
if|if
condition|(
name|IS_MF_AFEX
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|SC_PORT
argument_list|(
name|sc
argument_list|)
condition|?
name|NIG_REG_P1_HDRS_AFTER_BASIC
else|:
name|NIG_REG_P0_HDRS_AFTER_BASIC
argument_list|,
literal|0xE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|SC_PORT
argument_list|(
name|sc
argument_list|)
condition|?
name|NIG_REG_P1_HDRS_AFTER_BASIC
else|:
name|NIG_REG_P0_HDRS_AFTER_BASIC
argument_list|,
name|IS_MF_SD
argument_list|(
name|sc
argument_list|)
condition|?
literal|7
else|:
literal|6
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|SC_PORT
argument_list|(
name|sc
argument_list|)
condition|?
name|NIG_REG_LLH1_MF_MODE
else|:
name|NIG_REG_LLH_MF_MODE
argument_list|,
name|IS_MF
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_XGXS_SERDES0_MODE_SEL
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* 0x2 disable mf_ov, 0x1 enable */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LLH0_BRB1_DRV_MASK_MF
operator|+
name|port
operator|*
literal|4
argument_list|,
operator|(
name|IS_MF_SD
argument_list|(
name|sc
argument_list|)
condition|?
literal|0x1
else|:
literal|0x2
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|val
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|devinfo
operator|.
name|mf_info
operator|.
name|mf_mode
condition|)
block|{
case|case
name|MULTI_FUNCTION_SD
case|:
name|val
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MULTI_FUNCTION_SI
case|:
case|case
name|MULTI_FUNCTION_AFEX
case|:
name|val
operator|=
literal|2
expr_stmt|;
break|break;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|SC_PORT
argument_list|(
name|sc
argument_list|)
condition|?
name|NIG_REG_LLH1_CLS_TYPE
else|:
name|NIG_REG_LLH0_CLS_TYPE
operator|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LLFC_ENABLE_0
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LLFC_OUT_EN_0
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_PAUSE_ENABLE_0
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* If SPIO5 is set to generate interrupts, enable it for this port */
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_SPIO_EVENT_EN
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|MISC_SPIO_SPIO5
condition|)
block|{
name|uint32_t
name|reg_addr
init|=
operator|(
name|port
condition|?
name|MISC_REG_AEU_ENABLE1_FUNC_1_OUT_0
else|:
name|MISC_REG_AEU_ENABLE1_FUNC_0_OUT_0
operator|)
decl_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|reg_addr
argument_list|)
expr_stmt|;
name|val
operator||=
name|AEU_INPUTS_ATTN_BITS_SPIO5
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|reg_addr
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|bxe_flr_clnup_reg_poll
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|reg
parameter_list|,
name|uint32_t
name|expected
parameter_list|,
name|uint32_t
name|poll_count
parameter_list|)
block|{
name|uint32_t
name|cur_cnt
init|=
name|poll_count
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
while|while
condition|(
operator|(
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|)
operator|)
operator|!=
name|expected
operator|&&
name|cur_cnt
operator|--
condition|)
block|{
name|DELAY
argument_list|(
name|FLR_WAIT_INTERVAL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_flr_clnup_poll_hw_counter
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|reg
parameter_list|,
name|char
modifier|*
name|msg
parameter_list|,
name|uint32_t
name|poll_cnt
parameter_list|)
block|{
name|uint32_t
name|val
init|=
name|bxe_flr_clnup_reg_poll
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|,
name|poll_cnt
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"%s usage count=%d\n"
argument_list|,
name|msg
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Common routines with VF FLR cleanup */
end_comment

begin_function
specifier|static
name|uint32_t
name|bxe_flr_clnup_poll_count
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* adjust polling timeout */
if|if
condition|(
name|CHIP_REV_IS_EMUL
argument_list|(
name|sc
argument_list|)
condition|)
block|{
return|return
operator|(
name|FLR_POLL_CNT
operator|*
literal|2000
operator|)
return|;
block|}
if|if
condition|(
name|CHIP_REV_IS_FPGA
argument_list|(
name|sc
argument_list|)
condition|)
block|{
return|return
operator|(
name|FLR_POLL_CNT
operator|*
literal|120
operator|)
return|;
block|}
return|return
operator|(
name|FLR_POLL_CNT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_poll_hw_usage_counters
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|poll_cnt
parameter_list|)
block|{
comment|/* wait for CFC PF usage-counter to zero (includes all the VFs) */
if|if
condition|(
name|bxe_flr_clnup_poll_hw_counter
argument_list|(
name|sc
argument_list|,
name|CFC_REG_NUM_LCIDS_INSIDE_PF
argument_list|,
literal|"CFC PF usage counter timed out"
argument_list|,
name|poll_cnt
argument_list|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Wait for DQ PF usage-counter to zero (until DQ cleanup) */
if|if
condition|(
name|bxe_flr_clnup_poll_hw_counter
argument_list|(
name|sc
argument_list|,
name|DORQ_REG_PF_USAGE_CNT
argument_list|,
literal|"DQ PF usage counter timed out"
argument_list|,
name|poll_cnt
argument_list|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Wait for QM PF usage-counter to zero (until DQ cleanup) */
if|if
condition|(
name|bxe_flr_clnup_poll_hw_counter
argument_list|(
name|sc
argument_list|,
name|QM_REG_PF_USG_CNT_0
operator|+
literal|4
operator|*
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
argument_list|,
literal|"QM PF usage counter timed out"
argument_list|,
name|poll_cnt
argument_list|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Wait for Timer PF usage-counters to zero (until DQ cleanup) */
if|if
condition|(
name|bxe_flr_clnup_poll_hw_counter
argument_list|(
name|sc
argument_list|,
name|TM_REG_LIN0_VNIC_UC
operator|+
literal|4
operator|*
name|SC_PORT
argument_list|(
name|sc
argument_list|)
argument_list|,
literal|"Timers VNIC usage counter timed out"
argument_list|,
name|poll_cnt
argument_list|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|bxe_flr_clnup_poll_hw_counter
argument_list|(
name|sc
argument_list|,
name|TM_REG_LIN0_NUM_SCANS
operator|+
literal|4
operator|*
name|SC_PORT
argument_list|(
name|sc
argument_list|)
argument_list|,
literal|"Timers NUM_SCANS usage counter timed out"
argument_list|,
name|poll_cnt
argument_list|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Wait DMAE PF usage counter to zero */
if|if
condition|(
name|bxe_flr_clnup_poll_hw_counter
argument_list|(
name|sc
argument_list|,
name|dmae_reg_go_c
index|[
name|INIT_DMAE_C
argument_list|(
name|sc
argument_list|)
index|]
argument_list|,
literal|"DMAE dommand register timed out"
argument_list|,
name|poll_cnt
argument_list|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|OP_GEN_PARAM
parameter_list|(
name|param
parameter_list|)
define|\
value|(((param)<< SDM_OP_GEN_COMP_PARAM_SHIFT)& SDM_OP_GEN_COMP_PARAM)
end_define

begin_define
define|#
directive|define
name|OP_GEN_TYPE
parameter_list|(
name|type
parameter_list|)
define|\
value|(((type)<< SDM_OP_GEN_COMP_TYPE_SHIFT)& SDM_OP_GEN_COMP_TYPE)
end_define

begin_define
define|#
directive|define
name|OP_GEN_AGG_VECT
parameter_list|(
name|index
parameter_list|)
define|\
value|(((index)<< SDM_OP_GEN_AGG_VECT_IDX_SHIFT)& SDM_OP_GEN_AGG_VECT_IDX)
end_define

begin_function
specifier|static
name|int
name|bxe_send_final_clnup
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|clnup_func
parameter_list|,
name|uint32_t
name|poll_cnt
parameter_list|)
block|{
name|uint32_t
name|op_gen_command
init|=
literal|0
decl_stmt|;
name|uint32_t
name|comp_addr
init|=
operator|(
name|BAR_CSTRORM_INTMEM
operator|+
name|CSTORM_FINAL_CLEANUP_COMPLETE_OFFSET
argument_list|(
name|clnup_func
argument_list|)
operator|)
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|comp_addr
argument_list|)
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Cleanup complete was not 0 before sending\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|op_gen_command
operator||=
name|OP_GEN_PARAM
argument_list|(
name|XSTORM_AGG_INT_FINAL_CLEANUP_INDEX
argument_list|)
expr_stmt|;
name|op_gen_command
operator||=
name|OP_GEN_TYPE
argument_list|(
name|XSTORM_AGG_INT_FINAL_CLEANUP_COMP_TYPE
argument_list|)
expr_stmt|;
name|op_gen_command
operator||=
name|OP_GEN_AGG_VECT
argument_list|(
name|clnup_func
argument_list|)
expr_stmt|;
name|op_gen_command
operator||=
literal|1
operator|<<
name|SDM_OP_GEN_AGG_VECT_IDX_VALID_SHIFT
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"sending FW Final cleanup\n"
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|XSDM_REG_OPERATION_GEN
argument_list|,
name|op_gen_command
argument_list|)
expr_stmt|;
if|if
condition|(
name|bxe_flr_clnup_reg_poll
argument_list|(
name|sc
argument_list|,
name|comp_addr
argument_list|,
literal|1
argument_list|,
name|poll_cnt
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"FW final cleanup did not succeed\n"
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"At timeout completion address contained %x\n"
argument_list|,
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|comp_addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|bxe_panic
argument_list|(
name|sc
argument_list|,
operator|(
literal|"FLR cleanup failed\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Zero completion for nxt FLR */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|comp_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_pbf_pN_buf_flushed
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|pbf_pN_buf_regs
modifier|*
name|regs
parameter_list|,
name|uint32_t
name|poll_count
parameter_list|)
block|{
name|uint32_t
name|init_crd
decl_stmt|,
name|crd
decl_stmt|,
name|crd_start
decl_stmt|,
name|crd_freed
decl_stmt|,
name|crd_freed_start
decl_stmt|;
name|uint32_t
name|cur_cnt
init|=
name|poll_count
decl_stmt|;
name|crd_freed
operator|=
name|crd_freed_start
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|regs
operator|->
name|crd_freed
argument_list|)
expr_stmt|;
name|crd
operator|=
name|crd_start
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|regs
operator|->
name|crd
argument_list|)
expr_stmt|;
name|init_crd
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|regs
operator|->
name|init_crd
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"INIT CREDIT[%d] : %x\n"
argument_list|,
name|regs
operator|->
name|pN
argument_list|,
name|init_crd
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"CREDIT[%d]      : s:%x\n"
argument_list|,
name|regs
operator|->
name|pN
argument_list|,
name|crd
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"CREDIT_FREED[%d]: s:%x\n"
argument_list|,
name|regs
operator|->
name|pN
argument_list|,
name|crd_freed
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|crd
operator|!=
name|init_crd
operator|)
operator|&&
operator|(
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|int32_t
operator|)
name|crd_freed
operator|-
operator|(
name|int32_t
operator|)
name|crd_freed_start
argument_list|)
operator|<
operator|(
name|init_crd
operator|-
name|crd_start
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|cur_cnt
operator|--
condition|)
block|{
name|DELAY
argument_list|(
name|FLR_WAIT_INTERVAL
argument_list|)
expr_stmt|;
name|crd
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|regs
operator|->
name|crd
argument_list|)
expr_stmt|;
name|crd_freed
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|regs
operator|->
name|crd_freed
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"PBF tx buffer[%d] timed out\n"
argument_list|,
name|regs
operator|->
name|pN
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"CREDIT[%d]      : c:%x\n"
argument_list|,
name|regs
operator|->
name|pN
argument_list|,
name|crd
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"CREDIT_FREED[%d]: c:%x\n"
argument_list|,
name|regs
operator|->
name|pN
argument_list|,
name|crd_freed
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Waited %d*%d usec for PBF tx buffer[%d]\n"
argument_list|,
name|poll_count
operator|-
name|cur_cnt
argument_list|,
name|FLR_WAIT_INTERVAL
argument_list|,
name|regs
operator|->
name|pN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_pbf_pN_cmd_flushed
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|pbf_pN_cmd_regs
modifier|*
name|regs
parameter_list|,
name|uint32_t
name|poll_count
parameter_list|)
block|{
name|uint32_t
name|occup
decl_stmt|,
name|to_free
decl_stmt|,
name|freed
decl_stmt|,
name|freed_start
decl_stmt|;
name|uint32_t
name|cur_cnt
init|=
name|poll_count
decl_stmt|;
name|occup
operator|=
name|to_free
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|regs
operator|->
name|lines_occup
argument_list|)
expr_stmt|;
name|freed
operator|=
name|freed_start
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|regs
operator|->
name|lines_freed
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"OCCUPANCY[%d]   : s:%x\n"
argument_list|,
name|regs
operator|->
name|pN
argument_list|,
name|occup
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"LINES_FREED[%d] : s:%x\n"
argument_list|,
name|regs
operator|->
name|pN
argument_list|,
name|freed
argument_list|)
expr_stmt|;
while|while
condition|(
name|occup
operator|&&
operator|(
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|int32_t
operator|)
name|freed
operator|-
operator|(
name|int32_t
operator|)
name|freed_start
argument_list|)
operator|<
name|to_free
operator|)
condition|)
block|{
if|if
condition|(
name|cur_cnt
operator|--
condition|)
block|{
name|DELAY
argument_list|(
name|FLR_WAIT_INTERVAL
argument_list|)
expr_stmt|;
name|occup
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|regs
operator|->
name|lines_occup
argument_list|)
expr_stmt|;
name|freed
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|regs
operator|->
name|lines_freed
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"PBF cmd queue[%d] timed out\n"
argument_list|,
name|regs
operator|->
name|pN
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"OCCUPANCY[%d]   : s:%x\n"
argument_list|,
name|regs
operator|->
name|pN
argument_list|,
name|occup
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"LINES_FREED[%d] : s:%x\n"
argument_list|,
name|regs
operator|->
name|pN
argument_list|,
name|freed
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Waited %d*%d usec for PBF cmd queue[%d]\n"
argument_list|,
name|poll_count
operator|-
name|cur_cnt
argument_list|,
name|FLR_WAIT_INTERVAL
argument_list|,
name|regs
operator|->
name|pN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_tx_hw_flushed
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|poll_count
parameter_list|)
block|{
name|struct
name|pbf_pN_cmd_regs
name|cmd_regs
index|[]
init|=
block|{
block|{
literal|0
block|,
operator|(
name|CHIP_IS_E3B0
argument_list|(
name|sc
argument_list|)
operator|)
operator|?
name|PBF_REG_TQ_OCCUPANCY_Q0
operator|:
name|PBF_REG_P0_TQ_OCCUPANCY
block|,
operator|(
name|CHIP_IS_E3B0
argument_list|(
name|sc
argument_list|)
operator|)
operator|?
name|PBF_REG_TQ_LINES_FREED_CNT_Q0
operator|:
name|PBF_REG_P0_TQ_LINES_FREED_CNT
block|}
block|,
block|{
literal|1
block|,
operator|(
name|CHIP_IS_E3B0
argument_list|(
name|sc
argument_list|)
operator|)
operator|?
name|PBF_REG_TQ_OCCUPANCY_Q1
operator|:
name|PBF_REG_P1_TQ_OCCUPANCY
block|,
operator|(
name|CHIP_IS_E3B0
argument_list|(
name|sc
argument_list|)
operator|)
operator|?
name|PBF_REG_TQ_LINES_FREED_CNT_Q1
operator|:
name|PBF_REG_P1_TQ_LINES_FREED_CNT
block|}
block|,
block|{
literal|4
block|,
operator|(
name|CHIP_IS_E3B0
argument_list|(
name|sc
argument_list|)
operator|)
operator|?
name|PBF_REG_TQ_OCCUPANCY_LB_Q
operator|:
name|PBF_REG_P4_TQ_OCCUPANCY
block|,
operator|(
name|CHIP_IS_E3B0
argument_list|(
name|sc
argument_list|)
operator|)
operator|?
name|PBF_REG_TQ_LINES_FREED_CNT_LB_Q
operator|:
name|PBF_REG_P4_TQ_LINES_FREED_CNT
block|}
block|}
decl_stmt|;
name|struct
name|pbf_pN_buf_regs
name|buf_regs
index|[]
init|=
block|{
block|{
literal|0
block|,
operator|(
name|CHIP_IS_E3B0
argument_list|(
name|sc
argument_list|)
operator|)
operator|?
name|PBF_REG_INIT_CRD_Q0
operator|:
name|PBF_REG_P0_INIT_CRD
block|,
operator|(
name|CHIP_IS_E3B0
argument_list|(
name|sc
argument_list|)
operator|)
operator|?
name|PBF_REG_CREDIT_Q0
operator|:
name|PBF_REG_P0_CREDIT
block|,
operator|(
name|CHIP_IS_E3B0
argument_list|(
name|sc
argument_list|)
operator|)
operator|?
name|PBF_REG_INTERNAL_CRD_FREED_CNT_Q0
operator|:
name|PBF_REG_P0_INTERNAL_CRD_FREED_CNT
block|}
block|,
block|{
literal|1
block|,
operator|(
name|CHIP_IS_E3B0
argument_list|(
name|sc
argument_list|)
operator|)
operator|?
name|PBF_REG_INIT_CRD_Q1
operator|:
name|PBF_REG_P1_INIT_CRD
block|,
operator|(
name|CHIP_IS_E3B0
argument_list|(
name|sc
argument_list|)
operator|)
operator|?
name|PBF_REG_CREDIT_Q1
operator|:
name|PBF_REG_P1_CREDIT
block|,
operator|(
name|CHIP_IS_E3B0
argument_list|(
name|sc
argument_list|)
operator|)
operator|?
name|PBF_REG_INTERNAL_CRD_FREED_CNT_Q1
operator|:
name|PBF_REG_P1_INTERNAL_CRD_FREED_CNT
block|}
block|,
block|{
literal|4
block|,
operator|(
name|CHIP_IS_E3B0
argument_list|(
name|sc
argument_list|)
operator|)
operator|?
name|PBF_REG_INIT_CRD_LB_Q
operator|:
name|PBF_REG_P4_INIT_CRD
block|,
operator|(
name|CHIP_IS_E3B0
argument_list|(
name|sc
argument_list|)
operator|)
operator|?
name|PBF_REG_CREDIT_LB_Q
operator|:
name|PBF_REG_P4_CREDIT
block|,
operator|(
name|CHIP_IS_E3B0
argument_list|(
name|sc
argument_list|)
operator|)
operator|?
name|PBF_REG_INTERNAL_CRD_FREED_CNT_LB_Q
operator|:
name|PBF_REG_P4_INTERNAL_CRD_FREED_CNT
block|}
block|,     }
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Verify the command queues are flushed P0, P1, P4 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|cmd_regs
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|bxe_pbf_pN_cmd_flushed
argument_list|(
name|sc
argument_list|,
operator|&
name|cmd_regs
index|[
name|i
index|]
argument_list|,
name|poll_count
argument_list|)
expr_stmt|;
block|}
comment|/* Verify the transmission buffers are flushed P0, P1, P4 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|buf_regs
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|bxe_pbf_pN_buf_flushed
argument_list|(
name|sc
argument_list|,
operator|&
name|buf_regs
index|[
name|i
index|]
argument_list|,
name|poll_count
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_hw_enable_status
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|CFC_REG_WEAK_ENABLE_PF
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"CFC_REG_WEAK_ENABLE_PF is 0x%x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|PBF_REG_DISABLE_PF
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"PBF_REG_DISABLE_PF is 0x%x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|IGU_REG_PCI_PF_MSI_EN
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"IGU_REG_PCI_PF_MSI_EN is 0x%x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|IGU_REG_PCI_PF_MSIX_EN
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"IGU_REG_PCI_PF_MSIX_EN is 0x%x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|IGU_REG_PCI_PF_MSIX_FUNC_MASK
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"IGU_REG_PCI_PF_MSIX_FUNC_MASK is 0x%x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|PGLUE_B_REG_SHADOW_BME_PF_7_0_CLR
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"PGLUE_B_REG_SHADOW_BME_PF_7_0_CLR is 0x%x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|PGLUE_B_REG_FLR_REQUEST_PF_7_0_CLR
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"PGLUE_B_REG_FLR_REQUEST_PF_7_0_CLR is 0x%x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|PGLUE_B_REG_INTERNAL_PFID_ENABLE_MASTER
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"PGLUE_B_REG_INTERNAL_PFID_ENABLE_MASTER is 0x%x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_pf_flr_clnup
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|poll_cnt
init|=
name|bxe_flr_clnup_poll_count
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Cleanup after FLR PF[%d]\n"
argument_list|,
name|SC_ABS_FUNC
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Re-enable PF target read access */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PGLUE_B_REG_INTERNAL_PFID_ENABLE_TARGET_READ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Poll HW usage counters */
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Polling usage counters\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bxe_poll_hw_usage_counters
argument_list|(
name|sc
argument_list|,
name|poll_cnt
argument_list|)
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Zero the igu 'trailing edge' and 'leading edge' */
comment|/* Send the FW cleanup command */
if|if
condition|(
name|bxe_send_final_clnup
argument_list|(
name|sc
argument_list|,
operator|(
name|uint8_t
operator|)
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
argument_list|,
name|poll_cnt
argument_list|)
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* ATC cleanup */
comment|/* Verify TX hw is flushed */
name|bxe_tx_hw_flushed
argument_list|(
name|sc
argument_list|,
name|poll_cnt
argument_list|)
expr_stmt|;
comment|/* Wait 100ms (not adjusted according to platform) */
name|DELAY
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
comment|/* Verify no pending pci transactions */
if|if
condition|(
name|bxe_is_pcie_pending
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"PCIE Transactions still pending\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Debug */
name|bxe_hw_enable_status
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*      * Master enable - Due to WB DMAE writes performed before this      * register is re-initialized as part of the regular function init      */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PGLUE_B_REG_INTERNAL_PFID_ENABLE_MASTER
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_init_hw_func
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|port
init|=
name|SC_PORT
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|int
name|func
init|=
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|int
name|init_phase
init|=
name|PHASE_PF0
operator|+
name|func
decl_stmt|;
name|struct
name|ecore_ilt
modifier|*
name|ilt
init|=
name|sc
operator|->
name|ilt
decl_stmt|;
name|uint16_t
name|cdu_ilt_start
decl_stmt|;
name|uint32_t
name|addr
decl_stmt|,
name|val
decl_stmt|;
name|uint32_t
name|main_mem_base
decl_stmt|,
name|main_mem_size
decl_stmt|,
name|main_mem_prty_clr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|main_mem_width
decl_stmt|,
name|rc
decl_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"starting func init for func %d\n"
argument_list|,
name|func
argument_list|)
expr_stmt|;
comment|/* FLR cleanup */
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|rc
operator|=
name|bxe_pf_flr_clnup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"FLR cleanup failed!\n"
argument_list|)
expr_stmt|;
comment|// XXX bxe_fw_dump(sc);
comment|// XXX bxe_idle_chk(sc);
return|return
operator|(
name|rc
operator|)
return|;
block|}
block|}
comment|/* set MSI reconfigure capability */
if|if
condition|(
name|sc
operator|->
name|devinfo
operator|.
name|int_block
operator|==
name|INT_BLOCK_HC
condition|)
block|{
name|addr
operator|=
operator|(
name|port
condition|?
name|HC_REG_CONFIG_1
else|:
name|HC_REG_CONFIG_0
operator|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|val
operator||=
name|HC_CONFIG_0_REG_MSI_ATTN_EN_0
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_PXP
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_PXP2
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ilt
operator|=
name|sc
operator|->
name|ilt
expr_stmt|;
name|cdu_ilt_start
operator|=
name|ilt
operator|->
name|clients
index|[
name|ILT_CLIENT_CDU
index|]
operator|.
name|start
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|L2_ILT_LINES
argument_list|(
name|sc
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|ilt
operator|->
name|lines
index|[
name|cdu_ilt_start
operator|+
name|i
index|]
operator|.
name|page
operator|=
name|sc
operator|->
name|context
index|[
name|i
index|]
operator|.
name|vcxt
expr_stmt|;
name|ilt
operator|->
name|lines
index|[
name|cdu_ilt_start
operator|+
name|i
index|]
operator|.
name|page_mapping
operator|=
name|sc
operator|->
name|context
index|[
name|i
index|]
operator|.
name|vcxt_dma
operator|.
name|paddr
expr_stmt|;
name|ilt
operator|->
name|lines
index|[
name|cdu_ilt_start
operator|+
name|i
index|]
operator|.
name|size
operator|=
name|sc
operator|->
name|context
index|[
name|i
index|]
operator|.
name|size
expr_stmt|;
block|}
name|ecore_ilt_init_op
argument_list|(
name|sc
argument_list|,
name|INITOP_SET
argument_list|)
expr_stmt|;
comment|/* Set NIC mode */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PRS_REG_NIC_MODE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"NIC MODE configured\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|uint32_t
name|pf_conf
init|=
name|IGU_PF_CONF_FUNC_EN
decl_stmt|;
comment|/* Turn on a single ISR mode in IGU if driver is going to use          * INT#x or MSI          */
if|if
condition|(
name|sc
operator|->
name|interrupt_mode
operator|!=
name|INTR_MODE_MSIX
condition|)
block|{
name|pf_conf
operator||=
name|IGU_PF_CONF_SINGLE_ISR_EN
expr_stmt|;
block|}
comment|/*          * Timers workaround bug: function init part.          * Need to wait 20msec after initializing ILT,          * needed to make sure there are no requests in          * one of the PXP internal queues with "old" ILT addresses          */
name|DELAY
argument_list|(
literal|20000
argument_list|)
expr_stmt|;
comment|/*          * Master enable - Due to WB DMAE writes performed before this          * register is re-initialized as part of the regular function          * init          */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PGLUE_B_REG_INTERNAL_PFID_ENABLE_MASTER
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Enable the function in IGU */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|IGU_REG_PF_CONFIGURATION
argument_list|,
name|pf_conf
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|dmae_ready
operator|=
literal|1
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_PGLUE_B
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PGLUE_B_REG_WAS_ERROR_PF_7_0_CLR
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_ATC
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_DMAE
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_NIG
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_SRC
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_MISC
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_TCM
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_UCM
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_CCM
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_XCM
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_TSEM
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_USEM
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_CSEM
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_XSEM
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|QM_REG_PF_EN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|TSEM_REG_VFPF_ERR_NUM
argument_list|,
name|BXE_MAX_NUM_OF_VFS
operator|+
name|func
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|USEM_REG_VFPF_ERR_NUM
argument_list|,
name|BXE_MAX_NUM_OF_VFS
operator|+
name|func
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|CSEM_REG_VFPF_ERR_NUM
argument_list|,
name|BXE_MAX_NUM_OF_VFS
operator|+
name|func
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|XSEM_REG_VFPF_ERR_NUM
argument_list|,
name|BXE_MAX_NUM_OF_VFS
operator|+
name|func
argument_list|)
expr_stmt|;
block|}
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_QM
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_TM
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_DORQ
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|bxe_iov_init_dq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_BRB1
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_PRS
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_TSDM
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_CSDM
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_USDM
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_XSDM
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_UPB
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_XPB
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_PBF
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_DISABLE_PF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_CDU
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_CFC
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|CFC_REG_WEAK_ENABLE_PF
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_MF
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LLH0_FUNC_EN
operator|+
name|port
operator|*
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LLH0_FUNC_VLAN_ID
operator|+
name|port
operator|*
literal|8
argument_list|,
name|OVLAN
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_MISC_AEU
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
comment|/* HC init per function */
if|if
condition|(
name|sc
operator|->
name|devinfo
operator|.
name|int_block
operator|==
name|INT_BLOCK_HC
condition|)
block|{
if|if
condition|(
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_GENERAL_ATTN_12
operator|+
name|func
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|HC_REG_LEADING_EDGE_0
operator|+
name|port
operator|*
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|HC_REG_TRAILING_EDGE_0
operator|+
name|port
operator|*
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_HC
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|num_segs
decl_stmt|,
name|sb_idx
decl_stmt|,
name|prod_offset
decl_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_GENERAL_ATTN_12
operator|+
name|func
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|IGU_REG_LEADING_EDGE_LATCH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|IGU_REG_TRAILING_EDGE_LATCH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ecore_init_block
argument_list|(
name|sc
argument_list|,
name|BLOCK_IGU
argument_list|,
name|init_phase
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|int
name|dsb_idx
init|=
literal|0
decl_stmt|;
comment|/**              * Producer memory:              * E2 mode: address 0-135 match to the mapping memory;              * 136 - PF0 default prod; 137 - PF1 default prod;              * 138 - PF2 default prod; 139 - PF3 default prod;              * 140 - PF0 attn prod;    141 - PF1 attn prod;              * 142 - PF2 attn prod;    143 - PF3 attn prod;              * 144-147 reserved.              *              * E1.5 mode - In backward compatible mode;              * for non default SB; each even line in the memory              * holds the U producer and each odd line hold              * the C producer. The first 128 producers are for              * NDSB (PF0 - 0-31; PF1 - 32-63 and so on). The last 20              * producers are for the DSB for each PF.              * Each PF has five segments: (the order inside each              * segment is PF0; PF1; PF2; PF3) - 128-131 U prods;              * 132-135 C prods; 136-139 X prods; 140-143 T prods;              * 144-147 attn prods;              */
comment|/* non-default-status-blocks */
name|num_segs
operator|=
name|CHIP_INT_MODE_IS_BC
argument_list|(
name|sc
argument_list|)
condition|?
name|IGU_BC_NDSB_NUM_SEGS
else|:
name|IGU_NORM_NDSB_NUM_SEGS
expr_stmt|;
for|for
control|(
name|sb_idx
operator|=
literal|0
init|;
name|sb_idx
operator|<
name|sc
operator|->
name|igu_sb_cnt
condition|;
name|sb_idx
operator|++
control|)
block|{
name|prod_offset
operator|=
operator|(
name|sc
operator|->
name|igu_base_sb
operator|+
name|sb_idx
operator|)
operator|*
name|num_segs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_segs
condition|;
name|i
operator|++
control|)
block|{
name|addr
operator|=
name|IGU_REG_PROD_CONS_MEMORY
operator|+
operator|(
name|prod_offset
operator|+
name|i
operator|)
operator|*
literal|4
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* send consumer update with value 0 */
name|bxe_ack_sb
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|igu_base_sb
operator|+
name|sb_idx
argument_list|,
name|USTORM_ID
argument_list|,
literal|0
argument_list|,
name|IGU_INT_NOP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bxe_igu_clear_sb
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|igu_base_sb
operator|+
name|sb_idx
argument_list|)
expr_stmt|;
block|}
comment|/* default-status-blocks */
name|num_segs
operator|=
name|CHIP_INT_MODE_IS_BC
argument_list|(
name|sc
argument_list|)
condition|?
name|IGU_BC_DSB_NUM_SEGS
else|:
name|IGU_NORM_DSB_NUM_SEGS
expr_stmt|;
if|if
condition|(
name|CHIP_IS_MODE_4_PORT
argument_list|(
name|sc
argument_list|)
condition|)
name|dsb_idx
operator|=
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|dsb_idx
operator|=
name|SC_VN
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|prod_offset
operator|=
operator|(
name|CHIP_INT_MODE_IS_BC
argument_list|(
name|sc
argument_list|)
condition|?
name|IGU_BC_BASE_DSB_PROD
operator|+
name|dsb_idx
else|:
name|IGU_NORM_BASE_DSB_PROD
operator|+
name|dsb_idx
operator|)
expr_stmt|;
comment|/*              * igu prods come in chunks of E1HVN_MAX (4) -              * does not matters what is the current chip mode              */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|num_segs
operator|*
name|E1HVN_MAX
operator|)
condition|;
name|i
operator|+=
name|E1HVN_MAX
control|)
block|{
name|addr
operator|=
name|IGU_REG_PROD_CONS_MEMORY
operator|+
operator|(
name|prod_offset
operator|+
name|i
operator|)
operator|*
literal|4
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* send consumer update with 0 */
if|if
condition|(
name|CHIP_INT_MODE_IS_BC
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|bxe_ack_sb
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|igu_dsb_id
argument_list|,
name|USTORM_ID
argument_list|,
literal|0
argument_list|,
name|IGU_INT_NOP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bxe_ack_sb
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|igu_dsb_id
argument_list|,
name|CSTORM_ID
argument_list|,
literal|0
argument_list|,
name|IGU_INT_NOP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bxe_ack_sb
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|igu_dsb_id
argument_list|,
name|XSTORM_ID
argument_list|,
literal|0
argument_list|,
name|IGU_INT_NOP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bxe_ack_sb
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|igu_dsb_id
argument_list|,
name|TSTORM_ID
argument_list|,
literal|0
argument_list|,
name|IGU_INT_NOP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bxe_ack_sb
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|igu_dsb_id
argument_list|,
name|ATTENTION_ID
argument_list|,
literal|0
argument_list|,
name|IGU_INT_NOP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bxe_ack_sb
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|igu_dsb_id
argument_list|,
name|USTORM_ID
argument_list|,
literal|0
argument_list|,
name|IGU_INT_NOP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bxe_ack_sb
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|igu_dsb_id
argument_list|,
name|ATTENTION_ID
argument_list|,
literal|0
argument_list|,
name|IGU_INT_NOP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|bxe_igu_clear_sb
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|igu_dsb_id
argument_list|)
expr_stmt|;
comment|/* !!! these should become driver const once                rf-tool supports split-68 const */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|IGU_REG_SB_INT_BEFORE_MASK_LSB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|IGU_REG_SB_INT_BEFORE_MASK_MSB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|IGU_REG_SB_MASK_LSB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|IGU_REG_SB_MASK_MSB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|IGU_REG_PBA_STATUS_LSB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|IGU_REG_PBA_STATUS_MSB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Reset PCIE errors for debug */
name|REG_WR
argument_list|(
name|sc
argument_list|,
literal|0x2114
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
literal|0x2120
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|main_mem_size
operator|=
name|HC_REG_MAIN_MEMORY_SIZE
operator|/
literal|2
expr_stmt|;
comment|/*dwords*/
name|main_mem_base
operator|=
name|HC_REG_MAIN_MEMORY
operator|+
name|SC_PORT
argument_list|(
name|sc
argument_list|)
operator|*
operator|(
name|main_mem_size
operator|*
literal|4
operator|)
expr_stmt|;
name|main_mem_prty_clr
operator|=
name|HC_REG_HC_PRTY_STS_CLR
expr_stmt|;
name|main_mem_width
operator|=
literal|8
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|main_mem_prty_clr
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"Parity errors in HC block during function init (0x%x)!\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
comment|/* Clear "false" parity errors in MSI-X table */
for|for
control|(
name|i
operator|=
name|main_mem_base
init|;
name|i
operator|<
name|main_mem_base
operator|+
name|main_mem_size
operator|*
literal|4
condition|;
name|i
operator|+=
name|main_mem_width
control|)
block|{
name|bxe_read_dmae
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|main_mem_width
operator|/
literal|4
argument_list|)
expr_stmt|;
name|bxe_write_dmae
argument_list|(
name|sc
argument_list|,
name|BXE_SP_MAPPING
argument_list|(
name|sc
argument_list|,
name|wb_data
argument_list|)
argument_list|,
name|i
argument_list|,
name|main_mem_width
operator|/
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* Clear HC parity attention */
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|main_mem_prty_clr
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|1
comment|/* Enable STORMs SP logging */
name|REG_WR8
argument_list|(
name|sc
argument_list|,
name|BAR_USTRORM_INTMEM
operator|+
name|USTORM_RECORD_SLOW_PATH_OFFSET
argument_list|(
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|REG_WR8
argument_list|(
name|sc
argument_list|,
name|BAR_TSTRORM_INTMEM
operator|+
name|TSTORM_RECORD_SLOW_PATH_OFFSET
argument_list|(
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|REG_WR8
argument_list|(
name|sc
argument_list|,
name|BAR_CSTRORM_INTMEM
operator|+
name|CSTORM_RECORD_SLOW_PATH_OFFSET
argument_list|(
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|REG_WR8
argument_list|(
name|sc
argument_list|,
name|BAR_XSTRORM_INTMEM
operator|+
name|XSTORM_RECORD_SLOW_PATH_OFFSET
argument_list|(
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|elink_phy_probe
argument_list|(
operator|&
name|sc
operator|->
name|link_params
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_link_reset
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
operator|!
name|BXE_NOMCP
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|bxe_acquire_phy_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|elink_lfa_reset
argument_list|(
operator|&
name|sc
operator|->
name|link_params
argument_list|,
operator|&
name|sc
operator|->
name|link_vars
argument_list|)
expr_stmt|;
name|bxe_release_phy_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|CHIP_REV_IS_SLOW
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|BLOGW
argument_list|(
name|sc
argument_list|,
literal|"Bootcode is missing - cannot reset link\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_reset_port
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|port
init|=
name|SC_PORT
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"bxe_reset_port called\n"
argument_list|)
expr_stmt|;
comment|/* reset physical Link */
name|bxe_link_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_MASK_INTERRUPT_PORT0
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Do not rcv packets to BRB */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LLH0_BRB1_DRV_MASK
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* Do not direct rcv packets that are not for MCP to the BRB */
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|port
condition|?
name|NIG_REG_LLH1_BRB1_NOT_MCP
else|:
name|NIG_REG_LLH0_BRB1_NOT_MCP
operator|)
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* Configure AEU */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_MASK_ATTN_FUNC_0
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
comment|/* Check for BRB port occupancy */
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|BRB1_REG_PORT_NUM_OCC_BLOCKS_0
operator|+
name|port
operator|*
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
block|{
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"BRB1 is not empty, %d blocks are occupied\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
comment|/* TODO: Close Doorbell port? */
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_ilt_wr
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|index
parameter_list|,
name|bus_addr_t
name|addr
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|uint32_t
name|wb_write
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|reg
operator|=
name|PXP2_REG_RQ_ONCHIP_AT
operator|+
name|index
operator|*
literal|8
expr_stmt|;
block|}
else|else
block|{
name|reg
operator|=
name|PXP2_REG_RQ_ONCHIP_AT_B0
operator|+
name|index
operator|*
literal|8
expr_stmt|;
block|}
name|wb_write
index|[
literal|0
index|]
operator|=
name|ONCHIP_ADDR1
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|wb_write
index|[
literal|1
index|]
operator|=
name|ONCHIP_ADDR2
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|REG_WR_DMAE
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
name|wb_write
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_clear_func_ilt
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|func
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|,
name|base
init|=
name|FUNC_ILT_BASE
argument_list|(
name|func
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|base
init|;
name|i
operator|<
name|base
operator|+
name|ILT_PER_FUNC
condition|;
name|i
operator|++
control|)
block|{
name|bxe_ilt_wr
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_reset_func
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|int
name|port
init|=
name|SC_PORT
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|int
name|func
init|=
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Disable the function in the FW */
name|REG_WR8
argument_list|(
name|sc
argument_list|,
name|BAR_XSTRORM_INTMEM
operator|+
name|XSTORM_FUNC_EN_OFFSET
argument_list|(
name|func
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR8
argument_list|(
name|sc
argument_list|,
name|BAR_CSTRORM_INTMEM
operator|+
name|CSTORM_FUNC_EN_OFFSET
argument_list|(
name|func
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR8
argument_list|(
name|sc
argument_list|,
name|BAR_TSTRORM_INTMEM
operator|+
name|TSTORM_FUNC_EN_OFFSET
argument_list|(
name|func
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR8
argument_list|(
name|sc
argument_list|,
name|BAR_USTRORM_INTMEM
operator|+
name|USTORM_FUNC_EN_OFFSET
argument_list|(
name|func
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FP SBs */
name|FOR_EACH_ETH_QUEUE
argument_list|(
argument|sc
argument_list|,
argument|i
argument_list|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
expr_stmt|;
name|REG_WR8
argument_list|(
name|sc
argument_list|,
name|BAR_CSTRORM_INTMEM
operator|+
name|CSTORM_STATUS_BLOCK_DATA_STATE_OFFSET
argument_list|(
name|fp
operator|->
name|fw_sb_id
argument_list|)
argument_list|,
name|SB_DISABLED
argument_list|)
expr_stmt|;
block|}
comment|/* SP SB */
name|REG_WR8
argument_list|(
name|sc
argument_list|,
name|BAR_CSTRORM_INTMEM
operator|+
name|CSTORM_SP_STATUS_BLOCK_DATA_STATE_OFFSET
argument_list|(
name|func
argument_list|)
argument_list|,
name|SB_DISABLED
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XSTORM_SPQ_DATA_SIZE
operator|/
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|BAR_XSTRORM_INTMEM
operator|+
name|XSTORM_SPQ_DATA_OFFSET
argument_list|(
name|func
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Configure IGU */
if|if
condition|(
name|sc
operator|->
name|devinfo
operator|.
name|int_block
operator|==
name|INT_BLOCK_HC
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|HC_REG_LEADING_EDGE_0
operator|+
name|port
operator|*
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|HC_REG_TRAILING_EDGE_0
operator|+
name|port
operator|*
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|IGU_REG_LEADING_EDGE_LATCH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|IGU_REG_TRAILING_EDGE_LATCH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CNIC_LOADED
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* Disable Timer scan */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|TM_REG_EN_LINEAR0_TIMER
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*          * Wait for at least 10ms and up to 2 second for the timers          * scan to complete          */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|200
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|TM_REG_LIN0_SCAN_ON
operator|+
name|port
operator|*
literal|4
argument_list|)
condition|)
break|break;
block|}
block|}
comment|/* Clear ILT */
name|bxe_clear_func_ilt
argument_list|(
name|sc
argument_list|,
name|func
argument_list|)
expr_stmt|;
comment|/*      * Timers workaround bug for E2: if this is vnic-3,      * we need to set the entire ilt range for this timers.      */
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
operator|&&
name|SC_VN
argument_list|(
name|sc
argument_list|)
operator|==
literal|3
condition|)
block|{
name|struct
name|ilt_client_info
name|ilt_cli
decl_stmt|;
comment|/* use dummy TM client */
name|memset
argument_list|(
operator|&
name|ilt_cli
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ilt_client_info
argument_list|)
argument_list|)
expr_stmt|;
name|ilt_cli
operator|.
name|start
operator|=
literal|0
expr_stmt|;
name|ilt_cli
operator|.
name|end
operator|=
name|ILT_NUM_PAGE_ENTRIES
operator|-
literal|1
expr_stmt|;
name|ilt_cli
operator|.
name|client_num
operator|=
name|ILT_CLIENT_TM
expr_stmt|;
name|ecore_ilt_boundry_init_op
argument_list|(
name|sc
argument_list|,
operator|&
name|ilt_cli
argument_list|,
literal|0
argument_list|,
name|INITOP_CLEAR
argument_list|)
expr_stmt|;
block|}
comment|/* this assumes that reset_port() called before reset_func()*/
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|bxe_pf_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|dmae_ready
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_gunzip_init
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_gunzip_end
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_init_firmware
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|ecore_init_e1_firmware
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|iro_array
operator|=
name|e1_iro_arr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|ecore_init_e1h_firmware
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|iro_array
operator|=
name|e1h_iro_arr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|ecore_init_e2_firmware
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|iro_array
operator|=
name|e2_iro_arr
expr_stmt|;
block|}
else|else
block|{
name|BLOGE
argument_list|(
name|sc
argument_list|,
literal|"Unsupported chip revision\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_release_firmware
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Do nothing */
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|ecore_gunzip
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|zbuf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
comment|/* XXX : Implement... */
name|BLOGD
argument_list|(
name|sc
argument_list|,
name|DBG_LOAD
argument_list|,
literal|"ECORE_GUNZIP NOT IMPLEMENTED\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_reg_wr_ind
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|bxe_reg_wr_ind
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_write_dmae_phys_len
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|bus_addr_t
name|phys_addr
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|len
parameter_list|)
block|{
name|bxe_write_dmae_phys_len
argument_list|(
name|sc
argument_list|,
name|phys_addr
argument_list|,
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ecore_storm_memset_struct
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint32_t
modifier|*
name|data
parameter_list|)
block|{
name|uint8_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
operator|/
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|addr
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
argument_list|,
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * character device - ioctl interface definitions  */
end_comment

begin_include
include|#
directive|include
file|"bxe_dump.h"
end_include

begin_include
include|#
directive|include
file|"bxe_ioctl.h"
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_function_decl
specifier|static
name|int
name|bxe_eioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|bxe_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_ioctl
operator|=
name|bxe_eioctl
block|,
operator|.
name|d_name
operator|=
literal|"bxecnic"
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BXE_PATH
parameter_list|(
name|sc
parameter_list|)
value|(CHIP_IS_E1x(sc) ? 0 : (sc->pcie_func& 1))
end_define

begin_define
define|#
directive|define
name|DUMP_ALL_PRESETS
value|0x1FFF
end_define

begin_define
define|#
directive|define
name|DUMP_MAX_PRESETS
value|13
end_define

begin_define
define|#
directive|define
name|IS_E1_REG
parameter_list|(
name|chips
parameter_list|)
value|((chips& DUMP_CHIP_E1) == DUMP_CHIP_E1)
end_define

begin_define
define|#
directive|define
name|IS_E1H_REG
parameter_list|(
name|chips
parameter_list|)
value|((chips& DUMP_CHIP_E1H) == DUMP_CHIP_E1H)
end_define

begin_define
define|#
directive|define
name|IS_E2_REG
parameter_list|(
name|chips
parameter_list|)
value|((chips& DUMP_CHIP_E2) == DUMP_CHIP_E2)
end_define

begin_define
define|#
directive|define
name|IS_E3A0_REG
parameter_list|(
name|chips
parameter_list|)
value|((chips& DUMP_CHIP_E3A0) == DUMP_CHIP_E3A0)
end_define

begin_define
define|#
directive|define
name|IS_E3B0_REG
parameter_list|(
name|chips
parameter_list|)
value|((chips& DUMP_CHIP_E3B0) == DUMP_CHIP_E3B0)
end_define

begin_define
define|#
directive|define
name|IS_REG_IN_PRESET
parameter_list|(
name|presets
parameter_list|,
name|idx
parameter_list|)
define|\
value|((presets& (1<< (idx-1))) == (1<< (idx-1)))
end_define

begin_function
specifier|static
name|int
name|bxe_get_preset_regs_len
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|preset
parameter_list|)
block|{
if|if
condition|(
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|dump_num_registers
index|[
literal|0
index|]
index|[
name|preset
operator|-
literal|1
index|]
return|;
elseif|else
if|if
condition|(
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|dump_num_registers
index|[
literal|1
index|]
index|[
name|preset
operator|-
literal|1
index|]
return|;
elseif|else
if|if
condition|(
name|CHIP_IS_E2
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|dump_num_registers
index|[
literal|2
index|]
index|[
name|preset
operator|-
literal|1
index|]
return|;
elseif|else
if|if
condition|(
name|CHIP_IS_E3A0
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|dump_num_registers
index|[
literal|3
index|]
index|[
name|preset
operator|-
literal|1
index|]
return|;
elseif|else
if|if
condition|(
name|CHIP_IS_E3B0
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|dump_num_registers
index|[
literal|4
index|]
index|[
name|preset
operator|-
literal|1
index|]
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_get_total_regs_len32
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|preset_idx
decl_stmt|;
name|int
name|regdump_len32
init|=
literal|0
decl_stmt|;
comment|/* Calculate the total preset regs length */
for|for
control|(
name|preset_idx
operator|=
literal|1
init|;
name|preset_idx
operator|<=
name|DUMP_MAX_PRESETS
condition|;
name|preset_idx
operator|++
control|)
block|{
name|regdump_len32
operator|+=
name|bxe_get_preset_regs_len
argument_list|(
name|sc
argument_list|,
name|preset_idx
argument_list|)
expr_stmt|;
block|}
return|return
name|regdump_len32
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|uint32_t
modifier|*
name|__bxe_get_page_addr_ar
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|CHIP_IS_E2
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|page_vals_e2
return|;
elseif|else
if|if
condition|(
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|page_vals_e3
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|__bxe_get_page_reg_num
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|CHIP_IS_E2
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|PAGE_MODE_VALUES_E2
return|;
elseif|else
if|if
condition|(
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|PAGE_MODE_VALUES_E3
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|uint32_t
modifier|*
name|__bxe_get_page_write_ar
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|CHIP_IS_E2
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|page_write_regs_e2
return|;
elseif|else
if|if
condition|(
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|page_write_regs_e3
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|__bxe_get_page_write_num
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|CHIP_IS_E2
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|PAGE_WRITE_REGS_E2
return|;
elseif|else
if|if
condition|(
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|PAGE_WRITE_REGS_E3
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|struct
name|reg_addr
modifier|*
name|__bxe_get_page_read_ar
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|CHIP_IS_E2
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|page_read_regs_e2
return|;
elseif|else
if|if
condition|(
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|page_read_regs_e3
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|__bxe_get_page_read_num
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|CHIP_IS_E2
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|PAGE_READ_REGS_E2
return|;
elseif|else
if|if
condition|(
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|PAGE_READ_REGS_E3
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|bxe_is_reg_in_chip
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|reg_addr
modifier|*
name|reg_info
parameter_list|)
block|{
if|if
condition|(
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|IS_E1_REG
argument_list|(
name|reg_info
operator|->
name|chips
argument_list|)
return|;
elseif|else
if|if
condition|(
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|IS_E1H_REG
argument_list|(
name|reg_info
operator|->
name|chips
argument_list|)
return|;
elseif|else
if|if
condition|(
name|CHIP_IS_E2
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|IS_E2_REG
argument_list|(
name|reg_info
operator|->
name|chips
argument_list|)
return|;
elseif|else
if|if
condition|(
name|CHIP_IS_E3A0
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|IS_E3A0_REG
argument_list|(
name|reg_info
operator|->
name|chips
argument_list|)
return|;
elseif|else
if|if
condition|(
name|CHIP_IS_E3B0
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|IS_E3B0_REG
argument_list|(
name|reg_info
operator|->
name|chips
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|bxe_is_wreg_in_chip
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|wreg_addr
modifier|*
name|wreg_info
parameter_list|)
block|{
if|if
condition|(
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|IS_E1_REG
argument_list|(
name|wreg_info
operator|->
name|chips
argument_list|)
return|;
elseif|else
if|if
condition|(
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|IS_E1H_REG
argument_list|(
name|wreg_info
operator|->
name|chips
argument_list|)
return|;
elseif|else
if|if
condition|(
name|CHIP_IS_E2
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|IS_E2_REG
argument_list|(
name|wreg_info
operator|->
name|chips
argument_list|)
return|;
elseif|else
if|if
condition|(
name|CHIP_IS_E3A0
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|IS_E3A0_REG
argument_list|(
name|wreg_info
operator|->
name|chips
argument_list|)
return|;
elseif|else
if|if
condition|(
name|CHIP_IS_E3B0
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|IS_E3B0_REG
argument_list|(
name|wreg_info
operator|->
name|chips
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * bxe_read_pages_regs - read "paged" registers  *  * @bp          device handle  * @p           output buffer  *  * Reads "paged" memories: memories that may only be read by first writing to a  * specific address ("write address") and then reading from a specific address  * ("read address"). There may be more than one write address per "page" and  * more than one read address per write address.  */
end_comment

begin_function
specifier|static
name|void
name|bxe_read_pages_regs
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
modifier|*
name|p
parameter_list|,
name|uint32_t
name|preset
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|n
decl_stmt|;
comment|/* addresses of the paged registers */
specifier|const
name|uint32_t
modifier|*
name|page_addr
init|=
name|__bxe_get_page_addr_ar
argument_list|(
name|sc
argument_list|)
decl_stmt|;
comment|/* number of paged registers */
name|int
name|num_pages
init|=
name|__bxe_get_page_reg_num
argument_list|(
name|sc
argument_list|)
decl_stmt|;
comment|/* write addresses */
specifier|const
name|uint32_t
modifier|*
name|write_addr
init|=
name|__bxe_get_page_write_ar
argument_list|(
name|sc
argument_list|)
decl_stmt|;
comment|/* number of write addresses */
name|int
name|write_num
init|=
name|__bxe_get_page_write_num
argument_list|(
name|sc
argument_list|)
decl_stmt|;
comment|/* read addresses info */
specifier|const
name|struct
name|reg_addr
modifier|*
name|read_addr
init|=
name|__bxe_get_page_read_ar
argument_list|(
name|sc
argument_list|)
decl_stmt|;
comment|/* number of read addresses */
name|int
name|read_num
init|=
name|__bxe_get_page_read_num
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|uint32_t
name|addr
decl_stmt|,
name|size
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_pages
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|write_num
condition|;
name|j
operator|++
control|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|write_addr
index|[
name|j
index|]
argument_list|,
name|page_addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|read_num
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|IS_REG_IN_PRESET
argument_list|(
name|read_addr
index|[
name|k
index|]
operator|.
name|presets
argument_list|,
name|preset
argument_list|)
condition|)
block|{
name|size
operator|=
name|read_addr
index|[
name|k
index|]
operator|.
name|size
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|size
condition|;
name|n
operator|++
control|)
block|{
name|addr
operator|=
name|read_addr
index|[
name|k
index|]
operator|.
name|addr
operator|+
name|n
operator|*
literal|4
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_get_preset_regs
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
modifier|*
name|p
parameter_list|,
name|uint32_t
name|preset
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|,
name|j
decl_stmt|,
name|addr
decl_stmt|;
specifier|const
name|struct
name|wreg_addr
modifier|*
name|wreg_addr_p
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
name|wreg_addr_p
operator|=
operator|&
name|wreg_addr_e1
expr_stmt|;
elseif|else
if|if
condition|(
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
condition|)
name|wreg_addr_p
operator|=
operator|&
name|wreg_addr_e1h
expr_stmt|;
elseif|else
if|if
condition|(
name|CHIP_IS_E2
argument_list|(
name|sc
argument_list|)
condition|)
name|wreg_addr_p
operator|=
operator|&
name|wreg_addr_e2
expr_stmt|;
elseif|else
if|if
condition|(
name|CHIP_IS_E3A0
argument_list|(
name|sc
argument_list|)
condition|)
name|wreg_addr_p
operator|=
operator|&
name|wreg_addr_e3
expr_stmt|;
elseif|else
if|if
condition|(
name|CHIP_IS_E3B0
argument_list|(
name|sc
argument_list|)
condition|)
name|wreg_addr_p
operator|=
operator|&
name|wreg_addr_e3b0
expr_stmt|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Read the idle_chk registers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IDLE_REGS_COUNT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bxe_is_reg_in_chip
argument_list|(
name|sc
argument_list|,
operator|&
name|idle_reg_addrs
index|[
name|i
index|]
argument_list|)
operator|&&
name|IS_REG_IN_PRESET
argument_list|(
name|idle_reg_addrs
index|[
name|i
index|]
operator|.
name|presets
argument_list|,
name|preset
argument_list|)
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|idle_reg_addrs
index|[
name|i
index|]
operator|.
name|size
condition|;
name|j
operator|++
control|)
operator|*
name|p
operator|++
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|idle_reg_addrs
index|[
name|i
index|]
operator|.
name|addr
operator|+
name|j
operator|*
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Read the regular registers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGS_COUNT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bxe_is_reg_in_chip
argument_list|(
name|sc
argument_list|,
operator|&
name|reg_addrs
index|[
name|i
index|]
argument_list|)
operator|&&
name|IS_REG_IN_PRESET
argument_list|(
name|reg_addrs
index|[
name|i
index|]
operator|.
name|presets
argument_list|,
name|preset
argument_list|)
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|reg_addrs
index|[
name|i
index|]
operator|.
name|size
condition|;
name|j
operator|++
control|)
operator|*
name|p
operator|++
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|reg_addrs
index|[
name|i
index|]
operator|.
name|addr
operator|+
name|j
operator|*
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Read the CAM registers */
if|if
condition|(
name|bxe_is_wreg_in_chip
argument_list|(
name|sc
argument_list|,
name|wreg_addr_p
argument_list|)
operator|&&
name|IS_REG_IN_PRESET
argument_list|(
name|wreg_addr_p
operator|->
name|presets
argument_list|,
name|preset
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wreg_addr_p
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|p
operator|++
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|wreg_addr_p
operator|->
name|addr
operator|+
name|i
operator|*
literal|4
argument_list|)
expr_stmt|;
comment|/* In case of wreg_addr register, read additional                registers from read_regs array              */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|wreg_addr_p
operator|->
name|read_regs_count
condition|;
name|j
operator|++
control|)
block|{
name|addr
operator|=
operator|*
operator|(
name|wreg_addr_p
operator|->
name|read_regs
operator|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|addr
operator|+
name|j
operator|*
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Paged registers are supported in E2& E3 only */
if|if
condition|(
name|CHIP_IS_E2
argument_list|(
name|sc
argument_list|)
operator|||
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* Read "paged" registers */
name|bxe_read_pages_regs
argument_list|(
name|sc
argument_list|,
name|p
argument_list|,
name|preset
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|bxe_grc_dump
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rval
init|=
literal|0
decl_stmt|;
name|uint32_t
name|preset_idx
decl_stmt|;
name|uint8_t
modifier|*
name|buf
decl_stmt|;
name|uint32_t
name|size
decl_stmt|;
name|struct
name|dump_header
modifier|*
name|d_hdr
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|reg_val
decl_stmt|;
name|uint32_t
name|reg_addr
decl_stmt|;
name|uint32_t
name|cmd_offset
decl_stmt|;
name|struct
name|ecore_ilt
modifier|*
name|ilt
init|=
name|SC_ILT
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|struct
name|bxe_fastpath
modifier|*
name|fp
decl_stmt|;
name|struct
name|ilt_client_info
modifier|*
name|ilt_cli
decl_stmt|;
name|int
name|grc_dump_size
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|grcdump_done
operator|||
name|sc
operator|->
name|grcdump_started
condition|)
return|return
operator|(
name|rval
operator|)
return|;
name|sc
operator|->
name|grcdump_started
operator|=
literal|1
expr_stmt|;
name|BLOGI
argument_list|(
name|sc
argument_list|,
literal|"Started collecting grcdump\n"
argument_list|)
expr_stmt|;
name|grc_dump_size
operator|=
operator|(
name|bxe_get_total_regs_len32
argument_list|(
name|sc
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|dump_header
argument_list|)
expr_stmt|;
name|sc
operator|->
name|grc_dump
operator|=
name|malloc
argument_list|(
name|grc_dump_size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|grc_dump
operator|==
name|NULL
condition|)
block|{
name|BLOGW
argument_list|(
name|sc
argument_list|,
literal|"Unable to allocate memory for grcdump collection\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* Disable parity attentions as long as following dump may      * cause false alarms by reading never written registers. We      * will re-enable parity attentions right after the dump.      */
comment|/* Disable parity on path 0 */
name|bxe_pretend_func
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ecore_disable_blocks_parity
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Disable parity on path 1 */
name|bxe_pretend_func
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ecore_disable_blocks_parity
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Return to current function */
name|bxe_pretend_func
argument_list|(
name|sc
argument_list|,
name|SC_ABS_FUNC
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|=
name|sc
operator|->
name|grc_dump
expr_stmt|;
name|d_hdr
operator|=
name|sc
operator|->
name|grc_dump
expr_stmt|;
name|d_hdr
operator|->
name|header_size
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|dump_header
argument_list|)
operator|>>
literal|2
operator|)
operator|-
literal|1
expr_stmt|;
name|d_hdr
operator|->
name|version
operator|=
name|BNX2X_DUMP_VERSION
expr_stmt|;
name|d_hdr
operator|->
name|preset
operator|=
name|DUMP_ALL_PRESETS
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|d_hdr
operator|->
name|dump_meta_data
operator|=
name|DUMP_CHIP_E1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|d_hdr
operator|->
name|dump_meta_data
operator|=
name|DUMP_CHIP_E1H
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CHIP_IS_E2
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|d_hdr
operator|->
name|dump_meta_data
operator|=
name|DUMP_CHIP_E2
operator||
operator|(
name|BXE_PATH
argument_list|(
name|sc
argument_list|)
condition|?
name|DUMP_PATH_1
else|:
name|DUMP_PATH_0
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CHIP_IS_E3A0
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|d_hdr
operator|->
name|dump_meta_data
operator|=
name|DUMP_CHIP_E3A0
operator||
operator|(
name|BXE_PATH
argument_list|(
name|sc
argument_list|)
condition|?
name|DUMP_PATH_1
else|:
name|DUMP_PATH_0
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CHIP_IS_E3B0
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|d_hdr
operator|->
name|dump_meta_data
operator|=
name|DUMP_CHIP_E3B0
operator||
operator|(
name|BXE_PATH
argument_list|(
name|sc
argument_list|)
condition|?
name|DUMP_PATH_1
else|:
name|DUMP_PATH_0
operator|)
expr_stmt|;
block|}
name|buf
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|dump_header
argument_list|)
expr_stmt|;
for|for
control|(
name|preset_idx
operator|=
literal|1
init|;
name|preset_idx
operator|<=
name|DUMP_MAX_PRESETS
condition|;
name|preset_idx
operator|++
control|)
block|{
comment|/* Skip presets with IOR */
if|if
condition|(
operator|(
name|preset_idx
operator|==
literal|2
operator|)
operator|||
operator|(
name|preset_idx
operator|==
literal|5
operator|)
operator|||
operator|(
name|preset_idx
operator|==
literal|8
operator|)
operator|||
operator|(
name|preset_idx
operator|==
literal|11
operator|)
condition|)
continue|continue;
name|rval
operator|=
name|bxe_get_preset_regs
argument_list|(
name|sc
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
name|buf
argument_list|,
name|preset_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
break|break;
name|size
operator|=
name|bxe_get_preset_regs_len
argument_list|(
name|sc
argument_list|,
name|preset_idx
argument_list|)
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
name|buf
operator|+=
name|size
expr_stmt|;
block|}
name|bxe_pretend_func
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ecore_clear_blocks_parity
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ecore_enable_blocks_parity
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bxe_pretend_func
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ecore_clear_blocks_parity
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ecore_enable_blocks_parity
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Return to current function */
name|bxe_pretend_func
argument_list|(
name|sc
argument_list|,
name|SC_ABS_FUNC
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|state
operator|==
name|BXE_STATE_OPEN
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|fw_stats_req
operator|!=
name|NULL
condition|)
block|{
name|BLOGI
argument_list|(
name|sc
argument_list|,
literal|"fw stats start_paddr %#jx end_paddr %#jx vaddr %p size 0x%x\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|fw_stats_req_mapping
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|fw_stats_data_mapping
argument_list|,
name|sc
operator|->
name|fw_stats_req
argument_list|,
operator|(
name|sc
operator|->
name|fw_stats_req_size
operator|+
name|sc
operator|->
name|fw_stats_data_size
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|def_sb
operator|!=
name|NULL
condition|)
block|{
name|BLOGI
argument_list|(
name|sc
argument_list|,
literal|"def_status_block paddr %p vaddr %p size 0x%zx\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
operator|->
name|def_sb_dma
operator|.
name|paddr
argument_list|,
name|sc
operator|->
name|def_sb
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|host_sp_status_block
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|eq_dma
operator|.
name|vaddr
operator|!=
name|NULL
condition|)
block|{
name|BLOGI
argument_list|(
name|sc
argument_list|,
literal|"event_queue paddr %#jx vaddr %p size 0x%x\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|eq_dma
operator|.
name|paddr
argument_list|,
name|sc
operator|->
name|eq_dma
operator|.
name|vaddr
argument_list|,
name|BCM_PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sp_dma
operator|.
name|vaddr
operator|!=
name|NULL
condition|)
block|{
name|BLOGI
argument_list|(
name|sc
argument_list|,
literal|"slow path paddr %#jx vaddr %p size 0x%zx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|sp_dma
operator|.
name|paddr
argument_list|,
name|sc
operator|->
name|sp_dma
operator|.
name|vaddr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bxe_slowpath
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|spq_dma
operator|.
name|vaddr
operator|!=
name|NULL
condition|)
block|{
name|BLOGI
argument_list|(
name|sc
argument_list|,
literal|"slow path queue paddr %#jx vaddr %p size 0x%x\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|spq_dma
operator|.
name|paddr
argument_list|,
name|sc
operator|->
name|spq_dma
operator|.
name|vaddr
argument_list|,
name|BCM_PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|gz_buf_dma
operator|.
name|vaddr
operator|!=
name|NULL
condition|)
block|{
name|BLOGI
argument_list|(
name|sc
argument_list|,
literal|"fw_buf paddr %#jx vaddr %p size 0x%x\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sc
operator|->
name|gz_buf_dma
operator|.
name|paddr
argument_list|,
name|sc
operator|->
name|gz_buf_dma
operator|.
name|vaddr
argument_list|,
name|FW_BUF_SIZE
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_queues
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|&
name|sc
operator|->
name|fp
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|sb_dma
operator|.
name|vaddr
operator|!=
name|NULL
operator|&&
name|fp
operator|->
name|tx_dma
operator|.
name|vaddr
operator|!=
name|NULL
operator|&&
name|fp
operator|->
name|rx_dma
operator|.
name|vaddr
operator|!=
name|NULL
operator|&&
name|fp
operator|->
name|rcq_dma
operator|.
name|vaddr
operator|!=
name|NULL
operator|&&
name|fp
operator|->
name|rx_sge_dma
operator|.
name|vaddr
operator|!=
name|NULL
condition|)
block|{
name|BLOGI
argument_list|(
name|sc
argument_list|,
literal|"FP status block fp %d paddr %#jx vaddr %p size 0x%zx\n"
argument_list|,
name|i
argument_list|,
operator|(
name|uintmax_t
operator|)
name|fp
operator|->
name|sb_dma
operator|.
name|paddr
argument_list|,
name|fp
operator|->
name|sb_dma
operator|.
name|vaddr
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|bxe_host_hc_status_block
argument_list|)
argument_list|)
expr_stmt|;
name|BLOGI
argument_list|(
name|sc
argument_list|,
literal|"TX BD CHAIN fp %d paddr %#jx vaddr %p size 0x%x\n"
argument_list|,
name|i
argument_list|,
operator|(
name|uintmax_t
operator|)
name|fp
operator|->
name|tx_dma
operator|.
name|paddr
argument_list|,
name|fp
operator|->
name|tx_dma
operator|.
name|vaddr
argument_list|,
operator|(
name|BCM_PAGE_SIZE
operator|*
name|TX_BD_NUM_PAGES
operator|)
argument_list|)
expr_stmt|;
name|BLOGI
argument_list|(
name|sc
argument_list|,
literal|"RX BD CHAIN fp %d paddr %#jx vaddr %p size 0x%x\n"
argument_list|,
name|i
argument_list|,
operator|(
name|uintmax_t
operator|)
name|fp
operator|->
name|rx_dma
operator|.
name|paddr
argument_list|,
name|fp
operator|->
name|rx_dma
operator|.
name|vaddr
argument_list|,
operator|(
name|BCM_PAGE_SIZE
operator|*
name|RX_BD_NUM_PAGES
operator|)
argument_list|)
expr_stmt|;
name|BLOGI
argument_list|(
name|sc
argument_list|,
literal|"RX RCQ CHAIN fp %d paddr %#jx vaddr %p size 0x%zx\n"
argument_list|,
name|i
argument_list|,
operator|(
name|uintmax_t
operator|)
name|fp
operator|->
name|rcq_dma
operator|.
name|paddr
argument_list|,
name|fp
operator|->
name|rcq_dma
operator|.
name|vaddr
argument_list|,
operator|(
name|BCM_PAGE_SIZE
operator|*
name|RCQ_NUM_PAGES
operator|)
argument_list|)
expr_stmt|;
name|BLOGI
argument_list|(
name|sc
argument_list|,
literal|"RX SGE CHAIN fp %d paddr %#jx vaddr %p size 0x%x\n"
argument_list|,
name|i
argument_list|,
operator|(
name|uintmax_t
operator|)
name|fp
operator|->
name|rx_sge_dma
operator|.
name|paddr
argument_list|,
name|fp
operator|->
name|rx_sge_dma
operator|.
name|vaddr
argument_list|,
operator|(
name|BCM_PAGE_SIZE
operator|*
name|RX_SGE_NUM_PAGES
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ilt
operator|!=
name|NULL
condition|)
block|{
name|ilt_cli
operator|=
operator|&
name|ilt
operator|->
name|clients
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|ilt
operator|->
name|lines
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
name|ilt_cli
operator|->
name|start
init|;
name|i
operator|<=
name|ilt_cli
operator|->
name|end
condition|;
name|i
operator|++
control|)
block|{
name|BLOGI
argument_list|(
name|sc
argument_list|,
literal|"ECORE_ILT paddr %#jx vaddr %p size 0x%x\n"
argument_list|,
call|(
name|uintmax_t
call|)
argument_list|(
operator|(
operator|(
expr|struct
name|bxe_dma
operator|*
operator|)
operator|(
operator|(
operator|&
name|ilt
operator|->
name|lines
index|[
name|i
index|]
operator|)
operator|->
name|page
operator|)
operator|)
operator|->
name|paddr
argument_list|)
argument_list|,
operator|(
operator|(
expr|struct
name|bxe_dma
operator|*
operator|)
operator|(
operator|(
operator|&
name|ilt
operator|->
name|lines
index|[
name|i
index|]
operator|)
operator|->
name|page
operator|)
operator|)
operator|->
name|vaddr
argument_list|,
name|BCM_PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|cmd_offset
operator|=
name|DMAE_REG_CMD_MEM
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|224
condition|;
name|i
operator|++
control|)
block|{
name|reg_addr
operator|=
operator|(
name|cmd_offset
operator|+
operator|(
name|i
operator|*
literal|4
operator|)
operator|)
expr_stmt|;
name|reg_val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|reg_addr
argument_list|)
expr_stmt|;
name|BLOGI
argument_list|(
name|sc
argument_list|,
literal|"DMAE_REG_CMD_MEM i=%d reg_addr 0x%x reg_val 0x%08x\n"
argument_list|,
name|i
argument_list|,
name|reg_addr
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
block|}
block|}
name|BLOGI
argument_list|(
name|sc
argument_list|,
literal|"Collection of grcdump done\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|grcdump_done
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_add_cdev
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|eeprom
operator|=
name|malloc
argument_list|(
name|BXE_EEPROM_MAX_DATA_LEN
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|eeprom
operator|==
name|NULL
condition|)
block|{
name|BLOGW
argument_list|(
name|sc
argument_list|,
literal|"Unable to alloc for eeprom size buffer\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|sc
operator|->
name|ioctl_dev
operator|=
name|make_dev
argument_list|(
operator|&
name|bxe_cdevsw
argument_list|,
name|sc
operator|->
name|ifp
operator|->
name|if_dunit
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"%s"
argument_list|,
name|if_name
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ioctl_dev
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sc
operator|->
name|eeprom
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|eeprom
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|sc
operator|->
name|ioctl_dev
operator|->
name|si_drv1
operator|=
name|sc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bxe_del_cdev
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|ioctl_dev
operator|!=
name|NULL
condition|)
name|destroy_dev
argument_list|(
name|sc
operator|->
name|ioctl_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|eeprom
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sc
operator|->
name|eeprom
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|eeprom
operator|=
name|NULL
expr_stmt|;
block|}
name|sc
operator|->
name|ioctl_dev
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|bool
name|bxe_is_nvram_accessible
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
operator|(
name|if_getdrvflags
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_wr_eeprom
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint32_t
name|len
parameter_list|)
block|{
name|int
name|rval
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|bxe_is_nvram_accessible
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|BLOGW
argument_list|(
name|sc
argument_list|,
literal|"Cannot access eeprom when interface is down\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|EAGAIN
operator|)
return|;
block|}
name|rval
operator|=
name|bxe_nvram_write
argument_list|(
name|sc
argument_list|,
name|offset
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_rd_eeprom
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint32_t
name|len
parameter_list|)
block|{
name|int
name|rval
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|bxe_is_nvram_accessible
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|BLOGW
argument_list|(
name|sc
argument_list|,
literal|"Cannot access eeprom when interface is down\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|EAGAIN
operator|)
return|;
block|}
name|rval
operator|=
name|bxe_nvram_read
argument_list|(
name|sc
argument_list|,
name|offset
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_eeprom_rd_wr
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|bxe_eeprom_t
modifier|*
name|eeprom
parameter_list|)
block|{
name|int
name|rval
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|eeprom
operator|->
name|eeprom_cmd
condition|)
block|{
case|case
name|BXE_EEPROM_CMD_SET_EEPROM
case|:
name|rval
operator|=
name|copyin
argument_list|(
name|eeprom
operator|->
name|eeprom_data
argument_list|,
name|sc
operator|->
name|eeprom
argument_list|,
name|eeprom
operator|->
name|eeprom_data_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
break|break;
name|rval
operator|=
name|bxe_wr_eeprom
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|eeprom
argument_list|,
name|eeprom
operator|->
name|eeprom_offset
argument_list|,
name|eeprom
operator|->
name|eeprom_data_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|BXE_EEPROM_CMD_GET_EEPROM
case|:
name|rval
operator|=
name|bxe_rd_eeprom
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|eeprom
argument_list|,
name|eeprom
operator|->
name|eeprom_offset
argument_list|,
name|eeprom
operator|->
name|eeprom_data_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
block|{
break|break;
block|}
name|rval
operator|=
name|copyout
argument_list|(
name|sc
operator|->
name|eeprom
argument_list|,
name|eeprom
operator|->
name|eeprom_data
argument_list|,
name|eeprom
operator|->
name|eeprom_data_len
argument_list|)
expr_stmt|;
break|break;
default|default:
name|rval
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rval
condition|)
block|{
name|BLOGW
argument_list|(
name|sc
argument_list|,
literal|"ioctl cmd %d  failed rval %d\n"
argument_list|,
name|eeprom
operator|->
name|eeprom_cmd
argument_list|,
name|rval
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_get_settings
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|bxe_dev_setting_t
modifier|*
name|dev_p
parameter_list|)
block|{
name|uint32_t
name|ext_phy_config
decl_stmt|;
name|int
name|port
init|=
name|SC_PORT
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|int
name|cfg_idx
init|=
name|bxe_get_link_cfg_idx
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|dev_p
operator|->
name|supported
operator|=
name|sc
operator|->
name|port
operator|.
name|supported
index|[
name|cfg_idx
index|]
operator||
operator|(
name|sc
operator|->
name|port
operator|.
name|supported
index|[
name|cfg_idx
operator|^
literal|1
index|]
operator|&
operator|(
name|ELINK_SUPPORTED_TP
operator||
name|ELINK_SUPPORTED_FIBRE
operator|)
operator|)
expr_stmt|;
name|dev_p
operator|->
name|advertising
operator|=
name|sc
operator|->
name|port
operator|.
name|advertising
index|[
name|cfg_idx
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|link_params
operator|.
name|phy
index|[
name|bxe_get_cur_phy_idx
argument_list|(
name|sc
argument_list|)
index|]
operator|.
name|media_type
operator|==
name|ELINK_ETH_PHY_SFP_1G_FIBER
condition|)
block|{
name|dev_p
operator|->
name|supported
operator|=
operator|~
operator|(
name|ELINK_SUPPORTED_10000baseT_Full
operator|)
expr_stmt|;
name|dev_p
operator|->
name|advertising
operator|&=
operator|~
operator|(
name|ADVERTISED_10000baseT_Full
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|state
operator|==
name|BXE_STATE_OPEN
operator|)
operator|&&
name|sc
operator|->
name|link_vars
operator|.
name|link_up
operator|&&
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|BXE_MF_FUNC_DIS
operator|)
condition|)
block|{
name|dev_p
operator|->
name|duplex
operator|=
name|sc
operator|->
name|link_vars
operator|.
name|duplex
expr_stmt|;
if|if
condition|(
name|IS_MF
argument_list|(
name|sc
argument_list|)
operator|&&
operator|!
name|BXE_NOMCP
argument_list|(
name|sc
argument_list|)
condition|)
name|dev_p
operator|->
name|speed
operator|=
name|bxe_get_mf_speed
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|dev_p
operator|->
name|speed
operator|=
name|sc
operator|->
name|link_vars
operator|.
name|line_speed
expr_stmt|;
block|}
else|else
block|{
name|dev_p
operator|->
name|duplex
operator|=
name|DUPLEX_UNKNOWN
expr_stmt|;
name|dev_p
operator|->
name|speed
operator|=
name|SPEED_UNKNOWN
expr_stmt|;
block|}
name|dev_p
operator|->
name|port
operator|=
name|bxe_media_detect
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ext_phy_config
operator|=
name|SHMEM_RD
argument_list|(
name|sc
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|port
index|]
operator|.
name|external_phy_config
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ext_phy_config
operator|&
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_MASK
operator|)
operator|==
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT
condition|)
name|dev_p
operator|->
name|phy_address
operator|=
name|sc
operator|->
name|port
operator|.
name|phy_addr
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|ext_phy_config
operator|&
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_MASK
operator|)
operator|!=
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_FAILURE
operator|)
operator|&&
operator|(
operator|(
name|ext_phy_config
operator|&
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_MASK
operator|)
operator|!=
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_NOT_CONN
operator|)
condition|)
name|dev_p
operator|->
name|phy_address
operator|=
name|ELINK_XGXS_EXT_PHY_ADDR
argument_list|(
name|ext_phy_config
argument_list|)
expr_stmt|;
else|else
name|dev_p
operator|->
name|phy_address
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|link_params
operator|.
name|req_line_speed
index|[
name|cfg_idx
index|]
operator|==
name|ELINK_SPEED_AUTO_NEG
condition|)
name|dev_p
operator|->
name|autoneg
operator|=
name|AUTONEG_ENABLE
expr_stmt|;
else|else
name|dev_p
operator|->
name|autoneg
operator|=
name|AUTONEG_DISABLE
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bxe_eioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|rval
init|=
literal|0
decl_stmt|;
name|device_t
name|pci_dev
decl_stmt|;
name|bxe_grcdump_t
modifier|*
name|dump
init|=
name|NULL
decl_stmt|;
name|int
name|grc_dump_size
decl_stmt|;
name|bxe_drvinfo_t
modifier|*
name|drv_infop
init|=
name|NULL
decl_stmt|;
name|bxe_dev_setting_t
modifier|*
name|dev_p
decl_stmt|;
name|bxe_dev_setting_t
name|dev_set
decl_stmt|;
name|bxe_get_regs_t
modifier|*
name|reg_p
decl_stmt|;
name|bxe_reg_rdw_t
modifier|*
name|reg_rdw_p
decl_stmt|;
name|bxe_pcicfg_rdw_t
modifier|*
name|cfg_rdw_p
decl_stmt|;
name|bxe_perm_mac_addr_t
modifier|*
name|mac_addr_p
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|=
operator|(
expr|struct
name|bxe_softc
operator|*
operator|)
name|dev
operator|->
name|si_drv1
operator|)
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
name|pci_dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|dump
operator|=
operator|(
name|bxe_grcdump_t
operator|*
operator|)
name|data
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|BXE_GRC_DUMP_SIZE
case|:
name|dump
operator|->
name|pci_func
operator|=
name|sc
operator|->
name|pcie_func
expr_stmt|;
name|dump
operator|->
name|grcdump_size
operator|=
operator|(
name|bxe_get_total_regs_len32
argument_list|(
name|sc
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|dump_header
argument_list|)
expr_stmt|;
break|break;
case|case
name|BXE_GRC_DUMP
case|:
name|grc_dump_size
operator|=
operator|(
name|bxe_get_total_regs_len32
argument_list|(
name|sc
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|dump_header
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|sc
operator|->
name|trigger_grcdump
operator|)
operator|||
operator|(
name|dump
operator|->
name|grcdump
operator|==
name|NULL
operator|)
operator|||
operator|(
name|dump
operator|->
name|grcdump_size
operator|<
name|grc_dump_size
operator|)
condition|)
block|{
name|rval
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|trigger_grcdump
operator|)
operator|&&
operator|(
operator|!
name|sc
operator|->
name|grcdump_done
operator|)
operator|&&
operator|(
operator|!
name|sc
operator|->
name|grcdump_started
operator|)
condition|)
block|{
name|rval
operator|=
name|bxe_grc_dump
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|!
name|rval
operator|)
operator|&&
operator|(
name|sc
operator|->
name|grcdump_done
operator|)
operator|&&
operator|(
name|sc
operator|->
name|grcdump_started
operator|)
operator|&&
operator|(
name|sc
operator|->
name|grc_dump
operator|!=
name|NULL
operator|)
condition|)
block|{
name|dump
operator|->
name|grcdump_dwords
operator|=
name|grc_dump_size
operator|>>
literal|2
expr_stmt|;
name|rval
operator|=
name|copyout
argument_list|(
name|sc
operator|->
name|grc_dump
argument_list|,
name|dump
operator|->
name|grcdump
argument_list|,
name|grc_dump_size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|grc_dump
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|grc_dump
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|grcdump_started
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|grcdump_done
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|BXE_DRV_INFO
case|:
name|drv_infop
operator|=
operator|(
name|bxe_drvinfo_t
operator|*
operator|)
name|data
expr_stmt|;
name|snprintf
argument_list|(
name|drv_infop
operator|->
name|drv_name
argument_list|,
name|BXE_DRV_NAME_LENGTH
argument_list|,
literal|"%s"
argument_list|,
literal|"bxe"
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|drv_infop
operator|->
name|drv_version
argument_list|,
name|BXE_DRV_VERSION_LENGTH
argument_list|,
literal|"v:%s"
argument_list|,
name|BXE_DRIVER_VERSION
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|drv_infop
operator|->
name|mfw_version
argument_list|,
name|BXE_MFW_VERSION_LENGTH
argument_list|,
literal|"%s"
argument_list|,
name|sc
operator|->
name|devinfo
operator|.
name|bc_ver_str
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|drv_infop
operator|->
name|stormfw_version
argument_list|,
name|BXE_STORMFW_VERSION_LENGTH
argument_list|,
literal|"%s"
argument_list|,
name|sc
operator|->
name|fw_ver_str
argument_list|)
expr_stmt|;
name|drv_infop
operator|->
name|eeprom_dump_len
operator|=
name|sc
operator|->
name|devinfo
operator|.
name|flash_size
expr_stmt|;
name|drv_infop
operator|->
name|reg_dump_len
operator|=
operator|(
name|bxe_get_total_regs_len32
argument_list|(
name|sc
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|dump_header
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|drv_infop
operator|->
name|bus_info
argument_list|,
name|BXE_BUS_INFO_LENGTH
argument_list|,
literal|"%d:%d:%d"
argument_list|,
name|sc
operator|->
name|pcie_bus
argument_list|,
name|sc
operator|->
name|pcie_device
argument_list|,
name|sc
operator|->
name|pcie_func
argument_list|)
expr_stmt|;
break|break;
case|case
name|BXE_DEV_SETTING
case|:
name|dev_p
operator|=
operator|(
name|bxe_dev_setting_t
operator|*
operator|)
name|data
expr_stmt|;
name|bxe_get_settings
argument_list|(
name|sc
argument_list|,
operator|&
name|dev_set
argument_list|)
expr_stmt|;
name|dev_p
operator|->
name|supported
operator|=
name|dev_set
operator|.
name|supported
expr_stmt|;
name|dev_p
operator|->
name|advertising
operator|=
name|dev_set
operator|.
name|advertising
expr_stmt|;
name|dev_p
operator|->
name|speed
operator|=
name|dev_set
operator|.
name|speed
expr_stmt|;
name|dev_p
operator|->
name|duplex
operator|=
name|dev_set
operator|.
name|duplex
expr_stmt|;
name|dev_p
operator|->
name|port
operator|=
name|dev_set
operator|.
name|port
expr_stmt|;
name|dev_p
operator|->
name|phy_address
operator|=
name|dev_set
operator|.
name|phy_address
expr_stmt|;
name|dev_p
operator|->
name|autoneg
operator|=
name|dev_set
operator|.
name|autoneg
expr_stmt|;
break|break;
case|case
name|BXE_GET_REGS
case|:
name|reg_p
operator|=
operator|(
name|bxe_get_regs_t
operator|*
operator|)
name|data
expr_stmt|;
name|grc_dump_size
operator|=
name|reg_p
operator|->
name|reg_buf_len
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|sc
operator|->
name|grcdump_done
operator|)
operator|&&
operator|(
operator|!
name|sc
operator|->
name|grcdump_started
operator|)
condition|)
block|{
name|bxe_grc_dump
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|grcdump_done
operator|)
operator|&&
operator|(
name|sc
operator|->
name|grcdump_started
operator|)
operator|&&
operator|(
name|sc
operator|->
name|grc_dump
operator|!=
name|NULL
operator|)
condition|)
block|{
name|rval
operator|=
name|copyout
argument_list|(
name|sc
operator|->
name|grc_dump
argument_list|,
name|reg_p
operator|->
name|reg_buf
argument_list|,
name|grc_dump_size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|grc_dump
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|grc_dump
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|grcdump_started
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|grcdump_done
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|BXE_RDW_REG
case|:
name|reg_rdw_p
operator|=
operator|(
name|bxe_reg_rdw_t
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
operator|(
name|reg_rdw_p
operator|->
name|reg_cmd
operator|==
name|BXE_READ_REG_CMD
operator|)
operator|&&
operator|(
name|reg_rdw_p
operator|->
name|reg_access_type
operator|==
name|BXE_REG_ACCESS_DIRECT
operator|)
condition|)
name|reg_rdw_p
operator|->
name|reg_val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|reg_rdw_p
operator|->
name|reg_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg_rdw_p
operator|->
name|reg_cmd
operator|==
name|BXE_WRITE_REG_CMD
operator|)
operator|&&
operator|(
name|reg_rdw_p
operator|->
name|reg_access_type
operator|==
name|BXE_REG_ACCESS_DIRECT
operator|)
condition|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|reg_rdw_p
operator|->
name|reg_id
argument_list|,
name|reg_rdw_p
operator|->
name|reg_val
argument_list|)
expr_stmt|;
break|break;
case|case
name|BXE_RDW_PCICFG
case|:
name|cfg_rdw_p
operator|=
operator|(
name|bxe_pcicfg_rdw_t
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|cfg_rdw_p
operator|->
name|cfg_cmd
operator|==
name|BXE_READ_PCICFG
condition|)
block|{
name|cfg_rdw_p
operator|->
name|cfg_val
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|cfg_rdw_p
operator|->
name|cfg_id
argument_list|,
name|cfg_rdw_p
operator|->
name|cfg_width
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cfg_rdw_p
operator|->
name|cfg_cmd
operator|==
name|BXE_WRITE_PCICFG
condition|)
block|{
name|pci_write_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|cfg_rdw_p
operator|->
name|cfg_id
argument_list|,
name|cfg_rdw_p
operator|->
name|cfg_val
argument_list|,
name|cfg_rdw_p
operator|->
name|cfg_width
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BLOGW
argument_list|(
name|sc
argument_list|,
literal|"BXE_RDW_PCICFG ioctl wrong cmd passed\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BXE_MAC_ADDR
case|:
name|mac_addr_p
operator|=
operator|(
name|bxe_perm_mac_addr_t
operator|*
operator|)
name|data
expr_stmt|;
name|snprintf
argument_list|(
name|mac_addr_p
operator|->
name|mac_addr_str
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|mac_addr_str
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|sc
operator|->
name|mac_addr_str
argument_list|)
expr_stmt|;
break|break;
case|case
name|BXE_EEPROM
case|:
name|rval
operator|=
name|bxe_eeprom_rd_wr
argument_list|(
name|sc
argument_list|,
operator|(
name|bxe_eeprom_t
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

end_unit

