begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2007-2014 QLogic Corporation. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS'  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|ECORE_INIT_H
end_ifndef

begin_define
define|#
directive|define
name|ECORE_INIT_H
end_define

begin_comment
comment|/* Init operation types and structures */
end_comment

begin_enum
enum|enum
block|{
name|OP_RD
init|=
literal|0x1
block|,
comment|/* read a single register */
name|OP_WR
block|,
comment|/* write a single register */
name|OP_SW
block|,
comment|/* copy a string to the device */
name|OP_ZR
block|,
comment|/* clear memory */
name|OP_ZP
block|,
comment|/* unzip then copy with DMAE */
name|OP_WR_64
block|,
comment|/* write 64 bit pattern */
name|OP_WB
block|,
comment|/* copy a string using DMAE */
ifndef|#
directive|ifndef
name|FW_ZIP_SUPPORT
name|OP_FW
block|,
comment|/* copy an array from fw data (only used with unzipped FW) */
endif|#
directive|endif
name|OP_WB_ZR
block|,
comment|/* Clear a string using DMAE or indirect-wr */
name|OP_IF_MODE_OR
block|,
comment|/* Skip the following ops if all init modes don't match */
name|OP_IF_MODE_AND
block|,
comment|/* Skip the following ops if any init modes don't match */
name|OP_IF_PHASE
block|,
name|OP_RT
block|,
name|OP_DELAY
block|,
name|OP_VERIFY
block|,
name|OP_MAX
block|}
enum|;
end_enum

begin_enum
enum|enum
block|{
name|STAGE_START
block|,
name|STAGE_END
block|, }
enum|;
end_enum

begin_comment
comment|/* Returns the index of start or end of a specific block stage in ops array*/
end_comment

begin_define
define|#
directive|define
name|BLOCK_OPS_IDX
parameter_list|(
name|block
parameter_list|,
name|stage
parameter_list|,
name|end
parameter_list|)
define|\
value|(2*(((block)*NUM_OF_INIT_PHASES) + (stage)) + (end))
end_define

begin_comment
comment|/* structs for the various opcodes */
end_comment

begin_struct
struct|struct
name|raw_op
block|{
name|uint32_t
name|op
range|:
literal|8
decl_stmt|;
name|uint32_t
name|offset
range|:
literal|24
decl_stmt|;
name|uint32_t
name|raw_data
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|op_read
block|{
name|uint32_t
name|op
range|:
literal|8
decl_stmt|;
name|uint32_t
name|offset
range|:
literal|24
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|op_write
block|{
name|uint32_t
name|op
range|:
literal|8
decl_stmt|;
name|uint32_t
name|offset
range|:
literal|24
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|op_arr_write
block|{
name|uint32_t
name|op
range|:
literal|8
decl_stmt|;
name|uint32_t
name|offset
range|:
literal|24
decl_stmt|;
ifdef|#
directive|ifdef
name|__BIG_ENDIAN
name|uint16_t
name|data_len
decl_stmt|;
name|uint16_t
name|data_off
decl_stmt|;
else|#
directive|else
comment|/* __LITTLE_ENDIAN */
name|uint16_t
name|data_off
decl_stmt|;
name|uint16_t
name|data_len
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_struct
struct|struct
name|op_zero
block|{
name|uint32_t
name|op
range|:
literal|8
decl_stmt|;
name|uint32_t
name|offset
range|:
literal|24
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|op_if_mode
block|{
name|uint32_t
name|op
range|:
literal|8
decl_stmt|;
name|uint32_t
name|cmd_offset
range|:
literal|24
decl_stmt|;
name|uint32_t
name|mode_bit_map
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|op_if_phase
block|{
name|uint32_t
name|op
range|:
literal|8
decl_stmt|;
name|uint32_t
name|cmd_offset
range|:
literal|24
decl_stmt|;
name|uint32_t
name|phase_bit_map
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|op_delay
block|{
name|uint32_t
name|op
range|:
literal|8
decl_stmt|;
name|uint32_t
name|reserved
range|:
literal|24
decl_stmt|;
name|uint32_t
name|delay
decl_stmt|;
block|}
struct|;
end_struct

begin_union
union|union
name|init_op
block|{
name|struct
name|op_read
name|read
decl_stmt|;
name|struct
name|op_write
name|write
decl_stmt|;
name|struct
name|op_arr_write
name|arr_wr
decl_stmt|;
name|struct
name|op_zero
name|zero
decl_stmt|;
name|struct
name|raw_op
name|raw
decl_stmt|;
name|struct
name|op_if_mode
name|if_mode
decl_stmt|;
name|struct
name|op_if_phase
name|if_phase
decl_stmt|;
name|struct
name|op_delay
name|delay
decl_stmt|;
block|}
union|;
end_union

begin_comment
comment|/* Init Phases */
end_comment

begin_enum
enum|enum
block|{
name|PHASE_COMMON
block|,
name|PHASE_PORT0
block|,
name|PHASE_PORT1
block|,
name|PHASE_PF0
block|,
name|PHASE_PF1
block|,
name|PHASE_PF2
block|,
name|PHASE_PF3
block|,
name|PHASE_PF4
block|,
name|PHASE_PF5
block|,
name|PHASE_PF6
block|,
name|PHASE_PF7
block|,
name|NUM_OF_INIT_PHASES
block|}
enum|;
end_enum

begin_comment
comment|/* Init Modes */
end_comment

begin_enum
enum|enum
block|{
name|MODE_ASIC
init|=
literal|0x00000001
block|,
name|MODE_FPGA
init|=
literal|0x00000002
block|,
name|MODE_EMUL
init|=
literal|0x00000004
block|,
name|MODE_E2
init|=
literal|0x00000008
block|,
name|MODE_E3
init|=
literal|0x00000010
block|,
name|MODE_PORT2
init|=
literal|0x00000020
block|,
name|MODE_PORT4
init|=
literal|0x00000040
block|,
name|MODE_SF
init|=
literal|0x00000080
block|,
name|MODE_MF
init|=
literal|0x00000100
block|,
name|MODE_MF_SD
init|=
literal|0x00000200
block|,
name|MODE_MF_SI
init|=
literal|0x00000400
block|,
name|MODE_MF_AFEX
init|=
literal|0x00000800
block|,
name|MODE_E3_A0
init|=
literal|0x00001000
block|,
name|MODE_E3_B0
init|=
literal|0x00002000
block|,
name|MODE_COS3
init|=
literal|0x00004000
block|,
name|MODE_COS6
init|=
literal|0x00008000
block|,
name|MODE_LITTLE_ENDIAN
init|=
literal|0x00010000
block|,
name|MODE_BIG_ENDIAN
init|=
literal|0x00020000
block|, }
enum|;
end_enum

begin_comment
comment|/* Init Blocks */
end_comment

begin_enum
enum|enum
block|{
name|BLOCK_ATC
block|,
name|BLOCK_BRB1
block|,
name|BLOCK_CCM
block|,
name|BLOCK_CDU
block|,
name|BLOCK_CFC
block|,
name|BLOCK_CSDM
block|,
name|BLOCK_CSEM
block|,
name|BLOCK_DBG
block|,
name|BLOCK_DMAE
block|,
name|BLOCK_DORQ
block|,
name|BLOCK_HC
block|,
name|BLOCK_IGU
block|,
name|BLOCK_MISC
block|,
name|BLOCK_NIG
block|,
name|BLOCK_PBF
block|,
name|BLOCK_PGLUE_B
block|,
name|BLOCK_PRS
block|,
name|BLOCK_PXP2
block|,
name|BLOCK_PXP
block|,
name|BLOCK_QM
block|,
name|BLOCK_SRC
block|,
name|BLOCK_TCM
block|,
name|BLOCK_TM
block|,
name|BLOCK_TSDM
block|,
name|BLOCK_TSEM
block|,
name|BLOCK_UCM
block|,
name|BLOCK_UPB
block|,
name|BLOCK_USDM
block|,
name|BLOCK_USEM
block|,
name|BLOCK_XCM
block|,
name|BLOCK_XPB
block|,
name|BLOCK_XSDM
block|,
name|BLOCK_XSEM
block|,
name|BLOCK_MISC_AEU
block|,
name|NUM_OF_INIT_BLOCKS
block|}
enum|;
end_enum

begin_comment
comment|/* Vnics per mode */
end_comment

begin_define
define|#
directive|define
name|ECORE_PORT2_MODE_NUM_VNICS
value|4
end_define

begin_comment
comment|/* QM queue numbers */
end_comment

begin_define
define|#
directive|define
name|ECORE_ETH_Q
value|0
end_define

begin_define
define|#
directive|define
name|ECORE_TOE_Q
value|3
end_define

begin_define
define|#
directive|define
name|ECORE_TOE_ACK_Q
value|6
end_define

begin_define
define|#
directive|define
name|ECORE_ISCSI_Q
value|9
end_define

begin_define
define|#
directive|define
name|ECORE_ISCSI_ACK_Q
value|11
end_define

begin_define
define|#
directive|define
name|ECORE_FCOE_Q
value|10
end_define

begin_comment
comment|/* Vnics per mode */
end_comment

begin_define
define|#
directive|define
name|ECORE_PORT4_MODE_NUM_VNICS
value|2
end_define

begin_comment
comment|/* COS offset for port1 in E3 B0 4port mode */
end_comment

begin_define
define|#
directive|define
name|ECORE_E3B0_PORT1_COS_OFFSET
value|3
end_define

begin_comment
comment|/* QM Register addresses */
end_comment

begin_define
define|#
directive|define
name|ECORE_Q_VOQ_REG_ADDR
parameter_list|(
name|pf_q_num
parameter_list|)
define|\
value|(QM_REG_QVOQIDX_0 + 4 * (pf_q_num))
end_define

begin_define
define|#
directive|define
name|ECORE_VOQ_Q_REG_ADDR
parameter_list|(
name|cos
parameter_list|,
name|pf_q_num
parameter_list|)
define|\
value|(QM_REG_VOQQMASK_0_LSB + 4 * ((cos) * 2 + ((pf_q_num)>> 5)))
end_define

begin_define
define|#
directive|define
name|ECORE_Q_CMDQ_REG_ADDR
parameter_list|(
name|pf_q_num
parameter_list|)
define|\
value|(QM_REG_BYTECRDCMDQ_0 + 4 * ((pf_q_num)>> 4))
end_define

begin_comment
comment|/* extracts the QM queue number for the specified port and vnic */
end_comment

begin_define
define|#
directive|define
name|ECORE_PF_Q_NUM
parameter_list|(
name|q_num
parameter_list|,
name|port
parameter_list|,
name|vnic
parameter_list|)
define|\
value|((((port)<< 1) | (vnic)) * 16 + (q_num))
end_define

begin_comment
comment|/* Maps the specified queue to the specified COS */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ecore_map_q_cos
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|q_num
parameter_list|,
name|uint32_t
name|new_cos
parameter_list|)
block|{
comment|/* find current COS mapping */
name|uint32_t
name|curr_cos
init|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|QM_REG_QVOQIDX_0
operator|+
name|q_num
operator|*
literal|4
argument_list|)
decl_stmt|;
comment|/* check if queue->COS mapping has changed */
if|if
condition|(
name|curr_cos
operator|!=
name|new_cos
condition|)
block|{
name|uint32_t
name|num_vnics
init|=
name|ECORE_PORT2_MODE_NUM_VNICS
decl_stmt|;
name|uint32_t
name|reg_addr
decl_stmt|,
name|reg_bit_map
decl_stmt|,
name|vnic
decl_stmt|;
comment|/* update parameters for 4port mode */
if|if
condition|(
name|INIT_MODE_FLAGS
argument_list|(
name|sc
argument_list|)
operator|&
name|MODE_PORT4
condition|)
block|{
name|num_vnics
operator|=
name|ECORE_PORT4_MODE_NUM_VNICS
expr_stmt|;
if|if
condition|(
name|PORT_ID
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|curr_cos
operator|+=
name|ECORE_E3B0_PORT1_COS_OFFSET
expr_stmt|;
name|new_cos
operator|+=
name|ECORE_E3B0_PORT1_COS_OFFSET
expr_stmt|;
block|}
block|}
comment|/* change queue mapping for each VNIC */
for|for
control|(
name|vnic
operator|=
literal|0
init|;
name|vnic
operator|<
name|num_vnics
condition|;
name|vnic
operator|++
control|)
block|{
name|uint32_t
name|pf_q_num
init|=
name|ECORE_PF_Q_NUM
argument_list|(
name|q_num
argument_list|,
name|PORT_ID
argument_list|(
name|sc
argument_list|)
argument_list|,
name|vnic
argument_list|)
decl_stmt|;
name|uint32_t
name|q_bit_map
init|=
literal|1
operator|<<
operator|(
name|pf_q_num
operator|&
literal|0x1f
operator|)
decl_stmt|;
comment|/* overwrite queue->VOQ mapping */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|ECORE_Q_VOQ_REG_ADDR
argument_list|(
name|pf_q_num
argument_list|)
argument_list|,
name|new_cos
argument_list|)
expr_stmt|;
comment|/* clear queue bit from current COS bit map */
name|reg_addr
operator|=
name|ECORE_VOQ_Q_REG_ADDR
argument_list|(
name|curr_cos
argument_list|,
name|pf_q_num
argument_list|)
expr_stmt|;
name|reg_bit_map
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|reg_addr
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|reg_addr
argument_list|,
name|reg_bit_map
operator|&
operator|(
operator|~
name|q_bit_map
operator|)
argument_list|)
expr_stmt|;
comment|/* set queue bit in new COS bit map */
name|reg_addr
operator|=
name|ECORE_VOQ_Q_REG_ADDR
argument_list|(
name|new_cos
argument_list|,
name|pf_q_num
argument_list|)
expr_stmt|;
name|reg_bit_map
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|reg_addr
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|reg_addr
argument_list|,
name|reg_bit_map
operator||
name|q_bit_map
argument_list|)
expr_stmt|;
comment|/* set/clear queue bit in command-queue bit map 			(E2/E3A0 only, valid COS values are 0/1) */
if|if
condition|(
operator|!
operator|(
name|INIT_MODE_FLAGS
argument_list|(
name|sc
argument_list|)
operator|&
name|MODE_E3_B0
operator|)
condition|)
block|{
name|reg_addr
operator|=
name|ECORE_Q_CMDQ_REG_ADDR
argument_list|(
name|pf_q_num
argument_list|)
expr_stmt|;
name|reg_bit_map
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|reg_addr
argument_list|)
expr_stmt|;
name|q_bit_map
operator|=
literal|1
operator|<<
operator|(
literal|2
operator|*
operator|(
name|pf_q_num
operator|&
literal|0xf
operator|)
operator|)
expr_stmt|;
name|reg_bit_map
operator|=
name|new_cos
condition|?
operator|(
name|reg_bit_map
operator||
name|q_bit_map
operator|)
else|:
operator|(
name|reg_bit_map
operator|&
operator|(
operator|~
name|q_bit_map
operator|)
operator|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|reg_addr
argument_list|,
name|reg_bit_map
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Configures the QM according to the specified per-traffic-type COSes */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ecore_dcb_config_qm
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|enum
name|cos_mode
name|mode
parameter_list|,
name|struct
name|priority_cos
modifier|*
name|traffic_cos
parameter_list|)
block|{
name|ecore_map_q_cos
argument_list|(
name|sc
argument_list|,
name|ECORE_FCOE_Q
argument_list|,
name|traffic_cos
index|[
name|LLFC_TRAFFIC_TYPE_FCOE
index|]
operator|.
name|cos
argument_list|)
expr_stmt|;
name|ecore_map_q_cos
argument_list|(
name|sc
argument_list|,
name|ECORE_ISCSI_Q
argument_list|,
name|traffic_cos
index|[
name|LLFC_TRAFFIC_TYPE_ISCSI
index|]
operator|.
name|cos
argument_list|)
expr_stmt|;
name|ecore_map_q_cos
argument_list|(
name|sc
argument_list|,
name|ECORE_ISCSI_ACK_Q
argument_list|,
name|traffic_cos
index|[
name|LLFC_TRAFFIC_TYPE_ISCSI
index|]
operator|.
name|cos
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|STATIC_COS
condition|)
block|{
comment|/* required only in OVERRIDE_COS mode */
name|ecore_map_q_cos
argument_list|(
name|sc
argument_list|,
name|ECORE_ETH_Q
argument_list|,
name|traffic_cos
index|[
name|LLFC_TRAFFIC_TYPE_NW
index|]
operator|.
name|cos
argument_list|)
expr_stmt|;
name|ecore_map_q_cos
argument_list|(
name|sc
argument_list|,
name|ECORE_TOE_Q
argument_list|,
name|traffic_cos
index|[
name|LLFC_TRAFFIC_TYPE_NW
index|]
operator|.
name|cos
argument_list|)
expr_stmt|;
name|ecore_map_q_cos
argument_list|(
name|sc
argument_list|,
name|ECORE_TOE_ACK_Q
argument_list|,
name|traffic_cos
index|[
name|LLFC_TRAFFIC_TYPE_NW
index|]
operator|.
name|cos
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * congestion managment port init api description  * the api works as follows:  * the driver should pass the cmng_init_input struct, the port_init function  * will prepare the required internal ram structure which will be passed back  * to the driver (cmng_init) that will write it into the internal ram.  *  * IMPORTANT REMARKS:  * 1. the cmng_init struct does not represent the contiguous internal ram  *    structure. the driver should use the XSTORM_CMNG_PERPORT_VARS_OFFSET  *    offset in order to write the port sub struct and the  *    PFID_FROM_PORT_AND_VNIC offset for writing the vnic sub struct (in other  *    words - don't use memcpy!).  * 2. although the cmng_init struct is filled for the maximal vnic number  *    possible, the driver should only write the valid vnics into the internal  *    ram according to the appropriate port mode.  */
end_comment

begin_define
define|#
directive|define
name|BITS_TO_BYTES
parameter_list|(
name|x
parameter_list|)
value|((x)/8)
end_define

begin_comment
comment|/* CMNG constants, as derived from system spec calculations */
end_comment

begin_comment
comment|/* default MIN rate in case VNIC min rate is configured to zero- 100Mbps */
end_comment

begin_define
define|#
directive|define
name|DEF_MIN_RATE
value|100
end_define

begin_comment
comment|/* resolution of the rate shaping timer - 400 usec */
end_comment

begin_define
define|#
directive|define
name|RS_PERIODIC_TIMEOUT_USEC
value|400
end_define

begin_comment
comment|/*  *  number of bytes in single QM arbitration cycle -  *  coefficient for calculating the fairness timer  */
end_comment

begin_define
define|#
directive|define
name|QM_ARB_BYTES
value|160000
end_define

begin_comment
comment|/* resolution of Min algorithm 1:100 */
end_comment

begin_define
define|#
directive|define
name|MIN_RES
value|100
end_define

begin_comment
comment|/*  *  how many bytes above threshold for  *  the minimal credit of Min algorithm  */
end_comment

begin_define
define|#
directive|define
name|MIN_ABOVE_THRESH
value|32768
end_define

begin_comment
comment|/*  *  Fairness algorithm integration time coefficient -  *  for calculating the actual Tfair  */
end_comment

begin_define
define|#
directive|define
name|T_FAIR_COEF
value|((MIN_ABOVE_THRESH + QM_ARB_BYTES) * 8 * MIN_RES)
end_define

begin_comment
comment|/* Memory of fairness algorithm - 2 cycles */
end_comment

begin_define
define|#
directive|define
name|FAIR_MEM
value|2
end_define

begin_define
define|#
directive|define
name|SAFC_TIMEOUT_USEC
value|52
end_define

begin_define
define|#
directive|define
name|SDM_TICKS
value|4
end_define

begin_function
specifier|static
specifier|inline
name|void
name|ecore_init_max
parameter_list|(
specifier|const
name|struct
name|cmng_init_input
modifier|*
name|input_data
parameter_list|,
name|uint32_t
name|r_param
parameter_list|,
name|struct
name|cmng_init
modifier|*
name|ram_data
parameter_list|)
block|{
name|uint32_t
name|vnic
decl_stmt|;
name|struct
name|cmng_vnic
modifier|*
name|vdata
init|=
operator|&
name|ram_data
operator|->
name|vnic
decl_stmt|;
name|struct
name|cmng_struct_per_port
modifier|*
name|pdata
init|=
operator|&
name|ram_data
operator|->
name|port
decl_stmt|;
comment|/* 	 * rate shaping per-port variables 	 *  100 micro seconds in SDM ticks = 25 	 *  since each tick is 4 microSeconds 	 */
name|pdata
operator|->
name|rs_vars
operator|.
name|rs_periodic_timeout
operator|=
name|RS_PERIODIC_TIMEOUT_USEC
operator|/
name|SDM_TICKS
expr_stmt|;
comment|/* this is the threshold below which no timer arming will occur. 	 *  1.25 coefficient is for the threshold to be a little bigger 	 *  then the real time to compensate for timer in-accuracy 	 */
name|pdata
operator|->
name|rs_vars
operator|.
name|rs_threshold
operator|=
operator|(
literal|5
operator|*
name|RS_PERIODIC_TIMEOUT_USEC
operator|*
name|r_param
operator|)
operator|/
literal|4
expr_stmt|;
comment|/* rate shaping per-vnic variables */
for|for
control|(
name|vnic
operator|=
literal|0
init|;
name|vnic
operator|<
name|ECORE_PORT2_MODE_NUM_VNICS
condition|;
name|vnic
operator|++
control|)
block|{
comment|/* global vnic counter */
name|vdata
operator|->
name|vnic_max_rate
index|[
name|vnic
index|]
operator|.
name|vn_counter
operator|.
name|rate
operator|=
name|input_data
operator|->
name|vnic_max_rate
index|[
name|vnic
index|]
expr_stmt|;
comment|/* 		 * maximal Mbps for this vnic 		 * the quota in each timer period - number of bytes 		 * transmitted in this period 		 */
name|vdata
operator|->
name|vnic_max_rate
index|[
name|vnic
index|]
operator|.
name|vn_counter
operator|.
name|quota
operator|=
name|RS_PERIODIC_TIMEOUT_USEC
operator|*
operator|(
name|uint32_t
operator|)
name|vdata
operator|->
name|vnic_max_rate
index|[
name|vnic
index|]
operator|.
name|vn_counter
operator|.
name|rate
operator|/
literal|8
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ecore_init_max_per_vn
parameter_list|(
name|uint16_t
name|vnic_max_rate
parameter_list|,
name|struct
name|rate_shaping_vars_per_vn
modifier|*
name|ram_data
parameter_list|)
block|{
comment|/* global vnic counter */
name|ram_data
operator|->
name|vn_counter
operator|.
name|rate
operator|=
name|vnic_max_rate
expr_stmt|;
comment|/* 	* maximal Mbps for this vnic 	* the quota in each timer period - number of bytes 	* transmitted in this period 	*/
name|ram_data
operator|->
name|vn_counter
operator|.
name|quota
operator|=
name|RS_PERIODIC_TIMEOUT_USEC
operator|*
operator|(
name|uint32_t
operator|)
name|vnic_max_rate
operator|/
literal|8
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ecore_init_min
parameter_list|(
specifier|const
name|struct
name|cmng_init_input
modifier|*
name|input_data
parameter_list|,
name|uint32_t
name|r_param
parameter_list|,
name|struct
name|cmng_init
modifier|*
name|ram_data
parameter_list|)
block|{
name|uint32_t
name|vnic
decl_stmt|,
name|fair_periodic_timeout_usec
decl_stmt|,
name|vnicWeightSum
decl_stmt|,
name|tFair
decl_stmt|;
name|struct
name|cmng_vnic
modifier|*
name|vdata
init|=
operator|&
name|ram_data
operator|->
name|vnic
decl_stmt|;
name|struct
name|cmng_struct_per_port
modifier|*
name|pdata
init|=
operator|&
name|ram_data
operator|->
name|port
decl_stmt|;
comment|/* this is the resolution of the fairness timer */
name|fair_periodic_timeout_usec
operator|=
name|QM_ARB_BYTES
operator|/
name|r_param
expr_stmt|;
comment|/* 	 * fairness per-port variables 	 * for 10G it is 1000usec. for 1G it is 10000usec. 	 */
name|tFair
operator|=
name|T_FAIR_COEF
operator|/
name|input_data
operator|->
name|port_rate
expr_stmt|;
comment|/* this is the threshold below which we won't arm the timer anymore */
name|pdata
operator|->
name|fair_vars
operator|.
name|fair_threshold
operator|=
name|QM_ARB_BYTES
expr_stmt|;
comment|/* 	 *  we multiply by 1e3/8 to get bytes/msec. We don't want the credits 	 *  to pass a credit of the T_FAIR*FAIR_MEM (algorithm resolution) 	 */
name|pdata
operator|->
name|fair_vars
operator|.
name|upper_bound
operator|=
name|r_param
operator|*
name|tFair
operator|*
name|FAIR_MEM
expr_stmt|;
comment|/* since each tick is 4 microSeconds */
name|pdata
operator|->
name|fair_vars
operator|.
name|fairness_timeout
operator|=
name|fair_periodic_timeout_usec
operator|/
name|SDM_TICKS
expr_stmt|;
comment|/* calculate sum of weights */
name|vnicWeightSum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|vnic
operator|=
literal|0
init|;
name|vnic
operator|<
name|ECORE_PORT2_MODE_NUM_VNICS
condition|;
name|vnic
operator|++
control|)
name|vnicWeightSum
operator|+=
name|input_data
operator|->
name|vnic_min_rate
index|[
name|vnic
index|]
expr_stmt|;
comment|/* global vnic counter */
if|if
condition|(
name|vnicWeightSum
operator|>
literal|0
condition|)
block|{
comment|/* fairness per-vnic variables */
for|for
control|(
name|vnic
operator|=
literal|0
init|;
name|vnic
operator|<
name|ECORE_PORT2_MODE_NUM_VNICS
condition|;
name|vnic
operator|++
control|)
block|{
comment|/* 			 *  this is the credit for each period of the fairness 			 *  algorithm - number of bytes in T_FAIR (this vnic 			 *  share of the port rate) 			 */
name|vdata
operator|->
name|vnic_min_rate
index|[
name|vnic
index|]
operator|.
name|vn_credit_delta
operator|=
operator|(
call|(
name|uint32_t
call|)
argument_list|(
name|input_data
operator|->
name|vnic_min_rate
index|[
name|vnic
index|]
argument_list|)
operator|*
literal|100
operator|*
operator|(
name|T_FAIR_COEF
operator|/
operator|(
literal|8
operator|*
literal|100
operator|*
name|vnicWeightSum
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|vdata
operator|->
name|vnic_min_rate
index|[
name|vnic
index|]
operator|.
name|vn_credit_delta
operator|<
name|pdata
operator|->
name|fair_vars
operator|.
name|fair_threshold
operator|+
name|MIN_ABOVE_THRESH
condition|)
block|{
name|vdata
operator|->
name|vnic_min_rate
index|[
name|vnic
index|]
operator|.
name|vn_credit_delta
operator|=
name|pdata
operator|->
name|fair_vars
operator|.
name|fair_threshold
operator|+
name|MIN_ABOVE_THRESH
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ecore_init_fw_wrr
parameter_list|(
specifier|const
name|struct
name|cmng_init_input
modifier|*
name|input_data
parameter_list|,
name|uint32_t
name|r_param
parameter_list|,
name|struct
name|cmng_init
modifier|*
name|ram_data
parameter_list|)
block|{
name|uint32_t
name|vnic
decl_stmt|,
name|cos
decl_stmt|;
name|uint32_t
name|cosWeightSum
init|=
literal|0
decl_stmt|;
name|struct
name|cmng_vnic
modifier|*
name|vdata
init|=
operator|&
name|ram_data
operator|->
name|vnic
decl_stmt|;
name|struct
name|cmng_struct_per_port
modifier|*
name|pdata
init|=
operator|&
name|ram_data
operator|->
name|port
decl_stmt|;
for|for
control|(
name|cos
operator|=
literal|0
init|;
name|cos
operator|<
name|MAX_COS_NUMBER
condition|;
name|cos
operator|++
control|)
name|cosWeightSum
operator|+=
name|input_data
operator|->
name|cos_min_rate
index|[
name|cos
index|]
expr_stmt|;
if|if
condition|(
name|cosWeightSum
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|vnic
operator|=
literal|0
init|;
name|vnic
operator|<
name|ECORE_PORT2_MODE_NUM_VNICS
condition|;
name|vnic
operator|++
control|)
block|{
comment|/* 			 *  Since cos and vnic shouldn't work together the rate 			 *  to divide between the coses is the port rate. 			 */
name|uint32_t
modifier|*
name|ccd
init|=
name|vdata
operator|->
name|vnic_min_rate
index|[
name|vnic
index|]
operator|.
name|cos_credit_delta
decl_stmt|;
for|for
control|(
name|cos
operator|=
literal|0
init|;
name|cos
operator|<
name|MAX_COS_NUMBER
condition|;
name|cos
operator|++
control|)
block|{
comment|/* 				 * this is the credit for each period of 				 * the fairness algorithm - number of bytes 				 * in T_FAIR (this cos share of the vnic rate) 				 */
name|ccd
index|[
name|cos
index|]
operator|=
operator|(
operator|(
name|uint32_t
operator|)
name|input_data
operator|->
name|cos_min_rate
index|[
name|cos
index|]
operator|*
literal|100
operator|*
operator|(
name|T_FAIR_COEF
operator|/
operator|(
literal|8
operator|*
literal|100
operator|*
name|cosWeightSum
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|ccd
index|[
name|cos
index|]
operator|<
name|pdata
operator|->
name|fair_vars
operator|.
name|fair_threshold
operator|+
name|MIN_ABOVE_THRESH
condition|)
block|{
name|ccd
index|[
name|cos
index|]
operator|=
name|pdata
operator|->
name|fair_vars
operator|.
name|fair_threshold
operator|+
name|MIN_ABOVE_THRESH
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ecore_init_safc
parameter_list|(
specifier|const
name|struct
name|cmng_init_input
modifier|*
name|input_data
parameter_list|,
name|struct
name|cmng_init
modifier|*
name|ram_data
parameter_list|)
block|{
comment|/* in microSeconds */
name|ram_data
operator|->
name|port
operator|.
name|safc_vars
operator|.
name|safc_timeout_usec
operator|=
name|SAFC_TIMEOUT_USEC
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Congestion management port init */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ecore_init_cmng
parameter_list|(
specifier|const
name|struct
name|cmng_init_input
modifier|*
name|input_data
parameter_list|,
name|struct
name|cmng_init
modifier|*
name|ram_data
parameter_list|)
block|{
name|uint32_t
name|r_param
decl_stmt|;
name|ECORE_MEMSET
argument_list|(
name|ram_data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cmng_init
argument_list|)
argument_list|)
expr_stmt|;
name|ram_data
operator|->
name|port
operator|.
name|flags
operator|=
name|input_data
operator|->
name|flags
expr_stmt|;
comment|/* 	 *  number of bytes transmitted in a rate of 10Gbps 	 *  in one usec = 1.25KB. 	 */
name|r_param
operator|=
name|BITS_TO_BYTES
argument_list|(
name|input_data
operator|->
name|port_rate
argument_list|)
expr_stmt|;
name|ecore_init_max
argument_list|(
name|input_data
argument_list|,
name|r_param
argument_list|,
name|ram_data
argument_list|)
expr_stmt|;
name|ecore_init_min
argument_list|(
name|input_data
argument_list|,
name|r_param
argument_list|,
name|ram_data
argument_list|)
expr_stmt|;
name|ecore_init_fw_wrr
argument_list|(
name|input_data
argument_list|,
name|r_param
argument_list|,
name|ram_data
argument_list|)
expr_stmt|;
name|ecore_init_safc
argument_list|(
name|input_data
argument_list|,
name|ram_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns the index of start or end of a specific block stage in ops array*/
end_comment

begin_define
define|#
directive|define
name|BLOCK_OPS_IDX
parameter_list|(
name|block
parameter_list|,
name|stage
parameter_list|,
name|end
parameter_list|)
define|\
value|(2*(((block)*NUM_OF_INIT_PHASES) + (stage)) + (end))
end_define

begin_define
define|#
directive|define
name|INITOP_SET
value|0
end_define

begin_comment
comment|/* set the HW directly */
end_comment

begin_define
define|#
directive|define
name|INITOP_CLEAR
value|1
end_define

begin_comment
comment|/* clear the HW directly */
end_comment

begin_define
define|#
directive|define
name|INITOP_INIT
value|2
end_define

begin_comment
comment|/* set the init-value array */
end_comment

begin_comment
comment|/**************************************************************************** * ILT management ****************************************************************************/
end_comment

begin_struct
struct|struct
name|ilt_line
block|{
name|ecore_dma_addr_t
name|page_mapping
decl_stmt|;
name|void
modifier|*
name|page
decl_stmt|;
name|uint32_t
name|size
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ilt_client_info
block|{
name|uint32_t
name|page_size
decl_stmt|;
name|uint16_t
name|start
decl_stmt|;
name|uint16_t
name|end
decl_stmt|;
name|uint16_t
name|client_num
decl_stmt|;
name|uint16_t
name|flags
decl_stmt|;
define|#
directive|define
name|ILT_CLIENT_SKIP_INIT
value|0x1
define|#
directive|define
name|ILT_CLIENT_SKIP_MEM
value|0x2
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ecore_ilt
block|{
name|uint32_t
name|start_line
decl_stmt|;
name|struct
name|ilt_line
modifier|*
name|lines
decl_stmt|;
name|struct
name|ilt_client_info
name|clients
index|[
literal|4
index|]
decl_stmt|;
define|#
directive|define
name|ILT_CLIENT_CDU
value|0
define|#
directive|define
name|ILT_CLIENT_QM
value|1
define|#
directive|define
name|ILT_CLIENT_SRC
value|2
define|#
directive|define
name|ILT_CLIENT_TM
value|3
block|}
struct|;
end_struct

begin_comment
comment|/**************************************************************************** * SRC configuration ****************************************************************************/
end_comment

begin_struct
struct|struct
name|src_ent
block|{
name|uint8_t
name|opaque
index|[
literal|56
index|]
decl_stmt|;
name|uint64_t
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/**************************************************************************** * Parity configuration ****************************************************************************/
end_comment

begin_define
define|#
directive|define
name|BLOCK_PRTY_INFO
parameter_list|(
name|block
parameter_list|,
name|en_mask
parameter_list|,
name|m1
parameter_list|,
name|m1h
parameter_list|,
name|m2
parameter_list|,
name|m3
parameter_list|)
define|\
value|{ \ 	block##_REG_##block##_PRTY_MASK, \ 	block##_REG_##block##_PRTY_STS_CLR, \ 	en_mask, {m1, m1h, m2, m3}, #block \ }
end_define

begin_define
define|#
directive|define
name|BLOCK_PRTY_INFO_0
parameter_list|(
name|block
parameter_list|,
name|en_mask
parameter_list|,
name|m1
parameter_list|,
name|m1h
parameter_list|,
name|m2
parameter_list|,
name|m3
parameter_list|)
define|\
value|{ \ 	block##_REG_##block##_PRTY_MASK_0, \ 	block##_REG_##block##_PRTY_STS_CLR_0, \ 	en_mask, {m1, m1h, m2, m3}, #block"_0" \ }
end_define

begin_define
define|#
directive|define
name|BLOCK_PRTY_INFO_1
parameter_list|(
name|block
parameter_list|,
name|en_mask
parameter_list|,
name|m1
parameter_list|,
name|m1h
parameter_list|,
name|m2
parameter_list|,
name|m3
parameter_list|)
define|\
value|{ \ 	block##_REG_##block##_PRTY_MASK_1, \ 	block##_REG_##block##_PRTY_STS_CLR_1, \ 	en_mask, {m1, m1h, m2, m3}, #block"_1" \ }
end_define

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|uint32_t
name|mask_addr
decl_stmt|;
name|uint32_t
name|sts_clr_addr
decl_stmt|;
name|uint32_t
name|en_mask
decl_stmt|;
comment|/* Mask to enable parity attentions */
struct|struct
block|{
name|uint32_t
name|e1
decl_stmt|;
comment|/* 57710 */
name|uint32_t
name|e1h
decl_stmt|;
comment|/* 57711 */
name|uint32_t
name|e2
decl_stmt|;
comment|/* 57712 */
name|uint32_t
name|e3
decl_stmt|;
comment|/* 578xx */
block|}
name|reg_mask
struct|;
comment|/* Register mask (all valid bits) */
name|char
name|name
index|[
literal|8
index|]
decl_stmt|;
comment|/* Block's longest name is 7 characters long 				 * (name + suffix) 				 */
block|}
name|ecore_blocks_parity_data
index|[]
init|=
block|{
comment|/* bit 19 masked */
comment|/* REG_WR(bp, PXP_REG_PXP_PRTY_MASK, 0x80000); */
comment|/* bit 5,18,20-31 */
comment|/* REG_WR(bp, PXP2_REG_PXP2_PRTY_MASK_0, 0xfff40020); */
comment|/* bit 5 */
comment|/* REG_WR(bp, PXP2_REG_PXP2_PRTY_MASK_1, 0x20);	*/
comment|/* REG_WR(bp, HC_REG_HC_PRTY_MASK, 0x0); */
comment|/* REG_WR(bp, MISC_REG_MISC_PRTY_MASK, 0x0); */
comment|/* Block IGU, MISC, PXP and PXP2 parity errors as long as we don't 	 * want to handle "system kill" flow at the moment. 	 */
name|BLOCK_PRTY_INFO
argument_list|(
name|PXP
argument_list|,
literal|0x7ffffff
argument_list|,
literal|0x3ffffff
argument_list|,
literal|0x3ffffff
argument_list|,
literal|0x7ffffff
argument_list|,
literal|0x7ffffff
argument_list|)
block|,
name|BLOCK_PRTY_INFO_0
argument_list|(
name|PXP2
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|)
block|,
name|BLOCK_PRTY_INFO_1
argument_list|(
name|PXP2
argument_list|,
literal|0x1ffffff
argument_list|,
literal|0x7f
argument_list|,
literal|0x7f
argument_list|,
literal|0x7ff
argument_list|,
literal|0x1ffffff
argument_list|)
block|,
name|BLOCK_PRTY_INFO
argument_list|(
name|HC
argument_list|,
literal|0x7
argument_list|,
literal|0x7
argument_list|,
literal|0x7
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
block|,
name|BLOCK_PRTY_INFO
argument_list|(
name|NIG
argument_list|,
literal|0xffffffff
argument_list|,
literal|0x3fffffff
argument_list|,
literal|0xffffffff
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
block|,
name|BLOCK_PRTY_INFO_0
argument_list|(
name|NIG
argument_list|,
literal|0xffffffff
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|)
block|,
name|BLOCK_PRTY_INFO_1
argument_list|(
name|NIG
argument_list|,
literal|0xffff
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0xff
argument_list|,
literal|0xffff
argument_list|)
block|,
name|BLOCK_PRTY_INFO
argument_list|(
name|IGU
argument_list|,
literal|0x7ff
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0x7ff
argument_list|,
literal|0x7ff
argument_list|)
block|,
name|BLOCK_PRTY_INFO
argument_list|(
name|MISC
argument_list|,
literal|0x1
argument_list|,
literal|0x1
argument_list|,
literal|0x1
argument_list|,
literal|0x1
argument_list|,
literal|0x1
argument_list|)
block|,
name|BLOCK_PRTY_INFO
argument_list|(
name|QM
argument_list|,
literal|0
argument_list|,
literal|0x1ff
argument_list|,
literal|0xfff
argument_list|,
literal|0xfff
argument_list|,
literal|0xfff
argument_list|)
block|,
name|BLOCK_PRTY_INFO
argument_list|(
name|ATC
argument_list|,
literal|0x1f
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0x1f
argument_list|,
literal|0x1f
argument_list|)
block|,
name|BLOCK_PRTY_INFO
argument_list|(
name|PGLUE_B
argument_list|,
literal|0x3
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0x3
argument_list|,
literal|0x3
argument_list|)
block|,
name|BLOCK_PRTY_INFO
argument_list|(
name|DORQ
argument_list|,
literal|0
argument_list|,
literal|0x3
argument_list|,
literal|0x3
argument_list|,
literal|0x3
argument_list|,
literal|0x3
argument_list|)
block|,
block|{
name|GRCBASE_UPB
operator|+
name|PB_REG_PB_PRTY_MASK
block|,
name|GRCBASE_UPB
operator|+
name|PB_REG_PB_PRTY_STS_CLR
block|,
literal|0xf
block|,
block|{
literal|0xf
block|,
literal|0xf
block|,
literal|0xf
block|,
literal|0xf
block|}
block|,
literal|"UPB"
block|}
block|,
block|{
name|GRCBASE_XPB
operator|+
name|PB_REG_PB_PRTY_MASK
block|,
name|GRCBASE_XPB
operator|+
name|PB_REG_PB_PRTY_STS_CLR
block|,
literal|0
block|,
block|{
literal|0xf
block|,
literal|0xf
block|,
literal|0xf
block|,
literal|0xf
block|}
block|,
literal|"XPB"
block|}
block|,
name|BLOCK_PRTY_INFO
argument_list|(
name|SRC
argument_list|,
literal|0x4
argument_list|,
literal|0x7
argument_list|,
literal|0x7
argument_list|,
literal|0x7
argument_list|,
literal|0x7
argument_list|)
block|,
name|BLOCK_PRTY_INFO
argument_list|(
name|CDU
argument_list|,
literal|0
argument_list|,
literal|0x1f
argument_list|,
literal|0x1f
argument_list|,
literal|0x1f
argument_list|,
literal|0x1f
argument_list|)
block|,
name|BLOCK_PRTY_INFO
argument_list|(
name|CFC
argument_list|,
literal|0
argument_list|,
literal|0xf
argument_list|,
literal|0xf
argument_list|,
literal|0xf
argument_list|,
literal|0x3f
argument_list|)
block|,
name|BLOCK_PRTY_INFO
argument_list|(
name|DBG
argument_list|,
literal|0
argument_list|,
literal|0x1
argument_list|,
literal|0x1
argument_list|,
literal|0x1
argument_list|,
literal|0x1
argument_list|)
block|,
name|BLOCK_PRTY_INFO
argument_list|(
name|DMAE
argument_list|,
literal|0
argument_list|,
literal|0xf
argument_list|,
literal|0xf
argument_list|,
literal|0xf
argument_list|,
literal|0xf
argument_list|)
block|,
name|BLOCK_PRTY_INFO
argument_list|(
name|BRB1
argument_list|,
literal|0
argument_list|,
literal|0xf
argument_list|,
literal|0xf
argument_list|,
literal|0xf
argument_list|,
literal|0xf
argument_list|)
block|,
name|BLOCK_PRTY_INFO
argument_list|(
name|PRS
argument_list|,
operator|(
literal|1
operator|<<
literal|6
operator|)
argument_list|,
literal|0xff
argument_list|,
literal|0xff
argument_list|,
literal|0xff
argument_list|,
literal|0xff
argument_list|)
block|,
name|BLOCK_PRTY_INFO
argument_list|(
name|PBF
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0x3ffff
argument_list|,
literal|0xfffff
argument_list|,
literal|0xfffffff
argument_list|)
block|,
name|BLOCK_PRTY_INFO
argument_list|(
name|TM
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0x7f
argument_list|,
literal|0x7f
argument_list|,
literal|0x7f
argument_list|)
block|,
name|BLOCK_PRTY_INFO
argument_list|(
name|TSDM
argument_list|,
literal|0x18
argument_list|,
literal|0x7ff
argument_list|,
literal|0x7ff
argument_list|,
literal|0x7ff
argument_list|,
literal|0x7ff
argument_list|)
block|,
name|BLOCK_PRTY_INFO
argument_list|(
name|CSDM
argument_list|,
literal|0x8
argument_list|,
literal|0x7ff
argument_list|,
literal|0x7ff
argument_list|,
literal|0x7ff
argument_list|,
literal|0x7ff
argument_list|)
block|,
name|BLOCK_PRTY_INFO
argument_list|(
name|USDM
argument_list|,
literal|0x38
argument_list|,
literal|0x7ff
argument_list|,
literal|0x7ff
argument_list|,
literal|0x7ff
argument_list|,
literal|0x7ff
argument_list|)
block|,
name|BLOCK_PRTY_INFO
argument_list|(
name|XSDM
argument_list|,
literal|0x8
argument_list|,
literal|0x7ff
argument_list|,
literal|0x7ff
argument_list|,
literal|0x7ff
argument_list|,
literal|0x7ff
argument_list|)
block|,
name|BLOCK_PRTY_INFO
argument_list|(
name|TCM
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0x7ffffff
argument_list|,
literal|0x7ffffff
argument_list|,
literal|0x7ffffff
argument_list|)
block|,
name|BLOCK_PRTY_INFO
argument_list|(
name|CCM
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0x7ffffff
argument_list|,
literal|0x7ffffff
argument_list|,
literal|0x7ffffff
argument_list|)
block|,
name|BLOCK_PRTY_INFO
argument_list|(
name|UCM
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0x7ffffff
argument_list|,
literal|0x7ffffff
argument_list|,
literal|0x7ffffff
argument_list|)
block|,
name|BLOCK_PRTY_INFO
argument_list|(
name|XCM
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0x3fffffff
argument_list|,
literal|0x3fffffff
argument_list|,
literal|0x3fffffff
argument_list|)
block|,
name|BLOCK_PRTY_INFO_0
argument_list|(
name|TSEM
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|)
block|,
name|BLOCK_PRTY_INFO_1
argument_list|(
name|TSEM
argument_list|,
literal|0
argument_list|,
literal|0x3
argument_list|,
literal|0x1f
argument_list|,
literal|0x3f
argument_list|,
literal|0x3f
argument_list|)
block|,
name|BLOCK_PRTY_INFO_0
argument_list|(
name|USEM
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|)
block|,
name|BLOCK_PRTY_INFO_1
argument_list|(
name|USEM
argument_list|,
literal|0
argument_list|,
literal|0x3
argument_list|,
literal|0x1f
argument_list|,
literal|0x1f
argument_list|,
literal|0x1f
argument_list|)
block|,
name|BLOCK_PRTY_INFO_0
argument_list|(
name|CSEM
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|)
block|,
name|BLOCK_PRTY_INFO_1
argument_list|(
name|CSEM
argument_list|,
literal|0
argument_list|,
literal|0x3
argument_list|,
literal|0x1f
argument_list|,
literal|0x1f
argument_list|,
literal|0x1f
argument_list|)
block|,
name|BLOCK_PRTY_INFO_0
argument_list|(
name|XSEM
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|,
literal|0xffffffff
argument_list|)
block|,
name|BLOCK_PRTY_INFO_1
argument_list|(
name|XSEM
argument_list|,
literal|0
argument_list|,
literal|0x3
argument_list|,
literal|0x1f
argument_list|,
literal|0x3f
argument_list|,
literal|0x3f
argument_list|)
block|, }
struct|;
end_struct

begin_comment
comment|/* [28] MCP Latched rom_parity  * [29] MCP Latched ump_rx_parity  * [30] MCP Latched ump_tx_parity  * [31] MCP Latched scpad_parity  */
end_comment

begin_define
define|#
directive|define
name|MISC_AEU_ENABLE_MCP_PRTY_SUB_BITS
define|\
value|(AEU_INPUTS_ATTN_BITS_MCP_LATCHED_ROM_PARITY | \ 	 AEU_INPUTS_ATTN_BITS_MCP_LATCHED_UMP_RX_PARITY | \ 	 AEU_INPUTS_ATTN_BITS_MCP_LATCHED_UMP_TX_PARITY)
end_define

begin_define
define|#
directive|define
name|MISC_AEU_ENABLE_MCP_PRTY_BITS
define|\
value|(MISC_AEU_ENABLE_MCP_PRTY_SUB_BITS | \ 	 AEU_INPUTS_ATTN_BITS_MCP_LATCHED_SCPAD_PARITY)
end_define

begin_comment
comment|/* Below registers control the MCP parity attention output. When  * MISC_AEU_ENABLE_MCP_PRTY_BITS are set - attentions are  * enabled, when cleared - disabled.  */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|uint32_t
name|addr
decl_stmt|;
name|uint32_t
name|bits
decl_stmt|;
block|}
name|mcp_attn_ctl_regs
index|[]
init|=
block|{
block|{
name|MISC_REG_AEU_ENABLE4_FUNC_0_OUT_0
block|,
name|MISC_AEU_ENABLE_MCP_PRTY_BITS
block|}
block|,
block|{
name|MISC_REG_AEU_ENABLE4_NIG_0
block|,
name|MISC_AEU_ENABLE_MCP_PRTY_SUB_BITS
block|}
block|,
block|{
name|MISC_REG_AEU_ENABLE4_PXP_0
block|,
name|MISC_AEU_ENABLE_MCP_PRTY_SUB_BITS
block|}
block|,
block|{
name|MISC_REG_AEU_ENABLE4_FUNC_1_OUT_0
block|,
name|MISC_AEU_ENABLE_MCP_PRTY_BITS
block|}
block|,
block|{
name|MISC_REG_AEU_ENABLE4_NIG_1
block|,
name|MISC_AEU_ENABLE_MCP_PRTY_SUB_BITS
block|}
block|,
block|{
name|MISC_REG_AEU_ENABLE4_PXP_1
block|,
name|MISC_AEU_ENABLE_MCP_PRTY_SUB_BITS
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
specifier|inline
name|void
name|ecore_set_mcp_parity
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|enable
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint32_t
name|reg_val
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRSIZE
argument_list|(
name|mcp_attn_ctl_regs
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|reg_val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|mcp_attn_ctl_regs
index|[
name|i
index|]
operator|.
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|reg_val
operator||=
name|MISC_AEU_ENABLE_MCP_PRTY_BITS
expr_stmt|;
comment|/* Linux is using mcp_attn_ctl_regs[i].bits */
else|else
name|reg_val
operator|&=
operator|~
name|MISC_AEU_ENABLE_MCP_PRTY_BITS
expr_stmt|;
comment|/* Linux is using mcp_attn_ctl_regs[i].bits */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|mcp_attn_ctl_regs
index|[
name|i
index|]
operator|.
name|addr
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint32_t
name|ecore_parity_reg_mask
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
if|if
condition|(
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|ecore_blocks_parity_data
index|[
name|idx
index|]
operator|.
name|reg_mask
operator|.
name|e1
return|;
elseif|else
if|if
condition|(
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|ecore_blocks_parity_data
index|[
name|idx
index|]
operator|.
name|reg_mask
operator|.
name|e1h
return|;
elseif|else
if|if
condition|(
name|CHIP_IS_E2
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|ecore_blocks_parity_data
index|[
name|idx
index|]
operator|.
name|reg_mask
operator|.
name|e2
return|;
else|else
comment|/* CHIP_IS_E3 */
return|return
name|ecore_blocks_parity_data
index|[
name|idx
index|]
operator|.
name|reg_mask
operator|.
name|e3
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ecore_disable_blocks_parity
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRSIZE
argument_list|(
name|ecore_blocks_parity_data
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|uint32_t
name|dis_mask
init|=
name|ecore_parity_reg_mask
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|dis_mask
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|ecore_blocks_parity_data
index|[
name|i
index|]
operator|.
name|mask_addr
argument_list|,
name|dis_mask
argument_list|)
expr_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"Setting parity mask "
literal|"for %s to\t\t0x%x\n"
argument_list|,
name|ecore_blocks_parity_data
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|dis_mask
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Disable MCP parity attentions */
name|ecore_set_mcp_parity
argument_list|(
name|sc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Clear the parity error status registers.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ecore_clear_blocks_parity
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint32_t
name|reg_val
decl_stmt|,
name|mcp_aeu_bits
init|=
name|AEU_INPUTS_ATTN_BITS_MCP_LATCHED_ROM_PARITY
operator||
name|AEU_INPUTS_ATTN_BITS_MCP_LATCHED_SCPAD_PARITY
operator||
name|AEU_INPUTS_ATTN_BITS_MCP_LATCHED_UMP_RX_PARITY
operator||
name|AEU_INPUTS_ATTN_BITS_MCP_LATCHED_UMP_TX_PARITY
decl_stmt|;
comment|/* Clear SEM_FAST parities */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|XSEM_REG_FAST_MEMORY
operator|+
name|SEM_FAST_REG_PARITY_RST
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|TSEM_REG_FAST_MEMORY
operator|+
name|SEM_FAST_REG_PARITY_RST
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|USEM_REG_FAST_MEMORY
operator|+
name|SEM_FAST_REG_PARITY_RST
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|CSEM_REG_FAST_MEMORY
operator|+
name|SEM_FAST_REG_PARITY_RST
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRSIZE
argument_list|(
name|ecore_blocks_parity_data
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|uint32_t
name|reg_mask
init|=
name|ecore_parity_reg_mask
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg_mask
condition|)
block|{
name|reg_val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|ecore_blocks_parity_data
index|[
name|i
index|]
operator|.
name|sts_clr_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_val
operator|&
name|reg_mask
condition|)
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"Parity errors in %s: 0x%x\n"
argument_list|,
name|ecore_blocks_parity_data
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|reg_val
operator|&
name|reg_mask
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Check if there were parity attentions in MCP */
name|reg_val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_AFTER_INVERT_4_MCP
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_val
operator|&
name|mcp_aeu_bits
condition|)
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"Parity error in MCP: 0x%x\n"
argument_list|,
name|reg_val
operator|&
name|mcp_aeu_bits
argument_list|)
expr_stmt|;
comment|/* Clear parity attentions in MCP: 	 * [7]  clears Latched rom_parity 	 * [8]  clears Latched ump_rx_parity 	 * [9]  clears Latched ump_tx_parity 	 * [10] clears Latched scpad_parity (both ports) 	 */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_AEU_CLR_LATCH_SIGNAL
argument_list|,
literal|0x780
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ecore_enable_blocks_parity
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRSIZE
argument_list|(
name|ecore_blocks_parity_data
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|uint32_t
name|reg_mask
init|=
name|ecore_parity_reg_mask
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg_mask
condition|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|ecore_blocks_parity_data
index|[
name|i
index|]
operator|.
name|mask_addr
argument_list|,
name|ecore_blocks_parity_data
index|[
name|i
index|]
operator|.
name|en_mask
operator|&
name|reg_mask
argument_list|)
expr_stmt|;
block|}
comment|/* Enable MCP parity attentions */
name|ecore_set_mcp_parity
argument_list|(
name|sc
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ECORE_INIT_H */
end_comment

end_unit

