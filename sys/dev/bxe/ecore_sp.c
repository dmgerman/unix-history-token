begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2007-2014 QLogic Corporation. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS'  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"bxe.h"
end_include

begin_include
include|#
directive|include
file|"ecore_init.h"
end_include

begin_comment
comment|/**** Exe Queue interfaces ****/
end_comment

begin_comment
comment|/**  * ecore_exe_queue_init - init the Exe Queue object  *  * @o:		pointer to the object  * @exe_len:	length  * @owner:	pointer to the owner  * @validate:	validate function pointer  * @optimize:	optimize function pointer  * @exec:	execute function pointer  * @get:	get function pointer  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ecore_exe_queue_init
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_exe_queue_obj
modifier|*
name|o
parameter_list|,
name|int
name|exe_len
parameter_list|,
name|union
name|ecore_qable_obj
modifier|*
name|owner
parameter_list|,
name|exe_q_validate
name|validate
parameter_list|,
name|exe_q_remove
name|remove
parameter_list|,
name|exe_q_optimize
name|optimize
parameter_list|,
name|exe_q_execute
name|exec
parameter_list|,
name|exe_q_get
name|get
parameter_list|)
block|{
name|ECORE_MEMSET
argument_list|(
name|o
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|o
argument_list|)
argument_list|)
expr_stmt|;
name|ECORE_LIST_INIT
argument_list|(
operator|&
name|o
operator|->
name|exe_queue
argument_list|)
expr_stmt|;
name|ECORE_LIST_INIT
argument_list|(
operator|&
name|o
operator|->
name|pending_comp
argument_list|)
expr_stmt|;
name|ECORE_SPIN_LOCK_INIT
argument_list|(
operator|&
name|o
operator|->
name|lock
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|o
operator|->
name|exe_chunk_len
operator|=
name|exe_len
expr_stmt|;
name|o
operator|->
name|owner
operator|=
name|owner
expr_stmt|;
comment|/* Owner specific callbacks */
name|o
operator|->
name|validate
operator|=
name|validate
expr_stmt|;
name|o
operator|->
name|remove
operator|=
name|remove
expr_stmt|;
name|o
operator|->
name|optimize
operator|=
name|optimize
expr_stmt|;
name|o
operator|->
name|execute
operator|=
name|exec
expr_stmt|;
name|o
operator|->
name|get
operator|=
name|get
expr_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"Setup the execution queue with the chunk length of %d\n"
argument_list|,
name|exe_len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ecore_exe_queue_free_elem
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_exeq_elem
modifier|*
name|elem
parameter_list|)
block|{
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"Deleting an exe_queue element\n"
argument_list|)
expr_stmt|;
name|ECORE_FREE
argument_list|(
name|sc
argument_list|,
name|elem
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|elem
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|ecore_exe_queue_length
parameter_list|(
name|struct
name|ecore_exe_queue_obj
modifier|*
name|o
parameter_list|)
block|{
name|struct
name|ecore_exeq_elem
modifier|*
name|elem
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|;
name|ECORE_SPIN_LOCK_BH
argument_list|(
operator|&
name|o
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ECORE_LIST_FOR_EACH_ENTRY
argument_list|(
argument|elem
argument_list|,
argument|&o->exe_queue
argument_list|,
argument|link
argument_list|,
argument|struct ecore_exeq_elem
argument_list|)
name|cnt
operator|++
expr_stmt|;
name|ECORE_SPIN_UNLOCK_BH
argument_list|(
operator|&
name|o
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|cnt
return|;
block|}
end_function

begin_comment
comment|/**  * ecore_exe_queue_add - add a new element to the execution queue  *  * @sc:		driver handle  * @o:		queue  * @cmd:	new command to add  * @restore:	true - do not optimize the command  *  * If the element is optimized or is illegal, frees it.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ecore_exe_queue_add
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_exe_queue_obj
modifier|*
name|o
parameter_list|,
name|struct
name|ecore_exeq_elem
modifier|*
name|elem
parameter_list|,
name|bool
name|restore
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|ECORE_SPIN_LOCK_BH
argument_list|(
operator|&
name|o
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|restore
condition|)
block|{
comment|/* Try to cancel this element queue */
name|rc
operator|=
name|o
operator|->
name|optimize
argument_list|(
name|sc
argument_list|,
name|o
operator|->
name|owner
argument_list|,
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|free_and_exit
goto|;
comment|/* Check if this request is ok */
name|rc
operator|=
name|o
operator|->
name|validate
argument_list|(
name|sc
argument_list|,
name|o
operator|->
name|owner
argument_list|,
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"Preamble failed: %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|free_and_exit
goto|;
block|}
block|}
comment|/* If so, add it to the execution queue */
name|ECORE_LIST_PUSH_TAIL
argument_list|(
operator|&
name|elem
operator|->
name|link
argument_list|,
operator|&
name|o
operator|->
name|exe_queue
argument_list|)
expr_stmt|;
name|ECORE_SPIN_UNLOCK_BH
argument_list|(
operator|&
name|o
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
name|free_and_exit
label|:
name|ecore_exe_queue_free_elem
argument_list|(
name|sc
argument_list|,
name|elem
argument_list|)
expr_stmt|;
name|ECORE_SPIN_UNLOCK_BH
argument_list|(
operator|&
name|o
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|__ecore_exe_queue_reset_pending
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_exe_queue_obj
modifier|*
name|o
parameter_list|)
block|{
name|struct
name|ecore_exeq_elem
modifier|*
name|elem
decl_stmt|;
while|while
condition|(
operator|!
name|ECORE_LIST_IS_EMPTY
argument_list|(
operator|&
name|o
operator|->
name|pending_comp
argument_list|)
condition|)
block|{
name|elem
operator|=
name|ECORE_LIST_FIRST_ENTRY
argument_list|(
operator|&
name|o
operator|->
name|pending_comp
argument_list|,
expr|struct
name|ecore_exeq_elem
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ECORE_LIST_REMOVE_ENTRY
argument_list|(
operator|&
name|elem
operator|->
name|link
argument_list|,
operator|&
name|o
operator|->
name|pending_comp
argument_list|)
expr_stmt|;
name|ecore_exe_queue_free_elem
argument_list|(
name|sc
argument_list|,
name|elem
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * ecore_exe_queue_step - execute one execution chunk atomically  *  * @sc:			driver handle  * @o:			queue  * @ramrod_flags:	flags  *  * (Should be called while holding the exe_queue->lock).  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ecore_exe_queue_step
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_exe_queue_obj
modifier|*
name|o
parameter_list|,
name|unsigned
name|long
modifier|*
name|ramrod_flags
parameter_list|)
block|{
name|struct
name|ecore_exeq_elem
modifier|*
name|elem
decl_stmt|,
name|spacer
decl_stmt|;
name|int
name|cur_len
init|=
literal|0
decl_stmt|,
name|rc
decl_stmt|;
name|ECORE_MEMSET
argument_list|(
operator|&
name|spacer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|spacer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Next step should not be performed until the current is finished, 	 * unless a DRV_CLEAR_ONLY bit is set. In this case we just want to 	 * properly clear object internals without sending any command to the FW 	 * which also implies there won't be any completion to clear the 	 * 'pending' list. 	 */
if|if
condition|(
operator|!
name|ECORE_LIST_IS_EMPTY
argument_list|(
operator|&
name|o
operator|->
name|pending_comp
argument_list|)
condition|)
block|{
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|RAMROD_DRV_CLR_ONLY
argument_list|,
name|ramrod_flags
argument_list|)
condition|)
block|{
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"RAMROD_DRV_CLR_ONLY requested: resetting a pending_comp list\n"
argument_list|)
expr_stmt|;
name|__ecore_exe_queue_reset_pending
argument_list|(
name|sc
argument_list|,
name|o
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
name|ECORE_PENDING
return|;
block|}
block|}
comment|/* Run through the pending commands list and create a next 	 * execution chunk. 	 */
while|while
condition|(
operator|!
name|ECORE_LIST_IS_EMPTY
argument_list|(
operator|&
name|o
operator|->
name|exe_queue
argument_list|)
condition|)
block|{
name|elem
operator|=
name|ECORE_LIST_FIRST_ENTRY
argument_list|(
operator|&
name|o
operator|->
name|exe_queue
argument_list|,
expr|struct
name|ecore_exeq_elem
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ECORE_DBG_BREAK_IF
argument_list|(
operator|!
name|elem
operator|->
name|cmd_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_len
operator|+
name|elem
operator|->
name|cmd_len
operator|<=
name|o
operator|->
name|exe_chunk_len
condition|)
block|{
name|cur_len
operator|+=
name|elem
operator|->
name|cmd_len
expr_stmt|;
comment|/* Prevent from both lists being empty when moving an 			 * element. This will allow the call of 			 * ecore_exe_queue_empty() without locking. 			 */
name|ECORE_LIST_PUSH_TAIL
argument_list|(
operator|&
name|spacer
operator|.
name|link
argument_list|,
operator|&
name|o
operator|->
name|pending_comp
argument_list|)
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
name|ECORE_LIST_REMOVE_ENTRY
argument_list|(
operator|&
name|elem
operator|->
name|link
argument_list|,
operator|&
name|o
operator|->
name|exe_queue
argument_list|)
expr_stmt|;
name|ECORE_LIST_PUSH_TAIL
argument_list|(
operator|&
name|elem
operator|->
name|link
argument_list|,
operator|&
name|o
operator|->
name|pending_comp
argument_list|)
expr_stmt|;
name|ECORE_LIST_REMOVE_ENTRY
argument_list|(
operator|&
name|spacer
operator|.
name|link
argument_list|,
operator|&
name|o
operator|->
name|pending_comp
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
comment|/* Sanity check */
if|if
condition|(
operator|!
name|cur_len
condition|)
return|return
name|ECORE_SUCCESS
return|;
name|rc
operator|=
name|o
operator|->
name|execute
argument_list|(
name|sc
argument_list|,
name|o
operator|->
name|owner
argument_list|,
operator|&
name|o
operator|->
name|pending_comp
argument_list|,
name|ramrod_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
comment|/* In case of an error return the commands back to the queue 		 *  and reset the pending_comp. 		 */
name|ECORE_LIST_SPLICE_INIT
argument_list|(
operator|&
name|o
operator|->
name|pending_comp
argument_list|,
operator|&
name|o
operator|->
name|exe_queue
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|rc
condition|)
comment|/* If zero is returned, means there are no outstanding pending 		 * completions and we may dismiss the pending list. 		 */
name|__ecore_exe_queue_reset_pending
argument_list|(
name|sc
argument_list|,
name|o
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|ecore_exe_queue_empty
parameter_list|(
name|struct
name|ecore_exe_queue_obj
modifier|*
name|o
parameter_list|)
block|{
name|bool
name|empty
init|=
name|ECORE_LIST_IS_EMPTY
argument_list|(
operator|&
name|o
operator|->
name|exe_queue
argument_list|)
decl_stmt|;
comment|/* Don't reorder!!! */
name|mb
argument_list|()
expr_stmt|;
return|return
name|empty
operator|&&
name|ECORE_LIST_IS_EMPTY
argument_list|(
operator|&
name|o
operator|->
name|pending_comp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|ecore_exeq_elem
modifier|*
name|ecore_exe_queue_alloc_elem
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"Allocating a new exe_queue element\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_ZALLOC
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ecore_exeq_elem
argument_list|)
argument_list|,
name|GFP_ATOMIC
argument_list|,
name|sc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/************************ raw_obj functions ***********************************/
end_comment

begin_function
specifier|static
name|bool
name|ecore_raw_check_pending
parameter_list|(
name|struct
name|ecore_raw_obj
modifier|*
name|o
parameter_list|)
block|{
comment|/*      * !! converts the value returned by ECORE_TEST_BIT such that it      * is guaranteed not to be truncated regardless of bool definition. 	 * 	 * Note we cannot simply define the function's return value type      * to match the type returned by ECORE_TEST_BIT, as it varies by      * platform/implementation. 	 */
return|return
operator|!
operator|!
name|ECORE_TEST_BIT
argument_list|(
name|o
operator|->
name|state
argument_list|,
name|o
operator|->
name|pstate
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_raw_clear_pending
parameter_list|(
name|struct
name|ecore_raw_obj
modifier|*
name|o
parameter_list|)
block|{
name|ECORE_SMP_MB_BEFORE_CLEAR_BIT
argument_list|()
expr_stmt|;
name|ECORE_CLEAR_BIT
argument_list|(
name|o
operator|->
name|state
argument_list|,
name|o
operator|->
name|pstate
argument_list|)
expr_stmt|;
name|ECORE_SMP_MB_AFTER_CLEAR_BIT
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_raw_set_pending
parameter_list|(
name|struct
name|ecore_raw_obj
modifier|*
name|o
parameter_list|)
block|{
name|ECORE_SMP_MB_BEFORE_CLEAR_BIT
argument_list|()
expr_stmt|;
name|ECORE_SET_BIT
argument_list|(
name|o
operator|->
name|state
argument_list|,
name|o
operator|->
name|pstate
argument_list|)
expr_stmt|;
name|ECORE_SMP_MB_AFTER_CLEAR_BIT
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ecore_state_wait - wait until the given bit(state) is cleared  *  * @sc:		device handle  * @state:	state which is to be cleared  * @state_p:	state buffer  *  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ecore_state_wait
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|state
parameter_list|,
name|unsigned
name|long
modifier|*
name|pstate
parameter_list|)
block|{
comment|/* can take a while if any port is running */
name|int
name|cnt
init|=
literal|5000
decl_stmt|;
if|if
condition|(
name|CHIP_REV_IS_EMUL
argument_list|(
name|sc
argument_list|)
condition|)
name|cnt
operator|*=
literal|20
expr_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"waiting for state to become %d\n"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|ECORE_MIGHT_SLEEP
argument_list|()
expr_stmt|;
while|while
condition|(
name|cnt
operator|--
condition|)
block|{
if|if
condition|(
operator|!
name|ECORE_TEST_BIT
argument_list|(
name|state
argument_list|,
name|pstate
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|ECORE_STOP_ON_ERROR
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"exit  (cnt %d)\n"
argument_list|,
literal|5000
operator|-
name|cnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ECORE_SUCCESS
return|;
block|}
name|ECORE_WAIT
argument_list|(
name|sc
argument_list|,
name|delay_us
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|panic
condition|)
return|return
name|ECORE_IO
return|;
block|}
comment|/* timeout! */
name|ECORE_ERR
argument_list|(
literal|"timeout waiting for state %d\n"
argument_list|,
name|state
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ECORE_STOP_ON_ERROR
name|ecore_panic
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|ECORE_TIMEOUT
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ecore_raw_wait
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_raw_obj
modifier|*
name|raw
parameter_list|)
block|{
return|return
name|ecore_state_wait
argument_list|(
name|sc
argument_list|,
name|raw
operator|->
name|state
argument_list|,
name|raw
operator|->
name|pstate
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/***************** Classification verbs: Set/Del MAC/VLAN/VLAN-MAC ************/
end_comment

begin_comment
comment|/* credit handling callbacks */
end_comment

begin_function
specifier|static
name|bool
name|ecore_get_cam_offset_mac
parameter_list|(
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
parameter_list|,
name|int
modifier|*
name|offset
parameter_list|)
block|{
name|struct
name|ecore_credit_pool_obj
modifier|*
name|mp
init|=
name|o
operator|->
name|macs_pool
decl_stmt|;
name|ECORE_DBG_BREAK_IF
argument_list|(
operator|!
name|mp
argument_list|)
expr_stmt|;
return|return
name|mp
operator|->
name|get_entry
argument_list|(
name|mp
argument_list|,
name|offset
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ecore_get_credit_mac
parameter_list|(
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
parameter_list|)
block|{
name|struct
name|ecore_credit_pool_obj
modifier|*
name|mp
init|=
name|o
operator|->
name|macs_pool
decl_stmt|;
name|ECORE_DBG_BREAK_IF
argument_list|(
operator|!
name|mp
argument_list|)
expr_stmt|;
return|return
name|mp
operator|->
name|get
argument_list|(
name|mp
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ecore_get_cam_offset_vlan
parameter_list|(
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
parameter_list|,
name|int
modifier|*
name|offset
parameter_list|)
block|{
name|struct
name|ecore_credit_pool_obj
modifier|*
name|vp
init|=
name|o
operator|->
name|vlans_pool
decl_stmt|;
name|ECORE_DBG_BREAK_IF
argument_list|(
operator|!
name|vp
argument_list|)
expr_stmt|;
return|return
name|vp
operator|->
name|get_entry
argument_list|(
name|vp
argument_list|,
name|offset
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ecore_get_credit_vlan
parameter_list|(
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
parameter_list|)
block|{
name|struct
name|ecore_credit_pool_obj
modifier|*
name|vp
init|=
name|o
operator|->
name|vlans_pool
decl_stmt|;
name|ECORE_DBG_BREAK_IF
argument_list|(
operator|!
name|vp
argument_list|)
expr_stmt|;
return|return
name|vp
operator|->
name|get
argument_list|(
name|vp
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ecore_get_credit_vlan_mac
parameter_list|(
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
parameter_list|)
block|{
name|struct
name|ecore_credit_pool_obj
modifier|*
name|mp
init|=
name|o
operator|->
name|macs_pool
decl_stmt|;
name|struct
name|ecore_credit_pool_obj
modifier|*
name|vp
init|=
name|o
operator|->
name|vlans_pool
decl_stmt|;
if|if
condition|(
operator|!
name|mp
operator|->
name|get
argument_list|(
name|mp
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|vp
operator|->
name|get
argument_list|(
name|vp
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|mp
operator|->
name|put
argument_list|(
name|mp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ecore_put_cam_offset_mac
parameter_list|(
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|struct
name|ecore_credit_pool_obj
modifier|*
name|mp
init|=
name|o
operator|->
name|macs_pool
decl_stmt|;
return|return
name|mp
operator|->
name|put_entry
argument_list|(
name|mp
argument_list|,
name|offset
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ecore_put_credit_mac
parameter_list|(
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
parameter_list|)
block|{
name|struct
name|ecore_credit_pool_obj
modifier|*
name|mp
init|=
name|o
operator|->
name|macs_pool
decl_stmt|;
return|return
name|mp
operator|->
name|put
argument_list|(
name|mp
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ecore_put_cam_offset_vlan
parameter_list|(
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|struct
name|ecore_credit_pool_obj
modifier|*
name|vp
init|=
name|o
operator|->
name|vlans_pool
decl_stmt|;
return|return
name|vp
operator|->
name|put_entry
argument_list|(
name|vp
argument_list|,
name|offset
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ecore_put_credit_vlan
parameter_list|(
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
parameter_list|)
block|{
name|struct
name|ecore_credit_pool_obj
modifier|*
name|vp
init|=
name|o
operator|->
name|vlans_pool
decl_stmt|;
return|return
name|vp
operator|->
name|put
argument_list|(
name|vp
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ecore_put_credit_vlan_mac
parameter_list|(
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
parameter_list|)
block|{
name|struct
name|ecore_credit_pool_obj
modifier|*
name|mp
init|=
name|o
operator|->
name|macs_pool
decl_stmt|;
name|struct
name|ecore_credit_pool_obj
modifier|*
name|vp
init|=
name|o
operator|->
name|vlans_pool
decl_stmt|;
if|if
condition|(
operator|!
name|mp
operator|->
name|put
argument_list|(
name|mp
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|vp
operator|->
name|put
argument_list|(
name|vp
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|mp
operator|->
name|get
argument_list|(
name|mp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/**  * __ecore_vlan_mac_h_write_trylock - try getting the writer lock on vlan mac  * head list.  *  * @sc:		device handle  * @o:		vlan_mac object  *  * @details: Non-blocking implementation; should be called under execution  *           queue lock.  */
end_comment

begin_function
specifier|static
name|int
name|__ecore_vlan_mac_h_write_trylock
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|->
name|head_reader
condition|)
block|{
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"vlan_mac_lock writer - There are readers; Busy\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_BUSY
return|;
block|}
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"vlan_mac_lock writer - Taken\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * __ecore_vlan_mac_h_exec_pending - execute step instead of a previous step  * which wasn't able to run due to a taken lock on vlan mac head list.  *  * @sc:		device handle  * @o:		vlan_mac object  *  * @details Should be called under execution queue lock; notice it might release  *          and reclaim it during its run.  */
end_comment

begin_function
specifier|static
name|void
name|__ecore_vlan_mac_h_exec_pending
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|unsigned
name|long
name|ramrod_flags
init|=
name|o
operator|->
name|saved_ramrod_flags
decl_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"vlan_mac_lock execute pending command with ramrod flags %lu\n"
argument_list|,
name|ramrod_flags
argument_list|)
expr_stmt|;
name|o
operator|->
name|head_exe_request
operator|=
name|FALSE
expr_stmt|;
name|o
operator|->
name|saved_ramrod_flags
operator|=
literal|0
expr_stmt|;
name|rc
operator|=
name|ecore_exe_queue_step
argument_list|(
name|sc
argument_list|,
operator|&
name|o
operator|->
name|exe_queue
argument_list|,
operator|&
name|ramrod_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
name|ECORE_ERR
argument_list|(
literal|"execution of pending commands failed with rc %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ECORE_STOP_ON_ERROR
name|ecore_panic
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/**  * __ecore_vlan_mac_h_pend - Pend an execution step which couldn't have been  * called due to vlan mac head list lock being taken.  *  * @sc:			device handle  * @o:			vlan_mac object  * @ramrod_flags:	ramrod flags of missed execution  *  * @details Should be called under execution queue lock.  */
end_comment

begin_function
specifier|static
name|void
name|__ecore_vlan_mac_h_pend
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
parameter_list|,
name|unsigned
name|long
name|ramrod_flags
parameter_list|)
block|{
name|o
operator|->
name|head_exe_request
operator|=
name|TRUE
expr_stmt|;
name|o
operator|->
name|saved_ramrod_flags
operator|=
name|ramrod_flags
expr_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"Placing pending execution with ramrod flags %lu\n"
argument_list|,
name|ramrod_flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * __ecore_vlan_mac_h_write_unlock - unlock the vlan mac head list writer lock  *  * @sc:			device handle  * @o:			vlan_mac object  *  * @details Should be called under execution queue lock. Notice if a pending  *          execution exists, it would perform it - possibly releasing and  *          reclaiming the execution queue lock.  */
end_comment

begin_function
specifier|static
name|void
name|__ecore_vlan_mac_h_write_unlock
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
parameter_list|)
block|{
comment|/* It's possible a new pending execution was added since this writer 	 * executed. If so, execute again. [Ad infinitum] 	 */
while|while
condition|(
name|o
operator|->
name|head_exe_request
condition|)
block|{
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"vlan_mac_lock - writer release encountered a pending request\n"
argument_list|)
expr_stmt|;
name|__ecore_vlan_mac_h_exec_pending
argument_list|(
name|sc
argument_list|,
name|o
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * ecore_vlan_mac_h_write_unlock - unlock the vlan mac head list writer lock  *  * @sc:			device handle  * @o:			vlan_mac object  *  * @details Notice if a pending execution exists, it would perform it -  *          possibly releasing and reclaiming the execution queue lock.  */
end_comment

begin_function
name|void
name|ecore_vlan_mac_h_write_unlock
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
parameter_list|)
block|{
name|ECORE_SPIN_LOCK_BH
argument_list|(
operator|&
name|o
operator|->
name|exe_queue
operator|.
name|lock
argument_list|)
expr_stmt|;
name|__ecore_vlan_mac_h_write_unlock
argument_list|(
name|sc
argument_list|,
name|o
argument_list|)
expr_stmt|;
name|ECORE_SPIN_UNLOCK_BH
argument_list|(
operator|&
name|o
operator|->
name|exe_queue
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * __ecore_vlan_mac_h_read_lock - lock the vlan mac head list reader lock  *  * @sc:			device handle  * @o:			vlan_mac object  *  * @details Should be called under the execution queue lock. May sleep. May  *          release and reclaim execution queue lock during its run.  */
end_comment

begin_function
specifier|static
name|int
name|__ecore_vlan_mac_h_read_lock
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
parameter_list|)
block|{
comment|/* If we got here, we're holding lock --> no WRITER exists */
name|o
operator|->
name|head_reader
operator|++
expr_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"vlan_mac_lock - locked reader - number %d\n"
argument_list|,
name|o
operator|->
name|head_reader
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * ecore_vlan_mac_h_read_lock - lock the vlan mac head list reader lock  *  * @sc:			device handle  * @o:			vlan_mac object  *  * @details May sleep. Claims and releases execution queue lock during its run.  */
end_comment

begin_function
name|int
name|ecore_vlan_mac_h_read_lock
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|ECORE_SPIN_LOCK_BH
argument_list|(
operator|&
name|o
operator|->
name|exe_queue
operator|.
name|lock
argument_list|)
expr_stmt|;
name|rc
operator|=
name|__ecore_vlan_mac_h_read_lock
argument_list|(
name|sc
argument_list|,
name|o
argument_list|)
expr_stmt|;
name|ECORE_SPIN_UNLOCK_BH
argument_list|(
operator|&
name|o
operator|->
name|exe_queue
operator|.
name|lock
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/**  * __ecore_vlan_mac_h_read_unlock - unlock the vlan mac head list reader lock  *  * @sc:			device handle  * @o:			vlan_mac object  *  * @details Should be called under execution queue lock. Notice if a pending  *          execution exists, it would be performed if this was the last  *          reader. possibly releasing and reclaiming the execution queue lock.  */
end_comment

begin_function
specifier|static
name|void
name|__ecore_vlan_mac_h_read_unlock
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
name|o
operator|->
name|head_reader
condition|)
block|{
name|ECORE_ERR
argument_list|(
literal|"Need to release vlan mac reader lock, but lock isn't taken\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ECORE_STOP_ON_ERROR
name|ecore_panic
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|o
operator|->
name|head_reader
operator|--
expr_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"vlan_mac_lock - decreased readers to %d\n"
argument_list|,
name|o
operator|->
name|head_reader
argument_list|)
expr_stmt|;
block|}
comment|/* It's possible a new pending execution was added, and that this reader 	 * was last - if so we need to execute the command. 	 */
if|if
condition|(
operator|!
name|o
operator|->
name|head_reader
operator|&&
name|o
operator|->
name|head_exe_request
condition|)
block|{
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"vlan_mac_lock - reader release encountered a pending request\n"
argument_list|)
expr_stmt|;
comment|/* Writer release will do the trick */
name|__ecore_vlan_mac_h_write_unlock
argument_list|(
name|sc
argument_list|,
name|o
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * ecore_vlan_mac_h_read_unlock - unlock the vlan mac head list reader lock  *  * @sc:			device handle  * @o:			vlan_mac object  *  * @details Notice if a pending execution exists, it would be performed if this  *          was the last reader. Claims and releases the execution queue lock  *          during its run.  */
end_comment

begin_function
name|void
name|ecore_vlan_mac_h_read_unlock
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
parameter_list|)
block|{
name|ECORE_SPIN_LOCK_BH
argument_list|(
operator|&
name|o
operator|->
name|exe_queue
operator|.
name|lock
argument_list|)
expr_stmt|;
name|__ecore_vlan_mac_h_read_unlock
argument_list|(
name|sc
argument_list|,
name|o
argument_list|)
expr_stmt|;
name|ECORE_SPIN_UNLOCK_BH
argument_list|(
operator|&
name|o
operator|->
name|exe_queue
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ecore_vlan_mac_h_read_unlock - unlock the vlan mac head list reader lock  *  * @sc:			device handle  * @o:			vlan_mac object  * @n:			number of elements to get  * @base:		base address for element placement  * @stride:		stride between elements (in bytes)  */
end_comment

begin_function
specifier|static
name|int
name|ecore_get_n_elements
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
parameter_list|,
name|int
name|n
parameter_list|,
name|uint8_t
modifier|*
name|base
parameter_list|,
name|uint8_t
name|stride
parameter_list|,
name|uint8_t
name|size
parameter_list|)
block|{
name|struct
name|ecore_vlan_mac_registry_elem
modifier|*
name|pos
decl_stmt|;
name|uint8_t
modifier|*
name|next
init|=
name|base
decl_stmt|;
name|int
name|counter
init|=
literal|0
decl_stmt|;
name|int
name|read_lock
decl_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"get_n_elements - taking vlan_mac_lock (reader)\n"
argument_list|)
expr_stmt|;
name|read_lock
operator|=
name|ecore_vlan_mac_h_read_lock
argument_list|(
name|sc
argument_list|,
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_lock
operator|!=
name|ECORE_SUCCESS
condition|)
name|ECORE_ERR
argument_list|(
literal|"get_n_elements failed to get vlan mac reader lock; Access without lock\n"
argument_list|)
expr_stmt|;
comment|/* traverse list */
name|ECORE_LIST_FOR_EACH_ENTRY
argument_list|(
argument|pos
argument_list|,
argument|&o->head
argument_list|,
argument|link
argument_list|,
argument|struct ecore_vlan_mac_registry_elem
argument_list|)
block|{
if|if
condition|(
name|counter
operator|<
name|n
condition|)
block|{
name|ECORE_MEMCPY
argument_list|(
name|next
argument_list|,
operator|&
name|pos
operator|->
name|u
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|counter
operator|++
expr_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"copied element number %d to address %p element was:\n"
argument_list|,
name|counter
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|next
operator|+=
name|stride
operator|+
name|size
expr_stmt|;
block|}
block|}
if|if
condition|(
name|read_lock
operator|==
name|ECORE_SUCCESS
condition|)
block|{
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"get_n_elements - releasing vlan_mac_lock (reader)\n"
argument_list|)
expr_stmt|;
name|ecore_vlan_mac_h_read_unlock
argument_list|(
name|sc
argument_list|,
name|o
argument_list|)
expr_stmt|;
block|}
return|return
name|counter
operator|*
name|ETH_ALEN
return|;
block|}
end_function

begin_comment
comment|/* check_add() callbacks */
end_comment

begin_function
specifier|static
name|int
name|ecore_check_mac_add
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
parameter_list|,
name|union
name|ecore_classification_ramrod_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ecore_vlan_mac_registry_elem
modifier|*
name|pos
decl_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"Checking MAC %02x:%02x:%02x:%02x:%02x:%02x for ADD command\n"
argument_list|,
name|data
operator|->
name|mac
operator|.
name|mac
index|[
literal|0
index|]
argument_list|,
name|data
operator|->
name|mac
operator|.
name|mac
index|[
literal|1
index|]
argument_list|,
name|data
operator|->
name|mac
operator|.
name|mac
index|[
literal|2
index|]
argument_list|,
name|data
operator|->
name|mac
operator|.
name|mac
index|[
literal|3
index|]
argument_list|,
name|data
operator|->
name|mac
operator|.
name|mac
index|[
literal|4
index|]
argument_list|,
name|data
operator|->
name|mac
operator|.
name|mac
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ECORE_IS_VALID_ETHER_ADDR
argument_list|(
name|data
operator|->
name|mac
operator|.
name|mac
argument_list|)
condition|)
return|return
name|ECORE_INVAL
return|;
comment|/* Check if a requested MAC already exists */
name|ECORE_LIST_FOR_EACH_ENTRY
argument_list|(
argument|pos
argument_list|,
argument|&o->head
argument_list|,
argument|link
argument_list|,
argument|struct ecore_vlan_mac_registry_elem
argument_list|)
if|if
condition|(
operator|!
name|ECORE_MEMCMP
argument_list|(
name|data
operator|->
name|mac
operator|.
name|mac
argument_list|,
name|pos
operator|->
name|u
operator|.
name|mac
operator|.
name|mac
argument_list|,
name|ETH_ALEN
argument_list|)
operator|&&
operator|(
name|data
operator|->
name|mac
operator|.
name|is_inner_mac
operator|==
name|pos
operator|->
name|u
operator|.
name|mac
operator|.
name|is_inner_mac
operator|)
condition|)
return|return
name|ECORE_EXISTS
return|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ecore_check_vlan_add
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
parameter_list|,
name|union
name|ecore_classification_ramrod_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ecore_vlan_mac_registry_elem
modifier|*
name|pos
decl_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"Checking VLAN %d for ADD command\n"
argument_list|,
name|data
operator|->
name|vlan
operator|.
name|vlan
argument_list|)
expr_stmt|;
name|ECORE_LIST_FOR_EACH_ENTRY
argument_list|(
argument|pos
argument_list|,
argument|&o->head
argument_list|,
argument|link
argument_list|,
argument|struct ecore_vlan_mac_registry_elem
argument_list|)
if|if
condition|(
name|data
operator|->
name|vlan
operator|.
name|vlan
operator|==
name|pos
operator|->
name|u
operator|.
name|vlan
operator|.
name|vlan
condition|)
return|return
name|ECORE_EXISTS
return|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ecore_check_vlan_mac_add
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
parameter_list|,
name|union
name|ecore_classification_ramrod_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ecore_vlan_mac_registry_elem
modifier|*
name|pos
decl_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"Checking VLAN_MAC (%02x:%02x:%02x:%02x:%02x:%02x, %d) for ADD command\n"
argument_list|,
name|data
operator|->
name|vlan_mac
operator|.
name|mac
index|[
literal|0
index|]
argument_list|,
name|data
operator|->
name|vlan_mac
operator|.
name|mac
index|[
literal|1
index|]
argument_list|,
name|data
operator|->
name|vlan_mac
operator|.
name|mac
index|[
literal|2
index|]
argument_list|,
name|data
operator|->
name|vlan_mac
operator|.
name|mac
index|[
literal|3
index|]
argument_list|,
name|data
operator|->
name|vlan_mac
operator|.
name|mac
index|[
literal|4
index|]
argument_list|,
name|data
operator|->
name|vlan_mac
operator|.
name|mac
index|[
literal|5
index|]
argument_list|,
name|data
operator|->
name|vlan_mac
operator|.
name|vlan
argument_list|)
expr_stmt|;
name|ECORE_LIST_FOR_EACH_ENTRY
argument_list|(
argument|pos
argument_list|,
argument|&o->head
argument_list|,
argument|link
argument_list|,
argument|struct ecore_vlan_mac_registry_elem
argument_list|)
if|if
condition|(
operator|(
name|data
operator|->
name|vlan_mac
operator|.
name|vlan
operator|==
name|pos
operator|->
name|u
operator|.
name|vlan_mac
operator|.
name|vlan
operator|)
operator|&&
operator|(
operator|!
name|ECORE_MEMCMP
argument_list|(
name|data
operator|->
name|vlan_mac
operator|.
name|mac
argument_list|,
name|pos
operator|->
name|u
operator|.
name|vlan_mac
operator|.
name|mac
argument_list|,
name|ETH_ALEN
argument_list|)
operator|)
operator|&&
operator|(
name|data
operator|->
name|vlan_mac
operator|.
name|is_inner_mac
operator|==
name|pos
operator|->
name|u
operator|.
name|vlan_mac
operator|.
name|is_inner_mac
operator|)
condition|)
return|return
name|ECORE_EXISTS
return|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* check_del() callbacks */
end_comment

begin_function
specifier|static
name|struct
name|ecore_vlan_mac_registry_elem
modifier|*
name|ecore_check_mac_del
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
parameter_list|,
name|union
name|ecore_classification_ramrod_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ecore_vlan_mac_registry_elem
modifier|*
name|pos
decl_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"Checking MAC %02x:%02x:%02x:%02x:%02x:%02x for DEL command\n"
argument_list|,
name|data
operator|->
name|mac
operator|.
name|mac
index|[
literal|0
index|]
argument_list|,
name|data
operator|->
name|mac
operator|.
name|mac
index|[
literal|1
index|]
argument_list|,
name|data
operator|->
name|mac
operator|.
name|mac
index|[
literal|2
index|]
argument_list|,
name|data
operator|->
name|mac
operator|.
name|mac
index|[
literal|3
index|]
argument_list|,
name|data
operator|->
name|mac
operator|.
name|mac
index|[
literal|4
index|]
argument_list|,
name|data
operator|->
name|mac
operator|.
name|mac
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|ECORE_LIST_FOR_EACH_ENTRY
argument_list|(
argument|pos
argument_list|,
argument|&o->head
argument_list|,
argument|link
argument_list|,
argument|struct ecore_vlan_mac_registry_elem
argument_list|)
if|if
condition|(
operator|(
operator|!
name|ECORE_MEMCMP
argument_list|(
name|data
operator|->
name|mac
operator|.
name|mac
argument_list|,
name|pos
operator|->
name|u
operator|.
name|mac
operator|.
name|mac
argument_list|,
name|ETH_ALEN
argument_list|)
operator|)
operator|&&
operator|(
name|data
operator|->
name|mac
operator|.
name|is_inner_mac
operator|==
name|pos
operator|->
name|u
operator|.
name|mac
operator|.
name|is_inner_mac
operator|)
condition|)
return|return
name|pos
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ecore_vlan_mac_registry_elem
modifier|*
name|ecore_check_vlan_del
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
parameter_list|,
name|union
name|ecore_classification_ramrod_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ecore_vlan_mac_registry_elem
modifier|*
name|pos
decl_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"Checking VLAN %d for DEL command\n"
argument_list|,
name|data
operator|->
name|vlan
operator|.
name|vlan
argument_list|)
expr_stmt|;
name|ECORE_LIST_FOR_EACH_ENTRY
argument_list|(
argument|pos
argument_list|,
argument|&o->head
argument_list|,
argument|link
argument_list|,
argument|struct ecore_vlan_mac_registry_elem
argument_list|)
if|if
condition|(
name|data
operator|->
name|vlan
operator|.
name|vlan
operator|==
name|pos
operator|->
name|u
operator|.
name|vlan
operator|.
name|vlan
condition|)
return|return
name|pos
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ecore_vlan_mac_registry_elem
modifier|*
name|ecore_check_vlan_mac_del
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
parameter_list|,
name|union
name|ecore_classification_ramrod_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ecore_vlan_mac_registry_elem
modifier|*
name|pos
decl_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"Checking VLAN_MAC (%02x:%02x:%02x:%02x:%02x:%02x, %d) for DEL command\n"
argument_list|,
name|data
operator|->
name|vlan_mac
operator|.
name|mac
index|[
literal|0
index|]
argument_list|,
name|data
operator|->
name|vlan_mac
operator|.
name|mac
index|[
literal|1
index|]
argument_list|,
name|data
operator|->
name|vlan_mac
operator|.
name|mac
index|[
literal|2
index|]
argument_list|,
name|data
operator|->
name|vlan_mac
operator|.
name|mac
index|[
literal|3
index|]
argument_list|,
name|data
operator|->
name|vlan_mac
operator|.
name|mac
index|[
literal|4
index|]
argument_list|,
name|data
operator|->
name|vlan_mac
operator|.
name|mac
index|[
literal|5
index|]
argument_list|,
name|data
operator|->
name|vlan_mac
operator|.
name|vlan
argument_list|)
expr_stmt|;
name|ECORE_LIST_FOR_EACH_ENTRY
argument_list|(
argument|pos
argument_list|,
argument|&o->head
argument_list|,
argument|link
argument_list|,
argument|struct ecore_vlan_mac_registry_elem
argument_list|)
if|if
condition|(
operator|(
name|data
operator|->
name|vlan_mac
operator|.
name|vlan
operator|==
name|pos
operator|->
name|u
operator|.
name|vlan_mac
operator|.
name|vlan
operator|)
operator|&&
operator|(
operator|!
name|ECORE_MEMCMP
argument_list|(
name|data
operator|->
name|vlan_mac
operator|.
name|mac
argument_list|,
name|pos
operator|->
name|u
operator|.
name|vlan_mac
operator|.
name|mac
argument_list|,
name|ETH_ALEN
argument_list|)
operator|)
operator|&&
operator|(
name|data
operator|->
name|vlan_mac
operator|.
name|is_inner_mac
operator|==
name|pos
operator|->
name|u
operator|.
name|vlan_mac
operator|.
name|is_inner_mac
operator|)
condition|)
return|return
name|pos
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* check_move() callback */
end_comment

begin_function
specifier|static
name|bool
name|ecore_check_move
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|src_o
parameter_list|,
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|dst_o
parameter_list|,
name|union
name|ecore_classification_ramrod_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ecore_vlan_mac_registry_elem
modifier|*
name|pos
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* Check if we can delete the requested configuration from the first 	 * object. 	 */
name|pos
operator|=
name|src_o
operator|->
name|check_del
argument_list|(
name|sc
argument_list|,
name|src_o
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/*  check if configuration can be added */
name|rc
operator|=
name|dst_o
operator|->
name|check_add
argument_list|(
name|sc
argument_list|,
name|dst_o
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* If this classification can not be added (is already set) 	 * or can't be deleted - return an error. 	 */
if|if
condition|(
name|rc
operator|||
operator|!
name|pos
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ecore_check_move_always_err
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|src_o
parameter_list|,
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|dst_o
parameter_list|,
name|union
name|ecore_classification_ramrod_data
modifier|*
name|data
parameter_list|)
block|{
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint8_t
name|ecore_vlan_mac_get_rx_tx_flag
parameter_list|(
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
parameter_list|)
block|{
name|struct
name|ecore_raw_obj
modifier|*
name|raw
init|=
operator|&
name|o
operator|->
name|raw
decl_stmt|;
name|uint8_t
name|rx_tx_flag
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|raw
operator|->
name|obj_type
operator|==
name|ECORE_OBJ_TYPE_TX
operator|)
operator|||
operator|(
name|raw
operator|->
name|obj_type
operator|==
name|ECORE_OBJ_TYPE_RX_TX
operator|)
condition|)
name|rx_tx_flag
operator||=
name|ETH_CLASSIFY_CMD_HEADER_TX_CMD
expr_stmt|;
if|if
condition|(
operator|(
name|raw
operator|->
name|obj_type
operator|==
name|ECORE_OBJ_TYPE_RX
operator|)
operator|||
operator|(
name|raw
operator|->
name|obj_type
operator|==
name|ECORE_OBJ_TYPE_RX_TX
operator|)
condition|)
name|rx_tx_flag
operator||=
name|ETH_CLASSIFY_CMD_HEADER_RX_CMD
expr_stmt|;
return|return
name|rx_tx_flag
return|;
block|}
end_function

begin_function
name|void
name|ecore_set_mac_in_nig
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|bool
name|add
parameter_list|,
name|unsigned
name|char
modifier|*
name|dev_addr
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|uint32_t
name|wb_data
index|[
literal|2
index|]
decl_stmt|;
name|uint32_t
name|reg_offset
init|=
name|ECORE_PORT_ID
argument_list|(
name|sc
argument_list|)
condition|?
name|NIG_REG_LLH1_FUNC_MEM
else|:
name|NIG_REG_LLH0_FUNC_MEM
decl_stmt|;
if|if
condition|(
operator|!
name|ECORE_IS_MF_SI_MODE
argument_list|(
name|sc
argument_list|)
operator|&&
operator|!
name|IS_MF_AFEX
argument_list|(
name|sc
argument_list|)
condition|)
return|return;
if|if
condition|(
name|index
operator|>
name|ECORE_LLH_CAM_MAX_PF_LINE
condition|)
return|return;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"Going to %s LLH configuration at entry %d\n"
argument_list|,
operator|(
name|add
condition|?
literal|"ADD"
else|:
literal|"DELETE"
operator|)
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|add
condition|)
block|{
comment|/* LLH_FUNC_MEM is a uint64_t WB register */
name|reg_offset
operator|+=
literal|8
operator|*
name|index
expr_stmt|;
name|wb_data
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|dev_addr
index|[
literal|2
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|dev_addr
index|[
literal|3
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|dev_addr
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator||
name|dev_addr
index|[
literal|5
index|]
operator|)
expr_stmt|;
name|wb_data
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|dev_addr
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|dev_addr
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|ECORE_REG_WR_DMAE_LEN
argument_list|(
name|sc
argument_list|,
name|reg_offset
argument_list|,
name|wb_data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|ECORE_PORT_ID
argument_list|(
name|sc
argument_list|)
condition|?
name|NIG_REG_LLH1_FUNC_MEM_ENABLE
else|:
name|NIG_REG_LLH0_FUNC_MEM_ENABLE
operator|)
operator|+
literal|4
operator|*
name|index
argument_list|,
name|add
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ecore_vlan_mac_set_cmd_hdr_e2 - set a header in a single classify ramrod  *  * @sc:		device handle  * @o:		queue for which we want to configure this rule  * @add:	if TRUE the command is an ADD command, DEL otherwise  * @opcode:	CLASSIFY_RULE_OPCODE_XXX  * @hdr:	pointer to a header to setup  *  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ecore_vlan_mac_set_cmd_hdr_e2
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
parameter_list|,
name|bool
name|add
parameter_list|,
name|int
name|opcode
parameter_list|,
name|struct
name|eth_classify_cmd_header
modifier|*
name|hdr
parameter_list|)
block|{
name|struct
name|ecore_raw_obj
modifier|*
name|raw
init|=
operator|&
name|o
operator|->
name|raw
decl_stmt|;
name|hdr
operator|->
name|client_id
operator|=
name|raw
operator|->
name|cl_id
expr_stmt|;
name|hdr
operator|->
name|func_id
operator|=
name|raw
operator|->
name|func_id
expr_stmt|;
comment|/* Rx or/and Tx (internal switching) configuration ? */
name|hdr
operator|->
name|cmd_general_data
operator||=
name|ecore_vlan_mac_get_rx_tx_flag
argument_list|(
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|add
condition|)
name|hdr
operator|->
name|cmd_general_data
operator||=
name|ETH_CLASSIFY_CMD_HEADER_IS_ADD
expr_stmt|;
name|hdr
operator|->
name|cmd_general_data
operator||=
operator|(
name|opcode
operator|<<
name|ETH_CLASSIFY_CMD_HEADER_OPCODE_SHIFT
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ecore_vlan_mac_set_rdata_hdr_e2 - set the classify ramrod data header  *  * @cid:	connection id  * @type:	ECORE_FILTER_XXX_PENDING  * @hdr:	pointer to header to setup  * @rule_cnt:  *  * currently we always configure one rule and echo field to contain a CID and an  * opcode type.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ecore_vlan_mac_set_rdata_hdr_e2
parameter_list|(
name|uint32_t
name|cid
parameter_list|,
name|int
name|type
parameter_list|,
name|struct
name|eth_classify_header
modifier|*
name|hdr
parameter_list|,
name|int
name|rule_cnt
parameter_list|)
block|{
name|hdr
operator|->
name|echo
operator|=
name|ECORE_CPU_TO_LE32
argument_list|(
operator|(
name|cid
operator|&
name|ECORE_SWCID_MASK
operator|)
operator||
operator|(
name|type
operator|<<
name|ECORE_SWCID_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|rule_cnt
operator|=
operator|(
name|uint8_t
operator|)
name|rule_cnt
expr_stmt|;
block|}
end_function

begin_comment
comment|/* hw_config() callbacks */
end_comment

begin_function
specifier|static
name|void
name|ecore_set_one_mac_e2
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
parameter_list|,
name|struct
name|ecore_exeq_elem
modifier|*
name|elem
parameter_list|,
name|int
name|rule_idx
parameter_list|,
name|int
name|cam_offset
parameter_list|)
block|{
name|struct
name|ecore_raw_obj
modifier|*
name|raw
init|=
operator|&
name|o
operator|->
name|raw
decl_stmt|;
name|struct
name|eth_classify_rules_ramrod_data
modifier|*
name|data
init|=
operator|(
expr|struct
name|eth_classify_rules_ramrod_data
operator|*
operator|)
operator|(
name|raw
operator|->
name|rdata
operator|)
decl_stmt|;
name|int
name|rule_cnt
init|=
name|rule_idx
operator|+
literal|1
decl_stmt|,
name|cmd
init|=
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|cmd
decl_stmt|;
name|union
name|eth_classify_rule_cmd
modifier|*
name|rule_entry
init|=
operator|&
name|data
operator|->
name|rules
index|[
name|rule_idx
index|]
decl_stmt|;
name|bool
name|add
init|=
operator|(
name|cmd
operator|==
name|ECORE_VLAN_MAC_ADD
operator|)
condition|?
name|TRUE
else|:
name|FALSE
decl_stmt|;
name|unsigned
name|long
modifier|*
name|vlan_mac_flags
init|=
operator|&
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|vlan_mac_flags
decl_stmt|;
name|uint8_t
modifier|*
name|mac
init|=
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|u
operator|.
name|mac
operator|.
name|mac
decl_stmt|;
comment|/* Set LLH CAM entry: currently only iSCSI and ETH macs are 	 * relevant. In addition, current implementation is tuned for a 	 * single ETH MAC. 	 * 	 * When multiple unicast ETH MACs PF configuration in switch 	 * independent mode is required (NetQ, multiple netdev MACs, 	 * etc.), consider better utilisation of 8 per function MAC 	 * entries in the LLH register. There is also 	 * NIG_REG_P[01]_LLH_FUNC_MEM2 registers that complete the 	 * total number of CAM entries to 16. 	 * 	 * Currently we won't configure NIG for MACs other than a primary ETH 	 * MAC and iSCSI L2 MAC. 	 * 	 * If this MAC is moving from one Queue to another, no need to change 	 * NIG configuration. 	 */
if|if
condition|(
name|cmd
operator|!=
name|ECORE_VLAN_MAC_MOVE
condition|)
block|{
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_ISCSI_ETH_MAC
argument_list|,
name|vlan_mac_flags
argument_list|)
condition|)
name|ecore_set_mac_in_nig
argument_list|(
name|sc
argument_list|,
name|add
argument_list|,
name|mac
argument_list|,
name|ECORE_LLH_CAM_ISCSI_ETH_LINE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_ETH_MAC
argument_list|,
name|vlan_mac_flags
argument_list|)
condition|)
name|ecore_set_mac_in_nig
argument_list|(
name|sc
argument_list|,
name|add
argument_list|,
name|mac
argument_list|,
name|ECORE_LLH_CAM_ETH_LINE
argument_list|)
expr_stmt|;
block|}
comment|/* Reset the ramrod data buffer for the first rule */
if|if
condition|(
name|rule_idx
operator|==
literal|0
condition|)
name|ECORE_MEMSET
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Setup a command header */
name|ecore_vlan_mac_set_cmd_hdr_e2
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
name|add
argument_list|,
name|CLASSIFY_RULE_OPCODE_MAC
argument_list|,
operator|&
name|rule_entry
operator|->
name|mac
operator|.
name|header
argument_list|)
expr_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"About to %s MAC %02x:%02x:%02x:%02x:%02x:%02x for Queue %d\n"
argument_list|,
operator|(
name|add
condition|?
literal|"add"
else|:
literal|"delete"
operator|)
argument_list|,
name|mac
index|[
literal|0
index|]
argument_list|,
name|mac
index|[
literal|1
index|]
argument_list|,
name|mac
index|[
literal|2
index|]
argument_list|,
name|mac
index|[
literal|3
index|]
argument_list|,
name|mac
index|[
literal|4
index|]
argument_list|,
name|mac
index|[
literal|5
index|]
argument_list|,
name|raw
operator|->
name|cl_id
argument_list|)
expr_stmt|;
comment|/* Set a MAC itself */
name|ecore_set_fw_mac_addr
argument_list|(
operator|&
name|rule_entry
operator|->
name|mac
operator|.
name|mac_msb
argument_list|,
operator|&
name|rule_entry
operator|->
name|mac
operator|.
name|mac_mid
argument_list|,
operator|&
name|rule_entry
operator|->
name|mac
operator|.
name|mac_lsb
argument_list|,
name|mac
argument_list|)
expr_stmt|;
name|rule_entry
operator|->
name|mac
operator|.
name|inner_mac
operator|=
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|u
operator|.
name|mac
operator|.
name|is_inner_mac
expr_stmt|;
comment|/* MOVE: Add a rule that will add this MAC to the target Queue */
if|if
condition|(
name|cmd
operator|==
name|ECORE_VLAN_MAC_MOVE
condition|)
block|{
name|rule_entry
operator|++
expr_stmt|;
name|rule_cnt
operator|++
expr_stmt|;
comment|/* Setup ramrod data */
name|ecore_vlan_mac_set_cmd_hdr_e2
argument_list|(
name|sc
argument_list|,
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|target_obj
argument_list|,
name|TRUE
argument_list|,
name|CLASSIFY_RULE_OPCODE_MAC
argument_list|,
operator|&
name|rule_entry
operator|->
name|mac
operator|.
name|header
argument_list|)
expr_stmt|;
comment|/* Set a MAC itself */
name|ecore_set_fw_mac_addr
argument_list|(
operator|&
name|rule_entry
operator|->
name|mac
operator|.
name|mac_msb
argument_list|,
operator|&
name|rule_entry
operator|->
name|mac
operator|.
name|mac_mid
argument_list|,
operator|&
name|rule_entry
operator|->
name|mac
operator|.
name|mac_lsb
argument_list|,
name|mac
argument_list|)
expr_stmt|;
name|rule_entry
operator|->
name|mac
operator|.
name|inner_mac
operator|=
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|u
operator|.
name|mac
operator|.
name|is_inner_mac
expr_stmt|;
block|}
comment|/* Set the ramrod data header */
comment|/* TODO: take this to the higher level in order to prevent multiple 		 writing */
name|ecore_vlan_mac_set_rdata_hdr_e2
argument_list|(
name|raw
operator|->
name|cid
argument_list|,
name|raw
operator|->
name|state
argument_list|,
operator|&
name|data
operator|->
name|header
argument_list|,
name|rule_cnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ecore_vlan_mac_set_rdata_hdr_e1x - set a header in a single classify ramrod  *  * @sc:		device handle  * @o:		queue  * @type:  * @cam_offset:	offset in cam memory  * @hdr:	pointer to a header to setup  *  * E1/E1H  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ecore_vlan_mac_set_rdata_hdr_e1x
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|cam_offset
parameter_list|,
name|struct
name|mac_configuration_hdr
modifier|*
name|hdr
parameter_list|)
block|{
name|struct
name|ecore_raw_obj
modifier|*
name|r
init|=
operator|&
name|o
operator|->
name|raw
decl_stmt|;
name|hdr
operator|->
name|length
operator|=
literal|1
expr_stmt|;
name|hdr
operator|->
name|offset
operator|=
operator|(
name|uint8_t
operator|)
name|cam_offset
expr_stmt|;
name|hdr
operator|->
name|client_id
operator|=
name|ECORE_CPU_TO_LE16
argument_list|(
literal|0xff
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|echo
operator|=
name|ECORE_CPU_TO_LE32
argument_list|(
operator|(
name|r
operator|->
name|cid
operator|&
name|ECORE_SWCID_MASK
operator|)
operator||
operator|(
name|type
operator|<<
name|ECORE_SWCID_SHIFT
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ecore_vlan_mac_set_cfg_entry_e1x
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
parameter_list|,
name|bool
name|add
parameter_list|,
name|int
name|opcode
parameter_list|,
name|uint8_t
modifier|*
name|mac
parameter_list|,
name|uint16_t
name|vlan_id
parameter_list|,
name|struct
name|mac_configuration_entry
modifier|*
name|cfg_entry
parameter_list|)
block|{
name|struct
name|ecore_raw_obj
modifier|*
name|r
init|=
operator|&
name|o
operator|->
name|raw
decl_stmt|;
name|uint32_t
name|cl_bit_vec
init|=
operator|(
literal|1
operator|<<
name|r
operator|->
name|cl_id
operator|)
decl_stmt|;
name|cfg_entry
operator|->
name|clients_bit_vector
operator|=
name|ECORE_CPU_TO_LE32
argument_list|(
name|cl_bit_vec
argument_list|)
expr_stmt|;
name|cfg_entry
operator|->
name|pf_id
operator|=
name|r
operator|->
name|func_id
expr_stmt|;
name|cfg_entry
operator|->
name|vlan_id
operator|=
name|ECORE_CPU_TO_LE16
argument_list|(
name|vlan_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|add
condition|)
block|{
name|ECORE_SET_FLAG
argument_list|(
name|cfg_entry
operator|->
name|flags
argument_list|,
name|MAC_CONFIGURATION_ENTRY_ACTION_TYPE
argument_list|,
name|T_ETH_MAC_COMMAND_SET
argument_list|)
expr_stmt|;
name|ECORE_SET_FLAG
argument_list|(
name|cfg_entry
operator|->
name|flags
argument_list|,
name|MAC_CONFIGURATION_ENTRY_VLAN_FILTERING_MODE
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
comment|/* Set a MAC in a ramrod data */
name|ecore_set_fw_mac_addr
argument_list|(
operator|&
name|cfg_entry
operator|->
name|msb_mac_addr
argument_list|,
operator|&
name|cfg_entry
operator|->
name|middle_mac_addr
argument_list|,
operator|&
name|cfg_entry
operator|->
name|lsb_mac_addr
argument_list|,
name|mac
argument_list|)
expr_stmt|;
block|}
else|else
name|ECORE_SET_FLAG
argument_list|(
name|cfg_entry
operator|->
name|flags
argument_list|,
name|MAC_CONFIGURATION_ENTRY_ACTION_TYPE
argument_list|,
name|T_ETH_MAC_COMMAND_INVALIDATE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ecore_vlan_mac_set_rdata_e1x
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|cam_offset
parameter_list|,
name|bool
name|add
parameter_list|,
name|uint8_t
modifier|*
name|mac
parameter_list|,
name|uint16_t
name|vlan_id
parameter_list|,
name|int
name|opcode
parameter_list|,
name|struct
name|mac_configuration_cmd
modifier|*
name|config
parameter_list|)
block|{
name|struct
name|mac_configuration_entry
modifier|*
name|cfg_entry
init|=
operator|&
name|config
operator|->
name|config_table
index|[
literal|0
index|]
decl_stmt|;
name|struct
name|ecore_raw_obj
modifier|*
name|raw
init|=
operator|&
name|o
operator|->
name|raw
decl_stmt|;
name|ecore_vlan_mac_set_rdata_hdr_e1x
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
name|type
argument_list|,
name|cam_offset
argument_list|,
operator|&
name|config
operator|->
name|hdr
argument_list|)
expr_stmt|;
name|ecore_vlan_mac_set_cfg_entry_e1x
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
name|add
argument_list|,
name|opcode
argument_list|,
name|mac
argument_list|,
name|vlan_id
argument_list|,
name|cfg_entry
argument_list|)
expr_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"%s MAC %02x:%02x:%02x:%02x:%02x:%02x CLID %d CAM offset %d\n"
argument_list|,
operator|(
name|add
condition|?
literal|"setting"
else|:
literal|"clearing"
operator|)
argument_list|,
name|mac
index|[
literal|0
index|]
argument_list|,
name|mac
index|[
literal|1
index|]
argument_list|,
name|mac
index|[
literal|2
index|]
argument_list|,
name|mac
index|[
literal|3
index|]
argument_list|,
name|mac
index|[
literal|4
index|]
argument_list|,
name|mac
index|[
literal|5
index|]
argument_list|,
name|raw
operator|->
name|cl_id
argument_list|,
name|cam_offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ecore_set_one_mac_e1x - fill a single MAC rule ramrod data  *  * @sc:		device handle  * @o:		ecore_vlan_mac_obj  * @elem:	ecore_exeq_elem  * @rule_idx:	rule_idx  * @cam_offset: cam_offset  */
end_comment

begin_function
specifier|static
name|void
name|ecore_set_one_mac_e1x
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
parameter_list|,
name|struct
name|ecore_exeq_elem
modifier|*
name|elem
parameter_list|,
name|int
name|rule_idx
parameter_list|,
name|int
name|cam_offset
parameter_list|)
block|{
name|struct
name|ecore_raw_obj
modifier|*
name|raw
init|=
operator|&
name|o
operator|->
name|raw
decl_stmt|;
name|struct
name|mac_configuration_cmd
modifier|*
name|config
init|=
operator|(
expr|struct
name|mac_configuration_cmd
operator|*
operator|)
operator|(
name|raw
operator|->
name|rdata
operator|)
decl_stmt|;
comment|/* 57710 and 57711 do not support MOVE command, 	 * so it's either ADD or DEL 	 */
name|bool
name|add
init|=
operator|(
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|cmd
operator|==
name|ECORE_VLAN_MAC_ADD
operator|)
condition|?
name|TRUE
else|:
name|FALSE
decl_stmt|;
comment|/* Reset the ramrod data buffer */
name|ECORE_MEMSET
argument_list|(
name|config
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|config
argument_list|)
argument_list|)
expr_stmt|;
name|ecore_vlan_mac_set_rdata_e1x
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
name|raw
operator|->
name|state
argument_list|,
name|cam_offset
argument_list|,
name|add
argument_list|,
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|u
operator|.
name|mac
operator|.
name|mac
argument_list|,
literal|0
argument_list|,
name|ETH_VLAN_FILTER_ANY_VLAN
argument_list|,
name|config
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_set_one_vlan_e2
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
parameter_list|,
name|struct
name|ecore_exeq_elem
modifier|*
name|elem
parameter_list|,
name|int
name|rule_idx
parameter_list|,
name|int
name|cam_offset
parameter_list|)
block|{
name|struct
name|ecore_raw_obj
modifier|*
name|raw
init|=
operator|&
name|o
operator|->
name|raw
decl_stmt|;
name|struct
name|eth_classify_rules_ramrod_data
modifier|*
name|data
init|=
operator|(
expr|struct
name|eth_classify_rules_ramrod_data
operator|*
operator|)
operator|(
name|raw
operator|->
name|rdata
operator|)
decl_stmt|;
name|int
name|rule_cnt
init|=
name|rule_idx
operator|+
literal|1
decl_stmt|;
name|union
name|eth_classify_rule_cmd
modifier|*
name|rule_entry
init|=
operator|&
name|data
operator|->
name|rules
index|[
name|rule_idx
index|]
decl_stmt|;
name|enum
name|ecore_vlan_mac_cmd
name|cmd
init|=
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|cmd
decl_stmt|;
name|bool
name|add
init|=
operator|(
name|cmd
operator|==
name|ECORE_VLAN_MAC_ADD
operator|)
condition|?
name|TRUE
else|:
name|FALSE
decl_stmt|;
name|uint16_t
name|vlan
init|=
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|u
operator|.
name|vlan
operator|.
name|vlan
decl_stmt|;
comment|/* Reset the ramrod data buffer for the first rule */
if|if
condition|(
name|rule_idx
operator|==
literal|0
condition|)
name|ECORE_MEMSET
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set a rule header */
name|ecore_vlan_mac_set_cmd_hdr_e2
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
name|add
argument_list|,
name|CLASSIFY_RULE_OPCODE_VLAN
argument_list|,
operator|&
name|rule_entry
operator|->
name|vlan
operator|.
name|header
argument_list|)
expr_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"About to %s VLAN %d\n"
argument_list|,
operator|(
name|add
condition|?
literal|"add"
else|:
literal|"delete"
operator|)
argument_list|,
name|vlan
argument_list|)
expr_stmt|;
comment|/* Set a VLAN itself */
name|rule_entry
operator|->
name|vlan
operator|.
name|vlan
operator|=
name|ECORE_CPU_TO_LE16
argument_list|(
name|vlan
argument_list|)
expr_stmt|;
comment|/* MOVE: Add a rule that will add this MAC to the target Queue */
if|if
condition|(
name|cmd
operator|==
name|ECORE_VLAN_MAC_MOVE
condition|)
block|{
name|rule_entry
operator|++
expr_stmt|;
name|rule_cnt
operator|++
expr_stmt|;
comment|/* Setup ramrod data */
name|ecore_vlan_mac_set_cmd_hdr_e2
argument_list|(
name|sc
argument_list|,
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|target_obj
argument_list|,
name|TRUE
argument_list|,
name|CLASSIFY_RULE_OPCODE_VLAN
argument_list|,
operator|&
name|rule_entry
operator|->
name|vlan
operator|.
name|header
argument_list|)
expr_stmt|;
comment|/* Set a VLAN itself */
name|rule_entry
operator|->
name|vlan
operator|.
name|vlan
operator|=
name|ECORE_CPU_TO_LE16
argument_list|(
name|vlan
argument_list|)
expr_stmt|;
block|}
comment|/* Set the ramrod data header */
comment|/* TODO: take this to the higher level in order to prevent multiple 		 writing */
name|ecore_vlan_mac_set_rdata_hdr_e2
argument_list|(
name|raw
operator|->
name|cid
argument_list|,
name|raw
operator|->
name|state
argument_list|,
operator|&
name|data
operator|->
name|header
argument_list|,
name|rule_cnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_set_one_vlan_mac_e2
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
parameter_list|,
name|struct
name|ecore_exeq_elem
modifier|*
name|elem
parameter_list|,
name|int
name|rule_idx
parameter_list|,
name|int
name|cam_offset
parameter_list|)
block|{
name|struct
name|ecore_raw_obj
modifier|*
name|raw
init|=
operator|&
name|o
operator|->
name|raw
decl_stmt|;
name|struct
name|eth_classify_rules_ramrod_data
modifier|*
name|data
init|=
operator|(
expr|struct
name|eth_classify_rules_ramrod_data
operator|*
operator|)
operator|(
name|raw
operator|->
name|rdata
operator|)
decl_stmt|;
name|int
name|rule_cnt
init|=
name|rule_idx
operator|+
literal|1
decl_stmt|;
name|union
name|eth_classify_rule_cmd
modifier|*
name|rule_entry
init|=
operator|&
name|data
operator|->
name|rules
index|[
name|rule_idx
index|]
decl_stmt|;
name|enum
name|ecore_vlan_mac_cmd
name|cmd
init|=
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|cmd
decl_stmt|;
name|bool
name|add
init|=
operator|(
name|cmd
operator|==
name|ECORE_VLAN_MAC_ADD
operator|)
condition|?
name|TRUE
else|:
name|FALSE
decl_stmt|;
name|uint16_t
name|vlan
init|=
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|u
operator|.
name|vlan_mac
operator|.
name|vlan
decl_stmt|;
name|uint8_t
modifier|*
name|mac
init|=
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|u
operator|.
name|vlan_mac
operator|.
name|mac
decl_stmt|;
comment|/* Reset the ramrod data buffer for the first rule */
if|if
condition|(
name|rule_idx
operator|==
literal|0
condition|)
name|ECORE_MEMSET
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set a rule header */
name|ecore_vlan_mac_set_cmd_hdr_e2
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
name|add
argument_list|,
name|CLASSIFY_RULE_OPCODE_PAIR
argument_list|,
operator|&
name|rule_entry
operator|->
name|pair
operator|.
name|header
argument_list|)
expr_stmt|;
comment|/* Set VLAN and MAC themselves */
name|rule_entry
operator|->
name|pair
operator|.
name|vlan
operator|=
name|ECORE_CPU_TO_LE16
argument_list|(
name|vlan
argument_list|)
expr_stmt|;
name|ecore_set_fw_mac_addr
argument_list|(
operator|&
name|rule_entry
operator|->
name|pair
operator|.
name|mac_msb
argument_list|,
operator|&
name|rule_entry
operator|->
name|pair
operator|.
name|mac_mid
argument_list|,
operator|&
name|rule_entry
operator|->
name|pair
operator|.
name|mac_lsb
argument_list|,
name|mac
argument_list|)
expr_stmt|;
name|rule_entry
operator|->
name|pair
operator|.
name|inner_mac
operator|=
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|u
operator|.
name|vlan_mac
operator|.
name|is_inner_mac
expr_stmt|;
comment|/* MOVE: Add a rule that will add this MAC to the target Queue */
if|if
condition|(
name|cmd
operator|==
name|ECORE_VLAN_MAC_MOVE
condition|)
block|{
name|rule_entry
operator|++
expr_stmt|;
name|rule_cnt
operator|++
expr_stmt|;
comment|/* Setup ramrod data */
name|ecore_vlan_mac_set_cmd_hdr_e2
argument_list|(
name|sc
argument_list|,
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|target_obj
argument_list|,
name|TRUE
argument_list|,
name|CLASSIFY_RULE_OPCODE_PAIR
argument_list|,
operator|&
name|rule_entry
operator|->
name|pair
operator|.
name|header
argument_list|)
expr_stmt|;
comment|/* Set a VLAN itself */
name|rule_entry
operator|->
name|pair
operator|.
name|vlan
operator|=
name|ECORE_CPU_TO_LE16
argument_list|(
name|vlan
argument_list|)
expr_stmt|;
name|ecore_set_fw_mac_addr
argument_list|(
operator|&
name|rule_entry
operator|->
name|pair
operator|.
name|mac_msb
argument_list|,
operator|&
name|rule_entry
operator|->
name|pair
operator|.
name|mac_mid
argument_list|,
operator|&
name|rule_entry
operator|->
name|pair
operator|.
name|mac_lsb
argument_list|,
name|mac
argument_list|)
expr_stmt|;
name|rule_entry
operator|->
name|pair
operator|.
name|inner_mac
operator|=
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|u
operator|.
name|vlan_mac
operator|.
name|is_inner_mac
expr_stmt|;
block|}
comment|/* Set the ramrod data header */
comment|/* TODO: take this to the higher level in order to prevent multiple 		 writing */
name|ecore_vlan_mac_set_rdata_hdr_e2
argument_list|(
name|raw
operator|->
name|cid
argument_list|,
name|raw
operator|->
name|state
argument_list|,
operator|&
name|data
operator|->
name|header
argument_list|,
name|rule_cnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ecore_set_one_vlan_mac_e1h -  *  * @sc:		device handle  * @o:		ecore_vlan_mac_obj  * @elem:	ecore_exeq_elem  * @rule_idx:	rule_idx  * @cam_offset:	cam_offset  */
end_comment

begin_function
specifier|static
name|void
name|ecore_set_one_vlan_mac_e1h
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
parameter_list|,
name|struct
name|ecore_exeq_elem
modifier|*
name|elem
parameter_list|,
name|int
name|rule_idx
parameter_list|,
name|int
name|cam_offset
parameter_list|)
block|{
name|struct
name|ecore_raw_obj
modifier|*
name|raw
init|=
operator|&
name|o
operator|->
name|raw
decl_stmt|;
name|struct
name|mac_configuration_cmd
modifier|*
name|config
init|=
operator|(
expr|struct
name|mac_configuration_cmd
operator|*
operator|)
operator|(
name|raw
operator|->
name|rdata
operator|)
decl_stmt|;
comment|/* 57710 and 57711 do not support MOVE command, 	 * so it's either ADD or DEL 	 */
name|bool
name|add
init|=
operator|(
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|cmd
operator|==
name|ECORE_VLAN_MAC_ADD
operator|)
condition|?
name|TRUE
else|:
name|FALSE
decl_stmt|;
comment|/* Reset the ramrod data buffer */
name|ECORE_MEMSET
argument_list|(
name|config
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|config
argument_list|)
argument_list|)
expr_stmt|;
name|ecore_vlan_mac_set_rdata_e1x
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
name|ECORE_FILTER_VLAN_MAC_PENDING
argument_list|,
name|cam_offset
argument_list|,
name|add
argument_list|,
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|u
operator|.
name|vlan_mac
operator|.
name|mac
argument_list|,
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|u
operator|.
name|vlan_mac
operator|.
name|vlan
argument_list|,
name|ETH_VLAN_FILTER_CLASSIFY
argument_list|,
name|config
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|list_next_entry
parameter_list|(
name|pos
parameter_list|,
name|member
parameter_list|)
define|\
value|list_entry((pos)->member.next, typeof(*(pos)), member)
end_define

begin_comment
comment|/**  * ecore_vlan_mac_restore - reconfigure next MAC/VLAN/VLAN-MAC element  *  * @sc:		device handle  * @p:		command parameters  * @ppos:	pointer to the cookie  *  * reconfigure next MAC/VLAN/VLAN-MAC element from the  * previously configured elements list.  *  * from command parameters only RAMROD_COMP_WAIT bit in ramrod_flags is	taken  * into an account  *  * pointer to the cookie  - that should be given back in the next call to make  * function handle the next element. If *ppos is set to NULL it will restart the  * iterator. If returned *ppos == NULL this means that the last element has been  * handled.  *  */
end_comment

begin_function
specifier|static
name|int
name|ecore_vlan_mac_restore
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_vlan_mac_ramrod_params
modifier|*
name|p
parameter_list|,
name|struct
name|ecore_vlan_mac_registry_elem
modifier|*
modifier|*
name|ppos
parameter_list|)
block|{
name|struct
name|ecore_vlan_mac_registry_elem
modifier|*
name|pos
decl_stmt|;
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
init|=
name|p
operator|->
name|vlan_mac_obj
decl_stmt|;
comment|/* If list is empty - there is nothing to do here */
if|if
condition|(
name|ECORE_LIST_IS_EMPTY
argument_list|(
operator|&
name|o
operator|->
name|head
argument_list|)
condition|)
block|{
operator|*
name|ppos
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* make a step... */
if|if
condition|(
operator|*
name|ppos
operator|==
name|NULL
condition|)
operator|*
name|ppos
operator|=
name|ECORE_LIST_FIRST_ENTRY
argument_list|(
operator|&
name|o
operator|->
name|head
argument_list|,
expr|struct
name|ecore_vlan_mac_registry_elem
argument_list|,
name|link
argument_list|)
expr_stmt|;
else|else
operator|*
name|ppos
operator|=
name|ECORE_LIST_NEXT
argument_list|(
operator|*
name|ppos
argument_list|,
name|link
argument_list|,
expr|struct
name|ecore_vlan_mac_registry_elem
argument_list|)
expr_stmt|;
name|pos
operator|=
operator|*
name|ppos
expr_stmt|;
comment|/* If it's the last step - return NULL */
if|if
condition|(
name|ECORE_LIST_IS_LAST
argument_list|(
operator|&
name|pos
operator|->
name|link
argument_list|,
operator|&
name|o
operator|->
name|head
argument_list|)
condition|)
operator|*
name|ppos
operator|=
name|NULL
expr_stmt|;
comment|/* Prepare a 'user_req' */
name|ECORE_MEMCPY
argument_list|(
operator|&
name|p
operator|->
name|user_req
operator|.
name|u
argument_list|,
operator|&
name|pos
operator|->
name|u
argument_list|,
sizeof|sizeof
argument_list|(
name|pos
operator|->
name|u
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the command */
name|p
operator|->
name|user_req
operator|.
name|cmd
operator|=
name|ECORE_VLAN_MAC_ADD
expr_stmt|;
comment|/* Set vlan_mac_flags */
name|p
operator|->
name|user_req
operator|.
name|vlan_mac_flags
operator|=
name|pos
operator|->
name|vlan_mac_flags
expr_stmt|;
comment|/* Set a restore bit */
name|ECORE_SET_BIT_NA
argument_list|(
name|RAMROD_RESTORE
argument_list|,
operator|&
name|p
operator|->
name|ramrod_flags
argument_list|)
expr_stmt|;
return|return
name|ecore_config_vlan_mac
argument_list|(
name|sc
argument_list|,
name|p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ecore_exeq_get_mac/ecore_exeq_get_vlan/ecore_exeq_get_vlan_mac return a  * pointer to an element with a specific criteria and NULL if such an element  * hasn't been found.  */
end_comment

begin_function
specifier|static
name|struct
name|ecore_exeq_elem
modifier|*
name|ecore_exeq_get_mac
parameter_list|(
name|struct
name|ecore_exe_queue_obj
modifier|*
name|o
parameter_list|,
name|struct
name|ecore_exeq_elem
modifier|*
name|elem
parameter_list|)
block|{
name|struct
name|ecore_exeq_elem
modifier|*
name|pos
decl_stmt|;
name|struct
name|ecore_mac_ramrod_data
modifier|*
name|data
init|=
operator|&
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|u
operator|.
name|mac
decl_stmt|;
comment|/* Check pending for execution commands */
name|ECORE_LIST_FOR_EACH_ENTRY
argument_list|(
argument|pos
argument_list|,
argument|&o->exe_queue
argument_list|,
argument|link
argument_list|,
argument|struct ecore_exeq_elem
argument_list|)
if|if
condition|(
operator|!
name|ECORE_MEMCMP
argument_list|(
operator|&
name|pos
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|u
operator|.
name|mac
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
argument_list|)
operator|&&
operator|(
name|pos
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|cmd
operator|==
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|cmd
operator|)
condition|)
return|return
name|pos
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ecore_exeq_elem
modifier|*
name|ecore_exeq_get_vlan
parameter_list|(
name|struct
name|ecore_exe_queue_obj
modifier|*
name|o
parameter_list|,
name|struct
name|ecore_exeq_elem
modifier|*
name|elem
parameter_list|)
block|{
name|struct
name|ecore_exeq_elem
modifier|*
name|pos
decl_stmt|;
name|struct
name|ecore_vlan_ramrod_data
modifier|*
name|data
init|=
operator|&
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|u
operator|.
name|vlan
decl_stmt|;
comment|/* Check pending for execution commands */
name|ECORE_LIST_FOR_EACH_ENTRY
argument_list|(
argument|pos
argument_list|,
argument|&o->exe_queue
argument_list|,
argument|link
argument_list|,
argument|struct ecore_exeq_elem
argument_list|)
if|if
condition|(
operator|!
name|ECORE_MEMCMP
argument_list|(
operator|&
name|pos
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|u
operator|.
name|vlan
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
argument_list|)
operator|&&
operator|(
name|pos
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|cmd
operator|==
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|cmd
operator|)
condition|)
return|return
name|pos
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ecore_exeq_elem
modifier|*
name|ecore_exeq_get_vlan_mac
parameter_list|(
name|struct
name|ecore_exe_queue_obj
modifier|*
name|o
parameter_list|,
name|struct
name|ecore_exeq_elem
modifier|*
name|elem
parameter_list|)
block|{
name|struct
name|ecore_exeq_elem
modifier|*
name|pos
decl_stmt|;
name|struct
name|ecore_vlan_mac_ramrod_data
modifier|*
name|data
init|=
operator|&
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|u
operator|.
name|vlan_mac
decl_stmt|;
comment|/* Check pending for execution commands */
name|ECORE_LIST_FOR_EACH_ENTRY
argument_list|(
argument|pos
argument_list|,
argument|&o->exe_queue
argument_list|,
argument|link
argument_list|,
argument|struct ecore_exeq_elem
argument_list|)
if|if
condition|(
operator|!
name|ECORE_MEMCMP
argument_list|(
operator|&
name|pos
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|u
operator|.
name|vlan_mac
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
argument_list|)
operator|&&
operator|(
name|pos
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|cmd
operator|==
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|cmd
operator|)
condition|)
return|return
name|pos
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * ecore_validate_vlan_mac_add - check if an ADD command can be executed  *  * @sc:		device handle  * @qo:		ecore_qable_obj  * @elem:	ecore_exeq_elem  *  * Checks that the requested configuration can be added. If yes and if  * requested, consume CAM credit.  *  * The 'validate' is run after the 'optimize'.  *  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ecore_validate_vlan_mac_add
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|union
name|ecore_qable_obj
modifier|*
name|qo
parameter_list|,
name|struct
name|ecore_exeq_elem
modifier|*
name|elem
parameter_list|)
block|{
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
init|=
operator|&
name|qo
operator|->
name|vlan_mac
decl_stmt|;
name|struct
name|ecore_exe_queue_obj
modifier|*
name|exeq
init|=
operator|&
name|o
operator|->
name|exe_queue
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* Check the registry */
name|rc
operator|=
name|o
operator|->
name|check_add
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
operator|&
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"ADD command is not allowed considering current registry state.\n"
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
comment|/* Check if there is a pending ADD command for this 	 * MAC/VLAN/VLAN-MAC. Return an error if there is. 	 */
if|if
condition|(
name|exeq
operator|->
name|get
argument_list|(
name|exeq
argument_list|,
name|elem
argument_list|)
condition|)
block|{
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"There is a pending ADD command already\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_EXISTS
return|;
block|}
comment|/* TODO: Check the pending MOVE from other objects where this 	 * object is a destination object. 	 */
comment|/* Consume the credit if not requested not to */
if|if
condition|(
operator|!
operator|(
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_DONT_CONSUME_CAM_CREDIT
argument_list|,
operator|&
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|vlan_mac_flags
argument_list|)
operator|||
name|o
operator|->
name|get_credit
argument_list|(
name|o
argument_list|)
operator|)
condition|)
return|return
name|ECORE_INVAL
return|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * ecore_validate_vlan_mac_del - check if the DEL command can be executed  *  * @sc:		device handle  * @qo:		quable object to check  * @elem:	element that needs to be deleted  *  * Checks that the requested configuration can be deleted. If yes and if  * requested, returns a CAM credit.  *  * The 'validate' is run after the 'optimize'.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ecore_validate_vlan_mac_del
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|union
name|ecore_qable_obj
modifier|*
name|qo
parameter_list|,
name|struct
name|ecore_exeq_elem
modifier|*
name|elem
parameter_list|)
block|{
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
init|=
operator|&
name|qo
operator|->
name|vlan_mac
decl_stmt|;
name|struct
name|ecore_vlan_mac_registry_elem
modifier|*
name|pos
decl_stmt|;
name|struct
name|ecore_exe_queue_obj
modifier|*
name|exeq
init|=
operator|&
name|o
operator|->
name|exe_queue
decl_stmt|;
name|struct
name|ecore_exeq_elem
name|query_elem
decl_stmt|;
comment|/* If this classification can not be deleted (doesn't exist) 	 * - return a ECORE_EXIST. 	 */
name|pos
operator|=
name|o
operator|->
name|check_del
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
operator|&
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pos
condition|)
block|{
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"DEL command is not allowed considering current registry state\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_EXISTS
return|;
block|}
comment|/* Check if there are pending DEL or MOVE commands for this 	 * MAC/VLAN/VLAN-MAC. Return an error if so. 	 */
name|ECORE_MEMCPY
argument_list|(
operator|&
name|query_elem
argument_list|,
name|elem
argument_list|,
sizeof|sizeof
argument_list|(
name|query_elem
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check for MOVE commands */
name|query_elem
operator|.
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|cmd
operator|=
name|ECORE_VLAN_MAC_MOVE
expr_stmt|;
if|if
condition|(
name|exeq
operator|->
name|get
argument_list|(
name|exeq
argument_list|,
operator|&
name|query_elem
argument_list|)
condition|)
block|{
name|ECORE_ERR
argument_list|(
literal|"There is a pending MOVE command already\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
comment|/* Check for DEL commands */
if|if
condition|(
name|exeq
operator|->
name|get
argument_list|(
name|exeq
argument_list|,
name|elem
argument_list|)
condition|)
block|{
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"There is a pending DEL command already\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_EXISTS
return|;
block|}
comment|/* Return the credit to the credit pool if not requested not to */
if|if
condition|(
operator|!
operator|(
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_DONT_CONSUME_CAM_CREDIT
argument_list|,
operator|&
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|vlan_mac_flags
argument_list|)
operator|||
name|o
operator|->
name|put_credit
argument_list|(
name|o
argument_list|)
operator|)
condition|)
block|{
name|ECORE_ERR
argument_list|(
literal|"Failed to return a credit\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * ecore_validate_vlan_mac_move - check if the MOVE command can be executed  *  * @sc:		device handle  * @qo:		quable object to check (source)  * @elem:	element that needs to be moved  *  * Checks that the requested configuration can be moved. If yes and if  * requested, returns a CAM credit.  *  * The 'validate' is run after the 'optimize'.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ecore_validate_vlan_mac_move
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|union
name|ecore_qable_obj
modifier|*
name|qo
parameter_list|,
name|struct
name|ecore_exeq_elem
modifier|*
name|elem
parameter_list|)
block|{
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|src_o
init|=
operator|&
name|qo
operator|->
name|vlan_mac
decl_stmt|;
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|dest_o
init|=
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|target_obj
decl_stmt|;
name|struct
name|ecore_exeq_elem
name|query_elem
decl_stmt|;
name|struct
name|ecore_exe_queue_obj
modifier|*
name|src_exeq
init|=
operator|&
name|src_o
operator|->
name|exe_queue
decl_stmt|;
name|struct
name|ecore_exe_queue_obj
modifier|*
name|dest_exeq
init|=
operator|&
name|dest_o
operator|->
name|exe_queue
decl_stmt|;
comment|/* Check if we can perform this operation based on the current registry 	 * state. 	 */
if|if
condition|(
operator|!
name|src_o
operator|->
name|check_move
argument_list|(
name|sc
argument_list|,
name|src_o
argument_list|,
name|dest_o
argument_list|,
operator|&
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|u
argument_list|)
condition|)
block|{
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"MOVE command is not allowed considering current registry state\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
comment|/* Check if there is an already pending DEL or MOVE command for the 	 * source object or ADD command for a destination object. Return an 	 * error if so. 	 */
name|ECORE_MEMCPY
argument_list|(
operator|&
name|query_elem
argument_list|,
name|elem
argument_list|,
sizeof|sizeof
argument_list|(
name|query_elem
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check DEL on source */
name|query_elem
operator|.
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|cmd
operator|=
name|ECORE_VLAN_MAC_DEL
expr_stmt|;
if|if
condition|(
name|src_exeq
operator|->
name|get
argument_list|(
name|src_exeq
argument_list|,
operator|&
name|query_elem
argument_list|)
condition|)
block|{
name|ECORE_ERR
argument_list|(
literal|"There is a pending DEL command on the source queue already\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
comment|/* Check MOVE on source */
if|if
condition|(
name|src_exeq
operator|->
name|get
argument_list|(
name|src_exeq
argument_list|,
name|elem
argument_list|)
condition|)
block|{
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"There is a pending MOVE command already\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_EXISTS
return|;
block|}
comment|/* Check ADD on destination */
name|query_elem
operator|.
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|cmd
operator|=
name|ECORE_VLAN_MAC_ADD
expr_stmt|;
if|if
condition|(
name|dest_exeq
operator|->
name|get
argument_list|(
name|dest_exeq
argument_list|,
operator|&
name|query_elem
argument_list|)
condition|)
block|{
name|ECORE_ERR
argument_list|(
literal|"There is a pending ADD command on the destination queue already\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
comment|/* Consume the credit if not requested not to */
if|if
condition|(
operator|!
operator|(
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_DONT_CONSUME_CAM_CREDIT_DEST
argument_list|,
operator|&
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|vlan_mac_flags
argument_list|)
operator|||
name|dest_o
operator|->
name|get_credit
argument_list|(
name|dest_o
argument_list|)
operator|)
condition|)
return|return
name|ECORE_INVAL
return|;
if|if
condition|(
operator|!
operator|(
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_DONT_CONSUME_CAM_CREDIT
argument_list|,
operator|&
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|vlan_mac_flags
argument_list|)
operator|||
name|src_o
operator|->
name|put_credit
argument_list|(
name|src_o
argument_list|)
operator|)
condition|)
block|{
comment|/* return the credit taken from dest... */
name|dest_o
operator|->
name|put_credit
argument_list|(
name|dest_o
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ecore_validate_vlan_mac
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|union
name|ecore_qable_obj
modifier|*
name|qo
parameter_list|,
name|struct
name|ecore_exeq_elem
modifier|*
name|elem
parameter_list|)
block|{
switch|switch
condition|(
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|cmd
condition|)
block|{
case|case
name|ECORE_VLAN_MAC_ADD
case|:
return|return
name|ecore_validate_vlan_mac_add
argument_list|(
name|sc
argument_list|,
name|qo
argument_list|,
name|elem
argument_list|)
return|;
case|case
name|ECORE_VLAN_MAC_DEL
case|:
return|return
name|ecore_validate_vlan_mac_del
argument_list|(
name|sc
argument_list|,
name|qo
argument_list|,
name|elem
argument_list|)
return|;
case|case
name|ECORE_VLAN_MAC_MOVE
case|:
return|return
name|ecore_validate_vlan_mac_move
argument_list|(
name|sc
argument_list|,
name|qo
argument_list|,
name|elem
argument_list|)
return|;
default|default:
return|return
name|ECORE_INVAL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ecore_remove_vlan_mac
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|union
name|ecore_qable_obj
modifier|*
name|qo
parameter_list|,
name|struct
name|ecore_exeq_elem
modifier|*
name|elem
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
comment|/* If consumption wasn't required, nothing to do */
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_DONT_CONSUME_CAM_CREDIT
argument_list|,
operator|&
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|vlan_mac_flags
argument_list|)
condition|)
return|return
name|ECORE_SUCCESS
return|;
switch|switch
condition|(
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|cmd
condition|)
block|{
case|case
name|ECORE_VLAN_MAC_ADD
case|:
case|case
name|ECORE_VLAN_MAC_MOVE
case|:
name|rc
operator|=
name|qo
operator|->
name|vlan_mac
operator|.
name|put_credit
argument_list|(
operator|&
name|qo
operator|->
name|vlan_mac
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECORE_VLAN_MAC_DEL
case|:
name|rc
operator|=
name|qo
operator|->
name|vlan_mac
operator|.
name|get_credit
argument_list|(
operator|&
name|qo
operator|->
name|vlan_mac
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|ECORE_INVAL
return|;
block|}
if|if
condition|(
name|rc
operator|!=
name|TRUE
condition|)
return|return
name|ECORE_INVAL
return|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * ecore_wait_vlan_mac - passively wait for 5 seconds until all work completes.  *  * @sc:		device handle  * @o:		ecore_vlan_mac_obj  *  */
end_comment

begin_function
specifier|static
name|int
name|ecore_wait_vlan_mac
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
parameter_list|)
block|{
name|int
name|cnt
init|=
literal|5000
decl_stmt|,
name|rc
decl_stmt|;
name|struct
name|ecore_exe_queue_obj
modifier|*
name|exeq
init|=
operator|&
name|o
operator|->
name|exe_queue
decl_stmt|;
name|struct
name|ecore_raw_obj
modifier|*
name|raw
init|=
operator|&
name|o
operator|->
name|raw
decl_stmt|;
while|while
condition|(
name|cnt
operator|--
condition|)
block|{
comment|/* Wait for the current command to complete */
name|rc
operator|=
name|raw
operator|->
name|wait_comp
argument_list|(
name|sc
argument_list|,
name|raw
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
comment|/* Wait until there are no pending commands */
if|if
condition|(
operator|!
name|ecore_exe_queue_empty
argument_list|(
name|exeq
argument_list|)
condition|)
name|ECORE_WAIT
argument_list|(
name|sc
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
else|else
return|return
name|ECORE_SUCCESS
return|;
block|}
return|return
name|ECORE_TIMEOUT
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__ecore_vlan_mac_execute_step
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
parameter_list|,
name|unsigned
name|long
modifier|*
name|ramrod_flags
parameter_list|)
block|{
name|int
name|rc
init|=
name|ECORE_SUCCESS
decl_stmt|;
name|ECORE_SPIN_LOCK_BH
argument_list|(
operator|&
name|o
operator|->
name|exe_queue
operator|.
name|lock
argument_list|)
expr_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"vlan_mac_execute_step - trying to take writer lock\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|__ecore_vlan_mac_h_write_trylock
argument_list|(
name|sc
argument_list|,
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ECORE_SUCCESS
condition|)
block|{
name|__ecore_vlan_mac_h_pend
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
operator|*
name|ramrod_flags
argument_list|)
expr_stmt|;
comment|/** Calling function should not diffrentiate between this case 		 *  and the case in which there is already a pending ramrod 		 */
name|rc
operator|=
name|ECORE_PENDING
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
name|ecore_exe_queue_step
argument_list|(
name|sc
argument_list|,
operator|&
name|o
operator|->
name|exe_queue
argument_list|,
name|ramrod_flags
argument_list|)
expr_stmt|;
block|}
name|ECORE_SPIN_UNLOCK_BH
argument_list|(
operator|&
name|o
operator|->
name|exe_queue
operator|.
name|lock
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/**  * ecore_complete_vlan_mac - complete one VLAN-MAC ramrod  *  * @sc:		device handle  * @o:		ecore_vlan_mac_obj  * @cqe:  * @cont:	if TRUE schedule next execution chunk  *  */
end_comment

begin_function
specifier|static
name|int
name|ecore_complete_vlan_mac
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
parameter_list|,
name|union
name|event_ring_elem
modifier|*
name|cqe
parameter_list|,
name|unsigned
name|long
modifier|*
name|ramrod_flags
parameter_list|)
block|{
name|struct
name|ecore_raw_obj
modifier|*
name|r
init|=
operator|&
name|o
operator|->
name|raw
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* Clearing the pending list& raw state should be made 	 * atomically (as execution flow assumes they represent the same) 	 */
name|ECORE_SPIN_LOCK_BH
argument_list|(
operator|&
name|o
operator|->
name|exe_queue
operator|.
name|lock
argument_list|)
expr_stmt|;
comment|/* Reset pending list */
name|__ecore_exe_queue_reset_pending
argument_list|(
name|sc
argument_list|,
operator|&
name|o
operator|->
name|exe_queue
argument_list|)
expr_stmt|;
comment|/* Clear pending */
name|r
operator|->
name|clear_pending
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|ECORE_SPIN_UNLOCK_BH
argument_list|(
operator|&
name|o
operator|->
name|exe_queue
operator|.
name|lock
argument_list|)
expr_stmt|;
comment|/* If ramrod failed this is most likely a SW bug */
if|if
condition|(
name|cqe
operator|->
name|message
operator|.
name|error
condition|)
return|return
name|ECORE_INVAL
return|;
comment|/* Run the next bulk of pending commands if requested */
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|RAMROD_CONT
argument_list|,
name|ramrod_flags
argument_list|)
condition|)
block|{
name|rc
operator|=
name|__ecore_vlan_mac_execute_step
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
name|ramrod_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
return|return
name|rc
return|;
block|}
comment|/* If there is more work to do return PENDING */
if|if
condition|(
operator|!
name|ecore_exe_queue_empty
argument_list|(
operator|&
name|o
operator|->
name|exe_queue
argument_list|)
condition|)
return|return
name|ECORE_PENDING
return|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * ecore_optimize_vlan_mac - optimize ADD and DEL commands.  *  * @sc:		device handle  * @o:		ecore_qable_obj  * @elem:	ecore_exeq_elem  */
end_comment

begin_function
specifier|static
name|int
name|ecore_optimize_vlan_mac
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|union
name|ecore_qable_obj
modifier|*
name|qo
parameter_list|,
name|struct
name|ecore_exeq_elem
modifier|*
name|elem
parameter_list|)
block|{
name|struct
name|ecore_exeq_elem
name|query
decl_stmt|,
modifier|*
name|pos
decl_stmt|;
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
init|=
operator|&
name|qo
operator|->
name|vlan_mac
decl_stmt|;
name|struct
name|ecore_exe_queue_obj
modifier|*
name|exeq
init|=
operator|&
name|o
operator|->
name|exe_queue
decl_stmt|;
name|ECORE_MEMCPY
argument_list|(
operator|&
name|query
argument_list|,
name|elem
argument_list|,
sizeof|sizeof
argument_list|(
name|query
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|cmd
condition|)
block|{
case|case
name|ECORE_VLAN_MAC_ADD
case|:
name|query
operator|.
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|cmd
operator|=
name|ECORE_VLAN_MAC_DEL
expr_stmt|;
break|break;
case|case
name|ECORE_VLAN_MAC_DEL
case|:
name|query
operator|.
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|cmd
operator|=
name|ECORE_VLAN_MAC_ADD
expr_stmt|;
break|break;
default|default:
comment|/* Don't handle anything other than ADD or DEL */
return|return
literal|0
return|;
block|}
comment|/* If we found the appropriate element - delete it */
name|pos
operator|=
name|exeq
operator|->
name|get
argument_list|(
name|exeq
argument_list|,
operator|&
name|query
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
condition|)
block|{
comment|/* Return the credit of the optimized command */
if|if
condition|(
operator|!
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_DONT_CONSUME_CAM_CREDIT
argument_list|,
operator|&
name|pos
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|vlan_mac_flags
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|query
operator|.
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|cmd
operator|==
name|ECORE_VLAN_MAC_ADD
operator|)
operator|&&
operator|!
name|o
operator|->
name|put_credit
argument_list|(
name|o
argument_list|)
condition|)
block|{
name|ECORE_ERR
argument_list|(
literal|"Failed to return the credit for the optimized ADD command\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|o
operator|->
name|get_credit
argument_list|(
name|o
argument_list|)
condition|)
block|{
comment|/* VLAN_MAC_DEL */
name|ECORE_ERR
argument_list|(
literal|"Failed to recover the credit from the optimized DEL command\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
block|}
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"Optimizing %s command\n"
argument_list|,
operator|(
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|cmd
operator|==
name|ECORE_VLAN_MAC_ADD
operator|)
condition|?
literal|"ADD"
else|:
literal|"DEL"
argument_list|)
expr_stmt|;
name|ECORE_LIST_REMOVE_ENTRY
argument_list|(
operator|&
name|pos
operator|->
name|link
argument_list|,
operator|&
name|exeq
operator|->
name|exe_queue
argument_list|)
expr_stmt|;
name|ecore_exe_queue_free_elem
argument_list|(
name|sc
argument_list|,
name|pos
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * ecore_vlan_mac_get_registry_elem - prepare a registry element  *  * @sc:	  device handle  * @o:  * @elem:  * @restore:  * @re:  *  * prepare a registry element according to the current command request.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ecore_vlan_mac_get_registry_elem
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
parameter_list|,
name|struct
name|ecore_exeq_elem
modifier|*
name|elem
parameter_list|,
name|bool
name|restore
parameter_list|,
name|struct
name|ecore_vlan_mac_registry_elem
modifier|*
modifier|*
name|re
parameter_list|)
block|{
name|enum
name|ecore_vlan_mac_cmd
name|cmd
init|=
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|cmd
decl_stmt|;
name|struct
name|ecore_vlan_mac_registry_elem
modifier|*
name|reg_elem
decl_stmt|;
comment|/* Allocate a new registry element if needed. */
if|if
condition|(
operator|!
name|restore
operator|&&
operator|(
operator|(
name|cmd
operator|==
name|ECORE_VLAN_MAC_ADD
operator|)
operator|||
operator|(
name|cmd
operator|==
name|ECORE_VLAN_MAC_MOVE
operator|)
operator|)
condition|)
block|{
name|reg_elem
operator|=
name|ECORE_ZALLOC
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|reg_elem
argument_list|)
argument_list|,
name|GFP_ATOMIC
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reg_elem
condition|)
return|return
name|ECORE_NOMEM
return|;
comment|/* Get a new CAM offset */
if|if
condition|(
operator|!
name|o
operator|->
name|get_cam_offset
argument_list|(
name|o
argument_list|,
operator|&
name|reg_elem
operator|->
name|cam_offset
argument_list|)
condition|)
block|{
comment|/* This shall never happen, because we have checked the 			 * CAM availability in the 'validate'. 			 */
name|ECORE_DBG_BREAK_IF
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ECORE_FREE
argument_list|(
name|sc
argument_list|,
name|reg_elem
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|reg_elem
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"Got cam offset %d\n"
argument_list|,
name|reg_elem
operator|->
name|cam_offset
argument_list|)
expr_stmt|;
comment|/* Set a VLAN-MAC data */
name|ECORE_MEMCPY
argument_list|(
operator|&
name|reg_elem
operator|->
name|u
argument_list|,
operator|&
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|u
argument_list|,
sizeof|sizeof
argument_list|(
name|reg_elem
operator|->
name|u
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy the flags (needed for DEL and RESTORE flows) */
name|reg_elem
operator|->
name|vlan_mac_flags
operator|=
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|vlan_mac_flags
expr_stmt|;
block|}
else|else
comment|/* DEL, RESTORE */
name|reg_elem
operator|=
name|o
operator|->
name|check_del
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
operator|&
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|u
argument_list|)
expr_stmt|;
operator|*
name|re
operator|=
name|reg_elem
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * ecore_execute_vlan_mac - execute vlan mac command  *  * @sc:			device handle  * @qo:  * @exe_chunk:  * @ramrod_flags:  *  * go and send a ramrod!  */
end_comment

begin_function
specifier|static
name|int
name|ecore_execute_vlan_mac
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|union
name|ecore_qable_obj
modifier|*
name|qo
parameter_list|,
name|ecore_list_t
modifier|*
name|exe_chunk
parameter_list|,
name|unsigned
name|long
modifier|*
name|ramrod_flags
parameter_list|)
block|{
name|struct
name|ecore_exeq_elem
modifier|*
name|elem
decl_stmt|;
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
init|=
operator|&
name|qo
operator|->
name|vlan_mac
decl_stmt|,
modifier|*
name|cam_obj
decl_stmt|;
name|struct
name|ecore_raw_obj
modifier|*
name|r
init|=
operator|&
name|o
operator|->
name|raw
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|idx
init|=
literal|0
decl_stmt|;
name|bool
name|restore
init|=
name|ECORE_TEST_BIT
argument_list|(
name|RAMROD_RESTORE
argument_list|,
name|ramrod_flags
argument_list|)
decl_stmt|;
name|bool
name|drv_only
init|=
name|ECORE_TEST_BIT
argument_list|(
name|RAMROD_DRV_CLR_ONLY
argument_list|,
name|ramrod_flags
argument_list|)
decl_stmt|;
name|struct
name|ecore_vlan_mac_registry_elem
modifier|*
name|reg_elem
decl_stmt|;
name|enum
name|ecore_vlan_mac_cmd
name|cmd
decl_stmt|;
comment|/* If DRIVER_ONLY execution is requested, cleanup a registry 	 * and exit. Otherwise send a ramrod to FW. 	 */
if|if
condition|(
operator|!
name|drv_only
condition|)
block|{
name|ECORE_DBG_BREAK_IF
argument_list|(
name|r
operator|->
name|check_pending
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set pending */
name|r
operator|->
name|set_pending
argument_list|(
name|r
argument_list|)
expr_stmt|;
comment|/* Fill the ramrod data */
name|ECORE_LIST_FOR_EACH_ENTRY
argument_list|(
argument|elem
argument_list|,
argument|exe_chunk
argument_list|,
argument|link
argument_list|,
argument|struct ecore_exeq_elem
argument_list|)
block|{
name|cmd
operator|=
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|cmd
expr_stmt|;
comment|/* We will add to the target object in MOVE command, so 			 * change the object for a CAM search. 			 */
if|if
condition|(
name|cmd
operator|==
name|ECORE_VLAN_MAC_MOVE
condition|)
name|cam_obj
operator|=
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|target_obj
expr_stmt|;
else|else
name|cam_obj
operator|=
name|o
expr_stmt|;
name|rc
operator|=
name|ecore_vlan_mac_get_registry_elem
argument_list|(
name|sc
argument_list|,
name|cam_obj
argument_list|,
name|elem
argument_list|,
name|restore
argument_list|,
operator|&
name|reg_elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|error_exit
goto|;
name|ECORE_DBG_BREAK_IF
argument_list|(
operator|!
name|reg_elem
argument_list|)
expr_stmt|;
comment|/* Push a new entry into the registry */
if|if
condition|(
operator|!
name|restore
operator|&&
operator|(
operator|(
name|cmd
operator|==
name|ECORE_VLAN_MAC_ADD
operator|)
operator|||
operator|(
name|cmd
operator|==
name|ECORE_VLAN_MAC_MOVE
operator|)
operator|)
condition|)
name|ECORE_LIST_PUSH_HEAD
argument_list|(
operator|&
name|reg_elem
operator|->
name|link
argument_list|,
operator|&
name|cam_obj
operator|->
name|head
argument_list|)
expr_stmt|;
comment|/* Configure a single command in a ramrod data buffer */
name|o
operator|->
name|set_one_rule
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
name|elem
argument_list|,
name|idx
argument_list|,
name|reg_elem
operator|->
name|cam_offset
argument_list|)
expr_stmt|;
comment|/* MOVE command consumes 2 entries in the ramrod data */
if|if
condition|(
name|cmd
operator|==
name|ECORE_VLAN_MAC_MOVE
condition|)
name|idx
operator|+=
literal|2
expr_stmt|;
else|else
name|idx
operator|++
expr_stmt|;
block|}
comment|/* 		 *  No need for an explicit memory barrier here as long we would 		 *  need to ensure the ordering of writing to the SPQ element 		 *  and updating of the SPQ producer which involves a memory 		 *  read and we will have to put a full memory barrier there 		 *  (inside ecore_sp_post()). 		 */
name|rc
operator|=
name|ecore_sp_post
argument_list|(
name|sc
argument_list|,
name|o
operator|->
name|ramrod_cmd
argument_list|,
name|r
operator|->
name|cid
argument_list|,
name|r
operator|->
name|rdata_mapping
argument_list|,
name|ETH_CONNECTION_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|error_exit
goto|;
block|}
comment|/* Now, when we are done with the ramrod - clean up the registry */
name|ECORE_LIST_FOR_EACH_ENTRY
argument_list|(
argument|elem
argument_list|,
argument|exe_chunk
argument_list|,
argument|link
argument_list|,
argument|struct ecore_exeq_elem
argument_list|)
block|{
name|cmd
operator|=
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|cmd
expr_stmt|;
if|if
condition|(
operator|(
name|cmd
operator|==
name|ECORE_VLAN_MAC_DEL
operator|)
operator|||
operator|(
name|cmd
operator|==
name|ECORE_VLAN_MAC_MOVE
operator|)
condition|)
block|{
name|reg_elem
operator|=
name|o
operator|->
name|check_del
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
operator|&
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|u
argument_list|)
expr_stmt|;
name|ECORE_DBG_BREAK_IF
argument_list|(
operator|!
name|reg_elem
argument_list|)
expr_stmt|;
name|o
operator|->
name|put_cam_offset
argument_list|(
name|o
argument_list|,
name|reg_elem
operator|->
name|cam_offset
argument_list|)
expr_stmt|;
name|ECORE_LIST_REMOVE_ENTRY
argument_list|(
operator|&
name|reg_elem
operator|->
name|link
argument_list|,
operator|&
name|o
operator|->
name|head
argument_list|)
expr_stmt|;
name|ECORE_FREE
argument_list|(
name|sc
argument_list|,
name|reg_elem
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|reg_elem
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|drv_only
condition|)
return|return
name|ECORE_PENDING
return|;
else|else
return|return
name|ECORE_SUCCESS
return|;
name|error_exit
label|:
name|r
operator|->
name|clear_pending
argument_list|(
name|r
argument_list|)
expr_stmt|;
comment|/* Cleanup a registry in case of a failure */
name|ECORE_LIST_FOR_EACH_ENTRY
argument_list|(
argument|elem
argument_list|,
argument|exe_chunk
argument_list|,
argument|link
argument_list|,
argument|struct ecore_exeq_elem
argument_list|)
block|{
name|cmd
operator|=
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|cmd
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|ECORE_VLAN_MAC_MOVE
condition|)
name|cam_obj
operator|=
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|target_obj
expr_stmt|;
else|else
name|cam_obj
operator|=
name|o
expr_stmt|;
comment|/* Delete all newly added above entries */
if|if
condition|(
operator|!
name|restore
operator|&&
operator|(
operator|(
name|cmd
operator|==
name|ECORE_VLAN_MAC_ADD
operator|)
operator|||
operator|(
name|cmd
operator|==
name|ECORE_VLAN_MAC_MOVE
operator|)
operator|)
condition|)
block|{
name|reg_elem
operator|=
name|o
operator|->
name|check_del
argument_list|(
name|sc
argument_list|,
name|cam_obj
argument_list|,
operator|&
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_elem
condition|)
block|{
name|ECORE_LIST_REMOVE_ENTRY
argument_list|(
operator|&
name|reg_elem
operator|->
name|link
argument_list|,
operator|&
name|cam_obj
operator|->
name|head
argument_list|)
expr_stmt|;
name|ECORE_FREE
argument_list|(
name|sc
argument_list|,
name|reg_elem
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|reg_elem
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|ecore_vlan_mac_push_new_cmd
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_vlan_mac_ramrod_params
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ecore_exeq_elem
modifier|*
name|elem
decl_stmt|;
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
init|=
name|p
operator|->
name|vlan_mac_obj
decl_stmt|;
name|bool
name|restore
init|=
name|ECORE_TEST_BIT
argument_list|(
name|RAMROD_RESTORE
argument_list|,
operator|&
name|p
operator|->
name|ramrod_flags
argument_list|)
decl_stmt|;
comment|/* Allocate the execution queue element */
name|elem
operator|=
name|ecore_exe_queue_alloc_elem
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elem
condition|)
return|return
name|ECORE_NOMEM
return|;
comment|/* Set the command 'length' */
switch|switch
condition|(
name|p
operator|->
name|user_req
operator|.
name|cmd
condition|)
block|{
case|case
name|ECORE_VLAN_MAC_MOVE
case|:
name|elem
operator|->
name|cmd_len
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|elem
operator|->
name|cmd_len
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Fill the object specific info */
name|ECORE_MEMCPY
argument_list|(
operator|&
name|elem
operator|->
name|cmd_data
operator|.
name|vlan_mac
argument_list|,
operator|&
name|p
operator|->
name|user_req
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|user_req
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Try to add a new command to the pending list */
return|return
name|ecore_exe_queue_add
argument_list|(
name|sc
argument_list|,
operator|&
name|o
operator|->
name|exe_queue
argument_list|,
name|elem
argument_list|,
name|restore
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ecore_config_vlan_mac - configure VLAN/MAC/VLAN_MAC filtering rules.  *  * @sc:	  device handle  * @p:  *  */
end_comment

begin_function
name|int
name|ecore_config_vlan_mac
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_vlan_mac_ramrod_params
modifier|*
name|p
parameter_list|)
block|{
name|int
name|rc
init|=
name|ECORE_SUCCESS
decl_stmt|;
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
init|=
name|p
operator|->
name|vlan_mac_obj
decl_stmt|;
name|unsigned
name|long
modifier|*
name|ramrod_flags
init|=
operator|&
name|p
operator|->
name|ramrod_flags
decl_stmt|;
name|bool
name|cont
init|=
name|ECORE_TEST_BIT
argument_list|(
name|RAMROD_CONT
argument_list|,
name|ramrod_flags
argument_list|)
decl_stmt|;
name|struct
name|ecore_raw_obj
modifier|*
name|raw
init|=
operator|&
name|o
operator|->
name|raw
decl_stmt|;
comment|/* 	 * Add new elements to the execution list for commands that require it. 	 */
if|if
condition|(
operator|!
name|cont
condition|)
block|{
name|rc
operator|=
name|ecore_vlan_mac_push_new_cmd
argument_list|(
name|sc
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
block|}
comment|/* If nothing will be executed further in this iteration we want to 	 * return PENDING if there are pending commands 	 */
if|if
condition|(
operator|!
name|ecore_exe_queue_empty
argument_list|(
operator|&
name|o
operator|->
name|exe_queue
argument_list|)
condition|)
name|rc
operator|=
name|ECORE_PENDING
expr_stmt|;
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|RAMROD_DRV_CLR_ONLY
argument_list|,
name|ramrod_flags
argument_list|)
condition|)
block|{
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"RAMROD_DRV_CLR_ONLY requested: clearing a pending bit.\n"
argument_list|)
expr_stmt|;
name|raw
operator|->
name|clear_pending
argument_list|(
name|raw
argument_list|)
expr_stmt|;
block|}
comment|/* Execute commands if required */
if|if
condition|(
name|cont
operator|||
name|ECORE_TEST_BIT
argument_list|(
name|RAMROD_EXEC
argument_list|,
name|ramrod_flags
argument_list|)
operator|||
name|ECORE_TEST_BIT
argument_list|(
name|RAMROD_COMP_WAIT
argument_list|,
name|ramrod_flags
argument_list|)
condition|)
block|{
name|rc
operator|=
name|__ecore_vlan_mac_execute_step
argument_list|(
name|sc
argument_list|,
name|p
operator|->
name|vlan_mac_obj
argument_list|,
operator|&
name|p
operator|->
name|ramrod_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
return|return
name|rc
return|;
block|}
comment|/* RAMROD_COMP_WAIT is a superset of RAMROD_EXEC. If it was set 	 * then user want to wait until the last command is done. 	 */
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|RAMROD_COMP_WAIT
argument_list|,
operator|&
name|p
operator|->
name|ramrod_flags
argument_list|)
condition|)
block|{
comment|/* Wait maximum for the current exe_queue length iterations plus 		 * one (for the current pending command). 		 */
name|int
name|max_iterations
init|=
name|ecore_exe_queue_length
argument_list|(
operator|&
name|o
operator|->
name|exe_queue
argument_list|)
operator|+
literal|1
decl_stmt|;
while|while
condition|(
operator|!
name|ecore_exe_queue_empty
argument_list|(
operator|&
name|o
operator|->
name|exe_queue
argument_list|)
operator|&&
name|max_iterations
operator|--
condition|)
block|{
comment|/* Wait for the current command to complete */
name|rc
operator|=
name|raw
operator|->
name|wait_comp
argument_list|(
name|sc
argument_list|,
name|raw
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
comment|/* Make a next step */
name|rc
operator|=
name|__ecore_vlan_mac_execute_step
argument_list|(
name|sc
argument_list|,
name|p
operator|->
name|vlan_mac_obj
argument_list|,
operator|&
name|p
operator|->
name|ramrod_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
return|return
name|rc
return|;
block|}
return|return
name|ECORE_SUCCESS
return|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/**  * ecore_vlan_mac_del_all - delete elements with given vlan_mac_flags spec  *  * @sc:			device handle  * @o:  * @vlan_mac_flags:  * @ramrod_flags:	execution flags to be used for this deletion  *  * if the last operation has completed successfully and there are no  * more elements left, positive value if the last operation has completed  * successfully and there are more previously configured elements, negative  * value is current operation has failed.  */
end_comment

begin_function
specifier|static
name|int
name|ecore_vlan_mac_del_all
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
parameter_list|,
name|unsigned
name|long
modifier|*
name|vlan_mac_flags
parameter_list|,
name|unsigned
name|long
modifier|*
name|ramrod_flags
parameter_list|)
block|{
name|struct
name|ecore_vlan_mac_registry_elem
modifier|*
name|pos
init|=
name|NULL
decl_stmt|;
name|struct
name|ecore_vlan_mac_ramrod_params
name|p
decl_stmt|;
name|struct
name|ecore_exe_queue_obj
modifier|*
name|exeq
init|=
operator|&
name|o
operator|->
name|exe_queue
decl_stmt|;
name|struct
name|ecore_exeq_elem
modifier|*
name|exeq_pos
decl_stmt|,
modifier|*
name|exeq_pos_n
decl_stmt|;
name|int
name|read_lock
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
comment|/* Clear pending commands first */
name|ECORE_SPIN_LOCK_BH
argument_list|(
operator|&
name|exeq
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ECORE_LIST_FOR_EACH_ENTRY_SAFE
argument_list|(
argument|exeq_pos
argument_list|,
argument|exeq_pos_n
argument_list|,
argument|&exeq->exe_queue
argument_list|,
argument|link
argument_list|,
argument|struct ecore_exeq_elem
argument_list|)
block|{
if|if
condition|(
name|exeq_pos
operator|->
name|cmd_data
operator|.
name|vlan_mac
operator|.
name|vlan_mac_flags
operator|==
operator|*
name|vlan_mac_flags
condition|)
block|{
name|rc
operator|=
name|exeq
operator|->
name|remove
argument_list|(
name|sc
argument_list|,
name|exeq
operator|->
name|owner
argument_list|,
name|exeq_pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|ECORE_ERR
argument_list|(
literal|"Failed to remove command\n"
argument_list|)
expr_stmt|;
name|ECORE_SPIN_UNLOCK_BH
argument_list|(
operator|&
name|exeq
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
name|ECORE_LIST_REMOVE_ENTRY
argument_list|(
operator|&
name|exeq_pos
operator|->
name|link
argument_list|,
operator|&
name|exeq
operator|->
name|exe_queue
argument_list|)
expr_stmt|;
name|ecore_exe_queue_free_elem
argument_list|(
name|sc
argument_list|,
name|exeq_pos
argument_list|)
expr_stmt|;
block|}
block|}
name|ECORE_SPIN_UNLOCK_BH
argument_list|(
operator|&
name|exeq
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* Prepare a command request */
name|ECORE_MEMSET
argument_list|(
operator|&
name|p
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|.
name|vlan_mac_obj
operator|=
name|o
expr_stmt|;
name|p
operator|.
name|ramrod_flags
operator|=
operator|*
name|ramrod_flags
expr_stmt|;
name|p
operator|.
name|user_req
operator|.
name|cmd
operator|=
name|ECORE_VLAN_MAC_DEL
expr_stmt|;
comment|/* Add all but the last VLAN-MAC to the execution queue without actually 	 * execution anything. 	 */
name|ECORE_CLEAR_BIT_NA
argument_list|(
name|RAMROD_COMP_WAIT
argument_list|,
operator|&
name|p
operator|.
name|ramrod_flags
argument_list|)
expr_stmt|;
name|ECORE_CLEAR_BIT_NA
argument_list|(
name|RAMROD_EXEC
argument_list|,
operator|&
name|p
operator|.
name|ramrod_flags
argument_list|)
expr_stmt|;
name|ECORE_CLEAR_BIT_NA
argument_list|(
name|RAMROD_CONT
argument_list|,
operator|&
name|p
operator|.
name|ramrod_flags
argument_list|)
expr_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"vlan_mac_del_all -- taking vlan_mac_lock (reader)\n"
argument_list|)
expr_stmt|;
name|read_lock
operator|=
name|ecore_vlan_mac_h_read_lock
argument_list|(
name|sc
argument_list|,
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_lock
operator|!=
name|ECORE_SUCCESS
condition|)
return|return
name|read_lock
return|;
name|ECORE_LIST_FOR_EACH_ENTRY
argument_list|(
argument|pos
argument_list|,
argument|&o->head
argument_list|,
argument|link
argument_list|,
argument|struct ecore_vlan_mac_registry_elem
argument_list|)
block|{
if|if
condition|(
name|pos
operator|->
name|vlan_mac_flags
operator|==
operator|*
name|vlan_mac_flags
condition|)
block|{
name|p
operator|.
name|user_req
operator|.
name|vlan_mac_flags
operator|=
name|pos
operator|->
name|vlan_mac_flags
expr_stmt|;
name|ECORE_MEMCPY
argument_list|(
operator|&
name|p
operator|.
name|user_req
operator|.
name|u
argument_list|,
operator|&
name|pos
operator|->
name|u
argument_list|,
sizeof|sizeof
argument_list|(
name|pos
operator|->
name|u
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ecore_config_vlan_mac
argument_list|(
name|sc
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|ECORE_ERR
argument_list|(
literal|"Failed to add a new DEL command\n"
argument_list|)
expr_stmt|;
name|ecore_vlan_mac_h_read_unlock
argument_list|(
name|sc
argument_list|,
name|o
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
block|}
block|}
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"vlan_mac_del_all -- releasing vlan_mac_lock (reader)\n"
argument_list|)
expr_stmt|;
name|ecore_vlan_mac_h_read_unlock
argument_list|(
name|sc
argument_list|,
name|o
argument_list|)
expr_stmt|;
name|p
operator|.
name|ramrod_flags
operator|=
operator|*
name|ramrod_flags
expr_stmt|;
name|ECORE_SET_BIT_NA
argument_list|(
name|RAMROD_CONT
argument_list|,
operator|&
name|p
operator|.
name|ramrod_flags
argument_list|)
expr_stmt|;
return|return
name|ecore_config_vlan_mac
argument_list|(
name|sc
argument_list|,
operator|&
name|p
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ecore_init_raw_obj
parameter_list|(
name|struct
name|ecore_raw_obj
modifier|*
name|raw
parameter_list|,
name|uint8_t
name|cl_id
parameter_list|,
name|uint32_t
name|cid
parameter_list|,
name|uint8_t
name|func_id
parameter_list|,
name|void
modifier|*
name|rdata
parameter_list|,
name|ecore_dma_addr_t
name|rdata_mapping
parameter_list|,
name|int
name|state
parameter_list|,
name|unsigned
name|long
modifier|*
name|pstate
parameter_list|,
name|ecore_obj_type
name|type
parameter_list|)
block|{
name|raw
operator|->
name|func_id
operator|=
name|func_id
expr_stmt|;
name|raw
operator|->
name|cid
operator|=
name|cid
expr_stmt|;
name|raw
operator|->
name|cl_id
operator|=
name|cl_id
expr_stmt|;
name|raw
operator|->
name|rdata
operator|=
name|rdata
expr_stmt|;
name|raw
operator|->
name|rdata_mapping
operator|=
name|rdata_mapping
expr_stmt|;
name|raw
operator|->
name|state
operator|=
name|state
expr_stmt|;
name|raw
operator|->
name|pstate
operator|=
name|pstate
expr_stmt|;
name|raw
operator|->
name|obj_type
operator|=
name|type
expr_stmt|;
name|raw
operator|->
name|check_pending
operator|=
name|ecore_raw_check_pending
expr_stmt|;
name|raw
operator|->
name|clear_pending
operator|=
name|ecore_raw_clear_pending
expr_stmt|;
name|raw
operator|->
name|set_pending
operator|=
name|ecore_raw_set_pending
expr_stmt|;
name|raw
operator|->
name|wait_comp
operator|=
name|ecore_raw_wait
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ecore_init_vlan_mac_common
parameter_list|(
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|o
parameter_list|,
name|uint8_t
name|cl_id
parameter_list|,
name|uint32_t
name|cid
parameter_list|,
name|uint8_t
name|func_id
parameter_list|,
name|void
modifier|*
name|rdata
parameter_list|,
name|ecore_dma_addr_t
name|rdata_mapping
parameter_list|,
name|int
name|state
parameter_list|,
name|unsigned
name|long
modifier|*
name|pstate
parameter_list|,
name|ecore_obj_type
name|type
parameter_list|,
name|struct
name|ecore_credit_pool_obj
modifier|*
name|macs_pool
parameter_list|,
name|struct
name|ecore_credit_pool_obj
modifier|*
name|vlans_pool
parameter_list|)
block|{
name|ECORE_LIST_INIT
argument_list|(
operator|&
name|o
operator|->
name|head
argument_list|)
expr_stmt|;
name|o
operator|->
name|head_reader
operator|=
literal|0
expr_stmt|;
name|o
operator|->
name|head_exe_request
operator|=
name|FALSE
expr_stmt|;
name|o
operator|->
name|saved_ramrod_flags
operator|=
literal|0
expr_stmt|;
name|o
operator|->
name|macs_pool
operator|=
name|macs_pool
expr_stmt|;
name|o
operator|->
name|vlans_pool
operator|=
name|vlans_pool
expr_stmt|;
name|o
operator|->
name|delete_all
operator|=
name|ecore_vlan_mac_del_all
expr_stmt|;
name|o
operator|->
name|restore
operator|=
name|ecore_vlan_mac_restore
expr_stmt|;
name|o
operator|->
name|complete
operator|=
name|ecore_complete_vlan_mac
expr_stmt|;
name|o
operator|->
name|wait
operator|=
name|ecore_wait_vlan_mac
expr_stmt|;
name|ecore_init_raw_obj
argument_list|(
operator|&
name|o
operator|->
name|raw
argument_list|,
name|cl_id
argument_list|,
name|cid
argument_list|,
name|func_id
argument_list|,
name|rdata
argument_list|,
name|rdata_mapping
argument_list|,
name|state
argument_list|,
name|pstate
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ecore_init_mac_obj
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|mac_obj
parameter_list|,
name|uint8_t
name|cl_id
parameter_list|,
name|uint32_t
name|cid
parameter_list|,
name|uint8_t
name|func_id
parameter_list|,
name|void
modifier|*
name|rdata
parameter_list|,
name|ecore_dma_addr_t
name|rdata_mapping
parameter_list|,
name|int
name|state
parameter_list|,
name|unsigned
name|long
modifier|*
name|pstate
parameter_list|,
name|ecore_obj_type
name|type
parameter_list|,
name|struct
name|ecore_credit_pool_obj
modifier|*
name|macs_pool
parameter_list|)
block|{
name|union
name|ecore_qable_obj
modifier|*
name|qable_obj
init|=
operator|(
expr|union
name|ecore_qable_obj
operator|*
operator|)
name|mac_obj
decl_stmt|;
name|ecore_init_vlan_mac_common
argument_list|(
name|mac_obj
argument_list|,
name|cl_id
argument_list|,
name|cid
argument_list|,
name|func_id
argument_list|,
name|rdata
argument_list|,
name|rdata_mapping
argument_list|,
name|state
argument_list|,
name|pstate
argument_list|,
name|type
argument_list|,
name|macs_pool
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* CAM credit pool handling */
name|mac_obj
operator|->
name|get_credit
operator|=
name|ecore_get_credit_mac
expr_stmt|;
name|mac_obj
operator|->
name|put_credit
operator|=
name|ecore_put_credit_mac
expr_stmt|;
name|mac_obj
operator|->
name|get_cam_offset
operator|=
name|ecore_get_cam_offset_mac
expr_stmt|;
name|mac_obj
operator|->
name|put_cam_offset
operator|=
name|ecore_put_cam_offset_mac
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|mac_obj
operator|->
name|set_one_rule
operator|=
name|ecore_set_one_mac_e1x
expr_stmt|;
name|mac_obj
operator|->
name|check_del
operator|=
name|ecore_check_mac_del
expr_stmt|;
name|mac_obj
operator|->
name|check_add
operator|=
name|ecore_check_mac_add
expr_stmt|;
name|mac_obj
operator|->
name|check_move
operator|=
name|ecore_check_move_always_err
expr_stmt|;
name|mac_obj
operator|->
name|ramrod_cmd
operator|=
name|RAMROD_CMD_ID_ETH_SET_MAC
expr_stmt|;
comment|/* Exe Queue */
name|ecore_exe_queue_init
argument_list|(
name|sc
argument_list|,
operator|&
name|mac_obj
operator|->
name|exe_queue
argument_list|,
literal|1
argument_list|,
name|qable_obj
argument_list|,
name|ecore_validate_vlan_mac
argument_list|,
name|ecore_remove_vlan_mac
argument_list|,
name|ecore_optimize_vlan_mac
argument_list|,
name|ecore_execute_vlan_mac
argument_list|,
name|ecore_exeq_get_mac
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mac_obj
operator|->
name|set_one_rule
operator|=
name|ecore_set_one_mac_e2
expr_stmt|;
name|mac_obj
operator|->
name|check_del
operator|=
name|ecore_check_mac_del
expr_stmt|;
name|mac_obj
operator|->
name|check_add
operator|=
name|ecore_check_mac_add
expr_stmt|;
name|mac_obj
operator|->
name|check_move
operator|=
name|ecore_check_move
expr_stmt|;
name|mac_obj
operator|->
name|ramrod_cmd
operator|=
name|RAMROD_CMD_ID_ETH_CLASSIFICATION_RULES
expr_stmt|;
name|mac_obj
operator|->
name|get_n_elements
operator|=
name|ecore_get_n_elements
expr_stmt|;
comment|/* Exe Queue */
name|ecore_exe_queue_init
argument_list|(
name|sc
argument_list|,
operator|&
name|mac_obj
operator|->
name|exe_queue
argument_list|,
name|CLASSIFY_RULES_COUNT
argument_list|,
name|qable_obj
argument_list|,
name|ecore_validate_vlan_mac
argument_list|,
name|ecore_remove_vlan_mac
argument_list|,
name|ecore_optimize_vlan_mac
argument_list|,
name|ecore_execute_vlan_mac
argument_list|,
name|ecore_exeq_get_mac
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ecore_init_vlan_obj
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|vlan_obj
parameter_list|,
name|uint8_t
name|cl_id
parameter_list|,
name|uint32_t
name|cid
parameter_list|,
name|uint8_t
name|func_id
parameter_list|,
name|void
modifier|*
name|rdata
parameter_list|,
name|ecore_dma_addr_t
name|rdata_mapping
parameter_list|,
name|int
name|state
parameter_list|,
name|unsigned
name|long
modifier|*
name|pstate
parameter_list|,
name|ecore_obj_type
name|type
parameter_list|,
name|struct
name|ecore_credit_pool_obj
modifier|*
name|vlans_pool
parameter_list|)
block|{
name|union
name|ecore_qable_obj
modifier|*
name|qable_obj
init|=
operator|(
expr|union
name|ecore_qable_obj
operator|*
operator|)
name|vlan_obj
decl_stmt|;
name|ecore_init_vlan_mac_common
argument_list|(
name|vlan_obj
argument_list|,
name|cl_id
argument_list|,
name|cid
argument_list|,
name|func_id
argument_list|,
name|rdata
argument_list|,
name|rdata_mapping
argument_list|,
name|state
argument_list|,
name|pstate
argument_list|,
name|type
argument_list|,
name|NULL
argument_list|,
name|vlans_pool
argument_list|)
expr_stmt|;
name|vlan_obj
operator|->
name|get_credit
operator|=
name|ecore_get_credit_vlan
expr_stmt|;
name|vlan_obj
operator|->
name|put_credit
operator|=
name|ecore_put_credit_vlan
expr_stmt|;
name|vlan_obj
operator|->
name|get_cam_offset
operator|=
name|ecore_get_cam_offset_vlan
expr_stmt|;
name|vlan_obj
operator|->
name|put_cam_offset
operator|=
name|ecore_put_cam_offset_vlan
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|ECORE_ERR
argument_list|(
literal|"Do not support chips others than E2 and newer\n"
argument_list|)
expr_stmt|;
name|ECORE_BUG
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|vlan_obj
operator|->
name|set_one_rule
operator|=
name|ecore_set_one_vlan_e2
expr_stmt|;
name|vlan_obj
operator|->
name|check_del
operator|=
name|ecore_check_vlan_del
expr_stmt|;
name|vlan_obj
operator|->
name|check_add
operator|=
name|ecore_check_vlan_add
expr_stmt|;
name|vlan_obj
operator|->
name|check_move
operator|=
name|ecore_check_move
expr_stmt|;
name|vlan_obj
operator|->
name|ramrod_cmd
operator|=
name|RAMROD_CMD_ID_ETH_CLASSIFICATION_RULES
expr_stmt|;
name|vlan_obj
operator|->
name|get_n_elements
operator|=
name|ecore_get_n_elements
expr_stmt|;
comment|/* Exe Queue */
name|ecore_exe_queue_init
argument_list|(
name|sc
argument_list|,
operator|&
name|vlan_obj
operator|->
name|exe_queue
argument_list|,
name|CLASSIFY_RULES_COUNT
argument_list|,
name|qable_obj
argument_list|,
name|ecore_validate_vlan_mac
argument_list|,
name|ecore_remove_vlan_mac
argument_list|,
name|ecore_optimize_vlan_mac
argument_list|,
name|ecore_execute_vlan_mac
argument_list|,
name|ecore_exeq_get_vlan
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ecore_init_vlan_mac_obj
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|vlan_mac_obj
parameter_list|,
name|uint8_t
name|cl_id
parameter_list|,
name|uint32_t
name|cid
parameter_list|,
name|uint8_t
name|func_id
parameter_list|,
name|void
modifier|*
name|rdata
parameter_list|,
name|ecore_dma_addr_t
name|rdata_mapping
parameter_list|,
name|int
name|state
parameter_list|,
name|unsigned
name|long
modifier|*
name|pstate
parameter_list|,
name|ecore_obj_type
name|type
parameter_list|,
name|struct
name|ecore_credit_pool_obj
modifier|*
name|macs_pool
parameter_list|,
name|struct
name|ecore_credit_pool_obj
modifier|*
name|vlans_pool
parameter_list|)
block|{
name|union
name|ecore_qable_obj
modifier|*
name|qable_obj
init|=
operator|(
expr|union
name|ecore_qable_obj
operator|*
operator|)
name|vlan_mac_obj
decl_stmt|;
name|ecore_init_vlan_mac_common
argument_list|(
name|vlan_mac_obj
argument_list|,
name|cl_id
argument_list|,
name|cid
argument_list|,
name|func_id
argument_list|,
name|rdata
argument_list|,
name|rdata_mapping
argument_list|,
name|state
argument_list|,
name|pstate
argument_list|,
name|type
argument_list|,
name|macs_pool
argument_list|,
name|vlans_pool
argument_list|)
expr_stmt|;
comment|/* CAM pool handling */
name|vlan_mac_obj
operator|->
name|get_credit
operator|=
name|ecore_get_credit_vlan_mac
expr_stmt|;
name|vlan_mac_obj
operator|->
name|put_credit
operator|=
name|ecore_put_credit_vlan_mac
expr_stmt|;
comment|/* CAM offset is relevant for 57710 and 57711 chips only which have a 	 * single CAM for both MACs and VLAN-MAC pairs. So the offset 	 * will be taken from MACs' pool object only. 	 */
name|vlan_mac_obj
operator|->
name|get_cam_offset
operator|=
name|ecore_get_cam_offset_mac
expr_stmt|;
name|vlan_mac_obj
operator|->
name|put_cam_offset
operator|=
name|ecore_put_cam_offset_mac
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|ECORE_ERR
argument_list|(
literal|"Do not support chips others than E2\n"
argument_list|)
expr_stmt|;
name|ECORE_BUG
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|vlan_mac_obj
operator|->
name|set_one_rule
operator|=
name|ecore_set_one_vlan_mac_e1h
expr_stmt|;
name|vlan_mac_obj
operator|->
name|check_del
operator|=
name|ecore_check_vlan_mac_del
expr_stmt|;
name|vlan_mac_obj
operator|->
name|check_add
operator|=
name|ecore_check_vlan_mac_add
expr_stmt|;
name|vlan_mac_obj
operator|->
name|check_move
operator|=
name|ecore_check_move_always_err
expr_stmt|;
name|vlan_mac_obj
operator|->
name|ramrod_cmd
operator|=
name|RAMROD_CMD_ID_ETH_SET_MAC
expr_stmt|;
comment|/* Exe Queue */
name|ecore_exe_queue_init
argument_list|(
name|sc
argument_list|,
operator|&
name|vlan_mac_obj
operator|->
name|exe_queue
argument_list|,
literal|1
argument_list|,
name|qable_obj
argument_list|,
name|ecore_validate_vlan_mac
argument_list|,
name|ecore_remove_vlan_mac
argument_list|,
name|ecore_optimize_vlan_mac
argument_list|,
name|ecore_execute_vlan_mac
argument_list|,
name|ecore_exeq_get_vlan_mac
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vlan_mac_obj
operator|->
name|set_one_rule
operator|=
name|ecore_set_one_vlan_mac_e2
expr_stmt|;
name|vlan_mac_obj
operator|->
name|check_del
operator|=
name|ecore_check_vlan_mac_del
expr_stmt|;
name|vlan_mac_obj
operator|->
name|check_add
operator|=
name|ecore_check_vlan_mac_add
expr_stmt|;
name|vlan_mac_obj
operator|->
name|check_move
operator|=
name|ecore_check_move
expr_stmt|;
name|vlan_mac_obj
operator|->
name|ramrod_cmd
operator|=
name|RAMROD_CMD_ID_ETH_CLASSIFICATION_RULES
expr_stmt|;
comment|/* Exe Queue */
name|ecore_exe_queue_init
argument_list|(
name|sc
argument_list|,
operator|&
name|vlan_mac_obj
operator|->
name|exe_queue
argument_list|,
name|CLASSIFY_RULES_COUNT
argument_list|,
name|qable_obj
argument_list|,
name|ecore_validate_vlan_mac
argument_list|,
name|ecore_remove_vlan_mac
argument_list|,
name|ecore_optimize_vlan_mac
argument_list|,
name|ecore_execute_vlan_mac
argument_list|,
name|ecore_exeq_get_vlan_mac
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* RX_MODE verbs: DROP_ALL/ACCEPT_ALL/ACCEPT_ALL_MULTI/ACCEPT_ALL_VLAN/NORMAL */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|__storm_memset_mac_filters
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|tstorm_eth_mac_filter_config
modifier|*
name|mac_filters
parameter_list|,
name|uint16_t
name|pf_id
parameter_list|)
block|{
name|size_t
name|size
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|tstorm_eth_mac_filter_config
argument_list|)
decl_stmt|;
name|uint32_t
name|addr
init|=
name|BAR_TSTRORM_INTMEM
operator|+
name|TSTORM_MAC_FILTER_CONFIG_OFFSET
argument_list|(
name|pf_id
argument_list|)
decl_stmt|;
name|ecore_storm_memset_struct
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
name|mac_filters
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ecore_set_rx_mode_e1x
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_rx_mode_ramrod_params
modifier|*
name|p
parameter_list|)
block|{
comment|/* update the sc MAC filter structure */
name|uint32_t
name|mask
init|=
operator|(
literal|1
operator|<<
name|p
operator|->
name|cl_id
operator|)
decl_stmt|;
name|struct
name|tstorm_eth_mac_filter_config
modifier|*
name|mac_filters
init|=
operator|(
expr|struct
name|tstorm_eth_mac_filter_config
operator|*
operator|)
name|p
operator|->
name|rdata
decl_stmt|;
comment|/* initial setting is drop-all */
name|uint8_t
name|drop_all_ucast
init|=
literal|1
decl_stmt|,
name|drop_all_mcast
init|=
literal|1
decl_stmt|;
name|uint8_t
name|accp_all_ucast
init|=
literal|0
decl_stmt|,
name|accp_all_bcast
init|=
literal|0
decl_stmt|,
name|accp_all_mcast
init|=
literal|0
decl_stmt|;
name|uint8_t
name|unmatched_unicast
init|=
literal|0
decl_stmt|;
comment|/* In e1x there we only take into account rx accept flag since tx switching      * isn't enabled. */
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_ACCEPT_UNICAST
argument_list|,
operator|&
name|p
operator|->
name|rx_accept_flags
argument_list|)
condition|)
comment|/* accept matched ucast */
name|drop_all_ucast
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_ACCEPT_MULTICAST
argument_list|,
operator|&
name|p
operator|->
name|rx_accept_flags
argument_list|)
condition|)
comment|/* accept matched mcast */
name|drop_all_mcast
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_ACCEPT_ALL_UNICAST
argument_list|,
operator|&
name|p
operator|->
name|rx_accept_flags
argument_list|)
condition|)
block|{
comment|/* accept all mcast */
name|drop_all_ucast
operator|=
literal|0
expr_stmt|;
name|accp_all_ucast
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_ACCEPT_ALL_MULTICAST
argument_list|,
operator|&
name|p
operator|->
name|rx_accept_flags
argument_list|)
condition|)
block|{
comment|/* accept all mcast */
name|drop_all_mcast
operator|=
literal|0
expr_stmt|;
name|accp_all_mcast
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_ACCEPT_BROADCAST
argument_list|,
operator|&
name|p
operator|->
name|rx_accept_flags
argument_list|)
condition|)
comment|/* accept (all) bcast */
name|accp_all_bcast
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_ACCEPT_UNMATCHED
argument_list|,
operator|&
name|p
operator|->
name|rx_accept_flags
argument_list|)
condition|)
comment|/* accept unmatched unicasts */
name|unmatched_unicast
operator|=
literal|1
expr_stmt|;
name|mac_filters
operator|->
name|ucast_drop_all
operator|=
name|drop_all_ucast
condition|?
name|mac_filters
operator|->
name|ucast_drop_all
operator||
name|mask
else|:
name|mac_filters
operator|->
name|ucast_drop_all
operator|&
operator|~
name|mask
expr_stmt|;
name|mac_filters
operator|->
name|mcast_drop_all
operator|=
name|drop_all_mcast
condition|?
name|mac_filters
operator|->
name|mcast_drop_all
operator||
name|mask
else|:
name|mac_filters
operator|->
name|mcast_drop_all
operator|&
operator|~
name|mask
expr_stmt|;
name|mac_filters
operator|->
name|ucast_accept_all
operator|=
name|accp_all_ucast
condition|?
name|mac_filters
operator|->
name|ucast_accept_all
operator||
name|mask
else|:
name|mac_filters
operator|->
name|ucast_accept_all
operator|&
operator|~
name|mask
expr_stmt|;
name|mac_filters
operator|->
name|mcast_accept_all
operator|=
name|accp_all_mcast
condition|?
name|mac_filters
operator|->
name|mcast_accept_all
operator||
name|mask
else|:
name|mac_filters
operator|->
name|mcast_accept_all
operator|&
operator|~
name|mask
expr_stmt|;
name|mac_filters
operator|->
name|bcast_accept_all
operator|=
name|accp_all_bcast
condition|?
name|mac_filters
operator|->
name|bcast_accept_all
operator||
name|mask
else|:
name|mac_filters
operator|->
name|bcast_accept_all
operator|&
operator|~
name|mask
expr_stmt|;
name|mac_filters
operator|->
name|unmatched_unicast
operator|=
name|unmatched_unicast
condition|?
name|mac_filters
operator|->
name|unmatched_unicast
operator||
name|mask
else|:
name|mac_filters
operator|->
name|unmatched_unicast
operator|&
operator|~
name|mask
expr_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"drop_ucast 0x%x\ndrop_mcast 0x%x\n accp_ucast 0x%x\n"
literal|"accp_mcast 0x%x\naccp_bcast 0x%x\n"
argument_list|,
name|mac_filters
operator|->
name|ucast_drop_all
argument_list|,
name|mac_filters
operator|->
name|mcast_drop_all
argument_list|,
name|mac_filters
operator|->
name|ucast_accept_all
argument_list|,
name|mac_filters
operator|->
name|mcast_accept_all
argument_list|,
name|mac_filters
operator|->
name|bcast_accept_all
argument_list|)
expr_stmt|;
comment|/* write the MAC filter structure*/
name|__storm_memset_mac_filters
argument_list|(
name|sc
argument_list|,
name|mac_filters
argument_list|,
name|p
operator|->
name|func_id
argument_list|)
expr_stmt|;
comment|/* The operation is completed */
name|ECORE_CLEAR_BIT
argument_list|(
name|p
operator|->
name|state
argument_list|,
name|p
operator|->
name|pstate
argument_list|)
expr_stmt|;
name|ECORE_SMP_MB_AFTER_CLEAR_BIT
argument_list|()
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Setup ramrod data */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ecore_rx_mode_set_rdata_hdr_e2
parameter_list|(
name|uint32_t
name|cid
parameter_list|,
name|struct
name|eth_classify_header
modifier|*
name|hdr
parameter_list|,
name|uint8_t
name|rule_cnt
parameter_list|)
block|{
name|hdr
operator|->
name|echo
operator|=
name|ECORE_CPU_TO_LE32
argument_list|(
name|cid
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|rule_cnt
operator|=
name|rule_cnt
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ecore_rx_mode_set_cmd_state_e2
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|unsigned
name|long
modifier|*
name|accept_flags
parameter_list|,
name|struct
name|eth_filter_rules_cmd
modifier|*
name|cmd
parameter_list|,
name|bool
name|clear_accept_all
parameter_list|)
block|{
name|uint16_t
name|state
decl_stmt|;
comment|/* start with 'drop-all' */
name|state
operator|=
name|ETH_FILTER_RULES_CMD_UCAST_DROP_ALL
operator||
name|ETH_FILTER_RULES_CMD_MCAST_DROP_ALL
expr_stmt|;
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_ACCEPT_UNICAST
argument_list|,
name|accept_flags
argument_list|)
condition|)
name|state
operator|&=
operator|~
name|ETH_FILTER_RULES_CMD_UCAST_DROP_ALL
expr_stmt|;
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_ACCEPT_MULTICAST
argument_list|,
name|accept_flags
argument_list|)
condition|)
name|state
operator|&=
operator|~
name|ETH_FILTER_RULES_CMD_MCAST_DROP_ALL
expr_stmt|;
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_ACCEPT_ALL_UNICAST
argument_list|,
name|accept_flags
argument_list|)
condition|)
block|{
name|state
operator|&=
operator|~
name|ETH_FILTER_RULES_CMD_UCAST_DROP_ALL
expr_stmt|;
name|state
operator||=
name|ETH_FILTER_RULES_CMD_UCAST_ACCEPT_ALL
expr_stmt|;
block|}
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_ACCEPT_ALL_MULTICAST
argument_list|,
name|accept_flags
argument_list|)
condition|)
block|{
name|state
operator||=
name|ETH_FILTER_RULES_CMD_MCAST_ACCEPT_ALL
expr_stmt|;
name|state
operator|&=
operator|~
name|ETH_FILTER_RULES_CMD_MCAST_DROP_ALL
expr_stmt|;
block|}
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_ACCEPT_BROADCAST
argument_list|,
name|accept_flags
argument_list|)
condition|)
name|state
operator||=
name|ETH_FILTER_RULES_CMD_BCAST_ACCEPT_ALL
expr_stmt|;
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_ACCEPT_UNMATCHED
argument_list|,
name|accept_flags
argument_list|)
condition|)
block|{
name|state
operator|&=
operator|~
name|ETH_FILTER_RULES_CMD_UCAST_DROP_ALL
expr_stmt|;
name|state
operator||=
name|ETH_FILTER_RULES_CMD_UCAST_ACCEPT_UNMATCHED
expr_stmt|;
block|}
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_ACCEPT_ANY_VLAN
argument_list|,
name|accept_flags
argument_list|)
condition|)
name|state
operator||=
name|ETH_FILTER_RULES_CMD_ACCEPT_ANY_VLAN
expr_stmt|;
comment|/* Clear ACCEPT_ALL_XXX flags for FCoE L2 Queue */
if|if
condition|(
name|clear_accept_all
condition|)
block|{
name|state
operator|&=
operator|~
name|ETH_FILTER_RULES_CMD_MCAST_ACCEPT_ALL
expr_stmt|;
name|state
operator|&=
operator|~
name|ETH_FILTER_RULES_CMD_BCAST_ACCEPT_ALL
expr_stmt|;
name|state
operator|&=
operator|~
name|ETH_FILTER_RULES_CMD_UCAST_ACCEPT_ALL
expr_stmt|;
name|state
operator|&=
operator|~
name|ETH_FILTER_RULES_CMD_UCAST_ACCEPT_UNMATCHED
expr_stmt|;
block|}
name|cmd
operator|->
name|state
operator|=
name|ECORE_CPU_TO_LE16
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ecore_set_rx_mode_e2
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_rx_mode_ramrod_params
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|eth_filter_rules_ramrod_data
modifier|*
name|data
init|=
name|p
operator|->
name|rdata
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|uint8_t
name|rule_idx
init|=
literal|0
decl_stmt|;
comment|/* Reset the ramrod data buffer */
name|ECORE_MEMSET
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Setup ramrod data */
comment|/* Tx (internal switching) */
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|RAMROD_TX
argument_list|,
operator|&
name|p
operator|->
name|ramrod_flags
argument_list|)
condition|)
block|{
name|data
operator|->
name|rules
index|[
name|rule_idx
index|]
operator|.
name|client_id
operator|=
name|p
operator|->
name|cl_id
expr_stmt|;
name|data
operator|->
name|rules
index|[
name|rule_idx
index|]
operator|.
name|func_id
operator|=
name|p
operator|->
name|func_id
expr_stmt|;
name|data
operator|->
name|rules
index|[
name|rule_idx
index|]
operator|.
name|cmd_general_data
operator|=
name|ETH_FILTER_RULES_CMD_TX_CMD
expr_stmt|;
name|ecore_rx_mode_set_cmd_state_e2
argument_list|(
name|sc
argument_list|,
operator|&
name|p
operator|->
name|tx_accept_flags
argument_list|,
operator|&
operator|(
name|data
operator|->
name|rules
index|[
name|rule_idx
operator|++
index|]
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* Rx */
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|RAMROD_RX
argument_list|,
operator|&
name|p
operator|->
name|ramrod_flags
argument_list|)
condition|)
block|{
name|data
operator|->
name|rules
index|[
name|rule_idx
index|]
operator|.
name|client_id
operator|=
name|p
operator|->
name|cl_id
expr_stmt|;
name|data
operator|->
name|rules
index|[
name|rule_idx
index|]
operator|.
name|func_id
operator|=
name|p
operator|->
name|func_id
expr_stmt|;
name|data
operator|->
name|rules
index|[
name|rule_idx
index|]
operator|.
name|cmd_general_data
operator|=
name|ETH_FILTER_RULES_CMD_RX_CMD
expr_stmt|;
name|ecore_rx_mode_set_cmd_state_e2
argument_list|(
name|sc
argument_list|,
operator|&
name|p
operator|->
name|rx_accept_flags
argument_list|,
operator|&
operator|(
name|data
operator|->
name|rules
index|[
name|rule_idx
operator|++
index|]
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* If FCoE Queue configuration has been requested configure the Rx and 	 * internal switching modes for this queue in separate rules. 	 * 	 * FCoE queue shell never be set to ACCEPT_ALL packets of any sort: 	 * MCAST_ALL, UCAST_ALL, BCAST_ALL and UNMATCHED. 	 */
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_RX_MODE_FCOE_ETH
argument_list|,
operator|&
name|p
operator|->
name|rx_mode_flags
argument_list|)
condition|)
block|{
comment|/*  Tx (internal switching) */
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|RAMROD_TX
argument_list|,
operator|&
name|p
operator|->
name|ramrod_flags
argument_list|)
condition|)
block|{
name|data
operator|->
name|rules
index|[
name|rule_idx
index|]
operator|.
name|client_id
operator|=
name|ECORE_FCOE_CID
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|data
operator|->
name|rules
index|[
name|rule_idx
index|]
operator|.
name|func_id
operator|=
name|p
operator|->
name|func_id
expr_stmt|;
name|data
operator|->
name|rules
index|[
name|rule_idx
index|]
operator|.
name|cmd_general_data
operator|=
name|ETH_FILTER_RULES_CMD_TX_CMD
expr_stmt|;
name|ecore_rx_mode_set_cmd_state_e2
argument_list|(
name|sc
argument_list|,
operator|&
name|p
operator|->
name|tx_accept_flags
argument_list|,
operator|&
operator|(
name|data
operator|->
name|rules
index|[
name|rule_idx
index|]
operator|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|rule_idx
operator|++
expr_stmt|;
block|}
comment|/* Rx */
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|RAMROD_RX
argument_list|,
operator|&
name|p
operator|->
name|ramrod_flags
argument_list|)
condition|)
block|{
name|data
operator|->
name|rules
index|[
name|rule_idx
index|]
operator|.
name|client_id
operator|=
name|ECORE_FCOE_CID
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|data
operator|->
name|rules
index|[
name|rule_idx
index|]
operator|.
name|func_id
operator|=
name|p
operator|->
name|func_id
expr_stmt|;
name|data
operator|->
name|rules
index|[
name|rule_idx
index|]
operator|.
name|cmd_general_data
operator|=
name|ETH_FILTER_RULES_CMD_RX_CMD
expr_stmt|;
name|ecore_rx_mode_set_cmd_state_e2
argument_list|(
name|sc
argument_list|,
operator|&
name|p
operator|->
name|rx_accept_flags
argument_list|,
operator|&
operator|(
name|data
operator|->
name|rules
index|[
name|rule_idx
index|]
operator|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|rule_idx
operator|++
expr_stmt|;
block|}
block|}
comment|/* Set the ramrod header (most importantly - number of rules to 	 * configure). 	 */
name|ecore_rx_mode_set_rdata_hdr_e2
argument_list|(
name|p
operator|->
name|cid
argument_list|,
operator|&
name|data
operator|->
name|header
argument_list|,
name|rule_idx
argument_list|)
expr_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"About to configure %d rules, rx_accept_flags 0x%lx, tx_accept_flags 0x%lx\n"
argument_list|,
name|data
operator|->
name|header
operator|.
name|rule_cnt
argument_list|,
name|p
operator|->
name|rx_accept_flags
argument_list|,
name|p
operator|->
name|tx_accept_flags
argument_list|)
expr_stmt|;
comment|/* No need for an explicit memory barrier here as long we would 	 * need to ensure the ordering of writing to the SPQ element 	 * and updating of the SPQ producer which involves a memory 	 * read and we will have to put a full memory barrier there 	 * (inside ecore_sp_post()). 	 */
comment|/* Send a ramrod */
name|rc
operator|=
name|ecore_sp_post
argument_list|(
name|sc
argument_list|,
name|RAMROD_CMD_ID_ETH_FILTER_RULES
argument_list|,
name|p
operator|->
name|cid
argument_list|,
name|p
operator|->
name|rdata_mapping
argument_list|,
name|ETH_CONNECTION_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
comment|/* Ramrod completion is pending */
return|return
name|ECORE_PENDING
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ecore_wait_rx_mode_comp_e2
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_rx_mode_ramrod_params
modifier|*
name|p
parameter_list|)
block|{
return|return
name|ecore_state_wait
argument_list|(
name|sc
argument_list|,
name|p
operator|->
name|state
argument_list|,
name|p
operator|->
name|pstate
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ecore_empty_rx_mode_wait
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_rx_mode_ramrod_params
modifier|*
name|p
parameter_list|)
block|{
comment|/* Do nothing */
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
name|int
name|ecore_config_rx_mode
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_rx_mode_ramrod_params
modifier|*
name|p
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
comment|/* Configure the new classification in the chip */
name|rc
operator|=
name|p
operator|->
name|rx_mode_obj
operator|->
name|config_rx_mode
argument_list|(
name|sc
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
return|return
name|rc
return|;
comment|/* Wait for a ramrod completion if was requested */
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|RAMROD_COMP_WAIT
argument_list|,
operator|&
name|p
operator|->
name|ramrod_flags
argument_list|)
condition|)
block|{
name|rc
operator|=
name|p
operator|->
name|rx_mode_obj
operator|->
name|wait_comp
argument_list|(
name|sc
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
name|void
name|ecore_init_rx_mode_obj
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_rx_mode_obj
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|o
operator|->
name|wait_comp
operator|=
name|ecore_empty_rx_mode_wait
expr_stmt|;
name|o
operator|->
name|config_rx_mode
operator|=
name|ecore_set_rx_mode_e1x
expr_stmt|;
block|}
else|else
block|{
name|o
operator|->
name|wait_comp
operator|=
name|ecore_wait_rx_mode_comp_e2
expr_stmt|;
name|o
operator|->
name|config_rx_mode
operator|=
name|ecore_set_rx_mode_e2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/********************* Multicast verbs: SET, CLEAR ****************************/
end_comment

begin_function
specifier|static
specifier|inline
name|uint8_t
name|ecore_mcast_bin_from_mac
parameter_list|(
name|uint8_t
modifier|*
name|mac
parameter_list|)
block|{
return|return
operator|(
name|ECORE_CRC32_LE
argument_list|(
literal|0
argument_list|,
name|mac
argument_list|,
name|ETH_ALEN
argument_list|)
operator|>>
literal|24
operator|)
operator|&
literal|0xff
return|;
block|}
end_function

begin_struct
struct|struct
name|ecore_mcast_mac_elem
block|{
name|ecore_list_entry_t
name|link
decl_stmt|;
name|uint8_t
name|mac
index|[
name|ETH_ALEN
index|]
decl_stmt|;
name|uint8_t
name|pad
index|[
literal|2
index|]
decl_stmt|;
comment|/* For a natural alignment of the following buffer */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ecore_pending_mcast_cmd
block|{
name|ecore_list_entry_t
name|link
decl_stmt|;
name|int
name|type
decl_stmt|;
comment|/* ECORE_MCAST_CMD_X */
union|union
block|{
name|ecore_list_t
name|macs_head
decl_stmt|;
name|uint32_t
name|macs_num
decl_stmt|;
comment|/* Needed for DEL command */
name|int
name|next_bin
decl_stmt|;
comment|/* Needed for RESTORE flow with aprox match */
block|}
name|data
union|;
name|bool
name|done
decl_stmt|;
comment|/* set to TRUE, when the command has been handled, 		    * practically used in 57712 handling only, where one pending 		    * command may be handled in a few operations. As long as for 		    * other chips every operation handling is completed in a 		    * single ramrod, there is no need to utilize this field. 		    */
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|ecore_mcast_wait
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_mcast_obj
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
name|ecore_state_wait
argument_list|(
name|sc
argument_list|,
name|o
operator|->
name|sched_state
argument_list|,
name|o
operator|->
name|raw
operator|.
name|pstate
argument_list|)
operator|||
name|o
operator|->
name|raw
operator|.
name|wait_comp
argument_list|(
name|sc
argument_list|,
operator|&
name|o
operator|->
name|raw
argument_list|)
condition|)
return|return
name|ECORE_TIMEOUT
return|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ecore_mcast_enqueue_cmd
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_mcast_obj
modifier|*
name|o
parameter_list|,
name|struct
name|ecore_mcast_ramrod_params
modifier|*
name|p
parameter_list|,
name|enum
name|ecore_mcast_cmd
name|cmd
parameter_list|)
block|{
name|int
name|total_sz
decl_stmt|;
name|struct
name|ecore_pending_mcast_cmd
modifier|*
name|new_cmd
decl_stmt|;
name|struct
name|ecore_mcast_mac_elem
modifier|*
name|cur_mac
init|=
name|NULL
decl_stmt|;
name|struct
name|ecore_mcast_list_elem
modifier|*
name|pos
decl_stmt|;
name|int
name|macs_list_len
init|=
operator|(
operator|(
name|cmd
operator|==
name|ECORE_MCAST_CMD_ADD
operator|)
condition|?
name|p
operator|->
name|mcast_list_len
else|:
literal|0
operator|)
decl_stmt|;
comment|/* If the command is empty ("handle pending commands only"), break */
if|if
condition|(
operator|!
name|p
operator|->
name|mcast_list_len
condition|)
return|return
name|ECORE_SUCCESS
return|;
name|total_sz
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|new_cmd
argument_list|)
operator|+
name|macs_list_len
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ecore_mcast_mac_elem
argument_list|)
expr_stmt|;
comment|/* Add mcast is called under spin_lock, thus calling with GFP_ATOMIC */
name|new_cmd
operator|=
name|ECORE_ZALLOC
argument_list|(
name|total_sz
argument_list|,
name|GFP_ATOMIC
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_cmd
condition|)
return|return
name|ECORE_NOMEM
return|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"About to enqueue a new %d command. macs_list_len=%d\n"
argument_list|,
name|cmd
argument_list|,
name|macs_list_len
argument_list|)
expr_stmt|;
name|ECORE_LIST_INIT
argument_list|(
operator|&
name|new_cmd
operator|->
name|data
operator|.
name|macs_head
argument_list|)
expr_stmt|;
name|new_cmd
operator|->
name|type
operator|=
name|cmd
expr_stmt|;
name|new_cmd
operator|->
name|done
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|ECORE_MCAST_CMD_ADD
case|:
name|cur_mac
operator|=
operator|(
expr|struct
name|ecore_mcast_mac_elem
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|new_cmd
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|new_cmd
argument_list|)
operator|)
expr_stmt|;
comment|/* Push the MACs of the current command into the pending command 		 * MACs list: FIFO 		 */
name|ECORE_LIST_FOR_EACH_ENTRY
argument_list|(
argument|pos
argument_list|,
argument|&p->mcast_list
argument_list|,
argument|link
argument_list|,
argument|struct ecore_mcast_list_elem
argument_list|)
block|{
name|ECORE_MEMCPY
argument_list|(
name|cur_mac
operator|->
name|mac
argument_list|,
name|pos
operator|->
name|mac
argument_list|,
name|ETH_ALEN
argument_list|)
expr_stmt|;
name|ECORE_LIST_PUSH_TAIL
argument_list|(
operator|&
name|cur_mac
operator|->
name|link
argument_list|,
operator|&
name|new_cmd
operator|->
name|data
operator|.
name|macs_head
argument_list|)
expr_stmt|;
name|cur_mac
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|ECORE_MCAST_CMD_DEL
case|:
name|new_cmd
operator|->
name|data
operator|.
name|macs_num
operator|=
name|p
operator|->
name|mcast_list_len
expr_stmt|;
break|break;
case|case
name|ECORE_MCAST_CMD_RESTORE
case|:
name|new_cmd
operator|->
name|data
operator|.
name|next_bin
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|ECORE_FREE
argument_list|(
name|sc
argument_list|,
name|new_cmd
argument_list|,
name|total_sz
argument_list|)
expr_stmt|;
name|ECORE_ERR
argument_list|(
literal|"Unknown command: %d\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
comment|/* Push the new pending command to the tail of the pending list: FIFO */
name|ECORE_LIST_PUSH_TAIL
argument_list|(
operator|&
name|new_cmd
operator|->
name|link
argument_list|,
operator|&
name|o
operator|->
name|pending_cmds_head
argument_list|)
expr_stmt|;
name|o
operator|->
name|set_sched
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
name|ECORE_PENDING
return|;
block|}
end_function

begin_comment
comment|/**  * ecore_mcast_get_next_bin - get the next set bin (index)  *  * @o:  * @last:	index to start looking from (including)  *  * returns the next found (set) bin or a negative value if none is found.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ecore_mcast_get_next_bin
parameter_list|(
name|struct
name|ecore_mcast_obj
modifier|*
name|o
parameter_list|,
name|int
name|last
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|inner_start
init|=
name|last
operator|%
name|BIT_VEC64_ELEM_SZ
decl_stmt|;
for|for
control|(
name|i
operator|=
name|last
operator|/
name|BIT_VEC64_ELEM_SZ
init|;
name|i
operator|<
name|ECORE_MCAST_VEC_SZ
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|o
operator|->
name|registry
operator|.
name|aprox_match
operator|.
name|vec
index|[
name|i
index|]
condition|)
for|for
control|(
name|j
operator|=
name|inner_start
init|;
name|j
operator|<
name|BIT_VEC64_ELEM_SZ
condition|;
name|j
operator|++
control|)
block|{
name|int
name|cur_bit
init|=
name|j
operator|+
name|BIT_VEC64_ELEM_SZ
operator|*
name|i
decl_stmt|;
if|if
condition|(
name|BIT_VEC64_TEST_BIT
argument_list|(
name|o
operator|->
name|registry
operator|.
name|aprox_match
operator|.
name|vec
argument_list|,
name|cur_bit
argument_list|)
condition|)
block|{
return|return
name|cur_bit
return|;
block|}
block|}
name|inner_start
operator|=
literal|0
expr_stmt|;
block|}
comment|/* None found */
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * ecore_mcast_clear_first_bin - find the first set bin and clear it  *  * @o:  *  * returns the index of the found bin or -1 if none is found  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ecore_mcast_clear_first_bin
parameter_list|(
name|struct
name|ecore_mcast_obj
modifier|*
name|o
parameter_list|)
block|{
name|int
name|cur_bit
init|=
name|ecore_mcast_get_next_bin
argument_list|(
name|o
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|cur_bit
operator|>=
literal|0
condition|)
name|BIT_VEC64_CLEAR_BIT
argument_list|(
name|o
operator|->
name|registry
operator|.
name|aprox_match
operator|.
name|vec
argument_list|,
name|cur_bit
argument_list|)
expr_stmt|;
return|return
name|cur_bit
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint8_t
name|ecore_mcast_get_rx_tx_flag
parameter_list|(
name|struct
name|ecore_mcast_obj
modifier|*
name|o
parameter_list|)
block|{
name|struct
name|ecore_raw_obj
modifier|*
name|raw
init|=
operator|&
name|o
operator|->
name|raw
decl_stmt|;
name|uint8_t
name|rx_tx_flag
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|raw
operator|->
name|obj_type
operator|==
name|ECORE_OBJ_TYPE_TX
operator|)
operator|||
operator|(
name|raw
operator|->
name|obj_type
operator|==
name|ECORE_OBJ_TYPE_RX_TX
operator|)
condition|)
name|rx_tx_flag
operator||=
name|ETH_MULTICAST_RULES_CMD_TX_CMD
expr_stmt|;
if|if
condition|(
operator|(
name|raw
operator|->
name|obj_type
operator|==
name|ECORE_OBJ_TYPE_RX
operator|)
operator|||
operator|(
name|raw
operator|->
name|obj_type
operator|==
name|ECORE_OBJ_TYPE_RX_TX
operator|)
condition|)
name|rx_tx_flag
operator||=
name|ETH_MULTICAST_RULES_CMD_RX_CMD
expr_stmt|;
return|return
name|rx_tx_flag
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_mcast_set_one_rule_e2
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_mcast_obj
modifier|*
name|o
parameter_list|,
name|int
name|idx
parameter_list|,
name|union
name|ecore_mcast_config_data
modifier|*
name|cfg_data
parameter_list|,
name|enum
name|ecore_mcast_cmd
name|cmd
parameter_list|)
block|{
name|struct
name|ecore_raw_obj
modifier|*
name|r
init|=
operator|&
name|o
operator|->
name|raw
decl_stmt|;
name|struct
name|eth_multicast_rules_ramrod_data
modifier|*
name|data
init|=
operator|(
expr|struct
name|eth_multicast_rules_ramrod_data
operator|*
operator|)
operator|(
name|r
operator|->
name|rdata
operator|)
decl_stmt|;
name|uint8_t
name|func_id
init|=
name|r
operator|->
name|func_id
decl_stmt|;
name|uint8_t
name|rx_tx_add_flag
init|=
name|ecore_mcast_get_rx_tx_flag
argument_list|(
name|o
argument_list|)
decl_stmt|;
name|int
name|bin
decl_stmt|;
if|if
condition|(
operator|(
name|cmd
operator|==
name|ECORE_MCAST_CMD_ADD
operator|)
operator|||
operator|(
name|cmd
operator|==
name|ECORE_MCAST_CMD_RESTORE
operator|)
condition|)
name|rx_tx_add_flag
operator||=
name|ETH_MULTICAST_RULES_CMD_IS_ADD
expr_stmt|;
name|data
operator|->
name|rules
index|[
name|idx
index|]
operator|.
name|cmd_general_data
operator||=
name|rx_tx_add_flag
expr_stmt|;
comment|/* Get a bin and update a bins' vector */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|ECORE_MCAST_CMD_ADD
case|:
name|bin
operator|=
name|ecore_mcast_bin_from_mac
argument_list|(
name|cfg_data
operator|->
name|mac
argument_list|)
expr_stmt|;
name|BIT_VEC64_SET_BIT
argument_list|(
name|o
operator|->
name|registry
operator|.
name|aprox_match
operator|.
name|vec
argument_list|,
name|bin
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECORE_MCAST_CMD_DEL
case|:
comment|/* If there were no more bins to clear 		 * (ecore_mcast_clear_first_bin() returns -1) then we would 		 * clear any (0xff) bin. 		 * See ecore_mcast_validate_e2() for explanation when it may 		 * happen. 		 */
name|bin
operator|=
name|ecore_mcast_clear_first_bin
argument_list|(
name|o
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECORE_MCAST_CMD_RESTORE
case|:
name|bin
operator|=
name|cfg_data
operator|->
name|bin
expr_stmt|;
break|break;
default|default:
name|ECORE_ERR
argument_list|(
literal|"Unknown command: %d\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return;
block|}
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"%s bin %d\n"
argument_list|,
operator|(
operator|(
name|rx_tx_add_flag
operator|&
name|ETH_MULTICAST_RULES_CMD_IS_ADD
operator|)
condition|?
literal|"Setting"
else|:
literal|"Clearing"
operator|)
argument_list|,
name|bin
argument_list|)
expr_stmt|;
name|data
operator|->
name|rules
index|[
name|idx
index|]
operator|.
name|bin_id
operator|=
operator|(
name|uint8_t
operator|)
name|bin
expr_stmt|;
name|data
operator|->
name|rules
index|[
name|idx
index|]
operator|.
name|func_id
operator|=
name|func_id
expr_stmt|;
name|data
operator|->
name|rules
index|[
name|idx
index|]
operator|.
name|engine_id
operator|=
name|o
operator|->
name|engine_id
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ecore_mcast_handle_restore_cmd_e2 - restore configuration from the registry  *  * @sc:		device handle  * @o:  * @start_bin:	index in the registry to start from (including)  * @rdata_idx:	index in the ramrod data to start from  *  * returns last handled bin index or -1 if all bins have been handled  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ecore_mcast_handle_restore_cmd_e2
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_mcast_obj
modifier|*
name|o
parameter_list|,
name|int
name|start_bin
parameter_list|,
name|int
modifier|*
name|rdata_idx
parameter_list|)
block|{
name|int
name|cur_bin
decl_stmt|,
name|cnt
init|=
operator|*
name|rdata_idx
decl_stmt|;
name|union
name|ecore_mcast_config_data
name|cfg_data
init|=
block|{
name|NULL
block|}
decl_stmt|;
comment|/* go through the registry and configure the bins from it */
for|for
control|(
name|cur_bin
operator|=
name|ecore_mcast_get_next_bin
argument_list|(
name|o
argument_list|,
name|start_bin
argument_list|)
init|;
name|cur_bin
operator|>=
literal|0
condition|;
name|cur_bin
operator|=
name|ecore_mcast_get_next_bin
argument_list|(
name|o
argument_list|,
name|cur_bin
operator|+
literal|1
argument_list|)
control|)
block|{
name|cfg_data
operator|.
name|bin
operator|=
operator|(
name|uint8_t
operator|)
name|cur_bin
expr_stmt|;
name|o
operator|->
name|set_one_rule
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
name|cnt
argument_list|,
operator|&
name|cfg_data
argument_list|,
name|ECORE_MCAST_CMD_RESTORE
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"About to configure a bin %d\n"
argument_list|,
name|cur_bin
argument_list|)
expr_stmt|;
comment|/* Break if we reached the maximum number 		 * of rules. 		 */
if|if
condition|(
name|cnt
operator|>=
name|o
operator|->
name|max_cmd_len
condition|)
break|break;
block|}
operator|*
name|rdata_idx
operator|=
name|cnt
expr_stmt|;
return|return
name|cur_bin
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ecore_mcast_hdl_pending_add_e2
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_mcast_obj
modifier|*
name|o
parameter_list|,
name|struct
name|ecore_pending_mcast_cmd
modifier|*
name|cmd_pos
parameter_list|,
name|int
modifier|*
name|line_idx
parameter_list|)
block|{
name|struct
name|ecore_mcast_mac_elem
modifier|*
name|pmac_pos
decl_stmt|,
modifier|*
name|pmac_pos_n
decl_stmt|;
name|int
name|cnt
init|=
operator|*
name|line_idx
decl_stmt|;
name|union
name|ecore_mcast_config_data
name|cfg_data
init|=
block|{
name|NULL
block|}
decl_stmt|;
name|ECORE_LIST_FOR_EACH_ENTRY_SAFE
argument_list|(
argument|pmac_pos
argument_list|,
argument|pmac_pos_n
argument_list|,
argument|&cmd_pos->data.macs_head
argument_list|,
argument|link
argument_list|,
argument|struct ecore_mcast_mac_elem
argument_list|)
block|{
name|cfg_data
operator|.
name|mac
operator|=
operator|&
name|pmac_pos
operator|->
name|mac
index|[
literal|0
index|]
expr_stmt|;
name|o
operator|->
name|set_one_rule
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
name|cnt
argument_list|,
operator|&
name|cfg_data
argument_list|,
name|cmd_pos
operator|->
name|type
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"About to configure %02x:%02x:%02x:%02x:%02x:%02x mcast MAC\n"
argument_list|,
name|pmac_pos
operator|->
name|mac
index|[
literal|0
index|]
argument_list|,
name|pmac_pos
operator|->
name|mac
index|[
literal|1
index|]
argument_list|,
name|pmac_pos
operator|->
name|mac
index|[
literal|2
index|]
argument_list|,
name|pmac_pos
operator|->
name|mac
index|[
literal|3
index|]
argument_list|,
name|pmac_pos
operator|->
name|mac
index|[
literal|4
index|]
argument_list|,
name|pmac_pos
operator|->
name|mac
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|ECORE_LIST_REMOVE_ENTRY
argument_list|(
operator|&
name|pmac_pos
operator|->
name|link
argument_list|,
operator|&
name|cmd_pos
operator|->
name|data
operator|.
name|macs_head
argument_list|)
expr_stmt|;
comment|/* Break if we reached the maximum number 		 * of rules. 		 */
if|if
condition|(
name|cnt
operator|>=
name|o
operator|->
name|max_cmd_len
condition|)
break|break;
block|}
operator|*
name|line_idx
operator|=
name|cnt
expr_stmt|;
comment|/* if no more MACs to configure - we are done */
if|if
condition|(
name|ECORE_LIST_IS_EMPTY
argument_list|(
operator|&
name|cmd_pos
operator|->
name|data
operator|.
name|macs_head
argument_list|)
condition|)
name|cmd_pos
operator|->
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ecore_mcast_hdl_pending_del_e2
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_mcast_obj
modifier|*
name|o
parameter_list|,
name|struct
name|ecore_pending_mcast_cmd
modifier|*
name|cmd_pos
parameter_list|,
name|int
modifier|*
name|line_idx
parameter_list|)
block|{
name|int
name|cnt
init|=
operator|*
name|line_idx
decl_stmt|;
while|while
condition|(
name|cmd_pos
operator|->
name|data
operator|.
name|macs_num
condition|)
block|{
name|o
operator|->
name|set_one_rule
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
name|cnt
argument_list|,
name|NULL
argument_list|,
name|cmd_pos
operator|->
name|type
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
name|cmd_pos
operator|->
name|data
operator|.
name|macs_num
operator|--
expr_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"Deleting MAC. %d left,cnt is %d\n"
argument_list|,
name|cmd_pos
operator|->
name|data
operator|.
name|macs_num
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
comment|/* Break if we reached the maximum 		 * number of rules. 		 */
if|if
condition|(
name|cnt
operator|>=
name|o
operator|->
name|max_cmd_len
condition|)
break|break;
block|}
operator|*
name|line_idx
operator|=
name|cnt
expr_stmt|;
comment|/* If we cleared all bins - we are done */
if|if
condition|(
operator|!
name|cmd_pos
operator|->
name|data
operator|.
name|macs_num
condition|)
name|cmd_pos
operator|->
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ecore_mcast_hdl_pending_restore_e2
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_mcast_obj
modifier|*
name|o
parameter_list|,
name|struct
name|ecore_pending_mcast_cmd
modifier|*
name|cmd_pos
parameter_list|,
name|int
modifier|*
name|line_idx
parameter_list|)
block|{
name|cmd_pos
operator|->
name|data
operator|.
name|next_bin
operator|=
name|o
operator|->
name|hdl_restore
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
name|cmd_pos
operator|->
name|data
operator|.
name|next_bin
argument_list|,
name|line_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd_pos
operator|->
name|data
operator|.
name|next_bin
operator|<
literal|0
condition|)
comment|/* If o->set_restore returned -1 we are done */
name|cmd_pos
operator|->
name|done
operator|=
name|TRUE
expr_stmt|;
else|else
comment|/* Start from the next bin next time */
name|cmd_pos
operator|->
name|data
operator|.
name|next_bin
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|ecore_mcast_handle_pending_cmds_e2
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_mcast_ramrod_params
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ecore_pending_mcast_cmd
modifier|*
name|cmd_pos
decl_stmt|,
modifier|*
name|cmd_pos_n
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|;
name|struct
name|ecore_mcast_obj
modifier|*
name|o
init|=
name|p
operator|->
name|mcast_obj
decl_stmt|;
name|ECORE_LIST_FOR_EACH_ENTRY_SAFE
argument_list|(
argument|cmd_pos
argument_list|,
argument|cmd_pos_n
argument_list|,
argument|&o->pending_cmds_head
argument_list|,
argument|link
argument_list|,
argument|struct ecore_pending_mcast_cmd
argument_list|)
block|{
switch|switch
condition|(
name|cmd_pos
operator|->
name|type
condition|)
block|{
case|case
name|ECORE_MCAST_CMD_ADD
case|:
name|ecore_mcast_hdl_pending_add_e2
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
name|cmd_pos
argument_list|,
operator|&
name|cnt
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECORE_MCAST_CMD_DEL
case|:
name|ecore_mcast_hdl_pending_del_e2
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
name|cmd_pos
argument_list|,
operator|&
name|cnt
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECORE_MCAST_CMD_RESTORE
case|:
name|ecore_mcast_hdl_pending_restore_e2
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
name|cmd_pos
argument_list|,
operator|&
name|cnt
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ECORE_ERR
argument_list|(
literal|"Unknown command: %d\n"
argument_list|,
name|cmd_pos
operator|->
name|type
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
comment|/* If the command has been completed - remove it from the list 		 * and free the memory 		 */
if|if
condition|(
name|cmd_pos
operator|->
name|done
condition|)
block|{
name|ECORE_LIST_REMOVE_ENTRY
argument_list|(
operator|&
name|cmd_pos
operator|->
name|link
argument_list|,
operator|&
name|o
operator|->
name|pending_cmds_head
argument_list|)
expr_stmt|;
name|ECORE_FREE
argument_list|(
name|sc
argument_list|,
name|cmd_pos
argument_list|,
name|cmd_pos
operator|->
name|alloc_len
argument_list|)
expr_stmt|;
block|}
comment|/* Break if we reached the maximum number of rules */
if|if
condition|(
name|cnt
operator|>=
name|o
operator|->
name|max_cmd_len
condition|)
break|break;
block|}
return|return
name|cnt
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ecore_mcast_hdl_add
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_mcast_obj
modifier|*
name|o
parameter_list|,
name|struct
name|ecore_mcast_ramrod_params
modifier|*
name|p
parameter_list|,
name|int
modifier|*
name|line_idx
parameter_list|)
block|{
name|struct
name|ecore_mcast_list_elem
modifier|*
name|mlist_pos
decl_stmt|;
name|union
name|ecore_mcast_config_data
name|cfg_data
init|=
block|{
name|NULL
block|}
decl_stmt|;
name|int
name|cnt
init|=
operator|*
name|line_idx
decl_stmt|;
name|ECORE_LIST_FOR_EACH_ENTRY
argument_list|(
argument|mlist_pos
argument_list|,
argument|&p->mcast_list
argument_list|,
argument|link
argument_list|,
argument|struct ecore_mcast_list_elem
argument_list|)
block|{
name|cfg_data
operator|.
name|mac
operator|=
name|mlist_pos
operator|->
name|mac
expr_stmt|;
name|o
operator|->
name|set_one_rule
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
name|cnt
argument_list|,
operator|&
name|cfg_data
argument_list|,
name|ECORE_MCAST_CMD_ADD
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"About to configure %02x:%02x:%02x:%02x:%02x:%02x mcast MAC\n"
argument_list|,
name|mlist_pos
operator|->
name|mac
index|[
literal|0
index|]
argument_list|,
name|mlist_pos
operator|->
name|mac
index|[
literal|1
index|]
argument_list|,
name|mlist_pos
operator|->
name|mac
index|[
literal|2
index|]
argument_list|,
name|mlist_pos
operator|->
name|mac
index|[
literal|3
index|]
argument_list|,
name|mlist_pos
operator|->
name|mac
index|[
literal|4
index|]
argument_list|,
name|mlist_pos
operator|->
name|mac
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
block|}
operator|*
name|line_idx
operator|=
name|cnt
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ecore_mcast_hdl_del
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_mcast_obj
modifier|*
name|o
parameter_list|,
name|struct
name|ecore_mcast_ramrod_params
modifier|*
name|p
parameter_list|,
name|int
modifier|*
name|line_idx
parameter_list|)
block|{
name|int
name|cnt
init|=
operator|*
name|line_idx
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|mcast_list_len
condition|;
name|i
operator|++
control|)
block|{
name|o
operator|->
name|set_one_rule
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
name|cnt
argument_list|,
name|NULL
argument_list|,
name|ECORE_MCAST_CMD_DEL
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"Deleting MAC. %d left\n"
argument_list|,
name|p
operator|->
name|mcast_list_len
operator|-
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|line_idx
operator|=
name|cnt
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ecore_mcast_handle_current_cmd -  *  * @sc:		device handle  * @p:  * @cmd:  * @start_cnt:	first line in the ramrod data that may be used  *  * This function is called iff there is enough place for the current command in  * the ramrod data.  * Returns number of lines filled in the ramrod data in total.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ecore_mcast_handle_current_cmd
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_mcast_ramrod_params
modifier|*
name|p
parameter_list|,
name|enum
name|ecore_mcast_cmd
name|cmd
parameter_list|,
name|int
name|start_cnt
parameter_list|)
block|{
name|struct
name|ecore_mcast_obj
modifier|*
name|o
init|=
name|p
operator|->
name|mcast_obj
decl_stmt|;
name|int
name|cnt
init|=
name|start_cnt
decl_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"p->mcast_list_len=%d\n"
argument_list|,
name|p
operator|->
name|mcast_list_len
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|ECORE_MCAST_CMD_ADD
case|:
name|ecore_mcast_hdl_add
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
name|p
argument_list|,
operator|&
name|cnt
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECORE_MCAST_CMD_DEL
case|:
name|ecore_mcast_hdl_del
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
name|p
argument_list|,
operator|&
name|cnt
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECORE_MCAST_CMD_RESTORE
case|:
name|o
operator|->
name|hdl_restore
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
literal|0
argument_list|,
operator|&
name|cnt
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ECORE_ERR
argument_list|(
literal|"Unknown command: %d\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
comment|/* The current command has been handled */
name|p
operator|->
name|mcast_list_len
operator|=
literal|0
expr_stmt|;
return|return
name|cnt
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ecore_mcast_validate_e2
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_mcast_ramrod_params
modifier|*
name|p
parameter_list|,
name|enum
name|ecore_mcast_cmd
name|cmd
parameter_list|)
block|{
name|struct
name|ecore_mcast_obj
modifier|*
name|o
init|=
name|p
operator|->
name|mcast_obj
decl_stmt|;
name|int
name|reg_sz
init|=
name|o
operator|->
name|get_registry_size
argument_list|(
name|o
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
comment|/* DEL command deletes all currently configured MACs */
case|case
name|ECORE_MCAST_CMD_DEL
case|:
name|o
operator|->
name|set_registry_size
argument_list|(
name|o
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Don't break */
comment|/* RESTORE command will restore the entire multicast configuration */
case|case
name|ECORE_MCAST_CMD_RESTORE
case|:
comment|/* Here we set the approximate amount of work to do, which in 		 * fact may be only less as some MACs in postponed ADD 		 * command(s) scheduled before this command may fall into 		 * the same bin and the actual number of bins set in the 		 * registry would be less than we estimated here. See 		 * ecore_mcast_set_one_rule_e2() for further details. 		 */
name|p
operator|->
name|mcast_list_len
operator|=
name|reg_sz
expr_stmt|;
break|break;
case|case
name|ECORE_MCAST_CMD_ADD
case|:
case|case
name|ECORE_MCAST_CMD_CONT
case|:
comment|/* Here we assume that all new MACs will fall into new bins. 		 * However we will correct the real registry size after we 		 * handle all pending commands. 		 */
name|o
operator|->
name|set_registry_size
argument_list|(
name|o
argument_list|,
name|reg_sz
operator|+
name|p
operator|->
name|mcast_list_len
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ECORE_ERR
argument_list|(
literal|"Unknown command: %d\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
comment|/* Increase the total number of MACs pending to be configured */
name|o
operator|->
name|total_pending_num
operator|+=
name|p
operator|->
name|mcast_list_len
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_mcast_revert_e2
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_mcast_ramrod_params
modifier|*
name|p
parameter_list|,
name|int
name|old_num_bins
parameter_list|)
block|{
name|struct
name|ecore_mcast_obj
modifier|*
name|o
init|=
name|p
operator|->
name|mcast_obj
decl_stmt|;
name|o
operator|->
name|set_registry_size
argument_list|(
name|o
argument_list|,
name|old_num_bins
argument_list|)
expr_stmt|;
name|o
operator|->
name|total_pending_num
operator|-=
name|p
operator|->
name|mcast_list_len
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ecore_mcast_set_rdata_hdr_e2 - sets a header values  *  * @sc:		device handle  * @p:  * @len:	number of rules to handle  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ecore_mcast_set_rdata_hdr_e2
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_mcast_ramrod_params
modifier|*
name|p
parameter_list|,
name|uint8_t
name|len
parameter_list|)
block|{
name|struct
name|ecore_raw_obj
modifier|*
name|r
init|=
operator|&
name|p
operator|->
name|mcast_obj
operator|->
name|raw
decl_stmt|;
name|struct
name|eth_multicast_rules_ramrod_data
modifier|*
name|data
init|=
operator|(
expr|struct
name|eth_multicast_rules_ramrod_data
operator|*
operator|)
operator|(
name|r
operator|->
name|rdata
operator|)
decl_stmt|;
name|data
operator|->
name|header
operator|.
name|echo
operator|=
name|ECORE_CPU_TO_LE32
argument_list|(
operator|(
name|r
operator|->
name|cid
operator|&
name|ECORE_SWCID_MASK
operator|)
operator||
operator|(
name|ECORE_FILTER_MCAST_PENDING
operator|<<
name|ECORE_SWCID_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|data
operator|->
name|header
operator|.
name|rule_cnt
operator|=
name|len
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ecore_mcast_refresh_registry_e2 - recalculate the actual number of set bins  *  * @sc:		device handle  * @o:  *  * Recalculate the actual number of set bins in the registry using Brian  * Kernighan's algorithm: it's execution complexity is as a number of set bins.  *  * returns 0 for the compliance with ecore_mcast_refresh_registry_e1().  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ecore_mcast_refresh_registry_e2
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_mcast_obj
modifier|*
name|o
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|cnt
init|=
literal|0
decl_stmt|;
name|uint64_t
name|elem
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ECORE_MCAST_VEC_SZ
condition|;
name|i
operator|++
control|)
block|{
name|elem
operator|=
name|o
operator|->
name|registry
operator|.
name|aprox_match
operator|.
name|vec
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
init|;
name|elem
condition|;
name|cnt
operator|++
control|)
name|elem
operator|&=
name|elem
operator|-
literal|1
expr_stmt|;
block|}
name|o
operator|->
name|set_registry_size
argument_list|(
name|o
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ecore_mcast_setup_e2
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_mcast_ramrod_params
modifier|*
name|p
parameter_list|,
name|enum
name|ecore_mcast_cmd
name|cmd
parameter_list|)
block|{
name|struct
name|ecore_raw_obj
modifier|*
name|raw
init|=
operator|&
name|p
operator|->
name|mcast_obj
operator|->
name|raw
decl_stmt|;
name|struct
name|ecore_mcast_obj
modifier|*
name|o
init|=
name|p
operator|->
name|mcast_obj
decl_stmt|;
name|struct
name|eth_multicast_rules_ramrod_data
modifier|*
name|data
init|=
operator|(
expr|struct
name|eth_multicast_rules_ramrod_data
operator|*
operator|)
operator|(
name|raw
operator|->
name|rdata
operator|)
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|,
name|rc
decl_stmt|;
comment|/* Reset the ramrod data buffer */
name|ECORE_MEMSET
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|cnt
operator|=
name|ecore_mcast_handle_pending_cmds_e2
argument_list|(
name|sc
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* If there are no more pending commands - clear SCHEDULED state */
if|if
condition|(
name|ECORE_LIST_IS_EMPTY
argument_list|(
operator|&
name|o
operator|->
name|pending_cmds_head
argument_list|)
condition|)
name|o
operator|->
name|clear_sched
argument_list|(
name|o
argument_list|)
expr_stmt|;
comment|/* The below may be TRUE iff there was enough room in ramrod 	 * data for all pending commands and for the current 	 * command. Otherwise the current command would have been added 	 * to the pending commands and p->mcast_list_len would have been 	 * zeroed. 	 */
if|if
condition|(
name|p
operator|->
name|mcast_list_len
operator|>
literal|0
condition|)
name|cnt
operator|=
name|ecore_mcast_handle_current_cmd
argument_list|(
name|sc
argument_list|,
name|p
argument_list|,
name|cmd
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
comment|/* We've pulled out some MACs - update the total number of 	 * outstanding. 	 */
name|o
operator|->
name|total_pending_num
operator|-=
name|cnt
expr_stmt|;
comment|/* send a ramrod */
name|ECORE_DBG_BREAK_IF
argument_list|(
name|o
operator|->
name|total_pending_num
operator|<
literal|0
argument_list|)
expr_stmt|;
name|ECORE_DBG_BREAK_IF
argument_list|(
name|cnt
operator|>
name|o
operator|->
name|max_cmd_len
argument_list|)
expr_stmt|;
name|ecore_mcast_set_rdata_hdr_e2
argument_list|(
name|sc
argument_list|,
name|p
argument_list|,
operator|(
name|uint8_t
operator|)
name|cnt
argument_list|)
expr_stmt|;
comment|/* Update a registry size if there are no more pending operations. 	 * 	 * We don't want to change the value of the registry size if there are 	 * pending operations because we want it to always be equal to the 	 * exact or the approximate number (see ecore_mcast_validate_e2()) of 	 * set bins after the last requested operation in order to properly 	 * evaluate the size of the next DEL/RESTORE operation. 	 * 	 * Note that we update the registry itself during command(s) handling 	 * - see ecore_mcast_set_one_rule_e2(). That's because for 57712 we 	 * aggregate multiple commands (ADD/DEL/RESTORE) into one ramrod but 	 * with a limited amount of update commands (per MAC/bin) and we don't 	 * know in this scope what the actual state of bins configuration is 	 * going to be after this ramrod. 	 */
if|if
condition|(
operator|!
name|o
operator|->
name|total_pending_num
condition|)
name|ecore_mcast_refresh_registry_e2
argument_list|(
name|sc
argument_list|,
name|o
argument_list|)
expr_stmt|;
comment|/* If CLEAR_ONLY was requested - don't send a ramrod and clear 	 * RAMROD_PENDING status immediately. 	 */
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|RAMROD_DRV_CLR_ONLY
argument_list|,
operator|&
name|p
operator|->
name|ramrod_flags
argument_list|)
condition|)
block|{
name|raw
operator|->
name|clear_pending
argument_list|(
name|raw
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
else|else
block|{
comment|/* No need for an explicit memory barrier here as long we would 		 * need to ensure the ordering of writing to the SPQ element 		 * and updating of the SPQ producer which involves a memory 		 * read and we will have to put a full memory barrier there 		 * (inside ecore_sp_post()). 		 */
comment|/* Send a ramrod */
name|rc
operator|=
name|ecore_sp_post
argument_list|(
name|sc
argument_list|,
name|RAMROD_CMD_ID_ETH_MULTICAST_RULES
argument_list|,
name|raw
operator|->
name|cid
argument_list|,
name|raw
operator|->
name|rdata_mapping
argument_list|,
name|ETH_CONNECTION_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
comment|/* Ramrod completion is pending */
return|return
name|ECORE_PENDING
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ecore_mcast_validate_e1h
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_mcast_ramrod_params
modifier|*
name|p
parameter_list|,
name|enum
name|ecore_mcast_cmd
name|cmd
parameter_list|)
block|{
comment|/* Mark, that there is a work to do */
if|if
condition|(
operator|(
name|cmd
operator|==
name|ECORE_MCAST_CMD_DEL
operator|)
operator|||
operator|(
name|cmd
operator|==
name|ECORE_MCAST_CMD_RESTORE
operator|)
condition|)
name|p
operator|->
name|mcast_list_len
operator|=
literal|1
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_mcast_revert_e1h
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_mcast_ramrod_params
modifier|*
name|p
parameter_list|,
name|int
name|old_num_bins
parameter_list|)
block|{
comment|/* Do nothing */
block|}
end_function

begin_define
define|#
directive|define
name|ECORE_57711_SET_MC_FILTER
parameter_list|(
name|filter
parameter_list|,
name|bit
parameter_list|)
define|\
value|do { \ 	(filter)[(bit)>> 5] |= (1<< ((bit)& 0x1f)); \ } while (0)
end_define

begin_function
specifier|static
specifier|inline
name|void
name|ecore_mcast_hdl_add_e1h
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_mcast_obj
modifier|*
name|o
parameter_list|,
name|struct
name|ecore_mcast_ramrod_params
modifier|*
name|p
parameter_list|,
name|uint32_t
modifier|*
name|mc_filter
parameter_list|)
block|{
name|struct
name|ecore_mcast_list_elem
modifier|*
name|mlist_pos
decl_stmt|;
name|int
name|bit
decl_stmt|;
name|ECORE_LIST_FOR_EACH_ENTRY
argument_list|(
argument|mlist_pos
argument_list|,
argument|&p->mcast_list
argument_list|,
argument|link
argument_list|,
argument|struct ecore_mcast_list_elem
argument_list|)
block|{
name|bit
operator|=
name|ecore_mcast_bin_from_mac
argument_list|(
name|mlist_pos
operator|->
name|mac
argument_list|)
expr_stmt|;
name|ECORE_57711_SET_MC_FILTER
argument_list|(
name|mc_filter
argument_list|,
name|bit
argument_list|)
expr_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"About to configure %02x:%02x:%02x:%02x:%02x:%02x mcast MAC, bin %d\n"
argument_list|,
name|mlist_pos
operator|->
name|mac
index|[
literal|0
index|]
argument_list|,
name|mlist_pos
operator|->
name|mac
index|[
literal|1
index|]
argument_list|,
name|mlist_pos
operator|->
name|mac
index|[
literal|2
index|]
argument_list|,
name|mlist_pos
operator|->
name|mac
index|[
literal|3
index|]
argument_list|,
name|mlist_pos
operator|->
name|mac
index|[
literal|4
index|]
argument_list|,
name|mlist_pos
operator|->
name|mac
index|[
literal|5
index|]
argument_list|,
name|bit
argument_list|)
expr_stmt|;
comment|/* bookkeeping... */
name|BIT_VEC64_SET_BIT
argument_list|(
name|o
operator|->
name|registry
operator|.
name|aprox_match
operator|.
name|vec
argument_list|,
name|bit
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ecore_mcast_hdl_restore_e1h
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_mcast_obj
modifier|*
name|o
parameter_list|,
name|struct
name|ecore_mcast_ramrod_params
modifier|*
name|p
parameter_list|,
name|uint32_t
modifier|*
name|mc_filter
parameter_list|)
block|{
name|int
name|bit
decl_stmt|;
for|for
control|(
name|bit
operator|=
name|ecore_mcast_get_next_bin
argument_list|(
name|o
argument_list|,
literal|0
argument_list|)
init|;
name|bit
operator|>=
literal|0
condition|;
name|bit
operator|=
name|ecore_mcast_get_next_bin
argument_list|(
name|o
argument_list|,
name|bit
operator|+
literal|1
argument_list|)
control|)
block|{
name|ECORE_57711_SET_MC_FILTER
argument_list|(
name|mc_filter
argument_list|,
name|bit
argument_list|)
expr_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"About to set bin %d\n"
argument_list|,
name|bit
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* On 57711 we write the multicast MACs' approximate match  * table by directly into the TSTORM's internal RAM. So we don't  * really need to handle any tricks to make it work.  */
end_comment

begin_function
specifier|static
name|int
name|ecore_mcast_setup_e1h
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_mcast_ramrod_params
modifier|*
name|p
parameter_list|,
name|enum
name|ecore_mcast_cmd
name|cmd
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|ecore_mcast_obj
modifier|*
name|o
init|=
name|p
operator|->
name|mcast_obj
decl_stmt|;
name|struct
name|ecore_raw_obj
modifier|*
name|r
init|=
operator|&
name|o
operator|->
name|raw
decl_stmt|;
comment|/* If CLEAR_ONLY has been requested - clear the registry 	 * and clear a pending bit. 	 */
if|if
condition|(
operator|!
name|ECORE_TEST_BIT
argument_list|(
name|RAMROD_DRV_CLR_ONLY
argument_list|,
operator|&
name|p
operator|->
name|ramrod_flags
argument_list|)
condition|)
block|{
name|uint32_t
name|mc_filter
index|[
name|ECORE_MC_HASH_SIZE
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
comment|/* Set the multicast filter bits before writing it into 		 * the internal memory. 		 */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|ECORE_MCAST_CMD_ADD
case|:
name|ecore_mcast_hdl_add_e1h
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
name|p
argument_list|,
name|mc_filter
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECORE_MCAST_CMD_DEL
case|:
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"Invalidating multicast MACs configuration\n"
argument_list|)
expr_stmt|;
comment|/* clear the registry */
name|ECORE_MEMSET
argument_list|(
name|o
operator|->
name|registry
operator|.
name|aprox_match
operator|.
name|vec
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|o
operator|->
name|registry
operator|.
name|aprox_match
operator|.
name|vec
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECORE_MCAST_CMD_RESTORE
case|:
name|ecore_mcast_hdl_restore_e1h
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
name|p
argument_list|,
name|mc_filter
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ECORE_ERR
argument_list|(
literal|"Unknown command: %d\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
comment|/* Set the mcast filter in the internal memory */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ECORE_MC_HASH_SIZE
condition|;
name|i
operator|++
control|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|ECORE_MC_HASH_OFFSET
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
argument_list|,
name|mc_filter
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* clear the registry */
name|ECORE_MEMSET
argument_list|(
name|o
operator|->
name|registry
operator|.
name|aprox_match
operator|.
name|vec
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|o
operator|->
name|registry
operator|.
name|aprox_match
operator|.
name|vec
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We are done */
name|r
operator|->
name|clear_pending
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ecore_mcast_validate_e1
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_mcast_ramrod_params
modifier|*
name|p
parameter_list|,
name|enum
name|ecore_mcast_cmd
name|cmd
parameter_list|)
block|{
name|struct
name|ecore_mcast_obj
modifier|*
name|o
init|=
name|p
operator|->
name|mcast_obj
decl_stmt|;
name|int
name|reg_sz
init|=
name|o
operator|->
name|get_registry_size
argument_list|(
name|o
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
comment|/* DEL command deletes all currently configured MACs */
case|case
name|ECORE_MCAST_CMD_DEL
case|:
name|o
operator|->
name|set_registry_size
argument_list|(
name|o
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Don't break */
comment|/* RESTORE command will restore the entire multicast configuration */
case|case
name|ECORE_MCAST_CMD_RESTORE
case|:
name|p
operator|->
name|mcast_list_len
operator|=
name|reg_sz
expr_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"Command %d, p->mcast_list_len=%d\n"
argument_list|,
name|cmd
argument_list|,
name|p
operator|->
name|mcast_list_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECORE_MCAST_CMD_ADD
case|:
case|case
name|ECORE_MCAST_CMD_CONT
case|:
comment|/* Multicast MACs on 57710 are configured as unicast MACs and 		 * there is only a limited number of CAM entries for that 		 * matter. 		 */
if|if
condition|(
name|p
operator|->
name|mcast_list_len
operator|>
name|o
operator|->
name|max_cmd_len
condition|)
block|{
name|ECORE_ERR
argument_list|(
literal|"Can't configure more than %d multicast MACs on 57710\n"
argument_list|,
name|o
operator|->
name|max_cmd_len
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
comment|/* Every configured MAC should be cleared if DEL command is 		 * called. Only the last ADD command is relevant as long as 		 * every ADD commands overrides the previous configuration. 		 */
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"p->mcast_list_len=%d\n"
argument_list|,
name|p
operator|->
name|mcast_list_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|mcast_list_len
operator|>
literal|0
condition|)
name|o
operator|->
name|set_registry_size
argument_list|(
name|o
argument_list|,
name|p
operator|->
name|mcast_list_len
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ECORE_ERR
argument_list|(
literal|"Unknown command: %d\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
comment|/* We want to ensure that commands are executed one by one for 57710. 	 * Therefore each none-empty command will consume o->max_cmd_len. 	 */
if|if
condition|(
name|p
operator|->
name|mcast_list_len
condition|)
name|o
operator|->
name|total_pending_num
operator|+=
name|o
operator|->
name|max_cmd_len
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_mcast_revert_e1
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_mcast_ramrod_params
modifier|*
name|p
parameter_list|,
name|int
name|old_num_macs
parameter_list|)
block|{
name|struct
name|ecore_mcast_obj
modifier|*
name|o
init|=
name|p
operator|->
name|mcast_obj
decl_stmt|;
name|o
operator|->
name|set_registry_size
argument_list|(
name|o
argument_list|,
name|old_num_macs
argument_list|)
expr_stmt|;
comment|/* If current command hasn't been handled yet and we are 	 * here means that it's meant to be dropped and we have to 	 * update the number of outstanding MACs accordingly. 	 */
if|if
condition|(
name|p
operator|->
name|mcast_list_len
condition|)
name|o
operator|->
name|total_pending_num
operator|-=
name|o
operator|->
name|max_cmd_len
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_mcast_set_one_rule_e1
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_mcast_obj
modifier|*
name|o
parameter_list|,
name|int
name|idx
parameter_list|,
name|union
name|ecore_mcast_config_data
modifier|*
name|cfg_data
parameter_list|,
name|enum
name|ecore_mcast_cmd
name|cmd
parameter_list|)
block|{
name|struct
name|ecore_raw_obj
modifier|*
name|r
init|=
operator|&
name|o
operator|->
name|raw
decl_stmt|;
name|struct
name|mac_configuration_cmd
modifier|*
name|data
init|=
operator|(
expr|struct
name|mac_configuration_cmd
operator|*
operator|)
operator|(
name|r
operator|->
name|rdata
operator|)
decl_stmt|;
comment|/* copy mac */
if|if
condition|(
operator|(
name|cmd
operator|==
name|ECORE_MCAST_CMD_ADD
operator|)
operator|||
operator|(
name|cmd
operator|==
name|ECORE_MCAST_CMD_RESTORE
operator|)
condition|)
block|{
name|ecore_set_fw_mac_addr
argument_list|(
operator|&
name|data
operator|->
name|config_table
index|[
name|idx
index|]
operator|.
name|msb_mac_addr
argument_list|,
operator|&
name|data
operator|->
name|config_table
index|[
name|idx
index|]
operator|.
name|middle_mac_addr
argument_list|,
operator|&
name|data
operator|->
name|config_table
index|[
name|idx
index|]
operator|.
name|lsb_mac_addr
argument_list|,
name|cfg_data
operator|->
name|mac
argument_list|)
expr_stmt|;
name|data
operator|->
name|config_table
index|[
name|idx
index|]
operator|.
name|vlan_id
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|config_table
index|[
name|idx
index|]
operator|.
name|pf_id
operator|=
name|r
operator|->
name|func_id
expr_stmt|;
name|data
operator|->
name|config_table
index|[
name|idx
index|]
operator|.
name|clients_bit_vector
operator|=
name|ECORE_CPU_TO_LE32
argument_list|(
literal|1
operator|<<
name|r
operator|->
name|cl_id
argument_list|)
expr_stmt|;
name|ECORE_SET_FLAG
argument_list|(
name|data
operator|->
name|config_table
index|[
name|idx
index|]
operator|.
name|flags
argument_list|,
name|MAC_CONFIGURATION_ENTRY_ACTION_TYPE
argument_list|,
name|T_ETH_MAC_COMMAND_SET
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * ecore_mcast_set_rdata_hdr_e1  - set header values in mac_configuration_cmd  *  * @sc:		device handle  * @p:  * @len:	number of rules to handle  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ecore_mcast_set_rdata_hdr_e1
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_mcast_ramrod_params
modifier|*
name|p
parameter_list|,
name|uint8_t
name|len
parameter_list|)
block|{
name|struct
name|ecore_raw_obj
modifier|*
name|r
init|=
operator|&
name|p
operator|->
name|mcast_obj
operator|->
name|raw
decl_stmt|;
name|struct
name|mac_configuration_cmd
modifier|*
name|data
init|=
operator|(
expr|struct
name|mac_configuration_cmd
operator|*
operator|)
operator|(
name|r
operator|->
name|rdata
operator|)
decl_stmt|;
name|uint8_t
name|offset
init|=
operator|(
name|CHIP_REV_IS_SLOW
argument_list|(
name|sc
argument_list|)
condition|?
name|ECORE_MAX_EMUL_MULTI
operator|*
operator|(
literal|1
operator|+
name|r
operator|->
name|func_id
operator|)
else|:
name|ECORE_MAX_MULTICAST
operator|*
operator|(
literal|1
operator|+
name|r
operator|->
name|func_id
operator|)
operator|)
decl_stmt|;
name|data
operator|->
name|hdr
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|data
operator|->
name|hdr
operator|.
name|client_id
operator|=
name|ECORE_CPU_TO_LE16
argument_list|(
literal|0xff
argument_list|)
expr_stmt|;
name|data
operator|->
name|hdr
operator|.
name|echo
operator|=
name|ECORE_CPU_TO_LE32
argument_list|(
operator|(
name|r
operator|->
name|cid
operator|&
name|ECORE_SWCID_MASK
operator|)
operator||
operator|(
name|ECORE_FILTER_MCAST_PENDING
operator|<<
name|ECORE_SWCID_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|data
operator|->
name|hdr
operator|.
name|length
operator|=
name|len
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ecore_mcast_handle_restore_cmd_e1 - restore command for 57710  *  * @sc:		device handle  * @o:  * @start_idx:	index in the registry to start from  * @rdata_idx:	index in the ramrod data to start from  *  * restore command for 57710 is like all other commands - always a stand alone  * command - start_idx and rdata_idx will always be 0. This function will always  * succeed.  * returns -1 to comply with 57712 variant.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ecore_mcast_handle_restore_cmd_e1
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_mcast_obj
modifier|*
name|o
parameter_list|,
name|int
name|start_idx
parameter_list|,
name|int
modifier|*
name|rdata_idx
parameter_list|)
block|{
name|struct
name|ecore_mcast_mac_elem
modifier|*
name|elem
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|union
name|ecore_mcast_config_data
name|cfg_data
init|=
block|{
name|NULL
block|}
decl_stmt|;
comment|/* go through the registry and configure the MACs from it. */
name|ECORE_LIST_FOR_EACH_ENTRY
argument_list|(
argument|elem
argument_list|,
argument|&o->registry.exact_match.macs
argument_list|,
argument|link
argument_list|,
argument|struct ecore_mcast_mac_elem
argument_list|)
block|{
name|cfg_data
operator|.
name|mac
operator|=
operator|&
name|elem
operator|->
name|mac
index|[
literal|0
index|]
expr_stmt|;
name|o
operator|->
name|set_one_rule
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
name|i
argument_list|,
operator|&
name|cfg_data
argument_list|,
name|ECORE_MCAST_CMD_RESTORE
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"About to configure %02x:%02x:%02x:%02x:%02x:%02x mcast MAC\n"
argument_list|,
name|cfg_data
operator|.
name|mac
index|[
literal|0
index|]
argument_list|,
name|cfg_data
operator|.
name|mac
index|[
literal|1
index|]
argument_list|,
name|cfg_data
operator|.
name|mac
index|[
literal|2
index|]
argument_list|,
name|cfg_data
operator|.
name|mac
index|[
literal|3
index|]
argument_list|,
name|cfg_data
operator|.
name|mac
index|[
literal|4
index|]
argument_list|,
name|cfg_data
operator|.
name|mac
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
block|}
operator|*
name|rdata_idx
operator|=
name|i
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|ecore_mcast_handle_pending_cmds_e1
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_mcast_ramrod_params
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ecore_pending_mcast_cmd
modifier|*
name|cmd_pos
decl_stmt|;
name|struct
name|ecore_mcast_mac_elem
modifier|*
name|pmac_pos
decl_stmt|;
name|struct
name|ecore_mcast_obj
modifier|*
name|o
init|=
name|p
operator|->
name|mcast_obj
decl_stmt|;
name|union
name|ecore_mcast_config_data
name|cfg_data
init|=
block|{
name|NULL
block|}
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|;
comment|/* If nothing to be done - return */
if|if
condition|(
name|ECORE_LIST_IS_EMPTY
argument_list|(
operator|&
name|o
operator|->
name|pending_cmds_head
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Handle the first command */
name|cmd_pos
operator|=
name|ECORE_LIST_FIRST_ENTRY
argument_list|(
operator|&
name|o
operator|->
name|pending_cmds_head
argument_list|,
expr|struct
name|ecore_pending_mcast_cmd
argument_list|,
name|link
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd_pos
operator|->
name|type
condition|)
block|{
case|case
name|ECORE_MCAST_CMD_ADD
case|:
name|ECORE_LIST_FOR_EACH_ENTRY
argument_list|(
argument|pmac_pos
argument_list|,
argument|&cmd_pos->data.macs_head
argument_list|,
argument|link
argument_list|,
argument|struct ecore_mcast_mac_elem
argument_list|)
block|{
name|cfg_data
operator|.
name|mac
operator|=
operator|&
name|pmac_pos
operator|->
name|mac
index|[
literal|0
index|]
expr_stmt|;
name|o
operator|->
name|set_one_rule
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
name|cnt
argument_list|,
operator|&
name|cfg_data
argument_list|,
name|cmd_pos
operator|->
name|type
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"About to configure %02x:%02x:%02x:%02x:%02x:%02x mcast MAC\n"
argument_list|,
name|pmac_pos
operator|->
name|mac
index|[
literal|0
index|]
argument_list|,
name|pmac_pos
operator|->
name|mac
index|[
literal|1
index|]
argument_list|,
name|pmac_pos
operator|->
name|mac
index|[
literal|2
index|]
argument_list|,
name|pmac_pos
operator|->
name|mac
index|[
literal|3
index|]
argument_list|,
name|pmac_pos
operator|->
name|mac
index|[
literal|4
index|]
argument_list|,
name|pmac_pos
operator|->
name|mac
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ECORE_MCAST_CMD_DEL
case|:
name|cnt
operator|=
name|cmd_pos
operator|->
name|data
operator|.
name|macs_num
expr_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"About to delete %d multicast MACs\n"
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECORE_MCAST_CMD_RESTORE
case|:
name|o
operator|->
name|hdl_restore
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
literal|0
argument_list|,
operator|&
name|cnt
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ECORE_ERR
argument_list|(
literal|"Unknown command: %d\n"
argument_list|,
name|cmd_pos
operator|->
name|type
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
name|ECORE_LIST_REMOVE_ENTRY
argument_list|(
operator|&
name|cmd_pos
operator|->
name|link
argument_list|,
operator|&
name|o
operator|->
name|pending_cmds_head
argument_list|)
expr_stmt|;
name|ECORE_FREE
argument_list|(
name|sc
argument_list|,
name|cmd_pos
argument_list|,
name|cmd_pos
operator|->
name|alloc_len
argument_list|)
expr_stmt|;
return|return
name|cnt
return|;
block|}
end_function

begin_comment
comment|/**  * ecore_get_fw_mac_addr - revert the ecore_set_fw_mac_addr().  *  * @fw_hi:  * @fw_mid:  * @fw_lo:  * @mac:  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ecore_get_fw_mac_addr
parameter_list|(
name|uint16_t
modifier|*
name|fw_hi
parameter_list|,
name|uint16_t
modifier|*
name|fw_mid
parameter_list|,
name|uint16_t
modifier|*
name|fw_lo
parameter_list|,
name|uint8_t
modifier|*
name|mac
parameter_list|)
block|{
name|mac
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|fw_hi
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|mac
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|fw_hi
operator|)
index|[
literal|1
index|]
expr_stmt|;
name|mac
index|[
literal|3
index|]
operator|=
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|fw_mid
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|mac
index|[
literal|2
index|]
operator|=
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|fw_mid
operator|)
index|[
literal|1
index|]
expr_stmt|;
name|mac
index|[
literal|5
index|]
operator|=
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|fw_lo
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|mac
index|[
literal|4
index|]
operator|=
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|fw_lo
operator|)
index|[
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ecore_mcast_refresh_registry_e1 -  *  * @sc:		device handle  * @cnt:  *  * Check the ramrod data first entry flag to see if it's a DELETE or ADD command  * and update the registry correspondingly: if ADD - allocate a memory and add  * the entries to the registry (list), if DELETE - clear the registry and free  * the memory.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ecore_mcast_refresh_registry_e1
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_mcast_obj
modifier|*
name|o
parameter_list|)
block|{
name|struct
name|ecore_raw_obj
modifier|*
name|raw
init|=
operator|&
name|o
operator|->
name|raw
decl_stmt|;
name|struct
name|ecore_mcast_mac_elem
modifier|*
name|elem
decl_stmt|;
name|struct
name|mac_configuration_cmd
modifier|*
name|data
init|=
operator|(
expr|struct
name|mac_configuration_cmd
operator|*
operator|)
operator|(
name|raw
operator|->
name|rdata
operator|)
decl_stmt|;
comment|/* If first entry contains a SET bit - the command was ADD, 	 * otherwise - DEL_ALL 	 */
if|if
condition|(
name|ECORE_GET_FLAG
argument_list|(
name|data
operator|->
name|config_table
index|[
literal|0
index|]
operator|.
name|flags
argument_list|,
name|MAC_CONFIGURATION_ENTRY_ACTION_TYPE
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|,
name|len
init|=
name|data
operator|->
name|hdr
operator|.
name|length
decl_stmt|;
comment|/* Break if it was a RESTORE command */
if|if
condition|(
operator|!
name|ECORE_LIST_IS_EMPTY
argument_list|(
operator|&
name|o
operator|->
name|registry
operator|.
name|exact_match
operator|.
name|macs
argument_list|)
condition|)
return|return
name|ECORE_SUCCESS
return|;
name|elem
operator|=
name|ECORE_CALLOC
argument_list|(
name|len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|elem
argument_list|)
argument_list|,
name|GFP_ATOMIC
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elem
condition|)
block|{
name|ECORE_ERR
argument_list|(
literal|"Failed to allocate registry memory\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_NOMEM
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|elem
operator|++
control|)
block|{
name|ecore_get_fw_mac_addr
argument_list|(
operator|&
name|data
operator|->
name|config_table
index|[
name|i
index|]
operator|.
name|msb_mac_addr
argument_list|,
operator|&
name|data
operator|->
name|config_table
index|[
name|i
index|]
operator|.
name|middle_mac_addr
argument_list|,
operator|&
name|data
operator|->
name|config_table
index|[
name|i
index|]
operator|.
name|lsb_mac_addr
argument_list|,
name|elem
operator|->
name|mac
argument_list|)
expr_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"Adding registry entry for [%02x:%02x:%02x:%02x:%02x:%02x]\n"
argument_list|,
name|elem
operator|->
name|mac
index|[
literal|0
index|]
argument_list|,
name|elem
operator|->
name|mac
index|[
literal|1
index|]
argument_list|,
name|elem
operator|->
name|mac
index|[
literal|2
index|]
argument_list|,
name|elem
operator|->
name|mac
index|[
literal|3
index|]
argument_list|,
name|elem
operator|->
name|mac
index|[
literal|4
index|]
argument_list|,
name|elem
operator|->
name|mac
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|ECORE_LIST_PUSH_TAIL
argument_list|(
operator|&
name|elem
operator|->
name|link
argument_list|,
operator|&
name|o
operator|->
name|registry
operator|.
name|exact_match
operator|.
name|macs
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|elem
operator|=
name|ECORE_LIST_FIRST_ENTRY
argument_list|(
operator|&
name|o
operator|->
name|registry
operator|.
name|exact_match
operator|.
name|macs
argument_list|,
expr|struct
name|ecore_mcast_mac_elem
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"Deleting a registry\n"
argument_list|)
expr_stmt|;
name|ECORE_FREE
argument_list|(
name|sc
argument_list|,
name|elem
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|elem
argument_list|)
argument_list|)
expr_stmt|;
name|ECORE_LIST_INIT
argument_list|(
operator|&
name|o
operator|->
name|registry
operator|.
name|exact_match
operator|.
name|macs
argument_list|)
expr_stmt|;
block|}
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ecore_mcast_setup_e1
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_mcast_ramrod_params
modifier|*
name|p
parameter_list|,
name|enum
name|ecore_mcast_cmd
name|cmd
parameter_list|)
block|{
name|struct
name|ecore_mcast_obj
modifier|*
name|o
init|=
name|p
operator|->
name|mcast_obj
decl_stmt|;
name|struct
name|ecore_raw_obj
modifier|*
name|raw
init|=
operator|&
name|o
operator|->
name|raw
decl_stmt|;
name|struct
name|mac_configuration_cmd
modifier|*
name|data
init|=
operator|(
expr|struct
name|mac_configuration_cmd
operator|*
operator|)
operator|(
name|raw
operator|->
name|rdata
operator|)
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|rc
decl_stmt|;
comment|/* Reset the ramrod data buffer */
name|ECORE_MEMSET
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
argument_list|)
expr_stmt|;
comment|/* First set all entries as invalid */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|o
operator|->
name|max_cmd_len
condition|;
name|i
operator|++
control|)
name|ECORE_SET_FLAG
argument_list|(
name|data
operator|->
name|config_table
index|[
name|i
index|]
operator|.
name|flags
argument_list|,
name|MAC_CONFIGURATION_ENTRY_ACTION_TYPE
argument_list|,
name|T_ETH_MAC_COMMAND_INVALIDATE
argument_list|)
expr_stmt|;
comment|/* Handle pending commands first */
name|cnt
operator|=
name|ecore_mcast_handle_pending_cmds_e1
argument_list|(
name|sc
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* If there are no more pending commands - clear SCHEDULED state */
if|if
condition|(
name|ECORE_LIST_IS_EMPTY
argument_list|(
operator|&
name|o
operator|->
name|pending_cmds_head
argument_list|)
condition|)
name|o
operator|->
name|clear_sched
argument_list|(
name|o
argument_list|)
expr_stmt|;
comment|/* The below may be TRUE iff there were no pending commands */
if|if
condition|(
operator|!
name|cnt
condition|)
name|cnt
operator|=
name|ecore_mcast_handle_current_cmd
argument_list|(
name|sc
argument_list|,
name|p
argument_list|,
name|cmd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* For 57710 every command has o->max_cmd_len length to ensure that 	 * commands are done one at a time. 	 */
name|o
operator|->
name|total_pending_num
operator|-=
name|o
operator|->
name|max_cmd_len
expr_stmt|;
comment|/* send a ramrod */
name|ECORE_DBG_BREAK_IF
argument_list|(
name|cnt
operator|>
name|o
operator|->
name|max_cmd_len
argument_list|)
expr_stmt|;
comment|/* Set ramrod header (in particular, a number of entries to update) */
name|ecore_mcast_set_rdata_hdr_e1
argument_list|(
name|sc
argument_list|,
name|p
argument_list|,
operator|(
name|uint8_t
operator|)
name|cnt
argument_list|)
expr_stmt|;
comment|/* update a registry: we need the registry contents to be always up 	 * to date in order to be able to execute a RESTORE opcode. Here 	 * we use the fact that for 57710 we sent one command at a time 	 * hence we may take the registry update out of the command handling 	 * and do it in a simpler way here. 	 */
name|rc
operator|=
name|ecore_mcast_refresh_registry_e1
argument_list|(
name|sc
argument_list|,
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
comment|/* If CLEAR_ONLY was requested - don't send a ramrod and clear 	 * RAMROD_PENDING status immediately. 	 */
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|RAMROD_DRV_CLR_ONLY
argument_list|,
operator|&
name|p
operator|->
name|ramrod_flags
argument_list|)
condition|)
block|{
name|raw
operator|->
name|clear_pending
argument_list|(
name|raw
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
else|else
block|{
comment|/* No need for an explicit memory barrier here as long we would 		 * need to ensure the ordering of writing to the SPQ element 		 * and updating of the SPQ producer which involves a memory 		 * read and we will have to put a full memory barrier there 		 * (inside ecore_sp_post()). 		 */
comment|/* Send a ramrod */
name|rc
operator|=
name|ecore_sp_post
argument_list|(
name|sc
argument_list|,
name|RAMROD_CMD_ID_ETH_SET_MAC
argument_list|,
name|raw
operator|->
name|cid
argument_list|,
name|raw
operator|->
name|rdata_mapping
argument_list|,
name|ETH_CONNECTION_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
comment|/* Ramrod completion is pending */
return|return
name|ECORE_PENDING
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ecore_mcast_get_registry_size_exact
parameter_list|(
name|struct
name|ecore_mcast_obj
modifier|*
name|o
parameter_list|)
block|{
return|return
name|o
operator|->
name|registry
operator|.
name|exact_match
operator|.
name|num_macs_set
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ecore_mcast_get_registry_size_aprox
parameter_list|(
name|struct
name|ecore_mcast_obj
modifier|*
name|o
parameter_list|)
block|{
return|return
name|o
operator|->
name|registry
operator|.
name|aprox_match
operator|.
name|num_bins_set
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_mcast_set_registry_size_exact
parameter_list|(
name|struct
name|ecore_mcast_obj
modifier|*
name|o
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|o
operator|->
name|registry
operator|.
name|exact_match
operator|.
name|num_macs_set
operator|=
name|n
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_mcast_set_registry_size_aprox
parameter_list|(
name|struct
name|ecore_mcast_obj
modifier|*
name|o
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|o
operator|->
name|registry
operator|.
name|aprox_match
operator|.
name|num_bins_set
operator|=
name|n
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ecore_config_mcast
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_mcast_ramrod_params
modifier|*
name|p
parameter_list|,
name|enum
name|ecore_mcast_cmd
name|cmd
parameter_list|)
block|{
name|struct
name|ecore_mcast_obj
modifier|*
name|o
init|=
name|p
operator|->
name|mcast_obj
decl_stmt|;
name|struct
name|ecore_raw_obj
modifier|*
name|r
init|=
operator|&
name|o
operator|->
name|raw
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|,
name|old_reg_size
decl_stmt|;
comment|/* This is needed to recover number of currently configured mcast macs 	 * in case of failure. 	 */
name|old_reg_size
operator|=
name|o
operator|->
name|get_registry_size
argument_list|(
name|o
argument_list|)
expr_stmt|;
comment|/* Do some calculations and checks */
name|rc
operator|=
name|o
operator|->
name|validate
argument_list|(
name|sc
argument_list|,
name|p
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
comment|/* Return if there is no work to do */
if|if
condition|(
operator|(
operator|!
name|p
operator|->
name|mcast_list_len
operator|)
operator|&&
operator|(
operator|!
name|o
operator|->
name|check_sched
argument_list|(
name|o
argument_list|)
operator|)
condition|)
return|return
name|ECORE_SUCCESS
return|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"o->total_pending_num=%d p->mcast_list_len=%d o->max_cmd_len=%d\n"
argument_list|,
name|o
operator|->
name|total_pending_num
argument_list|,
name|p
operator|->
name|mcast_list_len
argument_list|,
name|o
operator|->
name|max_cmd_len
argument_list|)
expr_stmt|;
comment|/* Enqueue the current command to the pending list if we can't complete 	 * it in the current iteration 	 */
if|if
condition|(
name|r
operator|->
name|check_pending
argument_list|(
name|r
argument_list|)
operator|||
operator|(
operator|(
name|o
operator|->
name|max_cmd_len
operator|>
literal|0
operator|)
operator|&&
operator|(
name|o
operator|->
name|total_pending_num
operator|>
name|o
operator|->
name|max_cmd_len
operator|)
operator|)
condition|)
block|{
name|rc
operator|=
name|o
operator|->
name|enqueue_cmd
argument_list|(
name|sc
argument_list|,
name|p
operator|->
name|mcast_obj
argument_list|,
name|p
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
goto|goto
name|error_exit1
goto|;
comment|/* As long as the current command is in a command list we 		 * don't need to handle it separately. 		 */
name|p
operator|->
name|mcast_list_len
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|r
operator|->
name|check_pending
argument_list|(
name|r
argument_list|)
condition|)
block|{
comment|/* Set 'pending' state */
name|r
operator|->
name|set_pending
argument_list|(
name|r
argument_list|)
expr_stmt|;
comment|/* Configure the new classification in the chip */
name|rc
operator|=
name|o
operator|->
name|config_mcast
argument_list|(
name|sc
argument_list|,
name|p
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
goto|goto
name|error_exit2
goto|;
comment|/* Wait for a ramrod completion if was requested */
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|RAMROD_COMP_WAIT
argument_list|,
operator|&
name|p
operator|->
name|ramrod_flags
argument_list|)
condition|)
name|rc
operator|=
name|o
operator|->
name|wait_comp
argument_list|(
name|sc
argument_list|,
name|o
argument_list|)
expr_stmt|;
block|}
return|return
name|rc
return|;
name|error_exit2
label|:
name|r
operator|->
name|clear_pending
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|error_exit1
label|:
name|o
operator|->
name|revert
argument_list|(
name|sc
argument_list|,
name|p
argument_list|,
name|old_reg_size
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_mcast_clear_sched
parameter_list|(
name|struct
name|ecore_mcast_obj
modifier|*
name|o
parameter_list|)
block|{
name|ECORE_SMP_MB_BEFORE_CLEAR_BIT
argument_list|()
expr_stmt|;
name|ECORE_CLEAR_BIT
argument_list|(
name|o
operator|->
name|sched_state
argument_list|,
name|o
operator|->
name|raw
operator|.
name|pstate
argument_list|)
expr_stmt|;
name|ECORE_SMP_MB_AFTER_CLEAR_BIT
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_mcast_set_sched
parameter_list|(
name|struct
name|ecore_mcast_obj
modifier|*
name|o
parameter_list|)
block|{
name|ECORE_SMP_MB_BEFORE_CLEAR_BIT
argument_list|()
expr_stmt|;
name|ECORE_SET_BIT
argument_list|(
name|o
operator|->
name|sched_state
argument_list|,
name|o
operator|->
name|raw
operator|.
name|pstate
argument_list|)
expr_stmt|;
name|ECORE_SMP_MB_AFTER_CLEAR_BIT
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ecore_mcast_check_sched
parameter_list|(
name|struct
name|ecore_mcast_obj
modifier|*
name|o
parameter_list|)
block|{
return|return
operator|!
operator|!
name|ECORE_TEST_BIT
argument_list|(
name|o
operator|->
name|sched_state
argument_list|,
name|o
operator|->
name|raw
operator|.
name|pstate
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ecore_mcast_check_pending
parameter_list|(
name|struct
name|ecore_mcast_obj
modifier|*
name|o
parameter_list|)
block|{
return|return
name|o
operator|->
name|raw
operator|.
name|check_pending
argument_list|(
operator|&
name|o
operator|->
name|raw
argument_list|)
operator|||
name|o
operator|->
name|check_sched
argument_list|(
name|o
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|ecore_init_mcast_obj
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_mcast_obj
modifier|*
name|mcast_obj
parameter_list|,
name|uint8_t
name|mcast_cl_id
parameter_list|,
name|uint32_t
name|mcast_cid
parameter_list|,
name|uint8_t
name|func_id
parameter_list|,
name|uint8_t
name|engine_id
parameter_list|,
name|void
modifier|*
name|rdata
parameter_list|,
name|ecore_dma_addr_t
name|rdata_mapping
parameter_list|,
name|int
name|state
parameter_list|,
name|unsigned
name|long
modifier|*
name|pstate
parameter_list|,
name|ecore_obj_type
name|type
parameter_list|)
block|{
name|ECORE_MEMSET
argument_list|(
name|mcast_obj
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mcast_obj
argument_list|)
argument_list|)
expr_stmt|;
name|ecore_init_raw_obj
argument_list|(
operator|&
name|mcast_obj
operator|->
name|raw
argument_list|,
name|mcast_cl_id
argument_list|,
name|mcast_cid
argument_list|,
name|func_id
argument_list|,
name|rdata
argument_list|,
name|rdata_mapping
argument_list|,
name|state
argument_list|,
name|pstate
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|mcast_obj
operator|->
name|engine_id
operator|=
name|engine_id
expr_stmt|;
name|ECORE_LIST_INIT
argument_list|(
operator|&
name|mcast_obj
operator|->
name|pending_cmds_head
argument_list|)
expr_stmt|;
name|mcast_obj
operator|->
name|sched_state
operator|=
name|ECORE_FILTER_MCAST_SCHED
expr_stmt|;
name|mcast_obj
operator|->
name|check_sched
operator|=
name|ecore_mcast_check_sched
expr_stmt|;
name|mcast_obj
operator|->
name|set_sched
operator|=
name|ecore_mcast_set_sched
expr_stmt|;
name|mcast_obj
operator|->
name|clear_sched
operator|=
name|ecore_mcast_clear_sched
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|mcast_obj
operator|->
name|config_mcast
operator|=
name|ecore_mcast_setup_e1
expr_stmt|;
name|mcast_obj
operator|->
name|enqueue_cmd
operator|=
name|ecore_mcast_enqueue_cmd
expr_stmt|;
name|mcast_obj
operator|->
name|hdl_restore
operator|=
name|ecore_mcast_handle_restore_cmd_e1
expr_stmt|;
name|mcast_obj
operator|->
name|check_pending
operator|=
name|ecore_mcast_check_pending
expr_stmt|;
if|if
condition|(
name|CHIP_REV_IS_SLOW
argument_list|(
name|sc
argument_list|)
condition|)
name|mcast_obj
operator|->
name|max_cmd_len
operator|=
name|ECORE_MAX_EMUL_MULTI
expr_stmt|;
else|else
name|mcast_obj
operator|->
name|max_cmd_len
operator|=
name|ECORE_MAX_MULTICAST
expr_stmt|;
name|mcast_obj
operator|->
name|wait_comp
operator|=
name|ecore_mcast_wait
expr_stmt|;
name|mcast_obj
operator|->
name|set_one_rule
operator|=
name|ecore_mcast_set_one_rule_e1
expr_stmt|;
name|mcast_obj
operator|->
name|validate
operator|=
name|ecore_mcast_validate_e1
expr_stmt|;
name|mcast_obj
operator|->
name|revert
operator|=
name|ecore_mcast_revert_e1
expr_stmt|;
name|mcast_obj
operator|->
name|get_registry_size
operator|=
name|ecore_mcast_get_registry_size_exact
expr_stmt|;
name|mcast_obj
operator|->
name|set_registry_size
operator|=
name|ecore_mcast_set_registry_size_exact
expr_stmt|;
comment|/* 57710 is the only chip that uses the exact match for mcast 		 * at the moment. 		 */
name|ECORE_LIST_INIT
argument_list|(
operator|&
name|mcast_obj
operator|->
name|registry
operator|.
name|exact_match
operator|.
name|macs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|mcast_obj
operator|->
name|config_mcast
operator|=
name|ecore_mcast_setup_e1h
expr_stmt|;
name|mcast_obj
operator|->
name|enqueue_cmd
operator|=
name|NULL
expr_stmt|;
name|mcast_obj
operator|->
name|hdl_restore
operator|=
name|NULL
expr_stmt|;
name|mcast_obj
operator|->
name|check_pending
operator|=
name|ecore_mcast_check_pending
expr_stmt|;
comment|/* 57711 doesn't send a ramrod, so it has unlimited credit 		 * for one command. 		 */
name|mcast_obj
operator|->
name|max_cmd_len
operator|=
operator|-
literal|1
expr_stmt|;
name|mcast_obj
operator|->
name|wait_comp
operator|=
name|ecore_mcast_wait
expr_stmt|;
name|mcast_obj
operator|->
name|set_one_rule
operator|=
name|NULL
expr_stmt|;
name|mcast_obj
operator|->
name|validate
operator|=
name|ecore_mcast_validate_e1h
expr_stmt|;
name|mcast_obj
operator|->
name|revert
operator|=
name|ecore_mcast_revert_e1h
expr_stmt|;
name|mcast_obj
operator|->
name|get_registry_size
operator|=
name|ecore_mcast_get_registry_size_aprox
expr_stmt|;
name|mcast_obj
operator|->
name|set_registry_size
operator|=
name|ecore_mcast_set_registry_size_aprox
expr_stmt|;
block|}
else|else
block|{
name|mcast_obj
operator|->
name|config_mcast
operator|=
name|ecore_mcast_setup_e2
expr_stmt|;
name|mcast_obj
operator|->
name|enqueue_cmd
operator|=
name|ecore_mcast_enqueue_cmd
expr_stmt|;
name|mcast_obj
operator|->
name|hdl_restore
operator|=
name|ecore_mcast_handle_restore_cmd_e2
expr_stmt|;
name|mcast_obj
operator|->
name|check_pending
operator|=
name|ecore_mcast_check_pending
expr_stmt|;
comment|/* TODO: There should be a proper HSI define for this number!!! 		 */
name|mcast_obj
operator|->
name|max_cmd_len
operator|=
literal|16
expr_stmt|;
name|mcast_obj
operator|->
name|wait_comp
operator|=
name|ecore_mcast_wait
expr_stmt|;
name|mcast_obj
operator|->
name|set_one_rule
operator|=
name|ecore_mcast_set_one_rule_e2
expr_stmt|;
name|mcast_obj
operator|->
name|validate
operator|=
name|ecore_mcast_validate_e2
expr_stmt|;
name|mcast_obj
operator|->
name|revert
operator|=
name|ecore_mcast_revert_e2
expr_stmt|;
name|mcast_obj
operator|->
name|get_registry_size
operator|=
name|ecore_mcast_get_registry_size_aprox
expr_stmt|;
name|mcast_obj
operator|->
name|set_registry_size
operator|=
name|ecore_mcast_set_registry_size_aprox
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*************************** Credit handling **********************************/
end_comment

begin_comment
comment|/**  * atomic_add_ifless - add if the result is less than a given value.  *  * @v:	pointer of type ecore_atomic_t  * @a:	the amount to add to v...  * @u:	...if (v + a) is less than u.  *  * returns TRUE if (v + a) was less than u, and FALSE otherwise.  *  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|__atomic_add_ifless
parameter_list|(
name|ecore_atomic_t
modifier|*
name|v
parameter_list|,
name|int
name|a
parameter_list|,
name|int
name|u
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|old
decl_stmt|;
name|c
operator|=
name|ECORE_ATOMIC_READ
argument_list|(
name|v
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|ECORE_UNLIKELY
argument_list|(
name|c
operator|+
name|a
operator|>=
name|u
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|old
operator|=
name|ECORE_ATOMIC_CMPXCHG
argument_list|(
operator|(
name|v
operator|)
argument_list|,
name|c
argument_list|,
name|c
operator|+
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|ECORE_LIKELY
argument_list|(
name|old
operator|==
name|c
argument_list|)
condition|)
break|break;
name|c
operator|=
name|old
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/**  * atomic_dec_ifmoe - dec if the result is more or equal than a given value.  *  * @v:	pointer of type ecore_atomic_t  * @a:	the amount to dec from v...  * @u:	...if (v - a) is more or equal than u.  *  * returns TRUE if (v - a) was more or equal than u, and FALSE  * otherwise.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|__atomic_dec_ifmoe
parameter_list|(
name|ecore_atomic_t
modifier|*
name|v
parameter_list|,
name|int
name|a
parameter_list|,
name|int
name|u
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|old
decl_stmt|;
name|c
operator|=
name|ECORE_ATOMIC_READ
argument_list|(
name|v
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|ECORE_UNLIKELY
argument_list|(
name|c
operator|-
name|a
operator|<
name|u
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|old
operator|=
name|ECORE_ATOMIC_CMPXCHG
argument_list|(
operator|(
name|v
operator|)
argument_list|,
name|c
argument_list|,
name|c
operator|-
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|ECORE_LIKELY
argument_list|(
name|old
operator|==
name|c
argument_list|)
condition|)
break|break;
name|c
operator|=
name|old
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ecore_credit_pool_get
parameter_list|(
name|struct
name|ecore_credit_pool_obj
modifier|*
name|o
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|bool
name|rc
decl_stmt|;
name|ECORE_SMP_MB
argument_list|()
expr_stmt|;
name|rc
operator|=
name|__atomic_dec_ifmoe
argument_list|(
operator|&
name|o
operator|->
name|credit
argument_list|,
name|cnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ECORE_SMP_MB
argument_list|()
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ecore_credit_pool_put
parameter_list|(
name|struct
name|ecore_credit_pool_obj
modifier|*
name|o
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|bool
name|rc
decl_stmt|;
name|ECORE_SMP_MB
argument_list|()
expr_stmt|;
comment|/* Don't let to refill if credit + cnt> pool_sz */
name|rc
operator|=
name|__atomic_add_ifless
argument_list|(
operator|&
name|o
operator|->
name|credit
argument_list|,
name|cnt
argument_list|,
name|o
operator|->
name|pool_sz
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ECORE_SMP_MB
argument_list|()
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ecore_credit_pool_check
parameter_list|(
name|struct
name|ecore_credit_pool_obj
modifier|*
name|o
parameter_list|)
block|{
name|int
name|cur_credit
decl_stmt|;
name|ECORE_SMP_MB
argument_list|()
expr_stmt|;
name|cur_credit
operator|=
name|ECORE_ATOMIC_READ
argument_list|(
operator|&
name|o
operator|->
name|credit
argument_list|)
expr_stmt|;
return|return
name|cur_credit
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ecore_credit_pool_always_TRUE
parameter_list|(
name|struct
name|ecore_credit_pool_obj
modifier|*
name|o
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ecore_credit_pool_get_entry
parameter_list|(
name|struct
name|ecore_credit_pool_obj
modifier|*
name|o
parameter_list|,
name|int
modifier|*
name|offset
parameter_list|)
block|{
name|int
name|idx
decl_stmt|,
name|vec
decl_stmt|,
name|i
decl_stmt|;
operator|*
name|offset
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Find "internal cam-offset" then add to base for this object... */
for|for
control|(
name|vec
operator|=
literal|0
init|;
name|vec
operator|<
name|ECORE_POOL_VEC_SIZE
condition|;
name|vec
operator|++
control|)
block|{
comment|/* Skip the current vector if there are no free entries in it */
if|if
condition|(
operator|!
name|o
operator|->
name|pool_mirror
index|[
name|vec
index|]
condition|)
continue|continue;
comment|/* If we've got here we are going to find a free entry */
for|for
control|(
name|idx
operator|=
name|vec
operator|*
name|BIT_VEC64_ELEM_SZ
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BIT_VEC64_ELEM_SZ
condition|;
name|idx
operator|++
operator|,
name|i
operator|++
control|)
if|if
condition|(
name|BIT_VEC64_TEST_BIT
argument_list|(
name|o
operator|->
name|pool_mirror
argument_list|,
name|idx
argument_list|)
condition|)
block|{
comment|/* Got one!! */
name|BIT_VEC64_CLEAR_BIT
argument_list|(
name|o
operator|->
name|pool_mirror
argument_list|,
name|idx
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|o
operator|->
name|base_pool_offset
operator|+
name|idx
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ecore_credit_pool_put_entry
parameter_list|(
name|struct
name|ecore_credit_pool_obj
modifier|*
name|o
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
if|if
condition|(
name|offset
operator|<
name|o
operator|->
name|base_pool_offset
condition|)
return|return
name|FALSE
return|;
name|offset
operator|-=
name|o
operator|->
name|base_pool_offset
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|o
operator|->
name|pool_sz
condition|)
return|return
name|FALSE
return|;
comment|/* Return the entry to the pool */
name|BIT_VEC64_SET_BIT
argument_list|(
name|o
operator|->
name|pool_mirror
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ecore_credit_pool_put_entry_always_TRUE
parameter_list|(
name|struct
name|ecore_credit_pool_obj
modifier|*
name|o
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ecore_credit_pool_get_entry_always_TRUE
parameter_list|(
name|struct
name|ecore_credit_pool_obj
modifier|*
name|o
parameter_list|,
name|int
modifier|*
name|offset
parameter_list|)
block|{
operator|*
name|offset
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/**  * ecore_init_credit_pool - initialize credit pool internals.  *  * @p:  * @base:	Base entry in the CAM to use.  * @credit:	pool size.  *  * If base is negative no CAM entries handling will be performed.  * If credit is negative pool operations will always succeed (unlimited pool).  *  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ecore_init_credit_pool
parameter_list|(
name|struct
name|ecore_credit_pool_obj
modifier|*
name|p
parameter_list|,
name|int
name|base
parameter_list|,
name|int
name|credit
parameter_list|)
block|{
comment|/* Zero the object first */
name|ECORE_MEMSET
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the table to all 1s */
name|ECORE_MEMSET
argument_list|(
operator|&
name|p
operator|->
name|pool_mirror
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|pool_mirror
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Init a pool as full */
name|ECORE_ATOMIC_SET
argument_list|(
operator|&
name|p
operator|->
name|credit
argument_list|,
name|credit
argument_list|)
expr_stmt|;
comment|/* The total poll size */
name|p
operator|->
name|pool_sz
operator|=
name|credit
expr_stmt|;
name|p
operator|->
name|base_pool_offset
operator|=
name|base
expr_stmt|;
comment|/* Commit the change */
name|ECORE_SMP_MB
argument_list|()
expr_stmt|;
name|p
operator|->
name|check
operator|=
name|ecore_credit_pool_check
expr_stmt|;
comment|/* if pool credit is negative - disable the checks */
if|if
condition|(
name|credit
operator|>=
literal|0
condition|)
block|{
name|p
operator|->
name|put
operator|=
name|ecore_credit_pool_put
expr_stmt|;
name|p
operator|->
name|get
operator|=
name|ecore_credit_pool_get
expr_stmt|;
name|p
operator|->
name|put_entry
operator|=
name|ecore_credit_pool_put_entry
expr_stmt|;
name|p
operator|->
name|get_entry
operator|=
name|ecore_credit_pool_get_entry
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|put
operator|=
name|ecore_credit_pool_always_TRUE
expr_stmt|;
name|p
operator|->
name|get
operator|=
name|ecore_credit_pool_always_TRUE
expr_stmt|;
name|p
operator|->
name|put_entry
operator|=
name|ecore_credit_pool_put_entry_always_TRUE
expr_stmt|;
name|p
operator|->
name|get_entry
operator|=
name|ecore_credit_pool_get_entry_always_TRUE
expr_stmt|;
block|}
comment|/* If base is negative - disable entries handling */
if|if
condition|(
name|base
operator|<
literal|0
condition|)
block|{
name|p
operator|->
name|put_entry
operator|=
name|ecore_credit_pool_put_entry_always_TRUE
expr_stmt|;
name|p
operator|->
name|get_entry
operator|=
name|ecore_credit_pool_get_entry_always_TRUE
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ecore_init_mac_credit_pool
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_credit_pool_obj
modifier|*
name|p
parameter_list|,
name|uint8_t
name|func_id
parameter_list|,
name|uint8_t
name|func_num
parameter_list|)
block|{
comment|/* TODO: this will be defined in consts as well... */
define|#
directive|define
name|ECORE_CAM_SIZE_EMUL
value|5
name|int
name|cam_sz
decl_stmt|;
if|if
condition|(
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* In E1, Multicast is saved in cam... */
if|if
condition|(
operator|!
name|CHIP_REV_IS_SLOW
argument_list|(
name|sc
argument_list|)
condition|)
name|cam_sz
operator|=
operator|(
name|MAX_MAC_CREDIT_E1
operator|/
literal|2
operator|)
operator|-
name|ECORE_MAX_MULTICAST
expr_stmt|;
else|else
name|cam_sz
operator|=
name|ECORE_CAM_SIZE_EMUL
operator|-
name|ECORE_MAX_EMUL_MULTI
expr_stmt|;
name|ecore_init_credit_pool
argument_list|(
name|p
argument_list|,
name|func_id
operator|*
name|cam_sz
argument_list|,
name|cam_sz
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* CAM credit is equally divided between all active functions 		 * on the PORT!. 		 */
if|if
condition|(
operator|(
name|func_num
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|CHIP_REV_IS_SLOW
argument_list|(
name|sc
argument_list|)
condition|)
name|cam_sz
operator|=
operator|(
name|MAX_MAC_CREDIT_E1H
operator|/
operator|(
literal|2
operator|*
name|func_num
operator|)
operator|)
expr_stmt|;
else|else
name|cam_sz
operator|=
name|ECORE_CAM_SIZE_EMUL
expr_stmt|;
name|ecore_init_credit_pool
argument_list|(
name|p
argument_list|,
name|func_id
operator|*
name|cam_sz
argument_list|,
name|cam_sz
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* this should never happen! Block MAC operations. */
name|ecore_init_credit_pool
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * CAM credit is equaly divided between all active functions 		 * on the PATH. 		 */
if|if
condition|(
operator|(
name|func_num
operator|>
literal|1
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|CHIP_REV_IS_SLOW
argument_list|(
name|sc
argument_list|)
condition|)
name|cam_sz
operator|=
operator|(
name|MAX_MAC_CREDIT_E2
operator|-
name|GET_NUM_VFS_PER_PATH
argument_list|(
name|sc
argument_list|)
operator|)
operator|/
name|func_num
operator|+
name|GET_NUM_VFS_PER_PF
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|cam_sz
operator|=
name|ECORE_CAM_SIZE_EMUL
expr_stmt|;
comment|/* No need for CAM entries handling for 57712 and 			 * newer. 			 */
name|ecore_init_credit_pool
argument_list|(
name|p
argument_list|,
operator|-
literal|1
argument_list|,
name|cam_sz
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|func_num
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|CHIP_REV_IS_SLOW
argument_list|(
name|sc
argument_list|)
condition|)
name|cam_sz
operator|=
name|MAX_MAC_CREDIT_E2
expr_stmt|;
else|else
name|cam_sz
operator|=
name|ECORE_CAM_SIZE_EMUL
expr_stmt|;
comment|/* No need for CAM entries handling for 57712 and 			 * newer. 			 */
name|ecore_init_credit_pool
argument_list|(
name|p
argument_list|,
operator|-
literal|1
argument_list|,
name|cam_sz
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* this should never happen! Block MAC operations. */
name|ecore_init_credit_pool
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|ecore_init_vlan_credit_pool
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_credit_pool_obj
modifier|*
name|p
parameter_list|,
name|uint8_t
name|func_id
parameter_list|,
name|uint8_t
name|func_num
parameter_list|)
block|{
if|if
condition|(
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* There is no VLAN credit in HW on 57710 and 57711 only 		 * MAC / MAC-VLAN can be set 		 */
name|ecore_init_credit_pool
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* CAM credit is equally divided between all active functions 		 * on the PATH. 		 */
if|if
condition|(
name|func_num
operator|>
literal|0
condition|)
block|{
name|int
name|credit
init|=
name|MAX_VLAN_CREDIT_E2
operator|/
name|func_num
decl_stmt|;
name|ecore_init_credit_pool
argument_list|(
name|p
argument_list|,
name|func_id
operator|*
name|credit
argument_list|,
name|credit
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* this should never happen! Block VLAN operations. */
name|ecore_init_credit_pool
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/****************** RSS Configuration ******************/
end_comment

begin_comment
comment|/**  * ecore_setup_rss - configure RSS  *  * @sc:		device handle  * @p:		rss configuration  *  * sends on UPDATE ramrod for that matter.  */
end_comment

begin_function
specifier|static
name|int
name|ecore_setup_rss
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_config_rss_params
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ecore_rss_config_obj
modifier|*
name|o
init|=
name|p
operator|->
name|rss_obj
decl_stmt|;
name|struct
name|ecore_raw_obj
modifier|*
name|r
init|=
operator|&
name|o
operator|->
name|raw
decl_stmt|;
name|struct
name|eth_rss_update_ramrod_data
modifier|*
name|data
init|=
operator|(
expr|struct
name|eth_rss_update_ramrod_data
operator|*
operator|)
operator|(
name|r
operator|->
name|rdata
operator|)
decl_stmt|;
name|uint8_t
name|rss_mode
init|=
literal|0
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|ECORE_MEMSET
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"Configuring RSS\n"
argument_list|)
expr_stmt|;
comment|/* Set an echo field */
name|data
operator|->
name|echo
operator|=
name|ECORE_CPU_TO_LE32
argument_list|(
operator|(
name|r
operator|->
name|cid
operator|&
name|ECORE_SWCID_MASK
operator|)
operator||
operator|(
name|r
operator|->
name|state
operator|<<
name|ECORE_SWCID_SHIFT
operator|)
argument_list|)
expr_stmt|;
comment|/* RSS mode */
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_RSS_MODE_DISABLED
argument_list|,
operator|&
name|p
operator|->
name|rss_flags
argument_list|)
condition|)
name|rss_mode
operator|=
name|ETH_RSS_MODE_DISABLED
expr_stmt|;
elseif|else
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_RSS_MODE_REGULAR
argument_list|,
operator|&
name|p
operator|->
name|rss_flags
argument_list|)
condition|)
name|rss_mode
operator|=
name|ETH_RSS_MODE_REGULAR
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__VMKLNX__
argument_list|)
operator|&&
operator|(
name|VMWARE_ESX_DDK_VERSION
operator|<
literal|55000
operator|)
comment|/* ! BNX2X_UPSTREAM */
elseif|else
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_RSS_MODE_ESX51
argument_list|,
operator|&
name|p
operator|->
name|rss_flags
argument_list|)
condition|)
name|rss_mode
operator|=
name|ETH_RSS_MODE_ESX51
expr_stmt|;
endif|#
directive|endif
name|data
operator|->
name|rss_mode
operator|=
name|rss_mode
expr_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"rss_mode=%d\n"
argument_list|,
name|rss_mode
argument_list|)
expr_stmt|;
comment|/* RSS capabilities */
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_RSS_IPV4
argument_list|,
operator|&
name|p
operator|->
name|rss_flags
argument_list|)
condition|)
name|data
operator|->
name|capabilities
operator||=
name|ETH_RSS_UPDATE_RAMROD_DATA_IPV4_CAPABILITY
expr_stmt|;
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_RSS_IPV4_TCP
argument_list|,
operator|&
name|p
operator|->
name|rss_flags
argument_list|)
condition|)
name|data
operator|->
name|capabilities
operator||=
name|ETH_RSS_UPDATE_RAMROD_DATA_IPV4_TCP_CAPABILITY
expr_stmt|;
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_RSS_IPV4_UDP
argument_list|,
operator|&
name|p
operator|->
name|rss_flags
argument_list|)
condition|)
name|data
operator|->
name|capabilities
operator||=
name|ETH_RSS_UPDATE_RAMROD_DATA_IPV4_UDP_CAPABILITY
expr_stmt|;
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_RSS_IPV6
argument_list|,
operator|&
name|p
operator|->
name|rss_flags
argument_list|)
condition|)
name|data
operator|->
name|capabilities
operator||=
name|ETH_RSS_UPDATE_RAMROD_DATA_IPV6_CAPABILITY
expr_stmt|;
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_RSS_IPV6_TCP
argument_list|,
operator|&
name|p
operator|->
name|rss_flags
argument_list|)
condition|)
name|data
operator|->
name|capabilities
operator||=
name|ETH_RSS_UPDATE_RAMROD_DATA_IPV6_TCP_CAPABILITY
expr_stmt|;
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_RSS_IPV6_UDP
argument_list|,
operator|&
name|p
operator|->
name|rss_flags
argument_list|)
condition|)
name|data
operator|->
name|capabilities
operator||=
name|ETH_RSS_UPDATE_RAMROD_DATA_IPV6_UDP_CAPABILITY
expr_stmt|;
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_RSS_TUNNELING
argument_list|,
operator|&
name|p
operator|->
name|rss_flags
argument_list|)
condition|)
block|{
name|data
operator|->
name|udp_4tuple_dst_port_mask
operator|=
name|ECORE_CPU_TO_LE16
argument_list|(
name|p
operator|->
name|tunnel_mask
argument_list|)
expr_stmt|;
name|data
operator|->
name|udp_4tuple_dst_port_value
operator|=
name|ECORE_CPU_TO_LE16
argument_list|(
name|p
operator|->
name|tunnel_value
argument_list|)
expr_stmt|;
block|}
comment|/* Hashing mask */
name|data
operator|->
name|rss_result_mask
operator|=
name|p
operator|->
name|rss_result_mask
expr_stmt|;
comment|/* RSS engine ID */
name|data
operator|->
name|rss_engine_id
operator|=
name|o
operator|->
name|engine_id
expr_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"rss_engine_id=%d\n"
argument_list|,
name|data
operator|->
name|rss_engine_id
argument_list|)
expr_stmt|;
comment|/* Indirection table */
name|ECORE_MEMCPY
argument_list|(
name|data
operator|->
name|indirection_table
argument_list|,
name|p
operator|->
name|ind_table
argument_list|,
name|T_ETH_INDIRECTION_TABLE_SIZE
argument_list|)
expr_stmt|;
comment|/* Remember the last configuration */
name|ECORE_MEMCPY
argument_list|(
name|o
operator|->
name|ind_table
argument_list|,
name|p
operator|->
name|ind_table
argument_list|,
name|T_ETH_INDIRECTION_TABLE_SIZE
argument_list|)
expr_stmt|;
comment|/* RSS keys */
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_RSS_SET_SRCH
argument_list|,
operator|&
name|p
operator|->
name|rss_flags
argument_list|)
condition|)
block|{
name|ECORE_MEMCPY
argument_list|(
operator|&
name|data
operator|->
name|rss_key
index|[
literal|0
index|]
argument_list|,
operator|&
name|p
operator|->
name|rss_key
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|data
operator|->
name|rss_key
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|->
name|capabilities
operator||=
name|ETH_RSS_UPDATE_RAMROD_DATA_UPDATE_RSS_KEY
expr_stmt|;
block|}
comment|/* No need for an explicit memory barrier here as long we would 	 * need to ensure the ordering of writing to the SPQ element 	 * and updating of the SPQ producer which involves a memory 	 * read and we will have to put a full memory barrier there 	 * (inside ecore_sp_post()). 	 */
comment|/* Send a ramrod */
name|rc
operator|=
name|ecore_sp_post
argument_list|(
name|sc
argument_list|,
name|RAMROD_CMD_ID_ETH_RSS_UPDATE
argument_list|,
name|r
operator|->
name|cid
argument_list|,
name|r
operator|->
name|rdata_mapping
argument_list|,
name|ETH_CONNECTION_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
return|return
name|rc
return|;
return|return
name|ECORE_PENDING
return|;
block|}
end_function

begin_function
name|void
name|ecore_get_rss_ind_table
parameter_list|(
name|struct
name|ecore_rss_config_obj
modifier|*
name|rss_obj
parameter_list|,
name|uint8_t
modifier|*
name|ind_table
parameter_list|)
block|{
name|ECORE_MEMCPY
argument_list|(
name|ind_table
argument_list|,
name|rss_obj
operator|->
name|ind_table
argument_list|,
sizeof|sizeof
argument_list|(
name|rss_obj
operator|->
name|ind_table
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ecore_config_rss
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_config_rss_params
modifier|*
name|p
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|struct
name|ecore_rss_config_obj
modifier|*
name|o
init|=
name|p
operator|->
name|rss_obj
decl_stmt|;
name|struct
name|ecore_raw_obj
modifier|*
name|r
init|=
operator|&
name|o
operator|->
name|raw
decl_stmt|;
comment|/* Do nothing if only driver cleanup was requested */
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|RAMROD_DRV_CLR_ONLY
argument_list|,
operator|&
name|p
operator|->
name|ramrod_flags
argument_list|)
condition|)
block|{
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"Not configuring RSS ramrod_flags=%lx\n"
argument_list|,
name|p
operator|->
name|ramrod_flags
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
name|r
operator|->
name|set_pending
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|rc
operator|=
name|o
operator|->
name|config_rss
argument_list|(
name|sc
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|r
operator|->
name|clear_pending
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|RAMROD_COMP_WAIT
argument_list|,
operator|&
name|p
operator|->
name|ramrod_flags
argument_list|)
condition|)
name|rc
operator|=
name|r
operator|->
name|wait_comp
argument_list|(
name|sc
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|void
name|ecore_init_rss_config_obj
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_rss_config_obj
modifier|*
name|rss_obj
parameter_list|,
name|uint8_t
name|cl_id
parameter_list|,
name|uint32_t
name|cid
parameter_list|,
name|uint8_t
name|func_id
parameter_list|,
name|uint8_t
name|engine_id
parameter_list|,
name|void
modifier|*
name|rdata
parameter_list|,
name|ecore_dma_addr_t
name|rdata_mapping
parameter_list|,
name|int
name|state
parameter_list|,
name|unsigned
name|long
modifier|*
name|pstate
parameter_list|,
name|ecore_obj_type
name|type
parameter_list|)
block|{
name|ecore_init_raw_obj
argument_list|(
operator|&
name|rss_obj
operator|->
name|raw
argument_list|,
name|cl_id
argument_list|,
name|cid
argument_list|,
name|func_id
argument_list|,
name|rdata
argument_list|,
name|rdata_mapping
argument_list|,
name|state
argument_list|,
name|pstate
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|rss_obj
operator|->
name|engine_id
operator|=
name|engine_id
expr_stmt|;
name|rss_obj
operator|->
name|config_rss
operator|=
name|ecore_setup_rss
expr_stmt|;
block|}
end_function

begin_function
name|int
name|validate_vlan_mac
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_vlan_mac_obj
modifier|*
name|vlan_mac
parameter_list|)
block|{
if|if
condition|(
operator|!
name|vlan_mac
operator|->
name|get_n_elements
condition|)
block|{
name|ECORE_ERR
argument_list|(
literal|"vlan mac object was not intialized\n"
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/********************** Queue state object ***********************************/
end_comment

begin_comment
comment|/**  * ecore_queue_state_change - perform Queue state change transition  *  * @sc:		device handle  * @params:	parameters to perform the transition  *  * returns 0 in case of successfully completed transition, negative error  * code in case of failure, positive (EBUSY) value if there is a completion  * to that is still pending (possible only if RAMROD_COMP_WAIT is  * not set in params->ramrod_flags for asynchronous commands).  *  */
end_comment

begin_function
name|int
name|ecore_queue_state_change
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_queue_state_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ecore_queue_sp_obj
modifier|*
name|o
init|=
name|params
operator|->
name|q_obj
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|pending_bit
decl_stmt|;
name|unsigned
name|long
modifier|*
name|pending
init|=
operator|&
name|o
operator|->
name|pending
decl_stmt|;
comment|/* Check that the requested transition is legal */
name|rc
operator|=
name|o
operator|->
name|check_transition
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|ECORE_ERR
argument_list|(
literal|"check transition returned an error. rc %d\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
comment|/* Set "pending" bit */
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"pending bit was=%lx\n"
argument_list|,
name|o
operator|->
name|pending
argument_list|)
expr_stmt|;
name|pending_bit
operator|=
name|o
operator|->
name|set_pending
argument_list|(
name|o
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"pending bit now=%lx\n"
argument_list|,
name|o
operator|->
name|pending
argument_list|)
expr_stmt|;
comment|/* Don't send a command if only driver cleanup was requested */
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|RAMROD_DRV_CLR_ONLY
argument_list|,
operator|&
name|params
operator|->
name|ramrod_flags
argument_list|)
condition|)
name|o
operator|->
name|complete_cmd
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
name|pending_bit
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Send a ramrod */
name|rc
operator|=
name|o
operator|->
name|send_cmd
argument_list|(
name|sc
argument_list|,
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|o
operator|->
name|next_state
operator|=
name|ECORE_Q_STATE_MAX
expr_stmt|;
name|ECORE_CLEAR_BIT
argument_list|(
name|pending_bit
argument_list|,
name|pending
argument_list|)
expr_stmt|;
name|ECORE_SMP_MB_AFTER_CLEAR_BIT
argument_list|()
expr_stmt|;
return|return
name|rc
return|;
block|}
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|RAMROD_COMP_WAIT
argument_list|,
operator|&
name|params
operator|->
name|ramrod_flags
argument_list|)
condition|)
block|{
name|rc
operator|=
name|o
operator|->
name|wait_comp
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
name|pending_bit
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
return|return
name|ECORE_SUCCESS
return|;
block|}
block|}
return|return
name|ECORE_RET_PENDING
argument_list|(
name|pending_bit
argument_list|,
name|pending
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ecore_queue_set_pending
parameter_list|(
name|struct
name|ecore_queue_sp_obj
modifier|*
name|obj
parameter_list|,
name|struct
name|ecore_queue_state_params
modifier|*
name|params
parameter_list|)
block|{
name|enum
name|ecore_queue_cmd
name|cmd
init|=
name|params
operator|->
name|cmd
decl_stmt|,
name|bit
decl_stmt|;
comment|/* ACTIVATE and DEACTIVATE commands are implemented on top of 	 * UPDATE command. 	 */
if|if
condition|(
operator|(
name|cmd
operator|==
name|ECORE_Q_CMD_ACTIVATE
operator|)
operator|||
operator|(
name|cmd
operator|==
name|ECORE_Q_CMD_DEACTIVATE
operator|)
condition|)
name|bit
operator|=
name|ECORE_Q_CMD_UPDATE
expr_stmt|;
else|else
name|bit
operator|=
name|cmd
expr_stmt|;
name|ECORE_SET_BIT
argument_list|(
name|bit
argument_list|,
operator|&
name|obj
operator|->
name|pending
argument_list|)
expr_stmt|;
return|return
name|bit
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ecore_queue_wait_comp
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_queue_sp_obj
modifier|*
name|o
parameter_list|,
name|enum
name|ecore_queue_cmd
name|cmd
parameter_list|)
block|{
return|return
name|ecore_state_wait
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|,
operator|&
name|o
operator|->
name|pending
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ecore_queue_comp_cmd - complete the state change command.  *  * @sc:		device handle  * @o:  * @cmd:  *  * Checks that the arrived completion is expected.  */
end_comment

begin_function
specifier|static
name|int
name|ecore_queue_comp_cmd
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_queue_sp_obj
modifier|*
name|o
parameter_list|,
name|enum
name|ecore_queue_cmd
name|cmd
parameter_list|)
block|{
name|unsigned
name|long
name|cur_pending
init|=
name|o
operator|->
name|pending
decl_stmt|;
if|if
condition|(
operator|!
name|ECORE_TEST_AND_CLEAR_BIT
argument_list|(
name|cmd
argument_list|,
operator|&
name|cur_pending
argument_list|)
condition|)
block|{
name|ECORE_ERR
argument_list|(
literal|"Bad MC reply %d for queue %d in state %d pending 0x%lx, next_state %d\n"
argument_list|,
name|cmd
argument_list|,
name|o
operator|->
name|cids
index|[
name|ECORE_PRIMARY_CID_INDEX
index|]
argument_list|,
name|o
operator|->
name|state
argument_list|,
name|cur_pending
argument_list|,
name|o
operator|->
name|next_state
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
if|if
condition|(
name|o
operator|->
name|next_tx_only
operator|>=
name|o
operator|->
name|max_cos
condition|)
comment|/*>= because tx only must always be smaller than cos since the 		 * primary connection supports COS 0 		 */
name|ECORE_ERR
argument_list|(
literal|"illegal value for next tx_only: %d. max cos was %d"
argument_list|,
name|o
operator|->
name|next_tx_only
argument_list|,
name|o
operator|->
name|max_cos
argument_list|)
expr_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"Completing command %d for queue %d, setting state to %d\n"
argument_list|,
name|cmd
argument_list|,
name|o
operator|->
name|cids
index|[
name|ECORE_PRIMARY_CID_INDEX
index|]
argument_list|,
name|o
operator|->
name|next_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|next_tx_only
condition|)
comment|/* print num tx-only if any exist */
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"primary cid %d: num tx-only cons %d\n"
argument_list|,
name|o
operator|->
name|cids
index|[
name|ECORE_PRIMARY_CID_INDEX
index|]
argument_list|,
name|o
operator|->
name|next_tx_only
argument_list|)
expr_stmt|;
name|o
operator|->
name|state
operator|=
name|o
operator|->
name|next_state
expr_stmt|;
name|o
operator|->
name|num_tx_only
operator|=
name|o
operator|->
name|next_tx_only
expr_stmt|;
name|o
operator|->
name|next_state
operator|=
name|ECORE_Q_STATE_MAX
expr_stmt|;
comment|/* It's important that o->state and o->next_state are 	 * updated before o->pending. 	 */
name|wmb
argument_list|()
expr_stmt|;
name|ECORE_CLEAR_BIT
argument_list|(
name|cmd
argument_list|,
operator|&
name|o
operator|->
name|pending
argument_list|)
expr_stmt|;
name|ECORE_SMP_MB_AFTER_CLEAR_BIT
argument_list|()
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_q_fill_setup_data_e2
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_queue_state_params
modifier|*
name|cmd_params
parameter_list|,
name|struct
name|client_init_ramrod_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ecore_queue_setup_params
modifier|*
name|params
init|=
operator|&
name|cmd_params
operator|->
name|params
operator|.
name|setup
decl_stmt|;
comment|/* Rx data */
comment|/* IPv6 TPA supported for E2 and above only */
name|data
operator|->
name|rx
operator|.
name|tpa_en
operator||=
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_FLG_TPA_IPV6
argument_list|,
operator|&
name|params
operator|->
name|flags
argument_list|)
operator|*
name|CLIENT_INIT_RX_DATA_TPA_EN_IPV6
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_q_fill_init_general_data
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_queue_sp_obj
modifier|*
name|o
parameter_list|,
name|struct
name|ecore_general_setup_params
modifier|*
name|params
parameter_list|,
name|struct
name|client_init_general_data
modifier|*
name|gen_data
parameter_list|,
name|unsigned
name|long
modifier|*
name|flags
parameter_list|)
block|{
name|gen_data
operator|->
name|client_id
operator|=
name|o
operator|->
name|cl_id
expr_stmt|;
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_FLG_STATS
argument_list|,
name|flags
argument_list|)
condition|)
block|{
name|gen_data
operator|->
name|statistics_counter_id
operator|=
name|params
operator|->
name|stat_id
expr_stmt|;
name|gen_data
operator|->
name|statistics_en_flg
operator|=
literal|1
expr_stmt|;
name|gen_data
operator|->
name|statistics_zero_flg
operator|=
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_FLG_ZERO_STATS
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
name|gen_data
operator|->
name|statistics_counter_id
operator|=
name|DISABLE_STATISTIC_COUNTER_ID_VALUE
expr_stmt|;
name|gen_data
operator|->
name|is_fcoe_flg
operator|=
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_FLG_FCOE
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|gen_data
operator|->
name|activate_flg
operator|=
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_FLG_ACTIVE
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|gen_data
operator|->
name|sp_client_id
operator|=
name|params
operator|->
name|spcl_id
expr_stmt|;
name|gen_data
operator|->
name|mtu
operator|=
name|ECORE_CPU_TO_LE16
argument_list|(
name|params
operator|->
name|mtu
argument_list|)
expr_stmt|;
name|gen_data
operator|->
name|func_id
operator|=
name|o
operator|->
name|func_id
expr_stmt|;
name|gen_data
operator|->
name|cos
operator|=
name|params
operator|->
name|cos
expr_stmt|;
name|gen_data
operator|->
name|traffic_type
operator|=
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_FLG_FCOE
argument_list|,
name|flags
argument_list|)
condition|?
name|LLFC_TRAFFIC_TYPE_FCOE
else|:
name|LLFC_TRAFFIC_TYPE_NW
expr_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"flags: active %d, cos %d, stats en %d\n"
argument_list|,
name|gen_data
operator|->
name|activate_flg
argument_list|,
name|gen_data
operator|->
name|cos
argument_list|,
name|gen_data
operator|->
name|statistics_en_flg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_q_fill_init_tx_data
parameter_list|(
name|struct
name|ecore_queue_sp_obj
modifier|*
name|o
parameter_list|,
name|struct
name|ecore_txq_setup_params
modifier|*
name|params
parameter_list|,
name|struct
name|client_init_tx_data
modifier|*
name|tx_data
parameter_list|,
name|unsigned
name|long
modifier|*
name|flags
parameter_list|)
block|{
name|tx_data
operator|->
name|enforce_security_flg
operator|=
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_FLG_TX_SEC
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|tx_data
operator|->
name|default_vlan
operator|=
name|ECORE_CPU_TO_LE16
argument_list|(
name|params
operator|->
name|default_vlan
argument_list|)
expr_stmt|;
name|tx_data
operator|->
name|default_vlan_flg
operator|=
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_FLG_DEF_VLAN
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|tx_data
operator|->
name|tx_switching_flg
operator|=
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_FLG_TX_SWITCH
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|tx_data
operator|->
name|anti_spoofing_flg
operator|=
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_FLG_ANTI_SPOOF
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|tx_data
operator|->
name|force_default_pri_flg
operator|=
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_FLG_FORCE_DEFAULT_PRI
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|tx_data
operator|->
name|refuse_outband_vlan_flg
operator|=
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_FLG_REFUSE_OUTBAND_VLAN
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|tx_data
operator|->
name|tunnel_lso_inc_ip_id
operator|=
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_FLG_TUN_INC_INNER_IP_ID
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|tx_data
operator|->
name|tunnel_non_lso_pcsum_location
operator|=
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_FLG_PCSUM_ON_PKT
argument_list|,
name|flags
argument_list|)
condition|?
name|CSUM_ON_PKT
else|:
name|CSUM_ON_BD
expr_stmt|;
name|tx_data
operator|->
name|tx_status_block_id
operator|=
name|params
operator|->
name|fw_sb_id
expr_stmt|;
name|tx_data
operator|->
name|tx_sb_index_number
operator|=
name|params
operator|->
name|sb_cq_index
expr_stmt|;
name|tx_data
operator|->
name|tss_leading_client_id
operator|=
name|params
operator|->
name|tss_leading_cl_id
expr_stmt|;
name|tx_data
operator|->
name|tx_bd_page_base
operator|.
name|lo
operator|=
name|ECORE_CPU_TO_LE32
argument_list|(
name|U64_LO
argument_list|(
name|params
operator|->
name|dscr_map
argument_list|)
argument_list|)
expr_stmt|;
name|tx_data
operator|->
name|tx_bd_page_base
operator|.
name|hi
operator|=
name|ECORE_CPU_TO_LE32
argument_list|(
name|U64_HI
argument_list|(
name|params
operator|->
name|dscr_map
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't configure any Tx switching mode during queue SETUP */
name|tx_data
operator|->
name|state
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_q_fill_init_pause_data
parameter_list|(
name|struct
name|ecore_queue_sp_obj
modifier|*
name|o
parameter_list|,
name|struct
name|rxq_pause_params
modifier|*
name|params
parameter_list|,
name|struct
name|client_init_rx_data
modifier|*
name|rx_data
parameter_list|)
block|{
comment|/* flow control data */
name|rx_data
operator|->
name|cqe_pause_thr_low
operator|=
name|ECORE_CPU_TO_LE16
argument_list|(
name|params
operator|->
name|rcq_th_lo
argument_list|)
expr_stmt|;
name|rx_data
operator|->
name|cqe_pause_thr_high
operator|=
name|ECORE_CPU_TO_LE16
argument_list|(
name|params
operator|->
name|rcq_th_hi
argument_list|)
expr_stmt|;
name|rx_data
operator|->
name|bd_pause_thr_low
operator|=
name|ECORE_CPU_TO_LE16
argument_list|(
name|params
operator|->
name|bd_th_lo
argument_list|)
expr_stmt|;
name|rx_data
operator|->
name|bd_pause_thr_high
operator|=
name|ECORE_CPU_TO_LE16
argument_list|(
name|params
operator|->
name|bd_th_hi
argument_list|)
expr_stmt|;
name|rx_data
operator|->
name|sge_pause_thr_low
operator|=
name|ECORE_CPU_TO_LE16
argument_list|(
name|params
operator|->
name|sge_th_lo
argument_list|)
expr_stmt|;
name|rx_data
operator|->
name|sge_pause_thr_high
operator|=
name|ECORE_CPU_TO_LE16
argument_list|(
name|params
operator|->
name|sge_th_hi
argument_list|)
expr_stmt|;
name|rx_data
operator|->
name|rx_cos_mask
operator|=
name|ECORE_CPU_TO_LE16
argument_list|(
name|params
operator|->
name|pri_map
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_q_fill_init_rx_data
parameter_list|(
name|struct
name|ecore_queue_sp_obj
modifier|*
name|o
parameter_list|,
name|struct
name|ecore_rxq_setup_params
modifier|*
name|params
parameter_list|,
name|struct
name|client_init_rx_data
modifier|*
name|rx_data
parameter_list|,
name|unsigned
name|long
modifier|*
name|flags
parameter_list|)
block|{
name|rx_data
operator|->
name|tpa_en
operator|=
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_FLG_TPA
argument_list|,
name|flags
argument_list|)
operator|*
name|CLIENT_INIT_RX_DATA_TPA_EN_IPV4
expr_stmt|;
name|rx_data
operator|->
name|tpa_en
operator||=
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_FLG_TPA_GRO
argument_list|,
name|flags
argument_list|)
operator|*
name|CLIENT_INIT_RX_DATA_TPA_MODE
expr_stmt|;
name|rx_data
operator|->
name|vmqueue_mode_en_flg
operator|=
literal|0
expr_stmt|;
name|rx_data
operator|->
name|extra_data_over_sgl_en_flg
operator|=
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_FLG_OOO
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|rx_data
operator|->
name|cache_line_alignment_log_size
operator|=
name|params
operator|->
name|cache_line_log
expr_stmt|;
name|rx_data
operator|->
name|enable_dynamic_hc
operator|=
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_FLG_DHC
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|rx_data
operator|->
name|max_sges_for_packet
operator|=
name|params
operator|->
name|max_sges_pkt
expr_stmt|;
name|rx_data
operator|->
name|client_qzone_id
operator|=
name|params
operator|->
name|cl_qzone_id
expr_stmt|;
name|rx_data
operator|->
name|max_agg_size
operator|=
name|ECORE_CPU_TO_LE16
argument_list|(
name|params
operator|->
name|tpa_agg_sz
argument_list|)
expr_stmt|;
comment|/* Always start in DROP_ALL mode */
name|rx_data
operator|->
name|state
operator|=
name|ECORE_CPU_TO_LE16
argument_list|(
name|CLIENT_INIT_RX_DATA_UCAST_DROP_ALL
operator||
name|CLIENT_INIT_RX_DATA_MCAST_DROP_ALL
argument_list|)
expr_stmt|;
comment|/* We don't set drop flags */
name|rx_data
operator|->
name|drop_ip_cs_err_flg
operator|=
literal|0
expr_stmt|;
name|rx_data
operator|->
name|drop_tcp_cs_err_flg
operator|=
literal|0
expr_stmt|;
name|rx_data
operator|->
name|drop_ttl0_flg
operator|=
literal|0
expr_stmt|;
name|rx_data
operator|->
name|drop_udp_cs_err_flg
operator|=
literal|0
expr_stmt|;
name|rx_data
operator|->
name|inner_vlan_removal_enable_flg
operator|=
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_FLG_VLAN
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|rx_data
operator|->
name|outer_vlan_removal_enable_flg
operator|=
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_FLG_OV
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|rx_data
operator|->
name|status_block_id
operator|=
name|params
operator|->
name|fw_sb_id
expr_stmt|;
name|rx_data
operator|->
name|rx_sb_index_number
operator|=
name|params
operator|->
name|sb_cq_index
expr_stmt|;
name|rx_data
operator|->
name|max_tpa_queues
operator|=
name|params
operator|->
name|max_tpa_queues
expr_stmt|;
name|rx_data
operator|->
name|max_bytes_on_bd
operator|=
name|ECORE_CPU_TO_LE16
argument_list|(
name|params
operator|->
name|buf_sz
argument_list|)
expr_stmt|;
name|rx_data
operator|->
name|sge_buff_size
operator|=
name|ECORE_CPU_TO_LE16
argument_list|(
name|params
operator|->
name|sge_buf_sz
argument_list|)
expr_stmt|;
name|rx_data
operator|->
name|bd_page_base
operator|.
name|lo
operator|=
name|ECORE_CPU_TO_LE32
argument_list|(
name|U64_LO
argument_list|(
name|params
operator|->
name|dscr_map
argument_list|)
argument_list|)
expr_stmt|;
name|rx_data
operator|->
name|bd_page_base
operator|.
name|hi
operator|=
name|ECORE_CPU_TO_LE32
argument_list|(
name|U64_HI
argument_list|(
name|params
operator|->
name|dscr_map
argument_list|)
argument_list|)
expr_stmt|;
name|rx_data
operator|->
name|sge_page_base
operator|.
name|lo
operator|=
name|ECORE_CPU_TO_LE32
argument_list|(
name|U64_LO
argument_list|(
name|params
operator|->
name|sge_map
argument_list|)
argument_list|)
expr_stmt|;
name|rx_data
operator|->
name|sge_page_base
operator|.
name|hi
operator|=
name|ECORE_CPU_TO_LE32
argument_list|(
name|U64_HI
argument_list|(
name|params
operator|->
name|sge_map
argument_list|)
argument_list|)
expr_stmt|;
name|rx_data
operator|->
name|cqe_page_base
operator|.
name|lo
operator|=
name|ECORE_CPU_TO_LE32
argument_list|(
name|U64_LO
argument_list|(
name|params
operator|->
name|rcq_map
argument_list|)
argument_list|)
expr_stmt|;
name|rx_data
operator|->
name|cqe_page_base
operator|.
name|hi
operator|=
name|ECORE_CPU_TO_LE32
argument_list|(
name|U64_HI
argument_list|(
name|params
operator|->
name|rcq_map
argument_list|)
argument_list|)
expr_stmt|;
name|rx_data
operator|->
name|is_leading_rss
operator|=
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_FLG_LEADING_RSS
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_FLG_MCAST
argument_list|,
name|flags
argument_list|)
condition|)
block|{
name|rx_data
operator|->
name|approx_mcast_engine_id
operator|=
name|params
operator|->
name|mcast_engine_id
expr_stmt|;
name|rx_data
operator|->
name|is_approx_mcast
operator|=
literal|1
expr_stmt|;
block|}
name|rx_data
operator|->
name|rss_engine_id
operator|=
name|params
operator|->
name|rss_engine_id
expr_stmt|;
comment|/* silent vlan removal */
name|rx_data
operator|->
name|silent_vlan_removal_flg
operator|=
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_FLG_SILENT_VLAN_REM
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|rx_data
operator|->
name|silent_vlan_value
operator|=
name|ECORE_CPU_TO_LE16
argument_list|(
name|params
operator|->
name|silent_removal_value
argument_list|)
expr_stmt|;
name|rx_data
operator|->
name|silent_vlan_mask
operator|=
name|ECORE_CPU_TO_LE16
argument_list|(
name|params
operator|->
name|silent_removal_mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* initialize the general, tx and rx parts of a queue object */
end_comment

begin_function
specifier|static
name|void
name|ecore_q_fill_setup_data_cmn
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_queue_state_params
modifier|*
name|cmd_params
parameter_list|,
name|struct
name|client_init_ramrod_data
modifier|*
name|data
parameter_list|)
block|{
name|ecore_q_fill_init_general_data
argument_list|(
name|sc
argument_list|,
name|cmd_params
operator|->
name|q_obj
argument_list|,
operator|&
name|cmd_params
operator|->
name|params
operator|.
name|setup
operator|.
name|gen_params
argument_list|,
operator|&
name|data
operator|->
name|general
argument_list|,
operator|&
name|cmd_params
operator|->
name|params
operator|.
name|setup
operator|.
name|flags
argument_list|)
expr_stmt|;
name|ecore_q_fill_init_tx_data
argument_list|(
name|cmd_params
operator|->
name|q_obj
argument_list|,
operator|&
name|cmd_params
operator|->
name|params
operator|.
name|setup
operator|.
name|txq_params
argument_list|,
operator|&
name|data
operator|->
name|tx
argument_list|,
operator|&
name|cmd_params
operator|->
name|params
operator|.
name|setup
operator|.
name|flags
argument_list|)
expr_stmt|;
name|ecore_q_fill_init_rx_data
argument_list|(
name|cmd_params
operator|->
name|q_obj
argument_list|,
operator|&
name|cmd_params
operator|->
name|params
operator|.
name|setup
operator|.
name|rxq_params
argument_list|,
operator|&
name|data
operator|->
name|rx
argument_list|,
operator|&
name|cmd_params
operator|->
name|params
operator|.
name|setup
operator|.
name|flags
argument_list|)
expr_stmt|;
name|ecore_q_fill_init_pause_data
argument_list|(
name|cmd_params
operator|->
name|q_obj
argument_list|,
operator|&
name|cmd_params
operator|->
name|params
operator|.
name|setup
operator|.
name|pause_params
argument_list|,
operator|&
name|data
operator|->
name|rx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* initialize the general and tx parts of a tx-only queue object */
end_comment

begin_function
specifier|static
name|void
name|ecore_q_fill_setup_tx_only
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_queue_state_params
modifier|*
name|cmd_params
parameter_list|,
name|struct
name|tx_queue_init_ramrod_data
modifier|*
name|data
parameter_list|)
block|{
name|ecore_q_fill_init_general_data
argument_list|(
name|sc
argument_list|,
name|cmd_params
operator|->
name|q_obj
argument_list|,
operator|&
name|cmd_params
operator|->
name|params
operator|.
name|tx_only
operator|.
name|gen_params
argument_list|,
operator|&
name|data
operator|->
name|general
argument_list|,
operator|&
name|cmd_params
operator|->
name|params
operator|.
name|tx_only
operator|.
name|flags
argument_list|)
expr_stmt|;
name|ecore_q_fill_init_tx_data
argument_list|(
name|cmd_params
operator|->
name|q_obj
argument_list|,
operator|&
name|cmd_params
operator|->
name|params
operator|.
name|tx_only
operator|.
name|txq_params
argument_list|,
operator|&
name|data
operator|->
name|tx
argument_list|,
operator|&
name|cmd_params
operator|->
name|params
operator|.
name|tx_only
operator|.
name|flags
argument_list|)
expr_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"cid %d, tx bd page lo %x hi %x"
argument_list|,
name|cmd_params
operator|->
name|q_obj
operator|->
name|cids
index|[
literal|0
index|]
argument_list|,
name|data
operator|->
name|tx
operator|.
name|tx_bd_page_base
operator|.
name|lo
argument_list|,
name|data
operator|->
name|tx
operator|.
name|tx_bd_page_base
operator|.
name|hi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ecore_q_init - init HW/FW queue  *  * @sc:		device handle  * @params:  *  * HW/FW initial Queue configuration:  *      - HC: Rx and Tx  *      - CDU context validation  *  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ecore_q_init
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_queue_state_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ecore_queue_sp_obj
modifier|*
name|o
init|=
name|params
operator|->
name|q_obj
decl_stmt|;
name|struct
name|ecore_queue_init_params
modifier|*
name|init
init|=
operator|&
name|params
operator|->
name|params
operator|.
name|init
decl_stmt|;
name|uint16_t
name|hc_usec
decl_stmt|;
name|uint8_t
name|cos
decl_stmt|;
comment|/* Tx HC configuration */
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_TYPE_HAS_TX
argument_list|,
operator|&
name|o
operator|->
name|type
argument_list|)
operator|&&
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_FLG_HC
argument_list|,
operator|&
name|init
operator|->
name|tx
operator|.
name|flags
argument_list|)
condition|)
block|{
name|hc_usec
operator|=
name|init
operator|->
name|tx
operator|.
name|hc_rate
condition|?
literal|1000000
operator|/
name|init
operator|->
name|tx
operator|.
name|hc_rate
else|:
literal|0
expr_stmt|;
name|ECORE_UPDATE_COALESCE_SB_INDEX
argument_list|(
name|sc
argument_list|,
name|init
operator|->
name|tx
operator|.
name|fw_sb_id
argument_list|,
name|init
operator|->
name|tx
operator|.
name|sb_cq_index
argument_list|,
operator|!
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_FLG_HC_EN
argument_list|,
operator|&
name|init
operator|->
name|tx
operator|.
name|flags
argument_list|)
argument_list|,
name|hc_usec
argument_list|)
expr_stmt|;
block|}
comment|/* Rx HC configuration */
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_TYPE_HAS_RX
argument_list|,
operator|&
name|o
operator|->
name|type
argument_list|)
operator|&&
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_FLG_HC
argument_list|,
operator|&
name|init
operator|->
name|rx
operator|.
name|flags
argument_list|)
condition|)
block|{
name|hc_usec
operator|=
name|init
operator|->
name|rx
operator|.
name|hc_rate
condition|?
literal|1000000
operator|/
name|init
operator|->
name|rx
operator|.
name|hc_rate
else|:
literal|0
expr_stmt|;
name|ECORE_UPDATE_COALESCE_SB_INDEX
argument_list|(
name|sc
argument_list|,
name|init
operator|->
name|rx
operator|.
name|fw_sb_id
argument_list|,
name|init
operator|->
name|rx
operator|.
name|sb_cq_index
argument_list|,
operator|!
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_FLG_HC_EN
argument_list|,
operator|&
name|init
operator|->
name|rx
operator|.
name|flags
argument_list|)
argument_list|,
name|hc_usec
argument_list|)
expr_stmt|;
block|}
comment|/* Set CDU context validation values */
for|for
control|(
name|cos
operator|=
literal|0
init|;
name|cos
operator|<
name|o
operator|->
name|max_cos
condition|;
name|cos
operator|++
control|)
block|{
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"setting context validation. cid %d, cos %d\n"
argument_list|,
name|o
operator|->
name|cids
index|[
name|cos
index|]
argument_list|,
name|cos
argument_list|)
expr_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"context pointer %p\n"
argument_list|,
name|init
operator|->
name|cxts
index|[
name|cos
index|]
argument_list|)
expr_stmt|;
name|ECORE_SET_CTX_VALIDATION
argument_list|(
name|sc
argument_list|,
name|init
operator|->
name|cxts
index|[
name|cos
index|]
argument_list|,
name|o
operator|->
name|cids
index|[
name|cos
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* As no ramrod is sent, complete the command immediately  */
name|o
operator|->
name|complete_cmd
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
name|ECORE_Q_CMD_INIT
argument_list|)
expr_stmt|;
name|ECORE_MMIOWB
argument_list|()
expr_stmt|;
name|ECORE_SMP_MB
argument_list|()
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|ecore_q_send_setup_e1x
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_queue_state_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ecore_queue_sp_obj
modifier|*
name|o
init|=
name|params
operator|->
name|q_obj
decl_stmt|;
name|struct
name|client_init_ramrod_data
modifier|*
name|rdata
init|=
operator|(
expr|struct
name|client_init_ramrod_data
operator|*
operator|)
name|o
operator|->
name|rdata
decl_stmt|;
name|ecore_dma_addr_t
name|data_mapping
init|=
name|o
operator|->
name|rdata_mapping
decl_stmt|;
name|int
name|ramrod
init|=
name|RAMROD_CMD_ID_ETH_CLIENT_SETUP
decl_stmt|;
comment|/* Clear the ramrod data */
name|ECORE_MEMSET
argument_list|(
name|rdata
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rdata
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fill the ramrod data */
name|ecore_q_fill_setup_data_cmn
argument_list|(
name|sc
argument_list|,
name|params
argument_list|,
name|rdata
argument_list|)
expr_stmt|;
comment|/* No need for an explicit memory barrier here as long we would 	 * need to ensure the ordering of writing to the SPQ element 	 * and updating of the SPQ producer which involves a memory 	 * read and we will have to put a full memory barrier there 	 * (inside ecore_sp_post()). 	 */
return|return
name|ecore_sp_post
argument_list|(
name|sc
argument_list|,
name|ramrod
argument_list|,
name|o
operator|->
name|cids
index|[
name|ECORE_PRIMARY_CID_INDEX
index|]
argument_list|,
name|data_mapping
argument_list|,
name|ETH_CONNECTION_TYPE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|ecore_q_send_setup_e2
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_queue_state_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ecore_queue_sp_obj
modifier|*
name|o
init|=
name|params
operator|->
name|q_obj
decl_stmt|;
name|struct
name|client_init_ramrod_data
modifier|*
name|rdata
init|=
operator|(
expr|struct
name|client_init_ramrod_data
operator|*
operator|)
name|o
operator|->
name|rdata
decl_stmt|;
name|ecore_dma_addr_t
name|data_mapping
init|=
name|o
operator|->
name|rdata_mapping
decl_stmt|;
name|int
name|ramrod
init|=
name|RAMROD_CMD_ID_ETH_CLIENT_SETUP
decl_stmt|;
comment|/* Clear the ramrod data */
name|ECORE_MEMSET
argument_list|(
name|rdata
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rdata
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fill the ramrod data */
name|ecore_q_fill_setup_data_cmn
argument_list|(
name|sc
argument_list|,
name|params
argument_list|,
name|rdata
argument_list|)
expr_stmt|;
name|ecore_q_fill_setup_data_e2
argument_list|(
name|sc
argument_list|,
name|params
argument_list|,
name|rdata
argument_list|)
expr_stmt|;
comment|/* No need for an explicit memory barrier here as long we would 	 * need to ensure the ordering of writing to the SPQ element 	 * and updating of the SPQ producer which involves a memory 	 * read and we will have to put a full memory barrier there 	 * (inside ecore_sp_post()). 	 */
return|return
name|ecore_sp_post
argument_list|(
name|sc
argument_list|,
name|ramrod
argument_list|,
name|o
operator|->
name|cids
index|[
name|ECORE_PRIMARY_CID_INDEX
index|]
argument_list|,
name|data_mapping
argument_list|,
name|ETH_CONNECTION_TYPE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|ecore_q_send_setup_tx_only
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_queue_state_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ecore_queue_sp_obj
modifier|*
name|o
init|=
name|params
operator|->
name|q_obj
decl_stmt|;
name|struct
name|tx_queue_init_ramrod_data
modifier|*
name|rdata
init|=
operator|(
expr|struct
name|tx_queue_init_ramrod_data
operator|*
operator|)
name|o
operator|->
name|rdata
decl_stmt|;
name|ecore_dma_addr_t
name|data_mapping
init|=
name|o
operator|->
name|rdata_mapping
decl_stmt|;
name|int
name|ramrod
init|=
name|RAMROD_CMD_ID_ETH_TX_QUEUE_SETUP
decl_stmt|;
name|struct
name|ecore_queue_setup_tx_only_params
modifier|*
name|tx_only_params
init|=
operator|&
name|params
operator|->
name|params
operator|.
name|tx_only
decl_stmt|;
name|uint8_t
name|cid_index
init|=
name|tx_only_params
operator|->
name|cid_index
decl_stmt|;
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_TYPE_FWD
argument_list|,
operator|&
name|o
operator|->
name|type
argument_list|)
condition|)
name|ramrod
operator|=
name|RAMROD_CMD_ID_ETH_FORWARD_SETUP
expr_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"sending forward tx-only ramrod"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cid_index
operator|>=
name|o
operator|->
name|max_cos
condition|)
block|{
name|ECORE_ERR
argument_list|(
literal|"queue[%d]: cid_index (%d) is out of range\n"
argument_list|,
name|o
operator|->
name|cl_id
argument_list|,
name|cid_index
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"parameters received: cos: %d sp-id: %d\n"
argument_list|,
name|tx_only_params
operator|->
name|gen_params
operator|.
name|cos
argument_list|,
name|tx_only_params
operator|->
name|gen_params
operator|.
name|spcl_id
argument_list|)
expr_stmt|;
comment|/* Clear the ramrod data */
name|ECORE_MEMSET
argument_list|(
name|rdata
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rdata
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fill the ramrod data */
name|ecore_q_fill_setup_tx_only
argument_list|(
name|sc
argument_list|,
name|params
argument_list|,
name|rdata
argument_list|)
expr_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"sending tx-only ramrod: cid %d, client-id %d, sp-client id %d, cos %d\n"
argument_list|,
name|o
operator|->
name|cids
index|[
name|cid_index
index|]
argument_list|,
name|rdata
operator|->
name|general
operator|.
name|client_id
argument_list|,
name|rdata
operator|->
name|general
operator|.
name|sp_client_id
argument_list|,
name|rdata
operator|->
name|general
operator|.
name|cos
argument_list|)
expr_stmt|;
comment|/* No need for an explicit memory barrier here as long we would 	 * need to ensure the ordering of writing to the SPQ element 	 * and updating of the SPQ producer which involves a memory 	 * read and we will have to put a full memory barrier there 	 * (inside ecore_sp_post()). 	 */
return|return
name|ecore_sp_post
argument_list|(
name|sc
argument_list|,
name|ramrod
argument_list|,
name|o
operator|->
name|cids
index|[
name|cid_index
index|]
argument_list|,
name|data_mapping
argument_list|,
name|ETH_CONNECTION_TYPE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_q_fill_update_data
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_queue_sp_obj
modifier|*
name|obj
parameter_list|,
name|struct
name|ecore_queue_update_params
modifier|*
name|params
parameter_list|,
name|struct
name|client_update_ramrod_data
modifier|*
name|data
parameter_list|)
block|{
comment|/* Client ID of the client to update */
name|data
operator|->
name|client_id
operator|=
name|obj
operator|->
name|cl_id
expr_stmt|;
comment|/* Function ID of the client to update */
name|data
operator|->
name|func_id
operator|=
name|obj
operator|->
name|func_id
expr_stmt|;
comment|/* Default VLAN value */
name|data
operator|->
name|default_vlan
operator|=
name|ECORE_CPU_TO_LE16
argument_list|(
name|params
operator|->
name|def_vlan
argument_list|)
expr_stmt|;
comment|/* Inner VLAN stripping */
name|data
operator|->
name|inner_vlan_removal_enable_flg
operator|=
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_UPDATE_IN_VLAN_REM
argument_list|,
operator|&
name|params
operator|->
name|update_flags
argument_list|)
expr_stmt|;
name|data
operator|->
name|inner_vlan_removal_change_flg
operator|=
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_UPDATE_IN_VLAN_REM_CHNG
argument_list|,
operator|&
name|params
operator|->
name|update_flags
argument_list|)
expr_stmt|;
comment|/* Outer VLAN stripping */
name|data
operator|->
name|outer_vlan_removal_enable_flg
operator|=
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_UPDATE_OUT_VLAN_REM
argument_list|,
operator|&
name|params
operator|->
name|update_flags
argument_list|)
expr_stmt|;
name|data
operator|->
name|outer_vlan_removal_change_flg
operator|=
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_UPDATE_OUT_VLAN_REM_CHNG
argument_list|,
operator|&
name|params
operator|->
name|update_flags
argument_list|)
expr_stmt|;
comment|/* Drop packets that have source MAC that doesn't belong to this 	 * Queue. 	 */
name|data
operator|->
name|anti_spoofing_enable_flg
operator|=
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_UPDATE_ANTI_SPOOF
argument_list|,
operator|&
name|params
operator|->
name|update_flags
argument_list|)
expr_stmt|;
name|data
operator|->
name|anti_spoofing_change_flg
operator|=
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_UPDATE_ANTI_SPOOF_CHNG
argument_list|,
operator|&
name|params
operator|->
name|update_flags
argument_list|)
expr_stmt|;
comment|/* Activate/Deactivate */
name|data
operator|->
name|activate_flg
operator|=
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_UPDATE_ACTIVATE
argument_list|,
operator|&
name|params
operator|->
name|update_flags
argument_list|)
expr_stmt|;
name|data
operator|->
name|activate_change_flg
operator|=
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_UPDATE_ACTIVATE_CHNG
argument_list|,
operator|&
name|params
operator|->
name|update_flags
argument_list|)
expr_stmt|;
comment|/* Enable default VLAN */
name|data
operator|->
name|default_vlan_enable_flg
operator|=
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_UPDATE_DEF_VLAN_EN
argument_list|,
operator|&
name|params
operator|->
name|update_flags
argument_list|)
expr_stmt|;
name|data
operator|->
name|default_vlan_change_flg
operator|=
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_UPDATE_DEF_VLAN_EN_CHNG
argument_list|,
operator|&
name|params
operator|->
name|update_flags
argument_list|)
expr_stmt|;
comment|/* silent vlan removal */
name|data
operator|->
name|silent_vlan_change_flg
operator|=
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_UPDATE_SILENT_VLAN_REM_CHNG
argument_list|,
operator|&
name|params
operator|->
name|update_flags
argument_list|)
expr_stmt|;
name|data
operator|->
name|silent_vlan_removal_flg
operator|=
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_UPDATE_SILENT_VLAN_REM
argument_list|,
operator|&
name|params
operator|->
name|update_flags
argument_list|)
expr_stmt|;
name|data
operator|->
name|silent_vlan_value
operator|=
name|ECORE_CPU_TO_LE16
argument_list|(
name|params
operator|->
name|silent_removal_value
argument_list|)
expr_stmt|;
name|data
operator|->
name|silent_vlan_mask
operator|=
name|ECORE_CPU_TO_LE16
argument_list|(
name|params
operator|->
name|silent_removal_mask
argument_list|)
expr_stmt|;
comment|/* tx switching */
name|data
operator|->
name|tx_switching_flg
operator|=
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_UPDATE_TX_SWITCHING
argument_list|,
operator|&
name|params
operator|->
name|update_flags
argument_list|)
expr_stmt|;
name|data
operator|->
name|tx_switching_change_flg
operator|=
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_UPDATE_TX_SWITCHING_CHNG
argument_list|,
operator|&
name|params
operator|->
name|update_flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|ecore_q_send_update
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_queue_state_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ecore_queue_sp_obj
modifier|*
name|o
init|=
name|params
operator|->
name|q_obj
decl_stmt|;
name|struct
name|client_update_ramrod_data
modifier|*
name|rdata
init|=
operator|(
expr|struct
name|client_update_ramrod_data
operator|*
operator|)
name|o
operator|->
name|rdata
decl_stmt|;
name|ecore_dma_addr_t
name|data_mapping
init|=
name|o
operator|->
name|rdata_mapping
decl_stmt|;
name|struct
name|ecore_queue_update_params
modifier|*
name|update_params
init|=
operator|&
name|params
operator|->
name|params
operator|.
name|update
decl_stmt|;
name|uint8_t
name|cid_index
init|=
name|update_params
operator|->
name|cid_index
decl_stmt|;
if|if
condition|(
name|cid_index
operator|>=
name|o
operator|->
name|max_cos
condition|)
block|{
name|ECORE_ERR
argument_list|(
literal|"queue[%d]: cid_index (%d) is out of range\n"
argument_list|,
name|o
operator|->
name|cl_id
argument_list|,
name|cid_index
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
comment|/* Clear the ramrod data */
name|ECORE_MEMSET
argument_list|(
name|rdata
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rdata
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fill the ramrod data */
name|ecore_q_fill_update_data
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
name|update_params
argument_list|,
name|rdata
argument_list|)
expr_stmt|;
comment|/* No need for an explicit memory barrier here as long we would 	 * need to ensure the ordering of writing to the SPQ element 	 * and updating of the SPQ producer which involves a memory 	 * read and we will have to put a full memory barrier there 	 * (inside ecore_sp_post()). 	 */
return|return
name|ecore_sp_post
argument_list|(
name|sc
argument_list|,
name|RAMROD_CMD_ID_ETH_CLIENT_UPDATE
argument_list|,
name|o
operator|->
name|cids
index|[
name|cid_index
index|]
argument_list|,
name|data_mapping
argument_list|,
name|ETH_CONNECTION_TYPE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ecore_q_send_deactivate - send DEACTIVATE command  *  * @sc:		device handle  * @params:  *  * implemented using the UPDATE command.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ecore_q_send_deactivate
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_queue_state_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ecore_queue_update_params
modifier|*
name|update
init|=
operator|&
name|params
operator|->
name|params
operator|.
name|update
decl_stmt|;
name|ECORE_MEMSET
argument_list|(
name|update
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|update
argument_list|)
argument_list|)
expr_stmt|;
name|ECORE_SET_BIT_NA
argument_list|(
name|ECORE_Q_UPDATE_ACTIVATE_CHNG
argument_list|,
operator|&
name|update
operator|->
name|update_flags
argument_list|)
expr_stmt|;
return|return
name|ecore_q_send_update
argument_list|(
name|sc
argument_list|,
name|params
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ecore_q_send_activate - send ACTIVATE command  *  * @sc:		device handle  * @params:  *  * implemented using the UPDATE command.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ecore_q_send_activate
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_queue_state_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ecore_queue_update_params
modifier|*
name|update
init|=
operator|&
name|params
operator|->
name|params
operator|.
name|update
decl_stmt|;
name|ECORE_MEMSET
argument_list|(
name|update
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|update
argument_list|)
argument_list|)
expr_stmt|;
name|ECORE_SET_BIT_NA
argument_list|(
name|ECORE_Q_UPDATE_ACTIVATE
argument_list|,
operator|&
name|update
operator|->
name|update_flags
argument_list|)
expr_stmt|;
name|ECORE_SET_BIT_NA
argument_list|(
name|ECORE_Q_UPDATE_ACTIVATE_CHNG
argument_list|,
operator|&
name|update
operator|->
name|update_flags
argument_list|)
expr_stmt|;
return|return
name|ecore_q_send_update
argument_list|(
name|sc
argument_list|,
name|params
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|ecore_q_send_update_tpa
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_queue_state_params
modifier|*
name|params
parameter_list|)
block|{
comment|/* TODO: Not implemented yet. */
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|ecore_q_send_halt
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_queue_state_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ecore_queue_sp_obj
modifier|*
name|o
init|=
name|params
operator|->
name|q_obj
decl_stmt|;
comment|/* build eth_halt_ramrod_data.client_id in a big-endian friendly way */
name|ecore_dma_addr_t
name|data_mapping
init|=
literal|0
decl_stmt|;
name|data_mapping
operator|=
operator|(
name|ecore_dma_addr_t
operator|)
name|o
operator|->
name|cl_id
expr_stmt|;
return|return
name|ecore_sp_post
argument_list|(
name|sc
argument_list|,
name|RAMROD_CMD_ID_ETH_HALT
argument_list|,
name|o
operator|->
name|cids
index|[
name|ECORE_PRIMARY_CID_INDEX
index|]
argument_list|,
name|data_mapping
argument_list|,
name|ETH_CONNECTION_TYPE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|ecore_q_send_cfc_del
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_queue_state_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ecore_queue_sp_obj
modifier|*
name|o
init|=
name|params
operator|->
name|q_obj
decl_stmt|;
name|uint8_t
name|cid_idx
init|=
name|params
operator|->
name|params
operator|.
name|cfc_del
operator|.
name|cid_index
decl_stmt|;
if|if
condition|(
name|cid_idx
operator|>=
name|o
operator|->
name|max_cos
condition|)
block|{
name|ECORE_ERR
argument_list|(
literal|"queue[%d]: cid_index (%d) is out of range\n"
argument_list|,
name|o
operator|->
name|cl_id
argument_list|,
name|cid_idx
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
return|return
name|ecore_sp_post
argument_list|(
name|sc
argument_list|,
name|RAMROD_CMD_ID_COMMON_CFC_DEL
argument_list|,
name|o
operator|->
name|cids
index|[
name|cid_idx
index|]
argument_list|,
literal|0
argument_list|,
name|NONE_CONNECTION_TYPE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|ecore_q_send_terminate
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_queue_state_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ecore_queue_sp_obj
modifier|*
name|o
init|=
name|params
operator|->
name|q_obj
decl_stmt|;
name|uint8_t
name|cid_index
init|=
name|params
operator|->
name|params
operator|.
name|terminate
operator|.
name|cid_index
decl_stmt|;
if|if
condition|(
name|cid_index
operator|>=
name|o
operator|->
name|max_cos
condition|)
block|{
name|ECORE_ERR
argument_list|(
literal|"queue[%d]: cid_index (%d) is out of range\n"
argument_list|,
name|o
operator|->
name|cl_id
argument_list|,
name|cid_index
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
return|return
name|ecore_sp_post
argument_list|(
name|sc
argument_list|,
name|RAMROD_CMD_ID_ETH_TERMINATE
argument_list|,
name|o
operator|->
name|cids
index|[
name|cid_index
index|]
argument_list|,
literal|0
argument_list|,
name|ETH_CONNECTION_TYPE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|ecore_q_send_empty
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_queue_state_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ecore_queue_sp_obj
modifier|*
name|o
init|=
name|params
operator|->
name|q_obj
decl_stmt|;
return|return
name|ecore_sp_post
argument_list|(
name|sc
argument_list|,
name|RAMROD_CMD_ID_ETH_EMPTY
argument_list|,
name|o
operator|->
name|cids
index|[
name|ECORE_PRIMARY_CID_INDEX
index|]
argument_list|,
literal|0
argument_list|,
name|ETH_CONNECTION_TYPE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|ecore_queue_send_cmd_cmn
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_queue_state_params
modifier|*
name|params
parameter_list|)
block|{
switch|switch
condition|(
name|params
operator|->
name|cmd
condition|)
block|{
case|case
name|ECORE_Q_CMD_INIT
case|:
return|return
name|ecore_q_init
argument_list|(
name|sc
argument_list|,
name|params
argument_list|)
return|;
case|case
name|ECORE_Q_CMD_SETUP_TX_ONLY
case|:
return|return
name|ecore_q_send_setup_tx_only
argument_list|(
name|sc
argument_list|,
name|params
argument_list|)
return|;
case|case
name|ECORE_Q_CMD_DEACTIVATE
case|:
return|return
name|ecore_q_send_deactivate
argument_list|(
name|sc
argument_list|,
name|params
argument_list|)
return|;
case|case
name|ECORE_Q_CMD_ACTIVATE
case|:
return|return
name|ecore_q_send_activate
argument_list|(
name|sc
argument_list|,
name|params
argument_list|)
return|;
case|case
name|ECORE_Q_CMD_UPDATE
case|:
return|return
name|ecore_q_send_update
argument_list|(
name|sc
argument_list|,
name|params
argument_list|)
return|;
case|case
name|ECORE_Q_CMD_UPDATE_TPA
case|:
return|return
name|ecore_q_send_update_tpa
argument_list|(
name|sc
argument_list|,
name|params
argument_list|)
return|;
case|case
name|ECORE_Q_CMD_HALT
case|:
return|return
name|ecore_q_send_halt
argument_list|(
name|sc
argument_list|,
name|params
argument_list|)
return|;
case|case
name|ECORE_Q_CMD_CFC_DEL
case|:
return|return
name|ecore_q_send_cfc_del
argument_list|(
name|sc
argument_list|,
name|params
argument_list|)
return|;
case|case
name|ECORE_Q_CMD_TERMINATE
case|:
return|return
name|ecore_q_send_terminate
argument_list|(
name|sc
argument_list|,
name|params
argument_list|)
return|;
case|case
name|ECORE_Q_CMD_EMPTY
case|:
return|return
name|ecore_q_send_empty
argument_list|(
name|sc
argument_list|,
name|params
argument_list|)
return|;
default|default:
name|ECORE_ERR
argument_list|(
literal|"Unknown command: %d\n"
argument_list|,
name|params
operator|->
name|cmd
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ecore_queue_send_cmd_e1x
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_queue_state_params
modifier|*
name|params
parameter_list|)
block|{
switch|switch
condition|(
name|params
operator|->
name|cmd
condition|)
block|{
case|case
name|ECORE_Q_CMD_SETUP
case|:
return|return
name|ecore_q_send_setup_e1x
argument_list|(
name|sc
argument_list|,
name|params
argument_list|)
return|;
case|case
name|ECORE_Q_CMD_INIT
case|:
case|case
name|ECORE_Q_CMD_SETUP_TX_ONLY
case|:
case|case
name|ECORE_Q_CMD_DEACTIVATE
case|:
case|case
name|ECORE_Q_CMD_ACTIVATE
case|:
case|case
name|ECORE_Q_CMD_UPDATE
case|:
case|case
name|ECORE_Q_CMD_UPDATE_TPA
case|:
case|case
name|ECORE_Q_CMD_HALT
case|:
case|case
name|ECORE_Q_CMD_CFC_DEL
case|:
case|case
name|ECORE_Q_CMD_TERMINATE
case|:
case|case
name|ECORE_Q_CMD_EMPTY
case|:
return|return
name|ecore_queue_send_cmd_cmn
argument_list|(
name|sc
argument_list|,
name|params
argument_list|)
return|;
default|default:
name|ECORE_ERR
argument_list|(
literal|"Unknown command: %d\n"
argument_list|,
name|params
operator|->
name|cmd
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ecore_queue_send_cmd_e2
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_queue_state_params
modifier|*
name|params
parameter_list|)
block|{
switch|switch
condition|(
name|params
operator|->
name|cmd
condition|)
block|{
case|case
name|ECORE_Q_CMD_SETUP
case|:
return|return
name|ecore_q_send_setup_e2
argument_list|(
name|sc
argument_list|,
name|params
argument_list|)
return|;
case|case
name|ECORE_Q_CMD_INIT
case|:
case|case
name|ECORE_Q_CMD_SETUP_TX_ONLY
case|:
case|case
name|ECORE_Q_CMD_DEACTIVATE
case|:
case|case
name|ECORE_Q_CMD_ACTIVATE
case|:
case|case
name|ECORE_Q_CMD_UPDATE
case|:
case|case
name|ECORE_Q_CMD_UPDATE_TPA
case|:
case|case
name|ECORE_Q_CMD_HALT
case|:
case|case
name|ECORE_Q_CMD_CFC_DEL
case|:
case|case
name|ECORE_Q_CMD_TERMINATE
case|:
case|case
name|ECORE_Q_CMD_EMPTY
case|:
return|return
name|ecore_queue_send_cmd_cmn
argument_list|(
name|sc
argument_list|,
name|params
argument_list|)
return|;
default|default:
name|ECORE_ERR
argument_list|(
literal|"Unknown command: %d\n"
argument_list|,
name|params
operator|->
name|cmd
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * ecore_queue_chk_transition - check state machine of a regular Queue  *  * @sc:		device handle  * @o:  * @params:  *  * (not Forwarding)  * It both checks if the requested command is legal in a current  * state and, if it's legal, sets a `next_state' in the object  * that will be used in the completion flow to set the `state'  * of the object.  *  * returns 0 if a requested command is a legal transition,  *         ECORE_INVAL otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|ecore_queue_chk_transition
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_queue_sp_obj
modifier|*
name|o
parameter_list|,
name|struct
name|ecore_queue_state_params
modifier|*
name|params
parameter_list|)
block|{
name|enum
name|ecore_q_state
name|state
init|=
name|o
operator|->
name|state
decl_stmt|,
name|next_state
init|=
name|ECORE_Q_STATE_MAX
decl_stmt|;
name|enum
name|ecore_queue_cmd
name|cmd
init|=
name|params
operator|->
name|cmd
decl_stmt|;
name|struct
name|ecore_queue_update_params
modifier|*
name|update_params
init|=
operator|&
name|params
operator|->
name|params
operator|.
name|update
decl_stmt|;
name|uint8_t
name|next_tx_only
init|=
name|o
operator|->
name|num_tx_only
decl_stmt|;
comment|/* Forget all pending for completion commands if a driver only state 	 * transition has been requested. 	 */
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|RAMROD_DRV_CLR_ONLY
argument_list|,
operator|&
name|params
operator|->
name|ramrod_flags
argument_list|)
condition|)
block|{
name|o
operator|->
name|pending
operator|=
literal|0
expr_stmt|;
name|o
operator|->
name|next_state
operator|=
name|ECORE_Q_STATE_MAX
expr_stmt|;
block|}
comment|/* Don't allow a next state transition if we are in the middle of 	 * the previous one. 	 */
if|if
condition|(
name|o
operator|->
name|pending
condition|)
block|{
name|ECORE_ERR
argument_list|(
literal|"Blocking transition since pending was %lx\n"
argument_list|,
name|o
operator|->
name|pending
argument_list|)
expr_stmt|;
return|return
name|ECORE_BUSY
return|;
block|}
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|ECORE_Q_STATE_RESET
case|:
if|if
condition|(
name|cmd
operator|==
name|ECORE_Q_CMD_INIT
condition|)
name|next_state
operator|=
name|ECORE_Q_STATE_INITIALIZED
expr_stmt|;
break|break;
case|case
name|ECORE_Q_STATE_INITIALIZED
case|:
if|if
condition|(
name|cmd
operator|==
name|ECORE_Q_CMD_SETUP
condition|)
block|{
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_FLG_ACTIVE
argument_list|,
operator|&
name|params
operator|->
name|params
operator|.
name|setup
operator|.
name|flags
argument_list|)
condition|)
name|next_state
operator|=
name|ECORE_Q_STATE_ACTIVE
expr_stmt|;
else|else
name|next_state
operator|=
name|ECORE_Q_STATE_INACTIVE
expr_stmt|;
block|}
break|break;
case|case
name|ECORE_Q_STATE_ACTIVE
case|:
if|if
condition|(
name|cmd
operator|==
name|ECORE_Q_CMD_DEACTIVATE
condition|)
name|next_state
operator|=
name|ECORE_Q_STATE_INACTIVE
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|cmd
operator|==
name|ECORE_Q_CMD_EMPTY
operator|)
operator|||
operator|(
name|cmd
operator|==
name|ECORE_Q_CMD_UPDATE_TPA
operator|)
condition|)
name|next_state
operator|=
name|ECORE_Q_STATE_ACTIVE
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd
operator|==
name|ECORE_Q_CMD_SETUP_TX_ONLY
condition|)
block|{
name|next_state
operator|=
name|ECORE_Q_STATE_MULTI_COS
expr_stmt|;
name|next_tx_only
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|==
name|ECORE_Q_CMD_HALT
condition|)
name|next_state
operator|=
name|ECORE_Q_STATE_STOPPED
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd
operator|==
name|ECORE_Q_CMD_UPDATE
condition|)
block|{
comment|/* If "active" state change is requested, update the 			 *  state accordingly. 			 */
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_UPDATE_ACTIVATE_CHNG
argument_list|,
operator|&
name|update_params
operator|->
name|update_flags
argument_list|)
operator|&&
operator|!
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_UPDATE_ACTIVATE
argument_list|,
operator|&
name|update_params
operator|->
name|update_flags
argument_list|)
condition|)
name|next_state
operator|=
name|ECORE_Q_STATE_INACTIVE
expr_stmt|;
else|else
name|next_state
operator|=
name|ECORE_Q_STATE_ACTIVE
expr_stmt|;
block|}
break|break;
case|case
name|ECORE_Q_STATE_MULTI_COS
case|:
if|if
condition|(
name|cmd
operator|==
name|ECORE_Q_CMD_TERMINATE
condition|)
name|next_state
operator|=
name|ECORE_Q_STATE_MCOS_TERMINATED
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd
operator|==
name|ECORE_Q_CMD_SETUP_TX_ONLY
condition|)
block|{
name|next_state
operator|=
name|ECORE_Q_STATE_MULTI_COS
expr_stmt|;
name|next_tx_only
operator|=
name|o
operator|->
name|num_tx_only
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|cmd
operator|==
name|ECORE_Q_CMD_EMPTY
operator|)
operator|||
operator|(
name|cmd
operator|==
name|ECORE_Q_CMD_UPDATE_TPA
operator|)
condition|)
name|next_state
operator|=
name|ECORE_Q_STATE_MULTI_COS
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd
operator|==
name|ECORE_Q_CMD_UPDATE
condition|)
block|{
comment|/* If "active" state change is requested, update the 			 *  state accordingly. 			 */
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_UPDATE_ACTIVATE_CHNG
argument_list|,
operator|&
name|update_params
operator|->
name|update_flags
argument_list|)
operator|&&
operator|!
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_UPDATE_ACTIVATE
argument_list|,
operator|&
name|update_params
operator|->
name|update_flags
argument_list|)
condition|)
name|next_state
operator|=
name|ECORE_Q_STATE_INACTIVE
expr_stmt|;
else|else
name|next_state
operator|=
name|ECORE_Q_STATE_MULTI_COS
expr_stmt|;
block|}
break|break;
case|case
name|ECORE_Q_STATE_MCOS_TERMINATED
case|:
if|if
condition|(
name|cmd
operator|==
name|ECORE_Q_CMD_CFC_DEL
condition|)
block|{
name|next_tx_only
operator|=
name|o
operator|->
name|num_tx_only
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|next_tx_only
operator|==
literal|0
condition|)
name|next_state
operator|=
name|ECORE_Q_STATE_ACTIVE
expr_stmt|;
else|else
name|next_state
operator|=
name|ECORE_Q_STATE_MULTI_COS
expr_stmt|;
block|}
break|break;
case|case
name|ECORE_Q_STATE_INACTIVE
case|:
if|if
condition|(
name|cmd
operator|==
name|ECORE_Q_CMD_ACTIVATE
condition|)
name|next_state
operator|=
name|ECORE_Q_STATE_ACTIVE
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|cmd
operator|==
name|ECORE_Q_CMD_EMPTY
operator|)
operator|||
operator|(
name|cmd
operator|==
name|ECORE_Q_CMD_UPDATE_TPA
operator|)
condition|)
name|next_state
operator|=
name|ECORE_Q_STATE_INACTIVE
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd
operator|==
name|ECORE_Q_CMD_HALT
condition|)
name|next_state
operator|=
name|ECORE_Q_STATE_STOPPED
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd
operator|==
name|ECORE_Q_CMD_UPDATE
condition|)
block|{
comment|/* If "active" state change is requested, update the 			 * state accordingly. 			 */
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_UPDATE_ACTIVATE_CHNG
argument_list|,
operator|&
name|update_params
operator|->
name|update_flags
argument_list|)
operator|&&
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_UPDATE_ACTIVATE
argument_list|,
operator|&
name|update_params
operator|->
name|update_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|o
operator|->
name|num_tx_only
operator|==
literal|0
condition|)
name|next_state
operator|=
name|ECORE_Q_STATE_ACTIVE
expr_stmt|;
else|else
comment|/* tx only queues exist for this queue */
name|next_state
operator|=
name|ECORE_Q_STATE_MULTI_COS
expr_stmt|;
block|}
else|else
name|next_state
operator|=
name|ECORE_Q_STATE_INACTIVE
expr_stmt|;
block|}
break|break;
case|case
name|ECORE_Q_STATE_STOPPED
case|:
if|if
condition|(
name|cmd
operator|==
name|ECORE_Q_CMD_TERMINATE
condition|)
name|next_state
operator|=
name|ECORE_Q_STATE_TERMINATED
expr_stmt|;
break|break;
case|case
name|ECORE_Q_STATE_TERMINATED
case|:
if|if
condition|(
name|cmd
operator|==
name|ECORE_Q_CMD_CFC_DEL
condition|)
name|next_state
operator|=
name|ECORE_Q_STATE_RESET
expr_stmt|;
break|break;
default|default:
name|ECORE_ERR
argument_list|(
literal|"Illegal state: %d\n"
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
comment|/* Transition is assured */
if|if
condition|(
name|next_state
operator|!=
name|ECORE_Q_STATE_MAX
condition|)
block|{
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"Good state transition: %d(%d)->%d\n"
argument_list|,
name|state
argument_list|,
name|cmd
argument_list|,
name|next_state
argument_list|)
expr_stmt|;
name|o
operator|->
name|next_state
operator|=
name|next_state
expr_stmt|;
name|o
operator|->
name|next_tx_only
operator|=
name|next_tx_only
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"Bad state transition request: %d %d\n"
argument_list|,
name|state
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
end_function

begin_comment
comment|/**  * ecore_queue_chk_fwd_transition - check state machine of a Forwarding Queue.  *  * @sc:		device handle  * @o:  * @params:  *  * It both checks if the requested command is legal in a current  * state and, if it's legal, sets a `next_state' in the object  * that will be used in the completion flow to set the `state'  * of the object.  *  * returns 0 if a requested command is a legal transition,  *         ECORE_INVAL otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|ecore_queue_chk_fwd_transition
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_queue_sp_obj
modifier|*
name|o
parameter_list|,
name|struct
name|ecore_queue_state_params
modifier|*
name|params
parameter_list|)
block|{
name|enum
name|ecore_q_state
name|state
init|=
name|o
operator|->
name|state
decl_stmt|,
name|next_state
init|=
name|ECORE_Q_STATE_MAX
decl_stmt|;
name|enum
name|ecore_queue_cmd
name|cmd
init|=
name|params
operator|->
name|cmd
decl_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|ECORE_Q_STATE_RESET
case|:
if|if
condition|(
name|cmd
operator|==
name|ECORE_Q_CMD_INIT
condition|)
name|next_state
operator|=
name|ECORE_Q_STATE_INITIALIZED
expr_stmt|;
break|break;
case|case
name|ECORE_Q_STATE_INITIALIZED
case|:
if|if
condition|(
name|cmd
operator|==
name|ECORE_Q_CMD_SETUP_TX_ONLY
condition|)
block|{
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_FLG_ACTIVE
argument_list|,
operator|&
name|params
operator|->
name|params
operator|.
name|tx_only
operator|.
name|flags
argument_list|)
condition|)
name|next_state
operator|=
name|ECORE_Q_STATE_ACTIVE
expr_stmt|;
else|else
name|next_state
operator|=
name|ECORE_Q_STATE_INACTIVE
expr_stmt|;
block|}
break|break;
case|case
name|ECORE_Q_STATE_ACTIVE
case|:
case|case
name|ECORE_Q_STATE_INACTIVE
case|:
if|if
condition|(
name|cmd
operator|==
name|ECORE_Q_CMD_CFC_DEL
condition|)
name|next_state
operator|=
name|ECORE_Q_STATE_RESET
expr_stmt|;
break|break;
default|default:
name|ECORE_ERR
argument_list|(
literal|"Illegal state: %d\n"
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
comment|/* Transition is assured */
if|if
condition|(
name|next_state
operator|!=
name|ECORE_Q_STATE_MAX
condition|)
block|{
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"Good state transition: %d(%d)->%d\n"
argument_list|,
name|state
argument_list|,
name|cmd
argument_list|,
name|next_state
argument_list|)
expr_stmt|;
name|o
operator|->
name|next_state
operator|=
name|next_state
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"Bad state transition request: %d %d\n"
argument_list|,
name|state
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
end_function

begin_function
name|void
name|ecore_init_queue_obj
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_queue_sp_obj
modifier|*
name|obj
parameter_list|,
name|uint8_t
name|cl_id
parameter_list|,
name|uint32_t
modifier|*
name|cids
parameter_list|,
name|uint8_t
name|cid_cnt
parameter_list|,
name|uint8_t
name|func_id
parameter_list|,
name|void
modifier|*
name|rdata
parameter_list|,
name|ecore_dma_addr_t
name|rdata_mapping
parameter_list|,
name|unsigned
name|long
name|type
parameter_list|)
block|{
name|ECORE_MEMSET
argument_list|(
name|obj
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|obj
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We support only ECORE_MULTI_TX_COS Tx CoS at the moment */
name|ECORE_BUG_ON
argument_list|(
name|ECORE_MULTI_TX_COS
operator|<
name|cid_cnt
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|obj
operator|->
name|cids
argument_list|,
name|cids
argument_list|,
sizeof|sizeof
argument_list|(
name|obj
operator|->
name|cids
index|[
literal|0
index|]
argument_list|)
operator|*
name|cid_cnt
argument_list|)
expr_stmt|;
name|obj
operator|->
name|max_cos
operator|=
name|cid_cnt
expr_stmt|;
name|obj
operator|->
name|cl_id
operator|=
name|cl_id
expr_stmt|;
name|obj
operator|->
name|func_id
operator|=
name|func_id
expr_stmt|;
name|obj
operator|->
name|rdata
operator|=
name|rdata
expr_stmt|;
name|obj
operator|->
name|rdata_mapping
operator|=
name|rdata_mapping
expr_stmt|;
name|obj
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|obj
operator|->
name|next_state
operator|=
name|ECORE_Q_STATE_MAX
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
name|obj
operator|->
name|send_cmd
operator|=
name|ecore_queue_send_cmd_e1x
expr_stmt|;
else|else
name|obj
operator|->
name|send_cmd
operator|=
name|ecore_queue_send_cmd_e2
expr_stmt|;
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_Q_TYPE_FWD
argument_list|,
operator|&
name|type
argument_list|)
condition|)
name|obj
operator|->
name|check_transition
operator|=
name|ecore_queue_chk_fwd_transition
expr_stmt|;
else|else
name|obj
operator|->
name|check_transition
operator|=
name|ecore_queue_chk_transition
expr_stmt|;
name|obj
operator|->
name|complete_cmd
operator|=
name|ecore_queue_comp_cmd
expr_stmt|;
name|obj
operator|->
name|wait_comp
operator|=
name|ecore_queue_wait_comp
expr_stmt|;
name|obj
operator|->
name|set_pending
operator|=
name|ecore_queue_set_pending
expr_stmt|;
block|}
end_function

begin_comment
comment|/* return a queue object's logical state*/
end_comment

begin_function
name|int
name|ecore_get_q_logical_state
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_queue_sp_obj
modifier|*
name|obj
parameter_list|)
block|{
switch|switch
condition|(
name|obj
operator|->
name|state
condition|)
block|{
case|case
name|ECORE_Q_STATE_ACTIVE
case|:
case|case
name|ECORE_Q_STATE_MULTI_COS
case|:
return|return
name|ECORE_Q_LOGICAL_STATE_ACTIVE
return|;
case|case
name|ECORE_Q_STATE_RESET
case|:
case|case
name|ECORE_Q_STATE_INITIALIZED
case|:
case|case
name|ECORE_Q_STATE_MCOS_TERMINATED
case|:
case|case
name|ECORE_Q_STATE_INACTIVE
case|:
case|case
name|ECORE_Q_STATE_STOPPED
case|:
case|case
name|ECORE_Q_STATE_TERMINATED
case|:
case|case
name|ECORE_Q_STATE_FLRED
case|:
return|return
name|ECORE_Q_LOGICAL_STATE_STOPPED
return|;
default|default:
return|return
name|ECORE_INVAL
return|;
block|}
block|}
end_function

begin_comment
comment|/********************** Function state object *********************************/
end_comment

begin_function
name|enum
name|ecore_func_state
name|ecore_func_get_state
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_func_sp_obj
modifier|*
name|o
parameter_list|)
block|{
comment|/* in the middle of transaction - return INVALID state */
if|if
condition|(
name|o
operator|->
name|pending
condition|)
return|return
name|ECORE_F_STATE_MAX
return|;
comment|/* unsure the order of reading of o->pending and o->state 	 * o->pending should be read first 	 */
name|rmb
argument_list|()
expr_stmt|;
return|return
name|o
operator|->
name|state
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ecore_func_wait_comp
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_func_sp_obj
modifier|*
name|o
parameter_list|,
name|enum
name|ecore_func_cmd
name|cmd
parameter_list|)
block|{
return|return
name|ecore_state_wait
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|,
operator|&
name|o
operator|->
name|pending
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ecore_func_state_change_comp - complete the state machine transition  *  * @sc:		device handle  * @o:  * @cmd:  *  * Called on state change transition. Completes the state  * machine transition only - no HW interaction.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ecore_func_state_change_comp
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_func_sp_obj
modifier|*
name|o
parameter_list|,
name|enum
name|ecore_func_cmd
name|cmd
parameter_list|)
block|{
name|unsigned
name|long
name|cur_pending
init|=
name|o
operator|->
name|pending
decl_stmt|;
if|if
condition|(
operator|!
name|ECORE_TEST_AND_CLEAR_BIT
argument_list|(
name|cmd
argument_list|,
operator|&
name|cur_pending
argument_list|)
condition|)
block|{
name|ECORE_ERR
argument_list|(
literal|"Bad MC reply %d for func %d in state %d pending 0x%lx, next_state %d\n"
argument_list|,
name|cmd
argument_list|,
name|ECORE_FUNC_ID
argument_list|(
name|sc
argument_list|)
argument_list|,
name|o
operator|->
name|state
argument_list|,
name|cur_pending
argument_list|,
name|o
operator|->
name|next_state
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"Completing command %d for func %d, setting state to %d\n"
argument_list|,
name|cmd
argument_list|,
name|ECORE_FUNC_ID
argument_list|(
name|sc
argument_list|)
argument_list|,
name|o
operator|->
name|next_state
argument_list|)
expr_stmt|;
name|o
operator|->
name|state
operator|=
name|o
operator|->
name|next_state
expr_stmt|;
name|o
operator|->
name|next_state
operator|=
name|ECORE_F_STATE_MAX
expr_stmt|;
comment|/* It's important that o->state and o->next_state are 	 * updated before o->pending. 	 */
name|wmb
argument_list|()
expr_stmt|;
name|ECORE_CLEAR_BIT
argument_list|(
name|cmd
argument_list|,
operator|&
name|o
operator|->
name|pending
argument_list|)
expr_stmt|;
name|ECORE_SMP_MB_AFTER_CLEAR_BIT
argument_list|()
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  * ecore_func_comp_cmd - complete the state change command  *  * @sc:		device handle  * @o:  * @cmd:  *  * Checks that the arrived completion is expected.  */
end_comment

begin_function
specifier|static
name|int
name|ecore_func_comp_cmd
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_func_sp_obj
modifier|*
name|o
parameter_list|,
name|enum
name|ecore_func_cmd
name|cmd
parameter_list|)
block|{
comment|/* Complete the state machine part first, check if it's a 	 * legal completion. 	 */
name|int
name|rc
init|=
name|ecore_func_state_change_comp
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
name|cmd
argument_list|)
decl_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/**  * ecore_func_chk_transition - perform function state machine transition  *  * @sc:		device handle  * @o:  * @params:  *  * It both checks if the requested command is legal in a current  * state and, if it's legal, sets a `next_state' in the object  * that will be used in the completion flow to set the `state'  * of the object.  *  * returns 0 if a requested command is a legal transition,  *         ECORE_INVAL otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|ecore_func_chk_transition
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_func_sp_obj
modifier|*
name|o
parameter_list|,
name|struct
name|ecore_func_state_params
modifier|*
name|params
parameter_list|)
block|{
name|enum
name|ecore_func_state
name|state
init|=
name|o
operator|->
name|state
decl_stmt|,
name|next_state
init|=
name|ECORE_F_STATE_MAX
decl_stmt|;
name|enum
name|ecore_func_cmd
name|cmd
init|=
name|params
operator|->
name|cmd
decl_stmt|;
comment|/* Forget all pending for completion commands if a driver only state 	 * transition has been requested. 	 */
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|RAMROD_DRV_CLR_ONLY
argument_list|,
operator|&
name|params
operator|->
name|ramrod_flags
argument_list|)
condition|)
block|{
name|o
operator|->
name|pending
operator|=
literal|0
expr_stmt|;
name|o
operator|->
name|next_state
operator|=
name|ECORE_F_STATE_MAX
expr_stmt|;
block|}
comment|/* Don't allow a next state transition if we are in the middle of 	 * the previous one. 	 */
if|if
condition|(
name|o
operator|->
name|pending
condition|)
return|return
name|ECORE_BUSY
return|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|ECORE_F_STATE_RESET
case|:
if|if
condition|(
name|cmd
operator|==
name|ECORE_F_CMD_HW_INIT
condition|)
name|next_state
operator|=
name|ECORE_F_STATE_INITIALIZED
expr_stmt|;
break|break;
case|case
name|ECORE_F_STATE_INITIALIZED
case|:
if|if
condition|(
name|cmd
operator|==
name|ECORE_F_CMD_START
condition|)
name|next_state
operator|=
name|ECORE_F_STATE_STARTED
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd
operator|==
name|ECORE_F_CMD_HW_RESET
condition|)
name|next_state
operator|=
name|ECORE_F_STATE_RESET
expr_stmt|;
break|break;
case|case
name|ECORE_F_STATE_STARTED
case|:
if|if
condition|(
name|cmd
operator|==
name|ECORE_F_CMD_STOP
condition|)
name|next_state
operator|=
name|ECORE_F_STATE_INITIALIZED
expr_stmt|;
comment|/* afex ramrods can be sent only in started mode, and only 		 * if not pending for function_stop ramrod completion 		 * for these events - next state remained STARTED. 		 */
elseif|else
if|if
condition|(
operator|(
name|cmd
operator|==
name|ECORE_F_CMD_AFEX_UPDATE
operator|)
operator|&&
operator|(
operator|!
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_F_CMD_STOP
argument_list|,
operator|&
name|o
operator|->
name|pending
argument_list|)
operator|)
condition|)
name|next_state
operator|=
name|ECORE_F_STATE_STARTED
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|cmd
operator|==
name|ECORE_F_CMD_AFEX_VIFLISTS
operator|)
operator|&&
operator|(
operator|!
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_F_CMD_STOP
argument_list|,
operator|&
name|o
operator|->
name|pending
argument_list|)
operator|)
condition|)
name|next_state
operator|=
name|ECORE_F_STATE_STARTED
expr_stmt|;
comment|/* Switch_update ramrod can be sent in either started or 		 * tx_stopped state, and it doesn't change the state. 		 */
elseif|else
if|if
condition|(
operator|(
name|cmd
operator|==
name|ECORE_F_CMD_SWITCH_UPDATE
operator|)
operator|&&
operator|(
operator|!
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_F_CMD_STOP
argument_list|,
operator|&
name|o
operator|->
name|pending
argument_list|)
operator|)
condition|)
name|next_state
operator|=
name|ECORE_F_STATE_STARTED
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd
operator|==
name|ECORE_F_CMD_TX_STOP
condition|)
name|next_state
operator|=
name|ECORE_F_STATE_TX_STOPPED
expr_stmt|;
break|break;
case|case
name|ECORE_F_STATE_TX_STOPPED
case|:
if|if
condition|(
operator|(
name|cmd
operator|==
name|ECORE_F_CMD_SWITCH_UPDATE
operator|)
operator|&&
operator|(
operator|!
name|ECORE_TEST_BIT
argument_list|(
name|ECORE_F_CMD_STOP
argument_list|,
operator|&
name|o
operator|->
name|pending
argument_list|)
operator|)
condition|)
name|next_state
operator|=
name|ECORE_F_STATE_TX_STOPPED
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd
operator|==
name|ECORE_F_CMD_TX_START
condition|)
name|next_state
operator|=
name|ECORE_F_STATE_STARTED
expr_stmt|;
break|break;
default|default:
name|ECORE_ERR
argument_list|(
literal|"Unknown state: %d\n"
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
comment|/* Transition is assured */
if|if
condition|(
name|next_state
operator|!=
name|ECORE_F_STATE_MAX
condition|)
block|{
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"Good function state transition: %d(%d)->%d\n"
argument_list|,
name|state
argument_list|,
name|cmd
argument_list|,
name|next_state
argument_list|)
expr_stmt|;
name|o
operator|->
name|next_state
operator|=
name|next_state
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"Bad function state transition request: %d %d\n"
argument_list|,
name|state
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
end_function

begin_comment
comment|/**  * ecore_func_init_func - performs HW init at function stage  *  * @sc:		device handle  * @drv:  *  * Init HW when the current phase is  * FW_MSG_CODE_DRV_LOAD_FUNCTION: initialize only FUNCTION-only  * HW blocks.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ecore_func_init_func
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|ecore_func_sp_drv_ops
modifier|*
name|drv
parameter_list|)
block|{
return|return
name|drv
operator|->
name|init_hw_func
argument_list|(
name|sc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ecore_func_init_port - performs HW init at port stage  *  * @sc:		device handle  * @drv:  *  * Init HW when the current phase is  * FW_MSG_CODE_DRV_LOAD_PORT: initialize PORT-only and  * FUNCTION-only HW blocks.  *  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ecore_func_init_port
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|ecore_func_sp_drv_ops
modifier|*
name|drv
parameter_list|)
block|{
name|int
name|rc
init|=
name|drv
operator|->
name|init_hw_port
argument_list|(
name|sc
argument_list|)
decl_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
return|return
name|ecore_func_init_func
argument_list|(
name|sc
argument_list|,
name|drv
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ecore_func_init_cmn_chip - performs HW init at chip-common stage  *  * @sc:		device handle  * @drv:  *  * Init HW when the current phase is  * FW_MSG_CODE_DRV_LOAD_COMMON_CHIP: initialize COMMON_CHIP,  * PORT-only and FUNCTION-only HW blocks.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ecore_func_init_cmn_chip
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|ecore_func_sp_drv_ops
modifier|*
name|drv
parameter_list|)
block|{
name|int
name|rc
init|=
name|drv
operator|->
name|init_hw_cmn_chip
argument_list|(
name|sc
argument_list|)
decl_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
return|return
name|ecore_func_init_port
argument_list|(
name|sc
argument_list|,
name|drv
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ecore_func_init_cmn - performs HW init at common stage  *  * @sc:		device handle  * @drv:  *  * Init HW when the current phase is  * FW_MSG_CODE_DRV_LOAD_COMMON_CHIP: initialize COMMON,  * PORT-only and FUNCTION-only HW blocks.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ecore_func_init_cmn
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|ecore_func_sp_drv_ops
modifier|*
name|drv
parameter_list|)
block|{
name|int
name|rc
init|=
name|drv
operator|->
name|init_hw_cmn
argument_list|(
name|sc
argument_list|)
decl_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
return|return
name|ecore_func_init_port
argument_list|(
name|sc
argument_list|,
name|drv
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ecore_func_hw_init
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_func_state_params
modifier|*
name|params
parameter_list|)
block|{
name|uint32_t
name|load_code
init|=
name|params
operator|->
name|params
operator|.
name|hw_init
operator|.
name|load_phase
decl_stmt|;
name|struct
name|ecore_func_sp_obj
modifier|*
name|o
init|=
name|params
operator|->
name|f_obj
decl_stmt|;
specifier|const
name|struct
name|ecore_func_sp_drv_ops
modifier|*
name|drv
init|=
name|o
operator|->
name|drv
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"function %d  load_code %x\n"
argument_list|,
name|ECORE_ABS_FUNC_ID
argument_list|(
name|sc
argument_list|)
argument_list|,
name|load_code
argument_list|)
expr_stmt|;
comment|/* Prepare buffers for unzipping the FW */
name|rc
operator|=
name|drv
operator|->
name|gunzip_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
comment|/* Prepare FW */
name|rc
operator|=
name|drv
operator|->
name|init_fw
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|ECORE_ERR
argument_list|(
literal|"Error loading firmware\n"
argument_list|)
expr_stmt|;
goto|goto
name|init_err
goto|;
block|}
comment|/* Handle the beginning of COMMON_XXX pases separately... */
switch|switch
condition|(
name|load_code
condition|)
block|{
case|case
name|FW_MSG_CODE_DRV_LOAD_COMMON_CHIP
case|:
name|rc
operator|=
name|ecore_func_init_cmn_chip
argument_list|(
name|sc
argument_list|,
name|drv
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|init_err
goto|;
break|break;
case|case
name|FW_MSG_CODE_DRV_LOAD_COMMON
case|:
name|rc
operator|=
name|ecore_func_init_cmn
argument_list|(
name|sc
argument_list|,
name|drv
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|init_err
goto|;
break|break;
case|case
name|FW_MSG_CODE_DRV_LOAD_PORT
case|:
name|rc
operator|=
name|ecore_func_init_port
argument_list|(
name|sc
argument_list|,
name|drv
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|init_err
goto|;
break|break;
case|case
name|FW_MSG_CODE_DRV_LOAD_FUNCTION
case|:
name|rc
operator|=
name|ecore_func_init_func
argument_list|(
name|sc
argument_list|,
name|drv
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|init_err
goto|;
break|break;
default|default:
name|ECORE_ERR
argument_list|(
literal|"Unknown load_code (0x%x) from MCP\n"
argument_list|,
name|load_code
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ECORE_INVAL
expr_stmt|;
block|}
name|init_err
label|:
name|drv
operator|->
name|gunzip_end
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* In case of success, complete the command immediately: no ramrods 	 * have been sent. 	 */
if|if
condition|(
operator|!
name|rc
condition|)
name|o
operator|->
name|complete_cmd
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
name|ECORE_F_CMD_HW_INIT
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/**  * ecore_func_reset_func - reset HW at function stage  *  * @sc:		device handle  * @drv:  *  * Reset HW at FW_MSG_CODE_DRV_UNLOAD_FUNCTION stage: reset only  * FUNCTION-only HW blocks.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ecore_func_reset_func
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|ecore_func_sp_drv_ops
modifier|*
name|drv
parameter_list|)
block|{
name|drv
operator|->
name|reset_hw_func
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ecore_func_reset_port - reser HW at port stage  *  * @sc:		device handle  * @drv:  *  * Reset HW at FW_MSG_CODE_DRV_UNLOAD_PORT stage: reset  * FUNCTION-only and PORT-only HW blocks.  *  *                 !!!IMPORTANT!!!  *  * It's important to call reset_port before reset_func() as the last thing  * reset_func does is pf_disable() thus disabling PGLUE_B, which  * makes impossible any DMAE transactions.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ecore_func_reset_port
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|ecore_func_sp_drv_ops
modifier|*
name|drv
parameter_list|)
block|{
name|drv
operator|->
name|reset_hw_port
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ecore_func_reset_func
argument_list|(
name|sc
argument_list|,
name|drv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ecore_func_reset_cmn - reser HW at common stage  *  * @sc:		device handle  * @drv:  *  * Reset HW at FW_MSG_CODE_DRV_UNLOAD_COMMON and  * FW_MSG_CODE_DRV_UNLOAD_COMMON_CHIP stages: reset COMMON,  * COMMON_CHIP, FUNCTION-only and PORT-only HW blocks.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ecore_func_reset_cmn
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|ecore_func_sp_drv_ops
modifier|*
name|drv
parameter_list|)
block|{
name|ecore_func_reset_port
argument_list|(
name|sc
argument_list|,
name|drv
argument_list|)
expr_stmt|;
name|drv
operator|->
name|reset_hw_cmn
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|ecore_func_hw_reset
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_func_state_params
modifier|*
name|params
parameter_list|)
block|{
name|uint32_t
name|reset_phase
init|=
name|params
operator|->
name|params
operator|.
name|hw_reset
operator|.
name|reset_phase
decl_stmt|;
name|struct
name|ecore_func_sp_obj
modifier|*
name|o
init|=
name|params
operator|->
name|f_obj
decl_stmt|;
specifier|const
name|struct
name|ecore_func_sp_drv_ops
modifier|*
name|drv
init|=
name|o
operator|->
name|drv
decl_stmt|;
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"function %d  reset_phase %x\n"
argument_list|,
name|ECORE_ABS_FUNC_ID
argument_list|(
name|sc
argument_list|)
argument_list|,
name|reset_phase
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|reset_phase
condition|)
block|{
case|case
name|FW_MSG_CODE_DRV_UNLOAD_COMMON
case|:
name|ecore_func_reset_cmn
argument_list|(
name|sc
argument_list|,
name|drv
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_MSG_CODE_DRV_UNLOAD_PORT
case|:
name|ecore_func_reset_port
argument_list|(
name|sc
argument_list|,
name|drv
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_MSG_CODE_DRV_UNLOAD_FUNCTION
case|:
name|ecore_func_reset_func
argument_list|(
name|sc
argument_list|,
name|drv
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ECORE_ERR
argument_list|(
literal|"Unknown reset_phase (0x%x) from MCP\n"
argument_list|,
name|reset_phase
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Complete the command immediately: no ramrods have been sent. */
name|o
operator|->
name|complete_cmd
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
name|ECORE_F_CMD_HW_RESET
argument_list|)
expr_stmt|;
return|return
name|ECORE_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|ecore_func_send_start
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_func_state_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ecore_func_sp_obj
modifier|*
name|o
init|=
name|params
operator|->
name|f_obj
decl_stmt|;
name|struct
name|function_start_data
modifier|*
name|rdata
init|=
operator|(
expr|struct
name|function_start_data
operator|*
operator|)
name|o
operator|->
name|rdata
decl_stmt|;
name|ecore_dma_addr_t
name|data_mapping
init|=
name|o
operator|->
name|rdata_mapping
decl_stmt|;
name|struct
name|ecore_func_start_params
modifier|*
name|start_params
init|=
operator|&
name|params
operator|->
name|params
operator|.
name|start
decl_stmt|;
name|ECORE_MEMSET
argument_list|(
name|rdata
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rdata
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fill the ramrod data with provided parameters */
name|rdata
operator|->
name|function_mode
operator|=
operator|(
name|uint8_t
operator|)
name|start_params
operator|->
name|mf_mode
expr_stmt|;
name|rdata
operator|->
name|sd_vlan_tag
operator|=
name|ECORE_CPU_TO_LE16
argument_list|(
name|start_params
operator|->
name|sd_vlan_tag
argument_list|)
expr_stmt|;
name|rdata
operator|->
name|path_id
operator|=
name|ECORE_PATH_ID
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rdata
operator|->
name|network_cos_mode
operator|=
name|start_params
operator|->
name|network_cos_mode
expr_stmt|;
name|rdata
operator|->
name|gre_tunnel_mode
operator|=
name|start_params
operator|->
name|gre_tunnel_mode
expr_stmt|;
name|rdata
operator|->
name|gre_tunnel_rss
operator|=
name|start_params
operator|->
name|gre_tunnel_rss
expr_stmt|;
comment|/* 	 *  No need for an explicit memory barrier here as long we would 	 *  need to ensure the ordering of writing to the SPQ element 	 *  and updating of the SPQ producer which involves a memory 	 *  read and we will have to put a full memory barrier there 	 *  (inside ecore_sp_post()). 	 */
return|return
name|ecore_sp_post
argument_list|(
name|sc
argument_list|,
name|RAMROD_CMD_ID_COMMON_FUNCTION_START
argument_list|,
literal|0
argument_list|,
name|data_mapping
argument_list|,
name|NONE_CONNECTION_TYPE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|ecore_func_send_switch_update
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_func_state_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ecore_func_sp_obj
modifier|*
name|o
init|=
name|params
operator|->
name|f_obj
decl_stmt|;
name|struct
name|function_update_data
modifier|*
name|rdata
init|=
operator|(
expr|struct
name|function_update_data
operator|*
operator|)
name|o
operator|->
name|rdata
decl_stmt|;
name|ecore_dma_addr_t
name|data_mapping
init|=
name|o
operator|->
name|rdata_mapping
decl_stmt|;
name|struct
name|ecore_func_switch_update_params
modifier|*
name|switch_update_params
init|=
operator|&
name|params
operator|->
name|params
operator|.
name|switch_update
decl_stmt|;
name|ECORE_MEMSET
argument_list|(
name|rdata
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rdata
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fill the ramrod data with provided parameters */
name|rdata
operator|->
name|tx_switch_suspend_change_flg
operator|=
literal|1
expr_stmt|;
name|rdata
operator|->
name|tx_switch_suspend
operator|=
name|switch_update_params
operator|->
name|suspend
expr_stmt|;
name|rdata
operator|->
name|echo
operator|=
name|SWITCH_UPDATE
expr_stmt|;
return|return
name|ecore_sp_post
argument_list|(
name|sc
argument_list|,
name|RAMROD_CMD_ID_COMMON_FUNCTION_UPDATE
argument_list|,
literal|0
argument_list|,
name|data_mapping
argument_list|,
name|NONE_CONNECTION_TYPE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|ecore_func_send_afex_update
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_func_state_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ecore_func_sp_obj
modifier|*
name|o
init|=
name|params
operator|->
name|f_obj
decl_stmt|;
name|struct
name|function_update_data
modifier|*
name|rdata
init|=
operator|(
expr|struct
name|function_update_data
operator|*
operator|)
name|o
operator|->
name|afex_rdata
decl_stmt|;
name|ecore_dma_addr_t
name|data_mapping
init|=
name|o
operator|->
name|afex_rdata_mapping
decl_stmt|;
name|struct
name|ecore_func_afex_update_params
modifier|*
name|afex_update_params
init|=
operator|&
name|params
operator|->
name|params
operator|.
name|afex_update
decl_stmt|;
name|ECORE_MEMSET
argument_list|(
name|rdata
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rdata
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fill the ramrod data with provided parameters */
name|rdata
operator|->
name|vif_id_change_flg
operator|=
literal|1
expr_stmt|;
name|rdata
operator|->
name|vif_id
operator|=
name|ECORE_CPU_TO_LE16
argument_list|(
name|afex_update_params
operator|->
name|vif_id
argument_list|)
expr_stmt|;
name|rdata
operator|->
name|afex_default_vlan_change_flg
operator|=
literal|1
expr_stmt|;
name|rdata
operator|->
name|afex_default_vlan
operator|=
name|ECORE_CPU_TO_LE16
argument_list|(
name|afex_update_params
operator|->
name|afex_default_vlan
argument_list|)
expr_stmt|;
name|rdata
operator|->
name|allowed_priorities_change_flg
operator|=
literal|1
expr_stmt|;
name|rdata
operator|->
name|allowed_priorities
operator|=
name|afex_update_params
operator|->
name|allowed_priorities
expr_stmt|;
name|rdata
operator|->
name|echo
operator|=
name|AFEX_UPDATE
expr_stmt|;
comment|/*  No need for an explicit memory barrier here as long we would 	 *  need to ensure the ordering of writing to the SPQ element 	 *  and updating of the SPQ producer which involves a memory 	 *  read and we will have to put a full memory barrier there 	 *  (inside ecore_sp_post()). 	 */
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"afex: sending func_update vif_id 0x%x dvlan 0x%x prio 0x%x\n"
argument_list|,
name|rdata
operator|->
name|vif_id
argument_list|,
name|rdata
operator|->
name|afex_default_vlan
argument_list|,
name|rdata
operator|->
name|allowed_priorities
argument_list|)
expr_stmt|;
return|return
name|ecore_sp_post
argument_list|(
name|sc
argument_list|,
name|RAMROD_CMD_ID_COMMON_FUNCTION_UPDATE
argument_list|,
literal|0
argument_list|,
name|data_mapping
argument_list|,
name|NONE_CONNECTION_TYPE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|ecore_func_send_afex_viflists
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_func_state_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ecore_func_sp_obj
modifier|*
name|o
init|=
name|params
operator|->
name|f_obj
decl_stmt|;
name|struct
name|afex_vif_list_ramrod_data
modifier|*
name|rdata
init|=
operator|(
expr|struct
name|afex_vif_list_ramrod_data
operator|*
operator|)
name|o
operator|->
name|afex_rdata
decl_stmt|;
name|struct
name|ecore_func_afex_viflists_params
modifier|*
name|afex_vif_params
init|=
operator|&
name|params
operator|->
name|params
operator|.
name|afex_viflists
decl_stmt|;
name|uint64_t
modifier|*
name|p_rdata
init|=
operator|(
name|uint64_t
operator|*
operator|)
name|rdata
decl_stmt|;
name|ECORE_MEMSET
argument_list|(
name|rdata
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rdata
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fill the ramrod data with provided parameters */
name|rdata
operator|->
name|vif_list_index
operator|=
name|ECORE_CPU_TO_LE16
argument_list|(
name|afex_vif_params
operator|->
name|vif_list_index
argument_list|)
expr_stmt|;
name|rdata
operator|->
name|func_bit_map
operator|=
name|afex_vif_params
operator|->
name|func_bit_map
expr_stmt|;
name|rdata
operator|->
name|afex_vif_list_command
operator|=
name|afex_vif_params
operator|->
name|afex_vif_list_command
expr_stmt|;
name|rdata
operator|->
name|func_to_clear
operator|=
name|afex_vif_params
operator|->
name|func_to_clear
expr_stmt|;
comment|/* send in echo type of sub command */
name|rdata
operator|->
name|echo
operator|=
name|afex_vif_params
operator|->
name|afex_vif_list_command
expr_stmt|;
comment|/*  No need for an explicit memory barrier here as long we would 	 *  need to ensure the ordering of writing to the SPQ element 	 *  and updating of the SPQ producer which involves a memory 	 *  read and we will have to put a full memory barrier there 	 *  (inside ecore_sp_post()). 	 */
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"afex: ramrod lists, cmd 0x%x index 0x%x func_bit_map 0x%x func_to_clr 0x%x\n"
argument_list|,
name|rdata
operator|->
name|afex_vif_list_command
argument_list|,
name|rdata
operator|->
name|vif_list_index
argument_list|,
name|rdata
operator|->
name|func_bit_map
argument_list|,
name|rdata
operator|->
name|func_to_clear
argument_list|)
expr_stmt|;
comment|/* this ramrod sends data directly and not through DMA mapping */
return|return
name|ecore_sp_post
argument_list|(
name|sc
argument_list|,
name|RAMROD_CMD_ID_COMMON_AFEX_VIF_LISTS
argument_list|,
literal|0
argument_list|,
operator|*
name|p_rdata
argument_list|,
name|NONE_CONNECTION_TYPE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|ecore_func_send_stop
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_func_state_params
modifier|*
name|params
parameter_list|)
block|{
return|return
name|ecore_sp_post
argument_list|(
name|sc
argument_list|,
name|RAMROD_CMD_ID_COMMON_FUNCTION_STOP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NONE_CONNECTION_TYPE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|ecore_func_send_tx_stop
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_func_state_params
modifier|*
name|params
parameter_list|)
block|{
return|return
name|ecore_sp_post
argument_list|(
name|sc
argument_list|,
name|RAMROD_CMD_ID_COMMON_STOP_TRAFFIC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NONE_CONNECTION_TYPE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|ecore_func_send_tx_start
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_func_state_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ecore_func_sp_obj
modifier|*
name|o
init|=
name|params
operator|->
name|f_obj
decl_stmt|;
name|struct
name|flow_control_configuration
modifier|*
name|rdata
init|=
operator|(
expr|struct
name|flow_control_configuration
operator|*
operator|)
name|o
operator|->
name|rdata
decl_stmt|;
name|ecore_dma_addr_t
name|data_mapping
init|=
name|o
operator|->
name|rdata_mapping
decl_stmt|;
name|struct
name|ecore_func_tx_start_params
modifier|*
name|tx_start_params
init|=
operator|&
name|params
operator|->
name|params
operator|.
name|tx_start
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ECORE_MEMSET
argument_list|(
name|rdata
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rdata
argument_list|)
argument_list|)
expr_stmt|;
name|rdata
operator|->
name|dcb_enabled
operator|=
name|tx_start_params
operator|->
name|dcb_enabled
expr_stmt|;
name|rdata
operator|->
name|dcb_version
operator|=
name|tx_start_params
operator|->
name|dcb_version
expr_stmt|;
name|rdata
operator|->
name|dont_add_pri_0
operator|=
name|tx_start_params
operator|->
name|dont_add_pri_0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|rdata
operator|->
name|traffic_type_to_priority_cos
argument_list|)
condition|;
name|i
operator|++
control|)
name|rdata
operator|->
name|traffic_type_to_priority_cos
index|[
name|i
index|]
operator|=
name|tx_start_params
operator|->
name|traffic_type_to_priority_cos
index|[
name|i
index|]
expr_stmt|;
return|return
name|ecore_sp_post
argument_list|(
name|sc
argument_list|,
name|RAMROD_CMD_ID_COMMON_START_TRAFFIC
argument_list|,
literal|0
argument_list|,
name|data_mapping
argument_list|,
name|NONE_CONNECTION_TYPE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ecore_func_send_cmd
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_func_state_params
modifier|*
name|params
parameter_list|)
block|{
switch|switch
condition|(
name|params
operator|->
name|cmd
condition|)
block|{
case|case
name|ECORE_F_CMD_HW_INIT
case|:
return|return
name|ecore_func_hw_init
argument_list|(
name|sc
argument_list|,
name|params
argument_list|)
return|;
case|case
name|ECORE_F_CMD_START
case|:
return|return
name|ecore_func_send_start
argument_list|(
name|sc
argument_list|,
name|params
argument_list|)
return|;
case|case
name|ECORE_F_CMD_STOP
case|:
return|return
name|ecore_func_send_stop
argument_list|(
name|sc
argument_list|,
name|params
argument_list|)
return|;
case|case
name|ECORE_F_CMD_HW_RESET
case|:
return|return
name|ecore_func_hw_reset
argument_list|(
name|sc
argument_list|,
name|params
argument_list|)
return|;
case|case
name|ECORE_F_CMD_AFEX_UPDATE
case|:
return|return
name|ecore_func_send_afex_update
argument_list|(
name|sc
argument_list|,
name|params
argument_list|)
return|;
case|case
name|ECORE_F_CMD_AFEX_VIFLISTS
case|:
return|return
name|ecore_func_send_afex_viflists
argument_list|(
name|sc
argument_list|,
name|params
argument_list|)
return|;
case|case
name|ECORE_F_CMD_TX_STOP
case|:
return|return
name|ecore_func_send_tx_stop
argument_list|(
name|sc
argument_list|,
name|params
argument_list|)
return|;
case|case
name|ECORE_F_CMD_TX_START
case|:
return|return
name|ecore_func_send_tx_start
argument_list|(
name|sc
argument_list|,
name|params
argument_list|)
return|;
case|case
name|ECORE_F_CMD_SWITCH_UPDATE
case|:
return|return
name|ecore_func_send_switch_update
argument_list|(
name|sc
argument_list|,
name|params
argument_list|)
return|;
default|default:
name|ECORE_ERR
argument_list|(
literal|"Unknown command: %d\n"
argument_list|,
name|params
operator|->
name|cmd
argument_list|)
expr_stmt|;
return|return
name|ECORE_INVAL
return|;
block|}
block|}
end_function

begin_function
name|void
name|ecore_init_func_obj
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_func_sp_obj
modifier|*
name|obj
parameter_list|,
name|void
modifier|*
name|rdata
parameter_list|,
name|ecore_dma_addr_t
name|rdata_mapping
parameter_list|,
name|void
modifier|*
name|afex_rdata
parameter_list|,
name|ecore_dma_addr_t
name|afex_rdata_mapping
parameter_list|,
name|struct
name|ecore_func_sp_drv_ops
modifier|*
name|drv_iface
parameter_list|)
block|{
name|ECORE_MEMSET
argument_list|(
name|obj
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|ECORE_MUTEX_INIT
argument_list|(
operator|&
name|obj
operator|->
name|one_pending_mutex
argument_list|)
expr_stmt|;
name|obj
operator|->
name|rdata
operator|=
name|rdata
expr_stmt|;
name|obj
operator|->
name|rdata_mapping
operator|=
name|rdata_mapping
expr_stmt|;
name|obj
operator|->
name|afex_rdata
operator|=
name|afex_rdata
expr_stmt|;
name|obj
operator|->
name|afex_rdata_mapping
operator|=
name|afex_rdata_mapping
expr_stmt|;
name|obj
operator|->
name|send_cmd
operator|=
name|ecore_func_send_cmd
expr_stmt|;
name|obj
operator|->
name|check_transition
operator|=
name|ecore_func_chk_transition
expr_stmt|;
name|obj
operator|->
name|complete_cmd
operator|=
name|ecore_func_comp_cmd
expr_stmt|;
name|obj
operator|->
name|wait_comp
operator|=
name|ecore_func_wait_comp
expr_stmt|;
name|obj
operator|->
name|drv
operator|=
name|drv_iface
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ecore_func_state_change - perform Function state change transition  *  * @sc:		device handle  * @params:	parameters to perform the transaction  *  * returns 0 in case of successfully completed transition,  *         negative error code in case of failure, positive  *         (EBUSY) value if there is a completion to that is  *         still pending (possible only if RAMROD_COMP_WAIT is  *         not set in params->ramrod_flags for asynchronous  *         commands).  */
end_comment

begin_function
name|int
name|ecore_func_state_change
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_func_state_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ecore_func_sp_obj
modifier|*
name|o
init|=
name|params
operator|->
name|f_obj
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|cnt
init|=
literal|300
decl_stmt|;
name|enum
name|ecore_func_cmd
name|cmd
init|=
name|params
operator|->
name|cmd
decl_stmt|;
name|unsigned
name|long
modifier|*
name|pending
init|=
operator|&
name|o
operator|->
name|pending
decl_stmt|;
name|ECORE_MUTEX_LOCK
argument_list|(
operator|&
name|o
operator|->
name|one_pending_mutex
argument_list|)
expr_stmt|;
comment|/* Check that the requested transition is legal */
name|rc
operator|=
name|o
operator|->
name|check_transition
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|==
name|ECORE_BUSY
operator|)
operator|&&
operator|(
name|ECORE_TEST_BIT
argument_list|(
name|RAMROD_RETRY
argument_list|,
operator|&
name|params
operator|->
name|ramrod_flags
argument_list|)
operator|)
condition|)
block|{
while|while
condition|(
operator|(
name|rc
operator|==
name|ECORE_BUSY
operator|)
operator|&&
operator|(
operator|--
name|cnt
operator|>
literal|0
operator|)
condition|)
block|{
name|ECORE_MUTEX_UNLOCK
argument_list|(
operator|&
name|o
operator|->
name|one_pending_mutex
argument_list|)
expr_stmt|;
name|ECORE_MSLEEP
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|ECORE_MUTEX_LOCK
argument_list|(
operator|&
name|o
operator|->
name|one_pending_mutex
argument_list|)
expr_stmt|;
name|rc
operator|=
name|o
operator|->
name|check_transition
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
name|params
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|==
name|ECORE_BUSY
condition|)
block|{
name|ECORE_MUTEX_UNLOCK
argument_list|(
operator|&
name|o
operator|->
name|one_pending_mutex
argument_list|)
expr_stmt|;
name|ECORE_ERR
argument_list|(
literal|"timeout waiting for previous ramrod completion\n"
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|rc
condition|)
block|{
name|ECORE_MUTEX_UNLOCK
argument_list|(
operator|&
name|o
operator|->
name|one_pending_mutex
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
comment|/* Set "pending" bit */
name|ECORE_SET_BIT
argument_list|(
name|cmd
argument_list|,
name|pending
argument_list|)
expr_stmt|;
comment|/* Don't send a command if only driver cleanup was requested */
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|RAMROD_DRV_CLR_ONLY
argument_list|,
operator|&
name|params
operator|->
name|ramrod_flags
argument_list|)
condition|)
block|{
name|ecore_func_state_change_comp
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|ECORE_MUTEX_UNLOCK
argument_list|(
operator|&
name|o
operator|->
name|one_pending_mutex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Send a ramrod */
name|rc
operator|=
name|o
operator|->
name|send_cmd
argument_list|(
name|sc
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|ECORE_MUTEX_UNLOCK
argument_list|(
operator|&
name|o
operator|->
name|one_pending_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|o
operator|->
name|next_state
operator|=
name|ECORE_F_STATE_MAX
expr_stmt|;
name|ECORE_CLEAR_BIT
argument_list|(
name|cmd
argument_list|,
name|pending
argument_list|)
expr_stmt|;
name|ECORE_SMP_MB_AFTER_CLEAR_BIT
argument_list|()
expr_stmt|;
return|return
name|rc
return|;
block|}
if|if
condition|(
name|ECORE_TEST_BIT
argument_list|(
name|RAMROD_COMP_WAIT
argument_list|,
operator|&
name|params
operator|->
name|ramrod_flags
argument_list|)
condition|)
block|{
name|rc
operator|=
name|o
operator|->
name|wait_comp
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
name|rc
return|;
return|return
name|ECORE_SUCCESS
return|;
block|}
block|}
return|return
name|ECORE_RET_PENDING
argument_list|(
name|cmd
argument_list|,
name|pending
argument_list|)
return|;
block|}
end_function

end_unit

