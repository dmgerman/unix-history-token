begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2007-2013 Broadcom Corporation. All rights reserved.  *  * Eric Davis<edavis@broadcom.com>  * David Christensen<davidch@broadcom.com>  * Gary Zambrano<zambrano@broadcom.com>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of Broadcom Corporation nor the name of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written consent.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS'  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|ECORE_INIT_OPS_H
end_ifndef

begin_define
define|#
directive|define
name|ECORE_INIT_OPS_H
end_define

begin_function_decl
specifier|static
name|int
name|ecore_gunzip
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|zbuf
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ecore_reg_wr_ind
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ecore_write_dmae_phys_len
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|ecore_dma_addr_t
name|phys_addr
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|ecore_init_str_wr
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
specifier|const
name|uint32_t
modifier|*
name|data
parameter_list|,
name|uint32_t
name|len
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|addr
operator|+
name|i
operator|*
literal|4
argument_list|,
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_init_ind_wr
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
specifier|const
name|uint32_t
modifier|*
name|data
parameter_list|,
name|uint32_t
name|len
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|ecore_reg_wr_ind
argument_list|(
name|sc
argument_list|,
name|addr
operator|+
name|i
operator|*
literal|4
argument_list|,
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_write_big_buf
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|len
parameter_list|,
name|uint8_t
name|wb
parameter_list|)
block|{
if|if
condition|(
name|DMAE_READY
argument_list|(
name|sc
argument_list|)
condition|)
name|ecore_write_dmae_phys_len
argument_list|(
name|sc
argument_list|,
name|GUNZIP_PHYS
argument_list|(
name|sc
argument_list|)
argument_list|,
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* in E1 chips BIOS initiated ZLR may interrupt widebus writes */
elseif|else
if|if
condition|(
name|wb
operator|&&
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
name|ecore_init_ind_wr
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|GUNZIP_BUF
argument_list|(
name|sc
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* in later chips PXP root complex handles BIOS ZLR w/o interrupting */
else|else
name|ecore_init_str_wr
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|GUNZIP_BUF
argument_list|(
name|sc
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_init_fill
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|int
name|fill
parameter_list|,
name|uint32_t
name|len
parameter_list|,
name|uint8_t
name|wb
parameter_list|)
block|{
name|uint32_t
name|buf_len
init|=
operator|(
operator|(
operator|(
name|len
operator|*
literal|4
operator|)
operator|>
name|FW_BUF_SIZE
operator|)
condition|?
name|FW_BUF_SIZE
else|:
operator|(
name|len
operator|*
literal|4
operator|)
operator|)
decl_stmt|;
name|uint32_t
name|buf_len32
init|=
name|buf_len
operator|/
literal|4
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|ECORE_MEMSET
argument_list|(
name|GUNZIP_BUF
argument_list|(
name|sc
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|)
name|fill
argument_list|,
name|buf_len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
name|buf_len32
control|)
block|{
name|uint32_t
name|cur_len
init|=
name|min
argument_list|(
name|buf_len32
argument_list|,
name|len
operator|-
name|i
argument_list|)
decl_stmt|;
name|ecore_write_big_buf
argument_list|(
name|sc
argument_list|,
name|addr
operator|+
name|i
operator|*
literal|4
argument_list|,
name|cur_len
argument_list|,
name|wb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_write_big_buf_wb
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|DMAE_READY
argument_list|(
name|sc
argument_list|)
condition|)
name|ecore_write_dmae_phys_len
argument_list|(
name|sc
argument_list|,
name|GUNZIP_PHYS
argument_list|(
name|sc
argument_list|)
argument_list|,
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* in E1 chips BIOS initiated ZLR may interrupt widebus writes */
elseif|else
if|if
condition|(
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
name|ecore_init_ind_wr
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|GUNZIP_BUF
argument_list|(
name|sc
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* in later chips PXP root complex handles BIOS ZLR w/o interrupting */
else|else
name|ecore_init_str_wr
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|GUNZIP_BUF
argument_list|(
name|sc
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_init_wr_64
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
specifier|const
name|uint32_t
modifier|*
name|data
parameter_list|,
name|uint32_t
name|len64
parameter_list|)
block|{
name|uint32_t
name|buf_len32
init|=
name|FW_BUF_SIZE
operator|/
literal|4
decl_stmt|;
name|uint32_t
name|len
init|=
name|len64
operator|*
literal|2
decl_stmt|;
name|uint64_t
name|data64
init|=
literal|0
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
comment|/* 64 bit value is in a blob: first low DWORD, then high DWORD */
name|data64
operator|=
name|HILO_U64
argument_list|(
operator|(
operator|*
operator|(
name|data
operator|+
literal|1
operator|)
operator|)
argument_list|,
operator|(
operator|*
name|data
operator|)
argument_list|)
expr_stmt|;
name|len64
operator|=
name|min
argument_list|(
call|(
name|uint32_t
call|)
argument_list|(
name|FW_BUF_SIZE
operator|/
literal|8
argument_list|)
argument_list|,
name|len64
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len64
condition|;
name|i
operator|++
control|)
block|{
name|uint64_t
modifier|*
name|pdata
init|=
operator|(
operator|(
name|uint64_t
operator|*
operator|)
operator|(
name|GUNZIP_BUF
argument_list|(
name|sc
argument_list|)
operator|)
operator|)
operator|+
name|i
decl_stmt|;
operator|*
name|pdata
operator|=
name|data64
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
name|buf_len32
control|)
block|{
name|uint32_t
name|cur_len
init|=
name|min
argument_list|(
name|buf_len32
argument_list|,
name|len
operator|-
name|i
argument_list|)
decl_stmt|;
name|ecore_write_big_buf_wb
argument_list|(
name|sc
argument_list|,
name|addr
operator|+
name|i
operator|*
literal|4
argument_list|,
name|cur_len
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*********************************************************    There are different blobs for each PRAM section.    In addition, each blob write operation is divided into a few operations    in order to decrease the amount of phys. contiguous buffer needed.    Thus, when we select a blob the address may be with some offset    from the beginning of PRAM section.    The same holds for the INT_TABLE sections. **********************************************************/
end_comment

begin_define
define|#
directive|define
name|IF_IS_INT_TABLE_ADDR
parameter_list|(
name|base
parameter_list|,
name|addr
parameter_list|)
define|\
value|if (((base)<= (addr))&& ((base) + 0x400>= (addr)))
end_define

begin_define
define|#
directive|define
name|IF_IS_PRAM_ADDR
parameter_list|(
name|base
parameter_list|,
name|addr
parameter_list|)
define|\
value|if (((base)<= (addr))&& ((base) + 0x40000>= (addr)))
end_define

begin_function
specifier|static
specifier|const
name|uint8_t
modifier|*
name|ecore_sel_blob
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|data
parameter_list|)
block|{
name|IF_IS_INT_TABLE_ADDR
argument_list|(
argument|TSEM_REG_INT_TABLE
argument_list|,
argument|addr
argument_list|)
name|data
operator|=
name|INIT_TSEM_INT_TABLE_DATA
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|IF_IS_INT_TABLE_ADDR
argument_list|(
argument|CSEM_REG_INT_TABLE
argument_list|,
argument|addr
argument_list|)
name|data
operator|=
name|INIT_CSEM_INT_TABLE_DATA
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|IF_IS_INT_TABLE_ADDR
argument_list|(
argument|USEM_REG_INT_TABLE
argument_list|,
argument|addr
argument_list|)
name|data
operator|=
name|INIT_USEM_INT_TABLE_DATA
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|IF_IS_INT_TABLE_ADDR
argument_list|(
argument|XSEM_REG_INT_TABLE
argument_list|,
argument|addr
argument_list|)
name|data
operator|=
name|INIT_XSEM_INT_TABLE_DATA
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|IF_IS_PRAM_ADDR
argument_list|(
argument|TSEM_REG_PRAM
argument_list|,
argument|addr
argument_list|)
name|data
operator|=
name|INIT_TSEM_PRAM_DATA
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|IF_IS_PRAM_ADDR
argument_list|(
argument|CSEM_REG_PRAM
argument_list|,
argument|addr
argument_list|)
name|data
operator|=
name|INIT_CSEM_PRAM_DATA
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|IF_IS_PRAM_ADDR
argument_list|(
argument|USEM_REG_PRAM
argument_list|,
argument|addr
argument_list|)
name|data
operator|=
name|INIT_USEM_PRAM_DATA
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|IF_IS_PRAM_ADDR
argument_list|(
argument|XSEM_REG_PRAM
argument_list|,
argument|addr
argument_list|)
name|data
operator|=
name|INIT_XSEM_PRAM_DATA
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_init_wr_wb
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
specifier|const
name|uint32_t
modifier|*
name|data
parameter_list|,
name|uint32_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|DMAE_READY
argument_list|(
name|sc
argument_list|)
condition|)
name|VIRT_WR_DMAE_LEN
argument_list|(
name|sc
argument_list|,
name|data
argument_list|,
name|addr
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* in E1 chips BIOS initiated ZLR may interrupt widebus writes */
elseif|else
if|if
condition|(
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
name|ecore_init_ind_wr
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* in later chips PXP root complex handles BIOS ZLR w/o interrupting */
else|else
name|ecore_init_str_wr
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|FW_ZIP_SUPPORT
end_ifndef

begin_function
specifier|static
name|void
name|ecore_init_fw
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|len
parameter_list|)
block|{
specifier|const
name|uint8_t
modifier|*
name|data
init|=
name|NULL
decl_stmt|;
name|data
operator|=
name|ecore_sel_blob
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|DMAE_READY
argument_list|(
name|sc
argument_list|)
condition|)
name|VIRT_WR_DMAE_LEN
argument_list|(
name|sc
argument_list|,
name|data
argument_list|,
name|addr
argument_list|,
name|len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* in E1 BIOS initiated ZLR may interrupt widebus writes */
elseif|else
if|if
condition|(
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
name|ecore_init_ind_wr
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* in later chips PXP root complex handles BIOS ZLR w/o interrupting */
else|else
name|ecore_init_str_wr
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|ecore_wr_64
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|reg
parameter_list|,
name|uint32_t
name|val_lo
parameter_list|,
name|uint32_t
name|val_hi
parameter_list|)
block|{
name|uint32_t
name|wb_write
index|[
literal|2
index|]
decl_stmt|;
name|wb_write
index|[
literal|0
index|]
operator|=
name|val_lo
expr_stmt|;
name|wb_write
index|[
literal|1
index|]
operator|=
name|val_hi
expr_stmt|;
name|REG_WR_DMAE_LEN
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
name|wb_write
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_init_wr_zp
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|len
parameter_list|,
name|uint32_t
name|blob_off
parameter_list|)
block|{
specifier|const
name|uint8_t
modifier|*
name|data
init|=
name|NULL
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|data
operator|=
name|ecore_sel_blob
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|data
argument_list|)
operator|+
name|blob_off
operator|*
literal|4
expr_stmt|;
name|rc
operator|=
name|ecore_gunzip
argument_list|(
name|sc
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return;
comment|/* gunzip_outlen is in dwords */
name|len
operator|=
name|GUNZIP_OUTLEN
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|GUNZIP_BUF
argument_list|(
name|sc
argument_list|)
operator|)
index|[
name|i
index|]
operator|=
operator|(
name|uint32_t
operator|)
name|ECORE_CPU_TO_LE32
argument_list|(
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|GUNZIP_BUF
argument_list|(
name|sc
argument_list|)
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ecore_write_big_buf_wb
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_init_block
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|block
parameter_list|,
name|uint32_t
name|stage
parameter_list|)
block|{
name|uint16_t
name|op_start
init|=
name|INIT_OPS_OFFSETS
argument_list|(
name|sc
argument_list|)
index|[
name|BLOCK_OPS_IDX
argument_list|(
name|block
argument_list|,
name|stage
argument_list|,
name|STAGE_START
argument_list|)
index|]
decl_stmt|;
name|uint16_t
name|op_end
init|=
name|INIT_OPS_OFFSETS
argument_list|(
name|sc
argument_list|)
index|[
name|BLOCK_OPS_IDX
argument_list|(
name|block
argument_list|,
name|stage
argument_list|,
name|STAGE_END
argument_list|)
index|]
decl_stmt|;
specifier|const
name|union
name|init_op
modifier|*
name|op
decl_stmt|;
name|uint32_t
name|op_idx
decl_stmt|,
name|op_type
decl_stmt|,
name|addr
decl_stmt|,
name|len
decl_stmt|;
specifier|const
name|uint32_t
modifier|*
name|data
decl_stmt|,
modifier|*
name|data_base
decl_stmt|;
comment|/* If empty block */
if|if
condition|(
name|op_start
operator|==
name|op_end
condition|)
return|return;
name|data_base
operator|=
name|INIT_DATA
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|op_idx
operator|=
name|op_start
init|;
name|op_idx
operator|<
name|op_end
condition|;
name|op_idx
operator|++
control|)
block|{
name|op
operator|=
operator|(
specifier|const
expr|union
name|init_op
operator|*
operator|)
operator|&
operator|(
name|INIT_OPS
argument_list|(
name|sc
argument_list|)
index|[
name|op_idx
index|]
operator|)
expr_stmt|;
comment|/* Get generic data */
name|op_type
operator|=
name|op
operator|->
name|raw
operator|.
name|op
expr_stmt|;
name|addr
operator|=
name|op
operator|->
name|raw
operator|.
name|offset
expr_stmt|;
comment|/* Get data that's used for OP_SW, OP_WB, OP_FW, OP_ZP and 		 * OP_WR64 (we assume that op_arr_write and op_write have the 		 * same structure). 		 */
name|len
operator|=
name|op
operator|->
name|arr_wr
operator|.
name|data_len
expr_stmt|;
name|data
operator|=
name|data_base
operator|+
name|op
operator|->
name|arr_wr
operator|.
name|data_off
expr_stmt|;
switch|switch
condition|(
name|op_type
condition|)
block|{
case|case
name|OP_RD
case|:
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_WR
case|:
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|op
operator|->
name|write
operator|.
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_SW
case|:
name|ecore_init_str_wr
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_WB
case|:
name|ecore_init_wr_wb
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|FW_ZIP_SUPPORT
case|case
name|OP_FW
case|:
name|ecore_init_fw
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|OP_ZR
case|:
name|ecore_init_fill
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|,
name|op
operator|->
name|zero
operator|.
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_WB_ZR
case|:
name|ecore_init_fill
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|,
name|op
operator|->
name|zero
operator|.
name|len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_ZP
case|:
name|ecore_init_wr_zp
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|len
argument_list|,
name|op
operator|->
name|arr_wr
operator|.
name|data_off
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_WR_64
case|:
name|ecore_init_wr_64
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_IF_MODE_AND
case|:
comment|/* if any of the flags doesn't match, skip the 			 * conditional block. 			 */
if|if
condition|(
operator|(
name|INIT_MODE_FLAGS
argument_list|(
name|sc
argument_list|)
operator|&
name|op
operator|->
name|if_mode
operator|.
name|mode_bit_map
operator|)
operator|!=
name|op
operator|->
name|if_mode
operator|.
name|mode_bit_map
condition|)
name|op_idx
operator|+=
name|op
operator|->
name|if_mode
operator|.
name|cmd_offset
expr_stmt|;
break|break;
case|case
name|OP_IF_MODE_OR
case|:
comment|/* if all the flags don't match, skip the conditional 			 * block. 			 */
if|if
condition|(
operator|(
name|INIT_MODE_FLAGS
argument_list|(
name|sc
argument_list|)
operator|&
name|op
operator|->
name|if_mode
operator|.
name|mode_bit_map
operator|)
operator|==
literal|0
condition|)
name|op_idx
operator|+=
name|op
operator|->
name|if_mode
operator|.
name|cmd_offset
expr_stmt|;
break|break;
comment|/* the following opcodes are unused at the moment. */
case|case
name|OP_IF_PHASE
case|:
case|case
name|OP_RT
case|:
case|case
name|OP_DELAY
case|:
case|case
name|OP_VERIFY
case|:
default|default:
comment|/* Should never get here! */
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/**************************************************************************** * PXP Arbiter ****************************************************************************/
end_comment

begin_comment
comment|/*  * This code configures the PCI read/write arbiter  * which implements a weighted round robin  * between the virtual queues in the chip.  *  * The values were derived for each PCI max payload and max request size.  * since max payload and max request size are only known at run time,  * this is done as a separate init stage.  */
end_comment

begin_define
define|#
directive|define
name|NUM_WR_Q
value|13
end_define

begin_define
define|#
directive|define
name|NUM_RD_Q
value|29
end_define

begin_define
define|#
directive|define
name|MAX_RD_ORD
value|3
end_define

begin_define
define|#
directive|define
name|MAX_WR_ORD
value|2
end_define

begin_comment
comment|/* configuration for one arbiter queue */
end_comment

begin_struct
struct|struct
name|arb_line
block|{
name|int
name|l
decl_stmt|;
name|int
name|add
decl_stmt|;
name|int
name|ubound
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* derived configuration for each read queue for each max request size */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|arb_line
name|read_arb_data
index|[
name|NUM_RD_Q
index|]
index|[
name|MAX_RD_ORD
operator|+
literal|1
index|]
init|=
block|{
comment|/* 1 */
block|{
block|{
literal|8
block|,
literal|64
block|,
literal|25
block|}
block|,
block|{
literal|16
block|,
literal|64
block|,
literal|25
block|}
block|,
block|{
literal|32
block|,
literal|64
block|,
literal|25
block|}
block|,
block|{
literal|64
block|,
literal|64
block|,
literal|41
block|}
block|}
block|,
block|{
block|{
literal|4
block|,
literal|8
block|,
literal|4
block|}
block|,
block|{
literal|4
block|,
literal|8
block|,
literal|4
block|}
block|,
block|{
literal|4
block|,
literal|8
block|,
literal|4
block|}
block|,
block|{
literal|4
block|,
literal|8
block|,
literal|4
block|}
block|}
block|,
block|{
block|{
literal|4
block|,
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|4
block|,
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|4
block|,
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|4
block|,
literal|3
block|,
literal|3
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|64
block|,
literal|25
block|}
block|,
block|{
literal|16
block|,
literal|64
block|,
literal|25
block|}
block|,
block|{
literal|32
block|,
literal|64
block|,
literal|25
block|}
block|,
block|{
literal|64
block|,
literal|64
block|,
literal|41
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|64
block|,
literal|3
block|,
literal|41
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|64
block|,
literal|3
block|,
literal|41
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|64
block|,
literal|3
block|,
literal|41
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|64
block|,
literal|3
block|,
literal|41
block|}
block|}
block|,
comment|/* 10 */
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|64
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|64
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|64
block|,
literal|21
block|}
block|,
block|{
literal|32
block|,
literal|64
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|}
block|,
comment|/* 20 */
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|,
block|{
literal|32
block|,
literal|3
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|64
block|,
literal|25
block|}
block|,
block|{
literal|16
block|,
literal|64
block|,
literal|41
block|}
block|,
block|{
literal|32
block|,
literal|64
block|,
literal|81
block|}
block|,
block|{
literal|64
block|,
literal|64
block|,
literal|120
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* derived configuration for each write queue for each max request size */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|arb_line
name|write_arb_data
index|[
name|NUM_WR_Q
index|]
index|[
name|MAX_WR_ORD
operator|+
literal|1
index|]
init|=
block|{
comment|/* 1 */
block|{
block|{
literal|4
block|,
literal|6
block|,
literal|3
block|}
block|,
block|{
literal|4
block|,
literal|6
block|,
literal|3
block|}
block|,
block|{
literal|4
block|,
literal|6
block|,
literal|3
block|}
block|}
block|,
block|{
block|{
literal|4
block|,
literal|2
block|,
literal|3
block|}
block|,
block|{
literal|4
block|,
literal|2
block|,
literal|3
block|}
block|,
block|{
literal|4
block|,
literal|2
block|,
literal|3
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|2
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|2
block|,
literal|11
block|}
block|,
block|{
literal|16
block|,
literal|2
block|,
literal|11
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|2
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|2
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|2
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|2
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|2
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|2
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|2
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|2
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|2
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|64
block|,
literal|25
block|}
block|,
block|{
literal|16
block|,
literal|64
block|,
literal|25
block|}
block|,
block|{
literal|32
block|,
literal|64
block|,
literal|25
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|2
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|2
block|,
literal|11
block|}
block|,
block|{
literal|16
block|,
literal|2
block|,
literal|11
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|2
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|2
block|,
literal|11
block|}
block|,
block|{
literal|16
block|,
literal|2
block|,
literal|11
block|}
block|}
block|,
comment|/* 10 */
block|{
block|{
literal|8
block|,
literal|9
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|9
block|,
literal|11
block|}
block|,
block|{
literal|32
block|,
literal|9
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|47
block|,
literal|19
block|}
block|,
block|{
literal|16
block|,
literal|47
block|,
literal|19
block|}
block|,
block|{
literal|32
block|,
literal|47
block|,
literal|21
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|9
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|9
block|,
literal|11
block|}
block|,
block|{
literal|16
block|,
literal|9
block|,
literal|11
block|}
block|}
block|,
block|{
block|{
literal|8
block|,
literal|64
block|,
literal|25
block|}
block|,
block|{
literal|16
block|,
literal|64
block|,
literal|41
block|}
block|,
block|{
literal|32
block|,
literal|64
block|,
literal|81
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* register addresses for read queues */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|arb_line
name|read_arb_addr
index|[
name|NUM_RD_Q
operator|-
literal|1
index|]
init|=
block|{
comment|/* 1 */
block|{
name|PXP2_REG_RQ_BW_RD_L0
block|,
name|PXP2_REG_RQ_BW_RD_ADD0
block|,
name|PXP2_REG_RQ_BW_RD_UBOUND0
block|}
block|,
block|{
name|PXP2_REG_PSWRQ_BW_L1
block|,
name|PXP2_REG_PSWRQ_BW_ADD1
block|,
name|PXP2_REG_PSWRQ_BW_UB1
block|}
block|,
block|{
name|PXP2_REG_PSWRQ_BW_L2
block|,
name|PXP2_REG_PSWRQ_BW_ADD2
block|,
name|PXP2_REG_PSWRQ_BW_UB2
block|}
block|,
block|{
name|PXP2_REG_PSWRQ_BW_L3
block|,
name|PXP2_REG_PSWRQ_BW_ADD3
block|,
name|PXP2_REG_PSWRQ_BW_UB3
block|}
block|,
block|{
name|PXP2_REG_RQ_BW_RD_L4
block|,
name|PXP2_REG_RQ_BW_RD_ADD4
block|,
name|PXP2_REG_RQ_BW_RD_UBOUND4
block|}
block|,
block|{
name|PXP2_REG_RQ_BW_RD_L5
block|,
name|PXP2_REG_RQ_BW_RD_ADD5
block|,
name|PXP2_REG_RQ_BW_RD_UBOUND5
block|}
block|,
block|{
name|PXP2_REG_PSWRQ_BW_L6
block|,
name|PXP2_REG_PSWRQ_BW_ADD6
block|,
name|PXP2_REG_PSWRQ_BW_UB6
block|}
block|,
block|{
name|PXP2_REG_PSWRQ_BW_L7
block|,
name|PXP2_REG_PSWRQ_BW_ADD7
block|,
name|PXP2_REG_PSWRQ_BW_UB7
block|}
block|,
block|{
name|PXP2_REG_PSWRQ_BW_L8
block|,
name|PXP2_REG_PSWRQ_BW_ADD8
block|,
name|PXP2_REG_PSWRQ_BW_UB8
block|}
block|,
comment|/* 10 */
block|{
name|PXP2_REG_PSWRQ_BW_L9
block|,
name|PXP2_REG_PSWRQ_BW_ADD9
block|,
name|PXP2_REG_PSWRQ_BW_UB9
block|}
block|,
block|{
name|PXP2_REG_PSWRQ_BW_L10
block|,
name|PXP2_REG_PSWRQ_BW_ADD10
block|,
name|PXP2_REG_PSWRQ_BW_UB10
block|}
block|,
block|{
name|PXP2_REG_PSWRQ_BW_L11
block|,
name|PXP2_REG_PSWRQ_BW_ADD11
block|,
name|PXP2_REG_PSWRQ_BW_UB11
block|}
block|,
block|{
name|PXP2_REG_RQ_BW_RD_L12
block|,
name|PXP2_REG_RQ_BW_RD_ADD12
block|,
name|PXP2_REG_RQ_BW_RD_UBOUND12
block|}
block|,
block|{
name|PXP2_REG_RQ_BW_RD_L13
block|,
name|PXP2_REG_RQ_BW_RD_ADD13
block|,
name|PXP2_REG_RQ_BW_RD_UBOUND13
block|}
block|,
block|{
name|PXP2_REG_RQ_BW_RD_L14
block|,
name|PXP2_REG_RQ_BW_RD_ADD14
block|,
name|PXP2_REG_RQ_BW_RD_UBOUND14
block|}
block|,
block|{
name|PXP2_REG_RQ_BW_RD_L15
block|,
name|PXP2_REG_RQ_BW_RD_ADD15
block|,
name|PXP2_REG_RQ_BW_RD_UBOUND15
block|}
block|,
block|{
name|PXP2_REG_RQ_BW_RD_L16
block|,
name|PXP2_REG_RQ_BW_RD_ADD16
block|,
name|PXP2_REG_RQ_BW_RD_UBOUND16
block|}
block|,
block|{
name|PXP2_REG_RQ_BW_RD_L17
block|,
name|PXP2_REG_RQ_BW_RD_ADD17
block|,
name|PXP2_REG_RQ_BW_RD_UBOUND17
block|}
block|,
block|{
name|PXP2_REG_RQ_BW_RD_L18
block|,
name|PXP2_REG_RQ_BW_RD_ADD18
block|,
name|PXP2_REG_RQ_BW_RD_UBOUND18
block|}
block|,
comment|/* 20 */
block|{
name|PXP2_REG_RQ_BW_RD_L19
block|,
name|PXP2_REG_RQ_BW_RD_ADD19
block|,
name|PXP2_REG_RQ_BW_RD_UBOUND19
block|}
block|,
block|{
name|PXP2_REG_RQ_BW_RD_L20
block|,
name|PXP2_REG_RQ_BW_RD_ADD20
block|,
name|PXP2_REG_RQ_BW_RD_UBOUND20
block|}
block|,
block|{
name|PXP2_REG_RQ_BW_RD_L22
block|,
name|PXP2_REG_RQ_BW_RD_ADD22
block|,
name|PXP2_REG_RQ_BW_RD_UBOUND22
block|}
block|,
block|{
name|PXP2_REG_RQ_BW_RD_L23
block|,
name|PXP2_REG_RQ_BW_RD_ADD23
block|,
name|PXP2_REG_RQ_BW_RD_UBOUND23
block|}
block|,
block|{
name|PXP2_REG_RQ_BW_RD_L24
block|,
name|PXP2_REG_RQ_BW_RD_ADD24
block|,
name|PXP2_REG_RQ_BW_RD_UBOUND24
block|}
block|,
block|{
name|PXP2_REG_RQ_BW_RD_L25
block|,
name|PXP2_REG_RQ_BW_RD_ADD25
block|,
name|PXP2_REG_RQ_BW_RD_UBOUND25
block|}
block|,
block|{
name|PXP2_REG_RQ_BW_RD_L26
block|,
name|PXP2_REG_RQ_BW_RD_ADD26
block|,
name|PXP2_REG_RQ_BW_RD_UBOUND26
block|}
block|,
block|{
name|PXP2_REG_RQ_BW_RD_L27
block|,
name|PXP2_REG_RQ_BW_RD_ADD27
block|,
name|PXP2_REG_RQ_BW_RD_UBOUND27
block|}
block|,
block|{
name|PXP2_REG_PSWRQ_BW_L28
block|,
name|PXP2_REG_PSWRQ_BW_ADD28
block|,
name|PXP2_REG_PSWRQ_BW_UB28
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* register addresses for write queues */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|arb_line
name|write_arb_addr
index|[
name|NUM_WR_Q
operator|-
literal|1
index|]
init|=
block|{
comment|/* 1 */
block|{
name|PXP2_REG_PSWRQ_BW_L1
block|,
name|PXP2_REG_PSWRQ_BW_ADD1
block|,
name|PXP2_REG_PSWRQ_BW_UB1
block|}
block|,
block|{
name|PXP2_REG_PSWRQ_BW_L2
block|,
name|PXP2_REG_PSWRQ_BW_ADD2
block|,
name|PXP2_REG_PSWRQ_BW_UB2
block|}
block|,
block|{
name|PXP2_REG_PSWRQ_BW_L3
block|,
name|PXP2_REG_PSWRQ_BW_ADD3
block|,
name|PXP2_REG_PSWRQ_BW_UB3
block|}
block|,
block|{
name|PXP2_REG_PSWRQ_BW_L6
block|,
name|PXP2_REG_PSWRQ_BW_ADD6
block|,
name|PXP2_REG_PSWRQ_BW_UB6
block|}
block|,
block|{
name|PXP2_REG_PSWRQ_BW_L7
block|,
name|PXP2_REG_PSWRQ_BW_ADD7
block|,
name|PXP2_REG_PSWRQ_BW_UB7
block|}
block|,
block|{
name|PXP2_REG_PSWRQ_BW_L8
block|,
name|PXP2_REG_PSWRQ_BW_ADD8
block|,
name|PXP2_REG_PSWRQ_BW_UB8
block|}
block|,
block|{
name|PXP2_REG_PSWRQ_BW_L9
block|,
name|PXP2_REG_PSWRQ_BW_ADD9
block|,
name|PXP2_REG_PSWRQ_BW_UB9
block|}
block|,
block|{
name|PXP2_REG_PSWRQ_BW_L10
block|,
name|PXP2_REG_PSWRQ_BW_ADD10
block|,
name|PXP2_REG_PSWRQ_BW_UB10
block|}
block|,
block|{
name|PXP2_REG_PSWRQ_BW_L11
block|,
name|PXP2_REG_PSWRQ_BW_ADD11
block|,
name|PXP2_REG_PSWRQ_BW_UB11
block|}
block|,
comment|/* 10 */
block|{
name|PXP2_REG_PSWRQ_BW_L28
block|,
name|PXP2_REG_PSWRQ_BW_ADD28
block|,
name|PXP2_REG_PSWRQ_BW_UB28
block|}
block|,
block|{
name|PXP2_REG_RQ_BW_WR_L29
block|,
name|PXP2_REG_RQ_BW_WR_ADD29
block|,
name|PXP2_REG_RQ_BW_WR_UBOUND29
block|}
block|,
block|{
name|PXP2_REG_RQ_BW_WR_L30
block|,
name|PXP2_REG_RQ_BW_WR_ADD30
block|,
name|PXP2_REG_RQ_BW_WR_UBOUND30
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|ecore_init_pxp_arb
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|r_order
parameter_list|,
name|int
name|w_order
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|r_order
operator|>
name|MAX_RD_ORD
condition|)
block|{
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"read order of %d  order adjusted to %d\n"
argument_list|,
name|r_order
argument_list|,
name|MAX_RD_ORD
argument_list|)
expr_stmt|;
name|r_order
operator|=
name|MAX_RD_ORD
expr_stmt|;
block|}
if|if
condition|(
name|w_order
operator|>
name|MAX_WR_ORD
condition|)
block|{
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"write order of %d  order adjusted to %d\n"
argument_list|,
name|w_order
argument_list|,
name|MAX_WR_ORD
argument_list|)
expr_stmt|;
name|w_order
operator|=
name|MAX_WR_ORD
expr_stmt|;
block|}
if|if
condition|(
name|CHIP_REV_IS_FPGA
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"write order adjusted to 1 for FPGA\n"
argument_list|)
expr_stmt|;
name|w_order
operator|=
literal|0
expr_stmt|;
block|}
name|ECORE_MSG
argument_list|(
name|sc
argument_list|,
literal|"read order %d  write order %d\n"
argument_list|,
name|r_order
argument_list|,
name|w_order
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_RD_Q
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|read_arb_addr
index|[
name|i
index|]
operator|.
name|l
argument_list|,
name|read_arb_data
index|[
name|i
index|]
index|[
name|r_order
index|]
operator|.
name|l
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|read_arb_addr
index|[
name|i
index|]
operator|.
name|add
argument_list|,
name|read_arb_data
index|[
name|i
index|]
index|[
name|r_order
index|]
operator|.
name|add
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|read_arb_addr
index|[
name|i
index|]
operator|.
name|ubound
argument_list|,
name|read_arb_data
index|[
name|i
index|]
index|[
name|r_order
index|]
operator|.
name|ubound
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_WR_Q
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|write_arb_addr
index|[
name|i
index|]
operator|.
name|l
operator|==
name|PXP2_REG_RQ_BW_WR_L29
operator|)
operator|||
operator|(
name|write_arb_addr
index|[
name|i
index|]
operator|.
name|l
operator|==
name|PXP2_REG_RQ_BW_WR_L30
operator|)
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|write_arb_addr
index|[
name|i
index|]
operator|.
name|l
argument_list|,
name|write_arb_data
index|[
name|i
index|]
index|[
name|w_order
index|]
operator|.
name|l
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|write_arb_addr
index|[
name|i
index|]
operator|.
name|add
argument_list|,
name|write_arb_data
index|[
name|i
index|]
index|[
name|w_order
index|]
operator|.
name|add
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|write_arb_addr
index|[
name|i
index|]
operator|.
name|ubound
argument_list|,
name|write_arb_data
index|[
name|i
index|]
index|[
name|w_order
index|]
operator|.
name|ubound
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|write_arb_addr
index|[
name|i
index|]
operator|.
name|l
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|write_arb_addr
index|[
name|i
index|]
operator|.
name|l
argument_list|,
name|val
operator||
operator|(
name|write_arb_data
index|[
name|i
index|]
index|[
name|w_order
index|]
operator|.
name|l
operator|<<
literal|10
operator|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|write_arb_addr
index|[
name|i
index|]
operator|.
name|add
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|write_arb_addr
index|[
name|i
index|]
operator|.
name|add
argument_list|,
name|val
operator||
operator|(
name|write_arb_data
index|[
name|i
index|]
index|[
name|w_order
index|]
operator|.
name|add
operator|<<
literal|10
operator|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|write_arb_addr
index|[
name|i
index|]
operator|.
name|ubound
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|write_arb_addr
index|[
name|i
index|]
operator|.
name|ubound
argument_list|,
name|val
operator||
operator|(
name|write_arb_data
index|[
name|i
index|]
index|[
name|w_order
index|]
operator|.
name|ubound
operator|<<
literal|7
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|val
operator|=
name|write_arb_data
index|[
name|NUM_WR_Q
operator|-
literal|1
index|]
index|[
name|w_order
index|]
operator|.
name|add
expr_stmt|;
name|val
operator|+=
name|write_arb_data
index|[
name|NUM_WR_Q
operator|-
literal|1
index|]
index|[
name|w_order
index|]
operator|.
name|ubound
operator|<<
literal|10
expr_stmt|;
name|val
operator|+=
name|write_arb_data
index|[
name|NUM_WR_Q
operator|-
literal|1
index|]
index|[
name|w_order
index|]
operator|.
name|l
operator|<<
literal|17
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_PSWRQ_BW_RD
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|read_arb_data
index|[
name|NUM_RD_Q
operator|-
literal|1
index|]
index|[
name|r_order
index|]
operator|.
name|add
expr_stmt|;
name|val
operator|+=
name|read_arb_data
index|[
name|NUM_RD_Q
operator|-
literal|1
index|]
index|[
name|r_order
index|]
operator|.
name|ubound
operator|<<
literal|10
expr_stmt|;
name|val
operator|+=
name|read_arb_data
index|[
name|NUM_RD_Q
operator|-
literal|1
index|]
index|[
name|r_order
index|]
operator|.
name|l
operator|<<
literal|17
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_PSWRQ_BW_WR
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RQ_WR_MBS0
argument_list|,
name|w_order
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RQ_WR_MBS1
argument_list|,
name|w_order
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RQ_RD_MBS0
argument_list|,
name|r_order
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RQ_RD_MBS1
argument_list|,
name|r_order
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
operator|||
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
operator|)
operator|&&
operator|(
name|r_order
operator|==
name|MAX_RD_ORD
operator|)
condition|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_RQ_PDR_LIMIT
argument_list|,
literal|0xe00
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_WR_USDMDP_TH
argument_list|,
operator|(
literal|0x4
operator|<<
name|w_order
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CHIP_IS_E2
argument_list|(
name|sc
argument_list|)
condition|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_WR_USDMDP_TH
argument_list|,
operator|(
literal|0x8
operator|<<
name|w_order
operator|)
argument_list|)
expr_stmt|;
else|else
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_WR_USDMDP_TH
argument_list|,
operator|(
literal|0x18
operator|<<
name|w_order
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/*    MPS      w_order     optimal TH      presently TH 		 *    128         0             0               2 		 *    256         1             1               3 		 *>=512       2             2               3 		 */
comment|/* DMAE is special */
if|if
condition|(
operator|!
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* E2 can use optimal TH */
name|val
operator|=
name|w_order
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_WR_DMAE_MPS
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
operator|(
operator|(
name|w_order
operator|==
literal|0
operator|)
condition|?
literal|2
else|:
literal|3
operator|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_WR_DMAE_MPS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_WR_HC_MPS
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_WR_USDM_MPS
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_WR_CSDM_MPS
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_WR_TSDM_MPS
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_WR_XSDM_MPS
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_WR_QM_MPS
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_WR_TM_MPS
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_WR_SRC_MPS
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_WR_DBG_MPS
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_WR_CDU_MPS
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
comment|/* Validate number of tags suppoted by device */
define|#
directive|define
name|PCIE_REG_PCIER_TL_HDR_FC_ST
value|0x2980
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|PCIE_REG_PCIER_TL_HDR_FC_ST
argument_list|)
expr_stmt|;
name|val
operator|&=
literal|0xFF
expr_stmt|;
if|if
condition|(
name|val
operator|<=
literal|0x20
condition|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PXP2_REG_PGL_TAGS_LIMIT
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************************** * ILT management ****************************************************************************/
end_comment

begin_comment
comment|/*  * This codes hides the low level HW interaction for ILT management and  * configuration. The API consists of a shadow ILT table which is set by the  * driver and a set of routines to use it to configure the HW.  *  */
end_comment

begin_comment
comment|/* ILT HW init operations */
end_comment

begin_comment
comment|/* ILT memory management operations */
end_comment

begin_define
define|#
directive|define
name|ILT_MEMOP_ALLOC
value|0
end_define

begin_define
define|#
directive|define
name|ILT_MEMOP_FREE
value|1
end_define

begin_comment
comment|/* the phys address is shifted right 12 bits and has an added  * 1=valid bit added to the 53rd bit  * then since this is a wide register(TM)  * we split it into two 32 bit writes  */
end_comment

begin_define
define|#
directive|define
name|ILT_ADDR1
parameter_list|(
name|x
parameter_list|)
value|((uint32_t)(((uint64_t)x>> 12)& 0xFFFFFFFF))
end_define

begin_define
define|#
directive|define
name|ILT_ADDR2
parameter_list|(
name|x
parameter_list|)
value|((uint32_t)((1<< 20) | ((uint64_t)x>> 44)))
end_define

begin_define
define|#
directive|define
name|ILT_RANGE
parameter_list|(
name|f
parameter_list|,
name|l
parameter_list|)
value|(((l)<< 10) | f)
end_define

begin_function
specifier|static
name|int
name|ecore_ilt_line_mem_op
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ilt_line
modifier|*
name|line
parameter_list|,
name|uint32_t
name|size
parameter_list|,
name|uint8_t
name|memop
parameter_list|)
block|{
if|if
condition|(
name|memop
operator|==
name|ILT_MEMOP_FREE
condition|)
block|{
name|ECORE_ILT_FREE
argument_list|(
name|line
operator|->
name|page
argument_list|,
name|line
operator|->
name|page_mapping
argument_list|,
name|line
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ECORE_ILT_ZALLOC
argument_list|(
name|line
operator|->
name|page
argument_list|,
operator|&
name|line
operator|->
name|page_mapping
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|line
operator|->
name|page
condition|)
return|return
operator|-
literal|1
return|;
name|line
operator|->
name|size
operator|=
name|size
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ecore_ilt_client_mem_op
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|cli_num
parameter_list|,
name|uint8_t
name|memop
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|struct
name|ecore_ilt
modifier|*
name|ilt
init|=
name|SC_ILT
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|struct
name|ilt_client_info
modifier|*
name|ilt_cli
init|=
operator|&
name|ilt
operator|->
name|clients
index|[
name|cli_num
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|ilt
operator|||
operator|!
name|ilt
operator|->
name|lines
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ilt_cli
operator|->
name|flags
operator|&
operator|(
name|ILT_CLIENT_SKIP_INIT
operator||
name|ILT_CLIENT_SKIP_MEM
operator|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|rc
operator|=
literal|0
operator|,
name|i
operator|=
name|ilt_cli
operator|->
name|start
init|;
name|i
operator|<=
name|ilt_cli
operator|->
name|end
operator|&&
operator|!
name|rc
condition|;
name|i
operator|++
control|)
block|{
name|rc
operator|=
name|ecore_ilt_line_mem_op
argument_list|(
name|sc
argument_list|,
operator|&
name|ilt
operator|->
name|lines
index|[
name|i
index|]
argument_list|,
name|ilt_cli
operator|->
name|page_size
argument_list|,
name|memop
argument_list|)
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|ecore_ilt_mem_op_cnic
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|memop
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|CONFIGURE_NIC_MODE
argument_list|(
name|sc
argument_list|)
condition|)
name|rc
operator|=
name|ecore_ilt_client_mem_op
argument_list|(
name|sc
argument_list|,
name|ILT_CLIENT_SRC
argument_list|,
name|memop
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rc
condition|)
name|rc
operator|=
name|ecore_ilt_client_mem_op
argument_list|(
name|sc
argument_list|,
name|ILT_CLIENT_TM
argument_list|,
name|memop
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ecore_ilt_mem_op
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|memop
parameter_list|)
block|{
name|int
name|rc
init|=
name|ecore_ilt_client_mem_op
argument_list|(
name|sc
argument_list|,
name|ILT_CLIENT_CDU
argument_list|,
name|memop
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rc
condition|)
name|rc
operator|=
name|ecore_ilt_client_mem_op
argument_list|(
name|sc
argument_list|,
name|ILT_CLIENT_QM
argument_list|,
name|memop
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rc
operator|&&
name|CNIC_SUPPORT
argument_list|(
name|sc
argument_list|)
operator|&&
operator|!
name|CONFIGURE_NIC_MODE
argument_list|(
name|sc
argument_list|)
condition|)
name|rc
operator|=
name|ecore_ilt_client_mem_op
argument_list|(
name|sc
argument_list|,
name|ILT_CLIENT_SRC
argument_list|,
name|memop
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_ilt_line_wr
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|abs_idx
parameter_list|,
name|ecore_dma_addr_t
name|page_mapping
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
if|if
condition|(
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
name|reg
operator|=
name|PXP2_REG_RQ_ONCHIP_AT
operator|+
name|abs_idx
operator|*
literal|8
expr_stmt|;
else|else
name|reg
operator|=
name|PXP2_REG_RQ_ONCHIP_AT_B0
operator|+
name|abs_idx
operator|*
literal|8
expr_stmt|;
name|ecore_wr_64
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
name|ILT_ADDR1
argument_list|(
name|page_mapping
argument_list|)
argument_list|,
name|ILT_ADDR2
argument_list|(
name|page_mapping
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_ilt_line_init_op
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_ilt
modifier|*
name|ilt
parameter_list|,
name|int
name|idx
parameter_list|,
name|uint8_t
name|initop
parameter_list|)
block|{
name|ecore_dma_addr_t
name|null_mapping
decl_stmt|;
name|int
name|abs_idx
init|=
name|ilt
operator|->
name|start_line
operator|+
name|idx
decl_stmt|;
switch|switch
condition|(
name|initop
condition|)
block|{
case|case
name|INITOP_INIT
case|:
comment|/* set in the init-value array */
case|case
name|INITOP_SET
case|:
name|ecore_ilt_line_wr
argument_list|(
name|sc
argument_list|,
name|abs_idx
argument_list|,
name|ilt
operator|->
name|lines
index|[
name|idx
index|]
operator|.
name|page_mapping
argument_list|)
expr_stmt|;
break|break;
case|case
name|INITOP_CLEAR
case|:
name|null_mapping
operator|=
literal|0
expr_stmt|;
name|ecore_ilt_line_wr
argument_list|(
name|sc
argument_list|,
name|abs_idx
argument_list|,
name|null_mapping
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_ilt_boundry_init_op
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ilt_client_info
modifier|*
name|ilt_cli
parameter_list|,
name|uint32_t
name|ilt_start
parameter_list|,
name|uint8_t
name|initop
parameter_list|)
block|{
name|uint32_t
name|start_reg
init|=
literal|0
decl_stmt|;
name|uint32_t
name|end_reg
init|=
literal|0
decl_stmt|;
comment|/* The boundary is either SET or INIT, 	   CLEAR => SET and for now SET ~~ INIT */
comment|/* find the appropriate regs */
if|if
condition|(
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|ilt_cli
operator|->
name|client_num
condition|)
block|{
case|case
name|ILT_CLIENT_CDU
case|:
name|start_reg
operator|=
name|PXP2_REG_PSWRQ_CDU0_L2P
expr_stmt|;
break|break;
case|case
name|ILT_CLIENT_QM
case|:
name|start_reg
operator|=
name|PXP2_REG_PSWRQ_QM0_L2P
expr_stmt|;
break|break;
case|case
name|ILT_CLIENT_SRC
case|:
name|start_reg
operator|=
name|PXP2_REG_PSWRQ_SRC0_L2P
expr_stmt|;
break|break;
case|case
name|ILT_CLIENT_TM
case|:
name|start_reg
operator|=
name|PXP2_REG_PSWRQ_TM0_L2P
expr_stmt|;
break|break;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|start_reg
operator|+
name|SC_FUNC
argument_list|(
name|sc
argument_list|)
operator|*
literal|4
argument_list|,
name|ILT_RANGE
argument_list|(
operator|(
name|ilt_start
operator|+
name|ilt_cli
operator|->
name|start
operator|)
argument_list|,
operator|(
name|ilt_start
operator|+
name|ilt_cli
operator|->
name|end
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|ilt_cli
operator|->
name|client_num
condition|)
block|{
case|case
name|ILT_CLIENT_CDU
case|:
name|start_reg
operator|=
name|PXP2_REG_RQ_CDU_FIRST_ILT
expr_stmt|;
name|end_reg
operator|=
name|PXP2_REG_RQ_CDU_LAST_ILT
expr_stmt|;
break|break;
case|case
name|ILT_CLIENT_QM
case|:
name|start_reg
operator|=
name|PXP2_REG_RQ_QM_FIRST_ILT
expr_stmt|;
name|end_reg
operator|=
name|PXP2_REG_RQ_QM_LAST_ILT
expr_stmt|;
break|break;
case|case
name|ILT_CLIENT_SRC
case|:
name|start_reg
operator|=
name|PXP2_REG_RQ_SRC_FIRST_ILT
expr_stmt|;
name|end_reg
operator|=
name|PXP2_REG_RQ_SRC_LAST_ILT
expr_stmt|;
break|break;
case|case
name|ILT_CLIENT_TM
case|:
name|start_reg
operator|=
name|PXP2_REG_RQ_TM_FIRST_ILT
expr_stmt|;
name|end_reg
operator|=
name|PXP2_REG_RQ_TM_LAST_ILT
expr_stmt|;
break|break;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|start_reg
argument_list|,
operator|(
name|ilt_start
operator|+
name|ilt_cli
operator|->
name|start
operator|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|end_reg
argument_list|,
operator|(
name|ilt_start
operator|+
name|ilt_cli
operator|->
name|end
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_ilt_client_init_op_ilt
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ecore_ilt
modifier|*
name|ilt
parameter_list|,
name|struct
name|ilt_client_info
modifier|*
name|ilt_cli
parameter_list|,
name|uint8_t
name|initop
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ilt_cli
operator|->
name|flags
operator|&
name|ILT_CLIENT_SKIP_INIT
condition|)
return|return;
for|for
control|(
name|i
operator|=
name|ilt_cli
operator|->
name|start
init|;
name|i
operator|<=
name|ilt_cli
operator|->
name|end
condition|;
name|i
operator|++
control|)
name|ecore_ilt_line_init_op
argument_list|(
name|sc
argument_list|,
name|ilt
argument_list|,
name|i
argument_list|,
name|initop
argument_list|)
expr_stmt|;
comment|/* init/clear the ILT boundries */
name|ecore_ilt_boundry_init_op
argument_list|(
name|sc
argument_list|,
name|ilt_cli
argument_list|,
name|ilt
operator|->
name|start_line
argument_list|,
name|initop
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_ilt_client_init_op
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ilt_client_info
modifier|*
name|ilt_cli
parameter_list|,
name|uint8_t
name|initop
parameter_list|)
block|{
name|struct
name|ecore_ilt
modifier|*
name|ilt
init|=
name|SC_ILT
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|ecore_ilt_client_init_op_ilt
argument_list|(
name|sc
argument_list|,
name|ilt
argument_list|,
name|ilt_cli
argument_list|,
name|initop
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_ilt_client_id_init_op
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|cli_num
parameter_list|,
name|uint8_t
name|initop
parameter_list|)
block|{
name|struct
name|ecore_ilt
modifier|*
name|ilt
init|=
name|SC_ILT
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|struct
name|ilt_client_info
modifier|*
name|ilt_cli
init|=
operator|&
name|ilt
operator|->
name|clients
index|[
name|cli_num
index|]
decl_stmt|;
name|ecore_ilt_client_init_op
argument_list|(
name|sc
argument_list|,
name|ilt_cli
argument_list|,
name|initop
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ecore_ilt_init_op_cnic
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|initop
parameter_list|)
block|{
if|if
condition|(
name|CONFIGURE_NIC_MODE
argument_list|(
name|sc
argument_list|)
condition|)
name|ecore_ilt_client_id_init_op
argument_list|(
name|sc
argument_list|,
name|ILT_CLIENT_SRC
argument_list|,
name|initop
argument_list|)
expr_stmt|;
name|ecore_ilt_client_id_init_op
argument_list|(
name|sc
argument_list|,
name|ILT_CLIENT_TM
argument_list|,
name|initop
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_ilt_init_op
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|initop
parameter_list|)
block|{
name|ecore_ilt_client_id_init_op
argument_list|(
name|sc
argument_list|,
name|ILT_CLIENT_CDU
argument_list|,
name|initop
argument_list|)
expr_stmt|;
name|ecore_ilt_client_id_init_op
argument_list|(
name|sc
argument_list|,
name|ILT_CLIENT_QM
argument_list|,
name|initop
argument_list|)
expr_stmt|;
if|if
condition|(
name|CNIC_SUPPORT
argument_list|(
name|sc
argument_list|)
operator|&&
operator|!
name|CONFIGURE_NIC_MODE
argument_list|(
name|sc
argument_list|)
condition|)
name|ecore_ilt_client_id_init_op
argument_list|(
name|sc
argument_list|,
name|ILT_CLIENT_SRC
argument_list|,
name|initop
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_ilt_init_client_psz
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|cli_num
parameter_list|,
name|uint32_t
name|psz_reg
parameter_list|,
name|uint8_t
name|initop
parameter_list|)
block|{
name|struct
name|ecore_ilt
modifier|*
name|ilt
init|=
name|SC_ILT
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|struct
name|ilt_client_info
modifier|*
name|ilt_cli
init|=
operator|&
name|ilt
operator|->
name|clients
index|[
name|cli_num
index|]
decl_stmt|;
if|if
condition|(
name|ilt_cli
operator|->
name|flags
operator|&
name|ILT_CLIENT_SKIP_INIT
condition|)
return|return;
switch|switch
condition|(
name|initop
condition|)
block|{
case|case
name|INITOP_INIT
case|:
comment|/* set in the init-value array */
case|case
name|INITOP_SET
case|:
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|psz_reg
argument_list|,
name|ILOG2
argument_list|(
name|ilt_cli
operator|->
name|page_size
operator|>>
literal|12
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|INITOP_CLEAR
case|:
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * called during init common stage, ilt clients should be initialized  * prioir to calling this function  */
end_comment

begin_function
specifier|static
name|void
name|ecore_ilt_init_page_size
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|initop
parameter_list|)
block|{
name|ecore_ilt_init_client_psz
argument_list|(
name|sc
argument_list|,
name|ILT_CLIENT_CDU
argument_list|,
name|PXP2_REG_RQ_CDU_P_SIZE
argument_list|,
name|initop
argument_list|)
expr_stmt|;
name|ecore_ilt_init_client_psz
argument_list|(
name|sc
argument_list|,
name|ILT_CLIENT_QM
argument_list|,
name|PXP2_REG_RQ_QM_P_SIZE
argument_list|,
name|initop
argument_list|)
expr_stmt|;
name|ecore_ilt_init_client_psz
argument_list|(
name|sc
argument_list|,
name|ILT_CLIENT_SRC
argument_list|,
name|PXP2_REG_RQ_SRC_P_SIZE
argument_list|,
name|initop
argument_list|)
expr_stmt|;
name|ecore_ilt_init_client_psz
argument_list|(
name|sc
argument_list|,
name|ILT_CLIENT_TM
argument_list|,
name|PXP2_REG_RQ_TM_P_SIZE
argument_list|,
name|initop
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************************** * QM initializations ****************************************************************************/
end_comment

begin_define
define|#
directive|define
name|QM_QUEUES_PER_FUNC
value|16
end_define

begin_comment
comment|/* E1 has 32, but only 16 are used */
end_comment

begin_define
define|#
directive|define
name|QM_INIT_MIN_CID_COUNT
value|31
end_define

begin_define
define|#
directive|define
name|QM_INIT
parameter_list|(
name|cid_cnt
parameter_list|)
value|(cid_cnt> QM_INIT_MIN_CID_COUNT)
end_define

begin_comment
comment|/* called during init port stage */
end_comment

begin_function
specifier|static
name|void
name|ecore_qm_init_cid_count
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qm_cid_count
parameter_list|,
name|uint8_t
name|initop
parameter_list|)
block|{
name|int
name|port
init|=
name|SC_PORT
argument_list|(
name|sc
argument_list|)
decl_stmt|;
if|if
condition|(
name|QM_INIT
argument_list|(
name|qm_cid_count
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|initop
condition|)
block|{
case|case
name|INITOP_INIT
case|:
comment|/* set in the init-value array */
case|case
name|INITOP_SET
case|:
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|QM_REG_CONNNUM_0
operator|+
name|port
operator|*
literal|4
argument_list|,
name|qm_cid_count
operator|/
literal|16
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|INITOP_CLEAR
case|:
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ecore_qm_set_ptr_table
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qm_cid_count
parameter_list|,
name|uint32_t
name|base_reg
parameter_list|,
name|uint32_t
name|reg
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint32_t
name|wb_data
index|[
literal|2
index|]
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
operator|*
name|QM_QUEUES_PER_FUNC
condition|;
name|i
operator|++
control|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|base_reg
operator|+
name|i
operator|*
literal|4
argument_list|,
name|qm_cid_count
operator|*
literal|4
operator|*
operator|(
name|i
operator|%
name|QM_QUEUES_PER_FUNC
operator|)
argument_list|)
expr_stmt|;
name|ecore_init_wr_wb
argument_list|(
name|sc
argument_list|,
name|reg
operator|+
name|i
operator|*
literal|8
argument_list|,
name|wb_data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* called during init common stage */
end_comment

begin_function
specifier|static
name|void
name|ecore_qm_init_ptr_table
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qm_cid_count
parameter_list|,
name|uint8_t
name|initop
parameter_list|)
block|{
if|if
condition|(
operator|!
name|QM_INIT
argument_list|(
name|qm_cid_count
argument_list|)
condition|)
return|return;
switch|switch
condition|(
name|initop
condition|)
block|{
case|case
name|INITOP_INIT
case|:
comment|/* set in the init-value array */
case|case
name|INITOP_SET
case|:
name|ecore_qm_set_ptr_table
argument_list|(
name|sc
argument_list|,
name|qm_cid_count
argument_list|,
name|QM_REG_BASEADDR
argument_list|,
name|QM_REG_PTRTBL
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E1H
argument_list|(
name|sc
argument_list|)
condition|)
name|ecore_qm_set_ptr_table
argument_list|(
name|sc
argument_list|,
name|qm_cid_count
argument_list|,
name|QM_REG_BASEADDR_EXT_A
argument_list|,
name|QM_REG_PTRTBL_EXT_A
argument_list|)
expr_stmt|;
break|break;
case|case
name|INITOP_CLEAR
case|:
break|break;
block|}
block|}
end_function

begin_comment
comment|/**************************************************************************** * SRC initializations ****************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ECORE_L5
end_ifdef

begin_comment
comment|/* called during init func stage */
end_comment

begin_function
specifier|static
name|void
name|ecore_src_init_t2
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|src_ent
modifier|*
name|t2
parameter_list|,
name|ecore_dma_addr_t
name|t2_mapping
parameter_list|,
name|int
name|src_cid_count
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|port
init|=
name|SC_PORT
argument_list|(
name|sc
argument_list|)
decl_stmt|;
comment|/* Initialize T2 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|src_cid_count
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|t2
index|[
name|i
index|]
operator|.
name|next
operator|=
call|(
name|uint64_t
call|)
argument_list|(
name|t2_mapping
operator|+
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|src_ent
argument_list|)
argument_list|)
expr_stmt|;
comment|/* tell the searcher where the T2 table is */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|SRC_REG_COUNTFREE0
operator|+
name|port
operator|*
literal|4
argument_list|,
name|src_cid_count
argument_list|)
expr_stmt|;
name|ecore_wr_64
argument_list|(
name|sc
argument_list|,
name|SRC_REG_FIRSTFREE0
operator|+
name|port
operator|*
literal|16
argument_list|,
name|U64_LO
argument_list|(
name|t2_mapping
argument_list|)
argument_list|,
name|U64_HI
argument_list|(
name|t2_mapping
argument_list|)
argument_list|)
expr_stmt|;
name|ecore_wr_64
argument_list|(
name|sc
argument_list|,
name|SRC_REG_LASTFREE0
operator|+
name|port
operator|*
literal|16
argument_list|,
name|U64_LO
argument_list|(
operator|(
name|uint64_t
operator|)
name|t2_mapping
operator|+
operator|(
name|src_cid_count
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|src_ent
argument_list|)
argument_list|)
argument_list|,
name|U64_HI
argument_list|(
operator|(
name|uint64_t
operator|)
name|t2_mapping
operator|+
operator|(
name|src_cid_count
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|src_ent
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ECORE_INIT_OPS_H */
end_comment

end_unit

