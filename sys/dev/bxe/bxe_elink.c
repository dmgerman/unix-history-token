begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * SPDX-License-Identifier: BSD-2-Clause  *  * Copyright (c) 2007-2017 QLogic Corporation. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"bxe.h"
end_include

begin_include
include|#
directive|include
file|"bxe_elink.h"
end_include

begin_include
include|#
directive|include
file|"ecore_mfw_req.h"
end_include

begin_include
include|#
directive|include
file|"ecore_fw_defs.h"
end_include

begin_include
include|#
directive|include
file|"ecore_hsi.h"
end_include

begin_include
include|#
directive|include
file|"ecore_reg.h"
end_include

begin_define
define|#
directive|define
name|MDIO_REG_BANK_CL73_IEEEB0
value|0x0
end_define

begin_define
define|#
directive|define
name|MDIO_CL73_IEEEB0_CL73_AN_CONTROL
value|0x0
end_define

begin_define
define|#
directive|define
name|MDIO_CL73_IEEEB0_CL73_AN_CONTROL_RESTART_AN
value|0x0200
end_define

begin_define
define|#
directive|define
name|MDIO_CL73_IEEEB0_CL73_AN_CONTROL_AN_EN
value|0x1000
end_define

begin_define
define|#
directive|define
name|MDIO_CL73_IEEEB0_CL73_AN_CONTROL_MAIN_RST
value|0x8000
end_define

begin_define
define|#
directive|define
name|MDIO_REG_BANK_CL73_IEEEB1
value|0x10
end_define

begin_define
define|#
directive|define
name|MDIO_CL73_IEEEB1_AN_ADV1
value|0x00
end_define

begin_define
define|#
directive|define
name|MDIO_CL73_IEEEB1_AN_ADV1_PAUSE
value|0x0400
end_define

begin_define
define|#
directive|define
name|MDIO_CL73_IEEEB1_AN_ADV1_ASYMMETRIC
value|0x0800
end_define

begin_define
define|#
directive|define
name|MDIO_CL73_IEEEB1_AN_ADV1_PAUSE_BOTH
value|0x0C00
end_define

begin_define
define|#
directive|define
name|MDIO_CL73_IEEEB1_AN_ADV1_PAUSE_MASK
value|0x0C00
end_define

begin_define
define|#
directive|define
name|MDIO_CL73_IEEEB1_AN_ADV2
value|0x01
end_define

begin_define
define|#
directive|define
name|MDIO_CL73_IEEEB1_AN_ADV2_ADVR_1000M
value|0x0000
end_define

begin_define
define|#
directive|define
name|MDIO_CL73_IEEEB1_AN_ADV2_ADVR_1000M_KX
value|0x0020
end_define

begin_define
define|#
directive|define
name|MDIO_CL73_IEEEB1_AN_ADV2_ADVR_10G_KX4
value|0x0040
end_define

begin_define
define|#
directive|define
name|MDIO_CL73_IEEEB1_AN_ADV2_ADVR_10G_KR
value|0x0080
end_define

begin_define
define|#
directive|define
name|MDIO_CL73_IEEEB1_AN_LP_ADV1
value|0x03
end_define

begin_define
define|#
directive|define
name|MDIO_CL73_IEEEB1_AN_LP_ADV1_PAUSE
value|0x0400
end_define

begin_define
define|#
directive|define
name|MDIO_CL73_IEEEB1_AN_LP_ADV1_ASYMMETRIC
value|0x0800
end_define

begin_define
define|#
directive|define
name|MDIO_CL73_IEEEB1_AN_LP_ADV1_PAUSE_BOTH
value|0x0C00
end_define

begin_define
define|#
directive|define
name|MDIO_CL73_IEEEB1_AN_LP_ADV1_PAUSE_MASK
value|0x0C00
end_define

begin_define
define|#
directive|define
name|MDIO_CL73_IEEEB1_AN_LP_ADV2
value|0x04
end_define

begin_define
define|#
directive|define
name|MDIO_REG_BANK_RX0
value|0x80b0
end_define

begin_define
define|#
directive|define
name|MDIO_RX0_RX_STATUS
value|0x10
end_define

begin_define
define|#
directive|define
name|MDIO_RX0_RX_STATUS_SIGDET
value|0x8000
end_define

begin_define
define|#
directive|define
name|MDIO_RX0_RX_STATUS_RX_SEQ_DONE
value|0x1000
end_define

begin_define
define|#
directive|define
name|MDIO_RX0_RX_EQ_BOOST
value|0x1c
end_define

begin_define
define|#
directive|define
name|MDIO_RX0_RX_EQ_BOOST_EQUALIZER_CTRL_MASK
value|0x7
end_define

begin_define
define|#
directive|define
name|MDIO_RX0_RX_EQ_BOOST_OFFSET_CTRL
value|0x10
end_define

begin_define
define|#
directive|define
name|MDIO_REG_BANK_RX1
value|0x80c0
end_define

begin_define
define|#
directive|define
name|MDIO_RX1_RX_EQ_BOOST
value|0x1c
end_define

begin_define
define|#
directive|define
name|MDIO_RX1_RX_EQ_BOOST_EQUALIZER_CTRL_MASK
value|0x7
end_define

begin_define
define|#
directive|define
name|MDIO_RX1_RX_EQ_BOOST_OFFSET_CTRL
value|0x10
end_define

begin_define
define|#
directive|define
name|MDIO_REG_BANK_RX2
value|0x80d0
end_define

begin_define
define|#
directive|define
name|MDIO_RX2_RX_EQ_BOOST
value|0x1c
end_define

begin_define
define|#
directive|define
name|MDIO_RX2_RX_EQ_BOOST_EQUALIZER_CTRL_MASK
value|0x7
end_define

begin_define
define|#
directive|define
name|MDIO_RX2_RX_EQ_BOOST_OFFSET_CTRL
value|0x10
end_define

begin_define
define|#
directive|define
name|MDIO_REG_BANK_RX3
value|0x80e0
end_define

begin_define
define|#
directive|define
name|MDIO_RX3_RX_EQ_BOOST
value|0x1c
end_define

begin_define
define|#
directive|define
name|MDIO_RX3_RX_EQ_BOOST_EQUALIZER_CTRL_MASK
value|0x7
end_define

begin_define
define|#
directive|define
name|MDIO_RX3_RX_EQ_BOOST_OFFSET_CTRL
value|0x10
end_define

begin_define
define|#
directive|define
name|MDIO_REG_BANK_RX_ALL
value|0x80f0
end_define

begin_define
define|#
directive|define
name|MDIO_RX_ALL_RX_EQ_BOOST
value|0x1c
end_define

begin_define
define|#
directive|define
name|MDIO_RX_ALL_RX_EQ_BOOST_EQUALIZER_CTRL_MASK
value|0x7
end_define

begin_define
define|#
directive|define
name|MDIO_RX_ALL_RX_EQ_BOOST_OFFSET_CTRL
value|0x10
end_define

begin_define
define|#
directive|define
name|MDIO_REG_BANK_TX0
value|0x8060
end_define

begin_define
define|#
directive|define
name|MDIO_TX0_TX_DRIVER
value|0x17
end_define

begin_define
define|#
directive|define
name|MDIO_TX0_TX_DRIVER_PREEMPHASIS_MASK
value|0xf000
end_define

begin_define
define|#
directive|define
name|MDIO_TX0_TX_DRIVER_PREEMPHASIS_SHIFT
value|12
end_define

begin_define
define|#
directive|define
name|MDIO_TX0_TX_DRIVER_IDRIVER_MASK
value|0x0f00
end_define

begin_define
define|#
directive|define
name|MDIO_TX0_TX_DRIVER_IDRIVER_SHIFT
value|8
end_define

begin_define
define|#
directive|define
name|MDIO_TX0_TX_DRIVER_IPREDRIVER_MASK
value|0x00f0
end_define

begin_define
define|#
directive|define
name|MDIO_TX0_TX_DRIVER_IPREDRIVER_SHIFT
value|4
end_define

begin_define
define|#
directive|define
name|MDIO_TX0_TX_DRIVER_IFULLSPD_MASK
value|0x000e
end_define

begin_define
define|#
directive|define
name|MDIO_TX0_TX_DRIVER_IFULLSPD_SHIFT
value|1
end_define

begin_define
define|#
directive|define
name|MDIO_TX0_TX_DRIVER_ICBUF1T
value|1
end_define

begin_define
define|#
directive|define
name|MDIO_REG_BANK_TX1
value|0x8070
end_define

begin_define
define|#
directive|define
name|MDIO_TX1_TX_DRIVER
value|0x17
end_define

begin_define
define|#
directive|define
name|MDIO_TX0_TX_DRIVER_PREEMPHASIS_MASK
value|0xf000
end_define

begin_define
define|#
directive|define
name|MDIO_TX0_TX_DRIVER_PREEMPHASIS_SHIFT
value|12
end_define

begin_define
define|#
directive|define
name|MDIO_TX0_TX_DRIVER_IDRIVER_MASK
value|0x0f00
end_define

begin_define
define|#
directive|define
name|MDIO_TX0_TX_DRIVER_IDRIVER_SHIFT
value|8
end_define

begin_define
define|#
directive|define
name|MDIO_TX0_TX_DRIVER_IPREDRIVER_MASK
value|0x00f0
end_define

begin_define
define|#
directive|define
name|MDIO_TX0_TX_DRIVER_IPREDRIVER_SHIFT
value|4
end_define

begin_define
define|#
directive|define
name|MDIO_TX0_TX_DRIVER_IFULLSPD_MASK
value|0x000e
end_define

begin_define
define|#
directive|define
name|MDIO_TX0_TX_DRIVER_IFULLSPD_SHIFT
value|1
end_define

begin_define
define|#
directive|define
name|MDIO_TX0_TX_DRIVER_ICBUF1T
value|1
end_define

begin_define
define|#
directive|define
name|MDIO_REG_BANK_TX2
value|0x8080
end_define

begin_define
define|#
directive|define
name|MDIO_TX2_TX_DRIVER
value|0x17
end_define

begin_define
define|#
directive|define
name|MDIO_TX0_TX_DRIVER_PREEMPHASIS_MASK
value|0xf000
end_define

begin_define
define|#
directive|define
name|MDIO_TX0_TX_DRIVER_PREEMPHASIS_SHIFT
value|12
end_define

begin_define
define|#
directive|define
name|MDIO_TX0_TX_DRIVER_IDRIVER_MASK
value|0x0f00
end_define

begin_define
define|#
directive|define
name|MDIO_TX0_TX_DRIVER_IDRIVER_SHIFT
value|8
end_define

begin_define
define|#
directive|define
name|MDIO_TX0_TX_DRIVER_IPREDRIVER_MASK
value|0x00f0
end_define

begin_define
define|#
directive|define
name|MDIO_TX0_TX_DRIVER_IPREDRIVER_SHIFT
value|4
end_define

begin_define
define|#
directive|define
name|MDIO_TX0_TX_DRIVER_IFULLSPD_MASK
value|0x000e
end_define

begin_define
define|#
directive|define
name|MDIO_TX0_TX_DRIVER_IFULLSPD_SHIFT
value|1
end_define

begin_define
define|#
directive|define
name|MDIO_TX0_TX_DRIVER_ICBUF1T
value|1
end_define

begin_define
define|#
directive|define
name|MDIO_REG_BANK_TX3
value|0x8090
end_define

begin_define
define|#
directive|define
name|MDIO_TX3_TX_DRIVER
value|0x17
end_define

begin_define
define|#
directive|define
name|MDIO_TX0_TX_DRIVER_PREEMPHASIS_MASK
value|0xf000
end_define

begin_define
define|#
directive|define
name|MDIO_TX0_TX_DRIVER_PREEMPHASIS_SHIFT
value|12
end_define

begin_define
define|#
directive|define
name|MDIO_TX0_TX_DRIVER_IDRIVER_MASK
value|0x0f00
end_define

begin_define
define|#
directive|define
name|MDIO_TX0_TX_DRIVER_IDRIVER_SHIFT
value|8
end_define

begin_define
define|#
directive|define
name|MDIO_TX0_TX_DRIVER_IPREDRIVER_MASK
value|0x00f0
end_define

begin_define
define|#
directive|define
name|MDIO_TX0_TX_DRIVER_IPREDRIVER_SHIFT
value|4
end_define

begin_define
define|#
directive|define
name|MDIO_TX0_TX_DRIVER_IFULLSPD_MASK
value|0x000e
end_define

begin_define
define|#
directive|define
name|MDIO_TX0_TX_DRIVER_IFULLSPD_SHIFT
value|1
end_define

begin_define
define|#
directive|define
name|MDIO_TX0_TX_DRIVER_ICBUF1T
value|1
end_define

begin_define
define|#
directive|define
name|MDIO_REG_BANK_XGXS_BLOCK0
value|0x8000
end_define

begin_define
define|#
directive|define
name|MDIO_BLOCK0_XGXS_CONTROL
value|0x10
end_define

begin_define
define|#
directive|define
name|MDIO_REG_BANK_XGXS_BLOCK1
value|0x8010
end_define

begin_define
define|#
directive|define
name|MDIO_BLOCK1_LANE_CTRL0
value|0x15
end_define

begin_define
define|#
directive|define
name|MDIO_BLOCK1_LANE_CTRL1
value|0x16
end_define

begin_define
define|#
directive|define
name|MDIO_BLOCK1_LANE_CTRL2
value|0x17
end_define

begin_define
define|#
directive|define
name|MDIO_BLOCK1_LANE_PRBS
value|0x19
end_define

begin_define
define|#
directive|define
name|MDIO_REG_BANK_XGXS_BLOCK2
value|0x8100
end_define

begin_define
define|#
directive|define
name|MDIO_XGXS_BLOCK2_RX_LN_SWAP
value|0x10
end_define

begin_define
define|#
directive|define
name|MDIO_XGXS_BLOCK2_RX_LN_SWAP_ENABLE
value|0x8000
end_define

begin_define
define|#
directive|define
name|MDIO_XGXS_BLOCK2_RX_LN_SWAP_FORCE_ENABLE
value|0x4000
end_define

begin_define
define|#
directive|define
name|MDIO_XGXS_BLOCK2_TX_LN_SWAP
value|0x11
end_define

begin_define
define|#
directive|define
name|MDIO_XGXS_BLOCK2_TX_LN_SWAP_ENABLE
value|0x8000
end_define

begin_define
define|#
directive|define
name|MDIO_XGXS_BLOCK2_UNICORE_MODE_10G
value|0x14
end_define

begin_define
define|#
directive|define
name|MDIO_XGXS_BLOCK2_UNICORE_MODE_10G_CX4_XGXS
value|0x0001
end_define

begin_define
define|#
directive|define
name|MDIO_XGXS_BLOCK2_UNICORE_MODE_10G_HIGIG_XGXS
value|0x0010
end_define

begin_define
define|#
directive|define
name|MDIO_XGXS_BLOCK2_TEST_MODE_LANE
value|0x15
end_define

begin_define
define|#
directive|define
name|MDIO_REG_BANK_GP_STATUS
value|0x8120
end_define

begin_define
define|#
directive|define
name|MDIO_GP_STATUS_TOP_AN_STATUS1
value|0x1B
end_define

begin_define
define|#
directive|define
name|MDIO_GP_STATUS_TOP_AN_STATUS1_CL73_AUTONEG_COMPLETE
value|0x0001
end_define

begin_define
define|#
directive|define
name|MDIO_GP_STATUS_TOP_AN_STATUS1_CL37_AUTONEG_COMPLETE
value|0x0002
end_define

begin_define
define|#
directive|define
name|MDIO_GP_STATUS_TOP_AN_STATUS1_LINK_STATUS
value|0x0004
end_define

begin_define
define|#
directive|define
name|MDIO_GP_STATUS_TOP_AN_STATUS1_DUPLEX_STATUS
value|0x0008
end_define

begin_define
define|#
directive|define
name|MDIO_GP_STATUS_TOP_AN_STATUS1_CL73_MR_LP_NP_AN_ABLE
value|0x0010
end_define

begin_define
define|#
directive|define
name|MDIO_GP_STATUS_TOP_AN_STATUS1_CL73_LP_NP_BAM_ABLE
value|0x0020
end_define

begin_define
define|#
directive|define
name|MDIO_GP_STATUS_TOP_AN_STATUS1_PAUSE_RSOLUTION_TXSIDE
value|0x0040
end_define

begin_define
define|#
directive|define
name|MDIO_GP_STATUS_TOP_AN_STATUS1_PAUSE_RSOLUTION_RXSIDE
value|0x0080
end_define

begin_define
define|#
directive|define
name|MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_MASK
value|0x3f00
end_define

begin_define
define|#
directive|define
name|MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_10M
value|0x0000
end_define

begin_define
define|#
directive|define
name|MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_100M
value|0x0100
end_define

begin_define
define|#
directive|define
name|MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_1G
value|0x0200
end_define

begin_define
define|#
directive|define
name|MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_2_5G
value|0x0300
end_define

begin_define
define|#
directive|define
name|MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_5G
value|0x0400
end_define

begin_define
define|#
directive|define
name|MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_6G
value|0x0500
end_define

begin_define
define|#
directive|define
name|MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_10G_HIG
value|0x0600
end_define

begin_define
define|#
directive|define
name|MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_10G_CX4
value|0x0700
end_define

begin_define
define|#
directive|define
name|MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_12G_HIG
value|0x0800
end_define

begin_define
define|#
directive|define
name|MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_12_5G
value|0x0900
end_define

begin_define
define|#
directive|define
name|MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_13G
value|0x0A00
end_define

begin_define
define|#
directive|define
name|MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_15G
value|0x0B00
end_define

begin_define
define|#
directive|define
name|MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_16G
value|0x0C00
end_define

begin_define
define|#
directive|define
name|MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_1G_KX
value|0x0D00
end_define

begin_define
define|#
directive|define
name|MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_10G_KX4
value|0x0E00
end_define

begin_define
define|#
directive|define
name|MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_10G_KR
value|0x0F00
end_define

begin_define
define|#
directive|define
name|MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_10G_XFI
value|0x1B00
end_define

begin_define
define|#
directive|define
name|MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_20G_DXGXS
value|0x1E00
end_define

begin_define
define|#
directive|define
name|MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_10G_SFI
value|0x1F00
end_define

begin_define
define|#
directive|define
name|MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_20G_KR2
value|0x3900
end_define

begin_define
define|#
directive|define
name|MDIO_REG_BANK_10G_PARALLEL_DETECT
value|0x8130
end_define

begin_define
define|#
directive|define
name|MDIO_10G_PARALLEL_DETECT_PAR_DET_10G_STATUS
value|0x10
end_define

begin_define
define|#
directive|define
name|MDIO_10G_PARALLEL_DETECT_PAR_DET_10G_STATUS_PD_LINK
value|0x8000
end_define

begin_define
define|#
directive|define
name|MDIO_10G_PARALLEL_DETECT_PAR_DET_10G_CONTROL
value|0x11
end_define

begin_define
define|#
directive|define
name|MDIO_10G_PARALLEL_DETECT_PAR_DET_10G_CONTROL_PARDET10G_EN
value|0x1
end_define

begin_define
define|#
directive|define
name|MDIO_10G_PARALLEL_DETECT_PAR_DET_10G_LINK
value|0x13
end_define

begin_define
define|#
directive|define
name|MDIO_10G_PARALLEL_DETECT_PAR_DET_10G_LINK_CNT
value|(0xb71<<1)
end_define

begin_define
define|#
directive|define
name|MDIO_REG_BANK_SERDES_DIGITAL
value|0x8300
end_define

begin_define
define|#
directive|define
name|MDIO_SERDES_DIGITAL_A_1000X_CONTROL1
value|0x10
end_define

begin_define
define|#
directive|define
name|MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_FIBER_MODE
value|0x0001
end_define

begin_define
define|#
directive|define
name|MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_TBI_IF
value|0x0002
end_define

begin_define
define|#
directive|define
name|MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_SIGNAL_DETECT_EN
value|0x0004
end_define

begin_define
define|#
directive|define
name|MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_INVERT_SIGNAL_DETECT
value|0x0008
end_define

begin_define
define|#
directive|define
name|MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_AUTODET
value|0x0010
end_define

begin_define
define|#
directive|define
name|MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_MSTR_MODE
value|0x0020
end_define

begin_define
define|#
directive|define
name|MDIO_SERDES_DIGITAL_A_1000X_CONTROL2
value|0x11
end_define

begin_define
define|#
directive|define
name|MDIO_SERDES_DIGITAL_A_1000X_CONTROL2_PRL_DT_EN
value|0x0001
end_define

begin_define
define|#
directive|define
name|MDIO_SERDES_DIGITAL_A_1000X_CONTROL2_AN_FST_TMR
value|0x0040
end_define

begin_define
define|#
directive|define
name|MDIO_SERDES_DIGITAL_A_1000X_STATUS1
value|0x14
end_define

begin_define
define|#
directive|define
name|MDIO_SERDES_DIGITAL_A_1000X_STATUS1_SGMII
value|0x0001
end_define

begin_define
define|#
directive|define
name|MDIO_SERDES_DIGITAL_A_1000X_STATUS1_LINK
value|0x0002
end_define

begin_define
define|#
directive|define
name|MDIO_SERDES_DIGITAL_A_1000X_STATUS1_DUPLEX
value|0x0004
end_define

begin_define
define|#
directive|define
name|MDIO_SERDES_DIGITAL_A_1000X_STATUS1_SPEED_MASK
value|0x0018
end_define

begin_define
define|#
directive|define
name|MDIO_SERDES_DIGITAL_A_1000X_STATUS1_SPEED_SHIFT
value|3
end_define

begin_define
define|#
directive|define
name|MDIO_SERDES_DIGITAL_A_1000X_STATUS1_SPEED_2_5G
value|0x0018
end_define

begin_define
define|#
directive|define
name|MDIO_SERDES_DIGITAL_A_1000X_STATUS1_SPEED_1G
value|0x0010
end_define

begin_define
define|#
directive|define
name|MDIO_SERDES_DIGITAL_A_1000X_STATUS1_SPEED_100M
value|0x0008
end_define

begin_define
define|#
directive|define
name|MDIO_SERDES_DIGITAL_A_1000X_STATUS1_SPEED_10M
value|0x0000
end_define

begin_define
define|#
directive|define
name|MDIO_SERDES_DIGITAL_A_1000X_STATUS2
value|0x15
end_define

begin_define
define|#
directive|define
name|MDIO_SERDES_DIGITAL_A_1000X_STATUS2_AN_DISABLED
value|0x0002
end_define

begin_define
define|#
directive|define
name|MDIO_SERDES_DIGITAL_MISC1
value|0x18
end_define

begin_define
define|#
directive|define
name|MDIO_SERDES_DIGITAL_MISC1_REFCLK_SEL_MASK
value|0xE000
end_define

begin_define
define|#
directive|define
name|MDIO_SERDES_DIGITAL_MISC1_REFCLK_SEL_25M
value|0x0000
end_define

begin_define
define|#
directive|define
name|MDIO_SERDES_DIGITAL_MISC1_REFCLK_SEL_100M
value|0x2000
end_define

begin_define
define|#
directive|define
name|MDIO_SERDES_DIGITAL_MISC1_REFCLK_SEL_125M
value|0x4000
end_define

begin_define
define|#
directive|define
name|MDIO_SERDES_DIGITAL_MISC1_REFCLK_SEL_156_25M
value|0x6000
end_define

begin_define
define|#
directive|define
name|MDIO_SERDES_DIGITAL_MISC1_REFCLK_SEL_187_5M
value|0x8000
end_define

begin_define
define|#
directive|define
name|MDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_SEL
value|0x0010
end_define

begin_define
define|#
directive|define
name|MDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_MASK
value|0x000f
end_define

begin_define
define|#
directive|define
name|MDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_2_5G
value|0x0000
end_define

begin_define
define|#
directive|define
name|MDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_5G
value|0x0001
end_define

begin_define
define|#
directive|define
name|MDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_6G
value|0x0002
end_define

begin_define
define|#
directive|define
name|MDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_10G_HIG
value|0x0003
end_define

begin_define
define|#
directive|define
name|MDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_10G_CX4
value|0x0004
end_define

begin_define
define|#
directive|define
name|MDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_12G
value|0x0005
end_define

begin_define
define|#
directive|define
name|MDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_12_5G
value|0x0006
end_define

begin_define
define|#
directive|define
name|MDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_13G
value|0x0007
end_define

begin_define
define|#
directive|define
name|MDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_15G
value|0x0008
end_define

begin_define
define|#
directive|define
name|MDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_16G
value|0x0009
end_define

begin_define
define|#
directive|define
name|MDIO_REG_BANK_OVER_1G
value|0x8320
end_define

begin_define
define|#
directive|define
name|MDIO_OVER_1G_DIGCTL_3_4
value|0x14
end_define

begin_define
define|#
directive|define
name|MDIO_OVER_1G_DIGCTL_3_4_MP_ID_MASK
value|0xffe0
end_define

begin_define
define|#
directive|define
name|MDIO_OVER_1G_DIGCTL_3_4_MP_ID_SHIFT
value|5
end_define

begin_define
define|#
directive|define
name|MDIO_OVER_1G_UP1
value|0x19
end_define

begin_define
define|#
directive|define
name|MDIO_OVER_1G_UP1_2_5G
value|0x0001
end_define

begin_define
define|#
directive|define
name|MDIO_OVER_1G_UP1_5G
value|0x0002
end_define

begin_define
define|#
directive|define
name|MDIO_OVER_1G_UP1_6G
value|0x0004
end_define

begin_define
define|#
directive|define
name|MDIO_OVER_1G_UP1_10G
value|0x0010
end_define

begin_define
define|#
directive|define
name|MDIO_OVER_1G_UP1_10GH
value|0x0008
end_define

begin_define
define|#
directive|define
name|MDIO_OVER_1G_UP1_12G
value|0x0020
end_define

begin_define
define|#
directive|define
name|MDIO_OVER_1G_UP1_12_5G
value|0x0040
end_define

begin_define
define|#
directive|define
name|MDIO_OVER_1G_UP1_13G
value|0x0080
end_define

begin_define
define|#
directive|define
name|MDIO_OVER_1G_UP1_15G
value|0x0100
end_define

begin_define
define|#
directive|define
name|MDIO_OVER_1G_UP1_16G
value|0x0200
end_define

begin_define
define|#
directive|define
name|MDIO_OVER_1G_UP2
value|0x1A
end_define

begin_define
define|#
directive|define
name|MDIO_OVER_1G_UP2_IPREDRIVER_MASK
value|0x0007
end_define

begin_define
define|#
directive|define
name|MDIO_OVER_1G_UP2_IDRIVER_MASK
value|0x0038
end_define

begin_define
define|#
directive|define
name|MDIO_OVER_1G_UP2_PREEMPHASIS_MASK
value|0x03C0
end_define

begin_define
define|#
directive|define
name|MDIO_OVER_1G_UP3
value|0x1B
end_define

begin_define
define|#
directive|define
name|MDIO_OVER_1G_UP3_HIGIG2
value|0x0001
end_define

begin_define
define|#
directive|define
name|MDIO_OVER_1G_LP_UP1
value|0x1C
end_define

begin_define
define|#
directive|define
name|MDIO_OVER_1G_LP_UP2
value|0x1D
end_define

begin_define
define|#
directive|define
name|MDIO_OVER_1G_LP_UP2_MR_ADV_OVER_1G_MASK
value|0x03ff
end_define

begin_define
define|#
directive|define
name|MDIO_OVER_1G_LP_UP2_PREEMPHASIS_MASK
value|0x0780
end_define

begin_define
define|#
directive|define
name|MDIO_OVER_1G_LP_UP2_PREEMPHASIS_SHIFT
value|7
end_define

begin_define
define|#
directive|define
name|MDIO_OVER_1G_LP_UP3
value|0x1E
end_define

begin_define
define|#
directive|define
name|MDIO_REG_BANK_REMOTE_PHY
value|0x8330
end_define

begin_define
define|#
directive|define
name|MDIO_REMOTE_PHY_MISC_RX_STATUS
value|0x10
end_define

begin_define
define|#
directive|define
name|MDIO_REMOTE_PHY_MISC_RX_STATUS_CL37_FSM_RECEIVED_OVER1G_MSG
value|0x0010
end_define

begin_define
define|#
directive|define
name|MDIO_REMOTE_PHY_MISC_RX_STATUS_CL37_FSM_RECEIVED_BRCM_OUI_MSG
value|0x0600
end_define

begin_define
define|#
directive|define
name|MDIO_REG_BANK_BAM_NEXT_PAGE
value|0x8350
end_define

begin_define
define|#
directive|define
name|MDIO_BAM_NEXT_PAGE_MP5_NEXT_PAGE_CTRL
value|0x10
end_define

begin_define
define|#
directive|define
name|MDIO_BAM_NEXT_PAGE_MP5_NEXT_PAGE_CTRL_BAM_MODE
value|0x0001
end_define

begin_define
define|#
directive|define
name|MDIO_BAM_NEXT_PAGE_MP5_NEXT_PAGE_CTRL_TETON_AN
value|0x0002
end_define

begin_define
define|#
directive|define
name|MDIO_REG_BANK_CL73_USERB0
value|0x8370
end_define

begin_define
define|#
directive|define
name|MDIO_CL73_USERB0_CL73_UCTRL
value|0x10
end_define

begin_define
define|#
directive|define
name|MDIO_CL73_USERB0_CL73_UCTRL_USTAT1_MUXSEL
value|0x0002
end_define

begin_define
define|#
directive|define
name|MDIO_CL73_USERB0_CL73_USTAT1
value|0x11
end_define

begin_define
define|#
directive|define
name|MDIO_CL73_USERB0_CL73_USTAT1_LINK_STATUS_CHECK
value|0x0100
end_define

begin_define
define|#
directive|define
name|MDIO_CL73_USERB0_CL73_USTAT1_AN_GOOD_CHECK_BAM37
value|0x0400
end_define

begin_define
define|#
directive|define
name|MDIO_CL73_USERB0_CL73_BAM_CTRL1
value|0x12
end_define

begin_define
define|#
directive|define
name|MDIO_CL73_USERB0_CL73_BAM_CTRL1_BAM_EN
value|0x8000
end_define

begin_define
define|#
directive|define
name|MDIO_CL73_USERB0_CL73_BAM_CTRL1_BAM_STATION_MNGR_EN
value|0x4000
end_define

begin_define
define|#
directive|define
name|MDIO_CL73_USERB0_CL73_BAM_CTRL1_BAM_NP_AFTER_BP_EN
value|0x2000
end_define

begin_define
define|#
directive|define
name|MDIO_CL73_USERB0_CL73_BAM_CTRL3
value|0x14
end_define

begin_define
define|#
directive|define
name|MDIO_CL73_USERB0_CL73_BAM_CTRL3_USE_CL73_HCD_MR
value|0x0001
end_define

begin_define
define|#
directive|define
name|MDIO_REG_BANK_AER_BLOCK
value|0xFFD0
end_define

begin_define
define|#
directive|define
name|MDIO_AER_BLOCK_AER_REG
value|0x1E
end_define

begin_define
define|#
directive|define
name|MDIO_REG_BANK_COMBO_IEEE0
value|0xFFE0
end_define

begin_define
define|#
directive|define
name|MDIO_COMBO_IEEE0_MII_CONTROL
value|0x10
end_define

begin_define
define|#
directive|define
name|MDIO_COMBO_IEEO_MII_CONTROL_MAN_SGMII_SP_MASK
value|0x2040
end_define

begin_define
define|#
directive|define
name|MDIO_COMBO_IEEO_MII_CONTROL_MAN_SGMII_SP_10
value|0x0000
end_define

begin_define
define|#
directive|define
name|MDIO_COMBO_IEEO_MII_CONTROL_MAN_SGMII_SP_100
value|0x2000
end_define

begin_define
define|#
directive|define
name|MDIO_COMBO_IEEO_MII_CONTROL_MAN_SGMII_SP_1000
value|0x0040
end_define

begin_define
define|#
directive|define
name|MDIO_COMBO_IEEO_MII_CONTROL_FULL_DUPLEX
value|0x0100
end_define

begin_define
define|#
directive|define
name|MDIO_COMBO_IEEO_MII_CONTROL_RESTART_AN
value|0x0200
end_define

begin_define
define|#
directive|define
name|MDIO_COMBO_IEEO_MII_CONTROL_AN_EN
value|0x1000
end_define

begin_define
define|#
directive|define
name|MDIO_COMBO_IEEO_MII_CONTROL_LOOPBACK
value|0x4000
end_define

begin_define
define|#
directive|define
name|MDIO_COMBO_IEEO_MII_CONTROL_RESET
value|0x8000
end_define

begin_define
define|#
directive|define
name|MDIO_COMBO_IEEE0_MII_STATUS
value|0x11
end_define

begin_define
define|#
directive|define
name|MDIO_COMBO_IEEE0_MII_STATUS_LINK_PASS
value|0x0004
end_define

begin_define
define|#
directive|define
name|MDIO_COMBO_IEEE0_MII_STATUS_AUTONEG_COMPLETE
value|0x0020
end_define

begin_define
define|#
directive|define
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV
value|0x14
end_define

begin_define
define|#
directive|define
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_FULL_DUPLEX
value|0x0020
end_define

begin_define
define|#
directive|define
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_HALF_DUPLEX
value|0x0040
end_define

begin_define
define|#
directive|define
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_MASK
value|0x0180
end_define

begin_define
define|#
directive|define
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_NONE
value|0x0000
end_define

begin_define
define|#
directive|define
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_SYMMETRIC
value|0x0080
end_define

begin_define
define|#
directive|define
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC
value|0x0100
end_define

begin_define
define|#
directive|define
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH
value|0x0180
end_define

begin_define
define|#
directive|define
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_NEXT_PAGE
value|0x8000
end_define

begin_define
define|#
directive|define
name|MDIO_COMBO_IEEE0_AUTO_NEG_LINK_PARTNER_ABILITY1
value|0x15
end_define

begin_define
define|#
directive|define
name|MDIO_COMBO_IEEE0_AUTO_NEG_LINK_PARTNER_ABILITY1_NEXT_PAGE
value|0x8000
end_define

begin_define
define|#
directive|define
name|MDIO_COMBO_IEEE0_AUTO_NEG_LINK_PARTNER_ABILITY1_ACK
value|0x4000
end_define

begin_define
define|#
directive|define
name|MDIO_COMBO_IEEE0_AUTO_NEG_LINK_PARTNER_ABILITY1_PAUSE_MASK
value|0x0180
end_define

begin_define
define|#
directive|define
name|MDIO_COMBO_IEEE0_AUTO_NEG_LINK_PARTNER_ABILITY1_PAUSE_NONE
value|0x0000
end_define

begin_define
define|#
directive|define
name|MDIO_COMBO_IEEE0_AUTO_NEG_LINK_PARTNER_ABILITY1_PAUSE_BOTH
value|0x0180
end_define

begin_define
define|#
directive|define
name|MDIO_COMBO_IEEE0_AUTO_NEG_LINK_PARTNER_ABILITY1_HALF_DUP_CAP
value|0x0040
end_define

begin_define
define|#
directive|define
name|MDIO_COMBO_IEEE0_AUTO_NEG_LINK_PARTNER_ABILITY1_FULL_DUP_CAP
value|0x0020
end_define

begin_comment
comment|/*WhenthelinkpartnerisinSGMIImode(bit0=1),then bit15=link,bit12=duplex,bits11:10=speed,bit14=acknowledge. Theotherbitsarereservedandshouldbezero*/
end_comment

begin_define
define|#
directive|define
name|MDIO_COMBO_IEEE0_AUTO_NEG_LINK_PARTNER_ABILITY1_SGMII_MODE
value|0x0001
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_DEVAD
value|0x1
end_define

begin_comment
comment|/*ieee*/
end_comment

begin_define
define|#
directive|define
name|MDIO_PMA_REG_CTRL
value|0x0
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_STATUS
value|0x1
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_10G_CTRL2
value|0x7
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_TX_DISABLE
value|0x0009
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_RX_SD
value|0xa
end_define

begin_comment
comment|/*bcm*/
end_comment

begin_define
define|#
directive|define
name|MDIO_PMA_REG_BCM_CTRL
value|0x0096
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_FEC_CTRL
value|0x00ab
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_LASI_RXCTRL
value|0x9000
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_LASI_TXCTRL
value|0x9001
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_LASI_CTRL
value|0x9002
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_LASI_RXSTAT
value|0x9003
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_LASI_TXSTAT
value|0x9004
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_LASI_STAT
value|0x9005
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_PHY_IDENTIFIER
value|0xc800
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_DIGITAL_CTRL
value|0xc808
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_DIGITAL_STATUS
value|0xc809
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_TX_POWER_DOWN
value|0xca02
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_CMU_PLL_BYPASS
value|0xca09
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_MISC_CTRL
value|0xca0a
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_GEN_CTRL
value|0xca10
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_GEN_CTRL_ROM_RESET_INTERNAL_MP
value|0x0188
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_GEN_CTRL_ROM_MICRO_RESET
value|0x018a
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_M8051_MSGIN_REG
value|0xca12
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_M8051_MSGOUT_REG
value|0xca13
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_ROM_VER1
value|0xca19
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_ROM_VER2
value|0xca1a
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_EDC_FFE_MAIN
value|0xca1b
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_PLL_BANDWIDTH
value|0xca1d
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_PLL_CTRL
value|0xca1e
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_MISC_CTRL0
value|0xca23
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_LRM_MODE
value|0xca3f
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_CDR_BANDWIDTH
value|0xca46
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_MISC_CTRL1
value|0xca85
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_SFP_TWO_WIRE_CTRL
value|0x8000
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_SFP_TWO_WIRE_CTRL_STATUS_MASK
value|0x000c
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_SFP_TWO_WIRE_STATUS_IDLE
value|0x0000
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_SFP_TWO_WIRE_STATUS_COMPLETE
value|0x0004
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_SFP_TWO_WIRE_STATUS_IN_PROGRESS
value|0x0008
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_SFP_TWO_WIRE_STATUS_FAILED
value|0x000c
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_SFP_TWO_WIRE_BYTE_CNT
value|0x8002
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_SFP_TWO_WIRE_MEM_ADDR
value|0x8003
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_8726_TWO_WIRE_DATA_BUF
value|0xc820
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_8726_TWO_WIRE_DATA_MASK
value|0xff
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_8726_TX_CTRL1
value|0xca01
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_8726_TX_CTRL2
value|0xca05
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_8727_TWO_WIRE_SLAVE_ADDR
value|0x8005
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_8727_TWO_WIRE_DATA_BUF
value|0x8007
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_8727_TWO_WIRE_DATA_MASK
value|0xff
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_8727_MISC_CTRL
value|0x8309
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_8727_TX_CTRL1
value|0xca02
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_8727_TX_CTRL2
value|0xca05
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_8727_PCS_OPT_CTRL
value|0xc808
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_8727_GPIO_CTRL
value|0xc80e
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_8727_PCS_GP
value|0xc842
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_8727_OPT_CFG_REG
value|0xc8e4
end_define

begin_define
define|#
directive|define
name|MDIO_AN_REG_8727_MISC_CTRL
value|0x8309
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_8073_CHIP_REV
value|0xc801
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_8073_SPEED_LINK_STATUS
value|0xc820
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_8073_XAUI_WA
value|0xc841
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_8073_OPT_DIGITAL_CTRL
value|0xcd08
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_7101_RESET
value|0xc000
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_7107_LED_CNTL
value|0xc007
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_7107_LINK_LED_CNTL
value|0xc009
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_7101_VER1
value|0xc026
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_7101_VER2
value|0xc027
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_8481_PMD_SIGNAL
value|0xa811
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_8481_LED1_MASK
value|0xa82c
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_8481_LED2_MASK
value|0xa82f
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_8481_LED3_MASK
value|0xa832
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_8481_LED3_BLINK
value|0xa834
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_8481_LED5_MASK
value|0xa838
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_8481_SIGNAL_MASK
value|0xa835
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_8481_LINK_SIGNAL
value|0xa83b
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_8481_LINK_SIGNAL_LED4_ENABLE_MASK
value|0x800
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_8481_LINK_SIGNAL_LED4_ENABLE_SHIFT
value|11
end_define

begin_define
define|#
directive|define
name|MDIO_WIS_DEVAD
value|0x2
end_define

begin_comment
comment|/*bcm*/
end_comment

begin_define
define|#
directive|define
name|MDIO_WIS_REG_LASI_CNTL
value|0x9002
end_define

begin_define
define|#
directive|define
name|MDIO_WIS_REG_LASI_STATUS
value|0x9005
end_define

begin_define
define|#
directive|define
name|MDIO_PCS_DEVAD
value|0x3
end_define

begin_define
define|#
directive|define
name|MDIO_PCS_REG_STATUS
value|0x0020
end_define

begin_define
define|#
directive|define
name|MDIO_PCS_REG_LASI_STATUS
value|0x9005
end_define

begin_define
define|#
directive|define
name|MDIO_PCS_REG_7101_DSP_ACCESS
value|0xD000
end_define

begin_define
define|#
directive|define
name|MDIO_PCS_REG_7101_SPI_MUX
value|0xD008
end_define

begin_define
define|#
directive|define
name|MDIO_PCS_REG_7101_SPI_CTRL_ADDR
value|0xE12A
end_define

begin_define
define|#
directive|define
name|MDIO_PCS_REG_7101_SPI_RESET_BIT
value|(5)
end_define

begin_define
define|#
directive|define
name|MDIO_PCS_REG_7101_SPI_FIFO_ADDR
value|0xE02A
end_define

begin_define
define|#
directive|define
name|MDIO_PCS_REG_7101_SPI_FIFO_ADDR_WRITE_ENABLE_CMD
value|(6)
end_define

begin_define
define|#
directive|define
name|MDIO_PCS_REG_7101_SPI_FIFO_ADDR_BULK_ERASE_CMD
value|(0xC7)
end_define

begin_define
define|#
directive|define
name|MDIO_PCS_REG_7101_SPI_FIFO_ADDR_PAGE_PROGRAM_CMD
value|(2)
end_define

begin_define
define|#
directive|define
name|MDIO_PCS_REG_7101_SPI_BYTES_TO_TRANSFER_ADDR
value|0xE028
end_define

begin_define
define|#
directive|define
name|MDIO_XS_DEVAD
value|0x4
end_define

begin_define
define|#
directive|define
name|MDIO_XS_REG_STATUS
value|0x0001
end_define

begin_define
define|#
directive|define
name|MDIO_XS_PLL_SEQUENCER
value|0x8000
end_define

begin_define
define|#
directive|define
name|MDIO_XS_SFX7101_XGXS_TEST1
value|0xc00a
end_define

begin_define
define|#
directive|define
name|MDIO_XS_8706_REG_BANK_RX0
value|0x80bc
end_define

begin_define
define|#
directive|define
name|MDIO_XS_8706_REG_BANK_RX1
value|0x80cc
end_define

begin_define
define|#
directive|define
name|MDIO_XS_8706_REG_BANK_RX2
value|0x80dc
end_define

begin_define
define|#
directive|define
name|MDIO_XS_8706_REG_BANK_RX3
value|0x80ec
end_define

begin_define
define|#
directive|define
name|MDIO_XS_8706_REG_BANK_RXA
value|0x80fc
end_define

begin_define
define|#
directive|define
name|MDIO_XS_REG_8073_RX_CTRL_PCIE
value|0x80FA
end_define

begin_define
define|#
directive|define
name|MDIO_AN_DEVAD
value|0x7
end_define

begin_comment
comment|/*ieee*/
end_comment

begin_define
define|#
directive|define
name|MDIO_AN_REG_CTRL
value|0x0000
end_define

begin_define
define|#
directive|define
name|MDIO_AN_REG_STATUS
value|0x0001
end_define

begin_define
define|#
directive|define
name|MDIO_AN_REG_STATUS_AN_COMPLETE
value|0x0020
end_define

begin_define
define|#
directive|define
name|MDIO_AN_REG_ADV_PAUSE
value|0x0010
end_define

begin_define
define|#
directive|define
name|MDIO_AN_REG_ADV_PAUSE_PAUSE
value|0x0400
end_define

begin_define
define|#
directive|define
name|MDIO_AN_REG_ADV_PAUSE_ASYMMETRIC
value|0x0800
end_define

begin_define
define|#
directive|define
name|MDIO_AN_REG_ADV_PAUSE_BOTH
value|0x0C00
end_define

begin_define
define|#
directive|define
name|MDIO_AN_REG_ADV_PAUSE_MASK
value|0x0C00
end_define

begin_define
define|#
directive|define
name|MDIO_AN_REG_ADV
value|0x0011
end_define

begin_define
define|#
directive|define
name|MDIO_AN_REG_ADV2
value|0x0012
end_define

begin_define
define|#
directive|define
name|MDIO_AN_REG_LP_AUTO_NEG
value|0x0013
end_define

begin_define
define|#
directive|define
name|MDIO_AN_REG_LP_AUTO_NEG2
value|0x0014
end_define

begin_define
define|#
directive|define
name|MDIO_AN_REG_MASTER_STATUS
value|0x0021
end_define

begin_define
define|#
directive|define
name|MDIO_AN_REG_EEE_ADV
value|0x003c
end_define

begin_define
define|#
directive|define
name|MDIO_AN_REG_LP_EEE_ADV
value|0x003d
end_define

begin_comment
comment|/*bcm*/
end_comment

begin_define
define|#
directive|define
name|MDIO_AN_REG_LINK_STATUS
value|0x8304
end_define

begin_define
define|#
directive|define
name|MDIO_AN_REG_CL37_CL73
value|0x8370
end_define

begin_define
define|#
directive|define
name|MDIO_AN_REG_CL37_AN
value|0xffe0
end_define

begin_define
define|#
directive|define
name|MDIO_AN_REG_CL37_FC_LD
value|0xffe4
end_define

begin_define
define|#
directive|define
name|MDIO_AN_REG_CL37_FC_LP
value|0xffe5
end_define

begin_define
define|#
directive|define
name|MDIO_AN_REG_1000T_STATUS
value|0xffea
end_define

begin_define
define|#
directive|define
name|MDIO_AN_REG_8073_2_5G
value|0x8329
end_define

begin_define
define|#
directive|define
name|MDIO_AN_REG_8073_BAM
value|0x8350
end_define

begin_define
define|#
directive|define
name|MDIO_AN_REG_8481_10GBASE_T_AN_CTRL
value|0x0020
end_define

begin_define
define|#
directive|define
name|MDIO_AN_REG_8481_LEGACY_MII_CTRL
value|0xffe0
end_define

begin_define
define|#
directive|define
name|MDIO_AN_REG_8481_MII_CTRL_FORCE_1G
value|0x40
end_define

begin_define
define|#
directive|define
name|MDIO_AN_REG_8481_LEGACY_MII_STATUS
value|0xffe1
end_define

begin_define
define|#
directive|define
name|MDIO_AN_REG_848xx_ID_MSB
value|0xffe2
end_define

begin_define
define|#
directive|define
name|BCM84858_PHY_ID
value|0x600d
end_define

begin_define
define|#
directive|define
name|MDIO_AN_REG_848xx_ID_LSB
value|0xffe3
end_define

begin_define
define|#
directive|define
name|MDIO_AN_REG_8481_LEGACY_AN_ADV
value|0xffe4
end_define

begin_define
define|#
directive|define
name|MDIO_AN_REG_8481_LEGACY_AN_EXPANSION
value|0xffe6
end_define

begin_define
define|#
directive|define
name|MDIO_AN_REG_8481_1000T_CTRL
value|0xffe9
end_define

begin_define
define|#
directive|define
name|MDIO_AN_REG_8481_1G_100T_EXT_CTRL
value|0xfff0
end_define

begin_define
define|#
directive|define
name|MIDO_AN_REG_8481_EXT_CTRL_FORCE_LEDS_OFF
value|0x0008
end_define

begin_define
define|#
directive|define
name|MDIO_AN_REG_8481_EXPANSION_REG_RD_RW
value|0xfff5
end_define

begin_define
define|#
directive|define
name|MDIO_AN_REG_8481_EXPANSION_REG_ACCESS
value|0xfff7
end_define

begin_define
define|#
directive|define
name|MDIO_AN_REG_8481_AUX_CTRL
value|0xfff8
end_define

begin_define
define|#
directive|define
name|MDIO_AN_REG_8481_LEGACY_SHADOW
value|0xfffc
end_define

begin_comment
comment|/* BCM84823 only */
end_comment

begin_define
define|#
directive|define
name|MDIO_CTL_DEVAD
value|0x1e
end_define

begin_define
define|#
directive|define
name|MDIO_CTL_REG_84823_MEDIA
value|0x401a
end_define

begin_define
define|#
directive|define
name|MDIO_CTL_REG_84823_MEDIA_MAC_MASK
value|0x0018
end_define

begin_comment
comment|/* These pins configure the BCM84823 interface to MAC after reset. */
end_comment

begin_define
define|#
directive|define
name|MDIO_CTL_REG_84823_CTRL_MAC_XFI
value|0x0008
end_define

begin_define
define|#
directive|define
name|MDIO_CTL_REG_84823_MEDIA_MAC_XAUI_M
value|0x0010
end_define

begin_comment
comment|/* These pins configure the BCM84823 interface to Line after reset. */
end_comment

begin_define
define|#
directive|define
name|MDIO_CTL_REG_84823_MEDIA_LINE_MASK
value|0x0060
end_define

begin_define
define|#
directive|define
name|MDIO_CTL_REG_84823_MEDIA_LINE_XAUI_L
value|0x0020
end_define

begin_define
define|#
directive|define
name|MDIO_CTL_REG_84823_MEDIA_LINE_XFI
value|0x0040
end_define

begin_comment
comment|/* When this pin is active high during reset, 10GBASE-T core is power 	 * down, When it is active low the 10GBASE-T is power up 	 */
end_comment

begin_define
define|#
directive|define
name|MDIO_CTL_REG_84823_MEDIA_COPPER_CORE_DOWN
value|0x0080
end_define

begin_define
define|#
directive|define
name|MDIO_CTL_REG_84823_MEDIA_PRIORITY_MASK
value|0x0100
end_define

begin_define
define|#
directive|define
name|MDIO_CTL_REG_84823_MEDIA_PRIORITY_COPPER
value|0x0000
end_define

begin_define
define|#
directive|define
name|MDIO_CTL_REG_84823_MEDIA_PRIORITY_FIBER
value|0x0100
end_define

begin_define
define|#
directive|define
name|MDIO_CTL_REG_84823_MEDIA_FIBER_1G
value|0x1000
end_define

begin_define
define|#
directive|define
name|MDIO_CTL_REG_84823_USER_CTRL_REG
value|0x4005
end_define

begin_define
define|#
directive|define
name|MDIO_CTL_REG_84823_USER_CTRL_CMS
value|0x0080
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_84823_CTL_SLOW_CLK_CNT_HIGH
value|0xa82b
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_84823_BLINK_RATE_VAL_15P9HZ
value|0x2f
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_84823_CTL_LED_CTL_1
value|0xa8e3
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_84833_CTL_LED_CTL_1
value|0xa8ec
end_define

begin_define
define|#
directive|define
name|MDIO_PMA_REG_84823_LED3_STRETCH_EN
value|0x0080
end_define

begin_comment
comment|/* BCM84833 only */
end_comment

begin_define
define|#
directive|define
name|MDIO_84833_TOP_CFG_FW_REV
value|0x400f
end_define

begin_define
define|#
directive|define
name|MDIO_84833_TOP_CFG_FW_EEE
value|0x10b1
end_define

begin_define
define|#
directive|define
name|MDIO_84833_TOP_CFG_FW_NO_EEE
value|0x1f81
end_define

begin_define
define|#
directive|define
name|MDIO_84833_TOP_CFG_XGPHY_STRAP1
value|0x401a
end_define

begin_define
define|#
directive|define
name|MDIO_84833_SUPER_ISOLATE
value|0x8000
end_define

begin_comment
comment|/* These are mailbox register set used by 84833/84858. */
end_comment

begin_define
define|#
directive|define
name|MDIO_848xx_TOP_CFG_SCRATCH_REG0
value|0x4005
end_define

begin_define
define|#
directive|define
name|MDIO_848xx_TOP_CFG_SCRATCH_REG1
value|0x4006
end_define

begin_define
define|#
directive|define
name|MDIO_848xx_TOP_CFG_SCRATCH_REG2
value|0x4007
end_define

begin_define
define|#
directive|define
name|MDIO_848xx_TOP_CFG_SCRATCH_REG3
value|0x4008
end_define

begin_define
define|#
directive|define
name|MDIO_848xx_TOP_CFG_SCRATCH_REG4
value|0x4009
end_define

begin_define
define|#
directive|define
name|MDIO_848xx_TOP_CFG_SCRATCH_REG26
value|0x4037
end_define

begin_define
define|#
directive|define
name|MDIO_848xx_TOP_CFG_SCRATCH_REG27
value|0x4038
end_define

begin_define
define|#
directive|define
name|MDIO_848xx_TOP_CFG_SCRATCH_REG28
value|0x4039
end_define

begin_define
define|#
directive|define
name|MDIO_848xx_TOP_CFG_SCRATCH_REG29
value|0x403a
end_define

begin_define
define|#
directive|define
name|MDIO_848xx_TOP_CFG_SCRATCH_REG30
value|0x403b
end_define

begin_define
define|#
directive|define
name|MDIO_848xx_TOP_CFG_SCRATCH_REG31
value|0x403c
end_define

begin_define
define|#
directive|define
name|MDIO_848xx_CMD_HDLR_COMMAND
value|(MDIO_848xx_TOP_CFG_SCRATCH_REG0)
end_define

begin_define
define|#
directive|define
name|MDIO_848xx_CMD_HDLR_STATUS
value|(MDIO_848xx_TOP_CFG_SCRATCH_REG26)
end_define

begin_define
define|#
directive|define
name|MDIO_848xx_CMD_HDLR_DATA1
value|(MDIO_848xx_TOP_CFG_SCRATCH_REG27)
end_define

begin_define
define|#
directive|define
name|MDIO_848xx_CMD_HDLR_DATA2
value|(MDIO_848xx_TOP_CFG_SCRATCH_REG28)
end_define

begin_define
define|#
directive|define
name|MDIO_848xx_CMD_HDLR_DATA3
value|(MDIO_848xx_TOP_CFG_SCRATCH_REG29)
end_define

begin_define
define|#
directive|define
name|MDIO_848xx_CMD_HDLR_DATA4
value|(MDIO_848xx_TOP_CFG_SCRATCH_REG30)
end_define

begin_define
define|#
directive|define
name|MDIO_848xx_CMD_HDLR_DATA5
value|(MDIO_848xx_TOP_CFG_SCRATCH_REG31)
end_define

begin_comment
comment|/* Mailbox command set used by 84833/84858 */
end_comment

begin_define
define|#
directive|define
name|PHY848xx_CMD_SET_PAIR_SWAP
value|0x8001
end_define

begin_define
define|#
directive|define
name|PHY848xx_CMD_GET_EEE_MODE
value|0x8008
end_define

begin_define
define|#
directive|define
name|PHY848xx_CMD_SET_EEE_MODE
value|0x8009
end_define

begin_define
define|#
directive|define
name|PHY848xx_CMD_GET_CURRENT_TEMP
value|0x8031
end_define

begin_comment
comment|/* Mailbox status set used by 84833 only */
end_comment

begin_define
define|#
directive|define
name|PHY84833_STATUS_CMD_RECEIVED
value|0x0001
end_define

begin_define
define|#
directive|define
name|PHY84833_STATUS_CMD_IN_PROGRESS
value|0x0002
end_define

begin_define
define|#
directive|define
name|PHY84833_STATUS_CMD_COMPLETE_PASS
value|0x0004
end_define

begin_define
define|#
directive|define
name|PHY84833_STATUS_CMD_COMPLETE_ERROR
value|0x0008
end_define

begin_define
define|#
directive|define
name|PHY84833_STATUS_CMD_OPEN_FOR_CMDS
value|0x0010
end_define

begin_define
define|#
directive|define
name|PHY84833_STATUS_CMD_SYSTEM_BOOT
value|0x0020
end_define

begin_define
define|#
directive|define
name|PHY84833_STATUS_CMD_NOT_OPEN_FOR_CMDS
value|0x0040
end_define

begin_define
define|#
directive|define
name|PHY84833_STATUS_CMD_CLEAR_COMPLETE
value|0x0080
end_define

begin_define
define|#
directive|define
name|PHY84833_STATUS_CMD_OPEN_OVERRIDE
value|0xa5a5
end_define

begin_comment
comment|/* Mailbox Process */
end_comment

begin_define
define|#
directive|define
name|PHY84833_MB_PROCESS1
value|1
end_define

begin_define
define|#
directive|define
name|PHY84833_MB_PROCESS2
value|2
end_define

begin_define
define|#
directive|define
name|PHY84833_MB_PROCESS3
value|3
end_define

begin_comment
comment|/* Mailbox status set used by 84858 only */
end_comment

begin_define
define|#
directive|define
name|PHY84858_STATUS_CMD_RECEIVED
value|0x0001
end_define

begin_define
define|#
directive|define
name|PHY84858_STATUS_CMD_IN_PROGRESS
value|0x0002
end_define

begin_define
define|#
directive|define
name|PHY84858_STATUS_CMD_COMPLETE_PASS
value|0x0004
end_define

begin_define
define|#
directive|define
name|PHY84858_STATUS_CMD_COMPLETE_ERROR
value|0x0008
end_define

begin_define
define|#
directive|define
name|PHY84858_STATUS_CMD_SYSTEM_BUSY
value|0xbbbb
end_define

begin_comment
comment|/* Warpcore clause 45 addressing */
end_comment

begin_define
define|#
directive|define
name|MDIO_WC_DEVAD
value|0x3
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_IEEE0BLK_MIICNTL
value|0x0
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_IEEE0BLK_AUTONEGNP
value|0x7
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_AN_IEEE1BLK_AN_ADVERTISEMENT0
value|0x10
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_AN_IEEE1BLK_AN_ADVERTISEMENT1
value|0x11
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_AN_IEEE1BLK_AN_ADVERTISEMENT2
value|0x12
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_AN_IEEE1BLK_AN_ADV2_FEC_ABILITY
value|0x4000
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_AN_IEEE1BLK_AN_ADV2_FEC_REQ
value|0x8000
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_PCS_STATUS2
value|0x0021
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_PMD_KR_CONTROL
value|0x0096
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_XGXSBLK0_XGXSCONTROL
value|0x8000
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_XGXSBLK0_MISCCONTROL1
value|0x800e
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_XGXSBLK1_DESKEW
value|0x8010
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_XGXSBLK1_LANECTRL0
value|0x8015
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_XGXSBLK1_LANECTRL1
value|0x8016
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_XGXSBLK1_LANECTRL2
value|0x8017
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_XGXSBLK1_LANECTRL3
value|0x8018
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_XGXSBLK1_LANETEST0
value|0x801a
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_TX0_ANA_CTRL0
value|0x8061
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_TX1_ANA_CTRL0
value|0x8071
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_TX2_ANA_CTRL0
value|0x8081
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_TX3_ANA_CTRL0
value|0x8091
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_TX0_TX_DRIVER
value|0x8067
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_TX0_TX_DRIVER_IFIR_OFFSET
value|0x01
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_TX0_TX_DRIVER_IFIR_MASK
value|0x000e
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_TX0_TX_DRIVER_IPRE_DRIVER_OFFSET
value|0x04
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_TX0_TX_DRIVER_IPRE_DRIVER_MASK
value|0x00f0
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_TX0_TX_DRIVER_IDRIVER_OFFSET
value|0x08
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_TX0_TX_DRIVER_IDRIVER_MASK
value|0x0f00
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_TX0_TX_DRIVER_POST2_COEFF_OFFSET
value|0x0c
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_TX0_TX_DRIVER_POST2_COEFF_MASK
value|0x7000
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_TX1_TX_DRIVER
value|0x8077
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_TX2_TX_DRIVER
value|0x8087
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_TX3_TX_DRIVER
value|0x8097
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_RX0_ANARXCONTROL1G
value|0x80b9
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_RX2_ANARXCONTROL1G
value|0x80d9
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_RX0_PCI_CTRL
value|0x80ba
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_RX1_PCI_CTRL
value|0x80ca
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_RX2_PCI_CTRL
value|0x80da
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_RX3_PCI_CTRL
value|0x80ea
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_RXB_ANA_RX_CONTROL_PCI
value|0x80fa
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_XGXSBLK2_UNICORE_MODE_10G
value|0x8104
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_XGXSBLK2_LANE_RESET
value|0x810a
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_XGXS_STATUS3
value|0x8129
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_PAR_DET_10G_STATUS
value|0x8130
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_PAR_DET_10G_CTRL
value|0x8131
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_XGXS_STATUS4
value|0x813c
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_XGXS_X2_CONTROL2
value|0x8141
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_XGXS_X2_CONTROL3
value|0x8142
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_XGXS_RX_LN_SWAP1
value|0x816B
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_XGXS_TX_LN_SWAP1
value|0x8169
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_GP2_STATUS_GP_2_0
value|0x81d0
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_GP2_STATUS_GP_2_1
value|0x81d1
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_GP2_STATUS_GP_2_2
value|0x81d2
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_GP2_STATUS_GP_2_3
value|0x81d3
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_GP2_STATUS_GP_2_4
value|0x81d4
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_GP2_STATUS_GP_2_4_CL73_AN_CMPL
value|0x1000
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_GP2_STATUS_GP_2_4_CL37_AN_CMPL
value|0x0100
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_GP2_STATUS_GP_2_4_CL37_LP_AN_CAP
value|0x0010
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_GP2_STATUS_GP_2_4_CL37_AN_CAP
value|0x1
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_UC_INFO_B0_DEAD_TRAP
value|0x81EE
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_UC_INFO_B1_VERSION
value|0x81F0
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_UC_INFO_B1_FIRMWARE_MODE
value|0x81F2
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_UC_INFO_B1_FIRMWARE_LANE0_OFFSET
value|0x0
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_UC_INFO_B1_FIRMWARE_MODE_DEFAULT
value|0x0
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_UC_INFO_B1_FIRMWARE_MODE_SFP_OPT_LR
value|0x1
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_UC_INFO_B1_FIRMWARE_MODE_SFP_DAC
value|0x2
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_UC_INFO_B1_FIRMWARE_MODE_SFP_XLAUI
value|0x3
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_UC_INFO_B1_FIRMWARE_MODE_LONG_CH_6G
value|0x4
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_UC_INFO_B1_FIRMWARE_LANE1_OFFSET
value|0x4
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_UC_INFO_B1_FIRMWARE_LANE2_OFFSET
value|0x8
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_UC_INFO_B1_FIRMWARE_LANE3_OFFSET
value|0xc
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_UC_INFO_B1_CRC
value|0x81FE
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_DSC1B0_UC_CTRL
value|0x820e
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_DSC1B0_UC_CTRL_RDY4CMD
value|(1<<7)
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_DSC_SMC
value|0x8213
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_DSC2B0_DSC_MISC_CTRL0
value|0x821e
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_TX_FIR_TAP
value|0x82e2
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_TX_FIR_TAP_PRE_TAP_OFFSET
value|0x00
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_TX_FIR_TAP_PRE_TAP_MASK
value|0x000f
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_TX_FIR_TAP_MAIN_TAP_OFFSET
value|0x04
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_TX_FIR_TAP_MAIN_TAP_MASK
value|0x03f0
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_TX_FIR_TAP_POST_TAP_OFFSET
value|0x0a
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_TX_FIR_TAP_POST_TAP_MASK
value|0x7c00
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_TX_FIR_TAP_ENABLE
value|0x8000
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_CL72_USERB0_CL72_TX_FIR_TAP
value|0x82e2
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_CL72_USERB0_CL72_MISC1_CONTROL
value|0x82e3
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_CL72_USERB0_CL72_OS_DEF_CTRL
value|0x82e6
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_CL72_USERB0_CL72_BR_DEF_CTRL
value|0x82e7
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_CL72_USERB0_CL72_2P5_DEF_CTRL
value|0x82e8
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_CL72_USERB0_CL72_MISC4_CONTROL
value|0x82ec
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X1
value|0x8300
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X2
value|0x8301
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X3
value|0x8302
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_SERDESDIGITAL_STATUS1000X1
value|0x8304
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_SERDESDIGITAL_MISC1
value|0x8308
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_SERDESDIGITAL_MISC2
value|0x8309
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_DIGITAL3_UP1
value|0x8329
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_DIGITAL3_LP_UP1
value|0x832c
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_DIGITAL4_MISC3
value|0x833c
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_DIGITAL4_MISC5
value|0x833e
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_DIGITAL5_MISC6
value|0x8345
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_DIGITAL5_MISC7
value|0x8349
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_DIGITAL5_LINK_STATUS
value|0x834d
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_DIGITAL5_ACTUAL_SPEED
value|0x834e
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_DIGITAL6_MP5_NEXTPAGECTRL
value|0x8350
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_CL49_USERB0_CTRL
value|0x8368
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_CL73_USERB0_CTRL
value|0x8370
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_CL73_USERB0_USTAT
value|0x8371
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_CL73_BAM_CTRL1
value|0x8372
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_CL73_BAM_CTRL2
value|0x8373
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_CL73_BAM_CTRL3
value|0x8374
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_CL73_BAM_CODE_FIELD
value|0x837b
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_EEE_COMBO_CONTROL0
value|0x8390
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_TX66_CONTROL
value|0x83b0
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_RX66_CONTROL
value|0x83c0
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_RX66_SCW0
value|0x83c2
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_RX66_SCW1
value|0x83c3
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_RX66_SCW2
value|0x83c4
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_RX66_SCW3
value|0x83c5
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_RX66_SCW0_MASK
value|0x83c6
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_RX66_SCW1_MASK
value|0x83c7
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_RX66_SCW2_MASK
value|0x83c8
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_RX66_SCW3_MASK
value|0x83c9
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_FX100_CTRL1
value|0x8400
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_FX100_CTRL3
value|0x8402
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_CL82_USERB1_TX_CTRL5
value|0x8436
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_CL82_USERB1_TX_CTRL6
value|0x8437
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_CL82_USERB1_TX_CTRL7
value|0x8438
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_CL82_USERB1_TX_CTRL9
value|0x8439
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_CL82_USERB1_RX_CTRL10
value|0x843a
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_CL82_USERB1_RX_CTRL11
value|0x843b
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_ETA_CL73_OUI1
value|0x8453
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_ETA_CL73_OUI2
value|0x8454
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_ETA_CL73_OUI3
value|0x8455
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_ETA_CL73_LD_BAM_CODE
value|0x8456
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_ETA_CL73_LD_UD_CODE
value|0x8457
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_MICROBLK_CMD
value|0xffc2
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_MICROBLK_DL_STATUS
value|0xffc5
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_MICROBLK_CMD3
value|0xffcc
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_AERBLK_AER
value|0xffde
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_COMBO_IEEE0_MIICTRL
value|0xffe0
end_define

begin_define
define|#
directive|define
name|MDIO_WC_REG_COMBO_IEEE0_MIIISTAT
value|0xffe1
end_define

begin_define
define|#
directive|define
name|MDIO_WC0_XGXS_BLK2_LANE_RESET
value|0x810A
end_define

begin_define
define|#
directive|define
name|MDIO_WC0_XGXS_BLK2_LANE_RESET_RX_BITSHIFT
value|0
end_define

begin_define
define|#
directive|define
name|MDIO_WC0_XGXS_BLK2_LANE_RESET_TX_BITSHIFT
value|4
end_define

begin_define
define|#
directive|define
name|MDIO_WC0_XGXS_BLK6_XGXS_X2_CONTROL2
value|0x8141
end_define

begin_define
define|#
directive|define
name|DIGITAL5_ACTUAL_SPEED_TX_MASK
value|0x003f
end_define

begin_comment
comment|/* 54618se */
end_comment

begin_define
define|#
directive|define
name|MDIO_REG_GPHY_MII_STATUS
value|0x1
end_define

begin_define
define|#
directive|define
name|MDIO_REG_GPHY_PHYID_LSB
value|0x3
end_define

begin_define
define|#
directive|define
name|MDIO_REG_GPHY_CL45_ADDR_REG
value|0xd
end_define

begin_define
define|#
directive|define
name|MDIO_REG_GPHY_CL45_REG_WRITE
value|0x4000
end_define

begin_define
define|#
directive|define
name|MDIO_REG_GPHY_CL45_REG_READ
value|0xc000
end_define

begin_define
define|#
directive|define
name|MDIO_REG_GPHY_CL45_DATA_REG
value|0xe
end_define

begin_define
define|#
directive|define
name|MDIO_REG_GPHY_EEE_RESOLVED
value|0x803e
end_define

begin_define
define|#
directive|define
name|MDIO_REG_GPHY_EXP_ACCESS_GATE
value|0x15
end_define

begin_define
define|#
directive|define
name|MDIO_REG_GPHY_EXP_ACCESS
value|0x17
end_define

begin_define
define|#
directive|define
name|MDIO_REG_GPHY_EXP_ACCESS_TOP
value|0xd00
end_define

begin_define
define|#
directive|define
name|MDIO_REG_GPHY_EXP_TOP_2K_BUF
value|0x40
end_define

begin_define
define|#
directive|define
name|MDIO_REG_GPHY_AUX_STATUS
value|0x19
end_define

begin_define
define|#
directive|define
name|MDIO_REG_INTR_STATUS
value|0x1a
end_define

begin_define
define|#
directive|define
name|MDIO_REG_INTR_MASK
value|0x1b
end_define

begin_define
define|#
directive|define
name|MDIO_REG_INTR_MASK_LINK_STATUS
value|(0x1<< 1)
end_define

begin_define
define|#
directive|define
name|MDIO_REG_GPHY_SHADOW
value|0x1c
end_define

begin_define
define|#
directive|define
name|MDIO_REG_GPHY_SHADOW_LED_SEL1
value|(0x0d<< 10)
end_define

begin_define
define|#
directive|define
name|MDIO_REG_GPHY_SHADOW_LED_SEL2
value|(0x0e<< 10)
end_define

begin_define
define|#
directive|define
name|MDIO_REG_GPHY_SHADOW_WR_ENA
value|(0x1<< 15)
end_define

begin_define
define|#
directive|define
name|MDIO_REG_GPHY_SHADOW_AUTO_DET_MED
value|(0x1e<< 10)
end_define

begin_define
define|#
directive|define
name|MDIO_REG_GPHY_SHADOW_INVERT_FIB_SD
value|(0x1<< 8)
end_define

begin_typedef
typedef|typedef
name|elink_status_t
function_decl|(
modifier|*
name|read_sfp_module_eeprom_func_p
function_decl|)
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint8_t
name|dev_addr
parameter_list|,
name|uint16_t
name|addr
parameter_list|,
name|uint8_t
name|byte_cnt
parameter_list|,
name|uint8_t
modifier|*
name|o_buf
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/********************************************************/
end_comment

begin_define
define|#
directive|define
name|ELINK_ETH_HLEN
value|14
end_define

begin_comment
comment|/* L2 header size + 2*VLANs (8 bytes) + LLC SNAP (8 bytes) */
end_comment

begin_define
define|#
directive|define
name|ELINK_ETH_OVREHEAD
value|(ELINK_ETH_HLEN + 8 + 8)
end_define

begin_define
define|#
directive|define
name|ELINK_ETH_MIN_PACKET_SIZE
value|60
end_define

begin_define
define|#
directive|define
name|ELINK_ETH_MAX_PACKET_SIZE
value|1500
end_define

begin_define
define|#
directive|define
name|ELINK_ETH_MAX_JUMBO_PACKET_SIZE
value|9600
end_define

begin_define
define|#
directive|define
name|ELINK_MDIO_ACCESS_TIMEOUT
value|1000
end_define

begin_define
define|#
directive|define
name|WC_LANE_MAX
value|4
end_define

begin_define
define|#
directive|define
name|I2C_SWITCH_WIDTH
value|2
end_define

begin_define
define|#
directive|define
name|I2C_BSC0
value|0
end_define

begin_define
define|#
directive|define
name|I2C_BSC1
value|1
end_define

begin_define
define|#
directive|define
name|I2C_WA_RETRY_CNT
value|3
end_define

begin_define
define|#
directive|define
name|I2C_WA_PWR_ITER
value|(I2C_WA_RETRY_CNT - 1)
end_define

begin_define
define|#
directive|define
name|MCPR_IMC_COMMAND_READ_OP
value|1
end_define

begin_define
define|#
directive|define
name|MCPR_IMC_COMMAND_WRITE_OP
value|2
end_define

begin_comment
comment|/* LED Blink rate that will achieve ~15.9Hz */
end_comment

begin_define
define|#
directive|define
name|LED_BLINK_RATE_VAL_E3
value|354
end_define

begin_define
define|#
directive|define
name|LED_BLINK_RATE_VAL_E1X_E2
value|480
end_define

begin_comment
comment|/***********************************************************/
end_comment

begin_comment
comment|/*			Shortcut definitions		   */
end_comment

begin_comment
comment|/***********************************************************/
end_comment

begin_define
define|#
directive|define
name|ELINK_NIG_LATCH_BC_ENABLE_MI_INT
value|0
end_define

begin_define
define|#
directive|define
name|ELINK_NIG_STATUS_EMAC0_MI_INT
define|\
value|NIG_STATUS_INTERRUPT_PORT0_REG_STATUS_EMAC0_MISC_MI_INT
end_define

begin_define
define|#
directive|define
name|ELINK_NIG_STATUS_XGXS0_LINK10G
define|\
value|NIG_STATUS_INTERRUPT_PORT0_REG_STATUS_XGXS0_LINK10G
end_define

begin_define
define|#
directive|define
name|ELINK_NIG_STATUS_XGXS0_LINK_STATUS
define|\
value|NIG_STATUS_INTERRUPT_PORT0_REG_STATUS_XGXS0_LINK_STATUS
end_define

begin_define
define|#
directive|define
name|ELINK_NIG_STATUS_XGXS0_LINK_STATUS_SIZE
define|\
value|NIG_STATUS_INTERRUPT_PORT0_REG_STATUS_XGXS0_LINK_STATUS_SIZE
end_define

begin_define
define|#
directive|define
name|ELINK_NIG_STATUS_SERDES0_LINK_STATUS
define|\
value|NIG_STATUS_INTERRUPT_PORT0_REG_STATUS_SERDES0_LINK_STATUS
end_define

begin_define
define|#
directive|define
name|ELINK_NIG_MASK_MI_INT
define|\
value|NIG_MASK_INTERRUPT_PORT0_REG_MASK_EMAC0_MISC_MI_INT
end_define

begin_define
define|#
directive|define
name|ELINK_NIG_MASK_XGXS0_LINK10G
define|\
value|NIG_MASK_INTERRUPT_PORT0_REG_MASK_XGXS0_LINK10G
end_define

begin_define
define|#
directive|define
name|ELINK_NIG_MASK_XGXS0_LINK_STATUS
define|\
value|NIG_MASK_INTERRUPT_PORT0_REG_MASK_XGXS0_LINK_STATUS
end_define

begin_define
define|#
directive|define
name|ELINK_NIG_MASK_SERDES0_LINK_STATUS
define|\
value|NIG_MASK_INTERRUPT_PORT0_REG_MASK_SERDES0_LINK_STATUS
end_define

begin_define
define|#
directive|define
name|ELINK_MDIO_AN_CL73_OR_37_COMPLETE
define|\
value|(MDIO_GP_STATUS_TOP_AN_STATUS1_CL73_AUTONEG_COMPLETE | \ 		 MDIO_GP_STATUS_TOP_AN_STATUS1_CL37_AUTONEG_COMPLETE)
end_define

begin_define
define|#
directive|define
name|ELINK_XGXS_RESET_BITS
define|\
value|(MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_XGXS0_RSTB_HW |   \ 	 MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_XGXS0_IDDQ |      \ 	 MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_XGXS0_PWRDWN |    \ 	 MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_XGXS0_PWRDWN_SD | \ 	 MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_XGXS0_TXD_FIFO_RSTB)
end_define

begin_define
define|#
directive|define
name|ELINK_SERDES_RESET_BITS
define|\
value|(MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_SERDES0_RSTB_HW | \ 	 MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_SERDES0_IDDQ |    \ 	 MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_SERDES0_PWRDWN |  \ 	 MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_SERDES0_PWRDWN_SD)
end_define

begin_define
define|#
directive|define
name|ELINK_AUTONEG_CL37
value|SHARED_HW_CFG_AN_ENABLE_CL37
end_define

begin_define
define|#
directive|define
name|ELINK_AUTONEG_CL73
value|SHARED_HW_CFG_AN_ENABLE_CL73
end_define

begin_define
define|#
directive|define
name|ELINK_AUTONEG_BAM
value|SHARED_HW_CFG_AN_ENABLE_BAM
end_define

begin_define
define|#
directive|define
name|ELINK_AUTONEG_PARALLEL
define|\
value|SHARED_HW_CFG_AN_ENABLE_PARALLEL_DETECTION
end_define

begin_define
define|#
directive|define
name|ELINK_AUTONEG_SGMII_FIBER_AUTODET
define|\
value|SHARED_HW_CFG_AN_EN_SGMII_FIBER_AUTO_DETECT
end_define

begin_define
define|#
directive|define
name|ELINK_AUTONEG_REMOTE_PHY
value|SHARED_HW_CFG_AN_ENABLE_REMOTE_PHY
end_define

begin_define
define|#
directive|define
name|ELINK_GP_STATUS_PAUSE_RSOLUTION_TXSIDE
define|\
value|MDIO_GP_STATUS_TOP_AN_STATUS1_PAUSE_RSOLUTION_TXSIDE
end_define

begin_define
define|#
directive|define
name|ELINK_GP_STATUS_PAUSE_RSOLUTION_RXSIDE
define|\
value|MDIO_GP_STATUS_TOP_AN_STATUS1_PAUSE_RSOLUTION_RXSIDE
end_define

begin_define
define|#
directive|define
name|ELINK_GP_STATUS_SPEED_MASK
define|\
value|MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_MASK
end_define

begin_define
define|#
directive|define
name|ELINK_GP_STATUS_10M
value|MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_10M
end_define

begin_define
define|#
directive|define
name|ELINK_GP_STATUS_100M
value|MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_100M
end_define

begin_define
define|#
directive|define
name|ELINK_GP_STATUS_1G
value|MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_1G
end_define

begin_define
define|#
directive|define
name|ELINK_GP_STATUS_2_5G
value|MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_2_5G
end_define

begin_define
define|#
directive|define
name|ELINK_GP_STATUS_5G
value|MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_5G
end_define

begin_define
define|#
directive|define
name|ELINK_GP_STATUS_6G
value|MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_6G
end_define

begin_define
define|#
directive|define
name|ELINK_GP_STATUS_10G_HIG
define|\
value|MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_10G_HIG
end_define

begin_define
define|#
directive|define
name|ELINK_GP_STATUS_10G_CX4
define|\
value|MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_10G_CX4
end_define

begin_define
define|#
directive|define
name|ELINK_GP_STATUS_1G_KX
value|MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_1G_KX
end_define

begin_define
define|#
directive|define
name|ELINK_GP_STATUS_10G_KX4
define|\
value|MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_10G_KX4
end_define

begin_define
define|#
directive|define
name|ELINK_GP_STATUS_10G_KR
value|MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_10G_KR
end_define

begin_define
define|#
directive|define
name|ELINK_GP_STATUS_10G_XFI
value|MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_10G_XFI
end_define

begin_define
define|#
directive|define
name|ELINK_GP_STATUS_20G_DXGXS
value|MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_20G_DXGXS
end_define

begin_define
define|#
directive|define
name|ELINK_GP_STATUS_10G_SFI
value|MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_10G_SFI
end_define

begin_define
define|#
directive|define
name|ELINK_GP_STATUS_20G_KR2
value|MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_20G_KR2
end_define

begin_define
define|#
directive|define
name|ELINK_LINK_10THD
value|LINK_STATUS_SPEED_AND_DUPLEX_10THD
end_define

begin_define
define|#
directive|define
name|ELINK_LINK_10TFD
value|LINK_STATUS_SPEED_AND_DUPLEX_10TFD
end_define

begin_define
define|#
directive|define
name|ELINK_LINK_100TXHD
value|LINK_STATUS_SPEED_AND_DUPLEX_100TXHD
end_define

begin_define
define|#
directive|define
name|ELINK_LINK_100T4
value|LINK_STATUS_SPEED_AND_DUPLEX_100T4
end_define

begin_define
define|#
directive|define
name|ELINK_LINK_100TXFD
value|LINK_STATUS_SPEED_AND_DUPLEX_100TXFD
end_define

begin_define
define|#
directive|define
name|ELINK_LINK_1000THD
value|LINK_STATUS_SPEED_AND_DUPLEX_1000THD
end_define

begin_define
define|#
directive|define
name|ELINK_LINK_1000TFD
value|LINK_STATUS_SPEED_AND_DUPLEX_1000TFD
end_define

begin_define
define|#
directive|define
name|ELINK_LINK_1000XFD
value|LINK_STATUS_SPEED_AND_DUPLEX_1000XFD
end_define

begin_define
define|#
directive|define
name|ELINK_LINK_2500THD
value|LINK_STATUS_SPEED_AND_DUPLEX_2500THD
end_define

begin_define
define|#
directive|define
name|ELINK_LINK_2500TFD
value|LINK_STATUS_SPEED_AND_DUPLEX_2500TFD
end_define

begin_define
define|#
directive|define
name|ELINK_LINK_2500XFD
value|LINK_STATUS_SPEED_AND_DUPLEX_2500XFD
end_define

begin_define
define|#
directive|define
name|ELINK_LINK_10GTFD
value|LINK_STATUS_SPEED_AND_DUPLEX_10GTFD
end_define

begin_define
define|#
directive|define
name|ELINK_LINK_10GXFD
value|LINK_STATUS_SPEED_AND_DUPLEX_10GXFD
end_define

begin_define
define|#
directive|define
name|ELINK_LINK_20GTFD
value|LINK_STATUS_SPEED_AND_DUPLEX_20GTFD
end_define

begin_define
define|#
directive|define
name|ELINK_LINK_20GXFD
value|LINK_STATUS_SPEED_AND_DUPLEX_20GXFD
end_define

begin_define
define|#
directive|define
name|ELINK_LINK_UPDATE_MASK
define|\
value|(LINK_STATUS_SPEED_AND_DUPLEX_MASK | \ 			 LINK_STATUS_LINK_UP | \ 			 LINK_STATUS_PHYSICAL_LINK_FLAG | \ 			 LINK_STATUS_AUTO_NEGOTIATE_COMPLETE | \ 			 LINK_STATUS_RX_FLOW_CONTROL_FLAG_MASK | \ 			 LINK_STATUS_TX_FLOW_CONTROL_FLAG_MASK | \ 			 LINK_STATUS_PARALLEL_DETECTION_FLAG_MASK | \ 			 LINK_STATUS_LINK_PARTNER_SYMMETRIC_PAUSE | \ 			 LINK_STATUS_LINK_PARTNER_ASYMMETRIC_PAUSE)
end_define

begin_define
define|#
directive|define
name|ELINK_SFP_EEPROM_CON_TYPE_ADDR
value|0x2
end_define

begin_define
define|#
directive|define
name|ELINK_SFP_EEPROM_CON_TYPE_VAL_UNKNOWN
value|0x0
end_define

begin_define
define|#
directive|define
name|ELINK_SFP_EEPROM_CON_TYPE_VAL_LC
value|0x7
end_define

begin_define
define|#
directive|define
name|ELINK_SFP_EEPROM_CON_TYPE_VAL_COPPER
value|0x21
end_define

begin_define
define|#
directive|define
name|ELINK_SFP_EEPROM_CON_TYPE_VAL_RJ45
value|0x22
end_define

begin_define
define|#
directive|define
name|ELINK_SFP_EEPROM_10G_COMP_CODE_ADDR
value|0x3
end_define

begin_define
define|#
directive|define
name|ELINK_SFP_EEPROM_10G_COMP_CODE_SR_MASK
value|(1<<4)
end_define

begin_define
define|#
directive|define
name|ELINK_SFP_EEPROM_10G_COMP_CODE_LR_MASK
value|(1<<5)
end_define

begin_define
define|#
directive|define
name|ELINK_SFP_EEPROM_10G_COMP_CODE_LRM_MASK
value|(1<<6)
end_define

begin_define
define|#
directive|define
name|ELINK_SFP_EEPROM_1G_COMP_CODE_ADDR
value|0x6
end_define

begin_define
define|#
directive|define
name|ELINK_SFP_EEPROM_1G_COMP_CODE_SX
value|(1<<0)
end_define

begin_define
define|#
directive|define
name|ELINK_SFP_EEPROM_1G_COMP_CODE_LX
value|(1<<1)
end_define

begin_define
define|#
directive|define
name|ELINK_SFP_EEPROM_1G_COMP_CODE_CX
value|(1<<2)
end_define

begin_define
define|#
directive|define
name|ELINK_SFP_EEPROM_1G_COMP_CODE_BASE_T
value|(1<<3)
end_define

begin_define
define|#
directive|define
name|ELINK_SFP_EEPROM_FC_TX_TECH_ADDR
value|0x8
end_define

begin_define
define|#
directive|define
name|ELINK_SFP_EEPROM_FC_TX_TECH_BITMASK_COPPER_PASSIVE
value|0x4
end_define

begin_define
define|#
directive|define
name|ELINK_SFP_EEPROM_FC_TX_TECH_BITMASK_COPPER_ACTIVE
value|0x8
end_define

begin_define
define|#
directive|define
name|ELINK_SFP_EEPROM_OPTIONS_ADDR
value|0x40
end_define

begin_define
define|#
directive|define
name|ELINK_SFP_EEPROM_OPTIONS_LINEAR_RX_OUT_MASK
value|0x1
end_define

begin_define
define|#
directive|define
name|ELINK_SFP_EEPROM_OPTIONS_SIZE
value|2
end_define

begin_define
define|#
directive|define
name|ELINK_EDC_MODE_LINEAR
value|0x0022
end_define

begin_define
define|#
directive|define
name|ELINK_EDC_MODE_LIMITING
value|0x0044
end_define

begin_define
define|#
directive|define
name|ELINK_EDC_MODE_PASSIVE_DAC
value|0x0055
end_define

begin_define
define|#
directive|define
name|ELINK_EDC_MODE_ACTIVE_DAC
value|0x0066
end_define

begin_comment
comment|/* ETS defines*/
end_comment

begin_define
define|#
directive|define
name|DCBX_INVALID_COS
value|(0xFF)
end_define

begin_define
define|#
directive|define
name|ELINK_ETS_BW_LIMIT_CREDIT_UPPER_BOUND
value|(0x5000)
end_define

begin_define
define|#
directive|define
name|ELINK_ETS_BW_LIMIT_CREDIT_WEIGHT
value|(0x5000)
end_define

begin_define
define|#
directive|define
name|ELINK_ETS_E3B0_NIG_MIN_W_VAL_UP_TO_10GBPS
value|(1360)
end_define

begin_define
define|#
directive|define
name|ELINK_ETS_E3B0_NIG_MIN_W_VAL_20GBPS
value|(2720)
end_define

begin_define
define|#
directive|define
name|ELINK_ETS_E3B0_PBF_MIN_W_VAL
value|(10000)
end_define

begin_define
define|#
directive|define
name|ELINK_MAX_PACKET_SIZE
value|(9700)
end_define

begin_define
define|#
directive|define
name|MAX_KR_LINK_RETRY
value|4
end_define

begin_define
define|#
directive|define
name|DEFAULT_TX_DRV_BRDCT
value|2
end_define

begin_define
define|#
directive|define
name|DEFAULT_TX_DRV_IFIR
value|0
end_define

begin_define
define|#
directive|define
name|DEFAULT_TX_DRV_POST2
value|3
end_define

begin_define
define|#
directive|define
name|DEFAULT_TX_DRV_IPRE_DRIVER
value|6
end_define

begin_comment
comment|/**********************************************************/
end_comment

begin_comment
comment|/*                     INTERFACE                          */
end_comment

begin_comment
comment|/**********************************************************/
end_comment

begin_define
define|#
directive|define
name|CL22_WR_OVER_CL45
parameter_list|(
name|_sc
parameter_list|,
name|_phy
parameter_list|,
name|_bank
parameter_list|,
name|_addr
parameter_list|,
name|_val
parameter_list|)
define|\
value|elink_cl45_write(_sc, _phy, \ 		(_phy)->def_md_devad, \ 		(_bank + (_addr& 0xf)), \ 		_val)
end_define

begin_define
define|#
directive|define
name|CL22_RD_OVER_CL45
parameter_list|(
name|_sc
parameter_list|,
name|_phy
parameter_list|,
name|_bank
parameter_list|,
name|_addr
parameter_list|,
name|_val
parameter_list|)
define|\
value|elink_cl45_read(_sc, _phy, \ 		(_phy)->def_md_devad, \ 		(_bank + (_addr& 0xf)), \ 		_val)
end_define

begin_function_decl
specifier|static
name|elink_status_t
name|elink_check_half_open_conn
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|,
name|uint8_t
name|notify
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|elink_status_t
name|elink_sfp_module_detection
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|uint32_t
name|elink_bits_en
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|reg
parameter_list|,
name|uint32_t
name|bits
parameter_list|)
block|{
name|uint32_t
name|val
init|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|)
decl_stmt|;
name|val
operator||=
name|bits
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|elink_bits_dis
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|reg
parameter_list|,
name|uint32_t
name|bits
parameter_list|)
block|{
name|uint32_t
name|val
init|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|)
decl_stmt|;
name|val
operator|&=
operator|~
name|bits
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/*  * elink_check_lfa - This function checks if link reinitialization is required,  *                   or link flap can be avoided.  *  * @params:	link parameters  * Returns 0 if Link Flap Avoidance conditions are met otherwise, the failed  *         condition code.  */
end_comment

begin_function
specifier|static
name|int
name|elink_check_lfa
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|uint32_t
name|link_status
decl_stmt|,
name|cfg_idx
decl_stmt|,
name|lfa_mask
decl_stmt|,
name|cfg_size
decl_stmt|;
name|uint32_t
name|cur_speed_cap_mask
decl_stmt|,
name|cur_req_fc_auto_adv
decl_stmt|,
name|additional_config
decl_stmt|;
name|uint32_t
name|saved_val
decl_stmt|,
name|req_val
decl_stmt|,
name|eee_status
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|additional_config
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|lfa_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_lfa
argument_list|,
name|additional_config
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTE: must be first condition checked - 	* to verify DCC bit is cleared in any case! 	*/
if|if
condition|(
name|additional_config
operator|&
name|NO_LFA_DUE_TO_DCC_MASK
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"No LFA due to DCC flap after clp exit\n"
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|lfa_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_lfa
argument_list|,
name|additional_config
argument_list|)
argument_list|,
name|additional_config
operator|&
operator|~
name|NO_LFA_DUE_TO_DCC_MASK
argument_list|)
expr_stmt|;
return|return
name|LFA_DCC_LFA_DISABLED
return|;
block|}
comment|/* Verify that link is up */
name|link_status
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|port_mb
index|[
name|params
operator|->
name|port
index|]
operator|.
name|link_status
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|link_status
operator|&
name|LINK_STATUS_LINK_UP
operator|)
condition|)
return|return
name|LFA_LINK_DOWN
return|;
comment|/* if loaded after BOOT from SAN, don't flap the link in any case and 	 * rely on link set by preboot driver 	 */
if|if
condition|(
name|params
operator|->
name|feature_config_flags
operator|&
name|ELINK_FEATURE_CONFIG_BOOT_FROM_SAN
condition|)
return|return
literal|0
return|;
comment|/* Verify that loopback mode is not set */
if|if
condition|(
name|params
operator|->
name|loopback_mode
condition|)
return|return
name|LFA_LOOPBACK_ENABLED
return|;
comment|/* Verify that MFW supports LFA */
if|if
condition|(
operator|!
name|params
operator|->
name|lfa_base
condition|)
return|return
name|LFA_MFW_IS_TOO_OLD
return|;
if|if
condition|(
name|params
operator|->
name|num_phys
operator|==
literal|3
condition|)
block|{
name|cfg_size
operator|=
literal|2
expr_stmt|;
name|lfa_mask
operator|=
literal|0xffffffff
expr_stmt|;
block|}
else|else
block|{
name|cfg_size
operator|=
literal|1
expr_stmt|;
name|lfa_mask
operator|=
literal|0xffff
expr_stmt|;
block|}
comment|/* Compare Duplex */
name|saved_val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|lfa_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_lfa
argument_list|,
name|req_duplex
argument_list|)
argument_list|)
expr_stmt|;
name|req_val
operator|=
name|params
operator|->
name|req_duplex
index|[
literal|0
index|]
operator||
operator|(
name|params
operator|->
name|req_duplex
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|saved_val
operator|&
name|lfa_mask
operator|)
operator|!=
operator|(
name|req_val
operator|&
name|lfa_mask
operator|)
condition|)
block|{
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"Duplex mismatch %x vs. %x\n"
argument_list|,
operator|(
name|saved_val
operator|&
name|lfa_mask
operator|)
argument_list|,
operator|(
name|req_val
operator|&
name|lfa_mask
operator|)
argument_list|)
expr_stmt|;
return|return
name|LFA_DUPLEX_MISMATCH
return|;
block|}
comment|/* Compare Flow Control */
name|saved_val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|lfa_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_lfa
argument_list|,
name|req_flow_ctrl
argument_list|)
argument_list|)
expr_stmt|;
name|req_val
operator|=
name|params
operator|->
name|req_flow_ctrl
index|[
literal|0
index|]
operator||
operator|(
name|params
operator|->
name|req_flow_ctrl
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|saved_val
operator|&
name|lfa_mask
operator|)
operator|!=
operator|(
name|req_val
operator|&
name|lfa_mask
operator|)
condition|)
block|{
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"Flow control mismatch %x vs. %x\n"
argument_list|,
operator|(
name|saved_val
operator|&
name|lfa_mask
operator|)
argument_list|,
operator|(
name|req_val
operator|&
name|lfa_mask
operator|)
argument_list|)
expr_stmt|;
return|return
name|LFA_FLOW_CTRL_MISMATCH
return|;
block|}
comment|/* Compare Link Speed */
name|saved_val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|lfa_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_lfa
argument_list|,
name|req_line_speed
argument_list|)
argument_list|)
expr_stmt|;
name|req_val
operator|=
name|params
operator|->
name|req_line_speed
index|[
literal|0
index|]
operator||
operator|(
name|params
operator|->
name|req_line_speed
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|saved_val
operator|&
name|lfa_mask
operator|)
operator|!=
operator|(
name|req_val
operator|&
name|lfa_mask
operator|)
condition|)
block|{
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"Link speed mismatch %x vs. %x\n"
argument_list|,
operator|(
name|saved_val
operator|&
name|lfa_mask
operator|)
argument_list|,
operator|(
name|req_val
operator|&
name|lfa_mask
operator|)
argument_list|)
expr_stmt|;
return|return
name|LFA_LINK_SPEED_MISMATCH
return|;
block|}
for|for
control|(
name|cfg_idx
operator|=
literal|0
init|;
name|cfg_idx
operator|<
name|cfg_size
condition|;
name|cfg_idx
operator|++
control|)
block|{
name|cur_speed_cap_mask
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|lfa_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_lfa
argument_list|,
name|speed_cap_mask
index|[
name|cfg_idx
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_speed_cap_mask
operator|!=
name|params
operator|->
name|speed_cap_mask
index|[
name|cfg_idx
index|]
condition|)
block|{
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"Speed Cap mismatch %x vs. %x\n"
argument_list|,
name|cur_speed_cap_mask
argument_list|,
name|params
operator|->
name|speed_cap_mask
index|[
name|cfg_idx
index|]
argument_list|)
expr_stmt|;
return|return
name|LFA_SPEED_CAP_MISMATCH
return|;
block|}
block|}
name|cur_req_fc_auto_adv
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|lfa_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_lfa
argument_list|,
name|additional_config
argument_list|)
argument_list|)
operator|&
name|REQ_FC_AUTO_ADV_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|uint16_t
operator|)
name|cur_req_fc_auto_adv
operator|!=
name|params
operator|->
name|req_fc_auto_adv
condition|)
block|{
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"Flow Ctrl AN mismatch %x vs. %x\n"
argument_list|,
name|cur_req_fc_auto_adv
argument_list|,
name|params
operator|->
name|req_fc_auto_adv
argument_list|)
expr_stmt|;
return|return
name|LFA_FLOW_CTRL_MISMATCH
return|;
block|}
name|eee_status
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|shmem2_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem2_region
argument_list|,
name|eee_status
index|[
name|params
operator|->
name|port
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|eee_status
operator|&
name|SHMEM_EEE_LPI_REQUESTED_BIT
operator|)
operator|^
operator|(
name|params
operator|->
name|eee_mode
operator|&
name|ELINK_EEE_MODE_ENABLE_LPI
operator|)
operator|)
operator|||
operator|(
operator|(
name|eee_status
operator|&
name|SHMEM_EEE_REQUESTED_BIT
operator|)
operator|^
operator|(
name|params
operator|->
name|eee_mode
operator|&
name|ELINK_EEE_MODE_ADV_LPI
operator|)
operator|)
condition|)
block|{
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"EEE mismatch %x vs. %x\n"
argument_list|,
name|params
operator|->
name|eee_mode
argument_list|,
name|eee_status
argument_list|)
expr_stmt|;
return|return
name|LFA_EEE_MISMATCH
return|;
block|}
comment|/* LFA conditions are met */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/******************************************************************/
end_comment

begin_comment
comment|/*			EPIO/GPIO section			  */
end_comment

begin_comment
comment|/******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|elink_get_epio
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|epio_pin
parameter_list|,
name|uint32_t
modifier|*
name|en
parameter_list|)
block|{
name|uint32_t
name|epio_mask
decl_stmt|,
name|gp_oenable
decl_stmt|;
operator|*
name|en
operator|=
literal|0
expr_stmt|;
comment|/* Sanity check */
if|if
condition|(
name|epio_pin
operator|>
literal|31
condition|)
block|{
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Invalid EPIO pin %d to get\n"
argument_list|,
name|epio_pin
argument_list|)
expr_stmt|;
return|return;
block|}
name|epio_mask
operator|=
literal|1
operator|<<
name|epio_pin
expr_stmt|;
comment|/* Set this EPIO to output */
name|gp_oenable
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_GP_OENABLE
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_GP_OENABLE
argument_list|,
name|gp_oenable
operator|&
operator|~
name|epio_mask
argument_list|)
expr_stmt|;
operator|*
name|en
operator|=
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_GP_INPUTS
argument_list|)
operator|&
name|epio_mask
operator|)
operator|>>
name|epio_pin
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_set_epio
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|epio_pin
parameter_list|,
name|uint32_t
name|en
parameter_list|)
block|{
name|uint32_t
name|epio_mask
decl_stmt|,
name|gp_output
decl_stmt|,
name|gp_oenable
decl_stmt|;
comment|/* Sanity check */
if|if
condition|(
name|epio_pin
operator|>
literal|31
condition|)
block|{
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Invalid EPIO pin %d to set\n"
argument_list|,
name|epio_pin
argument_list|)
expr_stmt|;
return|return;
block|}
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"Setting EPIO pin %d to %d\n"
argument_list|,
name|epio_pin
argument_list|,
name|en
argument_list|)
expr_stmt|;
name|epio_mask
operator|=
literal|1
operator|<<
name|epio_pin
expr_stmt|;
comment|/* Set this EPIO to output */
name|gp_output
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_GP_OUTPUTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|en
condition|)
name|gp_output
operator||=
name|epio_mask
expr_stmt|;
else|else
name|gp_output
operator|&=
operator|~
name|epio_mask
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_GP_OUTPUTS
argument_list|,
name|gp_output
argument_list|)
expr_stmt|;
comment|/* Set the value for this EPIO */
name|gp_oenable
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_GP_OENABLE
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_GP_OENABLE
argument_list|,
name|gp_oenable
operator||
name|epio_mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_set_cfg_pin
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|pin_cfg
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
if|if
condition|(
name|pin_cfg
operator|==
name|PIN_CFG_NA
condition|)
return|return;
if|if
condition|(
name|pin_cfg
operator|>=
name|PIN_CFG_EPIO0
condition|)
block|{
name|elink_set_epio
argument_list|(
name|sc
argument_list|,
name|pin_cfg
operator|-
name|PIN_CFG_EPIO0
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uint8_t
name|gpio_num
init|=
operator|(
name|pin_cfg
operator|-
name|PIN_CFG_GPIO0_P0
operator|)
operator|&
literal|0x3
decl_stmt|;
name|uint8_t
name|gpio_port
init|=
operator|(
name|pin_cfg
operator|-
name|PIN_CFG_GPIO0_P0
operator|)
operator|>>
literal|2
decl_stmt|;
name|elink_cb_gpio_write
argument_list|(
name|sc
argument_list|,
name|gpio_num
argument_list|,
operator|(
name|uint8_t
operator|)
name|val
argument_list|,
name|gpio_port
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|elink_get_cfg_pin
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|pin_cfg
parameter_list|,
name|uint32_t
modifier|*
name|val
parameter_list|)
block|{
if|if
condition|(
name|pin_cfg
operator|==
name|PIN_CFG_NA
condition|)
return|return
name|ELINK_STATUS_ERROR
return|;
if|if
condition|(
name|pin_cfg
operator|>=
name|PIN_CFG_EPIO0
condition|)
block|{
name|elink_get_epio
argument_list|(
name|sc
argument_list|,
name|pin_cfg
operator|-
name|PIN_CFG_EPIO0
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uint8_t
name|gpio_num
init|=
operator|(
name|pin_cfg
operator|-
name|PIN_CFG_GPIO0_P0
operator|)
operator|&
literal|0x3
decl_stmt|;
name|uint8_t
name|gpio_port
init|=
operator|(
name|pin_cfg
operator|-
name|PIN_CFG_GPIO0_P0
operator|)
operator|>>
literal|2
decl_stmt|;
operator|*
name|val
operator|=
name|elink_cb_gpio_read
argument_list|(
name|sc
argument_list|,
name|gpio_num
argument_list|,
name|gpio_port
argument_list|)
expr_stmt|;
block|}
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/******************************************************************/
end_comment

begin_comment
comment|/*				ETS section			  */
end_comment

begin_comment
comment|/******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|elink_ets_e2e3a0_disabled
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
comment|/* ETS disabled configuration*/
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"ETS E2E3 disabled configuration\n"
argument_list|)
expr_stmt|;
comment|/* mapping between entry  priority to client number (0,1,2 -debug and 	 * management clients, 3 - COS0 client, 4 - COS client)(HIGHEST) 	 * 3bits client num. 	 *   PRI4    |    PRI3    |    PRI2    |    PRI1    |    PRI0 	 * cos1-100     cos0-011     dbg1-010     dbg0-001     MCP-000 	 */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_P0_TX_ARB_PRIORITY_CLIENT
argument_list|,
literal|0x4688
argument_list|)
expr_stmt|;
comment|/* Bitmap of 5bits length. Each bit specifies whether the entry behaves 	 * as strict.  Bits 0,1,2 - debug and management entries, 3 - 	 * COS0 entry, 4 - COS1 entry. 	 * COS1 | COS0 | DEBUG1 | DEBUG0 | MGMT 	 * bit4   bit3	  bit2   bit1	  bit0 	 * MCP and debug are strict 	 */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_P0_TX_ARB_CLIENT_IS_STRICT
argument_list|,
literal|0x7
argument_list|)
expr_stmt|;
comment|/* defines which entries (clients) are subjected to WFQ arbitration */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_P0_TX_ARB_CLIENT_IS_SUBJECT2WFQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* For strict priority entries defines the number of consecutive 	 * slots for the highest priority. 	 */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_P0_TX_ARB_NUM_STRICT_ARB_SLOTS
argument_list|,
literal|0x100
argument_list|)
expr_stmt|;
comment|/* mapping between the CREDIT_WEIGHT registers and actual client 	 * numbers 	 */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_P0_TX_ARB_CLIENT_CREDIT_MAP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_HIGH_PRIORITY_COS_NUM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ETS mode disable */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_ETS_ENABLED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If ETS mode is enabled (there is no strict priority) defines a WFQ 	 * weight for COS0/COS1. 	 */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_COS0_WEIGHT
argument_list|,
literal|0x2710
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_COS1_WEIGHT
argument_list|,
literal|0x2710
argument_list|)
expr_stmt|;
comment|/* Upper bound that COS0_WEIGHT can reach in the WFQ arbiter */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_COS0_UPPER_BOUND
argument_list|,
literal|0x989680
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_COS1_UPPER_BOUND
argument_list|,
literal|0x989680
argument_list|)
expr_stmt|;
comment|/* Defines the number of consecutive slots for the strict priority */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_NUM_STRICT_ARB_SLOTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Description: *	Getting min_w_val will be set according to line speed . *. ******************************************************************************/
end_comment

begin_function
specifier|static
name|uint32_t
name|elink_ets_get_min_w_val_nig
parameter_list|(
specifier|const
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|uint32_t
name|min_w_val
init|=
literal|0
decl_stmt|;
comment|/* Calculate min_w_val.*/
if|if
condition|(
name|vars
operator|->
name|link_up
condition|)
block|{
if|if
condition|(
name|vars
operator|->
name|line_speed
operator|==
name|ELINK_SPEED_20000
condition|)
name|min_w_val
operator|=
name|ELINK_ETS_E3B0_NIG_MIN_W_VAL_20GBPS
expr_stmt|;
else|else
name|min_w_val
operator|=
name|ELINK_ETS_E3B0_NIG_MIN_W_VAL_UP_TO_10GBPS
expr_stmt|;
block|}
else|else
name|min_w_val
operator|=
name|ELINK_ETS_E3B0_NIG_MIN_W_VAL_20GBPS
expr_stmt|;
comment|/* If the link isn't up (static configuration for example ) The 	 * link will be according to 20GBPS. 	 */
return|return
name|min_w_val
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Description: *	Getting credit upper bound form min_w_val. *. ******************************************************************************/
end_comment

begin_function
specifier|static
name|uint32_t
name|elink_ets_get_credit_upper_bound
parameter_list|(
specifier|const
name|uint32_t
name|min_w_val
parameter_list|)
block|{
specifier|const
name|uint32_t
name|credit_upper_bound
init|=
operator|(
name|uint32_t
operator|)
name|ELINK_MAXVAL
argument_list|(
operator|(
literal|150
operator|*
name|min_w_val
operator|)
argument_list|,
name|ELINK_MAX_PACKET_SIZE
argument_list|)
decl_stmt|;
return|return
name|credit_upper_bound
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Description: *	Set credit upper bound for NIG. *. ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|elink_ets_e3b0_set_credit_upper_bound_nig
parameter_list|(
specifier|const
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
specifier|const
name|uint32_t
name|min_w_val
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
specifier|const
name|uint8_t
name|port
init|=
name|params
operator|->
name|port
decl_stmt|;
specifier|const
name|uint32_t
name|credit_upper_bound
init|=
name|elink_ets_get_credit_upper_bound
argument_list|(
name|min_w_val
argument_list|)
decl_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|port
operator|)
condition|?
name|NIG_REG_P1_TX_ARB_CREDIT_UPPER_BOUND_0
else|:
name|NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_0
argument_list|,
name|credit_upper_bound
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|port
operator|)
condition|?
name|NIG_REG_P1_TX_ARB_CREDIT_UPPER_BOUND_1
else|:
name|NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_1
argument_list|,
name|credit_upper_bound
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|port
operator|)
condition|?
name|NIG_REG_P1_TX_ARB_CREDIT_UPPER_BOUND_2
else|:
name|NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_2
argument_list|,
name|credit_upper_bound
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|port
operator|)
condition|?
name|NIG_REG_P1_TX_ARB_CREDIT_UPPER_BOUND_3
else|:
name|NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_3
argument_list|,
name|credit_upper_bound
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|port
operator|)
condition|?
name|NIG_REG_P1_TX_ARB_CREDIT_UPPER_BOUND_4
else|:
name|NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_4
argument_list|,
name|credit_upper_bound
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|port
operator|)
condition|?
name|NIG_REG_P1_TX_ARB_CREDIT_UPPER_BOUND_5
else|:
name|NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_5
argument_list|,
name|credit_upper_bound
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|port
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_6
argument_list|,
name|credit_upper_bound
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_7
argument_list|,
name|credit_upper_bound
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_8
argument_list|,
name|credit_upper_bound
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/****************************************************************************** * Description: *	Will return the NIG ETS registers to init values.Except *	credit_upper_bound. *	That isn't used in this configuration (No WFQ is enabled) and will be *	configured according to spec. *. ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|elink_ets_e3b0_nig_disabled
parameter_list|(
specifier|const
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
specifier|const
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
specifier|const
name|uint8_t
name|port
init|=
name|params
operator|->
name|port
decl_stmt|;
specifier|const
name|uint32_t
name|min_w_val
init|=
name|elink_ets_get_min_w_val_nig
argument_list|(
name|vars
argument_list|)
decl_stmt|;
comment|/* Mapping between entry  priority to client number (0,1,2 -debug and 	 * management clients, 3 - COS0 client, 4 - COS1, ... 8 - 	 * COS5)(HIGHEST) 4bits client num.TODO_ETS - Should be done by 	 * reset value or init tool 	 */
if|if
condition|(
name|port
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_P1_TX_ARB_PRIORITY_CLIENT2_LSB
argument_list|,
literal|0x543210
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_P1_TX_ARB_PRIORITY_CLIENT2_MSB
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_P0_TX_ARB_PRIORITY_CLIENT2_LSB
argument_list|,
literal|0x76543210
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_P0_TX_ARB_PRIORITY_CLIENT2_MSB
argument_list|,
literal|0x8
argument_list|)
expr_stmt|;
block|}
comment|/* For strict priority entries defines the number of consecutive 	 * slots for the highest priority. 	 */
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|port
operator|)
condition|?
name|NIG_REG_P1_TX_ARB_NUM_STRICT_ARB_SLOTS
else|:
name|NIG_REG_P1_TX_ARB_NUM_STRICT_ARB_SLOTS
argument_list|,
literal|0x100
argument_list|)
expr_stmt|;
comment|/* Mapping between the CREDIT_WEIGHT registers and actual client 	 * numbers 	 */
if|if
condition|(
name|port
condition|)
block|{
comment|/*Port 1 has 6 COS*/
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_P1_TX_ARB_CLIENT_CREDIT_MAP2_LSB
argument_list|,
literal|0x210543
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_P1_TX_ARB_CLIENT_CREDIT_MAP2_MSB
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*Port 0 has 9 COS*/
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_P0_TX_ARB_CLIENT_CREDIT_MAP2_LSB
argument_list|,
literal|0x43210876
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_P0_TX_ARB_CLIENT_CREDIT_MAP2_MSB
argument_list|,
literal|0x5
argument_list|)
expr_stmt|;
block|}
comment|/* Bitmap of 5bits length. Each bit specifies whether the entry behaves 	 * as strict.  Bits 0,1,2 - debug and management entries, 3 - 	 * COS0 entry, 4 - COS1 entry. 	 * COS1 | COS0 | DEBUG1 | DEBUG0 | MGMT 	 * bit4   bit3	  bit2   bit1	  bit0 	 * MCP and debug are strict 	 */
if|if
condition|(
name|port
condition|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_P1_TX_ARB_CLIENT_IS_STRICT
argument_list|,
literal|0x3f
argument_list|)
expr_stmt|;
else|else
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_P0_TX_ARB_CLIENT_IS_STRICT
argument_list|,
literal|0x1ff
argument_list|)
expr_stmt|;
comment|/* defines which entries (clients) are subjected to WFQ arbitration */
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|port
operator|)
condition|?
name|NIG_REG_P1_TX_ARB_CLIENT_IS_SUBJECT2WFQ
else|:
name|NIG_REG_P0_TX_ARB_CLIENT_IS_SUBJECT2WFQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Please notice the register address are note continuous and a 	 * for here is note appropriate.In 2 port mode port0 only COS0-5 	 * can be used. DEBUG1,DEBUG1,MGMT are never used for WFQ* In 4 	 * port mode port1 only COS0-2 can be used. DEBUG1,DEBUG1,MGMT 	 * are never used for WFQ 	 */
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|port
operator|)
condition|?
name|NIG_REG_P1_TX_ARB_CREDIT_WEIGHT_0
else|:
name|NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_0
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|port
operator|)
condition|?
name|NIG_REG_P1_TX_ARB_CREDIT_WEIGHT_1
else|:
name|NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_1
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|port
operator|)
condition|?
name|NIG_REG_P1_TX_ARB_CREDIT_WEIGHT_2
else|:
name|NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_2
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|port
operator|)
condition|?
name|NIG_REG_P1_TX_ARB_CREDIT_WEIGHT_3
else|:
name|NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_3
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|port
operator|)
condition|?
name|NIG_REG_P1_TX_ARB_CREDIT_WEIGHT_4
else|:
name|NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_4
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|port
operator|)
condition|?
name|NIG_REG_P1_TX_ARB_CREDIT_WEIGHT_5
else|:
name|NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_5
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|port
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_6
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_7
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_8
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
name|elink_ets_e3b0_set_credit_upper_bound_nig
argument_list|(
name|params
argument_list|,
name|min_w_val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Description: *	Set credit upper bound for PBF. *. ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|elink_ets_e3b0_set_credit_upper_bound_pbf
parameter_list|(
specifier|const
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
specifier|const
name|uint32_t
name|min_w_val
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
specifier|const
name|uint32_t
name|credit_upper_bound
init|=
name|elink_ets_get_credit_upper_bound
argument_list|(
name|min_w_val
argument_list|)
decl_stmt|;
specifier|const
name|uint8_t
name|port
init|=
name|params
operator|->
name|port
decl_stmt|;
name|uint32_t
name|base_upper_bound
init|=
literal|0
decl_stmt|;
name|uint8_t
name|max_cos
init|=
literal|0
decl_stmt|;
name|uint8_t
name|i
init|=
literal|0
decl_stmt|;
comment|/* In 2 port mode port0 has COS0-5 that can be used for WFQ.In 4 	 * port mode port1 has COS0-2 that can be used for WFQ. 	 */
if|if
condition|(
operator|!
name|port
condition|)
block|{
name|base_upper_bound
operator|=
name|PBF_REG_COS0_UPPER_BOUND_P0
expr_stmt|;
name|max_cos
operator|=
name|ELINK_DCBX_E3B0_MAX_NUM_COS_PORT0
expr_stmt|;
block|}
else|else
block|{
name|base_upper_bound
operator|=
name|PBF_REG_COS0_UPPER_BOUND_P1
expr_stmt|;
name|max_cos
operator|=
name|ELINK_DCBX_E3B0_MAX_NUM_COS_PORT1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_cos
condition|;
name|i
operator|++
control|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|base_upper_bound
operator|+
operator|(
name|i
operator|<<
literal|2
operator|)
argument_list|,
name|credit_upper_bound
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Description: *	Will return the PBF ETS registers to init values.Except *	credit_upper_bound. *	That isn't used in this configuration (No WFQ is enabled) and will be *	configured according to spec. *. ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|elink_ets_e3b0_pbf_disabled
parameter_list|(
specifier|const
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
specifier|const
name|uint8_t
name|port
init|=
name|params
operator|->
name|port
decl_stmt|;
specifier|const
name|uint32_t
name|min_w_val_pbf
init|=
name|ELINK_ETS_E3B0_PBF_MIN_W_VAL
decl_stmt|;
name|uint8_t
name|i
init|=
literal|0
decl_stmt|;
name|uint32_t
name|base_weight
init|=
literal|0
decl_stmt|;
name|uint8_t
name|max_cos
init|=
literal|0
decl_stmt|;
comment|/* Mapping between entry  priority to client number 0 - COS0 	 * client, 2 - COS1, ... 5 - COS5)(HIGHEST) 4bits client num. 	 * TODO_ETS - Should be done by reset value or init tool 	 */
if|if
condition|(
name|port
condition|)
comment|/*  0x688 (|011|0 10|00 1|000) */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_ETS_ARB_PRIORITY_CLIENT_P1
argument_list|,
literal|0x688
argument_list|)
expr_stmt|;
else|else
comment|/*  (10 1|100 |011|0 10|00 1|000) */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_ETS_ARB_PRIORITY_CLIENT_P0
argument_list|,
literal|0x2C688
argument_list|)
expr_stmt|;
comment|/* TODO_ETS - Should be done by reset value or init tool */
if|if
condition|(
name|port
condition|)
comment|/* 0x688 (|011|0 10|00 1|000)*/
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_ETS_ARB_CLIENT_CREDIT_MAP_P1
argument_list|,
literal|0x688
argument_list|)
expr_stmt|;
else|else
comment|/* 0x2C688 (10 1|100 |011|0 10|00 1|000) */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_ETS_ARB_CLIENT_CREDIT_MAP_P0
argument_list|,
literal|0x2C688
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|port
operator|)
condition|?
name|PBF_REG_ETS_ARB_NUM_STRICT_ARB_SLOTS_P1
else|:
name|PBF_REG_ETS_ARB_NUM_STRICT_ARB_SLOTS_P0
argument_list|,
literal|0x100
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|port
operator|)
condition|?
name|PBF_REG_ETS_ARB_CLIENT_IS_STRICT_P1
else|:
name|PBF_REG_ETS_ARB_CLIENT_IS_STRICT_P0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|port
operator|)
condition|?
name|PBF_REG_ETS_ARB_CLIENT_IS_SUBJECT2WFQ_P1
else|:
name|PBF_REG_ETS_ARB_CLIENT_IS_SUBJECT2WFQ_P0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* In 2 port mode port0 has COS0-5 that can be used for WFQ. 	 * In 4 port mode port1 has COS0-2 that can be used for WFQ. 	 */
if|if
condition|(
operator|!
name|port
condition|)
block|{
name|base_weight
operator|=
name|PBF_REG_COS0_WEIGHT_P0
expr_stmt|;
name|max_cos
operator|=
name|ELINK_DCBX_E3B0_MAX_NUM_COS_PORT0
expr_stmt|;
block|}
else|else
block|{
name|base_weight
operator|=
name|PBF_REG_COS0_WEIGHT_P1
expr_stmt|;
name|max_cos
operator|=
name|ELINK_DCBX_E3B0_MAX_NUM_COS_PORT1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_cos
condition|;
name|i
operator|++
control|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|base_weight
operator|+
operator|(
literal|0x4
operator|*
name|i
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|elink_ets_e3b0_set_credit_upper_bound_pbf
argument_list|(
name|params
argument_list|,
name|min_w_val_pbf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Description: *	E3B0 disable will return basically the values to init values. *. ******************************************************************************/
end_comment

begin_function
specifier|static
name|elink_status_t
name|elink_ets_e3b0_disabled
parameter_list|(
specifier|const
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
specifier|const
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
if|if
condition|(
operator|!
name|CHIP_IS_E3B0
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"elink_ets_e3b0_disabled the chip isn't E3B0\n"
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
name|elink_ets_e3b0_nig_disabled
argument_list|(
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
name|elink_ets_e3b0_pbf_disabled
argument_list|(
name|params
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Description: *	Disable will return basically the values to init values. * ******************************************************************************/
end_comment

begin_function
name|elink_status_t
name|elink_ets_disabled
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|elink_status_t
name|elink_status
init|=
name|ELINK_STATUS_OK
decl_stmt|;
if|if
condition|(
operator|(
name|CHIP_IS_E2
argument_list|(
name|sc
argument_list|)
operator|)
operator|||
operator|(
name|CHIP_IS_E3A0
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
name|elink_ets_e2e3a0_disabled
argument_list|(
name|params
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CHIP_IS_E3B0
argument_list|(
name|sc
argument_list|)
condition|)
name|elink_status
operator|=
name|elink_ets_e3b0_disabled
argument_list|(
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
else|else
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"elink_ets_disabled - chip not supported\n"
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
return|return
name|elink_status
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Description *	Set the COS mappimg to SP and BW until this point all the COS are not *	set as SP or BW. ******************************************************************************/
end_comment

begin_function
specifier|static
name|elink_status_t
name|elink_ets_e3b0_cli_map
parameter_list|(
specifier|const
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
specifier|const
name|struct
name|elink_ets_params
modifier|*
name|ets_params
parameter_list|,
specifier|const
name|uint8_t
name|cos_sp_bitmap
parameter_list|,
specifier|const
name|uint8_t
name|cos_bw_bitmap
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
specifier|const
name|uint8_t
name|port
init|=
name|params
operator|->
name|port
decl_stmt|;
specifier|const
name|uint8_t
name|nig_cli_sp_bitmap
init|=
literal|0x7
operator||
operator|(
name|cos_sp_bitmap
operator|<<
literal|3
operator|)
decl_stmt|;
specifier|const
name|uint8_t
name|pbf_cli_sp_bitmap
init|=
name|cos_sp_bitmap
decl_stmt|;
specifier|const
name|uint8_t
name|nig_cli_subject2wfq_bitmap
init|=
name|cos_bw_bitmap
operator|<<
literal|3
decl_stmt|;
specifier|const
name|uint8_t
name|pbf_cli_subject2wfq_bitmap
init|=
name|cos_bw_bitmap
decl_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|port
operator|)
condition|?
name|NIG_REG_P1_TX_ARB_CLIENT_IS_STRICT
else|:
name|NIG_REG_P0_TX_ARB_CLIENT_IS_STRICT
argument_list|,
name|nig_cli_sp_bitmap
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|port
operator|)
condition|?
name|PBF_REG_ETS_ARB_CLIENT_IS_STRICT_P1
else|:
name|PBF_REG_ETS_ARB_CLIENT_IS_STRICT_P0
argument_list|,
name|pbf_cli_sp_bitmap
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|port
operator|)
condition|?
name|NIG_REG_P1_TX_ARB_CLIENT_IS_SUBJECT2WFQ
else|:
name|NIG_REG_P0_TX_ARB_CLIENT_IS_SUBJECT2WFQ
argument_list|,
name|nig_cli_subject2wfq_bitmap
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|port
operator|)
condition|?
name|PBF_REG_ETS_ARB_CLIENT_IS_SUBJECT2WFQ_P1
else|:
name|PBF_REG_ETS_ARB_CLIENT_IS_SUBJECT2WFQ_P0
argument_list|,
name|pbf_cli_subject2wfq_bitmap
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Description: *	This function is needed because NIG ARB_CREDIT_WEIGHT_X are *	not continues and ARB_CREDIT_WEIGHT_0 + offset is suitable. ******************************************************************************/
end_comment

begin_function
specifier|static
name|elink_status_t
name|elink_ets_e3b0_set_cos_bw
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint8_t
name|cos_entry
parameter_list|,
specifier|const
name|uint32_t
name|min_w_val_nig
parameter_list|,
specifier|const
name|uint32_t
name|min_w_val_pbf
parameter_list|,
specifier|const
name|uint16_t
name|total_bw
parameter_list|,
specifier|const
name|uint8_t
name|bw
parameter_list|,
specifier|const
name|uint8_t
name|port
parameter_list|)
block|{
name|uint32_t
name|nig_reg_adress_crd_weight
init|=
literal|0
decl_stmt|;
name|uint32_t
name|pbf_reg_adress_crd_weight
init|=
literal|0
decl_stmt|;
comment|/* Calculate and set BW for this COS - use 1 instead of 0 for BW */
specifier|const
name|uint32_t
name|cos_bw_nig
init|=
operator|(
operator|(
name|bw
condition|?
name|bw
else|:
literal|1
operator|)
operator|*
name|min_w_val_nig
operator|)
operator|/
name|total_bw
decl_stmt|;
specifier|const
name|uint32_t
name|cos_bw_pbf
init|=
operator|(
operator|(
name|bw
condition|?
name|bw
else|:
literal|1
operator|)
operator|*
name|min_w_val_pbf
operator|)
operator|/
name|total_bw
decl_stmt|;
switch|switch
condition|(
name|cos_entry
condition|)
block|{
case|case
literal|0
case|:
name|nig_reg_adress_crd_weight
operator|=
operator|(
name|port
operator|)
condition|?
name|NIG_REG_P1_TX_ARB_CREDIT_WEIGHT_0
else|:
name|NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_0
expr_stmt|;
name|pbf_reg_adress_crd_weight
operator|=
operator|(
name|port
operator|)
condition|?
name|PBF_REG_COS0_WEIGHT_P1
else|:
name|PBF_REG_COS0_WEIGHT_P0
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|nig_reg_adress_crd_weight
operator|=
operator|(
name|port
operator|)
condition|?
name|NIG_REG_P1_TX_ARB_CREDIT_WEIGHT_1
else|:
name|NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_1
expr_stmt|;
name|pbf_reg_adress_crd_weight
operator|=
operator|(
name|port
operator|)
condition|?
name|PBF_REG_COS1_WEIGHT_P1
else|:
name|PBF_REG_COS1_WEIGHT_P0
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|nig_reg_adress_crd_weight
operator|=
operator|(
name|port
operator|)
condition|?
name|NIG_REG_P1_TX_ARB_CREDIT_WEIGHT_2
else|:
name|NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_2
expr_stmt|;
name|pbf_reg_adress_crd_weight
operator|=
operator|(
name|port
operator|)
condition|?
name|PBF_REG_COS2_WEIGHT_P1
else|:
name|PBF_REG_COS2_WEIGHT_P0
expr_stmt|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|port
condition|)
return|return
name|ELINK_STATUS_ERROR
return|;
name|nig_reg_adress_crd_weight
operator|=
name|NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_3
expr_stmt|;
name|pbf_reg_adress_crd_weight
operator|=
name|PBF_REG_COS3_WEIGHT_P0
expr_stmt|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|port
condition|)
return|return
name|ELINK_STATUS_ERROR
return|;
name|nig_reg_adress_crd_weight
operator|=
name|NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_4
expr_stmt|;
name|pbf_reg_adress_crd_weight
operator|=
name|PBF_REG_COS4_WEIGHT_P0
expr_stmt|;
break|break;
case|case
literal|5
case|:
if|if
condition|(
name|port
condition|)
return|return
name|ELINK_STATUS_ERROR
return|;
name|nig_reg_adress_crd_weight
operator|=
name|NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_5
expr_stmt|;
name|pbf_reg_adress_crd_weight
operator|=
name|PBF_REG_COS5_WEIGHT_P0
expr_stmt|;
break|break;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|nig_reg_adress_crd_weight
argument_list|,
name|cos_bw_nig
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|pbf_reg_adress_crd_weight
argument_list|,
name|cos_bw_pbf
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Description: *	Calculate the total BW.A value of 0 isn't legal. * ******************************************************************************/
end_comment

begin_function
specifier|static
name|elink_status_t
name|elink_ets_e3b0_get_total_bw
parameter_list|(
specifier|const
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_ets_params
modifier|*
name|ets_params
parameter_list|,
name|uint16_t
modifier|*
name|total_bw
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint8_t
name|cos_idx
init|=
literal|0
decl_stmt|;
name|uint8_t
name|is_bw_cos_exist
init|=
literal|0
decl_stmt|;
operator|*
name|total_bw
operator|=
literal|0
expr_stmt|;
comment|/* Calculate total BW requested */
for|for
control|(
name|cos_idx
operator|=
literal|0
init|;
name|cos_idx
operator|<
name|ets_params
operator|->
name|num_of_cos
condition|;
name|cos_idx
operator|++
control|)
block|{
if|if
condition|(
name|ets_params
operator|->
name|cos
index|[
name|cos_idx
index|]
operator|.
name|state
operator|==
name|elink_cos_state_bw
condition|)
block|{
name|is_bw_cos_exist
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|ets_params
operator|->
name|cos
index|[
name|cos_idx
index|]
operator|.
name|params
operator|.
name|bw_params
operator|.
name|bw
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"elink_ets_E3B0_config BW"
literal|"was set to 0\n"
argument_list|)
expr_stmt|;
comment|/* This is to prevent a state when ramrods 				 * can't be sent 				 */
name|ets_params
operator|->
name|cos
index|[
name|cos_idx
index|]
operator|.
name|params
operator|.
name|bw_params
operator|.
name|bw
operator|=
literal|1
expr_stmt|;
block|}
operator|*
name|total_bw
operator|+=
name|ets_params
operator|->
name|cos
index|[
name|cos_idx
index|]
operator|.
name|params
operator|.
name|bw_params
operator|.
name|bw
expr_stmt|;
block|}
block|}
comment|/* Check total BW is valid */
if|if
condition|(
operator|(
name|is_bw_cos_exist
operator|==
literal|1
operator|)
operator|&&
operator|(
operator|*
name|total_bw
operator|!=
literal|100
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|total_bw
operator|==
literal|0
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"elink_ets_E3B0_config total BW shouldn't be 0\n"
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"elink_ets_E3B0_config total BW should be 100\n"
argument_list|)
expr_stmt|;
comment|/* We can handle a case whre the BW isn't 100 this can happen 		 * if the TC are joined. 		 */
block|}
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Description: *	Invalidate all the sp_pri_to_cos. * ******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|elink_ets_e3b0_sp_pri_to_cos_init
parameter_list|(
name|uint8_t
modifier|*
name|sp_pri_to_cos
parameter_list|)
block|{
name|uint8_t
name|pri
init|=
literal|0
decl_stmt|;
for|for
control|(
name|pri
operator|=
literal|0
init|;
name|pri
operator|<
name|ELINK_DCBX_MAX_NUM_COS
condition|;
name|pri
operator|++
control|)
name|sp_pri_to_cos
index|[
name|pri
index|]
operator|=
name|DCBX_INVALID_COS
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Description: *	Calculate and set the SP (ARB_PRIORITY_CLIENT) NIG and PBF registers *	according to sp_pri_to_cos. * ******************************************************************************/
end_comment

begin_function
specifier|static
name|elink_status_t
name|elink_ets_e3b0_sp_pri_to_cos_set
parameter_list|(
specifier|const
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint8_t
modifier|*
name|sp_pri_to_cos
parameter_list|,
specifier|const
name|uint8_t
name|pri
parameter_list|,
specifier|const
name|uint8_t
name|cos_entry
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
specifier|const
name|uint8_t
name|port
init|=
name|params
operator|->
name|port
decl_stmt|;
specifier|const
name|uint8_t
name|max_num_of_cos
init|=
operator|(
name|port
operator|)
condition|?
name|ELINK_DCBX_E3B0_MAX_NUM_COS_PORT1
else|:
name|ELINK_DCBX_E3B0_MAX_NUM_COS_PORT0
decl_stmt|;
if|if
condition|(
name|pri
operator|>=
name|max_num_of_cos
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"elink_ets_e3b0_sp_pri_to_cos_set invalid "
literal|"parameter Illegal strict priority\n"
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
if|if
condition|(
name|sp_pri_to_cos
index|[
name|pri
index|]
operator|!=
name|DCBX_INVALID_COS
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"elink_ets_e3b0_sp_pri_to_cos_set invalid "
literal|"parameter There can't be two COS's with "
literal|"the same strict pri\n"
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
name|sp_pri_to_cos
index|[
name|pri
index|]
operator|=
name|cos_entry
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Description: *	Returns the correct value according to COS and priority in *	the sp_pri_cli register. * ******************************************************************************/
end_comment

begin_function
specifier|static
name|uint64_t
name|elink_e3b0_sp_get_pri_cli_reg
parameter_list|(
specifier|const
name|uint8_t
name|cos
parameter_list|,
specifier|const
name|uint8_t
name|cos_offset
parameter_list|,
specifier|const
name|uint8_t
name|pri_set
parameter_list|,
specifier|const
name|uint8_t
name|pri_offset
parameter_list|,
specifier|const
name|uint8_t
name|entry_size
parameter_list|)
block|{
name|uint64_t
name|pri_cli_nig
init|=
literal|0
decl_stmt|;
name|pri_cli_nig
operator|=
operator|(
call|(
name|uint64_t
call|)
argument_list|(
name|cos
operator|+
name|cos_offset
argument_list|)
operator|)
operator|<<
operator|(
name|entry_size
operator|*
operator|(
name|pri_set
operator|+
name|pri_offset
operator|)
operator|)
expr_stmt|;
return|return
name|pri_cli_nig
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Description: *	Returns the correct value according to COS and priority in the *	sp_pri_cli register for NIG. * ******************************************************************************/
end_comment

begin_function
specifier|static
name|uint64_t
name|elink_e3b0_sp_get_pri_cli_reg_nig
parameter_list|(
specifier|const
name|uint8_t
name|cos
parameter_list|,
specifier|const
name|uint8_t
name|pri_set
parameter_list|)
block|{
comment|/* MCP Dbg0 and dbg1 are always with higher strict pri*/
specifier|const
name|uint8_t
name|nig_cos_offset
init|=
literal|3
decl_stmt|;
specifier|const
name|uint8_t
name|nig_pri_offset
init|=
literal|3
decl_stmt|;
return|return
name|elink_e3b0_sp_get_pri_cli_reg
argument_list|(
name|cos
argument_list|,
name|nig_cos_offset
argument_list|,
name|pri_set
argument_list|,
name|nig_pri_offset
argument_list|,
literal|4
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Description: *	Returns the correct value according to COS and priority in the *	sp_pri_cli register for PBF. * ******************************************************************************/
end_comment

begin_function
specifier|static
name|uint64_t
name|elink_e3b0_sp_get_pri_cli_reg_pbf
parameter_list|(
specifier|const
name|uint8_t
name|cos
parameter_list|,
specifier|const
name|uint8_t
name|pri_set
parameter_list|)
block|{
specifier|const
name|uint8_t
name|pbf_cos_offset
init|=
literal|0
decl_stmt|;
specifier|const
name|uint8_t
name|pbf_pri_offset
init|=
literal|0
decl_stmt|;
return|return
name|elink_e3b0_sp_get_pri_cli_reg
argument_list|(
name|cos
argument_list|,
name|pbf_cos_offset
argument_list|,
name|pri_set
argument_list|,
name|pbf_pri_offset
argument_list|,
literal|3
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Description: *	Calculate and set the SP (ARB_PRIORITY_CLIENT) NIG and PBF registers *	according to sp_pri_to_cos.(which COS has higher priority) * ******************************************************************************/
end_comment

begin_function
specifier|static
name|elink_status_t
name|elink_ets_e3b0_sp_set_pri_cli_reg
parameter_list|(
specifier|const
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint8_t
modifier|*
name|sp_pri_to_cos
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint8_t
name|i
init|=
literal|0
decl_stmt|;
specifier|const
name|uint8_t
name|port
init|=
name|params
operator|->
name|port
decl_stmt|;
comment|/* MCP Dbg0 and dbg1 are always with higher strict pri*/
name|uint64_t
name|pri_cli_nig
init|=
literal|0x210
decl_stmt|;
name|uint32_t
name|pri_cli_pbf
init|=
literal|0x0
decl_stmt|;
name|uint8_t
name|pri_set
init|=
literal|0
decl_stmt|;
name|uint8_t
name|pri_bitmask
init|=
literal|0
decl_stmt|;
specifier|const
name|uint8_t
name|max_num_of_cos
init|=
operator|(
name|port
operator|)
condition|?
name|ELINK_DCBX_E3B0_MAX_NUM_COS_PORT1
else|:
name|ELINK_DCBX_E3B0_MAX_NUM_COS_PORT0
decl_stmt|;
name|uint8_t
name|cos_bit_to_set
init|=
operator|(
literal|1
operator|<<
name|max_num_of_cos
operator|)
operator|-
literal|1
decl_stmt|;
comment|/* Set all the strict priority first */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_num_of_cos
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sp_pri_to_cos
index|[
name|i
index|]
operator|!=
name|DCBX_INVALID_COS
condition|)
block|{
if|if
condition|(
name|sp_pri_to_cos
index|[
name|i
index|]
operator|>=
name|ELINK_DCBX_MAX_NUM_COS
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"elink_ets_e3b0_sp_set_pri_cli_reg "
literal|"invalid cos entry\n"
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
name|pri_cli_nig
operator||=
name|elink_e3b0_sp_get_pri_cli_reg_nig
argument_list|(
name|sp_pri_to_cos
index|[
name|i
index|]
argument_list|,
name|pri_set
argument_list|)
expr_stmt|;
name|pri_cli_pbf
operator||=
name|elink_e3b0_sp_get_pri_cli_reg_pbf
argument_list|(
name|sp_pri_to_cos
index|[
name|i
index|]
argument_list|,
name|pri_set
argument_list|)
expr_stmt|;
name|pri_bitmask
operator|=
literal|1
operator|<<
name|sp_pri_to_cos
index|[
name|i
index|]
expr_stmt|;
comment|/* COS is used remove it from bitmap.*/
if|if
condition|(
operator|!
operator|(
name|pri_bitmask
operator|&
name|cos_bit_to_set
operator|)
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"elink_ets_e3b0_sp_set_pri_cli_reg "
literal|"invalid There can't be two COS's with"
literal|" the same strict pri\n"
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
name|cos_bit_to_set
operator|&=
operator|~
name|pri_bitmask
expr_stmt|;
name|pri_set
operator|++
expr_stmt|;
block|}
block|}
comment|/* Set all the Non strict priority i= COS*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_num_of_cos
condition|;
name|i
operator|++
control|)
block|{
name|pri_bitmask
operator|=
literal|1
operator|<<
name|i
expr_stmt|;
comment|/* Check if COS was already used for SP */
if|if
condition|(
name|pri_bitmask
operator|&
name|cos_bit_to_set
condition|)
block|{
comment|/* COS wasn't used for SP */
name|pri_cli_nig
operator||=
name|elink_e3b0_sp_get_pri_cli_reg_nig
argument_list|(
name|i
argument_list|,
name|pri_set
argument_list|)
expr_stmt|;
name|pri_cli_pbf
operator||=
name|elink_e3b0_sp_get_pri_cli_reg_pbf
argument_list|(
name|i
argument_list|,
name|pri_set
argument_list|)
expr_stmt|;
comment|/* COS is used remove it from bitmap.*/
name|cos_bit_to_set
operator|&=
operator|~
name|pri_bitmask
expr_stmt|;
name|pri_set
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pri_set
operator|!=
name|max_num_of_cos
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"elink_ets_e3b0_sp_set_pri_cli_reg not all "
literal|"entries were set\n"
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
if|if
condition|(
name|port
condition|)
block|{
comment|/* Only 6 usable clients*/
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_P1_TX_ARB_PRIORITY_CLIENT2_LSB
argument_list|,
operator|(
name|uint32_t
operator|)
name|pri_cli_nig
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_ETS_ARB_PRIORITY_CLIENT_P1
argument_list|,
name|pri_cli_pbf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Only 9 usable clients*/
specifier|const
name|uint32_t
name|pri_cli_nig_lsb
init|=
call|(
name|uint32_t
call|)
argument_list|(
name|pri_cli_nig
argument_list|)
decl_stmt|;
specifier|const
name|uint32_t
name|pri_cli_nig_msb
init|=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|pri_cli_nig
operator|>>
literal|32
operator|)
operator|&
literal|0xF
argument_list|)
decl_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_P0_TX_ARB_PRIORITY_CLIENT2_LSB
argument_list|,
name|pri_cli_nig_lsb
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_P0_TX_ARB_PRIORITY_CLIENT2_MSB
argument_list|,
name|pri_cli_nig_msb
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_ETS_ARB_PRIORITY_CLIENT_P0
argument_list|,
name|pri_cli_pbf
argument_list|)
expr_stmt|;
block|}
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Description: *	Configure the COS to ETS according to BW and SP settings. ******************************************************************************/
end_comment

begin_function
name|elink_status_t
name|elink_ets_e3b0_config
parameter_list|(
specifier|const
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
specifier|const
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|,
name|struct
name|elink_ets_params
modifier|*
name|ets_params
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|elink_status_t
name|elink_status
init|=
name|ELINK_STATUS_OK
decl_stmt|;
specifier|const
name|uint8_t
name|port
init|=
name|params
operator|->
name|port
decl_stmt|;
name|uint16_t
name|total_bw
init|=
literal|0
decl_stmt|;
specifier|const
name|uint32_t
name|min_w_val_nig
init|=
name|elink_ets_get_min_w_val_nig
argument_list|(
name|vars
argument_list|)
decl_stmt|;
specifier|const
name|uint32_t
name|min_w_val_pbf
init|=
name|ELINK_ETS_E3B0_PBF_MIN_W_VAL
decl_stmt|;
name|uint8_t
name|cos_bw_bitmap
init|=
literal|0
decl_stmt|;
name|uint8_t
name|cos_sp_bitmap
init|=
literal|0
decl_stmt|;
name|uint8_t
name|sp_pri_to_cos
index|[
name|ELINK_DCBX_MAX_NUM_COS
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
specifier|const
name|uint8_t
name|max_num_of_cos
init|=
operator|(
name|port
operator|)
condition|?
name|ELINK_DCBX_E3B0_MAX_NUM_COS_PORT1
else|:
name|ELINK_DCBX_E3B0_MAX_NUM_COS_PORT0
decl_stmt|;
name|uint8_t
name|cos_entry
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|CHIP_IS_E3B0
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"elink_ets_e3b0_disabled the chip isn't E3B0\n"
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
if|if
condition|(
operator|(
name|ets_params
operator|->
name|num_of_cos
operator|>
name|max_num_of_cos
operator|)
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"elink_ets_E3B0_config the number of COS "
literal|"isn't supported\n"
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
comment|/* Prepare sp strict priority parameters*/
name|elink_ets_e3b0_sp_pri_to_cos_init
argument_list|(
name|sp_pri_to_cos
argument_list|)
expr_stmt|;
comment|/* Prepare BW parameters*/
name|elink_status
operator|=
name|elink_ets_e3b0_get_total_bw
argument_list|(
name|params
argument_list|,
name|ets_params
argument_list|,
operator|&
name|total_bw
argument_list|)
expr_stmt|;
if|if
condition|(
name|elink_status
operator|!=
name|ELINK_STATUS_OK
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"elink_ets_E3B0_config get_total_bw failed\n"
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
comment|/* Upper bound is set according to current link speed (min_w_val 	 * should be the same for upper bound and COS credit val). 	 */
name|elink_ets_e3b0_set_credit_upper_bound_nig
argument_list|(
name|params
argument_list|,
name|min_w_val_nig
argument_list|)
expr_stmt|;
name|elink_ets_e3b0_set_credit_upper_bound_pbf
argument_list|(
name|params
argument_list|,
name|min_w_val_pbf
argument_list|)
expr_stmt|;
for|for
control|(
name|cos_entry
operator|=
literal|0
init|;
name|cos_entry
operator|<
name|ets_params
operator|->
name|num_of_cos
condition|;
name|cos_entry
operator|++
control|)
block|{
if|if
condition|(
name|elink_cos_state_bw
operator|==
name|ets_params
operator|->
name|cos
index|[
name|cos_entry
index|]
operator|.
name|state
condition|)
block|{
name|cos_bw_bitmap
operator||=
operator|(
literal|1
operator|<<
name|cos_entry
operator|)
expr_stmt|;
comment|/* The function also sets the BW in HW(not the mappin 			 * yet) 			 */
name|elink_status
operator|=
name|elink_ets_e3b0_set_cos_bw
argument_list|(
name|sc
argument_list|,
name|cos_entry
argument_list|,
name|min_w_val_nig
argument_list|,
name|min_w_val_pbf
argument_list|,
name|total_bw
argument_list|,
name|ets_params
operator|->
name|cos
index|[
name|cos_entry
index|]
operator|.
name|params
operator|.
name|bw_params
operator|.
name|bw
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|elink_cos_state_strict
operator|==
name|ets_params
operator|->
name|cos
index|[
name|cos_entry
index|]
operator|.
name|state
condition|)
block|{
name|cos_sp_bitmap
operator||=
operator|(
literal|1
operator|<<
name|cos_entry
operator|)
expr_stmt|;
name|elink_status
operator|=
name|elink_ets_e3b0_sp_pri_to_cos_set
argument_list|(
name|params
argument_list|,
name|sp_pri_to_cos
argument_list|,
name|ets_params
operator|->
name|cos
index|[
name|cos_entry
index|]
operator|.
name|params
operator|.
name|sp_params
operator|.
name|pri
argument_list|,
name|cos_entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"elink_ets_e3b0_config cos state not valid\n"
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
if|if
condition|(
name|elink_status
operator|!=
name|ELINK_STATUS_OK
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"elink_ets_e3b0_config set cos bw failed\n"
argument_list|)
expr_stmt|;
return|return
name|elink_status
return|;
block|}
block|}
comment|/* Set SP register (which COS has higher priority) */
name|elink_status
operator|=
name|elink_ets_e3b0_sp_set_pri_cli_reg
argument_list|(
name|params
argument_list|,
name|sp_pri_to_cos
argument_list|)
expr_stmt|;
if|if
condition|(
name|elink_status
operator|!=
name|ELINK_STATUS_OK
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"elink_ets_E3B0_config set_pri_cli_reg failed\n"
argument_list|)
expr_stmt|;
return|return
name|elink_status
return|;
block|}
comment|/* Set client mapping of BW and strict */
name|elink_status
operator|=
name|elink_ets_e3b0_cli_map
argument_list|(
name|params
argument_list|,
name|ets_params
argument_list|,
name|cos_sp_bitmap
argument_list|,
name|cos_bw_bitmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|elink_status
operator|!=
name|ELINK_STATUS_OK
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"elink_ets_E3B0_config SP failed\n"
argument_list|)
expr_stmt|;
return|return
name|elink_status
return|;
block|}
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_ets_bw_limit_common
parameter_list|(
specifier|const
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
comment|/* ETS disabled configuration */
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"ETS enabled BW limit configuration\n"
argument_list|)
expr_stmt|;
comment|/* Defines which entries (clients) are subjected to WFQ arbitration 	 * COS0 0x8 	 * COS1 0x10 	 */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_P0_TX_ARB_CLIENT_IS_SUBJECT2WFQ
argument_list|,
literal|0x18
argument_list|)
expr_stmt|;
comment|/* Mapping between the ARB_CREDIT_WEIGHT registers and actual 	 * client numbers (WEIGHT_0 does not actually have to represent 	 * client 0) 	 *    PRI4    |    PRI3    |    PRI2    |    PRI1    |    PRI0 	 *  cos1-001     cos0-000     dbg1-100     dbg0-011     MCP-010 	 */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_P0_TX_ARB_CLIENT_CREDIT_MAP
argument_list|,
literal|0x111A
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_0
argument_list|,
name|ELINK_ETS_BW_LIMIT_CREDIT_UPPER_BOUND
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_P0_TX_ARB_CREDIT_UPPER_BOUND_1
argument_list|,
name|ELINK_ETS_BW_LIMIT_CREDIT_UPPER_BOUND
argument_list|)
expr_stmt|;
comment|/* ETS mode enabled*/
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_ETS_ENABLED
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Defines the number of consecutive slots for the strict priority */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_NUM_STRICT_ARB_SLOTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Bitmap of 5bits length. Each bit specifies whether the entry behaves 	 * as strict.  Bits 0,1,2 - debug and management entries, 3 - COS0 	 * entry, 4 - COS1 entry. 	 * COS1 | COS0 | DEBUG21 | DEBUG0 | MGMT 	 * bit4   bit3	  bit2     bit1	   bit0 	 * MCP and debug are strict 	 */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_P0_TX_ARB_CLIENT_IS_STRICT
argument_list|,
literal|0x7
argument_list|)
expr_stmt|;
comment|/* Upper bound that COS0_WEIGHT can reach in the WFQ arbiter.*/
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_COS0_UPPER_BOUND
argument_list|,
name|ELINK_ETS_BW_LIMIT_CREDIT_UPPER_BOUND
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_COS1_UPPER_BOUND
argument_list|,
name|ELINK_ETS_BW_LIMIT_CREDIT_UPPER_BOUND
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|elink_ets_bw_limit
parameter_list|(
specifier|const
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
specifier|const
name|uint32_t
name|cos0_bw
parameter_list|,
specifier|const
name|uint32_t
name|cos1_bw
parameter_list|)
block|{
comment|/* ETS disabled configuration*/
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
specifier|const
name|uint32_t
name|total_bw
init|=
name|cos0_bw
operator|+
name|cos1_bw
decl_stmt|;
name|uint32_t
name|cos0_credit_weight
init|=
literal|0
decl_stmt|;
name|uint32_t
name|cos1_credit_weight
init|=
literal|0
decl_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"ETS enabled BW limit configuration\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|total_bw
operator|)
operator|||
operator|(
operator|!
name|cos0_bw
operator|)
operator|||
operator|(
operator|!
name|cos1_bw
operator|)
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Total BW can't be zero\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|cos0_credit_weight
operator|=
operator|(
name|cos0_bw
operator|*
name|ELINK_ETS_BW_LIMIT_CREDIT_WEIGHT
operator|)
operator|/
name|total_bw
expr_stmt|;
name|cos1_credit_weight
operator|=
operator|(
name|cos1_bw
operator|*
name|ELINK_ETS_BW_LIMIT_CREDIT_WEIGHT
operator|)
operator|/
name|total_bw
expr_stmt|;
name|elink_ets_bw_limit_common
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_0
argument_list|,
name|cos0_credit_weight
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_P0_TX_ARB_CREDIT_WEIGHT_1
argument_list|,
name|cos1_credit_weight
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_COS0_WEIGHT
argument_list|,
name|cos0_credit_weight
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_COS1_WEIGHT
argument_list|,
name|cos1_credit_weight
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|elink_status_t
name|elink_ets_strict
parameter_list|(
specifier|const
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
specifier|const
name|uint8_t
name|strict_cos
parameter_list|)
block|{
comment|/* ETS disabled configuration*/
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint32_t
name|val
init|=
literal|0
decl_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"ETS enabled strict configuration\n"
argument_list|)
expr_stmt|;
comment|/* Bitmap of 5bits length. Each bit specifies whether the entry behaves 	 * as strict.  Bits 0,1,2 - debug and management entries, 	 * 3 - COS0 entry, 4 - COS1 entry. 	 *  COS1 | COS0 | DEBUG21 | DEBUG0 | MGMT 	 *  bit4   bit3	  bit2      bit1     bit0 	 * MCP and debug are strict 	 */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_P0_TX_ARB_CLIENT_IS_STRICT
argument_list|,
literal|0x1F
argument_list|)
expr_stmt|;
comment|/* For strict priority entries defines the number of consecutive slots 	 * for the highest priority. 	 */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_P0_TX_ARB_NUM_STRICT_ARB_SLOTS
argument_list|,
literal|0x100
argument_list|)
expr_stmt|;
comment|/* ETS mode disable */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_ETS_ENABLED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Defines the number of consecutive slots for the strict priority */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_NUM_STRICT_ARB_SLOTS
argument_list|,
literal|0x100
argument_list|)
expr_stmt|;
comment|/* Defines the number of consecutive slots for the strict priority */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_HIGH_PRIORITY_COS_NUM
argument_list|,
name|strict_cos
argument_list|)
expr_stmt|;
comment|/* Mapping between entry  priority to client number (0,1,2 -debug and 	 * management clients, 3 - COS0 client, 4 - COS client)(HIGHEST) 	 * 3bits client num. 	 *   PRI4    |    PRI3    |    PRI2    |    PRI1    |    PRI0 	 * dbg0-010     dbg1-001     cos1-100     cos0-011     MCP-000 	 * dbg0-010     dbg1-001     cos0-011     cos1-100     MCP-000 	 */
name|val
operator|=
operator|(
operator|!
name|strict_cos
operator|)
condition|?
literal|0x2318
else|:
literal|0x22E0
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_P0_TX_ARB_PRIORITY_CLIENT
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/******************************************************************/
end_comment

begin_comment
comment|/*			PFC section				  */
end_comment

begin_comment
comment|/******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|elink_update_pfc_xmac
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|,
name|uint8_t
name|is_lb
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint32_t
name|xmac_base
decl_stmt|;
name|uint32_t
name|pause_val
decl_stmt|,
name|pfc0_val
decl_stmt|,
name|pfc1_val
decl_stmt|;
comment|/* XMAC base adrr */
name|xmac_base
operator|=
operator|(
name|params
operator|->
name|port
operator|)
condition|?
name|GRCBASE_XMAC1
else|:
name|GRCBASE_XMAC0
expr_stmt|;
comment|/* Initialize pause and pfc registers */
name|pause_val
operator|=
literal|0x18000
expr_stmt|;
name|pfc0_val
operator|=
literal|0xFFFF8000
expr_stmt|;
name|pfc1_val
operator|=
literal|0x2
expr_stmt|;
comment|/* No PFC support */
if|if
condition|(
operator|!
operator|(
name|params
operator|->
name|feature_config_flags
operator|&
name|ELINK_FEATURE_CONFIG_PFC_ENABLED
operator|)
condition|)
block|{
comment|/* RX flow control - Process pause frame in receive direction 		 */
if|if
condition|(
name|vars
operator|->
name|flow_ctrl
operator|&
name|ELINK_FLOW_CTRL_RX
condition|)
name|pause_val
operator||=
name|XMAC_PAUSE_CTRL_REG_RX_PAUSE_EN
expr_stmt|;
comment|/* TX flow control - Send pause packet when buffer is full */
if|if
condition|(
name|vars
operator|->
name|flow_ctrl
operator|&
name|ELINK_FLOW_CTRL_TX
condition|)
name|pause_val
operator||=
name|XMAC_PAUSE_CTRL_REG_TX_PAUSE_EN
expr_stmt|;
block|}
else|else
block|{
comment|/* PFC support */
name|pfc1_val
operator||=
name|XMAC_PFC_CTRL_HI_REG_PFC_REFRESH_EN
operator||
name|XMAC_PFC_CTRL_HI_REG_PFC_STATS_EN
operator||
name|XMAC_PFC_CTRL_HI_REG_RX_PFC_EN
operator||
name|XMAC_PFC_CTRL_HI_REG_TX_PFC_EN
operator||
name|XMAC_PFC_CTRL_HI_REG_FORCE_PFC_XON
expr_stmt|;
comment|/* Write pause and PFC registers */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|xmac_base
operator|+
name|XMAC_REG_PAUSE_CTRL
argument_list|,
name|pause_val
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|xmac_base
operator|+
name|XMAC_REG_PFC_CTRL
argument_list|,
name|pfc0_val
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|xmac_base
operator|+
name|XMAC_REG_PFC_CTRL_HI
argument_list|,
name|pfc1_val
argument_list|)
expr_stmt|;
name|pfc1_val
operator|&=
operator|~
name|XMAC_PFC_CTRL_HI_REG_FORCE_PFC_XON
expr_stmt|;
block|}
comment|/* Write pause and PFC registers */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|xmac_base
operator|+
name|XMAC_REG_PAUSE_CTRL
argument_list|,
name|pause_val
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|xmac_base
operator|+
name|XMAC_REG_PFC_CTRL
argument_list|,
name|pfc0_val
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|xmac_base
operator|+
name|XMAC_REG_PFC_CTRL_HI
argument_list|,
name|pfc1_val
argument_list|)
expr_stmt|;
comment|/* Set MAC address for source TX Pause/PFC frames */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|xmac_base
operator|+
name|XMAC_REG_CTRL_SA_LO
argument_list|,
operator|(
operator|(
name|params
operator|->
name|mac_addr
index|[
literal|2
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|params
operator|->
name|mac_addr
index|[
literal|3
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|params
operator|->
name|mac_addr
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|params
operator|->
name|mac_addr
index|[
literal|5
index|]
operator|)
operator|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|xmac_base
operator|+
name|XMAC_REG_CTRL_SA_HI
argument_list|,
operator|(
operator|(
name|params
operator|->
name|mac_addr
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|params
operator|->
name|mac_addr
index|[
literal|1
index|]
operator|)
operator|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|30
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_emac_get_pfc_stat
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint32_t
name|pfc_frames_sent
index|[
literal|2
index|]
parameter_list|,
name|uint32_t
name|pfc_frames_received
index|[
literal|2
index|]
parameter_list|)
block|{
comment|/* Read pfc statistic */
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint32_t
name|emac_base
init|=
name|params
operator|->
name|port
condition|?
name|GRCBASE_EMAC1
else|:
name|GRCBASE_EMAC0
decl_stmt|;
name|uint32_t
name|val_xon
init|=
literal|0
decl_stmt|;
name|uint32_t
name|val_xoff
init|=
literal|0
decl_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"pfc statistic read from EMAC\n"
argument_list|)
expr_stmt|;
comment|/* PFC received frames */
name|val_xoff
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|emac_base
operator|+
name|EMAC_REG_RX_PFC_STATS_XOFF_RCVD
argument_list|)
expr_stmt|;
name|val_xoff
operator|&=
name|EMAC_REG_RX_PFC_STATS_XOFF_RCVD_COUNT
expr_stmt|;
name|val_xon
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|emac_base
operator|+
name|EMAC_REG_RX_PFC_STATS_XON_RCVD
argument_list|)
expr_stmt|;
name|val_xon
operator|&=
name|EMAC_REG_RX_PFC_STATS_XON_RCVD_COUNT
expr_stmt|;
name|pfc_frames_received
index|[
literal|0
index|]
operator|=
name|val_xon
operator|+
name|val_xoff
expr_stmt|;
comment|/* PFC received sent */
name|val_xoff
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|emac_base
operator|+
name|EMAC_REG_RX_PFC_STATS_XOFF_SENT
argument_list|)
expr_stmt|;
name|val_xoff
operator|&=
name|EMAC_REG_RX_PFC_STATS_XOFF_SENT_COUNT
expr_stmt|;
name|val_xon
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|emac_base
operator|+
name|EMAC_REG_RX_PFC_STATS_XON_SENT
argument_list|)
expr_stmt|;
name|val_xon
operator|&=
name|EMAC_REG_RX_PFC_STATS_XON_SENT_COUNT
expr_stmt|;
name|pfc_frames_sent
index|[
literal|0
index|]
operator|=
name|val_xon
operator|+
name|val_xoff
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read pfc statistic*/
end_comment

begin_function
name|void
name|elink_pfc_statistic
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|,
name|uint32_t
name|pfc_frames_sent
index|[
literal|2
index|]
parameter_list|,
name|uint32_t
name|pfc_frames_received
index|[
literal|2
index|]
parameter_list|)
block|{
comment|/* Read pfc statistic */
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"pfc statistic\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vars
operator|->
name|link_up
condition|)
return|return;
if|if
condition|(
name|vars
operator|->
name|mac_type
operator|==
name|ELINK_MAC_TYPE_EMAC
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"About to read PFC stats from EMAC\n"
argument_list|)
expr_stmt|;
name|elink_emac_get_pfc_stat
argument_list|(
name|params
argument_list|,
name|pfc_frames_sent
argument_list|,
name|pfc_frames_received
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************/
end_comment

begin_comment
comment|/*			MAC/PBF section				  */
end_comment

begin_comment
comment|/******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|elink_set_mdio_clk
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|chip_id
parameter_list|,
name|uint32_t
name|emac_base
parameter_list|)
block|{
name|uint32_t
name|new_mode
decl_stmt|,
name|cur_mode
decl_stmt|;
name|uint32_t
name|clc_cnt
decl_stmt|;
comment|/* Set clause 45 mode, slow down the MDIO clock to 2.5MHz 	 * (a value of 49==0x31) and make sure that the AUTO poll is off 	 */
name|cur_mode
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|emac_base
operator|+
name|EMAC_REG_EMAC_MDIO_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|USES_WARPCORE
argument_list|(
name|sc
argument_list|)
condition|)
name|clc_cnt
operator|=
literal|74L
operator|<<
name|EMAC_MDIO_MODE_CLOCK_CNT_BITSHIFT
expr_stmt|;
else|else
name|clc_cnt
operator|=
literal|49L
operator|<<
name|EMAC_MDIO_MODE_CLOCK_CNT_BITSHIFT
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|cur_mode
operator|&
name|EMAC_MDIO_MODE_CLOCK_CNT
operator|)
operator|==
name|clc_cnt
operator|)
operator|&&
operator|(
name|cur_mode
operator|&
operator|(
name|EMAC_MDIO_MODE_CLAUSE_45
operator|)
operator|)
condition|)
return|return;
name|new_mode
operator|=
name|cur_mode
operator|&
operator|~
operator|(
name|EMAC_MDIO_MODE_AUTO_POLL
operator||
name|EMAC_MDIO_MODE_CLOCK_CNT
operator|)
expr_stmt|;
name|new_mode
operator||=
name|clc_cnt
expr_stmt|;
name|new_mode
operator||=
operator|(
name|EMAC_MDIO_MODE_CLAUSE_45
operator|)
expr_stmt|;
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"Changing emac_mode from 0x%x to 0x%x\n"
argument_list|,
name|cur_mode
argument_list|,
name|new_mode
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|emac_base
operator|+
name|EMAC_REG_EMAC_MDIO_MODE
argument_list|,
name|new_mode
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|40
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|elink_is_4_port_mode
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|port4mode_ovwr_val
decl_stmt|;
comment|/* Check 4-port override enabled */
name|port4mode_ovwr_val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_PORT4MODE_EN_OVWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|port4mode_ovwr_val
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
condition|)
block|{
comment|/* Return 4-port mode override value */
return|return
operator|(
operator|(
name|port4mode_ovwr_val
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
operator|)
operator|==
operator|(
literal|1
operator|<<
literal|1
operator|)
operator|)
return|;
block|}
comment|/* Return 4-port mode from input pin */
return|return
operator|(
name|uint8_t
operator|)
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_PORT4MODE_EN
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_set_mdio_emac_per_phy
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|uint8_t
name|phy_index
decl_stmt|;
comment|/* Set mdio clock per phy */
for|for
control|(
name|phy_index
operator|=
name|ELINK_INT_PHY
init|;
name|phy_index
operator|<
name|params
operator|->
name|num_phys
condition|;
name|phy_index
operator|++
control|)
name|elink_set_mdio_clk
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|chip_id
argument_list|,
name|params
operator|->
name|phy
index|[
name|phy_index
index|]
operator|.
name|mdio_ctrl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_emac_init
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
comment|/* reset and unreset the emac core */
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint8_t
name|port
init|=
name|params
operator|->
name|port
decl_stmt|;
name|uint32_t
name|emac_base
init|=
name|port
condition|?
name|GRCBASE_EMAC1
else|:
name|GRCBASE_EMAC0
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|uint16_t
name|timeout
decl_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_2_CLEAR
argument_list|,
operator|(
name|MISC_REGISTERS_RESET_REG_2_RST_EMAC0_HARD_CORE
operator|<<
name|port
operator|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_2_SET
argument_list|,
operator|(
name|MISC_REGISTERS_RESET_REG_2_RST_EMAC0_HARD_CORE
operator|<<
name|port
operator|)
argument_list|)
expr_stmt|;
comment|/* init emac - use read-modify-write */
comment|/* self clear reset */
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|emac_base
operator|+
name|EMAC_REG_EMAC_MODE
argument_list|)
expr_stmt|;
name|elink_cb_reg_write
argument_list|(
name|sc
argument_list|,
name|emac_base
operator|+
name|EMAC_REG_EMAC_MODE
argument_list|,
operator|(
name|val
operator||
name|EMAC_MODE_RESET
operator|)
argument_list|)
expr_stmt|;
name|timeout
operator|=
literal|200
expr_stmt|;
do|do
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|emac_base
operator|+
name|EMAC_REG_EMAC_MODE
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"EMAC reset reg is %u\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|timeout
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"EMAC timeout!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|timeout
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|val
operator|&
name|EMAC_MODE_RESET
condition|)
do|;
name|elink_set_mdio_emac_per_phy
argument_list|(
name|sc
argument_list|,
name|params
argument_list|)
expr_stmt|;
comment|/* Set mac address */
name|val
operator|=
operator|(
operator|(
name|params
operator|->
name|mac_addr
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|params
operator|->
name|mac_addr
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|elink_cb_reg_write
argument_list|(
name|sc
argument_list|,
name|emac_base
operator|+
name|EMAC_REG_EMAC_MAC_MATCH
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|params
operator|->
name|mac_addr
index|[
literal|2
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|params
operator|->
name|mac_addr
index|[
literal|3
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|params
operator|->
name|mac_addr
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator||
name|params
operator|->
name|mac_addr
index|[
literal|5
index|]
operator|)
expr_stmt|;
name|elink_cb_reg_write
argument_list|(
name|sc
argument_list|,
name|emac_base
operator|+
name|EMAC_REG_EMAC_MAC_MATCH
operator|+
literal|4
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_set_xumac_nig
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint16_t
name|tx_pause_en
parameter_list|,
name|uint8_t
name|enable
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|port
condition|?
name|NIG_REG_P1_MAC_IN_EN
else|:
name|NIG_REG_P0_MAC_IN_EN
argument_list|,
name|enable
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|port
condition|?
name|NIG_REG_P1_MAC_OUT_EN
else|:
name|NIG_REG_P0_MAC_OUT_EN
argument_list|,
name|enable
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|port
condition|?
name|NIG_REG_P1_MAC_PAUSE_OUT_EN
else|:
name|NIG_REG_P0_MAC_PAUSE_OUT_EN
argument_list|,
name|tx_pause_en
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_set_umac_rxtx
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint8_t
name|en
parameter_list|)
block|{
name|uint32_t
name|umac_base
init|=
name|params
operator|->
name|port
condition|?
name|GRCBASE_UMAC1
else|:
name|GRCBASE_UMAC0
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_RESET_REG_2
argument_list|)
operator|&
operator|(
name|MISC_REGISTERS_RESET_REG_2_UMAC0
operator|<<
name|params
operator|->
name|port
operator|)
operator|)
condition|)
return|return;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|umac_base
operator|+
name|UMAC_REG_COMMAND_CONFIG
argument_list|)
expr_stmt|;
if|if
condition|(
name|en
condition|)
name|val
operator||=
operator|(
name|UMAC_COMMAND_CONFIG_REG_TX_ENA
operator||
name|UMAC_COMMAND_CONFIG_REG_RX_ENA
operator|)
expr_stmt|;
else|else
name|val
operator|&=
operator|~
operator|(
name|UMAC_COMMAND_CONFIG_REG_TX_ENA
operator||
name|UMAC_COMMAND_CONFIG_REG_RX_ENA
operator|)
expr_stmt|;
comment|/* Disable RX and TX */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|umac_base
operator|+
name|UMAC_REG_COMMAND_CONFIG
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_umac_enable
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|,
name|uint8_t
name|lb
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|uint32_t
name|umac_base
init|=
name|params
operator|->
name|port
condition|?
name|GRCBASE_UMAC1
else|:
name|GRCBASE_UMAC0
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
comment|/* Reset UMAC */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_2_CLEAR
argument_list|,
operator|(
name|MISC_REGISTERS_RESET_REG_2_UMAC0
operator|<<
name|params
operator|->
name|port
operator|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
operator|*
literal|1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_2_SET
argument_list|,
operator|(
name|MISC_REGISTERS_RESET_REG_2_UMAC0
operator|<<
name|params
operator|->
name|port
operator|)
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"enabling UMAC\n"
argument_list|)
expr_stmt|;
comment|/* This register opens the gate for the UMAC despite its name */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_EGRESS_EMAC0_PORT
operator|+
name|params
operator|->
name|port
operator|*
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|val
operator|=
name|UMAC_COMMAND_CONFIG_REG_PROMIS_EN
operator||
name|UMAC_COMMAND_CONFIG_REG_PAD_EN
operator||
name|UMAC_COMMAND_CONFIG_REG_SW_RESET
operator||
name|UMAC_COMMAND_CONFIG_REG_NO_LGTH_CHECK
expr_stmt|;
switch|switch
condition|(
name|vars
operator|->
name|line_speed
condition|)
block|{
case|case
name|ELINK_SPEED_10
case|:
name|val
operator||=
operator|(
literal|0
operator|<<
literal|2
operator|)
expr_stmt|;
break|break;
case|case
name|ELINK_SPEED_100
case|:
name|val
operator||=
operator|(
literal|1
operator|<<
literal|2
operator|)
expr_stmt|;
break|break;
case|case
name|ELINK_SPEED_1000
case|:
name|val
operator||=
operator|(
literal|2
operator|<<
literal|2
operator|)
expr_stmt|;
break|break;
case|case
name|ELINK_SPEED_2500
case|:
name|val
operator||=
operator|(
literal|3
operator|<<
literal|2
operator|)
expr_stmt|;
break|break;
default|default:
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Invalid speed for UMAC %d\n"
argument_list|,
name|vars
operator|->
name|line_speed
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|vars
operator|->
name|flow_ctrl
operator|&
name|ELINK_FLOW_CTRL_TX
operator|)
condition|)
name|val
operator||=
name|UMAC_COMMAND_CONFIG_REG_IGNORE_TX_PAUSE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|vars
operator|->
name|flow_ctrl
operator|&
name|ELINK_FLOW_CTRL_RX
operator|)
condition|)
name|val
operator||=
name|UMAC_COMMAND_CONFIG_REG_PAUSE_IGNORE
expr_stmt|;
if|if
condition|(
name|vars
operator|->
name|duplex
operator|==
name|DUPLEX_HALF
condition|)
name|val
operator||=
name|UMAC_COMMAND_CONFIG_REG_HD_ENA
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|umac_base
operator|+
name|UMAC_REG_COMMAND_CONFIG
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|/* Configure UMAC for EEE */
if|if
condition|(
name|vars
operator|->
name|eee_status
operator|&
name|SHMEM_EEE_ADV_STATUS_MASK
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"configured UMAC for EEE\n"
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|umac_base
operator|+
name|UMAC_REG_UMAC_EEE_CTRL
argument_list|,
name|UMAC_UMAC_EEE_CTRL_REG_EEE_EN
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|umac_base
operator|+
name|UMAC_REG_EEE_WAKE_TIMER
argument_list|,
literal|0x11
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|umac_base
operator|+
name|UMAC_REG_UMAC_EEE_CTRL
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
comment|/* Set MAC address for source TX Pause/PFC frames (under SW reset) */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|umac_base
operator|+
name|UMAC_REG_MAC_ADDR0
argument_list|,
operator|(
operator|(
name|params
operator|->
name|mac_addr
index|[
literal|2
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|params
operator|->
name|mac_addr
index|[
literal|3
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|params
operator|->
name|mac_addr
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|params
operator|->
name|mac_addr
index|[
literal|5
index|]
operator|)
operator|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|umac_base
operator|+
name|UMAC_REG_MAC_ADDR1
argument_list|,
operator|(
operator|(
name|params
operator|->
name|mac_addr
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|params
operator|->
name|mac_addr
index|[
literal|1
index|]
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Enable RX and TX */
name|val
operator|&=
operator|~
name|UMAC_COMMAND_CONFIG_REG_PAD_EN
expr_stmt|;
name|val
operator||=
name|UMAC_COMMAND_CONFIG_REG_TX_ENA
operator||
name|UMAC_COMMAND_CONFIG_REG_RX_ENA
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|umac_base
operator|+
name|UMAC_REG_COMMAND_CONFIG
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|/* Remove SW Reset */
name|val
operator|&=
operator|~
name|UMAC_COMMAND_CONFIG_REG_SW_RESET
expr_stmt|;
comment|/* Check loopback mode */
if|if
condition|(
name|lb
condition|)
name|val
operator||=
name|UMAC_COMMAND_CONFIG_REG_LOOP_ENA
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|umac_base
operator|+
name|UMAC_REG_COMMAND_CONFIG
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Maximum Frame Length (RW). Defines a 14-Bit maximum frame 	 * length used by the MAC receive logic to check frames. 	 */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|umac_base
operator|+
name|UMAC_REG_MAXFR
argument_list|,
literal|0x2710
argument_list|)
expr_stmt|;
name|elink_set_xumac_nig
argument_list|(
name|params
argument_list|,
operator|(
operator|(
name|vars
operator|->
name|flow_ctrl
operator|&
name|ELINK_FLOW_CTRL_TX
operator|)
operator|!=
literal|0
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vars
operator|->
name|mac_type
operator|=
name|ELINK_MAC_TYPE_UMAC
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define the XMAC mode */
end_comment

begin_function
specifier|static
name|void
name|elink_xmac_init
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint32_t
name|max_speed
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint32_t
name|is_port4mode
init|=
name|elink_is_4_port_mode
argument_list|(
name|sc
argument_list|)
decl_stmt|;
comment|/* In 4-port mode, need to set the mode only once, so if XMAC is 	 * already out of reset, it means the mode has already been set, 	 * and it must not* reset the XMAC again, since it controls both 	 * ports of the path 	 */
if|if
condition|(
operator|(
operator|(
name|CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|CHIP_NUM_57840_4_10
operator|)
operator|||
operator|(
name|CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|CHIP_NUM_57840_2_20
operator|)
operator|||
operator|(
name|CHIP_NUM
argument_list|(
name|sc
argument_list|)
operator|==
name|CHIP_NUM_57840_OBS
operator|)
operator|)
operator|&&
name|is_port4mode
operator|&&
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_RESET_REG_2
argument_list|)
operator|&
name|MISC_REGISTERS_RESET_REG_2_XMAC
operator|)
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"XMAC already out of reset in 4-port mode\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Hard reset */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_2_CLEAR
argument_list|,
name|MISC_REGISTERS_RESET_REG_2_XMAC
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
operator|*
literal|1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_2_SET
argument_list|,
name|MISC_REGISTERS_RESET_REG_2_XMAC
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_port4mode
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Init XMAC to 2 ports x 10G per path\n"
argument_list|)
expr_stmt|;
comment|/* Set the number of ports on the system side to up to 2 */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_XMAC_CORE_PORT_MODE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Set the number of ports on the Warp Core to 10G */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_XMAC_PHY_PORT_MODE
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Set the number of ports on the system side to 1 */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_XMAC_CORE_PORT_MODE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_speed
operator|==
name|ELINK_SPEED_10000
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Init XMAC to 10G x 1 port per path\n"
argument_list|)
expr_stmt|;
comment|/* Set the number of ports on the Warp Core to 10G */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_XMAC_PHY_PORT_MODE
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Init XMAC to 20G x 2 ports per path\n"
argument_list|)
expr_stmt|;
comment|/* Set the number of ports on the Warp Core to 20G */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_XMAC_PHY_PORT_MODE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Soft reset */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_2_CLEAR
argument_list|,
name|MISC_REGISTERS_RESET_REG_2_XMAC_SOFT
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
operator|*
literal|1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_2_SET
argument_list|,
name|MISC_REGISTERS_RESET_REG_2_XMAC_SOFT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_set_xmac_rxtx
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint8_t
name|en
parameter_list|)
block|{
name|uint8_t
name|port
init|=
name|params
operator|->
name|port
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint32_t
name|pfc_ctrl
decl_stmt|,
name|xmac_base
init|=
operator|(
name|port
operator|)
condition|?
name|GRCBASE_XMAC1
else|:
name|GRCBASE_XMAC0
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
if|if
condition|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_RESET_REG_2
argument_list|)
operator|&
name|MISC_REGISTERS_RESET_REG_2_XMAC
condition|)
block|{
comment|/* Send an indication to change the state in the NIG back to XON 		 * Clearing this bit enables the next set of this bit to get 		 * rising edge 		 */
name|pfc_ctrl
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|xmac_base
operator|+
name|XMAC_REG_PFC_CTRL_HI
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|xmac_base
operator|+
name|XMAC_REG_PFC_CTRL_HI
argument_list|,
operator|(
name|pfc_ctrl
operator|&
operator|~
operator|(
literal|1
operator|<<
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|xmac_base
operator|+
name|XMAC_REG_PFC_CTRL_HI
argument_list|,
operator|(
name|pfc_ctrl
operator||
operator|(
literal|1
operator|<<
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Disable XMAC on port %x\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|xmac_base
operator|+
name|XMAC_REG_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|en
condition|)
name|val
operator||=
operator|(
name|XMAC_CTRL_REG_TX_EN
operator||
name|XMAC_CTRL_REG_RX_EN
operator|)
expr_stmt|;
else|else
name|val
operator|&=
operator|~
operator|(
name|XMAC_CTRL_REG_TX_EN
operator||
name|XMAC_CTRL_REG_RX_EN
operator|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|xmac_base
operator|+
name|XMAC_REG_CTRL
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_xmac_enable
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|,
name|uint8_t
name|lb
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|,
name|xmac_base
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"enabling XMAC\n"
argument_list|)
expr_stmt|;
name|xmac_base
operator|=
operator|(
name|params
operator|->
name|port
operator|)
condition|?
name|GRCBASE_XMAC1
else|:
name|GRCBASE_XMAC0
expr_stmt|;
name|elink_xmac_init
argument_list|(
name|params
argument_list|,
name|vars
operator|->
name|line_speed
argument_list|)
expr_stmt|;
comment|/* This register determines on which events the MAC will assert 	 * error on the i/f to the NIG along w/ EOP. 	 */
comment|/* This register tells the NIG whether to send traffic to UMAC 	 * or XMAC 	 */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_EGRESS_EMAC0_PORT
operator|+
name|params
operator|->
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* When XMAC is in XLGMII mode, disable sending idles for fault 	 * detection. 	 */
if|if
condition|(
operator|!
operator|(
name|params
operator|->
name|phy
index|[
name|ELINK_INT_PHY
index|]
operator|.
name|flags
operator|&
name|ELINK_FLAGS_TX_ERROR_CHECK
operator|)
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|xmac_base
operator|+
name|XMAC_REG_RX_LSS_CTRL
argument_list|,
operator|(
name|XMAC_RX_LSS_CTRL_REG_LOCAL_FAULT_DISABLE
operator||
name|XMAC_RX_LSS_CTRL_REG_REMOTE_FAULT_DISABLE
operator|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|xmac_base
operator|+
name|XMAC_REG_CLEAR_RX_LSS_STATUS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|xmac_base
operator|+
name|XMAC_REG_CLEAR_RX_LSS_STATUS
argument_list|,
name|XMAC_CLEAR_RX_LSS_STATUS_REG_CLEAR_LOCAL_FAULT_STATUS
operator||
name|XMAC_CLEAR_RX_LSS_STATUS_REG_CLEAR_REMOTE_FAULT_STATUS
argument_list|)
expr_stmt|;
block|}
comment|/* Set Max packet size */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|xmac_base
operator|+
name|XMAC_REG_RX_MAX_SIZE
argument_list|,
literal|0x2710
argument_list|)
expr_stmt|;
comment|/* CRC append for Tx packets */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|xmac_base
operator|+
name|XMAC_REG_TX_CTRL
argument_list|,
literal|0xC800
argument_list|)
expr_stmt|;
comment|/* update PFC */
name|elink_update_pfc_xmac
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vars
operator|->
name|eee_status
operator|&
name|SHMEM_EEE_ADV_STATUS_MASK
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Setting XMAC for EEE\n"
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|xmac_base
operator|+
name|XMAC_REG_EEE_TIMERS_HI
argument_list|,
literal|0x1380008
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|xmac_base
operator|+
name|XMAC_REG_EEE_CTRL
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|xmac_base
operator|+
name|XMAC_REG_EEE_CTRL
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
comment|/* Enable TX and RX */
name|val
operator|=
name|XMAC_CTRL_REG_TX_EN
operator||
name|XMAC_CTRL_REG_RX_EN
expr_stmt|;
comment|/* Set MAC in XLGMII mode for dual-mode */
if|if
condition|(
operator|(
name|vars
operator|->
name|line_speed
operator|==
name|ELINK_SPEED_20000
operator|)
operator|&&
operator|(
name|params
operator|->
name|phy
index|[
name|ELINK_INT_PHY
index|]
operator|.
name|supported
operator|&
name|ELINK_SUPPORTED_20000baseKR2_Full
operator|)
condition|)
name|val
operator||=
name|XMAC_CTRL_REG_XLGMII_ALIGN_ENB
expr_stmt|;
comment|/* Check loopback mode */
if|if
condition|(
name|lb
condition|)
name|val
operator||=
name|XMAC_CTRL_REG_LINE_LOCAL_LPBK
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|xmac_base
operator|+
name|XMAC_REG_CTRL
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|elink_set_xumac_nig
argument_list|(
name|params
argument_list|,
operator|(
operator|(
name|vars
operator|->
name|flow_ctrl
operator|&
name|ELINK_FLOW_CTRL_TX
operator|)
operator|!=
literal|0
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vars
operator|->
name|mac_type
operator|=
name|ELINK_MAC_TYPE_XMAC
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_emac_enable
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|,
name|uint8_t
name|lb
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint8_t
name|port
init|=
name|params
operator|->
name|port
decl_stmt|;
name|uint32_t
name|emac_base
init|=
name|port
condition|?
name|GRCBASE_EMAC1
else|:
name|GRCBASE_EMAC0
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"enabling EMAC\n"
argument_list|)
expr_stmt|;
comment|/* Disable BMAC */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_2_CLEAR
argument_list|,
operator|(
name|MISC_REGISTERS_RESET_REG_2_RST_BMAC0
operator|<<
name|port
operator|)
argument_list|)
expr_stmt|;
comment|/* enable emac and not bmac */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_EGRESS_EMAC0_PORT
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ELINK_INCLUDE_EMUL
comment|/* for paladium */
if|if
condition|(
name|CHIP_REV_IS_EMUL
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* Use lane 1 (of lanes 0-3) */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_XGXS_LANE_SEL_P0
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_XGXS_SERDES0_MODE_SEL
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* for fpga */
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ELINK_INCLUDE_FPGA
if|if
condition|(
name|CHIP_REV_IS_FPGA
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* Use lane 1 (of lanes 0-3) */
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"elink_emac_enable: Setting FPGA\n"
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_XGXS_LANE_SEL_P0
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_XGXS_SERDES0_MODE_SEL
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* ASIC */
if|if
condition|(
name|vars
operator|->
name|phy_flags
operator|&
name|PHY_XGXS_FLAG
condition|)
block|{
name|uint32_t
name|ser_lane
init|=
operator|(
operator|(
name|params
operator|->
name|lane_config
operator|&
name|PORT_HW_CFG_LANE_SWAP_CFG_MASTER_MASK
operator|)
operator|>>
name|PORT_HW_CFG_LANE_SWAP_CFG_MASTER_SHIFT
operator|)
decl_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"XGXS\n"
argument_list|)
expr_stmt|;
comment|/* select the master lanes (out of 0-3) */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_XGXS_LANE_SEL_P0
operator|+
name|port
operator|*
literal|4
argument_list|,
name|ser_lane
argument_list|)
expr_stmt|;
comment|/* select XGXS */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_XGXS_SERDES0_MODE_SEL
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* SerDes */
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"SerDes\n"
argument_list|)
expr_stmt|;
comment|/* select SerDes */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_XGXS_SERDES0_MODE_SEL
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|elink_bits_en
argument_list|(
name|sc
argument_list|,
name|emac_base
operator|+
name|EMAC_REG_EMAC_RX_MODE
argument_list|,
name|EMAC_RX_MODE_RESET
argument_list|)
expr_stmt|;
name|elink_bits_en
argument_list|(
name|sc
argument_list|,
name|emac_base
operator|+
name|EMAC_REG_EMAC_TX_MODE
argument_list|,
name|EMAC_TX_MODE_RESET
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ELINK_INCLUDE_EMUL
argument_list|)
operator|||
name|defined
argument_list|(
name|ELINK_INCLUDE_FPGA
argument_list|)
if|if
condition|(
name|CHIP_REV_IS_SLOW
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* config GMII mode */
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|emac_base
operator|+
name|EMAC_REG_EMAC_MODE
argument_list|)
expr_stmt|;
name|elink_cb_reg_write
argument_list|(
name|sc
argument_list|,
name|emac_base
operator|+
name|EMAC_REG_EMAC_MODE
argument_list|,
operator|(
name|val
operator||
name|EMAC_MODE_PORT_GMII
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* ASIC */
endif|#
directive|endif
comment|/* pause enable/disable */
name|elink_bits_dis
argument_list|(
name|sc
argument_list|,
name|emac_base
operator|+
name|EMAC_REG_EMAC_RX_MODE
argument_list|,
name|EMAC_RX_MODE_FLOW_EN
argument_list|)
expr_stmt|;
name|elink_bits_dis
argument_list|(
name|sc
argument_list|,
name|emac_base
operator|+
name|EMAC_REG_EMAC_TX_MODE
argument_list|,
operator|(
name|EMAC_TX_MODE_EXT_PAUSE_EN
operator||
name|EMAC_TX_MODE_FLOW_EN
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|params
operator|->
name|feature_config_flags
operator|&
name|ELINK_FEATURE_CONFIG_PFC_ENABLED
operator|)
condition|)
block|{
if|if
condition|(
name|vars
operator|->
name|flow_ctrl
operator|&
name|ELINK_FLOW_CTRL_RX
condition|)
name|elink_bits_en
argument_list|(
name|sc
argument_list|,
name|emac_base
operator|+
name|EMAC_REG_EMAC_RX_MODE
argument_list|,
name|EMAC_RX_MODE_FLOW_EN
argument_list|)
expr_stmt|;
if|if
condition|(
name|vars
operator|->
name|flow_ctrl
operator|&
name|ELINK_FLOW_CTRL_TX
condition|)
name|elink_bits_en
argument_list|(
name|sc
argument_list|,
name|emac_base
operator|+
name|EMAC_REG_EMAC_TX_MODE
argument_list|,
operator|(
name|EMAC_TX_MODE_EXT_PAUSE_EN
operator||
name|EMAC_TX_MODE_FLOW_EN
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|elink_bits_en
argument_list|(
name|sc
argument_list|,
name|emac_base
operator|+
name|EMAC_REG_EMAC_TX_MODE
argument_list|,
name|EMAC_TX_MODE_FLOW_EN
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ELINK_INCLUDE_EMUL
argument_list|)
operator|||
name|defined
argument_list|(
name|ELINK_INCLUDE_FPGA
argument_list|)
block|}
endif|#
directive|endif
comment|/* KEEP_VLAN_TAG, promiscuous */
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|emac_base
operator|+
name|EMAC_REG_EMAC_RX_MODE
argument_list|)
expr_stmt|;
name|val
operator||=
name|EMAC_RX_MODE_KEEP_VLAN_TAG
operator||
name|EMAC_RX_MODE_PROMISCUOUS
expr_stmt|;
comment|/* Setting this bit causes MAC control frames (except for pause 	 * frames) to be passed on for processing. This setting has no 	 * affect on the operation of the pause frames. This bit effects 	 * all packets regardless of RX Parser packet sorting logic. 	 * Turn the PFC off to make sure we are in Xon state before 	 * enabling it. 	 */
name|elink_cb_reg_write
argument_list|(
name|sc
argument_list|,
name|emac_base
operator|+
name|EMAC_REG_RX_PFC_MODE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|feature_config_flags
operator|&
name|ELINK_FEATURE_CONFIG_PFC_ENABLED
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"PFC is enabled\n"
argument_list|)
expr_stmt|;
comment|/* Enable PFC again */
name|elink_cb_reg_write
argument_list|(
name|sc
argument_list|,
name|emac_base
operator|+
name|EMAC_REG_RX_PFC_MODE
argument_list|,
name|EMAC_REG_RX_PFC_MODE_RX_EN
operator||
name|EMAC_REG_RX_PFC_MODE_TX_EN
operator||
name|EMAC_REG_RX_PFC_MODE_PRIORITIES
argument_list|)
expr_stmt|;
name|elink_cb_reg_write
argument_list|(
name|sc
argument_list|,
name|emac_base
operator|+
name|EMAC_REG_RX_PFC_PARAM
argument_list|,
operator|(
operator|(
literal|0x0101
operator|<<
name|EMAC_REG_RX_PFC_PARAM_OPCODE_BITSHIFT
operator|)
operator||
operator|(
literal|0x00ff
operator|<<
name|EMAC_REG_RX_PFC_PARAM_PRIORITY_EN_BITSHIFT
operator|)
operator|)
argument_list|)
expr_stmt|;
name|val
operator||=
name|EMAC_RX_MODE_KEEP_MAC_CONTROL
expr_stmt|;
block|}
name|elink_cb_reg_write
argument_list|(
name|sc
argument_list|,
name|emac_base
operator|+
name|EMAC_REG_EMAC_RX_MODE
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Set Loopback */
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|emac_base
operator|+
name|EMAC_REG_EMAC_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|lb
condition|)
name|val
operator||=
literal|0x810
expr_stmt|;
else|else
name|val
operator|&=
operator|~
literal|0x810
expr_stmt|;
name|elink_cb_reg_write
argument_list|(
name|sc
argument_list|,
name|emac_base
operator|+
name|EMAC_REG_EMAC_MODE
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Enable emac */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_NIG_EMAC0_EN
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Enable emac for jumbo packets */
name|elink_cb_reg_write
argument_list|(
name|sc
argument_list|,
name|emac_base
operator|+
name|EMAC_REG_EMAC_RX_MTU_SIZE
argument_list|,
operator|(
name|EMAC_RX_MTU_SIZE_JUMBO_ENA
operator||
operator|(
name|ELINK_ETH_MAX_JUMBO_PACKET_SIZE
operator|+
name|ELINK_ETH_OVREHEAD
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Strip CRC */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_NIG_INGRESS_EMAC0_NO_CRC
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
comment|/* Disable the NIG in/out to the bmac */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_BMAC0_IN_EN
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_BMAC0_PAUSE_OUT_EN
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_BMAC0_OUT_EN
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* Enable the NIG in/out to the emac */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_EMAC0_IN_EN
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|params
operator|->
name|feature_config_flags
operator|&
name|ELINK_FEATURE_CONFIG_PFC_ENABLED
operator|)
operator|||
operator|(
name|vars
operator|->
name|flow_ctrl
operator|&
name|ELINK_FLOW_CTRL_TX
operator|)
condition|)
name|val
operator|=
literal|1
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_EMAC0_PAUSE_OUT_EN
operator|+
name|port
operator|*
literal|4
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_EGRESS_EMAC0_OUT_EN
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ELINK_INCLUDE_EMUL
if|if
condition|(
name|CHIP_REV_IS_EMUL
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* Take the BigMac out of reset */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_2_SET
argument_list|,
operator|(
name|MISC_REGISTERS_RESET_REG_2_RST_BMAC0
operator|<<
name|port
operator|)
argument_list|)
expr_stmt|;
comment|/* Enable access for bmac registers */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_BMAC0_REGS_OUT_EN
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_BMAC0_REGS_OUT_EN
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|vars
operator|->
name|mac_type
operator|=
name|ELINK_MAC_TYPE_EMAC
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_update_pfc_bmac1
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|uint32_t
name|wb_data
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint32_t
name|bmac_addr
init|=
name|params
operator|->
name|port
condition|?
name|NIG_REG_INGRESS_BMAC1_MEM
else|:
name|NIG_REG_INGRESS_BMAC0_MEM
decl_stmt|;
name|uint32_t
name|val
init|=
literal|0x14
decl_stmt|;
if|if
condition|(
operator|(
operator|!
operator|(
name|params
operator|->
name|feature_config_flags
operator|&
name|ELINK_FEATURE_CONFIG_PFC_ENABLED
operator|)
operator|)
operator|&&
operator|(
name|vars
operator|->
name|flow_ctrl
operator|&
name|ELINK_FLOW_CTRL_RX
operator|)
condition|)
comment|/* Enable BigMAC to react on received Pause packets */
name|val
operator||=
operator|(
literal|1
operator|<<
literal|5
operator|)
expr_stmt|;
name|wb_data
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
name|wb_data
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|REG_WR_DMAE
argument_list|(
name|sc
argument_list|,
name|bmac_addr
operator|+
name|BIGMAC_REGISTER_RX_CONTROL
argument_list|,
name|wb_data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* TX control */
name|val
operator|=
literal|0xc0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|params
operator|->
name|feature_config_flags
operator|&
name|ELINK_FEATURE_CONFIG_PFC_ENABLED
operator|)
operator|&&
operator|(
name|vars
operator|->
name|flow_ctrl
operator|&
name|ELINK_FLOW_CTRL_TX
operator|)
condition|)
name|val
operator||=
literal|0x800000
expr_stmt|;
name|wb_data
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
name|wb_data
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|REG_WR_DMAE
argument_list|(
name|sc
argument_list|,
name|bmac_addr
operator|+
name|BIGMAC_REGISTER_TX_CONTROL
argument_list|,
name|wb_data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_update_pfc_bmac2
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|,
name|uint8_t
name|is_lb
parameter_list|)
block|{
comment|/* Set rx control: Strip CRC and enable BigMAC to relay 	 * control packets to the system as well 	 */
name|uint32_t
name|wb_data
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint32_t
name|bmac_addr
init|=
name|params
operator|->
name|port
condition|?
name|NIG_REG_INGRESS_BMAC1_MEM
else|:
name|NIG_REG_INGRESS_BMAC0_MEM
decl_stmt|;
name|uint32_t
name|val
init|=
literal|0x14
decl_stmt|;
if|if
condition|(
operator|(
operator|!
operator|(
name|params
operator|->
name|feature_config_flags
operator|&
name|ELINK_FEATURE_CONFIG_PFC_ENABLED
operator|)
operator|)
operator|&&
operator|(
name|vars
operator|->
name|flow_ctrl
operator|&
name|ELINK_FLOW_CTRL_RX
operator|)
condition|)
comment|/* Enable BigMAC to react on received Pause packets */
name|val
operator||=
operator|(
literal|1
operator|<<
literal|5
operator|)
expr_stmt|;
name|wb_data
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
name|wb_data
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|REG_WR_DMAE
argument_list|(
name|sc
argument_list|,
name|bmac_addr
operator|+
name|BIGMAC2_REGISTER_RX_CONTROL
argument_list|,
name|wb_data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|30
argument_list|)
expr_stmt|;
comment|/* Tx control */
name|val
operator|=
literal|0xc0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|params
operator|->
name|feature_config_flags
operator|&
name|ELINK_FEATURE_CONFIG_PFC_ENABLED
operator|)
operator|&&
operator|(
name|vars
operator|->
name|flow_ctrl
operator|&
name|ELINK_FLOW_CTRL_TX
operator|)
condition|)
name|val
operator||=
literal|0x800000
expr_stmt|;
name|wb_data
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
name|wb_data
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|REG_WR_DMAE
argument_list|(
name|sc
argument_list|,
name|bmac_addr
operator|+
name|BIGMAC2_REGISTER_TX_CONTROL
argument_list|,
name|wb_data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|feature_config_flags
operator|&
name|ELINK_FEATURE_CONFIG_PFC_ENABLED
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"PFC is enabled\n"
argument_list|)
expr_stmt|;
comment|/* Enable PFC RX& TX& STATS and set 8 COS  */
name|wb_data
index|[
literal|0
index|]
operator|=
literal|0x0
expr_stmt|;
name|wb_data
index|[
literal|0
index|]
operator||=
operator|(
literal|1
operator|<<
literal|0
operator|)
expr_stmt|;
comment|/* RX */
name|wb_data
index|[
literal|0
index|]
operator||=
operator|(
literal|1
operator|<<
literal|1
operator|)
expr_stmt|;
comment|/* TX */
name|wb_data
index|[
literal|0
index|]
operator||=
operator|(
literal|1
operator|<<
literal|2
operator|)
expr_stmt|;
comment|/* Force initial Xon */
name|wb_data
index|[
literal|0
index|]
operator||=
operator|(
literal|1
operator|<<
literal|3
operator|)
expr_stmt|;
comment|/* 8 cos */
name|wb_data
index|[
literal|0
index|]
operator||=
operator|(
literal|1
operator|<<
literal|5
operator|)
expr_stmt|;
comment|/* STATS */
name|wb_data
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|REG_WR_DMAE
argument_list|(
name|sc
argument_list|,
name|bmac_addr
operator|+
name|BIGMAC2_REGISTER_PFC_CONTROL
argument_list|,
name|wb_data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Clear the force Xon */
name|wb_data
index|[
literal|0
index|]
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|2
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"PFC is disabled\n"
argument_list|)
expr_stmt|;
comment|/* Disable PFC RX& TX& STATS and set 8 COS */
name|wb_data
index|[
literal|0
index|]
operator|=
literal|0x8
expr_stmt|;
name|wb_data
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|REG_WR_DMAE
argument_list|(
name|sc
argument_list|,
name|bmac_addr
operator|+
name|BIGMAC2_REGISTER_PFC_CONTROL
argument_list|,
name|wb_data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Set Time (based unit is 512 bit time) between automatic 	 * re-sending of PP packets amd enable automatic re-send of 	 * Per-Priroity Packet as long as pp_gen is asserted and 	 * pp_disable is low. 	 */
name|val
operator|=
literal|0x8000
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|feature_config_flags
operator|&
name|ELINK_FEATURE_CONFIG_PFC_ENABLED
condition|)
name|val
operator||=
operator|(
literal|1
operator|<<
literal|16
operator|)
expr_stmt|;
comment|/* enable automatic re-send */
name|wb_data
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
name|wb_data
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|REG_WR_DMAE
argument_list|(
name|sc
argument_list|,
name|bmac_addr
operator|+
name|BIGMAC2_REGISTER_TX_PAUSE_CONTROL
argument_list|,
name|wb_data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* mac control */
name|val
operator|=
literal|0x3
expr_stmt|;
comment|/* Enable RX and TX */
if|if
condition|(
name|is_lb
condition|)
block|{
name|val
operator||=
literal|0x4
expr_stmt|;
comment|/* Local loopback */
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"enable bmac loopback\n"
argument_list|)
expr_stmt|;
block|}
comment|/* When PFC enabled, Pass pause frames towards the NIG. */
if|if
condition|(
name|params
operator|->
name|feature_config_flags
operator|&
name|ELINK_FEATURE_CONFIG_PFC_ENABLED
condition|)
name|val
operator||=
operator|(
operator|(
literal|1
operator|<<
literal|6
operator|)
operator||
operator|(
literal|1
operator|<<
literal|5
operator|)
operator|)
expr_stmt|;
name|wb_data
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
name|wb_data
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|REG_WR_DMAE
argument_list|(
name|sc
argument_list|,
name|bmac_addr
operator|+
name|BIGMAC2_REGISTER_BMAC_CONTROL
argument_list|,
name|wb_data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Description: *  This function is needed because NIG ARB_CREDIT_WEIGHT_X are *  not continues and ARB_CREDIT_WEIGHT_0 + offset is suitable. ******************************************************************************/
end_comment

begin_function
specifier|static
name|elink_status_t
name|elink_pfc_nig_rx_priority_mask
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|cos_entry
parameter_list|,
name|uint32_t
name|priority_mask
parameter_list|,
name|uint8_t
name|port
parameter_list|)
block|{
name|uint32_t
name|nig_reg_rx_priority_mask_add
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cos_entry
condition|)
block|{
case|case
literal|0
case|:
name|nig_reg_rx_priority_mask_add
operator|=
operator|(
name|port
operator|)
condition|?
name|NIG_REG_P1_RX_COS0_PRIORITY_MASK
else|:
name|NIG_REG_P0_RX_COS0_PRIORITY_MASK
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|nig_reg_rx_priority_mask_add
operator|=
operator|(
name|port
operator|)
condition|?
name|NIG_REG_P1_RX_COS1_PRIORITY_MASK
else|:
name|NIG_REG_P0_RX_COS1_PRIORITY_MASK
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|nig_reg_rx_priority_mask_add
operator|=
operator|(
name|port
operator|)
condition|?
name|NIG_REG_P1_RX_COS2_PRIORITY_MASK
else|:
name|NIG_REG_P0_RX_COS2_PRIORITY_MASK
expr_stmt|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|port
condition|)
return|return
name|ELINK_STATUS_ERROR
return|;
name|nig_reg_rx_priority_mask_add
operator|=
name|NIG_REG_P0_RX_COS3_PRIORITY_MASK
expr_stmt|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|port
condition|)
return|return
name|ELINK_STATUS_ERROR
return|;
name|nig_reg_rx_priority_mask_add
operator|=
name|NIG_REG_P0_RX_COS4_PRIORITY_MASK
expr_stmt|;
break|break;
case|case
literal|5
case|:
if|if
condition|(
name|port
condition|)
return|return
name|ELINK_STATUS_ERROR
return|;
name|nig_reg_rx_priority_mask_add
operator|=
name|NIG_REG_P0_RX_COS5_PRIORITY_MASK
expr_stmt|;
break|break;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|nig_reg_rx_priority_mask_add
argument_list|,
name|priority_mask
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_update_mng
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint32_t
name|link_status
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|port_mb
index|[
name|params
operator|->
name|port
index|]
operator|.
name|link_status
argument_list|)
argument_list|,
name|link_status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_update_pfc_nig
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|,
name|struct
name|elink_nig_brb_pfc_port_params
modifier|*
name|nig_params
parameter_list|)
block|{
name|uint32_t
name|xcm_mask
init|=
literal|0
decl_stmt|,
name|ppp_enable
init|=
literal|0
decl_stmt|,
name|pause_enable
init|=
literal|0
decl_stmt|,
name|llfc_out_en
init|=
literal|0
decl_stmt|;
name|uint32_t
name|llfc_enable
init|=
literal|0
decl_stmt|,
name|xcm_out_en
init|=
literal|0
decl_stmt|,
name|hwpfc_enable
init|=
literal|0
decl_stmt|;
name|uint32_t
name|pkt_priority_to_cos
init|=
literal|0
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint8_t
name|port
init|=
name|params
operator|->
name|port
decl_stmt|;
name|int
name|set_pfc
init|=
name|params
operator|->
name|feature_config_flags
operator|&
name|ELINK_FEATURE_CONFIG_PFC_ENABLED
decl_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"updating pfc nig parameters\n"
argument_list|)
expr_stmt|;
comment|/* When NIG_LLH0_XCM_MASK_REG_LLHX_XCM_MASK_BCN bit is set 	 * MAC control frames (that are not pause packets) 	 * will be forwarded to the XCM. 	 */
name|xcm_mask
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|port
condition|?
name|NIG_REG_LLH1_XCM_MASK
else|:
name|NIG_REG_LLH0_XCM_MASK
argument_list|)
expr_stmt|;
comment|/* NIG params will override non PFC params, since it's possible to 	 * do transition from PFC to SAFC 	 */
if|if
condition|(
name|set_pfc
condition|)
block|{
name|pause_enable
operator|=
literal|0
expr_stmt|;
name|llfc_out_en
operator|=
literal|0
expr_stmt|;
name|llfc_enable
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
name|ppp_enable
operator|=
literal|0
expr_stmt|;
else|else
name|ppp_enable
operator|=
literal|1
expr_stmt|;
name|xcm_mask
operator|&=
operator|~
operator|(
name|port
condition|?
name|NIG_LLH1_XCM_MASK_REG_LLH1_XCM_MASK_BCN
else|:
name|NIG_LLH0_XCM_MASK_REG_LLH0_XCM_MASK_BCN
operator|)
expr_stmt|;
name|xcm_out_en
operator|=
literal|0
expr_stmt|;
name|hwpfc_enable
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nig_params
condition|)
block|{
name|llfc_out_en
operator|=
name|nig_params
operator|->
name|llfc_out_en
expr_stmt|;
name|llfc_enable
operator|=
name|nig_params
operator|->
name|llfc_enable
expr_stmt|;
name|pause_enable
operator|=
name|nig_params
operator|->
name|pause_enable
expr_stmt|;
block|}
else|else
comment|/* Default non PFC mode - PAUSE */
name|pause_enable
operator|=
literal|1
expr_stmt|;
name|xcm_mask
operator||=
operator|(
name|port
condition|?
name|NIG_LLH1_XCM_MASK_REG_LLH1_XCM_MASK_BCN
else|:
name|NIG_LLH0_XCM_MASK_REG_LLH0_XCM_MASK_BCN
operator|)
expr_stmt|;
name|xcm_out_en
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|port
condition|?
name|NIG_REG_BRB1_PAUSE_IN_EN
else|:
name|NIG_REG_BRB0_PAUSE_IN_EN
argument_list|,
name|pause_enable
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|port
condition|?
name|NIG_REG_LLFC_OUT_EN_1
else|:
name|NIG_REG_LLFC_OUT_EN_0
argument_list|,
name|llfc_out_en
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|port
condition|?
name|NIG_REG_LLFC_ENABLE_1
else|:
name|NIG_REG_LLFC_ENABLE_0
argument_list|,
name|llfc_enable
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|port
condition|?
name|NIG_REG_PAUSE_ENABLE_1
else|:
name|NIG_REG_PAUSE_ENABLE_0
argument_list|,
name|pause_enable
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|port
condition|?
name|NIG_REG_PPP_ENABLE_1
else|:
name|NIG_REG_PPP_ENABLE_0
argument_list|,
name|ppp_enable
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|port
condition|?
name|NIG_REG_LLH1_XCM_MASK
else|:
name|NIG_REG_LLH0_XCM_MASK
argument_list|,
name|xcm_mask
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|port
condition|?
name|NIG_REG_LLFC_EGRESS_SRC_ENABLE_1
else|:
name|NIG_REG_LLFC_EGRESS_SRC_ENABLE_0
argument_list|,
literal|0x7
argument_list|)
expr_stmt|;
comment|/* Output enable for RX_XCM # IF */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|port
condition|?
name|NIG_REG_XCM1_OUT_EN
else|:
name|NIG_REG_XCM0_OUT_EN
argument_list|,
name|xcm_out_en
argument_list|)
expr_stmt|;
comment|/* HW PFC TX enable */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|port
condition|?
name|NIG_REG_P1_HWPFC_ENABLE
else|:
name|NIG_REG_P0_HWPFC_ENABLE
argument_list|,
name|hwpfc_enable
argument_list|)
expr_stmt|;
if|if
condition|(
name|nig_params
condition|)
block|{
name|uint8_t
name|i
init|=
literal|0
decl_stmt|;
name|pkt_priority_to_cos
operator|=
name|nig_params
operator|->
name|pkt_priority_to_cos
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nig_params
operator|->
name|num_of_rx_cos_priority_mask
condition|;
name|i
operator|++
control|)
name|elink_pfc_nig_rx_priority_mask
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|nig_params
operator|->
name|rx_cos_priority_mask
index|[
name|i
index|]
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|port
condition|?
name|NIG_REG_LLFC_HIGH_PRIORITY_CLASSES_1
else|:
name|NIG_REG_LLFC_HIGH_PRIORITY_CLASSES_0
argument_list|,
name|nig_params
operator|->
name|llfc_high_priority_classes
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|port
condition|?
name|NIG_REG_LLFC_LOW_PRIORITY_CLASSES_1
else|:
name|NIG_REG_LLFC_LOW_PRIORITY_CLASSES_0
argument_list|,
name|nig_params
operator|->
name|llfc_low_priority_classes
argument_list|)
expr_stmt|;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|port
condition|?
name|NIG_REG_P1_PKT_PRIORITY_TO_COS
else|:
name|NIG_REG_P0_PKT_PRIORITY_TO_COS
argument_list|,
name|pkt_priority_to_cos
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|elink_status_t
name|elink_update_pfc
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|,
name|struct
name|elink_nig_brb_pfc_port_params
modifier|*
name|pfc_params
parameter_list|)
block|{
comment|/* The PFC and pause are orthogonal to one another, meaning when 	 * PFC is enabled, the pause are disabled, and when PFC is 	 * disabled, pause are set according to the pause result. 	 */
name|uint32_t
name|val
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint8_t
name|bmac_loopback
init|=
operator|(
name|params
operator|->
name|loopback_mode
operator|==
name|ELINK_LOOPBACK_BMAC
operator|)
decl_stmt|;
if|if
condition|(
name|params
operator|->
name|feature_config_flags
operator|&
name|ELINK_FEATURE_CONFIG_PFC_ENABLED
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_PFC_ENABLED
expr_stmt|;
else|else
name|vars
operator|->
name|link_status
operator|&=
operator|~
name|LINK_STATUS_PFC_ENABLED
expr_stmt|;
name|elink_update_mng
argument_list|(
name|params
argument_list|,
name|vars
operator|->
name|link_status
argument_list|)
expr_stmt|;
comment|/* Update NIG params */
name|elink_update_pfc_nig
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
name|pfc_params
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vars
operator|->
name|link_up
condition|)
return|return
name|ELINK_STATUS_OK
return|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"About to update PFC in BMAC\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
block|{
if|if
condition|(
name|vars
operator|->
name|mac_type
operator|==
name|ELINK_MAC_TYPE_XMAC
condition|)
name|elink_update_pfc_xmac
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_RESET_REG_2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
operator|(
name|MISC_REGISTERS_RESET_REG_2_RST_BMAC0
operator|<<
name|params
operator|->
name|port
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"About to update PFC in EMAC\n"
argument_list|)
expr_stmt|;
name|elink_emac_enable
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
if|if
condition|(
name|CHIP_IS_E2
argument_list|(
name|sc
argument_list|)
condition|)
name|elink_update_pfc_bmac2
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
name|bmac_loopback
argument_list|)
expr_stmt|;
else|else
name|elink_update_pfc_bmac1
argument_list|(
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|params
operator|->
name|feature_config_flags
operator|&
name|ELINK_FEATURE_CONFIG_PFC_ENABLED
operator|)
operator|||
operator|(
name|vars
operator|->
name|flow_ctrl
operator|&
name|ELINK_FLOW_CTRL_TX
operator|)
condition|)
name|val
operator|=
literal|1
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_BMAC0_PAUSE_OUT_EN
operator|+
name|params
operator|->
name|port
operator|*
literal|4
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_bmac1_enable
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|,
name|uint8_t
name|is_lb
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint8_t
name|port
init|=
name|params
operator|->
name|port
decl_stmt|;
name|uint32_t
name|bmac_addr
init|=
name|port
condition|?
name|NIG_REG_INGRESS_BMAC1_MEM
else|:
name|NIG_REG_INGRESS_BMAC0_MEM
decl_stmt|;
name|uint32_t
name|wb_data
index|[
literal|2
index|]
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Enabling BigMAC1\n"
argument_list|)
expr_stmt|;
comment|/* XGXS control */
name|wb_data
index|[
literal|0
index|]
operator|=
literal|0x3c
expr_stmt|;
name|wb_data
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|REG_WR_DMAE
argument_list|(
name|sc
argument_list|,
name|bmac_addr
operator|+
name|BIGMAC_REGISTER_BMAC_XGXS_CONTROL
argument_list|,
name|wb_data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* TX MAC SA */
name|wb_data
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|params
operator|->
name|mac_addr
index|[
literal|2
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|params
operator|->
name|mac_addr
index|[
literal|3
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|params
operator|->
name|mac_addr
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator||
name|params
operator|->
name|mac_addr
index|[
literal|5
index|]
operator|)
expr_stmt|;
name|wb_data
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|params
operator|->
name|mac_addr
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|params
operator|->
name|mac_addr
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|REG_WR_DMAE
argument_list|(
name|sc
argument_list|,
name|bmac_addr
operator|+
name|BIGMAC_REGISTER_TX_SOURCE_ADDR
argument_list|,
name|wb_data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* MAC control */
name|val
operator|=
literal|0x3
expr_stmt|;
if|if
condition|(
name|is_lb
condition|)
block|{
name|val
operator||=
literal|0x4
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"enable bmac loopback\n"
argument_list|)
expr_stmt|;
block|}
name|wb_data
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
name|wb_data
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|REG_WR_DMAE
argument_list|(
name|sc
argument_list|,
name|bmac_addr
operator|+
name|BIGMAC_REGISTER_BMAC_CONTROL
argument_list|,
name|wb_data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Set rx mtu */
name|wb_data
index|[
literal|0
index|]
operator|=
name|ELINK_ETH_MAX_JUMBO_PACKET_SIZE
operator|+
name|ELINK_ETH_OVREHEAD
expr_stmt|;
name|wb_data
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|REG_WR_DMAE
argument_list|(
name|sc
argument_list|,
name|bmac_addr
operator|+
name|BIGMAC_REGISTER_RX_MAX_SIZE
argument_list|,
name|wb_data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|elink_update_pfc_bmac1
argument_list|(
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
comment|/* Set tx mtu */
name|wb_data
index|[
literal|0
index|]
operator|=
name|ELINK_ETH_MAX_JUMBO_PACKET_SIZE
operator|+
name|ELINK_ETH_OVREHEAD
expr_stmt|;
name|wb_data
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|REG_WR_DMAE
argument_list|(
name|sc
argument_list|,
name|bmac_addr
operator|+
name|BIGMAC_REGISTER_TX_MAX_SIZE
argument_list|,
name|wb_data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Set cnt max size */
name|wb_data
index|[
literal|0
index|]
operator|=
name|ELINK_ETH_MAX_JUMBO_PACKET_SIZE
operator|+
name|ELINK_ETH_OVREHEAD
expr_stmt|;
name|wb_data
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|REG_WR_DMAE
argument_list|(
name|sc
argument_list|,
name|bmac_addr
operator|+
name|BIGMAC_REGISTER_CNT_MAX_SIZE
argument_list|,
name|wb_data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Configure SAFC */
name|wb_data
index|[
literal|0
index|]
operator|=
literal|0x1000200
expr_stmt|;
name|wb_data
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|REG_WR_DMAE
argument_list|(
name|sc
argument_list|,
name|bmac_addr
operator|+
name|BIGMAC_REGISTER_RX_LLFC_MSG_FLDS
argument_list|,
name|wb_data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ELINK_INCLUDE_EMUL
comment|/* Fix for emulation */
if|if
condition|(
name|CHIP_REV_IS_EMUL
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|wb_data
index|[
literal|0
index|]
operator|=
literal|0xf000
expr_stmt|;
name|wb_data
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|REG_WR_DMAE
argument_list|(
name|sc
argument_list|,
name|bmac_addr
operator|+
name|BIGMAC_REGISTER_TX_PAUSE_THRESHOLD
argument_list|,
name|wb_data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_bmac2_enable
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|,
name|uint8_t
name|is_lb
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint8_t
name|port
init|=
name|params
operator|->
name|port
decl_stmt|;
name|uint32_t
name|bmac_addr
init|=
name|port
condition|?
name|NIG_REG_INGRESS_BMAC1_MEM
else|:
name|NIG_REG_INGRESS_BMAC0_MEM
decl_stmt|;
name|uint32_t
name|wb_data
index|[
literal|2
index|]
decl_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Enabling BigMAC2\n"
argument_list|)
expr_stmt|;
name|wb_data
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|wb_data
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|REG_WR_DMAE
argument_list|(
name|sc
argument_list|,
name|bmac_addr
operator|+
name|BIGMAC2_REGISTER_BMAC_CONTROL
argument_list|,
name|wb_data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|30
argument_list|)
expr_stmt|;
comment|/* XGXS control: Reset phy HW, MDIO registers, PHY PLL and BMAC */
name|wb_data
index|[
literal|0
index|]
operator|=
literal|0x3c
expr_stmt|;
name|wb_data
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|REG_WR_DMAE
argument_list|(
name|sc
argument_list|,
name|bmac_addr
operator|+
name|BIGMAC2_REGISTER_BMAC_XGXS_CONTROL
argument_list|,
name|wb_data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|30
argument_list|)
expr_stmt|;
comment|/* TX MAC SA */
name|wb_data
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|params
operator|->
name|mac_addr
index|[
literal|2
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|params
operator|->
name|mac_addr
index|[
literal|3
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|params
operator|->
name|mac_addr
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator||
name|params
operator|->
name|mac_addr
index|[
literal|5
index|]
operator|)
expr_stmt|;
name|wb_data
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|params
operator|->
name|mac_addr
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|params
operator|->
name|mac_addr
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|REG_WR_DMAE
argument_list|(
name|sc
argument_list|,
name|bmac_addr
operator|+
name|BIGMAC2_REGISTER_TX_SOURCE_ADDR
argument_list|,
name|wb_data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|30
argument_list|)
expr_stmt|;
comment|/* Configure SAFC */
name|wb_data
index|[
literal|0
index|]
operator|=
literal|0x1000200
expr_stmt|;
name|wb_data
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|REG_WR_DMAE
argument_list|(
name|sc
argument_list|,
name|bmac_addr
operator|+
name|BIGMAC2_REGISTER_RX_LLFC_MSG_FLDS
argument_list|,
name|wb_data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|30
argument_list|)
expr_stmt|;
comment|/* Set RX MTU */
name|wb_data
index|[
literal|0
index|]
operator|=
name|ELINK_ETH_MAX_JUMBO_PACKET_SIZE
operator|+
name|ELINK_ETH_OVREHEAD
expr_stmt|;
name|wb_data
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|REG_WR_DMAE
argument_list|(
name|sc
argument_list|,
name|bmac_addr
operator|+
name|BIGMAC2_REGISTER_RX_MAX_SIZE
argument_list|,
name|wb_data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|30
argument_list|)
expr_stmt|;
comment|/* Set TX MTU */
name|wb_data
index|[
literal|0
index|]
operator|=
name|ELINK_ETH_MAX_JUMBO_PACKET_SIZE
operator|+
name|ELINK_ETH_OVREHEAD
expr_stmt|;
name|wb_data
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|REG_WR_DMAE
argument_list|(
name|sc
argument_list|,
name|bmac_addr
operator|+
name|BIGMAC2_REGISTER_TX_MAX_SIZE
argument_list|,
name|wb_data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|30
argument_list|)
expr_stmt|;
comment|/* Set cnt max size */
name|wb_data
index|[
literal|0
index|]
operator|=
name|ELINK_ETH_MAX_JUMBO_PACKET_SIZE
operator|+
name|ELINK_ETH_OVREHEAD
operator|-
literal|2
expr_stmt|;
name|wb_data
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|REG_WR_DMAE
argument_list|(
name|sc
argument_list|,
name|bmac_addr
operator|+
name|BIGMAC2_REGISTER_CNT_MAX_SIZE
argument_list|,
name|wb_data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|30
argument_list|)
expr_stmt|;
name|elink_update_pfc_bmac2
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
name|is_lb
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_bmac_enable
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|,
name|uint8_t
name|is_lb
parameter_list|,
name|uint8_t
name|reset_bmac
parameter_list|)
block|{
name|elink_status_t
name|rc
init|=
name|ELINK_STATUS_OK
decl_stmt|;
name|uint8_t
name|port
init|=
name|params
operator|->
name|port
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
comment|/* Reset and unreset the BigMac */
if|if
condition|(
name|reset_bmac
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_2_CLEAR
argument_list|,
operator|(
name|MISC_REGISTERS_RESET_REG_2_RST_BMAC0
operator|<<
name|port
operator|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
operator|*
literal|1
argument_list|)
expr_stmt|;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_2_SET
argument_list|,
operator|(
name|MISC_REGISTERS_RESET_REG_2_RST_BMAC0
operator|<<
name|port
operator|)
argument_list|)
expr_stmt|;
comment|/* Enable access for bmac registers */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_BMAC0_REGS_OUT_EN
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
comment|/* Enable BMAC according to BMAC type*/
if|if
condition|(
name|CHIP_IS_E2
argument_list|(
name|sc
argument_list|)
condition|)
name|rc
operator|=
name|elink_bmac2_enable
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
name|is_lb
argument_list|)
expr_stmt|;
else|else
name|rc
operator|=
name|elink_bmac1_enable
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
name|is_lb
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_XGXS_SERDES0_MODE_SEL
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_XGXS_LANE_SEL_P0
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_EGRESS_EMAC0_PORT
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|params
operator|->
name|feature_config_flags
operator|&
name|ELINK_FEATURE_CONFIG_PFC_ENABLED
operator|)
operator|||
operator|(
name|vars
operator|->
name|flow_ctrl
operator|&
name|ELINK_FLOW_CTRL_TX
operator|)
condition|)
name|val
operator|=
literal|1
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_BMAC0_PAUSE_OUT_EN
operator|+
name|port
operator|*
literal|4
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_EGRESS_EMAC0_OUT_EN
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_EMAC0_IN_EN
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_EMAC0_PAUSE_OUT_EN
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_BMAC0_IN_EN
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_BMAC0_OUT_EN
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|vars
operator|->
name|mac_type
operator|=
name|ELINK_MAC_TYPE_BMAC
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_set_bmac_rx
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|chip_id
parameter_list|,
name|uint8_t
name|port
parameter_list|,
name|uint8_t
name|en
parameter_list|)
block|{
name|uint32_t
name|bmac_addr
init|=
name|port
condition|?
name|NIG_REG_INGRESS_BMAC1_MEM
else|:
name|NIG_REG_INGRESS_BMAC0_MEM
decl_stmt|;
name|uint32_t
name|wb_data
index|[
literal|2
index|]
decl_stmt|;
name|uint32_t
name|nig_bmac_enable
init|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_BMAC0_REGS_OUT_EN
operator|+
name|port
operator|*
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
name|CHIP_IS_E2
argument_list|(
name|sc
argument_list|)
condition|)
name|bmac_addr
operator|+=
name|BIGMAC2_REGISTER_BMAC_CONTROL
expr_stmt|;
else|else
name|bmac_addr
operator|+=
name|BIGMAC_REGISTER_BMAC_CONTROL
expr_stmt|;
comment|/* Only if the bmac is out of reset */
if|if
condition|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_RESET_REG_2
argument_list|)
operator|&
operator|(
name|MISC_REGISTERS_RESET_REG_2_RST_BMAC0
operator|<<
name|port
operator|)
operator|&&
name|nig_bmac_enable
condition|)
block|{
comment|/* Clear Rx Enable bit in BMAC_CONTROL register */
name|REG_RD_DMAE
argument_list|(
name|sc
argument_list|,
name|bmac_addr
argument_list|,
name|wb_data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|en
condition|)
name|wb_data
index|[
literal|0
index|]
operator||=
name|ELINK_BMAC_CONTROL_RX_ENABLE
expr_stmt|;
else|else
name|wb_data
index|[
literal|0
index|]
operator|&=
operator|~
name|ELINK_BMAC_CONTROL_RX_ENABLE
expr_stmt|;
name|REG_WR_DMAE
argument_list|(
name|sc
argument_list|,
name|bmac_addr
argument_list|,
name|wb_data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
operator|*
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_pbf_update
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint32_t
name|flow_ctrl
parameter_list|,
name|uint32_t
name|line_speed
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint8_t
name|port
init|=
name|params
operator|->
name|port
decl_stmt|;
name|uint32_t
name|init_crd
decl_stmt|,
name|crd
decl_stmt|;
name|uint32_t
name|count
init|=
literal|1000
decl_stmt|;
comment|/* Disable port */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_DISABLE_NEW_TASK_PROC_P0
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
comment|/* Wait for init credit */
name|init_crd
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|PBF_REG_P0_INIT_CRD
operator|+
name|port
operator|*
literal|4
argument_list|)
expr_stmt|;
name|crd
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|PBF_REG_P0_CREDIT
operator|+
name|port
operator|*
literal|8
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"init_crd 0x%x  crd 0x%x\n"
argument_list|,
name|init_crd
argument_list|,
name|crd
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|init_crd
operator|!=
name|crd
operator|)
operator|&&
name|count
condition|)
block|{
name|DELAY
argument_list|(
literal|1000
operator|*
literal|5
argument_list|)
expr_stmt|;
name|crd
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|PBF_REG_P0_CREDIT
operator|+
name|port
operator|*
literal|8
argument_list|)
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
name|crd
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|PBF_REG_P0_CREDIT
operator|+
name|port
operator|*
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|init_crd
operator|!=
name|crd
condition|)
block|{
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"BUG! init_crd 0x%x != crd 0x%x\n"
argument_list|,
name|init_crd
argument_list|,
name|crd
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
if|if
condition|(
name|flow_ctrl
operator|&
name|ELINK_FLOW_CTRL_RX
operator|||
name|line_speed
operator|==
name|ELINK_SPEED_10
operator|||
name|line_speed
operator|==
name|ELINK_SPEED_100
operator|||
name|line_speed
operator|==
name|ELINK_SPEED_1000
operator|||
name|line_speed
operator|==
name|ELINK_SPEED_2500
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_P0_PAUSE_ENABLE
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Update threshold */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_P0_ARB_THRSH
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Update init credit */
name|init_crd
operator|=
literal|778
expr_stmt|;
comment|/* (800-18-4) */
block|}
else|else
block|{
name|uint32_t
name|thresh
init|=
operator|(
name|ELINK_ETH_MAX_JUMBO_PACKET_SIZE
operator|+
name|ELINK_ETH_OVREHEAD
operator|)
operator|/
literal|16
decl_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_P0_PAUSE_ENABLE
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Update threshold */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_P0_ARB_THRSH
operator|+
name|port
operator|*
literal|4
argument_list|,
name|thresh
argument_list|)
expr_stmt|;
comment|/* Update init credit */
switch|switch
condition|(
name|line_speed
condition|)
block|{
case|case
name|ELINK_SPEED_10000
case|:
name|init_crd
operator|=
name|thresh
operator|+
literal|553
operator|-
literal|22
expr_stmt|;
break|break;
default|default:
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Invalid line_speed 0x%x\n"
argument_list|,
name|line_speed
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_P0_INIT_CRD
operator|+
name|port
operator|*
literal|4
argument_list|,
name|init_crd
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"PBF updated to speed %d credit %d\n"
argument_list|,
name|line_speed
argument_list|,
name|init_crd
argument_list|)
expr_stmt|;
comment|/* Probe the credit changes */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_INIT_P0
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
operator|*
literal|5
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_INIT_P0
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* Enable port */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|PBF_REG_DISABLE_NEW_TASK_PROC_P0
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/**  * elink_get_emac_base - retrive emac base address  *  * @bp:			driver handle  * @mdc_mdio_access:	access type  * @port:		port id  *  * This function selects the MDC/MDIO access (through emac0 or  * emac1) depend on the mdc_mdio_access, port, port swapped. Each  * phy has a default access mode, which could also be overridden  * by nvram configuration. This parameter, whether this is the  * default phy configuration, or the nvram overrun  * configuration, is passed here as mdc_mdio_access and selects  * the emac_base for the CL45 read/writes operations  */
end_comment

begin_function
specifier|static
name|uint32_t
name|elink_get_emac_base
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|mdc_mdio_access
parameter_list|,
name|uint8_t
name|port
parameter_list|)
block|{
name|uint32_t
name|emac_base
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|mdc_mdio_access
condition|)
block|{
case|case
name|SHARED_HW_CFG_MDC_MDIO_ACCESS1_PHY_TYPE
case|:
break|break;
case|case
name|SHARED_HW_CFG_MDC_MDIO_ACCESS1_EMAC0
case|:
if|if
condition|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_PORT_SWAP
argument_list|)
condition|)
name|emac_base
operator|=
name|GRCBASE_EMAC1
expr_stmt|;
else|else
name|emac_base
operator|=
name|GRCBASE_EMAC0
expr_stmt|;
break|break;
case|case
name|SHARED_HW_CFG_MDC_MDIO_ACCESS1_EMAC1
case|:
if|if
condition|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_PORT_SWAP
argument_list|)
condition|)
name|emac_base
operator|=
name|GRCBASE_EMAC0
expr_stmt|;
else|else
name|emac_base
operator|=
name|GRCBASE_EMAC1
expr_stmt|;
break|break;
case|case
name|SHARED_HW_CFG_MDC_MDIO_ACCESS1_BOTH
case|:
name|emac_base
operator|=
operator|(
name|port
operator|)
condition|?
name|GRCBASE_EMAC1
else|:
name|GRCBASE_EMAC0
expr_stmt|;
break|break;
case|case
name|SHARED_HW_CFG_MDC_MDIO_ACCESS1_SWAPPED
case|:
name|emac_base
operator|=
operator|(
name|port
operator|)
condition|?
name|GRCBASE_EMAC0
else|:
name|GRCBASE_EMAC1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|emac_base
return|;
block|}
end_function

begin_comment
comment|/******************************************************************/
end_comment

begin_comment
comment|/*			CL22 access functions			  */
end_comment

begin_comment
comment|/******************************************************************/
end_comment

begin_function
specifier|static
name|elink_status_t
name|elink_cl22_write
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|uint16_t
name|reg
parameter_list|,
name|uint16_t
name|val
parameter_list|)
block|{
name|uint32_t
name|tmp
decl_stmt|,
name|mode
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|elink_status_t
name|rc
init|=
name|ELINK_STATUS_OK
decl_stmt|;
comment|/* Switch to CL22 */
name|mode
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|phy
operator|->
name|mdio_ctrl
operator|+
name|EMAC_REG_EMAC_MDIO_MODE
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|phy
operator|->
name|mdio_ctrl
operator|+
name|EMAC_REG_EMAC_MDIO_MODE
argument_list|,
name|mode
operator|&
operator|~
name|EMAC_MDIO_MODE_CLAUSE_45
argument_list|)
expr_stmt|;
comment|/* Address */
name|tmp
operator|=
operator|(
operator|(
name|phy
operator|->
name|addr
operator|<<
literal|21
operator|)
operator||
operator|(
name|reg
operator|<<
literal|16
operator|)
operator||
name|val
operator||
name|EMAC_MDIO_COMM_COMMAND_WRITE_22
operator||
name|EMAC_MDIO_COMM_START_BUSY
operator|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|phy
operator|->
name|mdio_ctrl
operator|+
name|EMAC_REG_EMAC_MDIO_COMM
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|50
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|phy
operator|->
name|mdio_ctrl
operator|+
name|EMAC_REG_EMAC_MDIO_COMM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tmp
operator|&
name|EMAC_MDIO_COMM_START_BUSY
operator|)
condition|)
block|{
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|tmp
operator|&
name|EMAC_MDIO_COMM_START_BUSY
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"write phy register failed\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ELINK_STATUS_TIMEOUT
expr_stmt|;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|phy
operator|->
name|mdio_ctrl
operator|+
name|EMAC_REG_EMAC_MDIO_MODE
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_cl22_read
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|uint16_t
name|reg
parameter_list|,
name|uint16_t
modifier|*
name|ret_val
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|,
name|mode
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
name|elink_status_t
name|rc
init|=
name|ELINK_STATUS_OK
decl_stmt|;
comment|/* Switch to CL22 */
name|mode
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|phy
operator|->
name|mdio_ctrl
operator|+
name|EMAC_REG_EMAC_MDIO_MODE
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|phy
operator|->
name|mdio_ctrl
operator|+
name|EMAC_REG_EMAC_MDIO_MODE
argument_list|,
name|mode
operator|&
operator|~
name|EMAC_MDIO_MODE_CLAUSE_45
argument_list|)
expr_stmt|;
comment|/* Address */
name|val
operator|=
operator|(
operator|(
name|phy
operator|->
name|addr
operator|<<
literal|21
operator|)
operator||
operator|(
name|reg
operator|<<
literal|16
operator|)
operator||
name|EMAC_MDIO_COMM_COMMAND_READ_22
operator||
name|EMAC_MDIO_COMM_START_BUSY
operator|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|phy
operator|->
name|mdio_ctrl
operator|+
name|EMAC_REG_EMAC_MDIO_COMM
argument_list|,
name|val
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|50
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|phy
operator|->
name|mdio_ctrl
operator|+
name|EMAC_REG_EMAC_MDIO_COMM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|&
name|EMAC_MDIO_COMM_START_BUSY
operator|)
condition|)
block|{
operator|*
name|ret_val
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|val
operator|&
name|EMAC_MDIO_COMM_DATA
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|val
operator|&
name|EMAC_MDIO_COMM_START_BUSY
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"read phy register failed\n"
argument_list|)
expr_stmt|;
operator|*
name|ret_val
operator|=
literal|0
expr_stmt|;
name|rc
operator|=
name|ELINK_STATUS_TIMEOUT
expr_stmt|;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|phy
operator|->
name|mdio_ctrl
operator|+
name|EMAC_REG_EMAC_MDIO_MODE
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/******************************************************************/
end_comment

begin_comment
comment|/*			CL45 access functions			  */
end_comment

begin_comment
comment|/******************************************************************/
end_comment

begin_function
specifier|static
name|elink_status_t
name|elink_cl45_read
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|uint8_t
name|devad
parameter_list|,
name|uint16_t
name|reg
parameter_list|,
name|uint16_t
modifier|*
name|ret_val
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
name|elink_status_t
name|rc
init|=
name|ELINK_STATUS_OK
decl_stmt|;
name|uint32_t
name|chip_id
decl_stmt|;
if|if
condition|(
name|phy
operator|->
name|flags
operator|&
name|ELINK_FLAGS_MDC_MDIO_WA_G
condition|)
block|{
name|chip_id
operator|=
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_CHIP_NUM
argument_list|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_CHIP_REV
argument_list|)
operator|&
literal|0xf
operator|)
operator|<<
literal|12
operator|)
expr_stmt|;
name|elink_set_mdio_clk
argument_list|(
name|sc
argument_list|,
name|chip_id
argument_list|,
name|phy
operator|->
name|mdio_ctrl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|phy
operator|->
name|flags
operator|&
name|ELINK_FLAGS_MDC_MDIO_WA_B0
condition|)
name|elink_bits_en
argument_list|(
name|sc
argument_list|,
name|phy
operator|->
name|mdio_ctrl
operator|+
name|EMAC_REG_EMAC_MDIO_STATUS
argument_list|,
name|EMAC_MDIO_STATUS_10MB
argument_list|)
expr_stmt|;
comment|/* Address */
name|val
operator|=
operator|(
operator|(
name|phy
operator|->
name|addr
operator|<<
literal|21
operator|)
operator||
operator|(
name|devad
operator|<<
literal|16
operator|)
operator||
name|reg
operator||
name|EMAC_MDIO_COMM_COMMAND_ADDRESS
operator||
name|EMAC_MDIO_COMM_START_BUSY
operator|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|phy
operator|->
name|mdio_ctrl
operator|+
name|EMAC_REG_EMAC_MDIO_COMM
argument_list|,
name|val
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|50
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|phy
operator|->
name|mdio_ctrl
operator|+
name|EMAC_REG_EMAC_MDIO_COMM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|&
name|EMAC_MDIO_COMM_START_BUSY
operator|)
condition|)
block|{
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|val
operator|&
name|EMAC_MDIO_COMM_START_BUSY
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"read phy register failed\n"
argument_list|)
expr_stmt|;
name|elink_cb_event_log
argument_list|(
name|sc
argument_list|,
name|ELINK_LOG_ID_MDIO_ACCESS_TIMEOUT
argument_list|)
expr_stmt|;
comment|// "MDC/MDIO access timeout\n"
operator|*
name|ret_val
operator|=
literal|0
expr_stmt|;
name|rc
operator|=
name|ELINK_STATUS_TIMEOUT
expr_stmt|;
block|}
else|else
block|{
comment|/* Data */
name|val
operator|=
operator|(
operator|(
name|phy
operator|->
name|addr
operator|<<
literal|21
operator|)
operator||
operator|(
name|devad
operator|<<
literal|16
operator|)
operator||
name|EMAC_MDIO_COMM_COMMAND_READ_45
operator||
name|EMAC_MDIO_COMM_START_BUSY
operator|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|phy
operator|->
name|mdio_ctrl
operator|+
name|EMAC_REG_EMAC_MDIO_COMM
argument_list|,
name|val
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|50
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|phy
operator|->
name|mdio_ctrl
operator|+
name|EMAC_REG_EMAC_MDIO_COMM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|&
name|EMAC_MDIO_COMM_START_BUSY
operator|)
condition|)
block|{
operator|*
name|ret_val
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|val
operator|&
name|EMAC_MDIO_COMM_DATA
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|val
operator|&
name|EMAC_MDIO_COMM_START_BUSY
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"read phy register failed\n"
argument_list|)
expr_stmt|;
name|elink_cb_event_log
argument_list|(
name|sc
argument_list|,
name|ELINK_LOG_ID_MDIO_ACCESS_TIMEOUT
argument_list|)
expr_stmt|;
comment|// "MDC/MDIO access timeout\n"
operator|*
name|ret_val
operator|=
literal|0
expr_stmt|;
name|rc
operator|=
name|ELINK_STATUS_TIMEOUT
expr_stmt|;
block|}
block|}
comment|/* Work around for E3 A0 */
if|if
condition|(
name|phy
operator|->
name|flags
operator|&
name|ELINK_FLAGS_MDC_MDIO_WA
condition|)
block|{
name|phy
operator|->
name|flags
operator|^=
name|ELINK_FLAGS_DUMMY_READ
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|flags
operator|&
name|ELINK_FLAGS_DUMMY_READ
condition|)
block|{
name|uint16_t
name|temp_val
decl_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|devad
argument_list|,
literal|0xf
argument_list|,
operator|&
name|temp_val
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|phy
operator|->
name|flags
operator|&
name|ELINK_FLAGS_MDC_MDIO_WA_B0
condition|)
name|elink_bits_dis
argument_list|(
name|sc
argument_list|,
name|phy
operator|->
name|mdio_ctrl
operator|+
name|EMAC_REG_EMAC_MDIO_STATUS
argument_list|,
name|EMAC_MDIO_STATUS_10MB
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_cl45_write
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|uint8_t
name|devad
parameter_list|,
name|uint16_t
name|reg
parameter_list|,
name|uint16_t
name|val
parameter_list|)
block|{
name|uint32_t
name|tmp
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|elink_status_t
name|rc
init|=
name|ELINK_STATUS_OK
decl_stmt|;
name|uint32_t
name|chip_id
decl_stmt|;
if|if
condition|(
name|phy
operator|->
name|flags
operator|&
name|ELINK_FLAGS_MDC_MDIO_WA_G
condition|)
block|{
name|chip_id
operator|=
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_CHIP_NUM
argument_list|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_CHIP_REV
argument_list|)
operator|&
literal|0xf
operator|)
operator|<<
literal|12
operator|)
expr_stmt|;
name|elink_set_mdio_clk
argument_list|(
name|sc
argument_list|,
name|chip_id
argument_list|,
name|phy
operator|->
name|mdio_ctrl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|phy
operator|->
name|flags
operator|&
name|ELINK_FLAGS_MDC_MDIO_WA_B0
condition|)
name|elink_bits_en
argument_list|(
name|sc
argument_list|,
name|phy
operator|->
name|mdio_ctrl
operator|+
name|EMAC_REG_EMAC_MDIO_STATUS
argument_list|,
name|EMAC_MDIO_STATUS_10MB
argument_list|)
expr_stmt|;
comment|/* Address */
name|tmp
operator|=
operator|(
operator|(
name|phy
operator|->
name|addr
operator|<<
literal|21
operator|)
operator||
operator|(
name|devad
operator|<<
literal|16
operator|)
operator||
name|reg
operator||
name|EMAC_MDIO_COMM_COMMAND_ADDRESS
operator||
name|EMAC_MDIO_COMM_START_BUSY
operator|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|phy
operator|->
name|mdio_ctrl
operator|+
name|EMAC_REG_EMAC_MDIO_COMM
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|50
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|phy
operator|->
name|mdio_ctrl
operator|+
name|EMAC_REG_EMAC_MDIO_COMM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tmp
operator|&
name|EMAC_MDIO_COMM_START_BUSY
operator|)
condition|)
block|{
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|tmp
operator|&
name|EMAC_MDIO_COMM_START_BUSY
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"write phy register failed\n"
argument_list|)
expr_stmt|;
name|elink_cb_event_log
argument_list|(
name|sc
argument_list|,
name|ELINK_LOG_ID_MDIO_ACCESS_TIMEOUT
argument_list|)
expr_stmt|;
comment|// "MDC/MDIO access timeout\n"
name|rc
operator|=
name|ELINK_STATUS_TIMEOUT
expr_stmt|;
block|}
else|else
block|{
comment|/* Data */
name|tmp
operator|=
operator|(
operator|(
name|phy
operator|->
name|addr
operator|<<
literal|21
operator|)
operator||
operator|(
name|devad
operator|<<
literal|16
operator|)
operator||
name|val
operator||
name|EMAC_MDIO_COMM_COMMAND_WRITE_45
operator||
name|EMAC_MDIO_COMM_START_BUSY
operator|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|phy
operator|->
name|mdio_ctrl
operator|+
name|EMAC_REG_EMAC_MDIO_COMM
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|50
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|phy
operator|->
name|mdio_ctrl
operator|+
name|EMAC_REG_EMAC_MDIO_COMM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tmp
operator|&
name|EMAC_MDIO_COMM_START_BUSY
operator|)
condition|)
block|{
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|tmp
operator|&
name|EMAC_MDIO_COMM_START_BUSY
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"write phy register failed\n"
argument_list|)
expr_stmt|;
name|elink_cb_event_log
argument_list|(
name|sc
argument_list|,
name|ELINK_LOG_ID_MDIO_ACCESS_TIMEOUT
argument_list|)
expr_stmt|;
comment|// "MDC/MDIO access timeout\n"
name|rc
operator|=
name|ELINK_STATUS_TIMEOUT
expr_stmt|;
block|}
block|}
comment|/* Work around for E3 A0 */
if|if
condition|(
name|phy
operator|->
name|flags
operator|&
name|ELINK_FLAGS_MDC_MDIO_WA
condition|)
block|{
name|phy
operator|->
name|flags
operator|^=
name|ELINK_FLAGS_DUMMY_READ
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|flags
operator|&
name|ELINK_FLAGS_DUMMY_READ
condition|)
block|{
name|uint16_t
name|temp_val
decl_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|devad
argument_list|,
literal|0xf
argument_list|,
operator|&
name|temp_val
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|phy
operator|->
name|flags
operator|&
name|ELINK_FLAGS_MDC_MDIO_WA_B0
condition|)
name|elink_bits_dis
argument_list|(
name|sc
argument_list|,
name|phy
operator|->
name|mdio_ctrl
operator|+
name|EMAC_REG_EMAC_MDIO_STATUS
argument_list|,
name|EMAC_MDIO_STATUS_10MB
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/******************************************************************/
end_comment

begin_comment
comment|/*			EEE section				   */
end_comment

begin_comment
comment|/******************************************************************/
end_comment

begin_function
specifier|static
name|uint8_t
name|elink_eee_has_cap
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
if|if
condition|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|shmem2_base
argument_list|)
operator|<=
name|offsetof
argument_list|(
expr|struct
name|shmem2_region
argument_list|,
name|eee_status
index|[
name|params
operator|->
name|port
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_eee_nvram_to_time
parameter_list|(
name|uint32_t
name|nvram_mode
parameter_list|,
name|uint32_t
modifier|*
name|idle_timer
parameter_list|)
block|{
switch|switch
condition|(
name|nvram_mode
condition|)
block|{
case|case
name|PORT_FEAT_CFG_EEE_POWER_MODE_BALANCED
case|:
operator|*
name|idle_timer
operator|=
name|ELINK_EEE_MODE_NVRAM_BALANCED_TIME
expr_stmt|;
break|break;
case|case
name|PORT_FEAT_CFG_EEE_POWER_MODE_AGGRESSIVE
case|:
operator|*
name|idle_timer
operator|=
name|ELINK_EEE_MODE_NVRAM_AGGRESSIVE_TIME
expr_stmt|;
break|break;
case|case
name|PORT_FEAT_CFG_EEE_POWER_MODE_LOW_LATENCY
case|:
operator|*
name|idle_timer
operator|=
name|ELINK_EEE_MODE_NVRAM_LATENCY_TIME
expr_stmt|;
break|break;
default|default:
operator|*
name|idle_timer
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_eee_time_to_nvram
parameter_list|(
name|uint32_t
name|idle_timer
parameter_list|,
name|uint32_t
modifier|*
name|nvram_mode
parameter_list|)
block|{
switch|switch
condition|(
name|idle_timer
condition|)
block|{
case|case
name|ELINK_EEE_MODE_NVRAM_BALANCED_TIME
case|:
operator|*
name|nvram_mode
operator|=
name|PORT_FEAT_CFG_EEE_POWER_MODE_BALANCED
expr_stmt|;
break|break;
case|case
name|ELINK_EEE_MODE_NVRAM_AGGRESSIVE_TIME
case|:
operator|*
name|nvram_mode
operator|=
name|PORT_FEAT_CFG_EEE_POWER_MODE_AGGRESSIVE
expr_stmt|;
break|break;
case|case
name|ELINK_EEE_MODE_NVRAM_LATENCY_TIME
case|:
operator|*
name|nvram_mode
operator|=
name|PORT_FEAT_CFG_EEE_POWER_MODE_LOW_LATENCY
expr_stmt|;
break|break;
default|default:
operator|*
name|nvram_mode
operator|=
name|PORT_FEAT_CFG_EEE_POWER_MODE_DISABLED
expr_stmt|;
break|break;
block|}
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|elink_eee_calc_timer
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|uint32_t
name|eee_mode
decl_stmt|,
name|eee_idle
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
if|if
condition|(
name|params
operator|->
name|eee_mode
operator|&
name|ELINK_EEE_MODE_OVERRIDE_NVRAM
condition|)
block|{
if|if
condition|(
name|params
operator|->
name|eee_mode
operator|&
name|ELINK_EEE_MODE_OUTPUT_TIME
condition|)
block|{
comment|/* time value in eee_mode --> used directly*/
name|eee_idle
operator|=
name|params
operator|->
name|eee_mode
operator|&
name|ELINK_EEE_MODE_TIMER_MASK
expr_stmt|;
block|}
else|else
block|{
comment|/* hsi value in eee_mode --> time */
if|if
condition|(
name|elink_eee_nvram_to_time
argument_list|(
name|params
operator|->
name|eee_mode
operator|&
name|ELINK_EEE_MODE_NVRAM_MASK
argument_list|,
operator|&
name|eee_idle
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
comment|/* hsi values in nvram --> time*/
name|eee_mode
operator|=
operator|(
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_feature_config
index|[
name|params
operator|->
name|port
index|]
operator|.
name|eee_power_mode
argument_list|)
argument_list|)
operator|&
name|PORT_FEAT_CFG_EEE_POWER_MODE_MASK
operator|)
operator|>>
name|PORT_FEAT_CFG_EEE_POWER_MODE_SHIFT
operator|)
expr_stmt|;
if|if
condition|(
name|elink_eee_nvram_to_time
argument_list|(
name|eee_mode
argument_list|,
operator|&
name|eee_idle
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
name|eee_idle
return|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_eee_set_timers
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|uint32_t
name|eee_idle
init|=
literal|0
decl_stmt|,
name|eee_mode
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|eee_idle
operator|=
name|elink_eee_calc_timer
argument_list|(
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|eee_idle
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_CPMU_LP_IDLE_THR_P0
operator|+
operator|(
name|params
operator|->
name|port
operator|<<
literal|2
operator|)
argument_list|,
name|eee_idle
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|params
operator|->
name|eee_mode
operator|&
name|ELINK_EEE_MODE_ENABLE_LPI
operator|)
operator|&&
operator|(
name|params
operator|->
name|eee_mode
operator|&
name|ELINK_EEE_MODE_OVERRIDE_NVRAM
operator|)
operator|&&
operator|(
name|params
operator|->
name|eee_mode
operator|&
name|ELINK_EEE_MODE_OUTPUT_TIME
operator|)
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Error: Tx LPI is enabled with timer 0\n"
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
name|vars
operator|->
name|eee_status
operator|&=
operator|~
operator|(
name|SHMEM_EEE_TIMER_MASK
operator||
name|SHMEM_EEE_TIME_OUTPUT_BIT
operator|)
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|eee_mode
operator|&
name|ELINK_EEE_MODE_OUTPUT_TIME
condition|)
block|{
comment|/* eee_idle in 1u --> eee_status in 16u */
name|eee_idle
operator|>>=
literal|4
expr_stmt|;
name|vars
operator|->
name|eee_status
operator||=
operator|(
name|eee_idle
operator|&
name|SHMEM_EEE_TIMER_MASK
operator|)
operator||
name|SHMEM_EEE_TIME_OUTPUT_BIT
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|elink_eee_time_to_nvram
argument_list|(
name|eee_idle
argument_list|,
operator|&
name|eee_mode
argument_list|)
condition|)
return|return
name|ELINK_STATUS_ERROR
return|;
name|vars
operator|->
name|eee_status
operator||=
name|eee_mode
expr_stmt|;
block|}
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_eee_initial_config
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|,
name|uint8_t
name|mode
parameter_list|)
block|{
name|vars
operator|->
name|eee_status
operator||=
operator|(
operator|(
name|uint32_t
operator|)
name|mode
operator|)
operator|<<
name|SHMEM_EEE_SUPPORTED_SHIFT
expr_stmt|;
comment|/* Propagate params' bits --> vars (for migration exposure) */
if|if
condition|(
name|params
operator|->
name|eee_mode
operator|&
name|ELINK_EEE_MODE_ENABLE_LPI
condition|)
name|vars
operator|->
name|eee_status
operator||=
name|SHMEM_EEE_LPI_REQUESTED_BIT
expr_stmt|;
else|else
name|vars
operator|->
name|eee_status
operator|&=
operator|~
name|SHMEM_EEE_LPI_REQUESTED_BIT
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|eee_mode
operator|&
name|ELINK_EEE_MODE_ADV_LPI
condition|)
name|vars
operator|->
name|eee_status
operator||=
name|SHMEM_EEE_REQUESTED_BIT
expr_stmt|;
else|else
name|vars
operator|->
name|eee_status
operator|&=
operator|~
name|SHMEM_EEE_REQUESTED_BIT
expr_stmt|;
return|return
name|elink_eee_set_timers
argument_list|(
name|params
argument_list|,
name|vars
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_eee_disable
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
comment|/* Make Certain LPI is disabled */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_CPMU_LP_FW_ENABLE_P0
operator|+
operator|(
name|params
operator|->
name|port
operator|<<
literal|2
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_EEE_ADV
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|vars
operator|->
name|eee_status
operator|&=
operator|~
name|SHMEM_EEE_ADV_STATUS_MASK
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_eee_advertise
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|,
name|uint8_t
name|modes
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint16_t
name|val
init|=
literal|0
decl_stmt|;
comment|/* Mask events preventing LPI generation */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_CPMU_LP_MASK_EXT_P0
operator|+
operator|(
name|params
operator|->
name|port
operator|<<
literal|2
operator|)
argument_list|,
literal|0xfc20
argument_list|)
expr_stmt|;
if|if
condition|(
name|modes
operator|&
name|SHMEM_EEE_10G_ADV
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Advertise 10GBase-T EEE\n"
argument_list|)
expr_stmt|;
name|val
operator||=
literal|0x8
expr_stmt|;
block|}
if|if
condition|(
name|modes
operator|&
name|SHMEM_EEE_1G_ADV
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Advertise 1GBase-T EEE\n"
argument_list|)
expr_stmt|;
name|val
operator||=
literal|0x4
expr_stmt|;
block|}
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_EEE_ADV
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|vars
operator|->
name|eee_status
operator|&=
operator|~
name|SHMEM_EEE_ADV_STATUS_MASK
expr_stmt|;
name|vars
operator|->
name|eee_status
operator||=
operator|(
name|modes
operator|<<
name|SHMEM_EEE_ADV_STATUS_SHIFT
operator|)
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_update_mng_eee
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint32_t
name|eee_status
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
if|if
condition|(
name|elink_eee_has_cap
argument_list|(
name|params
argument_list|)
condition|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|shmem2_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem2_region
argument_list|,
name|eee_status
index|[
name|params
operator|->
name|port
index|]
argument_list|)
argument_list|,
name|eee_status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_eee_an_resolve
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint16_t
name|adv
init|=
literal|0
decl_stmt|,
name|lp
init|=
literal|0
decl_stmt|;
name|uint32_t
name|lp_adv
init|=
literal|0
decl_stmt|;
name|uint8_t
name|neg
init|=
literal|0
decl_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_EEE_ADV
argument_list|,
operator|&
name|adv
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_LP_EEE_ADV
argument_list|,
operator|&
name|lp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|&
literal|0x2
condition|)
block|{
name|lp_adv
operator||=
name|SHMEM_EEE_100M_ADV
expr_stmt|;
if|if
condition|(
name|adv
operator|&
literal|0x2
condition|)
block|{
if|if
condition|(
name|vars
operator|->
name|line_speed
operator|==
name|ELINK_SPEED_100
condition|)
name|neg
operator|=
literal|1
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"EEE negotiated - 100M\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lp
operator|&
literal|0x14
condition|)
block|{
name|lp_adv
operator||=
name|SHMEM_EEE_1G_ADV
expr_stmt|;
if|if
condition|(
name|adv
operator|&
literal|0x14
condition|)
block|{
if|if
condition|(
name|vars
operator|->
name|line_speed
operator|==
name|ELINK_SPEED_1000
condition|)
name|neg
operator|=
literal|1
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"EEE negotiated - 1G\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lp
operator|&
literal|0x68
condition|)
block|{
name|lp_adv
operator||=
name|SHMEM_EEE_10G_ADV
expr_stmt|;
if|if
condition|(
name|adv
operator|&
literal|0x68
condition|)
block|{
if|if
condition|(
name|vars
operator|->
name|line_speed
operator|==
name|ELINK_SPEED_10000
condition|)
name|neg
operator|=
literal|1
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"EEE negotiated - 10G\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|vars
operator|->
name|eee_status
operator|&=
operator|~
name|SHMEM_EEE_LP_ADV_STATUS_MASK
expr_stmt|;
name|vars
operator|->
name|eee_status
operator||=
operator|(
name|lp_adv
operator|<<
name|SHMEM_EEE_LP_ADV_STATUS_SHIFT
operator|)
expr_stmt|;
if|if
condition|(
name|neg
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"EEE is active\n"
argument_list|)
expr_stmt|;
name|vars
operator|->
name|eee_status
operator||=
name|SHMEM_EEE_ACTIVE_BIT
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************/
end_comment

begin_comment
comment|/*			BSC access functions from E3	          */
end_comment

begin_comment
comment|/******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|elink_bsc_module_sel
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
name|uint32_t
name|board_cfg
decl_stmt|,
name|sfp_ctrl
decl_stmt|;
name|uint32_t
name|i2c_pins
index|[
name|I2C_SWITCH_WIDTH
index|]
decl_stmt|,
name|i2c_val
index|[
name|I2C_SWITCH_WIDTH
index|]
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint8_t
name|port
init|=
name|params
operator|->
name|port
decl_stmt|;
comment|/* Read I2C output PINs */
name|board_cfg
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|shared_hw_config
operator|.
name|board
argument_list|)
argument_list|)
expr_stmt|;
name|i2c_pins
index|[
name|I2C_BSC0
index|]
operator|=
name|board_cfg
operator|&
name|SHARED_HW_CFG_E3_I2C_MUX0_MASK
expr_stmt|;
name|i2c_pins
index|[
name|I2C_BSC1
index|]
operator|=
operator|(
name|board_cfg
operator|&
name|SHARED_HW_CFG_E3_I2C_MUX1_MASK
operator|)
operator|>>
name|SHARED_HW_CFG_E3_I2C_MUX1_SHIFT
expr_stmt|;
comment|/* Read I2C output value */
name|sfp_ctrl
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|port
index|]
operator|.
name|e3_cmn_pin_cfg
argument_list|)
argument_list|)
expr_stmt|;
name|i2c_val
index|[
name|I2C_BSC0
index|]
operator|=
operator|(
name|sfp_ctrl
operator|&
name|PORT_HW_CFG_E3_I2C_MUX0_MASK
operator|)
operator|>
literal|0
expr_stmt|;
name|i2c_val
index|[
name|I2C_BSC1
index|]
operator|=
operator|(
name|sfp_ctrl
operator|&
name|PORT_HW_CFG_E3_I2C_MUX1_MASK
operator|)
operator|>
literal|0
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Setting BSC switch\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|I2C_SWITCH_WIDTH
condition|;
name|idx
operator|++
control|)
name|elink_set_cfg_pin
argument_list|(
name|sc
argument_list|,
name|i2c_pins
index|[
name|idx
index|]
argument_list|,
name|i2c_val
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_bsc_read
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|sl_devid
parameter_list|,
name|uint16_t
name|sl_addr
parameter_list|,
name|uint8_t
name|lc_addr
parameter_list|,
name|uint8_t
name|xfer_cnt
parameter_list|,
name|uint32_t
modifier|*
name|data_array
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|,
name|i
decl_stmt|;
name|elink_status_t
name|rc
init|=
name|ELINK_STATUS_OK
decl_stmt|;
if|if
condition|(
name|xfer_cnt
operator|>
literal|16
condition|)
block|{
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"invalid xfer_cnt %d. Max is 16 bytes\n"
argument_list|,
name|xfer_cnt
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
name|xfer_cnt
operator|=
literal|16
operator|-
name|lc_addr
expr_stmt|;
comment|/* Enable the engine */
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_IMC_COMMAND
argument_list|)
expr_stmt|;
name|val
operator||=
name|MCPR_IMC_COMMAND_ENABLE
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_IMC_COMMAND
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Program slave device ID */
name|val
operator|=
operator|(
name|sl_devid
operator|<<
literal|16
operator|)
operator||
name|sl_addr
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_IMC_SLAVE_CONTROL
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Start xfer with 0 byte to update the address pointer ???*/
name|val
operator|=
operator|(
name|MCPR_IMC_COMMAND_ENABLE
operator|)
operator||
operator|(
name|MCPR_IMC_COMMAND_WRITE_OP
operator|<<
name|MCPR_IMC_COMMAND_OPERATION_BITSHIFT
operator|)
operator||
operator|(
name|lc_addr
operator|<<
name|MCPR_IMC_COMMAND_TRANSFER_ADDRESS_BITSHIFT
operator|)
operator||
operator|(
literal|0
operator|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_IMC_COMMAND
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Poll for completion */
name|i
operator|=
literal|0
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_IMC_COMMAND
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|val
operator|>>
name|MCPR_IMC_COMMAND_IMC_STATUS_BITSHIFT
operator|)
operator|&
literal|0x3
operator|)
operator|!=
literal|1
condition|)
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_IMC_COMMAND
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|++
operator|>
literal|1000
condition|)
block|{
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"wr 0 byte timed out after %d try\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ELINK_STATUS_TIMEOUT
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|rc
operator|==
name|ELINK_STATUS_TIMEOUT
condition|)
return|return
name|rc
return|;
comment|/* Start xfer with read op */
name|val
operator|=
operator|(
name|MCPR_IMC_COMMAND_ENABLE
operator|)
operator||
operator|(
name|MCPR_IMC_COMMAND_READ_OP
operator|<<
name|MCPR_IMC_COMMAND_OPERATION_BITSHIFT
operator|)
operator||
operator|(
name|lc_addr
operator|<<
name|MCPR_IMC_COMMAND_TRANSFER_ADDRESS_BITSHIFT
operator|)
operator||
operator|(
name|xfer_cnt
operator|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_IMC_COMMAND
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Poll for completion */
name|i
operator|=
literal|0
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_IMC_COMMAND
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|val
operator|>>
name|MCPR_IMC_COMMAND_IMC_STATUS_BITSHIFT
operator|)
operator|&
literal|0x3
operator|)
operator|!=
literal|1
condition|)
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MCP_REG_MCPR_IMC_COMMAND
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|++
operator|>
literal|1000
condition|)
block|{
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"rd op timed out after %d try\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ELINK_STATUS_TIMEOUT
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|rc
operator|==
name|ELINK_STATUS_TIMEOUT
condition|)
return|return
name|rc
return|;
for|for
control|(
name|i
operator|=
operator|(
name|lc_addr
operator|>>
literal|2
operator|)
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|data_array
index|[
name|i
index|]
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
operator|(
name|MCP_REG_MCPR_IMC_DATAREG0
operator|+
name|i
operator|*
literal|4
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__BIG_ENDIAN
name|data_array
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|data_array
index|[
name|i
index|]
operator|&
literal|0x000000ff
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|data_array
index|[
name|i
index|]
operator|&
literal|0x0000ff00
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|data_array
index|[
name|i
index|]
operator|&
literal|0x00ff0000
operator|)
operator|>>
literal|8
operator|)
operator||
operator|(
operator|(
name|data_array
index|[
name|i
index|]
operator|&
literal|0xff000000
operator|)
operator|>>
literal|24
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_cl45_read_or_write
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|uint8_t
name|devad
parameter_list|,
name|uint16_t
name|reg
parameter_list|,
name|uint16_t
name|or_val
parameter_list|)
block|{
name|uint16_t
name|val
decl_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|devad
argument_list|,
name|reg
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|devad
argument_list|,
name|reg
argument_list|,
name|val
operator||
name|or_val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_cl45_read_and_write
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|uint8_t
name|devad
parameter_list|,
name|uint16_t
name|reg
parameter_list|,
name|uint16_t
name|and_val
parameter_list|)
block|{
name|uint16_t
name|val
decl_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|devad
argument_list|,
name|reg
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|devad
argument_list|,
name|reg
argument_list|,
name|val
operator|&
name|and_val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|elink_status_t
name|elink_phy_read
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint8_t
name|phy_addr
parameter_list|,
name|uint8_t
name|devad
parameter_list|,
name|uint16_t
name|reg
parameter_list|,
name|uint16_t
modifier|*
name|ret_val
parameter_list|)
block|{
name|uint8_t
name|phy_index
decl_stmt|;
comment|/* Probe for the phy according to the given phy_addr, and execute 	 * the read request on it 	 */
for|for
control|(
name|phy_index
operator|=
literal|0
init|;
name|phy_index
operator|<
name|params
operator|->
name|num_phys
condition|;
name|phy_index
operator|++
control|)
block|{
if|if
condition|(
name|params
operator|->
name|phy
index|[
name|phy_index
index|]
operator|.
name|addr
operator|==
name|phy_addr
condition|)
block|{
return|return
name|elink_cl45_read
argument_list|(
name|params
operator|->
name|sc
argument_list|,
operator|&
name|params
operator|->
name|phy
index|[
name|phy_index
index|]
argument_list|,
name|devad
argument_list|,
name|reg
argument_list|,
name|ret_val
argument_list|)
return|;
block|}
block|}
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
end_function

begin_function
name|elink_status_t
name|elink_phy_write
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint8_t
name|phy_addr
parameter_list|,
name|uint8_t
name|devad
parameter_list|,
name|uint16_t
name|reg
parameter_list|,
name|uint16_t
name|val
parameter_list|)
block|{
name|uint8_t
name|phy_index
decl_stmt|;
comment|/* Probe for the phy according to the given phy_addr, and execute 	 * the write request on it 	 */
for|for
control|(
name|phy_index
operator|=
literal|0
init|;
name|phy_index
operator|<
name|params
operator|->
name|num_phys
condition|;
name|phy_index
operator|++
control|)
block|{
if|if
condition|(
name|params
operator|->
name|phy
index|[
name|phy_index
index|]
operator|.
name|addr
operator|==
name|phy_addr
condition|)
block|{
return|return
name|elink_cl45_write
argument_list|(
name|params
operator|->
name|sc
argument_list|,
operator|&
name|params
operator|->
name|phy
index|[
name|phy_index
index|]
argument_list|,
name|devad
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
return|;
block|}
block|}
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|elink_get_warpcore_lane
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|uint8_t
name|lane
init|=
literal|0
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint32_t
name|path_swap
decl_stmt|,
name|path_swap_ovr
decl_stmt|;
name|uint8_t
name|path
decl_stmt|,
name|port
decl_stmt|;
name|path
operator|=
name|SC_PATH
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|port
operator|=
name|params
operator|->
name|port
expr_stmt|;
if|if
condition|(
name|elink_is_4_port_mode
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|uint32_t
name|port_swap
decl_stmt|,
name|port_swap_ovr
decl_stmt|;
comment|/* Figure out path swap value */
name|path_swap_ovr
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_FOUR_PORT_PATH_SWAP_OVWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|path_swap_ovr
operator|&
literal|0x1
condition|)
name|path_swap
operator|=
operator|(
name|path_swap_ovr
operator|&
literal|0x2
operator|)
expr_stmt|;
else|else
name|path_swap
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_FOUR_PORT_PATH_SWAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|path_swap
condition|)
name|path
operator|=
name|path
operator|^
literal|1
expr_stmt|;
comment|/* Figure out port swap value */
name|port_swap_ovr
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_FOUR_PORT_PORT_SWAP_OVWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|port_swap_ovr
operator|&
literal|0x1
condition|)
name|port_swap
operator|=
operator|(
name|port_swap_ovr
operator|&
literal|0x2
operator|)
expr_stmt|;
else|else
name|port_swap
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_FOUR_PORT_PORT_SWAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|port_swap
condition|)
name|port
operator|=
name|port
operator|^
literal|1
expr_stmt|;
name|lane
operator|=
operator|(
name|port
operator|<<
literal|1
operator|)
operator|+
name|path
expr_stmt|;
block|}
else|else
block|{
comment|/* Two port mode - no port swap */
comment|/* Figure out path swap value */
name|path_swap_ovr
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_TWO_PORT_PATH_SWAP_OVWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|path_swap_ovr
operator|&
literal|0x1
condition|)
block|{
name|path_swap
operator|=
operator|(
name|path_swap_ovr
operator|&
literal|0x2
operator|)
expr_stmt|;
block|}
else|else
block|{
name|path_swap
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_TWO_PORT_PATH_SWAP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|path_swap
condition|)
name|path
operator|=
name|path
operator|^
literal|1
expr_stmt|;
name|lane
operator|=
name|path
operator|<<
literal|1
expr_stmt|;
block|}
return|return
name|lane
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_set_aer_mmd
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|)
block|{
name|uint32_t
name|ser_lane
decl_stmt|;
name|uint16_t
name|offset
decl_stmt|,
name|aer_val
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|ser_lane
operator|=
operator|(
operator|(
name|params
operator|->
name|lane_config
operator|&
name|PORT_HW_CFG_LANE_SWAP_CFG_MASTER_MASK
operator|)
operator|>>
name|PORT_HW_CFG_LANE_SWAP_CFG_MASTER_SHIFT
operator|)
expr_stmt|;
name|offset
operator|=
operator|(
name|phy
operator|->
name|type
operator|==
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT
operator|)
condition|?
operator|(
name|phy
operator|->
name|addr
operator|+
name|ser_lane
operator|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|USES_WARPCORE
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|aer_val
operator|=
name|elink_get_warpcore_lane
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
expr_stmt|;
comment|/* In Dual-lane mode, two lanes are joined together, 		 * so in order to configure them, the AER broadcast method is 		 * used here. 		 * 0x200 is the broadcast address for lanes 0,1 		 * 0x201 is the broadcast address for lanes 2,3 		 */
if|if
condition|(
name|phy
operator|->
name|flags
operator|&
name|ELINK_FLAGS_WC_DUAL_MODE
condition|)
name|aer_val
operator|=
operator|(
name|aer_val
operator|>>
literal|1
operator|)
operator||
literal|0x200
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CHIP_IS_E2
argument_list|(
name|sc
argument_list|)
condition|)
name|aer_val
operator|=
literal|0x3800
operator|+
name|offset
operator|-
literal|1
expr_stmt|;
else|else
name|aer_val
operator|=
literal|0x3800
operator|+
name|offset
expr_stmt|;
name|CL22_WR_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_AER_BLOCK
argument_list|,
name|MDIO_AER_BLOCK_AER_REG
argument_list|,
name|aer_val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************/
end_comment

begin_comment
comment|/*			Internal phy section			  */
end_comment

begin_comment
comment|/******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|elink_set_serdes_access
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|port
parameter_list|)
block|{
name|uint32_t
name|emac_base
init|=
operator|(
name|port
operator|)
condition|?
name|GRCBASE_EMAC1
else|:
name|GRCBASE_EMAC0
decl_stmt|;
comment|/* Set Clause 22 */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_SERDES0_CTRL_MD_ST
operator|+
name|port
operator|*
literal|0x10
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|emac_base
operator|+
name|EMAC_REG_EMAC_MDIO_COMM
argument_list|,
literal|0x245f8000
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|emac_base
operator|+
name|EMAC_REG_EMAC_MDIO_COMM
argument_list|,
literal|0x245d000f
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
comment|/* Set Clause 45 */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_SERDES0_CTRL_MD_ST
operator|+
name|port
operator|*
literal|0x10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_serdes_deassert
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|port
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"elink_serdes_deassert\n"
argument_list|)
expr_stmt|;
name|val
operator|=
name|ELINK_SERDES_RESET_BITS
operator|<<
operator|(
name|port
operator|*
literal|16
operator|)
expr_stmt|;
comment|/* Reset and unreset the SerDes/XGXS */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_3_CLEAR
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_3_SET
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|elink_set_serdes_access
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_SERDES0_CTRL_MD_DEVAD
operator|+
name|port
operator|*
literal|0x10
argument_list|,
name|ELINK_DEFAULT_PHY_DEV_ADDR
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_xgxs_specific_func
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint32_t
name|action
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|ELINK_PHY_INIT
case|:
comment|/* Set correct devad */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_XGXS0_CTRL_MD_ST
operator|+
name|params
operator|->
name|port
operator|*
literal|0x18
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_XGXS0_CTRL_MD_DEVAD
operator|+
name|params
operator|->
name|port
operator|*
literal|0x18
argument_list|,
name|phy
operator|->
name|def_md_devad
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|elink_xgxs_deassert
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint8_t
name|port
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"elink_xgxs_deassert\n"
argument_list|)
expr_stmt|;
name|port
operator|=
name|params
operator|->
name|port
expr_stmt|;
name|val
operator|=
name|ELINK_XGXS_RESET_BITS
operator|<<
operator|(
name|port
operator|*
literal|16
operator|)
expr_stmt|;
comment|/* Reset and unreset the SerDes/XGXS */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_3_CLEAR
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_3_SET
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|elink_xgxs_specific_func
argument_list|(
operator|&
name|params
operator|->
name|phy
index|[
name|ELINK_INT_PHY
index|]
argument_list|,
name|params
argument_list|,
name|ELINK_PHY_INIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_calc_ieee_aneg_adv
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint16_t
modifier|*
name|ieee_fc
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
operator|*
name|ieee_fc
operator|=
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_FULL_DUPLEX
expr_stmt|;
comment|/* Resolve pause mode and advertisement Please refer to Table 	 * 28B-3 of the 802.3ab-1999 spec 	 */
switch|switch
condition|(
name|phy
operator|->
name|req_flow_ctrl
condition|)
block|{
case|case
name|ELINK_FLOW_CTRL_AUTO
case|:
switch|switch
condition|(
name|params
operator|->
name|req_fc_auto_adv
condition|)
block|{
case|case
name|ELINK_FLOW_CTRL_BOTH
case|:
case|case
name|ELINK_FLOW_CTRL_RX
case|:
operator|*
name|ieee_fc
operator||=
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH
expr_stmt|;
break|break;
case|case
name|ELINK_FLOW_CTRL_TX
case|:
operator|*
name|ieee_fc
operator||=
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|ELINK_FLOW_CTRL_TX
case|:
operator|*
name|ieee_fc
operator||=
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC
expr_stmt|;
break|break;
case|case
name|ELINK_FLOW_CTRL_RX
case|:
case|case
name|ELINK_FLOW_CTRL_BOTH
case|:
operator|*
name|ieee_fc
operator||=
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH
expr_stmt|;
break|break;
case|case
name|ELINK_FLOW_CTRL_NONE
case|:
default|default:
operator|*
name|ieee_fc
operator||=
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_NONE
expr_stmt|;
break|break;
block|}
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"ieee_fc = 0x%x\n"
argument_list|,
operator|*
name|ieee_fc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_phy_vars
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint8_t
name|actual_phy_idx
decl_stmt|,
name|phy_index
decl_stmt|,
name|link_cfg_idx
decl_stmt|;
name|uint8_t
name|phy_config_swapped
init|=
name|params
operator|->
name|multi_phy_config
operator|&
name|PORT_HW_CFG_PHY_SWAPPED_ENABLED
decl_stmt|;
for|for
control|(
name|phy_index
operator|=
name|ELINK_INT_PHY
init|;
name|phy_index
operator|<
name|params
operator|->
name|num_phys
condition|;
name|phy_index
operator|++
control|)
block|{
name|link_cfg_idx
operator|=
name|ELINK_LINK_CONFIG_IDX
argument_list|(
name|phy_index
argument_list|)
expr_stmt|;
name|actual_phy_idx
operator|=
name|phy_index
expr_stmt|;
if|if
condition|(
name|phy_config_swapped
condition|)
block|{
if|if
condition|(
name|phy_index
operator|==
name|ELINK_EXT_PHY1
condition|)
name|actual_phy_idx
operator|=
name|ELINK_EXT_PHY2
expr_stmt|;
elseif|else
if|if
condition|(
name|phy_index
operator|==
name|ELINK_EXT_PHY2
condition|)
name|actual_phy_idx
operator|=
name|ELINK_EXT_PHY1
expr_stmt|;
block|}
name|params
operator|->
name|phy
index|[
name|actual_phy_idx
index|]
operator|.
name|req_flow_ctrl
operator|=
name|params
operator|->
name|req_flow_ctrl
index|[
name|link_cfg_idx
index|]
expr_stmt|;
name|params
operator|->
name|phy
index|[
name|actual_phy_idx
index|]
operator|.
name|req_line_speed
operator|=
name|params
operator|->
name|req_line_speed
index|[
name|link_cfg_idx
index|]
expr_stmt|;
name|params
operator|->
name|phy
index|[
name|actual_phy_idx
index|]
operator|.
name|speed_cap_mask
operator|=
name|params
operator|->
name|speed_cap_mask
index|[
name|link_cfg_idx
index|]
expr_stmt|;
name|params
operator|->
name|phy
index|[
name|actual_phy_idx
index|]
operator|.
name|req_duplex
operator|=
name|params
operator|->
name|req_duplex
index|[
name|link_cfg_idx
index|]
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|req_line_speed
index|[
name|link_cfg_idx
index|]
operator|==
name|ELINK_SPEED_AUTO_NEG
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_AUTO_NEGOTIATE_ENABLED
expr_stmt|;
name|ELINK_DEBUG_P3
argument_list|(
name|sc
argument_list|,
literal|"req_flow_ctrl %x, req_line_speed %x,"
literal|" speed_cap_mask %x\n"
argument_list|,
name|params
operator|->
name|phy
index|[
name|actual_phy_idx
index|]
operator|.
name|req_flow_ctrl
argument_list|,
name|params
operator|->
name|phy
index|[
name|actual_phy_idx
index|]
operator|.
name|req_line_speed
argument_list|,
name|params
operator|->
name|phy
index|[
name|actual_phy_idx
index|]
operator|.
name|speed_cap_mask
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|elink_ext_phy_set_pause
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|uint16_t
name|val
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
comment|/* Read modify write pause advertizing */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_ADV_PAUSE
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|MDIO_AN_REG_ADV_PAUSE_BOTH
expr_stmt|;
comment|/* Please refer to Table 28B-3 of 802.3ab-1999 spec. */
name|elink_calc_ieee_aneg_adv
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
operator|&
name|vars
operator|->
name|ieee_fc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vars
operator|->
name|ieee_fc
operator|&
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC
operator|)
operator|==
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC
condition|)
block|{
name|val
operator||=
name|MDIO_AN_REG_ADV_PAUSE_ASYMMETRIC
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|vars
operator|->
name|ieee_fc
operator|&
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH
operator|)
operator|==
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH
condition|)
block|{
name|val
operator||=
name|MDIO_AN_REG_ADV_PAUSE_PAUSE
expr_stmt|;
block|}
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Ext phy AN advertize 0x%x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_ADV_PAUSE
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_pause_resolve
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|,
name|uint32_t
name|pause_result
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
comment|/*  LD	    LP	 */
switch|switch
condition|(
name|pause_result
condition|)
block|{
comment|/* ASYM P ASYM P */
case|case
literal|0xb
case|:
comment|/*   1  0   1  1 */
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Flow Control: TX only\n"
argument_list|)
expr_stmt|;
name|vars
operator|->
name|flow_ctrl
operator|=
name|ELINK_FLOW_CTRL_TX
expr_stmt|;
break|break;
case|case
literal|0xe
case|:
comment|/*   1  1   1  0 */
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Flow Control: RX only\n"
argument_list|)
expr_stmt|;
name|vars
operator|->
name|flow_ctrl
operator|=
name|ELINK_FLOW_CTRL_RX
expr_stmt|;
break|break;
case|case
literal|0x5
case|:
comment|/*   0  1   0  1 */
case|case
literal|0x7
case|:
comment|/*   0  1   1  1 */
case|case
literal|0xd
case|:
comment|/*   1  1   0  1 */
case|case
literal|0xf
case|:
comment|/*   1  1   1  1 */
comment|/* If the user selected to advertise RX ONLY, 		 * although we advertised both, need to enable 		 * RX only. 		 */
if|if
condition|(
name|params
operator|->
name|req_fc_auto_adv
operator|==
name|ELINK_FLOW_CTRL_BOTH
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Flow Control: RX& TX\n"
argument_list|)
expr_stmt|;
name|vars
operator|->
name|flow_ctrl
operator|=
name|ELINK_FLOW_CTRL_BOTH
expr_stmt|;
block|}
else|else
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Flow Control: RX only\n"
argument_list|)
expr_stmt|;
name|vars
operator|->
name|flow_ctrl
operator|=
name|ELINK_FLOW_CTRL_RX
expr_stmt|;
block|}
break|break;
default|default:
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Flow Control: None\n"
argument_list|)
expr_stmt|;
name|vars
operator|->
name|flow_ctrl
operator|=
name|ELINK_FLOW_CTRL_NONE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pause_result
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_LINK_PARTNER_SYMMETRIC_PAUSE
expr_stmt|;
if|if
condition|(
name|pause_result
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_LINK_PARTNER_ASYMMETRIC_PAUSE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_ext_phy_update_adv_fc
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|uint16_t
name|ld_pause
decl_stmt|;
comment|/* local */
name|uint16_t
name|lp_pause
decl_stmt|;
comment|/* link partner */
name|uint16_t
name|pause_result
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
if|if
condition|(
name|phy
operator|->
name|type
operator|==
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM54618SE
condition|)
block|{
name|elink_cl22_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
literal|0x4
argument_list|,
operator|&
name|ld_pause
argument_list|)
expr_stmt|;
name|elink_cl22_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
literal|0x5
argument_list|,
operator|&
name|lp_pause
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
operator|&&
name|ELINK_SINGLE_MEDIA_DIRECT
argument_list|(
name|params
argument_list|)
condition|)
block|{
name|uint8_t
name|lane
init|=
name|elink_get_warpcore_lane
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
decl_stmt|;
name|uint16_t
name|gp_status
decl_stmt|,
name|gp_mask
decl_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_WC_REG_GP2_STATUS_GP_2_4
argument_list|,
operator|&
name|gp_status
argument_list|)
expr_stmt|;
name|gp_mask
operator|=
operator|(
name|MDIO_WC_REG_GP2_STATUS_GP_2_4_CL73_AN_CMPL
operator||
name|MDIO_WC_REG_GP2_STATUS_GP_2_4_CL37_LP_AN_CAP
operator|)
operator|<<
name|lane
expr_stmt|;
if|if
condition|(
operator|(
name|gp_status
operator|&
name|gp_mask
operator|)
operator|==
name|gp_mask
condition|)
block|{
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_ADV_PAUSE
argument_list|,
operator|&
name|ld_pause
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_LP_AUTO_NEG
argument_list|,
operator|&
name|lp_pause
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_CL37_FC_LD
argument_list|,
operator|&
name|ld_pause
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_CL37_FC_LP
argument_list|,
operator|&
name|lp_pause
argument_list|)
expr_stmt|;
name|ld_pause
operator|=
operator|(
operator|(
name|ld_pause
operator|&
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
name|lp_pause
operator|=
operator|(
operator|(
name|lp_pause
operator|&
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_ADV_PAUSE
argument_list|,
operator|&
name|ld_pause
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_LP_AUTO_NEG
argument_list|,
operator|&
name|lp_pause
argument_list|)
expr_stmt|;
block|}
name|pause_result
operator|=
operator|(
name|ld_pause
operator|&
name|MDIO_AN_REG_ADV_PAUSE_MASK
operator|)
operator|>>
literal|8
expr_stmt|;
name|pause_result
operator||=
operator|(
name|lp_pause
operator|&
name|MDIO_AN_REG_ADV_PAUSE_MASK
operator|)
operator|>>
literal|10
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Ext PHY pause result 0x%x\n"
argument_list|,
name|pause_result
argument_list|)
expr_stmt|;
name|elink_pause_resolve
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|,
name|pause_result
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|elink_ext_phy_resolve_fc
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|uint8_t
name|ret
init|=
literal|0
decl_stmt|;
name|vars
operator|->
name|flow_ctrl
operator|=
name|ELINK_FLOW_CTRL_NONE
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|req_flow_ctrl
operator|!=
name|ELINK_FLOW_CTRL_AUTO
condition|)
block|{
comment|/* Update the advertised flow-controled of LD/LP in AN */
if|if
condition|(
name|phy
operator|->
name|req_line_speed
operator|==
name|ELINK_SPEED_AUTO_NEG
condition|)
name|elink_ext_phy_update_adv_fc
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
comment|/* But set the flow-control result as the requested one */
name|vars
operator|->
name|flow_ctrl
operator|=
name|phy
operator|->
name|req_flow_ctrl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|phy
operator|->
name|req_line_speed
operator|!=
name|ELINK_SPEED_AUTO_NEG
condition|)
name|vars
operator|->
name|flow_ctrl
operator|=
name|params
operator|->
name|req_fc_auto_adv
expr_stmt|;
elseif|else
if|if
condition|(
name|vars
operator|->
name|link_status
operator|&
name|LINK_STATUS_AUTO_NEGOTIATE_COMPLETE
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
name|elink_ext_phy_update_adv_fc
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/******************************************************************/
end_comment

begin_comment
comment|/*			Warpcore section			  */
end_comment

begin_comment
comment|/******************************************************************/
end_comment

begin_comment
comment|/* The init_internal_warpcore should mirror the xgxs,  * i.e. reset the lane (if needed), set aer for the  * init configuration, and set/clear SGMII flag. Internal  * phy init is done purely in phy_init stage.  */
end_comment

begin_define
define|#
directive|define
name|WC_TX_DRIVER
parameter_list|(
name|post2
parameter_list|,
name|idriver
parameter_list|,
name|ipre
parameter_list|,
name|ifir
parameter_list|)
define|\
value|((post2<< MDIO_WC_REG_TX0_TX_DRIVER_POST2_COEFF_OFFSET) | \ 	 (idriver<< MDIO_WC_REG_TX0_TX_DRIVER_IDRIVER_OFFSET) | \ 	 (ipre<< MDIO_WC_REG_TX0_TX_DRIVER_IPRE_DRIVER_OFFSET) | \ 	 (ifir<< MDIO_WC_REG_TX0_TX_DRIVER_IFIR_OFFSET))
end_define

begin_define
define|#
directive|define
name|WC_TX_FIR
parameter_list|(
name|post
parameter_list|,
define|main, pre) \ 	((post<< MDIO_WC_REG_TX_FIR_TAP_POST_TAP_OFFSET) | \ 	 (main<< MDIO_WC_REG_TX_FIR_TAP_MAIN_TAP_OFFSET) | \ 	 (pre<< MDIO_WC_REG_TX_FIR_TAP_PRE_TAP_OFFSET))
end_define

begin_function
specifier|static
name|void
name|elink_update_link_attr
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint32_t
name|link_attr
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
if|if
condition|(
name|SHMEM2_HAS
argument_list|(
name|sc
argument_list|,
name|link_attr_sync
argument_list|)
condition|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|shmem2_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem2_region
argument_list|,
name|link_attr_sync
index|[
name|params
operator|->
name|port
index|]
argument_list|)
argument_list|,
name|link_attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_warpcore_enable_AN_KR2
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
specifier|static
name|struct
name|elink_reg_set
name|reg_set
index|[]
init|=
block|{
comment|/* Step 1 - Program the TX/RX alignment markers */
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_CL82_USERB1_TX_CTRL5
block|,
literal|0xa157
block|}
block|,
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_CL82_USERB1_TX_CTRL7
block|,
literal|0xcbe2
block|}
block|,
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_CL82_USERB1_TX_CTRL6
block|,
literal|0x7537
block|}
block|,
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_CL82_USERB1_TX_CTRL9
block|,
literal|0xa157
block|}
block|,
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_CL82_USERB1_RX_CTRL11
block|,
literal|0xcbe2
block|}
block|,
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_CL82_USERB1_RX_CTRL10
block|,
literal|0x7537
block|}
block|,
comment|/* Step 2 - Configure the NP registers */
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_CL73_USERB0_CTRL
block|,
literal|0x000a
block|}
block|,
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_CL73_BAM_CTRL1
block|,
literal|0x6400
block|}
block|,
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_CL73_BAM_CTRL3
block|,
literal|0x0620
block|}
block|,
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_CL73_BAM_CODE_FIELD
block|,
literal|0x0157
block|}
block|,
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_ETA_CL73_OUI1
block|,
literal|0x6464
block|}
block|,
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_ETA_CL73_OUI2
block|,
literal|0x3150
block|}
block|,
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_ETA_CL73_OUI3
block|,
literal|0x3150
block|}
block|,
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_ETA_CL73_LD_BAM_CODE
block|,
literal|0x0157
block|}
block|,
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_ETA_CL73_LD_UD_CODE
block|,
literal|0x0620
block|}
block|}
decl_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Enabling 20G-KR2\n"
argument_list|)
expr_stmt|;
name|elink_cl45_read_or_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_CL49_USERB0_CTRL
argument_list|,
operator|(
literal|3
operator|<<
literal|6
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|reg_set
argument_list|)
condition|;
name|i
operator|++
control|)
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|reg_set
index|[
name|i
index|]
operator|.
name|devad
argument_list|,
name|reg_set
index|[
name|i
index|]
operator|.
name|reg
argument_list|,
name|reg_set
index|[
name|i
index|]
operator|.
name|val
argument_list|)
expr_stmt|;
comment|/* Start KR2 work-around timer which handles BCM8073 link-parner */
name|params
operator|->
name|link_attr_sync
operator||=
name|LINK_ATTR_SYNC_KR2_ENABLE
expr_stmt|;
name|elink_update_link_attr
argument_list|(
name|params
argument_list|,
name|params
operator|->
name|link_attr_sync
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_disable_kr2
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|,
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
name|struct
name|elink_reg_set
name|reg_set
index|[]
init|=
block|{
comment|/* Step 1 - Program the TX/RX alignment markers */
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_CL82_USERB1_TX_CTRL5
block|,
literal|0x7690
block|}
block|,
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_CL82_USERB1_TX_CTRL7
block|,
literal|0xe647
block|}
block|,
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_CL82_USERB1_TX_CTRL6
block|,
literal|0xc4f0
block|}
block|,
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_CL82_USERB1_TX_CTRL9
block|,
literal|0x7690
block|}
block|,
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_CL82_USERB1_RX_CTRL11
block|,
literal|0xe647
block|}
block|,
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_CL82_USERB1_RX_CTRL10
block|,
literal|0xc4f0
block|}
block|,
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_CL73_USERB0_CTRL
block|,
literal|0x000c
block|}
block|,
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_CL73_BAM_CTRL1
block|,
literal|0x6000
block|}
block|,
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_CL73_BAM_CTRL3
block|,
literal|0x0000
block|}
block|,
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_CL73_BAM_CODE_FIELD
block|,
literal|0x0002
block|}
block|,
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_ETA_CL73_OUI1
block|,
literal|0x0000
block|}
block|,
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_ETA_CL73_OUI2
block|,
literal|0x0af7
block|}
block|,
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_ETA_CL73_OUI3
block|,
literal|0x0af7
block|}
block|,
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_ETA_CL73_LD_BAM_CODE
block|,
literal|0x0002
block|}
block|,
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_ETA_CL73_LD_UD_CODE
block|,
literal|0x0000
block|}
block|}
decl_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Disabling 20G-KR2\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|reg_set
argument_list|)
condition|;
name|i
operator|++
control|)
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|reg_set
index|[
name|i
index|]
operator|.
name|devad
argument_list|,
name|reg_set
index|[
name|i
index|]
operator|.
name|reg
argument_list|,
name|reg_set
index|[
name|i
index|]
operator|.
name|val
argument_list|)
expr_stmt|;
name|params
operator|->
name|link_attr_sync
operator|&=
operator|~
name|LINK_ATTR_SYNC_KR2_ENABLE
expr_stmt|;
name|elink_update_link_attr
argument_list|(
name|params
argument_list|,
name|params
operator|->
name|link_attr_sync
argument_list|)
expr_stmt|;
name|vars
operator|->
name|check_kr2_recovery_cnt
operator|=
name|ELINK_CHECK_KR2_RECOVERY_CNT
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_warpcore_set_lpi_passthrough
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Configure WC for LPI pass through\n"
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_EEE_COMBO_CONTROL0
argument_list|,
literal|0x7c
argument_list|)
expr_stmt|;
name|elink_cl45_read_or_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_DIGITAL4_MISC5
argument_list|,
literal|0xc000
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_warpcore_restart_AN_KR
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
comment|/* Restart autoneg on the leading lane only */
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint16_t
name|lane
init|=
name|elink_get_warpcore_lane
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
decl_stmt|;
name|CL22_WR_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_AER_BLOCK
argument_list|,
name|MDIO_AER_BLOCK_AER_REG
argument_list|,
name|lane
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_WC_REG_IEEE0BLK_MIICNTL
argument_list|,
literal|0x1200
argument_list|)
expr_stmt|;
comment|/* Restore AER */
name|elink_set_aer_mmd
argument_list|(
name|params
argument_list|,
name|phy
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_warpcore_enable_AN_KR
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|uint16_t
name|lane
decl_stmt|,
name|i
decl_stmt|,
name|cl72_ctrl
decl_stmt|,
name|an_adv
init|=
literal|0
decl_stmt|,
name|val
decl_stmt|;
name|uint32_t
name|wc_lane_config
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
specifier|static
name|struct
name|elink_reg_set
name|reg_set
index|[]
init|=
block|{
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X2
block|,
literal|0x7
block|}
block|,
block|{
name|MDIO_PMA_DEVAD
block|,
name|MDIO_WC_REG_IEEE0BLK_AUTONEGNP
block|,
literal|0x0
block|}
block|,
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_RX66_CONTROL
block|,
literal|0x7415
block|}
block|,
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_SERDESDIGITAL_MISC2
block|,
literal|0x6190
block|}
block|,
comment|/* Disable Autoneg: re-enable it after adv is done. */
block|{
name|MDIO_AN_DEVAD
block|,
name|MDIO_WC_REG_IEEE0BLK_MIICNTL
block|,
literal|0
block|}
block|,
block|{
name|MDIO_PMA_DEVAD
block|,
name|MDIO_WC_REG_PMD_KR_CONTROL
block|,
literal|0x2
block|}
block|,
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_CL72_USERB0_CL72_TX_FIR_TAP
block|,
literal|0
block|}
block|, 	}
decl_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Enable Auto Negotiation for KR\n"
argument_list|)
expr_stmt|;
comment|/* Set to default registers that may be overriden by 10G force */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|reg_set
argument_list|)
condition|;
name|i
operator|++
control|)
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|reg_set
index|[
name|i
index|]
operator|.
name|devad
argument_list|,
name|reg_set
index|[
name|i
index|]
operator|.
name|reg
argument_list|,
name|reg_set
index|[
name|i
index|]
operator|.
name|val
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_CL72_USERB0_CL72_MISC1_CONTROL
argument_list|,
operator|&
name|cl72_ctrl
argument_list|)
expr_stmt|;
name|cl72_ctrl
operator|&=
literal|0x08ff
expr_stmt|;
name|cl72_ctrl
operator||=
literal|0x3800
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_CL72_USERB0_CL72_MISC1_CONTROL
argument_list|,
name|cl72_ctrl
argument_list|)
expr_stmt|;
comment|/* Check adding advertisement for 1G KX */
if|if
condition|(
operator|(
operator|(
name|vars
operator|->
name|line_speed
operator|==
name|ELINK_SPEED_AUTO_NEG
operator|)
operator|&&
operator|(
name|phy
operator|->
name|speed_cap_mask
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_1G
operator|)
operator|)
operator|||
operator|(
name|vars
operator|->
name|line_speed
operator|==
name|ELINK_SPEED_1000
operator|)
condition|)
block|{
name|uint16_t
name|addr
init|=
name|MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X2
decl_stmt|;
name|an_adv
operator||=
operator|(
literal|1
operator|<<
literal|5
operator|)
expr_stmt|;
comment|/* Enable CL37 1G Parallel Detect */
name|elink_cl45_read_or_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|addr
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Advertize 1G\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|vars
operator|->
name|line_speed
operator|==
name|ELINK_SPEED_AUTO_NEG
operator|)
operator|&&
operator|(
name|phy
operator|->
name|speed_cap_mask
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_10G
operator|)
operator|)
operator|||
operator|(
name|vars
operator|->
name|line_speed
operator|==
name|ELINK_SPEED_10000
operator|)
condition|)
block|{
comment|/* Check adding advertisement for 10G KR */
name|an_adv
operator||=
operator|(
literal|1
operator|<<
literal|7
operator|)
expr_stmt|;
comment|/* Enable 10G Parallel Detect */
name|CL22_WR_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_AER_BLOCK
argument_list|,
name|MDIO_AER_BLOCK_AER_REG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_WC_REG_PAR_DET_10G_CTRL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|elink_set_aer_mmd
argument_list|(
name|params
argument_list|,
name|phy
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Advertize 10G\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Set Transmit PMD settings */
name|lane
operator|=
name|elink_get_warpcore_lane
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_TX0_TX_DRIVER
operator|+
literal|0x10
operator|*
name|lane
argument_list|,
name|WC_TX_DRIVER
argument_list|(
literal|0x02
argument_list|,
literal|0x06
argument_list|,
literal|0x09
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Configure the next lane if dual mode */
if|if
condition|(
name|phy
operator|->
name|flags
operator|&
name|ELINK_FLAGS_WC_DUAL_MODE
condition|)
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_TX0_TX_DRIVER
operator|+
literal|0x10
operator|*
operator|(
name|lane
operator|+
literal|1
operator|)
argument_list|,
name|WC_TX_DRIVER
argument_list|(
literal|0x02
argument_list|,
literal|0x06
argument_list|,
literal|0x09
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_CL72_USERB0_CL72_OS_DEF_CTRL
argument_list|,
literal|0x03f0
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_CL72_USERB0_CL72_2P5_DEF_CTRL
argument_list|,
literal|0x03f0
argument_list|)
expr_stmt|;
comment|/* Advertised speeds */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_WC_REG_AN_IEEE1BLK_AN_ADVERTISEMENT1
argument_list|,
name|an_adv
argument_list|)
expr_stmt|;
comment|/* Advertised and set FEC (Forward Error Correction) */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_WC_REG_AN_IEEE1BLK_AN_ADVERTISEMENT2
argument_list|,
operator|(
name|MDIO_WC_REG_AN_IEEE1BLK_AN_ADV2_FEC_ABILITY
operator||
name|MDIO_WC_REG_AN_IEEE1BLK_AN_ADV2_FEC_REQ
operator|)
argument_list|)
expr_stmt|;
comment|/* Enable CL37 BAM */
if|if
condition|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|params
operator|->
name|port
index|]
operator|.
name|default_cfg
argument_list|)
argument_list|)
operator|&
name|PORT_HW_CFG_ENABLE_BAM_ON_KR_ENABLED
condition|)
block|{
name|elink_cl45_read_or_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_DIGITAL6_MP5_NEXTPAGECTRL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Enable CL37 BAM on KR\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Advertise pause */
name|elink_ext_phy_set_pause
argument_list|(
name|params
argument_list|,
name|phy
argument_list|,
name|vars
argument_list|)
expr_stmt|;
name|vars
operator|->
name|rx_tx_asic_rst
operator|=
name|MAX_KR_LINK_RETRY
expr_stmt|;
name|elink_cl45_read_or_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_DIGITAL5_MISC7
argument_list|,
literal|0x100
argument_list|)
expr_stmt|;
comment|/* Over 1G - AN local device user page 1 */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_DIGITAL3_UP1
argument_list|,
literal|0x1f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|phy
operator|->
name|req_line_speed
operator|==
name|ELINK_SPEED_AUTO_NEG
operator|)
operator|&&
operator|(
name|phy
operator|->
name|speed_cap_mask
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_20G
operator|)
operator|)
operator|||
operator|(
name|phy
operator|->
name|req_line_speed
operator|==
name|ELINK_SPEED_20000
operator|)
condition|)
block|{
name|CL22_WR_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_AER_BLOCK
argument_list|,
name|MDIO_AER_BLOCK_AER_REG
argument_list|,
name|lane
argument_list|)
expr_stmt|;
name|elink_cl45_read_or_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_RX1_PCI_CTRL
operator|+
operator|(
literal|0x10
operator|*
name|lane
operator|)
argument_list|,
operator|(
literal|1
operator|<<
literal|11
operator|)
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_XGXS_X2_CONTROL3
argument_list|,
literal|0x7
argument_list|)
expr_stmt|;
name|elink_set_aer_mmd
argument_list|(
name|params
argument_list|,
name|phy
argument_list|)
expr_stmt|;
name|elink_warpcore_enable_AN_KR2
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Enable Auto-Detect to support 1G over CL37 as well */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X1
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
name|wc_lane_config
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|shared_hw_config
operator|.
name|wc_lane_config
argument_list|)
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_RX0_PCI_CTRL
operator|+
operator|(
name|lane
operator|<<
literal|4
operator|)
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
comment|/* Force cl48 sync_status LOW to avoid getting stuck in CL73 		 * parallel-detect loop when CL73 and CL37 are enabled. 		 */
name|val
operator||=
literal|1
operator|<<
literal|11
expr_stmt|;
comment|/* Restore Polarity settings in case it was run over by 		 * previous link owner 		 */
if|if
condition|(
name|wc_lane_config
operator|&
operator|(
name|SHARED_HW_CFG_RX_LANE0_POL_FLIP_ENABLED
operator|<<
name|lane
operator|)
condition|)
name|val
operator||=
literal|3
operator|<<
literal|2
expr_stmt|;
else|else
name|val
operator|&=
operator|~
operator|(
literal|3
operator|<<
literal|2
operator|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_RX0_PCI_CTRL
operator|+
operator|(
name|lane
operator|<<
literal|4
operator|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|elink_disable_kr2
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
name|phy
argument_list|)
expr_stmt|;
block|}
comment|/* Enable Autoneg: only on the main lane */
name|elink_warpcore_restart_AN_KR
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_warpcore_set_10G_KR
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint16_t
name|val16
decl_stmt|,
name|i
decl_stmt|,
name|lane
decl_stmt|;
specifier|static
name|struct
name|elink_reg_set
name|reg_set
index|[]
init|=
block|{
comment|/* Disable Autoneg */
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X2
block|,
literal|0x7
block|}
block|,
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_CL72_USERB0_CL72_MISC1_CONTROL
block|,
literal|0x3f00
block|}
block|,
block|{
name|MDIO_AN_DEVAD
block|,
name|MDIO_WC_REG_AN_IEEE1BLK_AN_ADVERTISEMENT1
block|,
literal|0
block|}
block|,
block|{
name|MDIO_AN_DEVAD
block|,
name|MDIO_WC_REG_IEEE0BLK_MIICNTL
block|,
literal|0x0
block|}
block|,
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_DIGITAL3_UP1
block|,
literal|0x1
block|}
block|,
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_DIGITAL5_MISC7
block|,
literal|0xa
block|}
block|,
comment|/* Leave cl72 training enable, needed for KR */
block|{
name|MDIO_PMA_DEVAD
block|,
name|MDIO_WC_REG_PMD_KR_CONTROL
block|,
literal|0x2
block|}
block|}
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|reg_set
argument_list|)
condition|;
name|i
operator|++
control|)
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|reg_set
index|[
name|i
index|]
operator|.
name|devad
argument_list|,
name|reg_set
index|[
name|i
index|]
operator|.
name|reg
argument_list|,
name|reg_set
index|[
name|i
index|]
operator|.
name|val
argument_list|)
expr_stmt|;
name|lane
operator|=
name|elink_get_warpcore_lane
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
expr_stmt|;
comment|/* Global registers */
name|CL22_WR_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_AER_BLOCK
argument_list|,
name|MDIO_AER_BLOCK_AER_REG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable CL36 PCS Tx */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_XGXSBLK1_LANECTRL0
argument_list|,
operator|&
name|val16
argument_list|)
expr_stmt|;
name|val16
operator|&=
operator|~
operator|(
literal|0x0011
operator|<<
name|lane
operator|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_XGXSBLK1_LANECTRL0
argument_list|,
name|val16
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_XGXSBLK1_LANECTRL1
argument_list|,
operator|&
name|val16
argument_list|)
expr_stmt|;
name|val16
operator||=
operator|(
literal|0x0303
operator|<<
operator|(
name|lane
operator|<<
literal|1
operator|)
operator|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_XGXSBLK1_LANECTRL1
argument_list|,
name|val16
argument_list|)
expr_stmt|;
comment|/* Restore AER */
name|elink_set_aer_mmd
argument_list|(
name|params
argument_list|,
name|phy
argument_list|)
expr_stmt|;
comment|/* Set speed via PMA/PMD register */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_WC_REG_IEEE0BLK_MIICNTL
argument_list|,
literal|0x2040
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_WC_REG_IEEE0BLK_AUTONEGNP
argument_list|,
literal|0xB
argument_list|)
expr_stmt|;
comment|/* Enable encoded forced speed */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_SERDESDIGITAL_MISC2
argument_list|,
literal|0x30
argument_list|)
expr_stmt|;
comment|/* Turn TX scramble payload only the 64/66 scrambler */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_TX66_CONTROL
argument_list|,
literal|0x9
argument_list|)
expr_stmt|;
comment|/* Turn RX scramble payload only the 64/66 scrambler */
name|elink_cl45_read_or_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_RX66_CONTROL
argument_list|,
literal|0xF9
argument_list|)
expr_stmt|;
comment|/* Set and clear loopback to cause a reset to 64/66 decoder */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_IEEE0BLK_MIICNTL
argument_list|,
literal|0x4000
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_IEEE0BLK_MIICNTL
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_warpcore_set_10G_XFI
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint8_t
name|is_xfi
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint16_t
name|misc1_val
decl_stmt|,
name|tap_val
decl_stmt|,
name|tx_driver_val
decl_stmt|,
name|lane
decl_stmt|,
name|val
decl_stmt|;
name|uint32_t
name|cfg_tap_val
decl_stmt|,
name|tx_drv_brdct
decl_stmt|,
name|tx_equal
decl_stmt|;
name|uint32_t
name|ifir_val
decl_stmt|,
name|ipost2_val
decl_stmt|,
name|ipre_driver_val
decl_stmt|;
comment|/* Hold rxSeqStart */
name|elink_cl45_read_or_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_DSC2B0_DSC_MISC_CTRL0
argument_list|,
literal|0x8000
argument_list|)
expr_stmt|;
comment|/* Hold tx_fifo_reset */
name|elink_cl45_read_or_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X3
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
comment|/* Disable CL73 AN */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_CTRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable 100FX Enable and Auto-Detect */
name|elink_cl45_read_and_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_FX100_CTRL1
argument_list|,
literal|0xFFFA
argument_list|)
expr_stmt|;
comment|/* Disable 100FX Idle detect */
name|elink_cl45_read_or_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_FX100_CTRL3
argument_list|,
literal|0x0080
argument_list|)
expr_stmt|;
comment|/* Set Block address to Remote PHY& Clear forced_speed[5] */
name|elink_cl45_read_and_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_DIGITAL4_MISC3
argument_list|,
literal|0xFF7F
argument_list|)
expr_stmt|;
comment|/* Turn off auto-detect& fiber mode */
name|elink_cl45_read_and_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X1
argument_list|,
literal|0xFFEE
argument_list|)
expr_stmt|;
comment|/* Set filter_force_link, disable_false_link and parallel_detect */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X2
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X2
argument_list|,
operator|(
operator|(
name|val
operator||
literal|0x0006
operator|)
operator|&
literal|0xFFFE
operator|)
argument_list|)
expr_stmt|;
comment|/* Set XFI / SFI */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_SERDESDIGITAL_MISC1
argument_list|,
operator|&
name|misc1_val
argument_list|)
expr_stmt|;
name|misc1_val
operator|&=
operator|~
operator|(
literal|0x1f
operator|)
expr_stmt|;
if|if
condition|(
name|is_xfi
condition|)
block|{
name|misc1_val
operator||=
literal|0x5
expr_stmt|;
name|tap_val
operator|=
name|WC_TX_FIR
argument_list|(
literal|0x08
argument_list|,
literal|0x37
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|tx_driver_val
operator|=
name|WC_TX_DRIVER
argument_list|(
literal|0x00
argument_list|,
literal|0x02
argument_list|,
literal|0x03
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cfg_tap_val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|params
operator|->
name|port
index|]
operator|.
name|sfi_tap_values
argument_list|)
argument_list|)
expr_stmt|;
name|tx_equal
operator|=
name|cfg_tap_val
operator|&
name|PORT_HW_CFG_TX_EQUALIZATION_MASK
expr_stmt|;
name|misc1_val
operator||=
literal|0x9
expr_stmt|;
comment|/* TAP values are controlled by nvram, if value there isn't 0 */
if|if
condition|(
name|tx_equal
condition|)
name|tap_val
operator|=
operator|(
name|uint16_t
operator|)
name|tx_equal
expr_stmt|;
else|else
name|tap_val
operator|=
name|WC_TX_FIR
argument_list|(
literal|0x0f
argument_list|,
literal|0x2b
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
name|ifir_val
operator|=
name|DEFAULT_TX_DRV_IFIR
expr_stmt|;
name|ipost2_val
operator|=
name|DEFAULT_TX_DRV_POST2
expr_stmt|;
name|ipre_driver_val
operator|=
name|DEFAULT_TX_DRV_IPRE_DRIVER
expr_stmt|;
name|tx_drv_brdct
operator|=
name|DEFAULT_TX_DRV_BRDCT
expr_stmt|;
comment|/* If any of the IFIR/IPRE_DRIVER/POST@ is set, apply all 		 * configuration. 		 */
if|if
condition|(
name|cfg_tap_val
operator|&
operator|(
name|PORT_HW_CFG_TX_DRV_IFIR_MASK
operator||
name|PORT_HW_CFG_TX_DRV_IPREDRIVER_MASK
operator||
name|PORT_HW_CFG_TX_DRV_POST2_MASK
operator|)
condition|)
block|{
name|ifir_val
operator|=
operator|(
name|cfg_tap_val
operator|&
name|PORT_HW_CFG_TX_DRV_IFIR_MASK
operator|)
operator|>>
name|PORT_HW_CFG_TX_DRV_IFIR_SHIFT
expr_stmt|;
name|ipre_driver_val
operator|=
operator|(
name|cfg_tap_val
operator|&
name|PORT_HW_CFG_TX_DRV_IPREDRIVER_MASK
operator|)
operator|>>
name|PORT_HW_CFG_TX_DRV_IPREDRIVER_SHIFT
expr_stmt|;
name|ipost2_val
operator|=
operator|(
name|cfg_tap_val
operator|&
name|PORT_HW_CFG_TX_DRV_POST2_MASK
operator|)
operator|>>
name|PORT_HW_CFG_TX_DRV_POST2_SHIFT
expr_stmt|;
block|}
if|if
condition|(
name|cfg_tap_val
operator|&
name|PORT_HW_CFG_TX_DRV_BROADCAST_MASK
condition|)
block|{
name|tx_drv_brdct
operator|=
operator|(
name|cfg_tap_val
operator|&
name|PORT_HW_CFG_TX_DRV_BROADCAST_MASK
operator|)
operator|>>
name|PORT_HW_CFG_TX_DRV_BROADCAST_SHIFT
expr_stmt|;
block|}
name|tx_driver_val
operator|=
name|WC_TX_DRIVER
argument_list|(
name|ipost2_val
argument_list|,
name|tx_drv_brdct
argument_list|,
name|ipre_driver_val
argument_list|,
name|ifir_val
argument_list|)
expr_stmt|;
block|}
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_SERDESDIGITAL_MISC1
argument_list|,
name|misc1_val
argument_list|)
expr_stmt|;
comment|/* Set Transmit PMD settings */
name|lane
operator|=
name|elink_get_warpcore_lane
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_TX_FIR_TAP
argument_list|,
name|tap_val
operator||
name|MDIO_WC_REG_TX_FIR_TAP_ENABLE
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_TX0_TX_DRIVER
operator|+
literal|0x10
operator|*
name|lane
argument_list|,
name|tx_driver_val
argument_list|)
expr_stmt|;
comment|/* Enable fiber mode, enable and invert sig_det */
name|elink_cl45_read_or_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X1
argument_list|,
literal|0xd
argument_list|)
expr_stmt|;
comment|/* Set Block address to Remote PHY& Set forced_speed[5], 40bit mode */
name|elink_cl45_read_or_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_DIGITAL4_MISC3
argument_list|,
literal|0x8080
argument_list|)
expr_stmt|;
name|elink_warpcore_set_lpi_passthrough
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
expr_stmt|;
comment|/* 10G XFI Full Duplex */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_IEEE0BLK_MIICNTL
argument_list|,
literal|0x100
argument_list|)
expr_stmt|;
comment|/* Release tx_fifo_reset */
name|elink_cl45_read_and_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X3
argument_list|,
literal|0xFFFE
argument_list|)
expr_stmt|;
comment|/* Release rxSeqStart */
name|elink_cl45_read_and_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_DSC2B0_DSC_MISC_CTRL0
argument_list|,
literal|0x7FFF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_warpcore_set_20G_force_KR2
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|uint16_t
name|val
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
comment|/* Set global registers, so set AER lane to 0 */
name|CL22_WR_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_AER_BLOCK
argument_list|,
name|MDIO_AER_BLOCK_AER_REG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable sequencer */
name|elink_cl45_read_and_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_XGXSBLK0_XGXSCONTROL
argument_list|,
operator|~
operator|(
literal|1
operator|<<
literal|13
operator|)
argument_list|)
expr_stmt|;
name|elink_set_aer_mmd
argument_list|(
name|params
argument_list|,
name|phy
argument_list|)
expr_stmt|;
name|elink_cl45_read_and_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_WC_REG_PMD_KR_CONTROL
argument_list|,
operator|~
operator|(
literal|1
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_CTRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Turn off CL73 */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_CL73_USERB0_CTRL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|5
operator|)
expr_stmt|;
name|val
operator||=
operator|(
literal|1
operator|<<
literal|6
operator|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_CL73_USERB0_CTRL
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Set 20G KR2 force speed */
name|elink_cl45_read_or_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_SERDESDIGITAL_MISC1
argument_list|,
literal|0x1f
argument_list|)
expr_stmt|;
name|elink_cl45_read_or_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_DIGITAL4_MISC3
argument_list|,
operator|(
literal|1
operator|<<
literal|7
operator|)
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_CL72_USERB0_CL72_MISC1_CONTROL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
literal|3
operator|<<
literal|14
operator|)
expr_stmt|;
name|val
operator||=
operator|(
literal|1
operator|<<
literal|15
operator|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_CL72_USERB0_CL72_MISC1_CONTROL
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_CL72_USERB0_CL72_TX_FIR_TAP
argument_list|,
literal|0x835A
argument_list|)
expr_stmt|;
comment|/* Enable sequencer (over lane 0) */
name|CL22_WR_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_AER_BLOCK
argument_list|,
name|MDIO_AER_BLOCK_AER_REG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|elink_cl45_read_or_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_XGXSBLK0_XGXSCONTROL
argument_list|,
operator|(
literal|1
operator|<<
literal|13
operator|)
argument_list|)
expr_stmt|;
name|elink_set_aer_mmd
argument_list|(
name|params
argument_list|,
name|phy
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_warpcore_set_20G_DXGXS
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|uint16_t
name|lane
parameter_list|)
block|{
comment|/* Rx0 anaRxControl1G */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_RX0_ANARXCONTROL1G
argument_list|,
literal|0x90
argument_list|)
expr_stmt|;
comment|/* Rx2 anaRxControl1G */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_RX2_ANARXCONTROL1G
argument_list|,
literal|0x90
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_RX66_SCW0
argument_list|,
literal|0xE070
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_RX66_SCW1
argument_list|,
literal|0xC0D0
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_RX66_SCW2
argument_list|,
literal|0xA0B0
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_RX66_SCW3
argument_list|,
literal|0x8090
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_RX66_SCW0_MASK
argument_list|,
literal|0xF0F0
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_RX66_SCW1_MASK
argument_list|,
literal|0xF0F0
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_RX66_SCW2_MASK
argument_list|,
literal|0xF0F0
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_RX66_SCW3_MASK
argument_list|,
literal|0xF0F0
argument_list|)
expr_stmt|;
comment|/* Serdes Digital Misc1 */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_SERDESDIGITAL_MISC1
argument_list|,
literal|0x6008
argument_list|)
expr_stmt|;
comment|/* Serdes Digital4 Misc3 */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_DIGITAL4_MISC3
argument_list|,
literal|0x8088
argument_list|)
expr_stmt|;
comment|/* Set Transmit PMD settings */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_TX_FIR_TAP
argument_list|,
operator|(
name|WC_TX_FIR
argument_list|(
literal|0x12
argument_list|,
literal|0x2d
argument_list|,
literal|0x00
argument_list|)
operator||
name|MDIO_WC_REG_TX_FIR_TAP_ENABLE
operator|)
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_TX0_TX_DRIVER
operator|+
literal|0x10
operator|*
name|lane
argument_list|,
name|WC_TX_DRIVER
argument_list|(
literal|0x02
argument_list|,
literal|0x02
argument_list|,
literal|0x02
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_warpcore_set_sgmii_speed
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint8_t
name|fiber_mode
parameter_list|,
name|uint8_t
name|always_autoneg
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint16_t
name|val16
decl_stmt|,
name|digctrl_kx1
decl_stmt|,
name|digctrl_kx2
decl_stmt|;
comment|/* Clear XFI clock comp in non-10G single lane mode. */
name|elink_cl45_read_and_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_RX66_CONTROL
argument_list|,
operator|~
operator|(
literal|3
operator|<<
literal|13
operator|)
argument_list|)
expr_stmt|;
name|elink_warpcore_set_lpi_passthrough
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|always_autoneg
operator|||
name|phy
operator|->
name|req_line_speed
operator|==
name|ELINK_SPEED_AUTO_NEG
condition|)
block|{
comment|/* SGMII Autoneg */
name|elink_cl45_read_or_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_COMBO_IEEE0_MIICTRL
argument_list|,
literal|0x1000
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"set SGMII AUTONEG\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_COMBO_IEEE0_MIICTRL
argument_list|,
operator|&
name|val16
argument_list|)
expr_stmt|;
name|val16
operator|&=
literal|0xcebf
expr_stmt|;
switch|switch
condition|(
name|phy
operator|->
name|req_line_speed
condition|)
block|{
case|case
name|ELINK_SPEED_10
case|:
break|break;
case|case
name|ELINK_SPEED_100
case|:
name|val16
operator||=
literal|0x2000
expr_stmt|;
break|break;
case|case
name|ELINK_SPEED_1000
case|:
name|val16
operator||=
literal|0x0040
expr_stmt|;
break|break;
default|default:
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Speed not supported: 0x%x\n"
argument_list|,
name|phy
operator|->
name|req_line_speed
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|phy
operator|->
name|req_duplex
operator|==
name|DUPLEX_FULL
condition|)
name|val16
operator||=
literal|0x0100
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_COMBO_IEEE0_MIICTRL
argument_list|,
name|val16
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"set SGMII force speed %d\n"
argument_list|,
name|phy
operator|->
name|req_line_speed
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_COMBO_IEEE0_MIICTRL
argument_list|,
operator|&
name|val16
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"  (readback) %x\n"
argument_list|,
name|val16
argument_list|)
expr_stmt|;
block|}
comment|/* SGMII Slave mode and disable signal detect */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X1
argument_list|,
operator|&
name|digctrl_kx1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fiber_mode
condition|)
name|digctrl_kx1
operator|=
literal|1
expr_stmt|;
else|else
name|digctrl_kx1
operator|&=
literal|0xff4a
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X1
argument_list|,
name|digctrl_kx1
argument_list|)
expr_stmt|;
comment|/* Turn off parallel detect */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X2
argument_list|,
operator|&
name|digctrl_kx2
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X2
argument_list|,
operator|(
name|digctrl_kx2
operator|&
operator|~
operator|(
literal|1
operator|<<
literal|2
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Re-enable parallel detect */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X2
argument_list|,
operator|(
name|digctrl_kx2
operator||
operator|(
literal|1
operator|<<
literal|2
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Enable autodet */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X1
argument_list|,
operator|(
name|digctrl_kx1
operator||
literal|0x10
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_warpcore_reset_lane
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|uint8_t
name|reset
parameter_list|)
block|{
name|uint16_t
name|val
decl_stmt|;
comment|/* Take lane out of reset after configuration is finished */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_DIGITAL5_MISC6
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|reset
condition|)
name|val
operator||=
literal|0xC000
expr_stmt|;
else|else
name|val
operator|&=
literal|0x3FFF
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_DIGITAL5_MISC6
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_DIGITAL5_MISC6
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear SFI/XFI link settings registers */
end_comment

begin_function
specifier|static
name|void
name|elink_warpcore_clear_regs
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint16_t
name|lane
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
specifier|static
name|struct
name|elink_reg_set
name|wc_regs
index|[]
init|=
block|{
block|{
name|MDIO_AN_DEVAD
block|,
name|MDIO_AN_REG_CTRL
block|,
literal|0
block|}
block|,
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_FX100_CTRL1
block|,
literal|0x014a
block|}
block|,
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_FX100_CTRL3
block|,
literal|0x0800
block|}
block|,
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_DIGITAL4_MISC3
block|,
literal|0x8008
block|}
block|,
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X1
block|,
literal|0x0195
block|}
block|,
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X2
block|,
literal|0x0007
block|}
block|,
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_SERDESDIGITAL_CONTROL1000X3
block|,
literal|0x0002
block|}
block|,
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_SERDESDIGITAL_MISC1
block|,
literal|0x6000
block|}
block|,
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_TX_FIR_TAP
block|,
literal|0x0000
block|}
block|,
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_IEEE0BLK_MIICNTL
block|,
literal|0x2040
block|}
block|,
block|{
name|MDIO_WC_DEVAD
block|,
name|MDIO_WC_REG_COMBO_IEEE0_MIICTRL
block|,
literal|0x0140
block|}
block|}
decl_stmt|;
comment|/* Set XFI clock comp as default. */
name|elink_cl45_read_or_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_RX66_CONTROL
argument_list|,
operator|(
literal|3
operator|<<
literal|13
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|wc_regs
argument_list|)
condition|;
name|i
operator|++
control|)
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|wc_regs
index|[
name|i
index|]
operator|.
name|devad
argument_list|,
name|wc_regs
index|[
name|i
index|]
operator|.
name|reg
argument_list|,
name|wc_regs
index|[
name|i
index|]
operator|.
name|val
argument_list|)
expr_stmt|;
name|lane
operator|=
name|elink_get_warpcore_lane
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_TX0_TX_DRIVER
operator|+
literal|0x10
operator|*
name|lane
argument_list|,
literal|0x0990
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_get_mod_abs_int_cfg
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|chip_id
parameter_list|,
name|uint32_t
name|shmem_base
parameter_list|,
name|uint8_t
name|port
parameter_list|,
name|uint8_t
modifier|*
name|gpio_num
parameter_list|,
name|uint8_t
modifier|*
name|gpio_port
parameter_list|)
block|{
name|uint32_t
name|cfg_pin
decl_stmt|;
operator|*
name|gpio_num
operator|=
literal|0
expr_stmt|;
operator|*
name|gpio_port
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|cfg_pin
operator|=
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|port
index|]
operator|.
name|e3_sfp_ctrl
argument_list|)
argument_list|)
operator|&
name|PORT_HW_CFG_E3_MOD_ABS_MASK
operator|)
operator|>>
name|PORT_HW_CFG_E3_MOD_ABS_SHIFT
expr_stmt|;
comment|/* Should not happen. This function called upon interrupt 		 * triggered by GPIO ( since EPIO can only generate interrupts 		 * to MCP). 		 * So if this function was called and none of the GPIOs was set, 		 * it means the shit hit the fan. 		 */
if|if
condition|(
operator|(
name|cfg_pin
operator|<
name|PIN_CFG_GPIO0_P0
operator|)
operator|||
operator|(
name|cfg_pin
operator|>
name|PIN_CFG_GPIO3_P1
operator|)
condition|)
block|{
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"No cfg pin %x for module detect indication\n"
argument_list|,
name|cfg_pin
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
operator|*
name|gpio_num
operator|=
operator|(
name|cfg_pin
operator|-
name|PIN_CFG_GPIO0_P0
operator|)
operator|&
literal|0x3
expr_stmt|;
operator|*
name|gpio_port
operator|=
operator|(
name|cfg_pin
operator|-
name|PIN_CFG_GPIO0_P0
operator|)
operator|>>
literal|2
expr_stmt|;
block|}
else|else
block|{
operator|*
name|gpio_num
operator|=
name|MISC_REGISTERS_GPIO_3
expr_stmt|;
operator|*
name|gpio_port
operator|=
name|port
expr_stmt|;
block|}
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|elink_is_sfp_module_plugged
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint8_t
name|gpio_num
decl_stmt|,
name|gpio_port
decl_stmt|;
name|uint32_t
name|gpio_val
decl_stmt|;
if|if
condition|(
name|elink_get_mod_abs_int_cfg
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|chip_id
argument_list|,
name|params
operator|->
name|shmem_base
argument_list|,
name|params
operator|->
name|port
argument_list|,
operator|&
name|gpio_num
argument_list|,
operator|&
name|gpio_port
argument_list|)
operator|!=
name|ELINK_STATUS_OK
condition|)
return|return
literal|0
return|;
name|gpio_val
operator|=
name|elink_cb_gpio_read
argument_list|(
name|sc
argument_list|,
name|gpio_num
argument_list|,
name|gpio_port
argument_list|)
expr_stmt|;
comment|/* Call the handling function in case module is detected */
if|if
condition|(
name|gpio_val
operator|==
literal|0
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|elink_warpcore_get_sigdet
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|uint16_t
name|gp2_status_reg0
decl_stmt|,
name|lane
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|lane
operator|=
name|elink_get_warpcore_lane
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_GP2_STATUS_GP_2_0
argument_list|,
operator|&
name|gp2_status_reg0
argument_list|)
expr_stmt|;
return|return
operator|(
name|gp2_status_reg0
operator|>>
operator|(
literal|8
operator|+
name|lane
operator|)
operator|)
operator|&
literal|0x1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_warpcore_config_runtime
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint32_t
name|serdes_net_if
decl_stmt|;
name|uint16_t
name|gp_status1
init|=
literal|0
decl_stmt|,
name|lnkup
init|=
literal|0
decl_stmt|,
name|lnkup_kr
init|=
literal|0
decl_stmt|;
name|vars
operator|->
name|turn_to_run_wc_rt
operator|=
name|vars
operator|->
name|turn_to_run_wc_rt
condition|?
literal|0
else|:
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|vars
operator|->
name|turn_to_run_wc_rt
condition|)
return|return;
if|if
condition|(
name|vars
operator|->
name|rx_tx_asic_rst
condition|)
block|{
name|uint16_t
name|lane
init|=
name|elink_get_warpcore_lane
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
decl_stmt|;
name|serdes_net_if
operator|=
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|params
operator|->
name|port
index|]
operator|.
name|default_cfg
argument_list|)
argument_list|)
operator|&
name|PORT_HW_CFG_NET_SERDES_IF_MASK
operator|)
expr_stmt|;
switch|switch
condition|(
name|serdes_net_if
condition|)
block|{
case|case
name|PORT_HW_CFG_NET_SERDES_IF_KR
case|:
comment|/* Do we get link yet? */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
literal|0x81d1
argument_list|,
operator|&
name|gp_status1
argument_list|)
expr_stmt|;
name|lnkup
operator|=
operator|(
name|gp_status1
operator|>>
operator|(
literal|8
operator|+
name|lane
operator|)
operator|)
operator|&
literal|0x1
expr_stmt|;
comment|/* 1G */
comment|/*10G KR*/
name|lnkup_kr
operator|=
operator|(
name|gp_status1
operator|>>
operator|(
literal|12
operator|+
name|lane
operator|)
operator|)
operator|&
literal|0x1
expr_stmt|;
if|if
condition|(
name|lnkup_kr
operator|||
name|lnkup
condition|)
block|{
name|vars
operator|->
name|rx_tx_asic_rst
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Reset the lane to see if link comes up.*/
name|elink_warpcore_reset_lane
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|elink_warpcore_reset_lane
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Restart Autoneg */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_WC_REG_IEEE0BLK_MIICNTL
argument_list|,
literal|0x1200
argument_list|)
expr_stmt|;
name|vars
operator|->
name|rx_tx_asic_rst
operator|--
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"0x%x retry left\n"
argument_list|,
name|vars
operator|->
name|rx_tx_asic_rst
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
comment|/*params->rx_tx_asic_rst*/
block|}
end_function

begin_function
specifier|static
name|void
name|elink_warpcore_config_sfi
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|uint16_t
name|lane
init|=
name|elink_get_warpcore_lane
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|elink_warpcore_clear_regs
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|lane
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|params
operator|->
name|req_line_speed
index|[
name|ELINK_LINK_CONFIG_IDX
argument_list|(
name|ELINK_INT_PHY
argument_list|)
index|]
operator|==
name|ELINK_SPEED_10000
operator|)
operator|&&
operator|(
name|phy
operator|->
name|media_type
operator|!=
name|ELINK_ETH_PHY_SFP_1G_FIBER
operator|)
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Setting 10G SFI\n"
argument_list|)
expr_stmt|;
name|elink_warpcore_set_10G_XFI
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Setting 1G Fiber\n"
argument_list|)
expr_stmt|;
name|elink_warpcore_set_sgmii_speed
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|elink_sfp_e3_set_transmitter
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|uint8_t
name|tx_en
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint32_t
name|cfg_pin
decl_stmt|;
name|uint8_t
name|port
init|=
name|params
operator|->
name|port
decl_stmt|;
name|cfg_pin
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|port
index|]
operator|.
name|e3_sfp_ctrl
argument_list|)
argument_list|)
operator|&
name|PORT_HW_CFG_E3_TX_LASER_MASK
expr_stmt|;
comment|/* Set the !tx_en since this pin is DISABLE_TX_LASER */
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Setting WC TX to %d\n"
argument_list|,
name|tx_en
argument_list|)
expr_stmt|;
comment|/* For 20G, the expected pin to be used is 3 pins after the current */
name|elink_set_cfg_pin
argument_list|(
name|sc
argument_list|,
name|cfg_pin
argument_list|,
name|tx_en
operator|^
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|speed_cap_mask
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_20G
condition|)
name|elink_set_cfg_pin
argument_list|(
name|sc
argument_list|,
name|cfg_pin
operator|+
literal|3
argument_list|,
name|tx_en
operator|^
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_warpcore_config_init
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint32_t
name|serdes_net_if
decl_stmt|;
name|uint8_t
name|fiber_mode
decl_stmt|;
name|uint16_t
name|lane
init|=
name|elink_get_warpcore_lane
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
decl_stmt|;
name|serdes_net_if
operator|=
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|params
operator|->
name|port
index|]
operator|.
name|default_cfg
argument_list|)
argument_list|)
operator|&
name|PORT_HW_CFG_NET_SERDES_IF_MASK
operator|)
expr_stmt|;
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"Begin Warpcore init, link_speed %d, "
literal|"serdes_net_if = 0x%x\n"
argument_list|,
name|vars
operator|->
name|line_speed
argument_list|,
name|serdes_net_if
argument_list|)
expr_stmt|;
name|elink_set_aer_mmd
argument_list|(
name|params
argument_list|,
name|phy
argument_list|)
expr_stmt|;
name|elink_warpcore_reset_lane
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vars
operator|->
name|phy_flags
operator||=
name|PHY_XGXS_FLAG
expr_stmt|;
if|if
condition|(
operator|(
name|serdes_net_if
operator|==
name|PORT_HW_CFG_NET_SERDES_IF_SGMII
operator|)
operator|||
operator|(
name|phy
operator|->
name|req_line_speed
operator|&&
operator|(
operator|(
name|phy
operator|->
name|req_line_speed
operator|==
name|ELINK_SPEED_100
operator|)
operator|||
operator|(
name|phy
operator|->
name|req_line_speed
operator|==
name|ELINK_SPEED_10
operator|)
operator|)
operator|)
condition|)
block|{
name|vars
operator|->
name|phy_flags
operator||=
name|PHY_SGMII_FLAG
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Setting SGMII mode\n"
argument_list|)
expr_stmt|;
name|elink_warpcore_clear_regs
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|lane
argument_list|)
expr_stmt|;
name|elink_warpcore_set_sgmii_speed
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|serdes_net_if
condition|)
block|{
case|case
name|PORT_HW_CFG_NET_SERDES_IF_KR
case|:
comment|/* Enable KR Auto Neg */
if|if
condition|(
name|params
operator|->
name|loopback_mode
operator|!=
name|ELINK_LOOPBACK_EXT
condition|)
name|elink_warpcore_enable_AN_KR
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
else|else
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Setting KR 10G-Force\n"
argument_list|)
expr_stmt|;
name|elink_warpcore_set_10G_KR
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PORT_HW_CFG_NET_SERDES_IF_XFI
case|:
name|elink_warpcore_clear_regs
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|lane
argument_list|)
expr_stmt|;
if|if
condition|(
name|vars
operator|->
name|line_speed
operator|==
name|ELINK_SPEED_10000
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Setting 10G XFI\n"
argument_list|)
expr_stmt|;
name|elink_warpcore_set_10G_XFI
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ELINK_SINGLE_MEDIA_DIRECT
argument_list|(
name|params
argument_list|)
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"1G Fiber\n"
argument_list|)
expr_stmt|;
name|fiber_mode
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"10/100/1G SGMII\n"
argument_list|)
expr_stmt|;
name|fiber_mode
operator|=
literal|0
expr_stmt|;
block|}
name|elink_warpcore_set_sgmii_speed
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|fiber_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PORT_HW_CFG_NET_SERDES_IF_SFI
case|:
comment|/* Issue Module detection if module is plugged, or 			 * enabled transmitter to avoid current leakage in case 			 * no module is connected 			 */
if|if
condition|(
operator|(
name|params
operator|->
name|loopback_mode
operator|==
name|ELINK_LOOPBACK_NONE
operator|)
operator|||
operator|(
name|params
operator|->
name|loopback_mode
operator|==
name|ELINK_LOOPBACK_EXT
operator|)
condition|)
block|{
if|if
condition|(
name|elink_is_sfp_module_plugged
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
condition|)
name|elink_sfp_module_detection
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
expr_stmt|;
else|else
name|elink_sfp_e3_set_transmitter
argument_list|(
name|params
argument_list|,
name|phy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|elink_warpcore_config_sfi
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_NET_SERDES_IF_DXGXS
case|:
if|if
condition|(
name|vars
operator|->
name|line_speed
operator|!=
name|ELINK_SPEED_20000
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Speed not supported yet\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Setting 20G DXGXS\n"
argument_list|)
expr_stmt|;
name|elink_warpcore_set_20G_DXGXS
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|lane
argument_list|)
expr_stmt|;
comment|/* Issue Module detection */
name|elink_sfp_module_detection
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_NET_SERDES_IF_KR2
case|:
if|if
condition|(
operator|!
name|params
operator|->
name|loopback_mode
condition|)
block|{
name|elink_warpcore_enable_AN_KR
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Setting KR 20G-Force\n"
argument_list|)
expr_stmt|;
name|elink_warpcore_set_20G_force_KR2
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Unsupported Serdes Net Interface 0x%x\n"
argument_list|,
name|serdes_net_if
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Take lane out of reset after configuration is finished */
name|elink_warpcore_reset_lane
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Exit config init\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_warpcore_link_reset
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint16_t
name|val16
decl_stmt|,
name|lane
decl_stmt|;
name|elink_sfp_e3_set_transmitter
argument_list|(
name|params
argument_list|,
name|phy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|elink_set_mdio_emac_per_phy
argument_list|(
name|sc
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|elink_set_aer_mmd
argument_list|(
name|params
argument_list|,
name|phy
argument_list|)
expr_stmt|;
comment|/* Global register */
name|elink_warpcore_reset_lane
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Clear loopback settings (if any) */
comment|/* 10G& 20G */
name|elink_cl45_read_and_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_COMBO_IEEE0_MIICTRL
argument_list|,
literal|0xBFFF
argument_list|)
expr_stmt|;
name|elink_cl45_read_and_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_IEEE0BLK_MIICNTL
argument_list|,
literal|0xfffe
argument_list|)
expr_stmt|;
comment|/* Update those 1-copy registers */
name|CL22_WR_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_AER_BLOCK
argument_list|,
name|MDIO_AER_BLOCK_AER_REG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Enable 1G MDIO (1-copy) */
name|elink_cl45_read_and_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_XGXSBLK0_XGXSCONTROL
argument_list|,
operator|~
literal|0x10
argument_list|)
expr_stmt|;
name|elink_cl45_read_and_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_XGXSBLK1_LANECTRL2
argument_list|,
literal|0xff00
argument_list|)
expr_stmt|;
name|lane
operator|=
name|elink_get_warpcore_lane
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
expr_stmt|;
comment|/* Disable CL36 PCS Tx */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_XGXSBLK1_LANECTRL0
argument_list|,
operator|&
name|val16
argument_list|)
expr_stmt|;
name|val16
operator||=
operator|(
literal|0x11
operator|<<
name|lane
operator|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|flags
operator|&
name|ELINK_FLAGS_WC_DUAL_MODE
condition|)
name|val16
operator||=
operator|(
literal|0x22
operator|<<
name|lane
operator|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_XGXSBLK1_LANECTRL0
argument_list|,
name|val16
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_XGXSBLK1_LANECTRL1
argument_list|,
operator|&
name|val16
argument_list|)
expr_stmt|;
name|val16
operator|&=
operator|~
operator|(
literal|0x0303
operator|<<
operator|(
name|lane
operator|<<
literal|1
operator|)
operator|)
expr_stmt|;
name|val16
operator||=
operator|(
literal|0x0101
operator|<<
operator|(
name|lane
operator|<<
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|flags
operator|&
name|ELINK_FLAGS_WC_DUAL_MODE
condition|)
block|{
name|val16
operator|&=
operator|~
operator|(
literal|0x0c0c
operator|<<
operator|(
name|lane
operator|<<
literal|1
operator|)
operator|)
expr_stmt|;
name|val16
operator||=
operator|(
literal|0x0404
operator|<<
operator|(
name|lane
operator|<<
literal|1
operator|)
operator|)
expr_stmt|;
block|}
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_XGXSBLK1_LANECTRL1
argument_list|,
name|val16
argument_list|)
expr_stmt|;
comment|/* Restore AER */
name|elink_set_aer_mmd
argument_list|(
name|params
argument_list|,
name|phy
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_set_warpcore_loopback
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint16_t
name|val16
decl_stmt|;
name|uint32_t
name|lane
decl_stmt|;
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"Setting Warpcore loopback type %x, speed %d\n"
argument_list|,
name|params
operator|->
name|loopback_mode
argument_list|,
name|phy
operator|->
name|req_line_speed
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|req_line_speed
operator|<
name|ELINK_SPEED_10000
operator|||
name|phy
operator|->
name|supported
operator|&
name|ELINK_SUPPORTED_20000baseKR2_Full
condition|)
block|{
comment|/* 10/100/1000/20G-KR2 */
comment|/* Update those 1-copy registers */
name|CL22_WR_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_AER_BLOCK
argument_list|,
name|MDIO_AER_BLOCK_AER_REG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Enable 1G MDIO (1-copy) */
name|elink_cl45_read_or_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_XGXSBLK0_XGXSCONTROL
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
comment|/* Set 1G loopback based on lane (1-copy) */
name|lane
operator|=
name|elink_get_warpcore_lane
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_XGXSBLK1_LANECTRL2
argument_list|,
operator|&
name|val16
argument_list|)
expr_stmt|;
name|val16
operator||=
operator|(
literal|1
operator|<<
name|lane
operator|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|flags
operator|&
name|ELINK_FLAGS_WC_DUAL_MODE
condition|)
name|val16
operator||=
operator|(
literal|2
operator|<<
name|lane
operator|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_XGXSBLK1_LANECTRL2
argument_list|,
name|val16
argument_list|)
expr_stmt|;
comment|/* Switch back to 4-copy registers */
name|elink_set_aer_mmd
argument_list|(
name|params
argument_list|,
name|phy
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 10G / 20G-DXGXS */
name|elink_cl45_read_or_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_COMBO_IEEE0_MIICTRL
argument_list|,
literal|0x4000
argument_list|)
expr_stmt|;
name|elink_cl45_read_or_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_IEEE0BLK_MIICNTL
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|elink_sync_link
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint8_t
name|link_10g_plus
decl_stmt|;
if|if
condition|(
name|vars
operator|->
name|link_status
operator|&
name|LINK_STATUS_PHYSICAL_LINK_FLAG
condition|)
name|vars
operator|->
name|phy_flags
operator||=
name|PHY_PHYSICAL_LINK_FLAG
expr_stmt|;
name|vars
operator|->
name|link_up
operator|=
operator|(
name|vars
operator|->
name|link_status
operator|&
name|LINK_STATUS_LINK_UP
operator|)
expr_stmt|;
if|if
condition|(
name|vars
operator|->
name|link_up
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"phy link up\n"
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"link status = %x\n"
argument_list|,
name|vars
operator|->
name|link_status
argument_list|)
expr_stmt|;
name|vars
operator|->
name|phy_link_up
operator|=
literal|1
expr_stmt|;
name|vars
operator|->
name|duplex
operator|=
name|DUPLEX_FULL
expr_stmt|;
switch|switch
condition|(
name|vars
operator|->
name|link_status
operator|&
name|LINK_STATUS_SPEED_AND_DUPLEX_MASK
condition|)
block|{
case|case
name|ELINK_LINK_10THD
case|:
name|vars
operator|->
name|duplex
operator|=
name|DUPLEX_HALF
expr_stmt|;
comment|/* Fall thru */
case|case
name|ELINK_LINK_10TFD
case|:
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_10
expr_stmt|;
break|break;
case|case
name|ELINK_LINK_100TXHD
case|:
name|vars
operator|->
name|duplex
operator|=
name|DUPLEX_HALF
expr_stmt|;
comment|/* Fall thru */
case|case
name|ELINK_LINK_100T4
case|:
case|case
name|ELINK_LINK_100TXFD
case|:
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_100
expr_stmt|;
break|break;
case|case
name|ELINK_LINK_1000THD
case|:
name|vars
operator|->
name|duplex
operator|=
name|DUPLEX_HALF
expr_stmt|;
comment|/* Fall thru */
case|case
name|ELINK_LINK_1000TFD
case|:
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_1000
expr_stmt|;
break|break;
case|case
name|ELINK_LINK_2500THD
case|:
name|vars
operator|->
name|duplex
operator|=
name|DUPLEX_HALF
expr_stmt|;
comment|/* Fall thru */
case|case
name|ELINK_LINK_2500TFD
case|:
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_2500
expr_stmt|;
break|break;
case|case
name|ELINK_LINK_10GTFD
case|:
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_10000
expr_stmt|;
break|break;
case|case
name|ELINK_LINK_20GTFD
case|:
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_20000
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|vars
operator|->
name|flow_ctrl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vars
operator|->
name|link_status
operator|&
name|LINK_STATUS_TX_FLOW_CONTROL_ENABLED
condition|)
name|vars
operator|->
name|flow_ctrl
operator||=
name|ELINK_FLOW_CTRL_TX
expr_stmt|;
if|if
condition|(
name|vars
operator|->
name|link_status
operator|&
name|LINK_STATUS_RX_FLOW_CONTROL_ENABLED
condition|)
name|vars
operator|->
name|flow_ctrl
operator||=
name|ELINK_FLOW_CTRL_RX
expr_stmt|;
if|if
condition|(
operator|!
name|vars
operator|->
name|flow_ctrl
condition|)
name|vars
operator|->
name|flow_ctrl
operator|=
name|ELINK_FLOW_CTRL_NONE
expr_stmt|;
if|if
condition|(
name|vars
operator|->
name|line_speed
operator|&&
operator|(
operator|(
name|vars
operator|->
name|line_speed
operator|==
name|ELINK_SPEED_10
operator|)
operator|||
operator|(
name|vars
operator|->
name|line_speed
operator|==
name|ELINK_SPEED_100
operator|)
operator|)
condition|)
block|{
name|vars
operator|->
name|phy_flags
operator||=
name|PHY_SGMII_FLAG
expr_stmt|;
block|}
else|else
block|{
name|vars
operator|->
name|phy_flags
operator|&=
operator|~
name|PHY_SGMII_FLAG
expr_stmt|;
block|}
if|if
condition|(
name|vars
operator|->
name|line_speed
operator|&&
name|USES_WARPCORE
argument_list|(
name|sc
argument_list|)
operator|&&
operator|(
name|vars
operator|->
name|line_speed
operator|==
name|ELINK_SPEED_1000
operator|)
condition|)
name|vars
operator|->
name|phy_flags
operator||=
name|PHY_SGMII_FLAG
expr_stmt|;
comment|/* Anything 10 and over uses the bmac */
name|link_10g_plus
operator|=
operator|(
name|vars
operator|->
name|line_speed
operator|>=
name|ELINK_SPEED_10000
operator|)
expr_stmt|;
if|if
condition|(
name|link_10g_plus
condition|)
block|{
if|if
condition|(
name|USES_WARPCORE
argument_list|(
name|sc
argument_list|)
condition|)
name|vars
operator|->
name|mac_type
operator|=
name|ELINK_MAC_TYPE_XMAC
expr_stmt|;
else|else
name|vars
operator|->
name|mac_type
operator|=
name|ELINK_MAC_TYPE_BMAC
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|USES_WARPCORE
argument_list|(
name|sc
argument_list|)
condition|)
name|vars
operator|->
name|mac_type
operator|=
name|ELINK_MAC_TYPE_UMAC
expr_stmt|;
else|else
name|vars
operator|->
name|mac_type
operator|=
name|ELINK_MAC_TYPE_EMAC
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Link down */
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"phy link down\n"
argument_list|)
expr_stmt|;
name|vars
operator|->
name|phy_link_up
operator|=
literal|0
expr_stmt|;
name|vars
operator|->
name|line_speed
operator|=
literal|0
expr_stmt|;
name|vars
operator|->
name|duplex
operator|=
name|DUPLEX_FULL
expr_stmt|;
name|vars
operator|->
name|flow_ctrl
operator|=
name|ELINK_FLOW_CTRL_NONE
expr_stmt|;
comment|/* Indicate no mac active */
name|vars
operator|->
name|mac_type
operator|=
name|ELINK_MAC_TYPE_NONE
expr_stmt|;
if|if
condition|(
name|vars
operator|->
name|link_status
operator|&
name|LINK_STATUS_PHYSICAL_LINK_FLAG
condition|)
name|vars
operator|->
name|phy_flags
operator||=
name|PHY_HALF_OPEN_CONN_FLAG
expr_stmt|;
if|if
condition|(
name|vars
operator|->
name|link_status
operator|&
name|LINK_STATUS_SFP_TX_FAULT
condition|)
name|vars
operator|->
name|phy_flags
operator||=
name|PHY_SFP_TX_FAULT_FLAG
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|elink_link_status_update
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint8_t
name|port
init|=
name|params
operator|->
name|port
decl_stmt|;
name|uint32_t
name|sync_offset
decl_stmt|,
name|media_types
decl_stmt|;
comment|/* Update PHY configuration */
name|set_phy_vars
argument_list|(
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
name|vars
operator|->
name|link_status
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|port_mb
index|[
name|port
index|]
operator|.
name|link_status
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Force link UP in non LOOPBACK_EXT loopback mode(s) */
if|if
condition|(
name|params
operator|->
name|loopback_mode
operator|!=
name|ELINK_LOOPBACK_NONE
operator|&&
name|params
operator|->
name|loopback_mode
operator|!=
name|ELINK_LOOPBACK_EXT
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_LINK_UP
expr_stmt|;
if|if
condition|(
name|elink_eee_has_cap
argument_list|(
name|params
argument_list|)
condition|)
name|vars
operator|->
name|eee_status
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|shmem2_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem2_region
argument_list|,
name|eee_status
index|[
name|params
operator|->
name|port
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|vars
operator|->
name|phy_flags
operator|=
name|PHY_XGXS_FLAG
expr_stmt|;
name|elink_sync_link
argument_list|(
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
comment|/* Sync media type */
name|sync_offset
operator|=
name|params
operator|->
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|port
index|]
operator|.
name|media_type
argument_list|)
expr_stmt|;
name|media_types
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|sync_offset
argument_list|)
expr_stmt|;
name|params
operator|->
name|phy
index|[
name|ELINK_INT_PHY
index|]
operator|.
name|media_type
operator|=
operator|(
name|media_types
operator|&
name|PORT_HW_CFG_MEDIA_TYPE_PHY0_MASK
operator|)
operator|>>
name|PORT_HW_CFG_MEDIA_TYPE_PHY0_SHIFT
expr_stmt|;
name|params
operator|->
name|phy
index|[
name|ELINK_EXT_PHY1
index|]
operator|.
name|media_type
operator|=
operator|(
name|media_types
operator|&
name|PORT_HW_CFG_MEDIA_TYPE_PHY1_MASK
operator|)
operator|>>
name|PORT_HW_CFG_MEDIA_TYPE_PHY1_SHIFT
expr_stmt|;
name|params
operator|->
name|phy
index|[
name|ELINK_EXT_PHY2
index|]
operator|.
name|media_type
operator|=
operator|(
name|media_types
operator|&
name|PORT_HW_CFG_MEDIA_TYPE_PHY2_MASK
operator|)
operator|>>
name|PORT_HW_CFG_MEDIA_TYPE_PHY2_SHIFT
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"media_types = 0x%x\n"
argument_list|,
name|media_types
argument_list|)
expr_stmt|;
comment|/* Sync AEU offset */
name|sync_offset
operator|=
name|params
operator|->
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|port
index|]
operator|.
name|aeu_int_mask
argument_list|)
expr_stmt|;
name|vars
operator|->
name|aeu_int_mask
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|sync_offset
argument_list|)
expr_stmt|;
comment|/* Sync PFC status */
if|if
condition|(
name|vars
operator|->
name|link_status
operator|&
name|LINK_STATUS_PFC_ENABLED
condition|)
name|params
operator|->
name|feature_config_flags
operator||=
name|ELINK_FEATURE_CONFIG_PFC_ENABLED
expr_stmt|;
else|else
name|params
operator|->
name|feature_config_flags
operator|&=
operator|~
name|ELINK_FEATURE_CONFIG_PFC_ENABLED
expr_stmt|;
if|if
condition|(
name|SHMEM2_HAS
argument_list|(
name|sc
argument_list|,
name|link_attr_sync
argument_list|)
condition|)
name|params
operator|->
name|link_attr_sync
operator|=
name|SHMEM2_RD
argument_list|(
name|sc
argument_list|,
name|link_attr_sync
index|[
name|params
operator|->
name|port
index|]
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P3
argument_list|(
name|sc
argument_list|,
literal|"link_status 0x%x  phy_link_up %x int_mask 0x%x\n"
argument_list|,
name|vars
operator|->
name|link_status
argument_list|,
name|vars
operator|->
name|phy_link_up
argument_list|,
name|vars
operator|->
name|aeu_int_mask
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P3
argument_list|(
name|sc
argument_list|,
literal|"line_speed %x  duplex %x  flow_ctrl 0x%x\n"
argument_list|,
name|vars
operator|->
name|line_speed
argument_list|,
name|vars
operator|->
name|duplex
argument_list|,
name|vars
operator|->
name|flow_ctrl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_set_master_ln
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint16_t
name|new_master_ln
decl_stmt|,
name|ser_lane
decl_stmt|;
name|ser_lane
operator|=
operator|(
operator|(
name|params
operator|->
name|lane_config
operator|&
name|PORT_HW_CFG_LANE_SWAP_CFG_MASTER_MASK
operator|)
operator|>>
name|PORT_HW_CFG_LANE_SWAP_CFG_MASTER_SHIFT
operator|)
expr_stmt|;
comment|/* Set the master_ln for AN */
name|CL22_RD_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_XGXS_BLOCK2
argument_list|,
name|MDIO_XGXS_BLOCK2_TEST_MODE_LANE
argument_list|,
operator|&
name|new_master_ln
argument_list|)
expr_stmt|;
name|CL22_WR_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_XGXS_BLOCK2
argument_list|,
name|MDIO_XGXS_BLOCK2_TEST_MODE_LANE
argument_list|,
operator|(
name|new_master_ln
operator||
name|ser_lane
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_reset_unicore
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|uint8_t
name|set_serdes
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint16_t
name|mii_control
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
name|CL22_RD_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_COMBO_IEEE0
argument_list|,
name|MDIO_COMBO_IEEE0_MII_CONTROL
argument_list|,
operator|&
name|mii_control
argument_list|)
expr_stmt|;
comment|/* Reset the unicore */
name|CL22_WR_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_COMBO_IEEE0
argument_list|,
name|MDIO_COMBO_IEEE0_MII_CONTROL
argument_list|,
operator|(
name|mii_control
operator||
name|MDIO_COMBO_IEEO_MII_CONTROL_RESET
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_serdes
condition|)
name|elink_set_serdes_access
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|port
argument_list|)
expr_stmt|;
comment|/* Wait for the reset to self clear */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ELINK_MDIO_ACCESS_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
comment|/* The reset erased the previous bank value */
name|CL22_RD_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_COMBO_IEEE0
argument_list|,
name|MDIO_COMBO_IEEE0_MII_CONTROL
argument_list|,
operator|&
name|mii_control
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mii_control
operator|&
name|MDIO_COMBO_IEEO_MII_CONTROL_RESET
operator|)
condition|)
block|{
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
block|}
name|elink_cb_event_log
argument_list|(
name|sc
argument_list|,
name|ELINK_LOG_ID_PHY_UNINITIALIZED
argument_list|,
name|params
operator|->
name|port
argument_list|)
expr_stmt|;
comment|// "Warning: PHY was not initialized,"
comment|// " Port %d\n",
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"BUG! XGXS is still in reset!\n"
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_set_swap_lanes
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
comment|/* Each two bits represents a lane number: 	 * No swap is 0123 => 0x1b no need to enable the swap 	 */
name|uint16_t
name|rx_lane_swap
decl_stmt|,
name|tx_lane_swap
decl_stmt|;
name|rx_lane_swap
operator|=
operator|(
operator|(
name|params
operator|->
name|lane_config
operator|&
name|PORT_HW_CFG_LANE_SWAP_CFG_RX_MASK
operator|)
operator|>>
name|PORT_HW_CFG_LANE_SWAP_CFG_RX_SHIFT
operator|)
expr_stmt|;
name|tx_lane_swap
operator|=
operator|(
operator|(
name|params
operator|->
name|lane_config
operator|&
name|PORT_HW_CFG_LANE_SWAP_CFG_TX_MASK
operator|)
operator|>>
name|PORT_HW_CFG_LANE_SWAP_CFG_TX_SHIFT
operator|)
expr_stmt|;
if|if
condition|(
name|rx_lane_swap
operator|!=
literal|0x1b
condition|)
block|{
name|CL22_WR_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_XGXS_BLOCK2
argument_list|,
name|MDIO_XGXS_BLOCK2_RX_LN_SWAP
argument_list|,
operator|(
name|rx_lane_swap
operator||
name|MDIO_XGXS_BLOCK2_RX_LN_SWAP_ENABLE
operator||
name|MDIO_XGXS_BLOCK2_RX_LN_SWAP_FORCE_ENABLE
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CL22_WR_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_XGXS_BLOCK2
argument_list|,
name|MDIO_XGXS_BLOCK2_RX_LN_SWAP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tx_lane_swap
operator|!=
literal|0x1b
condition|)
block|{
name|CL22_WR_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_XGXS_BLOCK2
argument_list|,
name|MDIO_XGXS_BLOCK2_TX_LN_SWAP
argument_list|,
operator|(
name|tx_lane_swap
operator||
name|MDIO_XGXS_BLOCK2_TX_LN_SWAP_ENABLE
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CL22_WR_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_XGXS_BLOCK2
argument_list|,
name|MDIO_XGXS_BLOCK2_TX_LN_SWAP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|elink_set_parallel_detection
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint16_t
name|control2
decl_stmt|;
name|CL22_RD_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_SERDES_DIGITAL
argument_list|,
name|MDIO_SERDES_DIGITAL_A_1000X_CONTROL2
argument_list|,
operator|&
name|control2
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|speed_cap_mask
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_1G
condition|)
name|control2
operator||=
name|MDIO_SERDES_DIGITAL_A_1000X_CONTROL2_PRL_DT_EN
expr_stmt|;
else|else
name|control2
operator|&=
operator|~
name|MDIO_SERDES_DIGITAL_A_1000X_CONTROL2_PRL_DT_EN
expr_stmt|;
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"phy->speed_cap_mask = 0x%x, control2 = 0x%x\n"
argument_list|,
name|phy
operator|->
name|speed_cap_mask
argument_list|,
name|control2
argument_list|)
expr_stmt|;
name|CL22_WR_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_SERDES_DIGITAL
argument_list|,
name|MDIO_SERDES_DIGITAL_A_1000X_CONTROL2
argument_list|,
name|control2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|phy
operator|->
name|type
operator|==
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT
operator|)
operator|&&
operator|(
name|phy
operator|->
name|speed_cap_mask
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_10G
operator|)
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"XGXS\n"
argument_list|)
expr_stmt|;
name|CL22_WR_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_10G_PARALLEL_DETECT
argument_list|,
name|MDIO_10G_PARALLEL_DETECT_PAR_DET_10G_LINK
argument_list|,
name|MDIO_10G_PARALLEL_DETECT_PAR_DET_10G_LINK_CNT
argument_list|)
expr_stmt|;
name|CL22_RD_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_10G_PARALLEL_DETECT
argument_list|,
name|MDIO_10G_PARALLEL_DETECT_PAR_DET_10G_CONTROL
argument_list|,
operator|&
name|control2
argument_list|)
expr_stmt|;
name|control2
operator||=
name|MDIO_10G_PARALLEL_DETECT_PAR_DET_10G_CONTROL_PARDET10G_EN
expr_stmt|;
name|CL22_WR_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_10G_PARALLEL_DETECT
argument_list|,
name|MDIO_10G_PARALLEL_DETECT_PAR_DET_10G_CONTROL
argument_list|,
name|control2
argument_list|)
expr_stmt|;
comment|/* Disable parallel detection of HiG */
name|CL22_WR_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_XGXS_BLOCK2
argument_list|,
name|MDIO_XGXS_BLOCK2_UNICORE_MODE_10G
argument_list|,
name|MDIO_XGXS_BLOCK2_UNICORE_MODE_10G_CX4_XGXS
operator||
name|MDIO_XGXS_BLOCK2_UNICORE_MODE_10G_HIGIG_XGXS
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|elink_set_autoneg
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|,
name|uint8_t
name|enable_cl73
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint16_t
name|reg_val
decl_stmt|;
comment|/* CL37 Autoneg */
name|CL22_RD_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_COMBO_IEEE0
argument_list|,
name|MDIO_COMBO_IEEE0_MII_CONTROL
argument_list|,
operator|&
name|reg_val
argument_list|)
expr_stmt|;
comment|/* CL37 Autoneg Enabled */
if|if
condition|(
name|vars
operator|->
name|line_speed
operator|==
name|ELINK_SPEED_AUTO_NEG
condition|)
name|reg_val
operator||=
name|MDIO_COMBO_IEEO_MII_CONTROL_AN_EN
expr_stmt|;
else|else
comment|/* CL37 Autoneg Disabled */
name|reg_val
operator|&=
operator|~
operator|(
name|MDIO_COMBO_IEEO_MII_CONTROL_AN_EN
operator||
name|MDIO_COMBO_IEEO_MII_CONTROL_RESTART_AN
operator|)
expr_stmt|;
name|CL22_WR_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_COMBO_IEEE0
argument_list|,
name|MDIO_COMBO_IEEE0_MII_CONTROL
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
comment|/* Enable/Disable Autodetection */
name|CL22_RD_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_SERDES_DIGITAL
argument_list|,
name|MDIO_SERDES_DIGITAL_A_1000X_CONTROL1
argument_list|,
operator|&
name|reg_val
argument_list|)
expr_stmt|;
name|reg_val
operator|&=
operator|~
operator|(
name|MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_SIGNAL_DETECT_EN
operator||
name|MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_INVERT_SIGNAL_DETECT
operator|)
expr_stmt|;
name|reg_val
operator||=
name|MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_FIBER_MODE
expr_stmt|;
if|if
condition|(
name|vars
operator|->
name|line_speed
operator|==
name|ELINK_SPEED_AUTO_NEG
condition|)
name|reg_val
operator||=
name|MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_AUTODET
expr_stmt|;
else|else
name|reg_val
operator|&=
operator|~
name|MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_AUTODET
expr_stmt|;
name|CL22_WR_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_SERDES_DIGITAL
argument_list|,
name|MDIO_SERDES_DIGITAL_A_1000X_CONTROL1
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
comment|/* Enable TetonII and BAM autoneg */
name|CL22_RD_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_BAM_NEXT_PAGE
argument_list|,
name|MDIO_BAM_NEXT_PAGE_MP5_NEXT_PAGE_CTRL
argument_list|,
operator|&
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|vars
operator|->
name|line_speed
operator|==
name|ELINK_SPEED_AUTO_NEG
condition|)
block|{
comment|/* Enable BAM aneg Mode and TetonII aneg Mode */
name|reg_val
operator||=
operator|(
name|MDIO_BAM_NEXT_PAGE_MP5_NEXT_PAGE_CTRL_BAM_MODE
operator||
name|MDIO_BAM_NEXT_PAGE_MP5_NEXT_PAGE_CTRL_TETON_AN
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* TetonII and BAM Autoneg Disabled */
name|reg_val
operator|&=
operator|~
operator|(
name|MDIO_BAM_NEXT_PAGE_MP5_NEXT_PAGE_CTRL_BAM_MODE
operator||
name|MDIO_BAM_NEXT_PAGE_MP5_NEXT_PAGE_CTRL_TETON_AN
operator|)
expr_stmt|;
block|}
name|CL22_WR_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_BAM_NEXT_PAGE
argument_list|,
name|MDIO_BAM_NEXT_PAGE_MP5_NEXT_PAGE_CTRL
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable_cl73
condition|)
block|{
comment|/* Enable Cl73 FSM status bits */
name|CL22_WR_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_CL73_USERB0
argument_list|,
name|MDIO_CL73_USERB0_CL73_UCTRL
argument_list|,
literal|0xe
argument_list|)
expr_stmt|;
comment|/* Enable BAM Station Manager*/
name|CL22_WR_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_CL73_USERB0
argument_list|,
name|MDIO_CL73_USERB0_CL73_BAM_CTRL1
argument_list|,
name|MDIO_CL73_USERB0_CL73_BAM_CTRL1_BAM_EN
operator||
name|MDIO_CL73_USERB0_CL73_BAM_CTRL1_BAM_STATION_MNGR_EN
operator||
name|MDIO_CL73_USERB0_CL73_BAM_CTRL1_BAM_NP_AFTER_BP_EN
argument_list|)
expr_stmt|;
comment|/* Advertise CL73 link speeds */
name|CL22_RD_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_CL73_IEEEB1
argument_list|,
name|MDIO_CL73_IEEEB1_AN_ADV2
argument_list|,
operator|&
name|reg_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|speed_cap_mask
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_10G
condition|)
name|reg_val
operator||=
name|MDIO_CL73_IEEEB1_AN_ADV2_ADVR_10G_KX4
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|speed_cap_mask
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_1G
condition|)
name|reg_val
operator||=
name|MDIO_CL73_IEEEB1_AN_ADV2_ADVR_1000M_KX
expr_stmt|;
name|CL22_WR_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_CL73_IEEEB1
argument_list|,
name|MDIO_CL73_IEEEB1_AN_ADV2
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
comment|/* CL73 Autoneg Enabled */
name|reg_val
operator|=
name|MDIO_CL73_IEEEB0_CL73_AN_CONTROL_AN_EN
expr_stmt|;
block|}
else|else
comment|/* CL73 Autoneg Disabled */
name|reg_val
operator|=
literal|0
expr_stmt|;
name|CL22_WR_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_CL73_IEEEB0
argument_list|,
name|MDIO_CL73_IEEEB0_CL73_AN_CONTROL
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Program SerDes, forced speed */
end_comment

begin_function
specifier|static
name|void
name|elink_program_serdes
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint16_t
name|reg_val
decl_stmt|;
comment|/* Program duplex, disable autoneg and sgmii*/
name|CL22_RD_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_COMBO_IEEE0
argument_list|,
name|MDIO_COMBO_IEEE0_MII_CONTROL
argument_list|,
operator|&
name|reg_val
argument_list|)
expr_stmt|;
name|reg_val
operator|&=
operator|~
operator|(
name|MDIO_COMBO_IEEO_MII_CONTROL_FULL_DUPLEX
operator||
name|MDIO_COMBO_IEEO_MII_CONTROL_AN_EN
operator||
name|MDIO_COMBO_IEEO_MII_CONTROL_MAN_SGMII_SP_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|req_duplex
operator|==
name|DUPLEX_FULL
condition|)
name|reg_val
operator||=
name|MDIO_COMBO_IEEO_MII_CONTROL_FULL_DUPLEX
expr_stmt|;
name|CL22_WR_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_COMBO_IEEE0
argument_list|,
name|MDIO_COMBO_IEEE0_MII_CONTROL
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
comment|/* Program speed 	 *  - needed only if the speed is greater than 1G (2.5G or 10G) 	 */
name|CL22_RD_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_SERDES_DIGITAL
argument_list|,
name|MDIO_SERDES_DIGITAL_MISC1
argument_list|,
operator|&
name|reg_val
argument_list|)
expr_stmt|;
comment|/* Clearing the speed value before setting the right speed */
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"MDIO_REG_BANK_SERDES_DIGITAL = 0x%x\n"
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
name|reg_val
operator|&=
operator|~
operator|(
name|MDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_MASK
operator||
name|MDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_SEL
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|vars
operator|->
name|line_speed
operator|==
name|ELINK_SPEED_1000
operator|)
operator|||
operator|(
name|vars
operator|->
name|line_speed
operator|==
name|ELINK_SPEED_100
operator|)
operator|||
operator|(
name|vars
operator|->
name|line_speed
operator|==
name|ELINK_SPEED_10
operator|)
operator|)
condition|)
block|{
name|reg_val
operator||=
operator|(
name|MDIO_SERDES_DIGITAL_MISC1_REFCLK_SEL_156_25M
operator||
name|MDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_SEL
operator|)
expr_stmt|;
if|if
condition|(
name|vars
operator|->
name|line_speed
operator|==
name|ELINK_SPEED_10000
condition|)
name|reg_val
operator||=
name|MDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_10G_CX4
expr_stmt|;
block|}
name|CL22_WR_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_SERDES_DIGITAL
argument_list|,
name|MDIO_SERDES_DIGITAL_MISC1
argument_list|,
name|reg_val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_set_brcm_cl37_advertisement
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint16_t
name|val
init|=
literal|0
decl_stmt|;
comment|/* Set extended capabilities */
if|if
condition|(
name|phy
operator|->
name|speed_cap_mask
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_2_5G
condition|)
name|val
operator||=
name|MDIO_OVER_1G_UP1_2_5G
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|speed_cap_mask
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_10G
condition|)
name|val
operator||=
name|MDIO_OVER_1G_UP1_10G
expr_stmt|;
name|CL22_WR_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_OVER_1G
argument_list|,
name|MDIO_OVER_1G_UP1
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|CL22_WR_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_OVER_1G
argument_list|,
name|MDIO_OVER_1G_UP3
argument_list|,
literal|0x400
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_set_ieee_aneg_advertisement
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint16_t
name|ieee_fc
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint16_t
name|val
decl_stmt|;
comment|/* For AN, we are always publishing full duplex */
name|CL22_WR_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_COMBO_IEEE0
argument_list|,
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV
argument_list|,
name|ieee_fc
argument_list|)
expr_stmt|;
name|CL22_RD_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_CL73_IEEEB1
argument_list|,
name|MDIO_CL73_IEEEB1_AN_ADV1
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|MDIO_CL73_IEEEB1_AN_ADV1_PAUSE_BOTH
expr_stmt|;
name|val
operator||=
operator|(
operator|(
name|ieee_fc
operator|<<
literal|3
operator|)
operator|&
name|MDIO_CL73_IEEEB1_AN_ADV1_PAUSE_MASK
operator|)
expr_stmt|;
name|CL22_WR_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_CL73_IEEEB1
argument_list|,
name|MDIO_CL73_IEEEB1_AN_ADV1
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_restart_autoneg
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint8_t
name|enable_cl73
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint16_t
name|mii_control
decl_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"elink_restart_autoneg\n"
argument_list|)
expr_stmt|;
comment|/* Enable and restart BAM/CL37 aneg */
if|if
condition|(
name|enable_cl73
condition|)
block|{
name|CL22_RD_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_CL73_IEEEB0
argument_list|,
name|MDIO_CL73_IEEEB0_CL73_AN_CONTROL
argument_list|,
operator|&
name|mii_control
argument_list|)
expr_stmt|;
name|CL22_WR_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_CL73_IEEEB0
argument_list|,
name|MDIO_CL73_IEEEB0_CL73_AN_CONTROL
argument_list|,
operator|(
name|mii_control
operator||
name|MDIO_CL73_IEEEB0_CL73_AN_CONTROL_AN_EN
operator||
name|MDIO_CL73_IEEEB0_CL73_AN_CONTROL_RESTART_AN
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CL22_RD_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_COMBO_IEEE0
argument_list|,
name|MDIO_COMBO_IEEE0_MII_CONTROL
argument_list|,
operator|&
name|mii_control
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"elink_restart_autoneg mii_control before = 0x%x\n"
argument_list|,
name|mii_control
argument_list|)
expr_stmt|;
name|CL22_WR_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_COMBO_IEEE0
argument_list|,
name|MDIO_COMBO_IEEE0_MII_CONTROL
argument_list|,
operator|(
name|mii_control
operator||
name|MDIO_COMBO_IEEO_MII_CONTROL_AN_EN
operator||
name|MDIO_COMBO_IEEO_MII_CONTROL_RESTART_AN
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|elink_initialize_sgmii_process
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint16_t
name|control1
decl_stmt|;
comment|/* In SGMII mode, the unicore is always slave */
name|CL22_RD_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_SERDES_DIGITAL
argument_list|,
name|MDIO_SERDES_DIGITAL_A_1000X_CONTROL1
argument_list|,
operator|&
name|control1
argument_list|)
expr_stmt|;
name|control1
operator||=
name|MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_INVERT_SIGNAL_DETECT
expr_stmt|;
comment|/* Set sgmii mode (and not fiber) */
name|control1
operator|&=
operator|~
operator|(
name|MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_FIBER_MODE
operator||
name|MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_AUTODET
operator||
name|MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_MSTR_MODE
operator|)
expr_stmt|;
name|CL22_WR_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_SERDES_DIGITAL
argument_list|,
name|MDIO_SERDES_DIGITAL_A_1000X_CONTROL1
argument_list|,
name|control1
argument_list|)
expr_stmt|;
comment|/* If forced speed */
if|if
condition|(
operator|!
operator|(
name|vars
operator|->
name|line_speed
operator|==
name|ELINK_SPEED_AUTO_NEG
operator|)
condition|)
block|{
comment|/* Set speed, disable autoneg */
name|uint16_t
name|mii_control
decl_stmt|;
name|CL22_RD_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_COMBO_IEEE0
argument_list|,
name|MDIO_COMBO_IEEE0_MII_CONTROL
argument_list|,
operator|&
name|mii_control
argument_list|)
expr_stmt|;
name|mii_control
operator|&=
operator|~
operator|(
name|MDIO_COMBO_IEEO_MII_CONTROL_AN_EN
operator||
name|MDIO_COMBO_IEEO_MII_CONTROL_MAN_SGMII_SP_MASK
operator||
name|MDIO_COMBO_IEEO_MII_CONTROL_FULL_DUPLEX
operator|)
expr_stmt|;
switch|switch
condition|(
name|vars
operator|->
name|line_speed
condition|)
block|{
case|case
name|ELINK_SPEED_100
case|:
name|mii_control
operator||=
name|MDIO_COMBO_IEEO_MII_CONTROL_MAN_SGMII_SP_100
expr_stmt|;
break|break;
case|case
name|ELINK_SPEED_1000
case|:
name|mii_control
operator||=
name|MDIO_COMBO_IEEO_MII_CONTROL_MAN_SGMII_SP_1000
expr_stmt|;
break|break;
case|case
name|ELINK_SPEED_10
case|:
comment|/* There is nothing to set for 10M */
break|break;
default|default:
comment|/* Invalid speed for SGMII */
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Invalid line_speed 0x%x\n"
argument_list|,
name|vars
operator|->
name|line_speed
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Setting the full duplex */
if|if
condition|(
name|phy
operator|->
name|req_duplex
operator|==
name|DUPLEX_FULL
condition|)
name|mii_control
operator||=
name|MDIO_COMBO_IEEO_MII_CONTROL_FULL_DUPLEX
expr_stmt|;
name|CL22_WR_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_COMBO_IEEE0
argument_list|,
name|MDIO_COMBO_IEEE0_MII_CONTROL
argument_list|,
name|mii_control
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* AN mode */
comment|/* Enable and restart AN */
name|elink_restart_autoneg
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Link management  */
end_comment

begin_function
specifier|static
name|elink_status_t
name|elink_direct_parallel_detect_used
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint16_t
name|pd_10g
decl_stmt|,
name|status2_1000x
decl_stmt|;
if|if
condition|(
name|phy
operator|->
name|req_line_speed
operator|!=
name|ELINK_SPEED_AUTO_NEG
condition|)
return|return
name|ELINK_STATUS_OK
return|;
name|CL22_RD_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_SERDES_DIGITAL
argument_list|,
name|MDIO_SERDES_DIGITAL_A_1000X_STATUS2
argument_list|,
operator|&
name|status2_1000x
argument_list|)
expr_stmt|;
name|CL22_RD_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_SERDES_DIGITAL
argument_list|,
name|MDIO_SERDES_DIGITAL_A_1000X_STATUS2
argument_list|,
operator|&
name|status2_1000x
argument_list|)
expr_stmt|;
if|if
condition|(
name|status2_1000x
operator|&
name|MDIO_SERDES_DIGITAL_A_1000X_STATUS2_AN_DISABLED
condition|)
block|{
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"1G parallel detect link on port %d\n"
argument_list|,
name|params
operator|->
name|port
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|CL22_RD_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_10G_PARALLEL_DETECT
argument_list|,
name|MDIO_10G_PARALLEL_DETECT_PAR_DET_10G_STATUS
argument_list|,
operator|&
name|pd_10g
argument_list|)
expr_stmt|;
if|if
condition|(
name|pd_10g
operator|&
name|MDIO_10G_PARALLEL_DETECT_PAR_DET_10G_STATUS_PD_LINK
condition|)
block|{
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"10G parallel detect link on port %d\n"
argument_list|,
name|params
operator|->
name|port
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_update_adv_fc
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|,
name|uint32_t
name|gp_status
parameter_list|)
block|{
name|uint16_t
name|ld_pause
decl_stmt|;
comment|/* local driver */
name|uint16_t
name|lp_pause
decl_stmt|;
comment|/* link partner */
name|uint16_t
name|pause_result
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
if|if
condition|(
operator|(
name|gp_status
operator|&
operator|(
name|MDIO_GP_STATUS_TOP_AN_STATUS1_CL73_AUTONEG_COMPLETE
operator||
name|MDIO_GP_STATUS_TOP_AN_STATUS1_CL73_MR_LP_NP_AN_ABLE
operator|)
operator|)
operator|==
operator|(
name|MDIO_GP_STATUS_TOP_AN_STATUS1_CL73_AUTONEG_COMPLETE
operator||
name|MDIO_GP_STATUS_TOP_AN_STATUS1_CL73_MR_LP_NP_AN_ABLE
operator|)
condition|)
block|{
name|CL22_RD_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_CL73_IEEEB1
argument_list|,
name|MDIO_CL73_IEEEB1_AN_ADV1
argument_list|,
operator|&
name|ld_pause
argument_list|)
expr_stmt|;
name|CL22_RD_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_CL73_IEEEB1
argument_list|,
name|MDIO_CL73_IEEEB1_AN_LP_ADV1
argument_list|,
operator|&
name|lp_pause
argument_list|)
expr_stmt|;
name|pause_result
operator|=
operator|(
name|ld_pause
operator|&
name|MDIO_CL73_IEEEB1_AN_ADV1_PAUSE_MASK
operator|)
operator|>>
literal|8
expr_stmt|;
name|pause_result
operator||=
operator|(
name|lp_pause
operator|&
name|MDIO_CL73_IEEEB1_AN_LP_ADV1_PAUSE_MASK
operator|)
operator|>>
literal|10
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"pause_result CL73 0x%x\n"
argument_list|,
name|pause_result
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CL22_RD_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_COMBO_IEEE0
argument_list|,
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV
argument_list|,
operator|&
name|ld_pause
argument_list|)
expr_stmt|;
name|CL22_RD_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_COMBO_IEEE0
argument_list|,
name|MDIO_COMBO_IEEE0_AUTO_NEG_LINK_PARTNER_ABILITY1
argument_list|,
operator|&
name|lp_pause
argument_list|)
expr_stmt|;
name|pause_result
operator|=
operator|(
name|ld_pause
operator|&
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_MASK
operator|)
operator|>>
literal|5
expr_stmt|;
name|pause_result
operator||=
operator|(
name|lp_pause
operator|&
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_MASK
operator|)
operator|>>
literal|7
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"pause_result CL37 0x%x\n"
argument_list|,
name|pause_result
argument_list|)
expr_stmt|;
block|}
name|elink_pause_resolve
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|,
name|pause_result
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_flow_ctrl_resolve
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|,
name|uint32_t
name|gp_status
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|vars
operator|->
name|flow_ctrl
operator|=
name|ELINK_FLOW_CTRL_NONE
expr_stmt|;
comment|/* Resolve from gp_status in case of AN complete and not sgmii */
if|if
condition|(
name|phy
operator|->
name|req_flow_ctrl
operator|!=
name|ELINK_FLOW_CTRL_AUTO
condition|)
block|{
comment|/* Update the advertised flow-controled of LD/LP in AN */
if|if
condition|(
name|phy
operator|->
name|req_line_speed
operator|==
name|ELINK_SPEED_AUTO_NEG
condition|)
name|elink_update_adv_fc
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|,
name|gp_status
argument_list|)
expr_stmt|;
comment|/* But set the flow-control result as the requested one */
name|vars
operator|->
name|flow_ctrl
operator|=
name|phy
operator|->
name|req_flow_ctrl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|phy
operator|->
name|req_line_speed
operator|!=
name|ELINK_SPEED_AUTO_NEG
condition|)
name|vars
operator|->
name|flow_ctrl
operator|=
name|params
operator|->
name|req_fc_auto_adv
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|gp_status
operator|&
name|ELINK_MDIO_AN_CL73_OR_37_COMPLETE
operator|)
operator|&&
operator|(
operator|!
operator|(
name|vars
operator|->
name|phy_flags
operator|&
name|PHY_SGMII_FLAG
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|elink_direct_parallel_detect_used
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
condition|)
block|{
name|vars
operator|->
name|flow_ctrl
operator|=
name|params
operator|->
name|req_fc_auto_adv
expr_stmt|;
return|return;
block|}
name|elink_update_adv_fc
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|,
name|gp_status
argument_list|)
expr_stmt|;
block|}
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"flow_ctrl 0x%x\n"
argument_list|,
name|vars
operator|->
name|flow_ctrl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_check_fallback_to_cl37
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint16_t
name|rx_status
decl_stmt|,
name|ustat_val
decl_stmt|,
name|cl37_fsm_received
decl_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"elink_check_fallback_to_cl37\n"
argument_list|)
expr_stmt|;
comment|/* Step 1: Make sure signal is detected */
name|CL22_RD_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_RX0
argument_list|,
name|MDIO_RX0_RX_STATUS
argument_list|,
operator|&
name|rx_status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rx_status
operator|&
name|MDIO_RX0_RX_STATUS_SIGDET
operator|)
operator|!=
operator|(
name|MDIO_RX0_RX_STATUS_SIGDET
operator|)
condition|)
block|{
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Signal is not detected. Restoring CL73."
literal|"rx_status(0x80b0) = 0x%x\n"
argument_list|,
name|rx_status
argument_list|)
expr_stmt|;
name|CL22_WR_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_CL73_IEEEB0
argument_list|,
name|MDIO_CL73_IEEEB0_CL73_AN_CONTROL
argument_list|,
name|MDIO_CL73_IEEEB0_CL73_AN_CONTROL_AN_EN
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Step 2: Check CL73 state machine */
name|CL22_RD_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_CL73_USERB0
argument_list|,
name|MDIO_CL73_USERB0_CL73_USTAT1
argument_list|,
operator|&
name|ustat_val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ustat_val
operator|&
operator|(
name|MDIO_CL73_USERB0_CL73_USTAT1_LINK_STATUS_CHECK
operator||
name|MDIO_CL73_USERB0_CL73_USTAT1_AN_GOOD_CHECK_BAM37
operator|)
operator|)
operator|!=
operator|(
name|MDIO_CL73_USERB0_CL73_USTAT1_LINK_STATUS_CHECK
operator||
name|MDIO_CL73_USERB0_CL73_USTAT1_AN_GOOD_CHECK_BAM37
operator|)
condition|)
block|{
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"CL73 state-machine is not stable. "
literal|"ustat_val(0x8371) = 0x%x\n"
argument_list|,
name|ustat_val
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Step 3: Check CL37 Message Pages received to indicate LP 	 * supports only CL37 	 */
name|CL22_RD_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_REMOTE_PHY
argument_list|,
name|MDIO_REMOTE_PHY_MISC_RX_STATUS
argument_list|,
operator|&
name|cl37_fsm_received
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cl37_fsm_received
operator|&
operator|(
name|MDIO_REMOTE_PHY_MISC_RX_STATUS_CL37_FSM_RECEIVED_OVER1G_MSG
operator||
name|MDIO_REMOTE_PHY_MISC_RX_STATUS_CL37_FSM_RECEIVED_BRCM_OUI_MSG
operator|)
operator|)
operator|!=
operator|(
name|MDIO_REMOTE_PHY_MISC_RX_STATUS_CL37_FSM_RECEIVED_OVER1G_MSG
operator||
name|MDIO_REMOTE_PHY_MISC_RX_STATUS_CL37_FSM_RECEIVED_BRCM_OUI_MSG
operator|)
condition|)
block|{
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"No CL37 FSM were received. "
literal|"misc_rx_status(0x8330) = 0x%x\n"
argument_list|,
name|cl37_fsm_received
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* The combined cl37/cl73 fsm state information indicating that 	 * we are connected to a device which does not support cl73, but 	 * does support cl37 BAM. In this case we disable cl73 and 	 * restart cl37 auto-neg 	 */
comment|/* Disable CL73 */
name|CL22_WR_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_CL73_IEEEB0
argument_list|,
name|MDIO_CL73_IEEEB0_CL73_AN_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Restart CL37 autoneg */
name|elink_restart_autoneg
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Disabling CL73, and restarting CL37 autoneg\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_xgxs_an_resolve
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|,
name|uint32_t
name|gp_status
parameter_list|)
block|{
if|if
condition|(
name|gp_status
operator|&
name|ELINK_MDIO_AN_CL73_OR_37_COMPLETE
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_AUTO_NEGOTIATE_COMPLETE
expr_stmt|;
if|if
condition|(
name|elink_direct_parallel_detect_used
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_PARALLEL_DETECTION_USED
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_get_link_speed_duplex
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|,
name|uint16_t
name|is_link_up
parameter_list|,
name|uint16_t
name|speed_mask
parameter_list|,
name|uint16_t
name|is_duplex
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
if|if
condition|(
name|phy
operator|->
name|req_line_speed
operator|==
name|ELINK_SPEED_AUTO_NEG
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_AUTO_NEGOTIATE_ENABLED
expr_stmt|;
if|if
condition|(
name|is_link_up
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"phy link up\n"
argument_list|)
expr_stmt|;
name|vars
operator|->
name|phy_link_up
operator|=
literal|1
expr_stmt|;
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_LINK_UP
expr_stmt|;
switch|switch
condition|(
name|speed_mask
condition|)
block|{
case|case
name|ELINK_GP_STATUS_10M
case|:
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_10
expr_stmt|;
if|if
condition|(
name|is_duplex
operator|==
name|DUPLEX_FULL
condition|)
name|vars
operator|->
name|link_status
operator||=
name|ELINK_LINK_10TFD
expr_stmt|;
else|else
name|vars
operator|->
name|link_status
operator||=
name|ELINK_LINK_10THD
expr_stmt|;
break|break;
case|case
name|ELINK_GP_STATUS_100M
case|:
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_100
expr_stmt|;
if|if
condition|(
name|is_duplex
operator|==
name|DUPLEX_FULL
condition|)
name|vars
operator|->
name|link_status
operator||=
name|ELINK_LINK_100TXFD
expr_stmt|;
else|else
name|vars
operator|->
name|link_status
operator||=
name|ELINK_LINK_100TXHD
expr_stmt|;
break|break;
case|case
name|ELINK_GP_STATUS_1G
case|:
case|case
name|ELINK_GP_STATUS_1G_KX
case|:
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_1000
expr_stmt|;
if|if
condition|(
name|is_duplex
operator|==
name|DUPLEX_FULL
condition|)
name|vars
operator|->
name|link_status
operator||=
name|ELINK_LINK_1000TFD
expr_stmt|;
else|else
name|vars
operator|->
name|link_status
operator||=
name|ELINK_LINK_1000THD
expr_stmt|;
break|break;
case|case
name|ELINK_GP_STATUS_2_5G
case|:
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_2500
expr_stmt|;
if|if
condition|(
name|is_duplex
operator|==
name|DUPLEX_FULL
condition|)
name|vars
operator|->
name|link_status
operator||=
name|ELINK_LINK_2500TFD
expr_stmt|;
else|else
name|vars
operator|->
name|link_status
operator||=
name|ELINK_LINK_2500THD
expr_stmt|;
break|break;
case|case
name|ELINK_GP_STATUS_5G
case|:
case|case
name|ELINK_GP_STATUS_6G
case|:
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"link speed unsupported  gp_status 0x%x\n"
argument_list|,
name|speed_mask
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
case|case
name|ELINK_GP_STATUS_10G_KX4
case|:
case|case
name|ELINK_GP_STATUS_10G_HIG
case|:
case|case
name|ELINK_GP_STATUS_10G_CX4
case|:
case|case
name|ELINK_GP_STATUS_10G_KR
case|:
case|case
name|ELINK_GP_STATUS_10G_SFI
case|:
case|case
name|ELINK_GP_STATUS_10G_XFI
case|:
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_10000
expr_stmt|;
name|vars
operator|->
name|link_status
operator||=
name|ELINK_LINK_10GTFD
expr_stmt|;
break|break;
case|case
name|ELINK_GP_STATUS_20G_DXGXS
case|:
case|case
name|ELINK_GP_STATUS_20G_KR2
case|:
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_20000
expr_stmt|;
name|vars
operator|->
name|link_status
operator||=
name|ELINK_LINK_20GTFD
expr_stmt|;
break|break;
default|default:
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"link speed unsupported gp_status 0x%x\n"
argument_list|,
name|speed_mask
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
block|}
else|else
block|{
comment|/* link_down */
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"phy link down\n"
argument_list|)
expr_stmt|;
name|vars
operator|->
name|phy_link_up
operator|=
literal|0
expr_stmt|;
name|vars
operator|->
name|duplex
operator|=
name|DUPLEX_FULL
expr_stmt|;
name|vars
operator|->
name|flow_ctrl
operator|=
name|ELINK_FLOW_CTRL_NONE
expr_stmt|;
name|vars
operator|->
name|mac_type
operator|=
name|ELINK_MAC_TYPE_NONE
expr_stmt|;
block|}
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|" in elink_get_link_speed_duplex vars->link_status = %x, vars->duplex = %x\n"
argument_list|,
name|vars
operator|->
name|link_status
argument_list|,
name|vars
operator|->
name|duplex
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|" phy_link_up %x line_speed %d\n"
argument_list|,
name|vars
operator|->
name|phy_link_up
argument_list|,
name|vars
operator|->
name|line_speed
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_link_settings_status
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint16_t
name|gp_status
decl_stmt|,
name|duplex
init|=
name|DUPLEX_HALF
decl_stmt|,
name|link_up
init|=
literal|0
decl_stmt|,
name|speed_mask
decl_stmt|;
name|elink_status_t
name|rc
init|=
name|ELINK_STATUS_OK
decl_stmt|;
comment|/* Read gp_status */
name|CL22_RD_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_GP_STATUS
argument_list|,
name|MDIO_GP_STATUS_TOP_AN_STATUS1
argument_list|,
operator|&
name|gp_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|gp_status
operator|&
name|MDIO_GP_STATUS_TOP_AN_STATUS1_DUPLEX_STATUS
condition|)
block|{
name|duplex
operator|=
name|DUPLEX_FULL
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"duplex status read from phy is = %x\n"
argument_list|,
name|duplex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"phy status does not allow interface to be FULL_DUPLEX : %x\n"
argument_list|,
name|gp_status
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gp_status
operator|&
name|MDIO_GP_STATUS_TOP_AN_STATUS1_LINK_STATUS
condition|)
name|link_up
operator|=
literal|1
expr_stmt|;
name|speed_mask
operator|=
name|gp_status
operator|&
name|ELINK_GP_STATUS_SPEED_MASK
expr_stmt|;
name|ELINK_DEBUG_P3
argument_list|(
name|sc
argument_list|,
literal|"gp_status 0x%x, is_link_up %d, speed_mask 0x%x\n"
argument_list|,
name|gp_status
argument_list|,
name|link_up
argument_list|,
name|speed_mask
argument_list|)
expr_stmt|;
name|rc
operator|=
name|elink_get_link_speed_duplex
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|,
name|link_up
argument_list|,
name|speed_mask
argument_list|,
name|duplex
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|ELINK_STATUS_ERROR
condition|)
return|return
name|rc
return|;
if|if
condition|(
name|gp_status
operator|&
name|MDIO_GP_STATUS_TOP_AN_STATUS1_LINK_STATUS
condition|)
block|{
if|if
condition|(
name|ELINK_SINGLE_MEDIA_DIRECT
argument_list|(
name|params
argument_list|)
condition|)
block|{
name|vars
operator|->
name|duplex
operator|=
name|duplex
expr_stmt|;
name|elink_flow_ctrl_resolve
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|,
name|gp_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|req_line_speed
operator|==
name|ELINK_SPEED_AUTO_NEG
condition|)
name|elink_xgxs_an_resolve
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|,
name|gp_status
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Link_down */
if|if
condition|(
operator|(
name|phy
operator|->
name|req_line_speed
operator|==
name|ELINK_SPEED_AUTO_NEG
operator|)
operator|&&
name|ELINK_SINGLE_MEDIA_DIRECT
argument_list|(
name|params
argument_list|)
condition|)
block|{
comment|/* Check signal is detected */
name|elink_check_fallback_to_cl37
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Read LP advertised speeds*/
if|if
condition|(
name|ELINK_SINGLE_MEDIA_DIRECT
argument_list|(
name|params
argument_list|)
operator|&&
operator|(
name|vars
operator|->
name|link_status
operator|&
name|LINK_STATUS_AUTO_NEGOTIATE_COMPLETE
operator|)
condition|)
block|{
name|uint16_t
name|val
decl_stmt|;
name|CL22_RD_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_CL73_IEEEB1
argument_list|,
name|MDIO_CL73_IEEEB1_AN_LP_ADV2
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|MDIO_CL73_IEEEB1_AN_ADV2_ADVR_1000M_KX
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_LINK_PARTNER_1000TFD_CAPABLE
expr_stmt|;
if|if
condition|(
name|val
operator|&
operator|(
name|MDIO_CL73_IEEEB1_AN_ADV2_ADVR_10G_KX4
operator||
name|MDIO_CL73_IEEEB1_AN_ADV2_ADVR_10G_KR
operator|)
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_LINK_PARTNER_10GXFD_CAPABLE
expr_stmt|;
name|CL22_RD_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_OVER_1G
argument_list|,
name|MDIO_OVER_1G_LP_UP1
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|MDIO_OVER_1G_UP1_2_5G
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_LINK_PARTNER_2500XFD_CAPABLE
expr_stmt|;
if|if
condition|(
name|val
operator|&
operator|(
name|MDIO_OVER_1G_UP1_10G
operator||
name|MDIO_OVER_1G_UP1_10GH
operator|)
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_LINK_PARTNER_10GXFD_CAPABLE
expr_stmt|;
block|}
name|ELINK_DEBUG_P3
argument_list|(
name|sc
argument_list|,
literal|"duplex %x  flow_ctrl 0x%x link_status 0x%x\n"
argument_list|,
name|vars
operator|->
name|duplex
argument_list|,
name|vars
operator|->
name|flow_ctrl
argument_list|,
name|vars
operator|->
name|link_status
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_warpcore_read_status
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint8_t
name|lane
decl_stmt|;
name|uint16_t
name|gp_status1
decl_stmt|,
name|gp_speed
decl_stmt|,
name|link_up
decl_stmt|,
name|duplex
init|=
name|DUPLEX_FULL
decl_stmt|;
name|elink_status_t
name|rc
init|=
name|ELINK_STATUS_OK
decl_stmt|;
name|lane
operator|=
name|elink_get_warpcore_lane
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
expr_stmt|;
comment|/* Read gp_status */
if|if
condition|(
operator|(
name|params
operator|->
name|loopback_mode
operator|)
operator|&&
operator|(
name|phy
operator|->
name|flags
operator|&
name|ELINK_FLAGS_WC_DUAL_MODE
operator|)
condition|)
block|{
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_DIGITAL5_LINK_STATUS
argument_list|,
operator|&
name|link_up
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_DIGITAL5_LINK_STATUS
argument_list|,
operator|&
name|link_up
argument_list|)
expr_stmt|;
name|link_up
operator|&=
literal|0x1
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"params->loopback_mode link_up read = %x\n"
argument_list|,
name|link_up
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|phy
operator|->
name|req_line_speed
operator|>
name|ELINK_SPEED_10000
operator|)
operator|&&
operator|(
name|phy
operator|->
name|supported
operator|&
name|ELINK_SUPPORTED_20000baseMLD2_Full
operator|)
condition|)
block|{
name|uint16_t
name|temp_link_up
decl_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
literal|1
argument_list|,
operator|&
name|temp_link_up
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
literal|1
argument_list|,
operator|&
name|link_up
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"PCS RX link status = 0x%x-->0x%x\n"
argument_list|,
name|temp_link_up
argument_list|,
name|link_up
argument_list|)
expr_stmt|;
name|link_up
operator|&=
operator|(
literal|1
operator|<<
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|link_up
condition|)
name|elink_ext_phy_resolve_fc
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_GP2_STATUS_GP_2_1
argument_list|,
operator|&
name|gp_status1
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"0x81d1 = 0x%x\n"
argument_list|,
name|gp_status1
argument_list|)
expr_stmt|;
comment|/* Check for either KR, 1G, or AN up. */
name|link_up
operator|=
operator|(
operator|(
name|gp_status1
operator|>>
literal|8
operator|)
operator||
operator|(
name|gp_status1
operator|>>
literal|12
operator|)
operator||
operator|(
name|gp_status1
operator|)
operator|)
operator|&
operator|(
literal|1
operator|<<
name|lane
operator|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|supported
operator|&
name|ELINK_SUPPORTED_20000baseKR2_Full
condition|)
block|{
name|uint16_t
name|an_link
decl_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_STATUS
argument_list|,
operator|&
name|an_link
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_STATUS
argument_list|,
operator|&
name|an_link
argument_list|)
expr_stmt|;
name|link_up
operator||=
operator|(
name|an_link
operator|&
operator|(
literal|1
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"an_link = %x, link_up = %x\n"
argument_list|,
name|an_link
argument_list|,
name|link_up
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|link_up
operator|&&
name|ELINK_SINGLE_MEDIA_DIRECT
argument_list|(
name|params
argument_list|)
condition|)
block|{
name|uint16_t
name|pd
decl_stmt|,
name|gp_status4
decl_stmt|;
if|if
condition|(
name|phy
operator|->
name|req_line_speed
operator|==
name|ELINK_SPEED_AUTO_NEG
condition|)
block|{
comment|/* Check Autoneg complete */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_GP2_STATUS_GP_2_4
argument_list|,
operator|&
name|gp_status4
argument_list|)
expr_stmt|;
if|if
condition|(
name|gp_status4
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|12
operator|)
operator|<<
name|lane
operator|)
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_AUTO_NEGOTIATE_COMPLETE
expr_stmt|;
comment|/* Check parallel detect used */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_PAR_DET_10G_STATUS
argument_list|,
operator|&
name|pd
argument_list|)
expr_stmt|;
if|if
condition|(
name|pd
operator|&
operator|(
literal|1
operator|<<
literal|15
operator|)
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_PARALLEL_DETECTION_USED
expr_stmt|;
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"pd = %x, link_status = %x\n"
argument_list|,
name|pd
argument_list|,
name|vars
operator|->
name|link_status
argument_list|)
expr_stmt|;
block|}
name|elink_ext_phy_resolve_fc
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
name|vars
operator|->
name|duplex
operator|=
name|duplex
expr_stmt|;
name|ELINK_DEBUG_P3
argument_list|(
name|sc
argument_list|,
literal|" ELINK_SINGLE_MEDIA_DIRECT duplex %x  flow_ctrl 0x%x link_status 0x%x\n"
argument_list|,
name|vars
operator|->
name|duplex
argument_list|,
name|vars
operator|->
name|flow_ctrl
argument_list|,
name|vars
operator|->
name|link_status
argument_list|)
expr_stmt|;
block|}
block|}
name|ELINK_DEBUG_P3
argument_list|(
name|sc
argument_list|,
literal|"duplex %x  flow_ctrl 0x%x link_status 0x%x\n"
argument_list|,
name|vars
operator|->
name|duplex
argument_list|,
name|vars
operator|->
name|flow_ctrl
argument_list|,
name|vars
operator|->
name|link_status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vars
operator|->
name|link_status
operator|&
name|LINK_STATUS_AUTO_NEGOTIATE_COMPLETE
operator|)
operator|&&
name|ELINK_SINGLE_MEDIA_DIRECT
argument_list|(
name|params
argument_list|)
condition|)
block|{
name|uint16_t
name|val
decl_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_LP_AUTO_NEG2
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|MDIO_CL73_IEEEB1_AN_ADV2_ADVR_1000M_KX
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_LINK_PARTNER_1000TFD_CAPABLE
expr_stmt|;
if|if
condition|(
name|val
operator|&
operator|(
name|MDIO_CL73_IEEEB1_AN_ADV2_ADVR_10G_KX4
operator||
name|MDIO_CL73_IEEEB1_AN_ADV2_ADVR_10G_KR
operator|)
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_LINK_PARTNER_10GXFD_CAPABLE
expr_stmt|;
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"val = %x, link_status = %x\n"
argument_list|,
name|val
argument_list|,
name|vars
operator|->
name|link_status
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_DIGITAL3_LP_UP1
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|MDIO_OVER_1G_UP1_2_5G
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_LINK_PARTNER_2500XFD_CAPABLE
expr_stmt|;
if|if
condition|(
name|val
operator|&
operator|(
name|MDIO_OVER_1G_UP1_10G
operator||
name|MDIO_OVER_1G_UP1_10GH
operator|)
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_LINK_PARTNER_10GXFD_CAPABLE
expr_stmt|;
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"val = %x, link_status = %x\n"
argument_list|,
name|val
argument_list|,
name|vars
operator|->
name|link_status
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lane
operator|<
literal|2
condition|)
block|{
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_GP2_STATUS_GP_2_2
argument_list|,
operator|&
name|gp_speed
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_GP2_STATUS_GP_2_3
argument_list|,
operator|&
name|gp_speed
argument_list|)
expr_stmt|;
block|}
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"lane %d gp_speed 0x%x\n"
argument_list|,
name|lane
argument_list|,
name|gp_speed
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lane
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|gp_speed
operator|<<=
literal|8
expr_stmt|;
name|gp_speed
operator|&=
literal|0x3f00
expr_stmt|;
name|link_up
operator|=
operator|!
operator|!
name|link_up
expr_stmt|;
comment|/* Reset the TX FIFO to fix SGMII issue */
name|rc
operator|=
name|elink_get_link_speed_duplex
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|,
name|link_up
argument_list|,
name|gp_speed
argument_list|,
name|duplex
argument_list|)
expr_stmt|;
comment|/* In case of KR link down, start up the recovering procedure */
if|if
condition|(
operator|(
operator|!
name|link_up
operator|)
operator|&&
operator|(
name|phy
operator|->
name|media_type
operator|==
name|ELINK_ETH_PHY_KR
operator|)
operator|&&
operator|(
operator|!
operator|(
name|phy
operator|->
name|flags
operator|&
name|ELINK_FLAGS_WC_DUAL_MODE
operator|)
operator|)
condition|)
name|vars
operator|->
name|rx_tx_asic_rst
operator|=
name|MAX_KR_LINK_RETRY
expr_stmt|;
name|ELINK_DEBUG_P3
argument_list|(
name|sc
argument_list|,
literal|"duplex %x  flow_ctrl 0x%x link_status 0x%x\n"
argument_list|,
name|vars
operator|->
name|duplex
argument_list|,
name|vars
operator|->
name|flow_ctrl
argument_list|,
name|vars
operator|->
name|link_status
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_set_gmii_tx_driver
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|struct
name|elink_phy
modifier|*
name|phy
init|=
operator|&
name|params
operator|->
name|phy
index|[
name|ELINK_INT_PHY
index|]
decl_stmt|;
name|uint16_t
name|lp_up2
decl_stmt|;
name|uint16_t
name|tx_driver
decl_stmt|;
name|uint16_t
name|bank
decl_stmt|;
comment|/* Read precomp */
name|CL22_RD_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_OVER_1G
argument_list|,
name|MDIO_OVER_1G_LP_UP2
argument_list|,
operator|&
name|lp_up2
argument_list|)
expr_stmt|;
comment|/* Bits [10:7] at lp_up2, positioned at [15:12] */
name|lp_up2
operator|=
operator|(
operator|(
operator|(
name|lp_up2
operator|&
name|MDIO_OVER_1G_LP_UP2_PREEMPHASIS_MASK
operator|)
operator|>>
name|MDIO_OVER_1G_LP_UP2_PREEMPHASIS_SHIFT
operator|)
operator|<<
name|MDIO_TX0_TX_DRIVER_PREEMPHASIS_SHIFT
operator|)
expr_stmt|;
if|if
condition|(
name|lp_up2
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|bank
operator|=
name|MDIO_REG_BANK_TX0
init|;
name|bank
operator|<=
name|MDIO_REG_BANK_TX3
condition|;
name|bank
operator|+=
operator|(
name|MDIO_REG_BANK_TX1
operator|-
name|MDIO_REG_BANK_TX0
operator|)
control|)
block|{
name|CL22_RD_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|bank
argument_list|,
name|MDIO_TX0_TX_DRIVER
argument_list|,
operator|&
name|tx_driver
argument_list|)
expr_stmt|;
comment|/* Replace tx_driver bits [15:12] */
if|if
condition|(
name|lp_up2
operator|!=
operator|(
name|tx_driver
operator|&
name|MDIO_TX0_TX_DRIVER_PREEMPHASIS_MASK
operator|)
condition|)
block|{
name|tx_driver
operator|&=
operator|~
name|MDIO_TX0_TX_DRIVER_PREEMPHASIS_MASK
expr_stmt|;
name|tx_driver
operator||=
name|lp_up2
expr_stmt|;
name|CL22_WR_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|bank
argument_list|,
name|MDIO_TX0_TX_DRIVER
argument_list|,
name|tx_driver
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_emac_program
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint8_t
name|port
init|=
name|params
operator|->
name|port
decl_stmt|;
name|uint16_t
name|mode
init|=
literal|0
decl_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"setting link speed& duplex\n"
argument_list|)
expr_stmt|;
name|elink_bits_dis
argument_list|(
name|sc
argument_list|,
name|GRCBASE_EMAC0
operator|+
name|port
operator|*
literal|0x400
operator|+
name|EMAC_REG_EMAC_MODE
argument_list|,
operator|(
name|EMAC_MODE_25G_MODE
operator||
name|EMAC_MODE_PORT_MII_10M
operator||
name|EMAC_MODE_HALF_DUPLEX
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|vars
operator|->
name|line_speed
condition|)
block|{
case|case
name|ELINK_SPEED_10
case|:
name|mode
operator||=
name|EMAC_MODE_PORT_MII_10M
expr_stmt|;
break|break;
case|case
name|ELINK_SPEED_100
case|:
name|mode
operator||=
name|EMAC_MODE_PORT_MII
expr_stmt|;
break|break;
case|case
name|ELINK_SPEED_1000
case|:
name|mode
operator||=
name|EMAC_MODE_PORT_GMII
expr_stmt|;
break|break;
case|case
name|ELINK_SPEED_2500
case|:
name|mode
operator||=
operator|(
name|EMAC_MODE_25G_MODE
operator||
name|EMAC_MODE_PORT_GMII
operator|)
expr_stmt|;
break|break;
default|default:
comment|/* 10G not valid for EMAC */
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Invalid line_speed 0x%x\n"
argument_list|,
name|vars
operator|->
name|line_speed
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
if|if
condition|(
name|vars
operator|->
name|duplex
operator|==
name|DUPLEX_HALF
condition|)
name|mode
operator||=
name|EMAC_MODE_HALF_DUPLEX
expr_stmt|;
name|elink_bits_en
argument_list|(
name|sc
argument_list|,
name|GRCBASE_EMAC0
operator|+
name|port
operator|*
literal|0x400
operator|+
name|EMAC_REG_EMAC_MODE
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|elink_set_led
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
name|ELINK_LED_MODE_OPER
argument_list|,
name|vars
operator|->
name|line_speed
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_set_preemphasis
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|uint16_t
name|bank
decl_stmt|,
name|i
init|=
literal|0
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
for|for
control|(
name|bank
operator|=
name|MDIO_REG_BANK_RX0
operator|,
name|i
operator|=
literal|0
init|;
name|bank
operator|<=
name|MDIO_REG_BANK_RX3
condition|;
name|bank
operator|+=
operator|(
name|MDIO_REG_BANK_RX1
operator|-
name|MDIO_REG_BANK_RX0
operator|)
operator|,
name|i
operator|++
control|)
block|{
name|CL22_WR_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|bank
argument_list|,
name|MDIO_RX0_RX_EQ_BOOST
argument_list|,
name|phy
operator|->
name|rx_preemphasis
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|bank
operator|=
name|MDIO_REG_BANK_TX0
operator|,
name|i
operator|=
literal|0
init|;
name|bank
operator|<=
name|MDIO_REG_BANK_TX3
condition|;
name|bank
operator|+=
operator|(
name|MDIO_REG_BANK_TX1
operator|-
name|MDIO_REG_BANK_TX0
operator|)
operator|,
name|i
operator|++
control|)
block|{
name|CL22_WR_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|bank
argument_list|,
name|MDIO_TX0_TX_DRIVER
argument_list|,
name|phy
operator|->
name|tx_preemphasis
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|elink_xgxs_config_init
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint8_t
name|enable_cl73
init|=
operator|(
name|ELINK_SINGLE_MEDIA_DIRECT
argument_list|(
name|params
argument_list|)
operator|||
operator|(
name|params
operator|->
name|loopback_mode
operator|==
name|ELINK_LOOPBACK_XGXS
operator|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|vars
operator|->
name|phy_flags
operator|&
name|PHY_SGMII_FLAG
operator|)
condition|)
block|{
if|if
condition|(
name|ELINK_SINGLE_MEDIA_DIRECT
argument_list|(
name|params
argument_list|)
operator|&&
operator|(
name|params
operator|->
name|feature_config_flags
operator|&
name|ELINK_FEATURE_CONFIG_OVERRIDE_PREEMPHASIS_ENABLED
operator|)
condition|)
name|elink_set_preemphasis
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
expr_stmt|;
comment|/* Forced speed requested? */
if|if
condition|(
name|vars
operator|->
name|line_speed
operator|!=
name|ELINK_SPEED_AUTO_NEG
operator|||
operator|(
name|ELINK_SINGLE_MEDIA_DIRECT
argument_list|(
name|params
argument_list|)
operator|&&
name|params
operator|->
name|loopback_mode
operator|==
name|ELINK_LOOPBACK_EXT
operator|)
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"not SGMII, no AN\n"
argument_list|)
expr_stmt|;
comment|/* Disable autoneg */
name|elink_set_autoneg
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Program speed and duplex */
name|elink_program_serdes
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* AN_mode */
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"not SGMII, AN\n"
argument_list|)
expr_stmt|;
comment|/* AN enabled */
name|elink_set_brcm_cl37_advertisement
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
expr_stmt|;
comment|/* Program duplex& pause advertisement (for aneg) */
name|elink_set_ieee_aneg_advertisement
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
operator|->
name|ieee_fc
argument_list|)
expr_stmt|;
comment|/* Enable autoneg */
name|elink_set_autoneg
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|,
name|enable_cl73
argument_list|)
expr_stmt|;
comment|/* Enable and restart AN */
name|elink_restart_autoneg
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|enable_cl73
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* SGMII mode */
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"SGMII\n"
argument_list|)
expr_stmt|;
name|elink_initialize_sgmii_process
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_prepare_xgxs
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|elink_status_t
name|rc
decl_stmt|;
name|vars
operator|->
name|phy_flags
operator||=
name|PHY_XGXS_FLAG
expr_stmt|;
if|if
condition|(
operator|(
name|phy
operator|->
name|req_line_speed
operator|&&
operator|(
operator|(
name|phy
operator|->
name|req_line_speed
operator|==
name|ELINK_SPEED_100
operator|)
operator|||
operator|(
name|phy
operator|->
name|req_line_speed
operator|==
name|ELINK_SPEED_10
operator|)
operator|)
operator|)
operator|||
operator|(
operator|!
name|phy
operator|->
name|req_line_speed
operator|&&
operator|(
name|phy
operator|->
name|speed_cap_mask
operator|>=
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_10M_FULL
operator|)
operator|&&
operator|(
name|phy
operator|->
name|speed_cap_mask
operator|<
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_1G
operator|)
operator|)
operator|||
operator|(
name|phy
operator|->
name|type
operator|==
name|PORT_HW_CFG_SERDES_EXT_PHY_TYPE_DIRECT_SD
operator|)
condition|)
name|vars
operator|->
name|phy_flags
operator||=
name|PHY_SGMII_FLAG
expr_stmt|;
else|else
name|vars
operator|->
name|phy_flags
operator|&=
operator|~
name|PHY_SGMII_FLAG
expr_stmt|;
name|elink_calc_ieee_aneg_adv
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
operator|&
name|vars
operator|->
name|ieee_fc
argument_list|)
expr_stmt|;
name|elink_set_aer_mmd
argument_list|(
name|params
argument_list|,
name|phy
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|type
operator|==
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT
condition|)
name|elink_set_master_ln
argument_list|(
name|params
argument_list|,
name|phy
argument_list|)
expr_stmt|;
name|rc
operator|=
name|elink_reset_unicore
argument_list|(
name|params
argument_list|,
name|phy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reset the SerDes and wait for reset bit return low */
if|if
condition|(
name|rc
operator|!=
name|ELINK_STATUS_OK
condition|)
return|return
name|rc
return|;
name|elink_set_aer_mmd
argument_list|(
name|params
argument_list|,
name|phy
argument_list|)
expr_stmt|;
comment|/* Setting the masterLn_def again after the reset */
if|if
condition|(
name|phy
operator|->
name|type
operator|==
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT
condition|)
block|{
name|elink_set_master_ln
argument_list|(
name|params
argument_list|,
name|phy
argument_list|)
expr_stmt|;
name|elink_set_swap_lanes
argument_list|(
name|params
argument_list|,
name|phy
argument_list|)
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|uint16_t
name|elink_wait_reset_complete
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|uint16_t
name|cnt
decl_stmt|,
name|ctrl
decl_stmt|;
comment|/* Wait for soft reset to get cleared up to 1 sec */
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
literal|1000
condition|;
name|cnt
operator|++
control|)
block|{
if|if
condition|(
name|phy
operator|->
name|type
operator|==
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM54618SE
condition|)
name|elink_cl22_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_REG_CTRL
argument_list|,
operator|&
name|ctrl
argument_list|)
expr_stmt|;
else|else
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_CTRL
argument_list|,
operator|&
name|ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ctrl
operator|&
operator|(
literal|1
operator|<<
literal|15
operator|)
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|1000
operator|*
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cnt
operator|==
literal|1000
condition|)
name|elink_cb_event_log
argument_list|(
name|sc
argument_list|,
name|ELINK_LOG_ID_PHY_UNINITIALIZED
argument_list|,
name|params
operator|->
name|port
argument_list|)
expr_stmt|;
comment|// "Warning: PHY was not initialized,"
comment|// " Port %d\n",
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"control reg 0x%x (after %d ms)\n"
argument_list|,
name|ctrl
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
return|return
name|cnt
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_link_int_enable
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|uint8_t
name|port
init|=
name|params
operator|->
name|port
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
comment|/* Setting the status to report on link up for either XGXS or SerDes */
if|if
condition|(
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|mask
operator|=
name|ELINK_NIG_MASK_XGXS0_LINK_STATUS
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ELINK_SINGLE_MEDIA_DIRECT
argument_list|(
name|params
argument_list|)
operator|)
condition|)
name|mask
operator||=
name|ELINK_NIG_MASK_MI_INT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|params
operator|->
name|switch_cfg
operator|==
name|ELINK_SWITCH_CFG_10G
condition|)
block|{
name|mask
operator|=
operator|(
name|ELINK_NIG_MASK_XGXS0_LINK10G
operator||
name|ELINK_NIG_MASK_XGXS0_LINK_STATUS
operator|)
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"enabled XGXS interrupt\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ELINK_SINGLE_MEDIA_DIRECT
argument_list|(
name|params
argument_list|)
operator|)
operator|&&
name|params
operator|->
name|phy
index|[
name|ELINK_INT_PHY
index|]
operator|.
name|type
operator|!=
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_FAILURE
condition|)
block|{
name|mask
operator||=
name|ELINK_NIG_MASK_MI_INT
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"enabled external phy int\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* SerDes */
name|mask
operator|=
name|ELINK_NIG_MASK_SERDES0_LINK_STATUS
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"enabled SerDes interrupt\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ELINK_SINGLE_MEDIA_DIRECT
argument_list|(
name|params
argument_list|)
operator|)
operator|&&
name|params
operator|->
name|phy
index|[
name|ELINK_INT_PHY
index|]
operator|.
name|type
operator|!=
name|PORT_HW_CFG_SERDES_EXT_PHY_TYPE_NOT_CONN
condition|)
block|{
name|mask
operator||=
name|ELINK_NIG_MASK_MI_INT
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"enabled external phy int\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|elink_bits_en
argument_list|(
name|sc
argument_list|,
name|NIG_REG_MASK_INTERRUPT_PORT0
operator|+
name|port
operator|*
literal|4
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P3
argument_list|(
name|sc
argument_list|,
literal|"port %x, is_xgxs %x, int_status 0x%x\n"
argument_list|,
name|port
argument_list|,
operator|(
name|params
operator|->
name|switch_cfg
operator|==
name|ELINK_SWITCH_CFG_10G
operator|)
argument_list|,
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_STATUS_INTERRUPT_PORT0
operator|+
name|port
operator|*
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P3
argument_list|(
name|sc
argument_list|,
literal|" int_mask 0x%x, MI_INT %x, SERDES_LINK %x\n"
argument_list|,
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_MASK_INTERRUPT_PORT0
operator|+
name|port
operator|*
literal|4
argument_list|)
argument_list|,
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_EMAC0_STATUS_MISC_MI_INT
operator|+
name|port
operator|*
literal|0x18
argument_list|)
argument_list|,
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_SERDES0_STATUS_LINK_STATUS
operator|+
name|port
operator|*
literal|0x3c
argument_list|)
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|" 10G %x, XGXS_LINK %x\n"
argument_list|,
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_XGXS0_STATUS_LINK10G
operator|+
name|port
operator|*
literal|0x68
argument_list|)
argument_list|,
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_XGXS0_STATUS_LINK_STATUS
operator|+
name|port
operator|*
literal|0x68
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_rearm_latch_signal
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|port
parameter_list|,
name|uint8_t
name|exp_mi_int
parameter_list|)
block|{
name|uint32_t
name|latch_status
init|=
literal|0
decl_stmt|;
comment|/* Disable the MI INT ( external phy int ) by writing 1 to the 	 * status register. Link down indication is high-active-signal, 	 * so in this case we need to write the status to clear the XOR 	 */
comment|/* Read Latched signals */
name|latch_status
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LATCH_STATUS_0
operator|+
name|port
operator|*
literal|8
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"latch_status = 0x%x\n"
argument_list|,
name|latch_status
argument_list|)
expr_stmt|;
comment|/* Handle only those with latched-signal=up.*/
if|if
condition|(
name|exp_mi_int
condition|)
name|elink_bits_en
argument_list|(
name|sc
argument_list|,
name|NIG_REG_STATUS_INTERRUPT_PORT0
operator|+
name|port
operator|*
literal|4
argument_list|,
name|ELINK_NIG_STATUS_EMAC0_MI_INT
argument_list|)
expr_stmt|;
else|else
name|elink_bits_dis
argument_list|(
name|sc
argument_list|,
name|NIG_REG_STATUS_INTERRUPT_PORT0
operator|+
name|port
operator|*
literal|4
argument_list|,
name|ELINK_NIG_STATUS_EMAC0_MI_INT
argument_list|)
expr_stmt|;
if|if
condition|(
name|latch_status
operator|&
literal|1
condition|)
block|{
comment|/* For all latched-signal=up : Re-Arm Latch signals */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LATCH_STATUS_0
operator|+
name|port
operator|*
literal|8
argument_list|,
operator|(
name|latch_status
operator|&
literal|0xfffe
operator|)
operator||
operator|(
name|latch_status
operator|&
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* For all latched-signal=up,Write original_signal to status */
block|}
end_function

begin_function
specifier|static
name|void
name|elink_link_int_ack
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|,
name|uint8_t
name|is_10g_plus
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint8_t
name|port
init|=
name|params
operator|->
name|port
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|;
comment|/* First reset all status we assume only one line will be 	 * change at a time 	 */
name|elink_bits_dis
argument_list|(
name|sc
argument_list|,
name|NIG_REG_STATUS_INTERRUPT_PORT0
operator|+
name|port
operator|*
literal|4
argument_list|,
operator|(
name|ELINK_NIG_STATUS_XGXS0_LINK10G
operator||
name|ELINK_NIG_STATUS_XGXS0_LINK_STATUS
operator||
name|ELINK_NIG_STATUS_SERDES0_LINK_STATUS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vars
operator|->
name|phy_link_up
condition|)
block|{
if|if
condition|(
name|USES_WARPCORE
argument_list|(
name|sc
argument_list|)
condition|)
name|mask
operator|=
name|ELINK_NIG_STATUS_XGXS0_LINK_STATUS
expr_stmt|;
else|else
block|{
if|if
condition|(
name|is_10g_plus
condition|)
name|mask
operator|=
name|ELINK_NIG_STATUS_XGXS0_LINK10G
expr_stmt|;
elseif|else
if|if
condition|(
name|params
operator|->
name|switch_cfg
operator|==
name|ELINK_SWITCH_CFG_10G
condition|)
block|{
comment|/* Disable the link interrupt by writing 1 to 				 * the relevant lane in the status register 				 */
name|uint32_t
name|ser_lane
init|=
operator|(
operator|(
name|params
operator|->
name|lane_config
operator|&
name|PORT_HW_CFG_LANE_SWAP_CFG_MASTER_MASK
operator|)
operator|>>
name|PORT_HW_CFG_LANE_SWAP_CFG_MASTER_SHIFT
operator|)
decl_stmt|;
name|mask
operator|=
operator|(
operator|(
literal|1
operator|<<
name|ser_lane
operator|)
operator|<<
name|ELINK_NIG_STATUS_XGXS0_LINK_STATUS_SIZE
operator|)
expr_stmt|;
block|}
else|else
name|mask
operator|=
name|ELINK_NIG_STATUS_SERDES0_LINK_STATUS
expr_stmt|;
block|}
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Ack link up interrupt with mask 0x%x\n"
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|elink_bits_en
argument_list|(
name|sc
argument_list|,
name|NIG_REG_STATUS_INTERRUPT_PORT0
operator|+
name|port
operator|*
literal|4
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_format_ver
parameter_list|(
name|uint32_t
name|num
parameter_list|,
name|uint8_t
modifier|*
name|str
parameter_list|,
name|uint16_t
modifier|*
name|len
parameter_list|)
block|{
name|uint8_t
modifier|*
name|str_ptr
init|=
name|str
decl_stmt|;
name|uint32_t
name|mask
init|=
literal|0xf0000000
decl_stmt|;
name|uint8_t
name|shift
init|=
literal|8
operator|*
literal|4
decl_stmt|;
name|uint8_t
name|digit
decl_stmt|;
name|uint8_t
name|remove_leading_zeros
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|*
name|len
operator|<
literal|10
condition|)
block|{
comment|/* Need more than 10chars for this format */
operator|*
name|str_ptr
operator|=
literal|'\0'
expr_stmt|;
operator|(
operator|*
name|len
operator|)
operator|--
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
while|while
condition|(
name|shift
operator|>
literal|0
condition|)
block|{
name|shift
operator|-=
literal|4
expr_stmt|;
name|digit
operator|=
operator|(
operator|(
name|num
operator|&
name|mask
operator|)
operator|>>
name|shift
operator|)
expr_stmt|;
if|if
condition|(
name|digit
operator|==
literal|0
operator|&&
name|remove_leading_zeros
condition|)
block|{
name|mask
operator|=
name|mask
operator|>>
literal|4
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|digit
operator|<
literal|0xa
condition|)
operator|*
name|str_ptr
operator|=
name|digit
operator|+
literal|'0'
expr_stmt|;
else|else
operator|*
name|str_ptr
operator|=
name|digit
operator|-
literal|0xa
operator|+
literal|'a'
expr_stmt|;
name|remove_leading_zeros
operator|=
literal|0
expr_stmt|;
name|str_ptr
operator|++
expr_stmt|;
operator|(
operator|*
name|len
operator|)
operator|--
expr_stmt|;
name|mask
operator|=
name|mask
operator|>>
literal|4
expr_stmt|;
if|if
condition|(
name|shift
operator|==
literal|4
operator|*
literal|4
condition|)
block|{
operator|*
name|str_ptr
operator|=
literal|'.'
expr_stmt|;
name|str_ptr
operator|++
expr_stmt|;
operator|(
operator|*
name|len
operator|)
operator|--
expr_stmt|;
name|remove_leading_zeros
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_null_format_ver
parameter_list|(
name|uint32_t
name|spirom_ver
parameter_list|,
name|uint8_t
modifier|*
name|str
parameter_list|,
name|uint16_t
modifier|*
name|len
parameter_list|)
block|{
name|str
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
operator|*
name|len
operator|)
operator|--
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
name|elink_status_t
name|elink_get_ext_phy_fw_version
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint8_t
modifier|*
name|version
parameter_list|,
name|uint16_t
name|len
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|spirom_ver
init|=
literal|0
decl_stmt|;
name|elink_status_t
name|status
init|=
name|ELINK_STATUS_OK
decl_stmt|;
name|uint8_t
modifier|*
name|ver_p
init|=
name|version
decl_stmt|;
name|uint16_t
name|remain_len
init|=
name|len
decl_stmt|;
if|if
condition|(
name|version
operator|==
name|NULL
operator|||
name|params
operator|==
name|NULL
condition|)
return|return
name|ELINK_STATUS_ERROR
return|;
name|sc
operator|=
name|params
operator|->
name|sc
expr_stmt|;
comment|/* Extract first external phy*/
name|version
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|spirom_ver
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|phy
index|[
name|ELINK_EXT_PHY1
index|]
operator|.
name|ver_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|phy
index|[
name|ELINK_EXT_PHY1
index|]
operator|.
name|format_fw_ver
condition|)
block|{
name|status
operator||=
name|params
operator|->
name|phy
index|[
name|ELINK_EXT_PHY1
index|]
operator|.
name|format_fw_ver
argument_list|(
name|spirom_ver
argument_list|,
name|ver_p
argument_list|,
operator|&
name|remain_len
argument_list|)
expr_stmt|;
name|ver_p
operator|+=
operator|(
name|len
operator|-
name|remain_len
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|params
operator|->
name|num_phys
operator|==
name|ELINK_MAX_PHYS
operator|)
operator|&&
operator|(
name|params
operator|->
name|phy
index|[
name|ELINK_EXT_PHY2
index|]
operator|.
name|ver_addr
operator|!=
literal|0
operator|)
condition|)
block|{
name|spirom_ver
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|phy
index|[
name|ELINK_EXT_PHY2
index|]
operator|.
name|ver_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|phy
index|[
name|ELINK_EXT_PHY2
index|]
operator|.
name|format_fw_ver
condition|)
block|{
operator|*
name|ver_p
operator|=
literal|'/'
expr_stmt|;
name|ver_p
operator|++
expr_stmt|;
name|remain_len
operator|--
expr_stmt|;
name|status
operator||=
name|params
operator|->
name|phy
index|[
name|ELINK_EXT_PHY2
index|]
operator|.
name|format_fw_ver
argument_list|(
name|spirom_ver
argument_list|,
name|ver_p
argument_list|,
operator|&
name|remain_len
argument_list|)
expr_stmt|;
name|ver_p
operator|=
name|version
operator|+
operator|(
name|len
operator|-
name|remain_len
operator|)
expr_stmt|;
block|}
block|}
operator|*
name|ver_p
operator|=
literal|'\0'
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_set_xgxs_loopback
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|uint8_t
name|port
init|=
name|params
operator|->
name|port
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
if|if
condition|(
name|phy
operator|->
name|req_line_speed
operator|!=
name|ELINK_SPEED_1000
condition|)
block|{
name|uint32_t
name|md_devad
init|=
literal|0
decl_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"XGXS 10G loopback enable\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* Change the uni_phy_addr in the nig */
name|md_devad
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
operator|(
name|NIG_REG_XGXS0_CTRL_MD_DEVAD
operator|+
name|port
operator|*
literal|0x18
operator|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_XGXS0_CTRL_MD_DEVAD
operator|+
name|port
operator|*
literal|0x18
argument_list|,
literal|0x5
argument_list|)
expr_stmt|;
block|}
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
literal|5
argument_list|,
operator|(
name|MDIO_REG_BANK_AER_BLOCK
operator|+
operator|(
name|MDIO_AER_BLOCK_AER_REG
operator|&
literal|0xf
operator|)
operator|)
argument_list|,
literal|0x2800
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
literal|5
argument_list|,
operator|(
name|MDIO_REG_BANK_CL73_IEEEB0
operator|+
operator|(
name|MDIO_CL73_IEEEB0_CL73_AN_CONTROL
operator|&
literal|0xf
operator|)
operator|)
argument_list|,
literal|0x6041
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
operator|*
literal|200
argument_list|)
expr_stmt|;
comment|/* Set aer mmd back */
name|elink_set_aer_mmd
argument_list|(
name|params
argument_list|,
name|phy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* And md_devad */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_XGXS0_CTRL_MD_DEVAD
operator|+
name|port
operator|*
literal|0x18
argument_list|,
name|md_devad
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|uint16_t
name|mii_ctrl
decl_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"XGXS 1G loopback enable\n"
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
literal|5
argument_list|,
operator|(
name|MDIO_REG_BANK_COMBO_IEEE0
operator|+
operator|(
name|MDIO_COMBO_IEEE0_MII_CONTROL
operator|&
literal|0xf
operator|)
operator|)
argument_list|,
operator|&
name|mii_ctrl
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
literal|5
argument_list|,
operator|(
name|MDIO_REG_BANK_COMBO_IEEE0
operator|+
operator|(
name|MDIO_COMBO_IEEE0_MII_CONTROL
operator|&
literal|0xf
operator|)
operator|)
argument_list|,
name|mii_ctrl
operator||
name|MDIO_COMBO_IEEO_MII_CONTROL_LOOPBACK
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|elink_status_t
name|elink_set_led
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|,
name|uint8_t
name|mode
parameter_list|,
name|uint32_t
name|speed
parameter_list|)
block|{
name|uint8_t
name|port
init|=
name|params
operator|->
name|port
decl_stmt|;
name|uint16_t
name|hw_led_mode
init|=
name|params
operator|->
name|hw_led_mode
decl_stmt|;
name|elink_status_t
name|rc
init|=
name|ELINK_STATUS_OK
decl_stmt|;
name|uint8_t
name|phy_idx
decl_stmt|;
name|uint32_t
name|tmp
decl_stmt|;
name|uint32_t
name|emac_base
init|=
name|port
condition|?
name|GRCBASE_EMAC1
else|:
name|GRCBASE_EMAC0
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"elink_set_led: port %x, mode %d\n"
argument_list|,
name|port
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"speed 0x%x, hw_led_mode 0x%x\n"
argument_list|,
name|speed
argument_list|,
name|hw_led_mode
argument_list|)
expr_stmt|;
comment|/* In case */
for|for
control|(
name|phy_idx
operator|=
name|ELINK_EXT_PHY1
init|;
name|phy_idx
operator|<
name|ELINK_MAX_PHYS
condition|;
name|phy_idx
operator|++
control|)
block|{
if|if
condition|(
name|params
operator|->
name|phy
index|[
name|phy_idx
index|]
operator|.
name|set_link_led
condition|)
block|{
name|params
operator|->
name|phy
index|[
name|phy_idx
index|]
operator|.
name|set_link_led
argument_list|(
operator|&
name|params
operator|->
name|phy
index|[
name|phy_idx
index|]
argument_list|,
name|params
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|ELINK_INCLUDE_EMUL
if|if
condition|(
name|params
operator|->
name|feature_config_flags
operator|&
name|ELINK_FEATURE_CONFIG_EMUL_DISABLE_EMAC
condition|)
return|return
name|rc
return|;
endif|#
directive|endif
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|ELINK_LED_MODE_FRONT_PANEL_OFF
case|:
case|case
name|ELINK_LED_MODE_OFF
case|:
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LED_10G_P0
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LED_MODE_P0
operator|+
name|port
operator|*
literal|4
argument_list|,
name|SHARED_HW_CFG_LED_MAC1
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|elink_cb_reg_read
argument_list|(
name|sc
argument_list|,
name|emac_base
operator|+
name|EMAC_REG_EMAC_LED
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|phy
index|[
name|ELINK_EXT_PHY1
index|]
operator|.
name|type
operator|==
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM54618SE
condition|)
name|tmp
operator|&=
operator|~
operator|(
name|EMAC_LED_1000MB_OVERRIDE
operator||
name|EMAC_LED_100MB_OVERRIDE
operator||
name|EMAC_LED_10MB_OVERRIDE
operator|)
expr_stmt|;
else|else
name|tmp
operator||=
name|EMAC_LED_OVERRIDE
expr_stmt|;
name|elink_cb_reg_write
argument_list|(
name|sc
argument_list|,
name|emac_base
operator|+
name|EMAC_REG_EMAC_LED
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
break|break;
case|case
name|ELINK_LED_MODE_OPER
case|:
comment|/* For all other phys, OPER mode is same as ON, so in case 		 * link is down, do nothing 		 */
if|if
condition|(
operator|!
name|vars
operator|->
name|link_up
condition|)
break|break;
case|case
name|ELINK_LED_MODE_ON
case|:
if|if
condition|(
operator|(
operator|(
name|params
operator|->
name|phy
index|[
name|ELINK_EXT_PHY1
index|]
operator|.
name|type
operator|==
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727
operator|)
operator|||
operator|(
name|params
operator|->
name|phy
index|[
name|ELINK_EXT_PHY1
index|]
operator|.
name|type
operator|==
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8722
operator|)
operator|)
operator|&&
name|CHIP_IS_E2
argument_list|(
name|sc
argument_list|)
operator|&&
name|params
operator|->
name|num_phys
operator|==
literal|2
condition|)
block|{
comment|/* This is a work-around for E2+8727 Configurations */
if|if
condition|(
name|mode
operator|==
name|ELINK_LED_MODE_ON
operator|||
name|speed
operator|==
name|ELINK_SPEED_10000
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LED_MODE_P0
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LED_10G_P0
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|elink_cb_reg_read
argument_list|(
name|sc
argument_list|,
name|emac_base
operator|+
name|EMAC_REG_EMAC_LED
argument_list|)
expr_stmt|;
name|elink_cb_reg_write
argument_list|(
name|sc
argument_list|,
name|emac_base
operator|+
name|EMAC_REG_EMAC_LED
argument_list|,
operator|(
name|tmp
operator||
name|EMAC_LED_OVERRIDE
operator|)
argument_list|)
expr_stmt|;
comment|/* Return here without enabling traffic 				 * LED blink and setting rate in ON mode. 				 * In oper mode, enabling LED blink 				 * and setting rate is needed. 				 */
if|if
condition|(
name|mode
operator|==
name|ELINK_LED_MODE_ON
condition|)
return|return
name|rc
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|ELINK_SINGLE_MEDIA_DIRECT
argument_list|(
name|params
argument_list|)
condition|)
block|{
comment|/* This is a work-around for HW issue found when link 			 * is up in CL73 			 */
if|if
condition|(
operator|(
operator|!
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
operator|)
operator|||
operator|(
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
operator|&&
name|mode
operator|==
name|ELINK_LED_MODE_ON
operator|)
condition|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LED_10G_P0
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
operator|||
name|CHIP_IS_E2
argument_list|(
name|sc
argument_list|)
operator|||
operator|(
name|mode
operator|==
name|ELINK_LED_MODE_ON
operator|)
condition|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LED_MODE_P0
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LED_MODE_P0
operator|+
name|port
operator|*
literal|4
argument_list|,
name|hw_led_mode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|params
operator|->
name|phy
index|[
name|ELINK_EXT_PHY1
index|]
operator|.
name|type
operator|==
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM54618SE
operator|)
operator|&&
operator|(
name|mode
operator|==
name|ELINK_LED_MODE_ON
operator|)
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LED_MODE_P0
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|elink_cb_reg_read
argument_list|(
name|sc
argument_list|,
name|emac_base
operator|+
name|EMAC_REG_EMAC_LED
argument_list|)
expr_stmt|;
name|elink_cb_reg_write
argument_list|(
name|sc
argument_list|,
name|emac_base
operator|+
name|EMAC_REG_EMAC_LED
argument_list|,
name|tmp
operator||
name|EMAC_LED_OVERRIDE
operator||
name|EMAC_LED_1000MB_OVERRIDE
argument_list|)
expr_stmt|;
comment|/* Break here; otherwise, it'll disable the 			 * intended override. 			 */
break|break;
block|}
else|else
block|{
name|uint32_t
name|nig_led_mode
init|=
operator|(
operator|(
name|params
operator|->
name|hw_led_mode
operator|<<
name|SHARED_HW_CFG_LED_MODE_SHIFT
operator|)
operator|==
name|SHARED_HW_CFG_LED_EXTPHY2
operator|)
condition|?
operator|(
name|SHARED_HW_CFG_LED_PHY1
operator|>>
name|SHARED_HW_CFG_LED_MODE_SHIFT
operator|)
else|:
name|hw_led_mode
decl_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LED_MODE_P0
operator|+
name|port
operator|*
literal|4
argument_list|,
name|nig_led_mode
argument_list|)
expr_stmt|;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LED_CONTROL_OVERRIDE_TRAFFIC_P0
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set blinking rate to ~15.9Hz */
if|if
condition|(
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LED_CONTROL_BLINK_RATE_P0
operator|+
name|port
operator|*
literal|4
argument_list|,
name|LED_BLINK_RATE_VAL_E3
argument_list|)
expr_stmt|;
else|else
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LED_CONTROL_BLINK_RATE_P0
operator|+
name|port
operator|*
literal|4
argument_list|,
name|LED_BLINK_RATE_VAL_E1X_E2
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LED_CONTROL_BLINK_RATE_ENA_P0
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|elink_cb_reg_read
argument_list|(
name|sc
argument_list|,
name|emac_base
operator|+
name|EMAC_REG_EMAC_LED
argument_list|)
expr_stmt|;
name|elink_cb_reg_write
argument_list|(
name|sc
argument_list|,
name|emac_base
operator|+
name|EMAC_REG_EMAC_LED
argument_list|,
operator|(
name|tmp
operator|&
operator|(
operator|~
name|EMAC_LED_OVERRIDE
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
operator|&&
operator|(
operator|(
name|speed
operator|==
name|ELINK_SPEED_2500
operator|)
operator|||
operator|(
name|speed
operator|==
name|ELINK_SPEED_1000
operator|)
operator|||
operator|(
name|speed
operator|==
name|ELINK_SPEED_100
operator|)
operator|||
operator|(
name|speed
operator|==
name|ELINK_SPEED_10
operator|)
operator|)
condition|)
block|{
comment|/* For speeds less than 10G LED scheme is different */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LED_CONTROL_OVERRIDE_TRAFFIC_P0
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LED_CONTROL_TRAFFIC_P0
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LED_CONTROL_BLINK_TRAFFIC_P0
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|rc
operator|=
name|ELINK_STATUS_ERROR
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"elink_set_led: Invalid led mode %d\n"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/* This function comes to reflect the actual link state read DIRECTLY from the  * HW  */
end_comment

begin_function
name|elink_status_t
name|elink_test_link
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|,
name|uint8_t
name|is_serdes
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint16_t
name|gp_status
init|=
literal|0
decl_stmt|,
name|phy_index
init|=
literal|0
decl_stmt|;
name|uint8_t
name|ext_phy_link_up
init|=
literal|0
decl_stmt|,
name|serdes_phy_type
decl_stmt|;
name|struct
name|elink_vars
name|temp_vars
decl_stmt|;
name|struct
name|elink_phy
modifier|*
name|int_phy
init|=
operator|&
name|params
operator|->
name|phy
index|[
name|ELINK_INT_PHY
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|ELINK_INCLUDE_FPGA
if|if
condition|(
name|CHIP_REV_IS_FPGA
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|ELINK_STATUS_OK
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ELINK_INCLUDE_EMUL
if|if
condition|(
name|CHIP_REV_IS_EMUL
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|ELINK_STATUS_OK
return|;
endif|#
directive|endif
if|if
condition|(
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|uint16_t
name|link_up
decl_stmt|;
if|if
condition|(
name|params
operator|->
name|req_line_speed
index|[
name|ELINK_LINK_CONFIG_IDX
argument_list|(
name|ELINK_INT_PHY
argument_list|)
index|]
operator|>
name|ELINK_SPEED_10000
condition|)
block|{
comment|/* Check 20G link */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|int_phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
literal|1
argument_list|,
operator|&
name|link_up
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|int_phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
literal|1
argument_list|,
operator|&
name|link_up
argument_list|)
expr_stmt|;
name|link_up
operator|&=
operator|(
literal|1
operator|<<
literal|2
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Check 10G link and below*/
name|uint8_t
name|lane
init|=
name|elink_get_warpcore_lane
argument_list|(
name|int_phy
argument_list|,
name|params
argument_list|)
decl_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|int_phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_GP2_STATUS_GP_2_1
argument_list|,
operator|&
name|gp_status
argument_list|)
expr_stmt|;
name|gp_status
operator|=
operator|(
operator|(
name|gp_status
operator|>>
literal|8
operator|)
operator|&
literal|0xf
operator|)
operator||
operator|(
operator|(
name|gp_status
operator|>>
literal|12
operator|)
operator|&
literal|0xf
operator|)
expr_stmt|;
name|link_up
operator|=
name|gp_status
operator|&
operator|(
literal|1
operator|<<
name|lane
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|link_up
condition|)
return|return
name|ELINK_STATUS_NO_LINK
return|;
block|}
else|else
block|{
name|CL22_RD_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|int_phy
argument_list|,
name|MDIO_REG_BANK_GP_STATUS
argument_list|,
name|MDIO_GP_STATUS_TOP_AN_STATUS1
argument_list|,
operator|&
name|gp_status
argument_list|)
expr_stmt|;
comment|/* Link is up only if both local phy and external phy are up */
if|if
condition|(
operator|!
operator|(
name|gp_status
operator|&
name|MDIO_GP_STATUS_TOP_AN_STATUS1_LINK_STATUS
operator|)
condition|)
return|return
name|ELINK_STATUS_NO_LINK
return|;
block|}
comment|/* In XGXS loopback mode, do not check external PHY */
if|if
condition|(
name|params
operator|->
name|loopback_mode
operator|==
name|ELINK_LOOPBACK_XGXS
condition|)
return|return
name|ELINK_STATUS_OK
return|;
switch|switch
condition|(
name|params
operator|->
name|num_phys
condition|)
block|{
case|case
literal|1
case|:
comment|/* No external PHY */
return|return
name|ELINK_STATUS_OK
return|;
case|case
literal|2
case|:
name|ext_phy_link_up
operator|=
name|params
operator|->
name|phy
index|[
name|ELINK_EXT_PHY1
index|]
operator|.
name|read_status
argument_list|(
operator|&
name|params
operator|->
name|phy
index|[
name|ELINK_EXT_PHY1
index|]
argument_list|,
name|params
argument_list|,
operator|&
name|temp_vars
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* Dual Media */
for|for
control|(
name|phy_index
operator|=
name|ELINK_EXT_PHY1
init|;
name|phy_index
operator|<
name|params
operator|->
name|num_phys
condition|;
name|phy_index
operator|++
control|)
block|{
name|serdes_phy_type
operator|=
operator|(
operator|(
name|params
operator|->
name|phy
index|[
name|phy_index
index|]
operator|.
name|media_type
operator|==
name|ELINK_ETH_PHY_SFPP_10G_FIBER
operator|)
operator|||
operator|(
name|params
operator|->
name|phy
index|[
name|phy_index
index|]
operator|.
name|media_type
operator|==
name|ELINK_ETH_PHY_SFP_1G_FIBER
operator|)
operator|||
operator|(
name|params
operator|->
name|phy
index|[
name|phy_index
index|]
operator|.
name|media_type
operator|==
name|ELINK_ETH_PHY_XFP_FIBER
operator|)
operator|||
operator|(
name|params
operator|->
name|phy
index|[
name|phy_index
index|]
operator|.
name|media_type
operator|==
name|ELINK_ETH_PHY_DA_TWINAX
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|is_serdes
operator|!=
name|serdes_phy_type
condition|)
continue|continue;
if|if
condition|(
name|params
operator|->
name|phy
index|[
name|phy_index
index|]
operator|.
name|read_status
condition|)
block|{
name|ext_phy_link_up
operator||=
name|params
operator|->
name|phy
index|[
name|phy_index
index|]
operator|.
name|read_status
argument_list|(
operator|&
name|params
operator|->
name|phy
index|[
name|phy_index
index|]
argument_list|,
name|params
argument_list|,
operator|&
name|temp_vars
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
if|if
condition|(
name|ext_phy_link_up
condition|)
return|return
name|ELINK_STATUS_OK
return|;
return|return
name|ELINK_STATUS_NO_LINK
return|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_link_initialize
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|uint8_t
name|phy_index
decl_stmt|,
name|non_ext_phy
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
comment|/* In case of external phy existence, the line speed would be the 	 * line speed linked up by the external phy. In case it is direct 	 * only, then the line_speed during initialization will be 	 * equal to the req_line_speed 	 */
name|vars
operator|->
name|line_speed
operator|=
name|params
operator|->
name|phy
index|[
name|ELINK_INT_PHY
index|]
operator|.
name|req_line_speed
expr_stmt|;
comment|/* Initialize the internal phy in case this is a direct board 	 * (no external phys), or this board has external phy which requires 	 * to first. 	 */
if|if
condition|(
operator|!
name|USES_WARPCORE
argument_list|(
name|sc
argument_list|)
condition|)
name|elink_prepare_xgxs
argument_list|(
operator|&
name|params
operator|->
name|phy
index|[
name|ELINK_INT_PHY
index|]
argument_list|,
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
comment|/* init ext phy and enable link state int */
name|non_ext_phy
operator|=
operator|(
name|ELINK_SINGLE_MEDIA_DIRECT
argument_list|(
name|params
argument_list|)
operator|||
operator|(
name|params
operator|->
name|loopback_mode
operator|==
name|ELINK_LOOPBACK_XGXS
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|non_ext_phy
operator|||
operator|(
name|params
operator|->
name|phy
index|[
name|ELINK_EXT_PHY1
index|]
operator|.
name|flags
operator|&
name|ELINK_FLAGS_INIT_XGXS_FIRST
operator|)
operator|||
operator|(
name|params
operator|->
name|loopback_mode
operator|==
name|ELINK_LOOPBACK_EXT_PHY
operator|)
condition|)
block|{
name|struct
name|elink_phy
modifier|*
name|phy
init|=
operator|&
name|params
operator|->
name|phy
index|[
name|ELINK_INT_PHY
index|]
decl_stmt|;
if|if
condition|(
name|vars
operator|->
name|line_speed
operator|==
name|ELINK_SPEED_AUTO_NEG
operator|&&
operator|(
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
operator|||
name|CHIP_IS_E2
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
name|elink_set_parallel_detection
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|phy
index|[
name|ELINK_INT_PHY
index|]
operator|.
name|config_init
condition|)
name|params
operator|->
name|phy
index|[
name|ELINK_INT_PHY
index|]
operator|.
name|config_init
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
block|}
comment|/* Re-read this value in case it was changed inside config_init due to 	 * limitations of optic module 	 */
name|vars
operator|->
name|line_speed
operator|=
name|params
operator|->
name|phy
index|[
name|ELINK_INT_PHY
index|]
operator|.
name|req_line_speed
expr_stmt|;
comment|/* Init external phy*/
if|if
condition|(
name|non_ext_phy
condition|)
block|{
if|if
condition|(
name|params
operator|->
name|phy
index|[
name|ELINK_INT_PHY
index|]
operator|.
name|supported
operator|&
name|ELINK_SUPPORTED_FIBRE
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_SERDES_LINK
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|phy_index
operator|=
name|ELINK_EXT_PHY1
init|;
name|phy_index
operator|<
name|params
operator|->
name|num_phys
condition|;
name|phy_index
operator|++
control|)
block|{
comment|/* No need to initialize second phy in case of first 			 * phy only selection. In case of second phy, we do 			 * need to initialize the first phy, since they are 			 * connected. 			 */
if|if
condition|(
name|params
operator|->
name|phy
index|[
name|phy_index
index|]
operator|.
name|supported
operator|&
name|ELINK_SUPPORTED_FIBRE
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_SERDES_LINK
expr_stmt|;
if|if
condition|(
name|phy_index
operator|==
name|ELINK_EXT_PHY2
operator|&&
operator|(
name|elink_phy_selection
argument_list|(
name|params
argument_list|)
operator|==
name|PORT_HW_CFG_PHY_SELECTION_FIRST_PHY
operator|)
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Not initializing second phy\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|params
operator|->
name|phy
index|[
name|phy_index
index|]
operator|.
name|config_init
argument_list|(
operator|&
name|params
operator|->
name|phy
index|[
name|phy_index
index|]
argument_list|,
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Reset the interrupt indication after phy was initialized */
name|elink_bits_dis
argument_list|(
name|sc
argument_list|,
name|NIG_REG_STATUS_INTERRUPT_PORT0
operator|+
name|params
operator|->
name|port
operator|*
literal|4
argument_list|,
operator|(
name|ELINK_NIG_STATUS_XGXS0_LINK10G
operator||
name|ELINK_NIG_STATUS_XGXS0_LINK_STATUS
operator||
name|ELINK_NIG_STATUS_SERDES0_LINK_STATUS
operator||
name|ELINK_NIG_MASK_MI_INT
operator|)
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_int_link_reset
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
comment|/* Reset the SerDes/XGXS */
name|REG_WR
argument_list|(
name|params
operator|->
name|sc
argument_list|,
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_3_CLEAR
argument_list|,
operator|(
literal|0x1ff
operator|<<
operator|(
name|params
operator|->
name|port
operator|*
literal|16
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_common_ext_link_reset
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint8_t
name|gpio_port
decl_stmt|;
comment|/* HW reset */
if|if
condition|(
name|CHIP_IS_E2
argument_list|(
name|sc
argument_list|)
condition|)
name|gpio_port
operator|=
name|SC_PATH
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|gpio_port
operator|=
name|params
operator|->
name|port
expr_stmt|;
name|elink_cb_gpio_write
argument_list|(
name|sc
argument_list|,
name|MISC_REGISTERS_GPIO_1
argument_list|,
name|MISC_REGISTERS_GPIO_OUTPUT_LOW
argument_list|,
name|gpio_port
argument_list|)
expr_stmt|;
name|elink_cb_gpio_write
argument_list|(
name|sc
argument_list|,
name|MISC_REGISTERS_GPIO_2
argument_list|,
name|MISC_REGISTERS_GPIO_OUTPUT_LOW
argument_list|,
name|gpio_port
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"reset external PHY\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_update_link_down
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint8_t
name|port
init|=
name|params
operator|->
name|port
decl_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Port %x: Link is down\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|elink_set_led
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
name|ELINK_LED_MODE_OFF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vars
operator|->
name|phy_flags
operator|&=
operator|~
name|PHY_PHYSICAL_LINK_FLAG
expr_stmt|;
comment|/* Indicate no mac active */
name|vars
operator|->
name|mac_type
operator|=
name|ELINK_MAC_TYPE_NONE
expr_stmt|;
comment|/* Update shared memory */
name|vars
operator|->
name|link_status
operator|&=
operator|~
name|ELINK_LINK_UPDATE_MASK
expr_stmt|;
name|vars
operator|->
name|line_speed
operator|=
literal|0
expr_stmt|;
name|elink_update_mng
argument_list|(
name|params
argument_list|,
name|vars
operator|->
name|link_status
argument_list|)
expr_stmt|;
comment|/* Activate nig drain */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_EGRESS_DRAIN0_MODE
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Disable emac */
if|if
condition|(
operator|!
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_NIG_EMAC0_EN
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
operator|*
literal|10
argument_list|)
expr_stmt|;
comment|/* Reset BigMac/Xmac */
if|if
condition|(
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
operator|||
name|CHIP_IS_E2
argument_list|(
name|sc
argument_list|)
condition|)
name|elink_set_bmac_rx
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|chip_id
argument_list|,
name|params
operator|->
name|port
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* Prevent LPI Generation by chip */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_CPMU_LP_FW_ENABLE_P0
operator|+
operator|(
name|params
operator|->
name|port
operator|<<
literal|2
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_CPMU_LP_MASK_ENT_P0
operator|+
operator|(
name|params
operator|->
name|port
operator|<<
literal|2
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vars
operator|->
name|eee_status
operator|&=
operator|~
operator|(
name|SHMEM_EEE_LP_ADV_STATUS_MASK
operator||
name|SHMEM_EEE_ACTIVE_BIT
operator|)
expr_stmt|;
name|elink_update_mng_eee
argument_list|(
name|params
argument_list|,
name|vars
operator|->
name|eee_status
argument_list|)
expr_stmt|;
name|elink_set_xmac_rxtx
argument_list|(
name|params
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|elink_set_umac_rxtx
argument_list|(
name|params
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_update_link_up
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|,
name|uint8_t
name|link_10g
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint8_t
name|phy_idx
decl_stmt|,
name|port
init|=
name|params
operator|->
name|port
decl_stmt|;
name|elink_status_t
name|rc
init|=
name|ELINK_STATUS_OK
decl_stmt|;
name|vars
operator|->
name|link_status
operator||=
operator|(
name|LINK_STATUS_LINK_UP
operator||
name|LINK_STATUS_PHYSICAL_LINK_FLAG
operator|)
expr_stmt|;
name|vars
operator|->
name|phy_flags
operator||=
name|PHY_PHYSICAL_LINK_FLAG
expr_stmt|;
if|if
condition|(
name|vars
operator|->
name|flow_ctrl
operator|&
name|ELINK_FLOW_CTRL_TX
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_TX_FLOW_CONTROL_ENABLED
expr_stmt|;
if|if
condition|(
name|vars
operator|->
name|flow_ctrl
operator|&
name|ELINK_FLOW_CTRL_RX
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_RX_FLOW_CONTROL_ENABLED
expr_stmt|;
if|if
condition|(
name|USES_WARPCORE
argument_list|(
name|sc
argument_list|)
condition|)
block|{
if|if
condition|(
name|link_10g
condition|)
block|{
if|if
condition|(
name|elink_xmac_enable
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
literal|0
argument_list|)
operator|==
name|ELINK_STATUS_NO_LINK
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Found errors on XMAC\n"
argument_list|)
expr_stmt|;
name|vars
operator|->
name|link_up
operator|=
literal|0
expr_stmt|;
name|vars
operator|->
name|phy_flags
operator||=
name|PHY_HALF_OPEN_CONN_FLAG
expr_stmt|;
name|vars
operator|->
name|link_status
operator|&=
operator|~
name|LINK_STATUS_LINK_UP
expr_stmt|;
block|}
block|}
else|else
name|elink_umac_enable
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|elink_set_led
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
name|ELINK_LED_MODE_OPER
argument_list|,
name|vars
operator|->
name|line_speed
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vars
operator|->
name|eee_status
operator|&
name|SHMEM_EEE_ACTIVE_BIT
operator|)
operator|&&
operator|(
name|vars
operator|->
name|eee_status
operator|&
name|SHMEM_EEE_LPI_REQUESTED_BIT
operator|)
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Enabling LPI assertion\n"
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_CPMU_LP_FW_ENABLE_P0
operator|+
operator|(
name|params
operator|->
name|port
operator|<<
literal|2
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_CPMU_LP_DR_ENABLE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_CPMU_LP_MASK_ENT_P0
operator|+
operator|(
name|params
operator|->
name|port
operator|<<
literal|2
operator|)
argument_list|,
literal|0xfc20
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
operator|||
name|CHIP_IS_E2
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|link_10g
condition|)
block|{
if|if
condition|(
name|elink_bmac_enable
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|==
name|ELINK_STATUS_NO_LINK
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Found errors on BMAC\n"
argument_list|)
expr_stmt|;
name|vars
operator|->
name|link_up
operator|=
literal|0
expr_stmt|;
name|vars
operator|->
name|phy_flags
operator||=
name|PHY_HALF_OPEN_CONN_FLAG
expr_stmt|;
name|vars
operator|->
name|link_status
operator|&=
operator|~
name|LINK_STATUS_LINK_UP
expr_stmt|;
block|}
name|elink_set_led
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
name|ELINK_LED_MODE_OPER
argument_list|,
name|ELINK_SPEED_10000
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
name|elink_emac_program
argument_list|(
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
name|elink_emac_enable
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* AN complete? */
if|if
condition|(
operator|(
name|vars
operator|->
name|link_status
operator|&
name|LINK_STATUS_AUTO_NEGOTIATE_COMPLETE
operator|)
operator|&&
operator|(
operator|!
operator|(
name|vars
operator|->
name|phy_flags
operator|&
name|PHY_SGMII_FLAG
operator|)
operator|)
operator|&&
name|ELINK_SINGLE_MEDIA_DIRECT
argument_list|(
name|params
argument_list|)
condition|)
name|elink_set_gmii_tx_driver
argument_list|(
name|params
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* PBF - link up */
if|if
condition|(
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
name|rc
operator||=
name|elink_pbf_update
argument_list|(
name|params
argument_list|,
name|vars
operator|->
name|flow_ctrl
argument_list|,
name|vars
operator|->
name|line_speed
argument_list|)
expr_stmt|;
comment|/* Disable drain */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_EGRESS_DRAIN0_MODE
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Update shared memory */
name|elink_update_mng
argument_list|(
name|params
argument_list|,
name|vars
operator|->
name|link_status
argument_list|)
expr_stmt|;
name|elink_update_mng_eee
argument_list|(
name|params
argument_list|,
name|vars
operator|->
name|eee_status
argument_list|)
expr_stmt|;
comment|/* Check remote fault */
for|for
control|(
name|phy_idx
operator|=
name|ELINK_INT_PHY
init|;
name|phy_idx
operator|<
name|ELINK_MAX_PHYS
condition|;
name|phy_idx
operator|++
control|)
block|{
if|if
condition|(
name|params
operator|->
name|phy
index|[
name|phy_idx
index|]
operator|.
name|flags
operator|&
name|ELINK_FLAGS_TX_ERROR_CHECK
condition|)
block|{
name|elink_check_half_open_conn
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|DELAY
argument_list|(
literal|1000
operator|*
literal|20
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_chng_link_count
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint8_t
name|clear
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint32_t
name|addr
decl_stmt|,
name|val
decl_stmt|;
comment|/* Verify the link_change_count is supported by the MFW */
if|if
condition|(
operator|!
operator|(
name|SHMEM2_HAS
argument_list|(
name|sc
argument_list|,
name|link_change_count
argument_list|)
operator|)
condition|)
return|return;
name|addr
operator|=
name|params
operator|->
name|shmem2_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem2_region
argument_list|,
name|link_change_count
index|[
name|params
operator|->
name|port
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|clear
condition|)
name|val
operator|=
literal|0
expr_stmt|;
else|else
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
operator|+
literal|1
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The elink_link_update function should be called upon link  * interrupt.  * Link is considered up as follows:  * - DIRECT_SINGLE_MEDIA - Only XGXS link (internal link) needs  *   to be up  * - SINGLE_MEDIA - The link between the 577xx and the external  *   phy (XGXS) need to up as well as the external link of the  *   phy (PHY_EXT1)  * - DUAL_MEDIA - The link between the 577xx and the first  *   external phy needs to be up, and at least one of the 2  *   external phy link must be up.  */
end_comment

begin_function
name|elink_status_t
name|elink_link_update
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|struct
name|elink_vars
name|phy_vars
index|[
name|ELINK_MAX_PHYS
index|]
decl_stmt|;
name|uint8_t
name|port
init|=
name|params
operator|->
name|port
decl_stmt|;
name|uint8_t
name|link_10g_plus
decl_stmt|,
name|phy_index
decl_stmt|;
name|uint32_t
name|prev_link_status
init|=
name|vars
operator|->
name|link_status
decl_stmt|;
name|uint8_t
name|ext_phy_link_up
init|=
literal|0
decl_stmt|,
name|cur_link_up
decl_stmt|;
name|elink_status_t
name|rc
init|=
name|ELINK_STATUS_OK
decl_stmt|;
name|uint16_t
name|ext_phy_line_speed
init|=
literal|0
decl_stmt|,
name|prev_line_speed
init|=
name|vars
operator|->
name|line_speed
decl_stmt|;
name|uint8_t
name|active_external_phy
init|=
name|ELINK_INT_PHY
decl_stmt|;
name|vars
operator|->
name|phy_flags
operator|&=
operator|~
name|PHY_HALF_OPEN_CONN_FLAG
expr_stmt|;
name|vars
operator|->
name|link_status
operator|&=
operator|~
name|ELINK_LINK_UPDATE_MASK
expr_stmt|;
for|for
control|(
name|phy_index
operator|=
name|ELINK_INT_PHY
init|;
name|phy_index
operator|<
name|params
operator|->
name|num_phys
condition|;
name|phy_index
operator|++
control|)
block|{
name|phy_vars
index|[
name|phy_index
index|]
operator|.
name|flow_ctrl
operator|=
literal|0
expr_stmt|;
name|phy_vars
index|[
name|phy_index
index|]
operator|.
name|link_status
operator|=
literal|0
expr_stmt|;
name|phy_vars
index|[
name|phy_index
index|]
operator|.
name|line_speed
operator|=
literal|0
expr_stmt|;
name|phy_vars
index|[
name|phy_index
index|]
operator|.
name|duplex
operator|=
name|DUPLEX_FULL
expr_stmt|;
name|phy_vars
index|[
name|phy_index
index|]
operator|.
name|phy_link_up
operator|=
literal|0
expr_stmt|;
name|phy_vars
index|[
name|phy_index
index|]
operator|.
name|link_up
operator|=
literal|0
expr_stmt|;
name|phy_vars
index|[
name|phy_index
index|]
operator|.
name|fault_detected
operator|=
literal|0
expr_stmt|;
comment|/* different consideration, since vars holds inner state */
name|phy_vars
index|[
name|phy_index
index|]
operator|.
name|eee_status
operator|=
name|vars
operator|->
name|eee_status
expr_stmt|;
block|}
if|if
condition|(
name|USES_WARPCORE
argument_list|(
name|sc
argument_list|)
condition|)
name|elink_set_aer_mmd
argument_list|(
name|params
argument_list|,
operator|&
name|params
operator|->
name|phy
index|[
name|ELINK_INT_PHY
index|]
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P3
argument_list|(
name|sc
argument_list|,
literal|"port %x, XGXS?%x, int_status 0x%x\n"
argument_list|,
name|port
argument_list|,
operator|(
name|vars
operator|->
name|phy_flags
operator|&
name|PHY_XGXS_FLAG
operator|)
argument_list|,
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_STATUS_INTERRUPT_PORT0
operator|+
name|port
operator|*
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P3
argument_list|(
name|sc
argument_list|,
literal|"int_mask 0x%x MI_INT %x, SERDES_LINK %x\n"
argument_list|,
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_MASK_INTERRUPT_PORT0
operator|+
name|port
operator|*
literal|4
argument_list|)
argument_list|,
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_EMAC0_STATUS_MISC_MI_INT
operator|+
name|port
operator|*
literal|0x18
argument_list|)
operator|>
literal|0
argument_list|,
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_SERDES0_STATUS_LINK_STATUS
operator|+
name|port
operator|*
literal|0x3c
argument_list|)
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|" 10G %x, XGXS_LINK %x\n"
argument_list|,
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_XGXS0_STATUS_LINK10G
operator|+
name|port
operator|*
literal|0x68
argument_list|)
argument_list|,
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_XGXS0_STATUS_LINK_STATUS
operator|+
name|port
operator|*
literal|0x68
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Disable emac */
if|if
condition|(
operator|!
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_NIG_EMAC0_EN
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Step 1: 	 * Check external link change only for external phys, and apply 	 * priority selection between them in case the link on both phys 	 * is up. Note that instead of the common vars, a temporary 	 * vars argument is used since each phy may have different link/ 	 * speed/duplex result 	 */
for|for
control|(
name|phy_index
operator|=
name|ELINK_EXT_PHY1
init|;
name|phy_index
operator|<
name|params
operator|->
name|num_phys
condition|;
name|phy_index
operator|++
control|)
block|{
name|struct
name|elink_phy
modifier|*
name|phy
init|=
operator|&
name|params
operator|->
name|phy
index|[
name|phy_index
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|phy
operator|->
name|read_status
condition|)
continue|continue;
comment|/* Read link status and params of this ext phy */
name|cur_link_up
operator|=
name|phy
operator|->
name|read_status
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
operator|&
name|phy_vars
index|[
name|phy_index
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_link_up
condition|)
block|{
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"phy in index %d link is up\n"
argument_list|,
name|phy_index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"phy in index %d link is down\n"
argument_list|,
name|phy_index
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|ext_phy_link_up
condition|)
block|{
name|ext_phy_link_up
operator|=
literal|1
expr_stmt|;
name|active_external_phy
operator|=
name|phy_index
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|elink_phy_selection
argument_list|(
name|params
argument_list|)
condition|)
block|{
case|case
name|PORT_HW_CFG_PHY_SELECTION_HARDWARE_DEFAULT
case|:
case|case
name|PORT_HW_CFG_PHY_SELECTION_FIRST_PHY_PRIORITY
case|:
comment|/* In this option, the first PHY makes sure to pass the 			 * traffic through itself only. 			 * Its not clear how to reset the link on the second phy 			 */
name|active_external_phy
operator|=
name|ELINK_EXT_PHY1
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_PHY_SELECTION_SECOND_PHY_PRIORITY
case|:
comment|/* In this option, the first PHY makes sure to pass the 			 * traffic through the second PHY. 			 */
name|active_external_phy
operator|=
name|ELINK_EXT_PHY2
expr_stmt|;
break|break;
default|default:
comment|/* Link indication on both PHYs with the following cases 			 * is invalid: 			 * - FIRST_PHY means that second phy wasn't initialized, 			 * hence its link is expected to be down 			 * - SECOND_PHY means that first phy should not be able 			 * to link up by itself (using configuration) 			 * - DEFAULT should be overriden during initialiazation 			 */
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Invalid link indication"
literal|"mpc=0x%x. DISABLING LINK !!!\n"
argument_list|,
name|params
operator|->
name|multi_phy_config
argument_list|)
expr_stmt|;
name|ext_phy_link_up
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
name|prev_line_speed
operator|=
name|vars
operator|->
name|line_speed
expr_stmt|;
comment|/* Step 2: 	 * Read the status of the internal phy. In case of 	 * DIRECT_SINGLE_MEDIA board, this link is the external link, 	 * otherwise this is the link between the 577xx and the first 	 * external phy 	 */
if|if
condition|(
name|params
operator|->
name|phy
index|[
name|ELINK_INT_PHY
index|]
operator|.
name|read_status
condition|)
name|params
operator|->
name|phy
index|[
name|ELINK_INT_PHY
index|]
operator|.
name|read_status
argument_list|(
operator|&
name|params
operator|->
name|phy
index|[
name|ELINK_INT_PHY
index|]
argument_list|,
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
comment|/* The INT_PHY flow control reside in the vars. This include the 	 * case where the speed or flow control are not set to AUTO. 	 * Otherwise, the active external phy flow control result is set 	 * to the vars. The ext_phy_line_speed is needed to check if the 	 * speed is different between the internal phy and external phy. 	 * This case may be result of intermediate link speed change. 	 */
if|if
condition|(
name|active_external_phy
operator|>
name|ELINK_INT_PHY
condition|)
block|{
name|vars
operator|->
name|flow_ctrl
operator|=
name|phy_vars
index|[
name|active_external_phy
index|]
operator|.
name|flow_ctrl
expr_stmt|;
comment|/* Link speed is taken from the XGXS. AN and FC result from 		 * the external phy. 		 */
name|vars
operator|->
name|link_status
operator||=
name|phy_vars
index|[
name|active_external_phy
index|]
operator|.
name|link_status
expr_stmt|;
comment|/* if active_external_phy is first PHY and link is up - disable 		 * disable TX on second external PHY 		 */
if|if
condition|(
name|active_external_phy
operator|==
name|ELINK_EXT_PHY1
condition|)
block|{
if|if
condition|(
name|params
operator|->
name|phy
index|[
name|ELINK_EXT_PHY2
index|]
operator|.
name|phy_specific_func
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Disabling TX on EXT_PHY2\n"
argument_list|)
expr_stmt|;
name|params
operator|->
name|phy
index|[
name|ELINK_EXT_PHY2
index|]
operator|.
name|phy_specific_func
argument_list|(
operator|&
name|params
operator|->
name|phy
index|[
name|ELINK_EXT_PHY2
index|]
argument_list|,
name|params
argument_list|,
name|ELINK_DISABLE_TX
argument_list|)
expr_stmt|;
block|}
block|}
name|ext_phy_line_speed
operator|=
name|phy_vars
index|[
name|active_external_phy
index|]
operator|.
name|line_speed
expr_stmt|;
name|vars
operator|->
name|duplex
operator|=
name|phy_vars
index|[
name|active_external_phy
index|]
operator|.
name|duplex
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|phy
index|[
name|active_external_phy
index|]
operator|.
name|supported
operator|&
name|ELINK_SUPPORTED_FIBRE
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_SERDES_LINK
expr_stmt|;
else|else
name|vars
operator|->
name|link_status
operator|&=
operator|~
name|LINK_STATUS_SERDES_LINK
expr_stmt|;
name|vars
operator|->
name|eee_status
operator|=
name|phy_vars
index|[
name|active_external_phy
index|]
operator|.
name|eee_status
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Active external phy selected: %x\n"
argument_list|,
name|active_external_phy
argument_list|)
expr_stmt|;
block|}
name|ELINK_DEBUG_P3
argument_list|(
name|sc
argument_list|,
literal|"vars : phy_flags = %x, mac_type = %x, phy_link_up = %x\n"
argument_list|,
name|vars
operator|->
name|phy_flags
argument_list|,
name|vars
operator|->
name|mac_type
argument_list|,
name|vars
operator|->
name|phy_link_up
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P3
argument_list|(
name|sc
argument_list|,
literal|"vars : link_up = %x, line_speed = %x, duplex = %x\n"
argument_list|,
name|vars
operator|->
name|link_up
argument_list|,
name|vars
operator|->
name|line_speed
argument_list|,
name|vars
operator|->
name|duplex
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P3
argument_list|(
name|sc
argument_list|,
literal|"vars : flow_ctrl = %x, ieee_fc = %x, link_status = %x\n"
argument_list|,
name|vars
operator|->
name|flow_ctrl
argument_list|,
name|vars
operator|->
name|ieee_fc
argument_list|,
name|vars
operator|->
name|link_status
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P3
argument_list|(
name|sc
argument_list|,
literal|"vars : eee_status = %x, fault_detected = %x, check_kr2_recovery_cnt = %x\n"
argument_list|,
name|vars
operator|->
name|eee_status
argument_list|,
name|vars
operator|->
name|fault_detected
argument_list|,
name|vars
operator|->
name|check_kr2_recovery_cnt
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P3
argument_list|(
name|sc
argument_list|,
literal|"vars : periodic_flags = %x, aeu_int_mask = %x, rx_tx_asic_rst = %x\n"
argument_list|,
name|vars
operator|->
name|periodic_flags
argument_list|,
name|vars
operator|->
name|aeu_int_mask
argument_list|,
name|vars
operator|->
name|rx_tx_asic_rst
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"vars : turn_to_run_wc_rt = %x, rsrv2 = %x\n"
argument_list|,
name|vars
operator|->
name|turn_to_run_wc_rt
argument_list|,
name|vars
operator|->
name|rsrv2
argument_list|)
expr_stmt|;
for|for
control|(
name|phy_index
operator|=
name|ELINK_EXT_PHY1
init|;
name|phy_index
operator|<
name|params
operator|->
name|num_phys
condition|;
name|phy_index
operator|++
control|)
block|{
if|if
condition|(
name|params
operator|->
name|phy
index|[
name|phy_index
index|]
operator|.
name|flags
operator|&
name|ELINK_FLAGS_REARM_LATCH_SIGNAL
condition|)
block|{
name|elink_rearm_latch_signal
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|phy_index
operator|==
name|active_external_phy
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|ELINK_DEBUG_P3
argument_list|(
name|sc
argument_list|,
literal|"vars->flow_ctrl = 0x%x, vars->link_status = 0x%x,"
literal|" ext_phy_line_speed = %d\n"
argument_list|,
name|vars
operator|->
name|flow_ctrl
argument_list|,
name|vars
operator|->
name|link_status
argument_list|,
name|ext_phy_line_speed
argument_list|)
expr_stmt|;
comment|/* Upon link speed change set the NIG into drain mode. Comes to 	 * deals with possible FIFO glitch due to clk change when speed 	 * is decreased without link down indicator 	 */
if|if
condition|(
name|vars
operator|->
name|phy_link_up
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ELINK_SINGLE_MEDIA_DIRECT
argument_list|(
name|params
argument_list|)
operator|)
operator|&&
name|ext_phy_link_up
operator|&&
operator|(
name|ext_phy_line_speed
operator|!=
name|vars
operator|->
name|line_speed
operator|)
condition|)
block|{
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"Internal link speed %d is"
literal|" different than the external"
literal|" link speed %d\n"
argument_list|,
name|vars
operator|->
name|line_speed
argument_list|,
name|ext_phy_line_speed
argument_list|)
expr_stmt|;
name|vars
operator|->
name|phy_link_up
operator|=
literal|0
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"phy_link_up set to 0\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prev_line_speed
operator|!=
name|vars
operator|->
name|line_speed
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_EGRESS_DRAIN0_MODE
operator|+
name|params
operator|->
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
operator|*
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Anything 10 and over uses the bmac */
name|link_10g_plus
operator|=
operator|(
name|vars
operator|->
name|line_speed
operator|>=
name|ELINK_SPEED_10000
operator|)
expr_stmt|;
name|elink_link_int_ack
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
name|link_10g_plus
argument_list|)
expr_stmt|;
comment|/* In case external phy link is up, and internal link is down 	 * (not initialized yet probably after link initialization, it 	 * needs to be initialized. 	 * Note that after link down-up as result of cable plug, the xgxs 	 * link would probably become up again without the need 	 * initialize it 	 */
if|if
condition|(
operator|!
operator|(
name|ELINK_SINGLE_MEDIA_DIRECT
argument_list|(
name|params
argument_list|)
operator|)
condition|)
block|{
name|ELINK_DEBUG_P3
argument_list|(
name|sc
argument_list|,
literal|"ext_phy_link_up = %d, int_link_up = %d,"
literal|" init_preceding = %d\n"
argument_list|,
name|ext_phy_link_up
argument_list|,
name|vars
operator|->
name|phy_link_up
argument_list|,
name|params
operator|->
name|phy
index|[
name|ELINK_EXT_PHY1
index|]
operator|.
name|flags
operator|&
name|ELINK_FLAGS_INIT_XGXS_FIRST
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|params
operator|->
name|phy
index|[
name|ELINK_EXT_PHY1
index|]
operator|.
name|flags
operator|&
name|ELINK_FLAGS_INIT_XGXS_FIRST
operator|)
operator|&&
name|ext_phy_link_up
operator|&&
operator|!
name|vars
operator|->
name|phy_link_up
condition|)
block|{
name|vars
operator|->
name|line_speed
operator|=
name|ext_phy_line_speed
expr_stmt|;
if|if
condition|(
name|vars
operator|->
name|line_speed
operator|<
name|ELINK_SPEED_1000
condition|)
name|vars
operator|->
name|phy_flags
operator||=
name|PHY_SGMII_FLAG
expr_stmt|;
else|else
name|vars
operator|->
name|phy_flags
operator|&=
operator|~
name|PHY_SGMII_FLAG
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|phy
index|[
name|ELINK_INT_PHY
index|]
operator|.
name|config_init
condition|)
name|params
operator|->
name|phy
index|[
name|ELINK_INT_PHY
index|]
operator|.
name|config_init
argument_list|(
operator|&
name|params
operator|->
name|phy
index|[
name|ELINK_INT_PHY
index|]
argument_list|,
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Link is up only if both local phy and external phy (in case of 	 * non-direct board) are up and no fault detected on active PHY. 	 */
name|vars
operator|->
name|link_up
operator|=
operator|(
name|vars
operator|->
name|phy_link_up
operator|&&
operator|(
name|ext_phy_link_up
operator|||
name|ELINK_SINGLE_MEDIA_DIRECT
argument_list|(
name|params
argument_list|)
operator|)
operator|&&
operator|(
name|phy_vars
index|[
name|active_external_phy
index|]
operator|.
name|fault_detected
operator|==
literal|0
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|vars
operator|->
name|link_up
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"local phy and external phy are up\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"either local phy or external phy or both are down\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Update the PFC configuration in case it was changed */
if|if
condition|(
name|params
operator|->
name|feature_config_flags
operator|&
name|ELINK_FEATURE_CONFIG_PFC_ENABLED
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_PFC_ENABLED
expr_stmt|;
else|else
name|vars
operator|->
name|link_status
operator|&=
operator|~
name|LINK_STATUS_PFC_ENABLED
expr_stmt|;
if|if
condition|(
name|vars
operator|->
name|link_up
condition|)
name|rc
operator|=
name|elink_update_link_up
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
name|link_10g_plus
argument_list|)
expr_stmt|;
else|else
name|rc
operator|=
name|elink_update_link_down
argument_list|(
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|prev_link_status
operator|^
name|vars
operator|->
name|link_status
operator|)
operator|&
name|LINK_STATUS_LINK_UP
condition|)
name|elink_chng_link_count
argument_list|(
name|params
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Update MCP link status was changed */
if|if
condition|(
name|params
operator|->
name|feature_config_flags
operator|&
name|ELINK_FEATURE_CONFIG_BC_SUPPORTS_AFEX
condition|)
name|elink_cb_fw_command
argument_list|(
name|sc
argument_list|,
name|DRV_MSG_CODE_LINK_STATUS_CHANGED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*			    External Phy section			     */
end_comment

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|void
name|elink_ext_phy_hw_reset
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|port
parameter_list|)
block|{
name|elink_cb_gpio_write
argument_list|(
name|sc
argument_list|,
name|MISC_REGISTERS_GPIO_1
argument_list|,
name|MISC_REGISTERS_GPIO_OUTPUT_LOW
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
operator|*
literal|1
argument_list|)
expr_stmt|;
name|elink_cb_gpio_write
argument_list|(
name|sc
argument_list|,
name|MISC_REGISTERS_GPIO_1
argument_list|,
name|MISC_REGISTERS_GPIO_OUTPUT_HIGH
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_save_spirom_version
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|port
parameter_list|,
name|uint32_t
name|spirom_ver
parameter_list|,
name|uint32_t
name|ver_addr
parameter_list|)
block|{
name|ELINK_DEBUG_P3
argument_list|(
name|sc
argument_list|,
literal|"FW version 0x%x:0x%x for port %d\n"
argument_list|,
call|(
name|uint16_t
call|)
argument_list|(
name|spirom_ver
operator|>>
literal|16
argument_list|)
argument_list|,
operator|(
name|uint16_t
operator|)
name|spirom_ver
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|ver_addr
condition|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|ver_addr
argument_list|,
name|spirom_ver
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_save_bcm_spirom_ver
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|uint8_t
name|port
parameter_list|)
block|{
name|uint16_t
name|fw_ver1
decl_stmt|,
name|fw_ver2
decl_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_ROM_VER1
argument_list|,
operator|&
name|fw_ver1
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_ROM_VER2
argument_list|,
operator|&
name|fw_ver2
argument_list|)
expr_stmt|;
name|elink_save_spirom_version
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|fw_ver1
operator|<<
literal|16
operator||
name|fw_ver2
argument_list|)
argument_list|,
name|phy
operator|->
name|ver_addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_ext_phy_10G_an_resolve
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|uint16_t
name|val
decl_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_STATUS
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_STATUS
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_AUTO_NEGOTIATE_COMPLETE
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
operator|)
operator|==
literal|0
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_PARALLEL_DETECTION_USED
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************/
end_comment

begin_comment
comment|/*		common BCM8073/BCM8727 PHY SECTION		  */
end_comment

begin_comment
comment|/******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|elink_8073_resolve_fc
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
if|if
condition|(
name|phy
operator|->
name|req_line_speed
operator|==
name|ELINK_SPEED_10
operator|||
name|phy
operator|->
name|req_line_speed
operator|==
name|ELINK_SPEED_100
condition|)
block|{
name|vars
operator|->
name|flow_ctrl
operator|=
name|phy
operator|->
name|req_flow_ctrl
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|elink_ext_phy_resolve_fc
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|)
operator|&&
operator|(
name|vars
operator|->
name|flow_ctrl
operator|==
name|ELINK_FLOW_CTRL_NONE
operator|)
condition|)
block|{
name|uint16_t
name|pause_result
decl_stmt|;
name|uint16_t
name|ld_pause
decl_stmt|;
comment|/* local */
name|uint16_t
name|lp_pause
decl_stmt|;
comment|/* link partner */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_CL37_FC_LD
argument_list|,
operator|&
name|ld_pause
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_CL37_FC_LP
argument_list|,
operator|&
name|lp_pause
argument_list|)
expr_stmt|;
name|pause_result
operator|=
operator|(
name|ld_pause
operator|&
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH
operator|)
operator|>>
literal|5
expr_stmt|;
name|pause_result
operator||=
operator|(
name|lp_pause
operator|&
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH
operator|)
operator|>>
literal|7
expr_stmt|;
name|elink_pause_resolve
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|,
name|pause_result
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Ext PHY CL37 pause result 0x%x\n"
argument_list|,
name|pause_result
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_8073_8727_external_rom_boot
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|uint8_t
name|port
parameter_list|)
block|{
name|uint32_t
name|count
init|=
literal|0
decl_stmt|;
name|uint16_t
name|fw_ver1
decl_stmt|,
name|fw_msgout
decl_stmt|;
name|elink_status_t
name|rc
init|=
name|ELINK_STATUS_OK
decl_stmt|;
comment|/* Boot port from external ROM  */
comment|/* EDC grst */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_GEN_CTRL
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
comment|/* Ucode reboot and rst */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_GEN_CTRL
argument_list|,
literal|0x008c
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_MISC_CTRL1
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
comment|/* Reset internal microprocessor */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_GEN_CTRL
argument_list|,
name|MDIO_PMA_REG_GEN_CTRL_ROM_MICRO_RESET
argument_list|)
expr_stmt|;
comment|/* Release srst bit */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_GEN_CTRL
argument_list|,
name|MDIO_PMA_REG_GEN_CTRL_ROM_RESET_INTERNAL_MP
argument_list|)
expr_stmt|;
comment|/* Delay 100ms per the PHY specifications */
name|DELAY
argument_list|(
literal|1000
operator|*
literal|100
argument_list|)
expr_stmt|;
comment|/* 8073 sometimes taking longer to download */
do|do
block|{
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|300
condition|)
block|{
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"elink_8073_8727_external_rom_boot port %x:"
literal|"Download failed. fw version = 0x%x\n"
argument_list|,
name|port
argument_list|,
name|fw_ver1
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ELINK_STATUS_ERROR
expr_stmt|;
break|break;
block|}
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_ROM_VER1
argument_list|,
operator|&
name|fw_ver1
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_M8051_MSGOUT_REG
argument_list|,
operator|&
name|fw_msgout
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
operator|*
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|fw_ver1
operator|==
literal|0
operator|||
name|fw_ver1
operator|==
literal|0x4321
operator|||
operator|(
operator|(
name|fw_msgout
operator|&
literal|0xff
operator|)
operator|!=
literal|0x03
operator|&&
operator|(
name|phy
operator|->
name|type
operator|==
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073
operator|)
operator|)
condition|)
do|;
comment|/* Clear ser_boot_ctl bit */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_MISC_CTRL1
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
name|elink_save_bcm_spirom_ver
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"elink_8073_8727_external_rom_boot port %x:"
literal|"Download complete. fw version = 0x%x\n"
argument_list|,
name|port
argument_list|,
name|fw_ver1
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/******************************************************************/
end_comment

begin_comment
comment|/*			BCM8073 PHY SECTION			  */
end_comment

begin_comment
comment|/******************************************************************/
end_comment

begin_function
specifier|static
name|elink_status_t
name|elink_8073_is_snr_needed
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|)
block|{
comment|/* This is only required for 8073A1, version 102 only */
name|uint16_t
name|val
decl_stmt|;
comment|/* Read 8073 HW revision*/
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8073_CHIP_REV
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|1
condition|)
block|{
comment|/* No need to workaround in 8073 A1 */
return|return
name|ELINK_STATUS_OK
return|;
block|}
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_ROM_VER2
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
comment|/* SNR should be applied only for version 0x102 */
if|if
condition|(
name|val
operator|!=
literal|0x102
condition|)
return|return
name|ELINK_STATUS_OK
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_8073_xaui_wa
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|)
block|{
name|uint16_t
name|val
decl_stmt|,
name|cnt
decl_stmt|,
name|cnt1
decl_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8073_CHIP_REV
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|>
literal|0
condition|)
block|{
comment|/* No need to workaround in 8073 A1 */
return|return
name|ELINK_STATUS_OK
return|;
block|}
comment|/* XAUI workaround in 8073 A0: */
comment|/* After loading the boot ROM and restarting Autoneg, poll 	 * Dev1, Reg $C820: 	 */
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
literal|1000
condition|;
name|cnt
operator|++
control|)
block|{
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8073_SPEED_LINK_STATUS
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
comment|/* If bit [14] = 0 or bit [13] = 0, continue on with 		   * system initialization (XAUI work-around not required, as 		   * these bits indicate 2.5G or 1G link up). 		   */
if|if
condition|(
operator|!
operator|(
name|val
operator|&
operator|(
literal|1
operator|<<
literal|14
operator|)
operator|)
operator|||
operator|!
operator|(
name|val
operator|&
operator|(
literal|1
operator|<<
literal|13
operator|)
operator|)
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"XAUI work-around not required\n"
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|val
operator|&
operator|(
literal|1
operator|<<
literal|15
operator|)
operator|)
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"bit 15 went off\n"
argument_list|)
expr_stmt|;
comment|/* If bit 15 is 0, then poll Dev1, Reg $C841 until it's 			 * MSB (bit15) goes to 1 (indicating that the XAUI 			 * workaround has completed), then continue on with 			 * system initialization. 			 */
for|for
control|(
name|cnt1
operator|=
literal|0
init|;
name|cnt1
operator|<
literal|1000
condition|;
name|cnt1
operator|++
control|)
block|{
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8073_XAUI_WA
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
operator|(
literal|1
operator|<<
literal|15
operator|)
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"XAUI workaround has completed\n"
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
name|DELAY
argument_list|(
literal|1000
operator|*
literal|3
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|DELAY
argument_list|(
literal|1000
operator|*
literal|3
argument_list|)
expr_stmt|;
block|}
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Warning: XAUI work-around timeout !!!\n"
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_807x_force_10G
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|)
block|{
comment|/* Force KR or KX */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_CTRL
argument_list|,
literal|0x2040
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_10G_CTRL2
argument_list|,
literal|0x000b
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_BCM_CTRL
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_CTRL
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_8073_set_pause_cl37
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|uint16_t
name|cl37_val
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_CL37_FC_LD
argument_list|,
operator|&
name|cl37_val
argument_list|)
expr_stmt|;
name|cl37_val
operator|&=
operator|~
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH
expr_stmt|;
comment|/* Please refer to Table 28B-3 of 802.3ab-1999 spec. */
name|elink_calc_ieee_aneg_adv
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
operator|&
name|vars
operator|->
name|ieee_fc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vars
operator|->
name|ieee_fc
operator|&
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_SYMMETRIC
operator|)
operator|==
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_SYMMETRIC
condition|)
block|{
name|cl37_val
operator||=
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_SYMMETRIC
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|vars
operator|->
name|ieee_fc
operator|&
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC
operator|)
operator|==
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC
condition|)
block|{
name|cl37_val
operator||=
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|vars
operator|->
name|ieee_fc
operator|&
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH
operator|)
operator|==
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH
condition|)
block|{
name|cl37_val
operator||=
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH
expr_stmt|;
block|}
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Ext phy AN advertize cl37 0x%x\n"
argument_list|,
name|cl37_val
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_CL37_FC_LD
argument_list|,
name|cl37_val
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
operator|*
literal|500
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_8073_specific_func
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint32_t
name|action
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|ELINK_PHY_INIT
case|:
comment|/* Enable LASI */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_LASI_RXCTRL
argument_list|,
operator|(
literal|1
operator|<<
literal|2
operator|)
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_LASI_CTRL
argument_list|,
literal|0x0004
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_8073_config_init
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint16_t
name|val
init|=
literal|0
decl_stmt|,
name|tmp1
decl_stmt|;
name|uint8_t
name|gpio_port
decl_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Init 8073\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E2
argument_list|(
name|sc
argument_list|)
condition|)
name|gpio_port
operator|=
name|SC_PATH
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|gpio_port
operator|=
name|params
operator|->
name|port
expr_stmt|;
comment|/* Restore normal power mode*/
name|elink_cb_gpio_write
argument_list|(
name|sc
argument_list|,
name|MISC_REGISTERS_GPIO_2
argument_list|,
name|MISC_REGISTERS_GPIO_OUTPUT_HIGH
argument_list|,
name|gpio_port
argument_list|)
expr_stmt|;
name|elink_cb_gpio_write
argument_list|(
name|sc
argument_list|,
name|MISC_REGISTERS_GPIO_1
argument_list|,
name|MISC_REGISTERS_GPIO_OUTPUT_HIGH
argument_list|,
name|gpio_port
argument_list|)
expr_stmt|;
name|elink_8073_specific_func
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|ELINK_PHY_INIT
argument_list|)
expr_stmt|;
name|elink_8073_set_pause_cl37
argument_list|(
name|params
argument_list|,
name|phy
argument_list|,
name|vars
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_M8051_MSGOUT_REG
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_LASI_RXSTAT
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Before rom RX_ALARM(port1): 0x%x\n"
argument_list|,
name|tmp1
argument_list|)
expr_stmt|;
comment|/* Swap polarity if required - Must be done only in non-1G mode */
if|if
condition|(
name|params
operator|->
name|lane_config
operator|&
name|PORT_HW_CFG_SWAP_PHY_POLARITY_ENABLED
condition|)
block|{
comment|/* Configure the 8073 to swap _P and _N of the KR lines */
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Swapping polarity for the 8073\n"
argument_list|)
expr_stmt|;
comment|/* 10G Rx/Tx and 1G Tx signal polarity swap */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8073_OPT_DIGITAL_CTRL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8073_OPT_DIGITAL_CTRL
argument_list|,
operator|(
name|val
operator||
operator|(
literal|3
operator|<<
literal|9
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Enable CL37 BAM */
if|if
condition|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|params
operator|->
name|port
index|]
operator|.
name|default_cfg
argument_list|)
argument_list|)
operator|&
name|PORT_HW_CFG_ENABLE_BAM_ON_KR_ENABLED
condition|)
block|{
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_8073_BAM
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_8073_BAM
argument_list|,
name|val
operator||
literal|1
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Enable CL37 BAM on KR\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|params
operator|->
name|loopback_mode
operator|==
name|ELINK_LOOPBACK_EXT
condition|)
block|{
name|elink_807x_force_10G
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Forced speed 10G on 807X\n"
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
else|else
block|{
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_BCM_CTRL
argument_list|,
literal|0x0002
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|phy
operator|->
name|req_line_speed
operator|!=
name|ELINK_SPEED_AUTO_NEG
condition|)
block|{
if|if
condition|(
name|phy
operator|->
name|req_line_speed
operator|==
name|ELINK_SPEED_10000
condition|)
block|{
name|val
operator|=
operator|(
literal|1
operator|<<
literal|7
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|phy
operator|->
name|req_line_speed
operator|==
name|ELINK_SPEED_2500
condition|)
block|{
name|val
operator|=
operator|(
literal|1
operator|<<
literal|5
operator|)
expr_stmt|;
comment|/* Note that 2.5G works only when used with 1G 			 * advertisement 			 */
block|}
else|else
name|val
operator|=
operator|(
literal|1
operator|<<
literal|5
operator|)
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|speed_cap_mask
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_10G
condition|)
name|val
operator||=
operator|(
literal|1
operator|<<
literal|7
operator|)
expr_stmt|;
comment|/* Note that 2.5G works only when used with 1G advertisement */
if|if
condition|(
name|phy
operator|->
name|speed_cap_mask
operator|&
operator|(
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_1G
operator||
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_2_5G
operator|)
condition|)
name|val
operator||=
operator|(
literal|1
operator|<<
literal|5
operator|)
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"807x autoneg val = 0x%x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_ADV
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_8073_2_5G
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|phy
operator|->
name|speed_cap_mask
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_2_5G
operator|)
operator|&&
operator|(
name|phy
operator|->
name|req_line_speed
operator|==
name|ELINK_SPEED_AUTO_NEG
operator|)
operator|)
operator|||
operator|(
name|phy
operator|->
name|req_line_speed
operator|==
name|ELINK_SPEED_2500
operator|)
condition|)
block|{
name|uint16_t
name|phy_ver
decl_stmt|;
comment|/* Allow 2.5G for A1 and above */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8073_CHIP_REV
argument_list|,
operator|&
name|phy_ver
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Add 2.5G\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_ver
operator|>
literal|0
condition|)
name|tmp1
operator||=
literal|1
expr_stmt|;
else|else
name|tmp1
operator|&=
literal|0xfffe
expr_stmt|;
block|}
else|else
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Disable 2.5G\n"
argument_list|)
expr_stmt|;
name|tmp1
operator|&=
literal|0xfffe
expr_stmt|;
block|}
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_8073_2_5G
argument_list|,
name|tmp1
argument_list|)
expr_stmt|;
comment|/* Add support for CL37 (passive mode) II */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_CL37_FC_LD
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_CL37_FC_LD
argument_list|,
operator|(
name|tmp1
operator||
operator|(
operator|(
name|phy
operator|->
name|req_duplex
operator|==
name|DUPLEX_FULL
operator|)
condition|?
literal|0x20
else|:
literal|0x40
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Add support for CL37 (passive mode) III */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_CL37_AN
argument_list|,
literal|0x1000
argument_list|)
expr_stmt|;
comment|/* The SNR will improve about 2db by changing BW and FEE main 	 * tap. Rest commands are executed after link is up 	 * Change FFE main cursor to 5 in EDC register 	 */
if|if
condition|(
name|elink_8073_is_snr_needed
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|)
condition|)
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_EDC_FFE_MAIN
argument_list|,
literal|0xFB0C
argument_list|)
expr_stmt|;
comment|/* Enable FEC (Forware Error Correction) Request in the AN */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_ADV2
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|tmp1
operator||=
operator|(
literal|1
operator|<<
literal|15
operator|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_ADV2
argument_list|,
name|tmp1
argument_list|)
expr_stmt|;
name|elink_ext_phy_set_pause
argument_list|(
name|params
argument_list|,
name|phy
argument_list|,
name|vars
argument_list|)
expr_stmt|;
comment|/* Restart autoneg */
name|DELAY
argument_list|(
literal|1000
operator|*
literal|500
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_CTRL
argument_list|,
literal|0x1200
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"807x Autoneg Restart: Advertise 1G=%x, 10G=%x\n"
argument_list|,
operator|(
operator|(
name|val
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
operator|)
operator|>
literal|0
operator|)
argument_list|,
operator|(
operator|(
name|val
operator|&
operator|(
literal|1
operator|<<
literal|7
operator|)
operator|)
operator|>
literal|0
operator|)
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|elink_8073_read_status
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint8_t
name|link_up
init|=
literal|0
decl_stmt|;
name|uint16_t
name|val1
decl_stmt|,
name|val2
decl_stmt|;
name|uint16_t
name|link_status
init|=
literal|0
decl_stmt|;
name|uint16_t
name|an1000_status
init|=
literal|0
decl_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_LASI_STAT
argument_list|,
operator|&
name|val1
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"8703 LASI status 0x%x\n"
argument_list|,
name|val1
argument_list|)
expr_stmt|;
comment|/* Clear the interrupt LASI status register */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PCS_DEVAD
argument_list|,
name|MDIO_PCS_REG_STATUS
argument_list|,
operator|&
name|val2
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PCS_DEVAD
argument_list|,
name|MDIO_PCS_REG_STATUS
argument_list|,
operator|&
name|val1
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"807x PCS status 0x%x->0x%x\n"
argument_list|,
name|val2
argument_list|,
name|val1
argument_list|)
expr_stmt|;
comment|/* Clear MSG-OUT */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_M8051_MSGOUT_REG
argument_list|,
operator|&
name|val1
argument_list|)
expr_stmt|;
comment|/* Check the LASI */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_LASI_RXSTAT
argument_list|,
operator|&
name|val2
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"KR 0x9003 0x%x\n"
argument_list|,
name|val2
argument_list|)
expr_stmt|;
comment|/* Check the link status */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PCS_DEVAD
argument_list|,
name|MDIO_PCS_REG_STATUS
argument_list|,
operator|&
name|val2
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"KR PCS status 0x%x\n"
argument_list|,
name|val2
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_STATUS
argument_list|,
operator|&
name|val2
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_STATUS
argument_list|,
operator|&
name|val1
argument_list|)
expr_stmt|;
name|link_up
operator|=
operator|(
operator|(
name|val1
operator|&
literal|4
operator|)
operator|==
literal|4
operator|)
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"PMA_REG_STATUS=0x%x\n"
argument_list|,
name|val1
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_up
operator|&&
operator|(
operator|(
name|phy
operator|->
name|req_line_speed
operator|!=
name|ELINK_SPEED_10000
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|elink_8073_xaui_wa
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
block|}
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_LINK_STATUS
argument_list|,
operator|&
name|an1000_status
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_LINK_STATUS
argument_list|,
operator|&
name|an1000_status
argument_list|)
expr_stmt|;
comment|/* Check the link status on 1.1.2 */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_STATUS
argument_list|,
operator|&
name|val2
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_STATUS
argument_list|,
operator|&
name|val1
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P3
argument_list|(
name|sc
argument_list|,
literal|"KR PMA status 0x%x->0x%x,"
literal|"an_link_status=0x%x\n"
argument_list|,
name|val2
argument_list|,
name|val1
argument_list|,
name|an1000_status
argument_list|)
expr_stmt|;
name|link_up
operator|=
operator|(
operator|(
operator|(
name|val1
operator|&
literal|4
operator|)
operator|==
literal|4
operator|)
operator|||
operator|(
name|an1000_status
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|link_up
operator|&&
name|elink_8073_is_snr_needed
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|)
condition|)
block|{
comment|/* The SNR will improve about 2dbby changing the BW and FEE main 		 * tap. The 1st write to change FFE main tap is set before 		 * restart AN. Change PLL Bandwidth in EDC register 		 */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_PLL_BANDWIDTH
argument_list|,
literal|0x26BC
argument_list|)
expr_stmt|;
comment|/* Change CDR Bandwidth in EDC register */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_CDR_BANDWIDTH
argument_list|,
literal|0x0333
argument_list|)
expr_stmt|;
block|}
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8073_SPEED_LINK_STATUS
argument_list|,
operator|&
name|link_status
argument_list|)
expr_stmt|;
comment|/* Bits 0..2 --> speed detected, bits 13..15--> link is down */
if|if
condition|(
operator|(
name|link_status
operator|&
operator|(
literal|1
operator|<<
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|link_status
operator|&
operator|(
literal|1
operator|<<
literal|15
operator|)
operator|)
operator|)
condition|)
block|{
name|link_up
operator|=
literal|1
expr_stmt|;
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_10000
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"port %x: External link up in 10G\n"
argument_list|,
name|params
operator|->
name|port
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|link_status
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|link_status
operator|&
operator|(
literal|1
operator|<<
literal|14
operator|)
operator|)
operator|)
condition|)
block|{
name|link_up
operator|=
literal|1
expr_stmt|;
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_2500
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"port %x: External link up in 2.5G\n"
argument_list|,
name|params
operator|->
name|port
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|link_status
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|link_status
operator|&
operator|(
literal|1
operator|<<
literal|13
operator|)
operator|)
operator|)
condition|)
block|{
name|link_up
operator|=
literal|1
expr_stmt|;
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_1000
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"port %x: External link up in 1G\n"
argument_list|,
name|params
operator|->
name|port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|link_up
operator|=
literal|0
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"port %x: External link is down\n"
argument_list|,
name|params
operator|->
name|port
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|link_up
condition|)
block|{
comment|/* Swap polarity if required */
if|if
condition|(
name|params
operator|->
name|lane_config
operator|&
name|PORT_HW_CFG_SWAP_PHY_POLARITY_ENABLED
condition|)
block|{
comment|/* Configure the 8073 to swap P and N of the KR lines */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_XS_DEVAD
argument_list|,
name|MDIO_XS_REG_8073_RX_CTRL_PCIE
argument_list|,
operator|&
name|val1
argument_list|)
expr_stmt|;
comment|/* Set bit 3 to invert Rx in 1G mode and clear this bit 			 * when it`s in 10G mode. 			 */
if|if
condition|(
name|vars
operator|->
name|line_speed
operator|==
name|ELINK_SPEED_1000
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Swapping 1G polarity for"
literal|"the 8073\n"
argument_list|)
expr_stmt|;
name|val1
operator||=
operator|(
literal|1
operator|<<
literal|3
operator|)
expr_stmt|;
block|}
else|else
name|val1
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|3
operator|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_XS_DEVAD
argument_list|,
name|MDIO_XS_REG_8073_RX_CTRL_PCIE
argument_list|,
name|val1
argument_list|)
expr_stmt|;
block|}
name|elink_ext_phy_10G_an_resolve
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|vars
argument_list|)
expr_stmt|;
name|elink_8073_resolve_fc
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
name|vars
operator|->
name|duplex
operator|=
name|DUPLEX_FULL
expr_stmt|;
block|}
if|if
condition|(
name|vars
operator|->
name|link_status
operator|&
name|LINK_STATUS_AUTO_NEGOTIATE_COMPLETE
condition|)
block|{
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_LP_AUTO_NEG2
argument_list|,
operator|&
name|val1
argument_list|)
expr_stmt|;
if|if
condition|(
name|val1
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_LINK_PARTNER_1000TFD_CAPABLE
expr_stmt|;
if|if
condition|(
name|val1
operator|&
operator|(
literal|1
operator|<<
literal|7
operator|)
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_LINK_PARTNER_10GXFD_CAPABLE
expr_stmt|;
block|}
return|return
name|link_up
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_8073_link_reset
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint8_t
name|gpio_port
decl_stmt|;
if|if
condition|(
name|CHIP_IS_E2
argument_list|(
name|sc
argument_list|)
condition|)
name|gpio_port
operator|=
name|SC_PATH
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|gpio_port
operator|=
name|params
operator|->
name|port
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Setting 8073 port %d into low power mode\n"
argument_list|,
name|gpio_port
argument_list|)
expr_stmt|;
name|elink_cb_gpio_write
argument_list|(
name|sc
argument_list|,
name|MISC_REGISTERS_GPIO_2
argument_list|,
name|MISC_REGISTERS_GPIO_OUTPUT_LOW
argument_list|,
name|gpio_port
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************/
end_comment

begin_comment
comment|/*			BCM8705 PHY SECTION			  */
end_comment

begin_comment
comment|/******************************************************************/
end_comment

begin_function
specifier|static
name|elink_status_t
name|elink_8705_config_init
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"init 8705\n"
argument_list|)
expr_stmt|;
comment|/* Restore normal power mode*/
name|elink_cb_gpio_write
argument_list|(
name|sc
argument_list|,
name|MISC_REGISTERS_GPIO_2
argument_list|,
name|MISC_REGISTERS_GPIO_OUTPUT_HIGH
argument_list|,
name|params
operator|->
name|port
argument_list|)
expr_stmt|;
comment|/* HW reset */
name|elink_ext_phy_hw_reset
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|port
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_CTRL
argument_list|,
literal|0xa040
argument_list|)
expr_stmt|;
name|elink_wait_reset_complete
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_MISC_CTRL
argument_list|,
literal|0x8288
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_PHY_IDENTIFIER
argument_list|,
literal|0x7fbf
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_CMU_PLL_BYPASS
argument_list|,
literal|0x0100
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WIS_DEVAD
argument_list|,
name|MDIO_WIS_REG_LASI_CNTL
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
comment|/* BCM8705 doesn't have microcode, hence the 0 */
name|elink_save_spirom_version
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|port
argument_list|,
name|params
operator|->
name|shmem_base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|elink_8705_read_status
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|uint8_t
name|link_up
init|=
literal|0
decl_stmt|;
name|uint16_t
name|val1
decl_stmt|,
name|rx_sd
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"read status 8705\n"
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WIS_DEVAD
argument_list|,
name|MDIO_WIS_REG_LASI_STATUS
argument_list|,
operator|&
name|val1
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"8705 LASI status 0x%x\n"
argument_list|,
name|val1
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WIS_DEVAD
argument_list|,
name|MDIO_WIS_REG_LASI_STATUS
argument_list|,
operator|&
name|val1
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"8705 LASI status 0x%x\n"
argument_list|,
name|val1
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_RX_SD
argument_list|,
operator|&
name|rx_sd
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
literal|0xc809
argument_list|,
operator|&
name|val1
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
literal|0xc809
argument_list|,
operator|&
name|val1
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"8705 1.c809 val=0x%x\n"
argument_list|,
name|val1
argument_list|)
expr_stmt|;
name|link_up
operator|=
operator|(
operator|(
name|rx_sd
operator|&
literal|0x1
operator|)
operator|&&
operator|(
name|val1
operator|&
operator|(
literal|1
operator|<<
literal|9
operator|)
operator|)
operator|&&
operator|(
operator|(
name|val1
operator|&
operator|(
literal|1
operator|<<
literal|8
operator|)
operator|)
operator|==
literal|0
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|link_up
condition|)
block|{
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_10000
expr_stmt|;
name|elink_ext_phy_resolve_fc
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
block|}
return|return
name|link_up
return|;
block|}
end_function

begin_comment
comment|/******************************************************************/
end_comment

begin_comment
comment|/*			SFP+ module Section			  */
end_comment

begin_comment
comment|/******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|elink_set_disable_pmd_transmit
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|uint8_t
name|pmd_dis
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
comment|/* Disable transmitter only for bootcodes which can enable it afterwards 	 * (for D3 link) 	 */
if|if
condition|(
name|pmd_dis
condition|)
block|{
if|if
condition|(
name|params
operator|->
name|feature_config_flags
operator|&
name|ELINK_FEATURE_CONFIG_BC_SUPPORTS_SFP_TX_DISABLED
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Disabling PMD transmitter\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"NOT disabling PMD transmitter\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Enabling PMD transmitter\n"
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_TX_DISABLE
argument_list|,
name|pmd_dis
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|elink_get_gpio_port
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|uint8_t
name|gpio_port
decl_stmt|;
name|uint32_t
name|swap_val
decl_stmt|,
name|swap_override
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
if|if
condition|(
name|CHIP_IS_E2
argument_list|(
name|sc
argument_list|)
condition|)
name|gpio_port
operator|=
name|SC_PATH
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|gpio_port
operator|=
name|params
operator|->
name|port
expr_stmt|;
name|swap_val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_PORT_SWAP
argument_list|)
expr_stmt|;
name|swap_override
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_STRAP_OVERRIDE
argument_list|)
expr_stmt|;
return|return
name|gpio_port
operator|^
operator|(
name|swap_val
operator|&&
name|swap_override
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_sfp_e1e2_set_transmitter
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|uint8_t
name|tx_en
parameter_list|)
block|{
name|uint16_t
name|val
decl_stmt|;
name|uint8_t
name|port
init|=
name|params
operator|->
name|port
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint32_t
name|tx_en_mode
decl_stmt|;
comment|/* Disable/Enable transmitter ( TX laser of the SFP+ module.)*/
name|tx_en_mode
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|port
index|]
operator|.
name|sfp_ctrl
argument_list|)
argument_list|)
operator|&
name|PORT_HW_CFG_TX_LASER_MASK
expr_stmt|;
name|ELINK_DEBUG_P3
argument_list|(
name|sc
argument_list|,
literal|"Setting transmitter tx_en=%x for port %x "
literal|"mode = %x\n"
argument_list|,
name|tx_en
argument_list|,
name|port
argument_list|,
name|tx_en_mode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tx_en_mode
condition|)
block|{
case|case
name|PORT_HW_CFG_TX_LASER_MDIO
case|:
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_PHY_IDENTIFIER
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx_en
condition|)
name|val
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|15
operator|)
expr_stmt|;
else|else
name|val
operator||=
operator|(
literal|1
operator|<<
literal|15
operator|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_PHY_IDENTIFIER
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_TX_LASER_GPIO0
case|:
case|case
name|PORT_HW_CFG_TX_LASER_GPIO1
case|:
case|case
name|PORT_HW_CFG_TX_LASER_GPIO2
case|:
case|case
name|PORT_HW_CFG_TX_LASER_GPIO3
case|:
block|{
name|uint16_t
name|gpio_pin
decl_stmt|;
name|uint8_t
name|gpio_port
decl_stmt|,
name|gpio_mode
decl_stmt|;
if|if
condition|(
name|tx_en
condition|)
name|gpio_mode
operator|=
name|MISC_REGISTERS_GPIO_OUTPUT_HIGH
expr_stmt|;
else|else
name|gpio_mode
operator|=
name|MISC_REGISTERS_GPIO_OUTPUT_LOW
expr_stmt|;
name|gpio_pin
operator|=
name|tx_en_mode
operator|-
name|PORT_HW_CFG_TX_LASER_GPIO0
expr_stmt|;
name|gpio_port
operator|=
name|elink_get_gpio_port
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|elink_cb_gpio_write
argument_list|(
name|sc
argument_list|,
name|gpio_pin
argument_list|,
name|gpio_mode
argument_list|,
name|gpio_port
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Invalid TX_LASER_MDIO 0x%x\n"
argument_list|,
name|tx_en_mode
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|elink_sfp_set_transmitter
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|uint8_t
name|tx_en
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Setting SFP+ transmitter to %d\n"
argument_list|,
name|tx_en
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
name|elink_sfp_e3_set_transmitter
argument_list|(
name|params
argument_list|,
name|phy
argument_list|,
name|tx_en
argument_list|)
expr_stmt|;
else|else
name|elink_sfp_e1e2_set_transmitter
argument_list|(
name|params
argument_list|,
name|phy
argument_list|,
name|tx_en
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_8726_read_sfp_module_eeprom
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint8_t
name|dev_addr
parameter_list|,
name|uint16_t
name|addr
parameter_list|,
name|uint8_t
name|byte_cnt
parameter_list|,
name|uint8_t
modifier|*
name|o_buf
parameter_list|,
name|uint8_t
name|is_init
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint16_t
name|val
init|=
literal|0
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
if|if
condition|(
name|byte_cnt
operator|>
name|ELINK_SFP_EEPROM_PAGE_SIZE
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Reading from eeprom is limited to 0xf\n"
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
comment|/* Set the read command byte count */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_SFP_TWO_WIRE_BYTE_CNT
argument_list|,
operator|(
name|byte_cnt
operator||
operator|(
name|dev_addr
operator|<<
literal|8
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Set the read command address */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_SFP_TWO_WIRE_MEM_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* Activate read command */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_SFP_TWO_WIRE_CTRL
argument_list|,
literal|0x2c0f
argument_list|)
expr_stmt|;
comment|/* Wait up to 500us for command complete status */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_SFP_TWO_WIRE_CTRL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|MDIO_PMA_REG_SFP_TWO_WIRE_CTRL_STATUS_MASK
operator|)
operator|==
name|MDIO_PMA_REG_SFP_TWO_WIRE_STATUS_COMPLETE
condition|)
break|break;
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|val
operator|&
name|MDIO_PMA_REG_SFP_TWO_WIRE_CTRL_STATUS_MASK
operator|)
operator|!=
name|MDIO_PMA_REG_SFP_TWO_WIRE_STATUS_COMPLETE
condition|)
block|{
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Got bad status 0x%x when reading from SFP+ EEPROM\n"
argument_list|,
operator|(
name|val
operator|&
name|MDIO_PMA_REG_SFP_TWO_WIRE_CTRL_STATUS_MASK
operator|)
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
comment|/* Read the buffer */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|byte_cnt
condition|;
name|i
operator|++
control|)
block|{
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8726_TWO_WIRE_DATA_BUF
operator|+
name|i
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|o_buf
index|[
name|i
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|val
operator|&
name|MDIO_PMA_REG_8726_TWO_WIRE_DATA_MASK
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_SFP_TWO_WIRE_CTRL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|MDIO_PMA_REG_SFP_TWO_WIRE_CTRL_STATUS_MASK
operator|)
operator|==
name|MDIO_PMA_REG_SFP_TWO_WIRE_STATUS_IDLE
condition|)
return|return
name|ELINK_STATUS_OK
return|;
name|DELAY
argument_list|(
literal|1000
operator|*
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_warpcore_power_module
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint8_t
name|power
parameter_list|)
block|{
name|uint32_t
name|pin_cfg
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|pin_cfg
operator|=
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|params
operator|->
name|port
index|]
operator|.
name|e3_sfp_ctrl
argument_list|)
argument_list|)
operator|&
name|PORT_HW_CFG_E3_PWR_DIS_MASK
operator|)
operator|>>
name|PORT_HW_CFG_E3_PWR_DIS_SHIFT
expr_stmt|;
if|if
condition|(
name|pin_cfg
operator|==
name|PIN_CFG_NA
condition|)
return|return;
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"Setting SFP+ module power to %d using pin cfg %d\n"
argument_list|,
name|power
argument_list|,
name|pin_cfg
argument_list|)
expr_stmt|;
comment|/* Low ==> corresponding SFP+ module is powered 	 * high ==> the SFP+ module is powered down 	 */
name|elink_set_cfg_pin
argument_list|(
name|sc
argument_list|,
name|pin_cfg
argument_list|,
name|power
operator|^
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_warpcore_read_sfp_module_eeprom
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint8_t
name|dev_addr
parameter_list|,
name|uint16_t
name|addr
parameter_list|,
name|uint8_t
name|byte_cnt
parameter_list|,
name|uint8_t
modifier|*
name|o_buf
parameter_list|,
name|uint8_t
name|is_init
parameter_list|)
block|{
name|elink_status_t
name|rc
init|=
name|ELINK_STATUS_OK
decl_stmt|;
name|uint8_t
name|i
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|,
name|cnt
init|=
literal|0
decl_stmt|;
name|uint32_t
name|data_array
index|[
literal|4
index|]
decl_stmt|;
name|uint16_t
name|addr32
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
if|if
condition|(
name|byte_cnt
operator|>
name|ELINK_SFP_EEPROM_PAGE_SIZE
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Reading from eeprom is limited to 16 bytes\n"
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
comment|/* 4 byte aligned address */
name|addr32
operator|=
name|addr
operator|&
operator|(
operator|~
literal|0x3
operator|)
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
operator|!
name|is_init
operator|)
operator|&&
operator|(
name|cnt
operator|==
name|I2C_WA_PWR_ITER
operator|)
condition|)
block|{
name|elink_warpcore_power_module
argument_list|(
name|params
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Note that 100us are not enough here */
name|DELAY
argument_list|(
literal|1000
operator|*
literal|1
argument_list|)
expr_stmt|;
name|elink_warpcore_power_module
argument_list|(
name|params
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|elink_bsc_module_sel
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|rc
operator|=
name|elink_bsc_read
argument_list|(
name|sc
argument_list|,
name|dev_addr
argument_list|,
name|addr32
argument_list|,
literal|0
argument_list|,
name|byte_cnt
argument_list|,
name|data_array
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|rc
operator|!=
name|ELINK_STATUS_OK
operator|)
operator|&&
operator|(
operator|++
name|cnt
operator|<
name|I2C_WA_RETRY_CNT
operator|)
condition|)
do|;
if|if
condition|(
name|rc
operator|==
name|ELINK_STATUS_OK
condition|)
block|{
for|for
control|(
name|i
operator|=
operator|(
name|addr
operator|-
name|addr32
operator|)
init|;
name|i
operator|<
name|byte_cnt
operator|+
operator|(
name|addr
operator|-
name|addr32
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|o_buf
index|[
name|j
index|]
operator|=
operator|*
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|data_array
operator|+
name|i
operator|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_8727_read_sfp_module_eeprom
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint8_t
name|dev_addr
parameter_list|,
name|uint16_t
name|addr
parameter_list|,
name|uint8_t
name|byte_cnt
parameter_list|,
name|uint8_t
modifier|*
name|o_buf
parameter_list|,
name|uint8_t
name|is_init
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint16_t
name|val
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|byte_cnt
operator|>
name|ELINK_SFP_EEPROM_PAGE_SIZE
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Reading from eeprom is limited to 0xf\n"
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
comment|/* Set 2-wire transfer rate of SFP+ module EEPROM 	 * to 100Khz since some DACs(direct attached cables) do 	 * not work at 400Khz. 	 */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8727_TWO_WIRE_SLAVE_ADDR
argument_list|,
operator|(
operator|(
name|dev_addr
operator|<<
literal|8
operator|)
operator||
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* Need to read from 1.8000 to clear it */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_SFP_TWO_WIRE_CTRL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
comment|/* Set the read command byte count */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_SFP_TWO_WIRE_BYTE_CNT
argument_list|,
operator|(
operator|(
name|byte_cnt
operator|<
literal|2
operator|)
condition|?
literal|2
else|:
name|byte_cnt
operator|)
argument_list|)
expr_stmt|;
comment|/* Set the read command address */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_SFP_TWO_WIRE_MEM_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* Set the destination address */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
literal|0x8004
argument_list|,
name|MDIO_PMA_REG_8727_TWO_WIRE_DATA_BUF
argument_list|)
expr_stmt|;
comment|/* Activate read command */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_SFP_TWO_WIRE_CTRL
argument_list|,
literal|0x8002
argument_list|)
expr_stmt|;
comment|/* Wait appropriate time for two-wire command to finish before 	 * polling the status register 	 */
name|DELAY
argument_list|(
literal|1000
operator|*
literal|1
argument_list|)
expr_stmt|;
comment|/* Wait up to 500us for command complete status */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_SFP_TWO_WIRE_CTRL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|MDIO_PMA_REG_SFP_TWO_WIRE_CTRL_STATUS_MASK
operator|)
operator|==
name|MDIO_PMA_REG_SFP_TWO_WIRE_STATUS_COMPLETE
condition|)
break|break;
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|val
operator|&
name|MDIO_PMA_REG_SFP_TWO_WIRE_CTRL_STATUS_MASK
operator|)
operator|!=
name|MDIO_PMA_REG_SFP_TWO_WIRE_STATUS_COMPLETE
condition|)
block|{
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Got bad status 0x%x when reading from SFP+ EEPROM\n"
argument_list|,
operator|(
name|val
operator|&
name|MDIO_PMA_REG_SFP_TWO_WIRE_CTRL_STATUS_MASK
operator|)
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_TIMEOUT
return|;
block|}
comment|/* Read the buffer */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|byte_cnt
condition|;
name|i
operator|++
control|)
block|{
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8727_TWO_WIRE_DATA_BUF
operator|+
name|i
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|o_buf
index|[
name|i
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|val
operator|&
name|MDIO_PMA_REG_8727_TWO_WIRE_DATA_MASK
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_SFP_TWO_WIRE_CTRL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|MDIO_PMA_REG_SFP_TWO_WIRE_CTRL_STATUS_MASK
operator|)
operator|==
name|MDIO_PMA_REG_SFP_TWO_WIRE_STATUS_IDLE
condition|)
return|return
name|ELINK_STATUS_OK
return|;
name|DELAY
argument_list|(
literal|1000
operator|*
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
end_function

begin_function
name|elink_status_t
name|elink_read_sfp_module_eeprom
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint8_t
name|dev_addr
parameter_list|,
name|uint16_t
name|addr
parameter_list|,
name|uint16_t
name|byte_cnt
parameter_list|,
name|uint8_t
modifier|*
name|o_buf
parameter_list|)
block|{
name|elink_status_t
name|rc
init|=
literal|0
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint8_t
name|xfer_size
decl_stmt|;
name|uint8_t
modifier|*
name|user_data
init|=
name|o_buf
decl_stmt|;
name|read_sfp_module_eeprom_func_p
name|read_func
decl_stmt|;
if|if
condition|(
operator|(
name|dev_addr
operator|!=
literal|0xa0
operator|)
operator|&&
operator|(
name|dev_addr
operator|!=
literal|0xa2
operator|)
condition|)
block|{
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"invalid dev_addr 0x%x\n"
argument_list|,
name|dev_addr
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
switch|switch
condition|(
name|phy
operator|->
name|type
condition|)
block|{
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726
case|:
name|read_func
operator|=
name|elink_8726_read_sfp_module_eeprom
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727
case|:
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8722
case|:
name|read_func
operator|=
name|elink_8727_read_sfp_module_eeprom
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT
case|:
name|read_func
operator|=
name|elink_warpcore_read_sfp_module_eeprom
expr_stmt|;
break|break;
default|default:
return|return
name|ELINK_OP_NOT_SUPPORTED
return|;
block|}
while|while
condition|(
operator|!
name|rc
operator|&&
operator|(
name|byte_cnt
operator|>
literal|0
operator|)
condition|)
block|{
name|xfer_size
operator|=
operator|(
name|byte_cnt
operator|>
name|ELINK_SFP_EEPROM_PAGE_SIZE
operator|)
condition|?
name|ELINK_SFP_EEPROM_PAGE_SIZE
else|:
name|byte_cnt
expr_stmt|;
name|rc
operator|=
name|read_func
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|dev_addr
argument_list|,
name|addr
argument_list|,
name|xfer_size
argument_list|,
name|user_data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|byte_cnt
operator|-=
name|xfer_size
expr_stmt|;
name|user_data
operator|+=
name|xfer_size
expr_stmt|;
name|addr
operator|+=
name|xfer_size
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_get_edc_mode
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint16_t
modifier|*
name|edc_mode
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint32_t
name|sync_offset
init|=
literal|0
decl_stmt|,
name|phy_idx
decl_stmt|,
name|media_types
decl_stmt|;
name|uint8_t
name|val
index|[
name|ELINK_SFP_EEPROM_FC_TX_TECH_ADDR
operator|+
literal|1
index|]
decl_stmt|,
name|check_limiting_mode
init|=
literal|0
decl_stmt|;
operator|*
name|edc_mode
operator|=
name|ELINK_EDC_MODE_LIMITING
expr_stmt|;
name|phy
operator|->
name|media_type
operator|=
name|ELINK_ETH_PHY_UNSPECIFIED
expr_stmt|;
comment|/* First check for copper cable */
if|if
condition|(
name|elink_read_sfp_module_eeprom
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|ELINK_I2C_DEV_ADDR_A0
argument_list|,
literal|0
argument_list|,
name|ELINK_SFP_EEPROM_FC_TX_TECH_ADDR
operator|+
literal|1
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|val
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Failed to read from SFP+ module EEPROM\n"
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
name|params
operator|->
name|link_attr_sync
operator|&=
operator|~
name|LINK_SFP_EEPROM_COMP_CODE_MASK
expr_stmt|;
name|params
operator|->
name|link_attr_sync
operator||=
name|val
index|[
name|ELINK_SFP_EEPROM_10G_COMP_CODE_ADDR
index|]
operator|<<
name|LINK_SFP_EEPROM_COMP_CODE_SHIFT
expr_stmt|;
name|elink_update_link_attr
argument_list|(
name|params
argument_list|,
name|params
operator|->
name|link_attr_sync
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|val
index|[
name|ELINK_SFP_EEPROM_CON_TYPE_ADDR
index|]
condition|)
block|{
case|case
name|ELINK_SFP_EEPROM_CON_TYPE_VAL_COPPER
case|:
block|{
name|uint8_t
name|copper_module_type
decl_stmt|;
name|phy
operator|->
name|media_type
operator|=
name|ELINK_ETH_PHY_DA_TWINAX
expr_stmt|;
comment|/* Check if its active cable (includes SFP+ module) 		 * of passive cable 		 */
name|copper_module_type
operator|=
name|val
index|[
name|ELINK_SFP_EEPROM_FC_TX_TECH_ADDR
index|]
expr_stmt|;
if|if
condition|(
name|copper_module_type
operator|&
name|ELINK_SFP_EEPROM_FC_TX_TECH_BITMASK_COPPER_ACTIVE
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Active Copper cable detected\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|type
operator|==
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT
condition|)
operator|*
name|edc_mode
operator|=
name|ELINK_EDC_MODE_ACTIVE_DAC
expr_stmt|;
else|else
name|check_limiting_mode
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|edc_mode
operator|=
name|ELINK_EDC_MODE_PASSIVE_DAC
expr_stmt|;
comment|/* Even in case PASSIVE_DAC indication is not set, 			 * treat it as a passive DAC cable, since some cables 			 * don't have this indication. 			 */
if|if
condition|(
name|copper_module_type
operator|&
name|ELINK_SFP_EEPROM_FC_TX_TECH_BITMASK_COPPER_PASSIVE
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Passive Copper cable detected\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Unknown copper-cable-type\n"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|ELINK_SFP_EEPROM_CON_TYPE_VAL_UNKNOWN
case|:
case|case
name|ELINK_SFP_EEPROM_CON_TYPE_VAL_LC
case|:
case|case
name|ELINK_SFP_EEPROM_CON_TYPE_VAL_RJ45
case|:
name|check_limiting_mode
operator|=
literal|1
expr_stmt|;
comment|/* Module is considered as 1G in case it's NOT compliant with 		 * any 10G ethernet protocol, but is 1G Ethernet compliant. 		 */
if|if
condition|(
operator|(
operator|(
name|val
index|[
name|ELINK_SFP_EEPROM_10G_COMP_CODE_ADDR
index|]
operator|&
operator|(
name|ELINK_SFP_EEPROM_10G_COMP_CODE_SR_MASK
operator||
name|ELINK_SFP_EEPROM_10G_COMP_CODE_LR_MASK
operator||
name|ELINK_SFP_EEPROM_10G_COMP_CODE_LRM_MASK
operator|)
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|val
index|[
name|ELINK_SFP_EEPROM_1G_COMP_CODE_ADDR
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"1G SFP module detected\n"
argument_list|)
expr_stmt|;
name|phy
operator|->
name|media_type
operator|=
name|ELINK_ETH_PHY_SFP_1G_FIBER
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|req_line_speed
operator|!=
name|ELINK_SPEED_1000
condition|)
block|{
name|uint8_t
name|gport
init|=
name|params
operator|->
name|port
decl_stmt|;
name|phy
operator|->
name|req_line_speed
operator|=
name|ELINK_SPEED_1000
expr_stmt|;
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|gport
operator|=
name|SC_PATH
argument_list|(
name|sc
argument_list|)
operator|+
operator|(
name|params
operator|->
name|port
operator|<<
literal|1
operator|)
expr_stmt|;
block|}
name|elink_cb_event_log
argument_list|(
name|sc
argument_list|,
name|ELINK_LOG_ID_NON_10G_MODULE
argument_list|,
name|gport
argument_list|)
expr_stmt|;
comment|//"Warning: Link speed was forced to 1000Mbps."
comment|// " Current SFP module in port %d is not"
comment|// " compliant with 10G Ethernet\n",
block|}
if|if
condition|(
name|val
index|[
name|ELINK_SFP_EEPROM_1G_COMP_CODE_ADDR
index|]
operator|&
name|ELINK_SFP_EEPROM_1G_COMP_CODE_BASE_T
condition|)
block|{
comment|/* Some 1G-baseT modules will not link up, 				 * unless TX_EN is toggled with long delay in 				 * between. 				 */
name|elink_sfp_set_transmitter
argument_list|(
name|params
argument_list|,
name|phy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
operator|*
literal|40
argument_list|)
expr_stmt|;
name|elink_sfp_set_transmitter
argument_list|(
name|params
argument_list|,
name|phy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|idx
decl_stmt|,
name|cfg_idx
init|=
literal|0
decl_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"10G Optic module detected\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
name|ELINK_INT_PHY
init|;
name|idx
operator|<
name|ELINK_MAX_PHYS
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|params
operator|->
name|phy
index|[
name|idx
index|]
operator|.
name|type
operator|==
name|phy
operator|->
name|type
condition|)
block|{
name|cfg_idx
operator|=
name|ELINK_LINK_CONFIG_IDX
argument_list|(
name|idx
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|phy
operator|->
name|media_type
operator|=
name|ELINK_ETH_PHY_SFPP_10G_FIBER
expr_stmt|;
name|phy
operator|->
name|req_line_speed
operator|=
name|params
operator|->
name|req_line_speed
index|[
name|cfg_idx
index|]
expr_stmt|;
block|}
break|break;
default|default:
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Unable to determine module type 0x%x !!!\n"
argument_list|,
name|val
index|[
name|ELINK_SFP_EEPROM_CON_TYPE_ADDR
index|]
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
name|sync_offset
operator|=
name|params
operator|->
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|params
operator|->
name|port
index|]
operator|.
name|media_type
argument_list|)
expr_stmt|;
name|media_types
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|sync_offset
argument_list|)
expr_stmt|;
comment|/* Update media type for non-PMF sync */
for|for
control|(
name|phy_idx
operator|=
name|ELINK_INT_PHY
init|;
name|phy_idx
operator|<
name|ELINK_MAX_PHYS
condition|;
name|phy_idx
operator|++
control|)
block|{
if|if
condition|(
operator|&
operator|(
name|params
operator|->
name|phy
index|[
name|phy_idx
index|]
operator|)
operator|==
name|phy
condition|)
block|{
name|media_types
operator|&=
operator|~
operator|(
name|PORT_HW_CFG_MEDIA_TYPE_PHY0_MASK
operator|<<
operator|(
name|PORT_HW_CFG_MEDIA_TYPE_PHY1_SHIFT
operator|*
name|phy_idx
operator|)
operator|)
expr_stmt|;
name|media_types
operator||=
operator|(
operator|(
name|phy
operator|->
name|media_type
operator|&
name|PORT_HW_CFG_MEDIA_TYPE_PHY0_MASK
operator|)
operator|<<
operator|(
name|PORT_HW_CFG_MEDIA_TYPE_PHY1_SHIFT
operator|*
name|phy_idx
operator|)
operator|)
expr_stmt|;
break|break;
block|}
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|sync_offset
argument_list|,
name|media_types
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_limiting_mode
condition|)
block|{
name|uint8_t
name|options
index|[
name|ELINK_SFP_EEPROM_OPTIONS_SIZE
index|]
decl_stmt|;
if|if
condition|(
name|elink_read_sfp_module_eeprom
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|ELINK_I2C_DEV_ADDR_A0
argument_list|,
name|ELINK_SFP_EEPROM_OPTIONS_ADDR
argument_list|,
name|ELINK_SFP_EEPROM_OPTIONS_SIZE
argument_list|,
name|options
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Failed to read Option field from module EEPROM\n"
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
if|if
condition|(
operator|(
name|options
index|[
literal|0
index|]
operator|&
name|ELINK_SFP_EEPROM_OPTIONS_LINEAR_RX_OUT_MASK
operator|)
condition|)
operator|*
name|edc_mode
operator|=
name|ELINK_EDC_MODE_LINEAR
expr_stmt|;
else|else
operator|*
name|edc_mode
operator|=
name|ELINK_EDC_MODE_LIMITING
expr_stmt|;
block|}
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"EDC mode is set to 0x%x\n"
argument_list|,
operator|*
name|edc_mode
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* This function read the relevant field from the module (SFP+), and verify it  * is compliant with this board  */
end_comment

begin_function
specifier|static
name|elink_status_t
name|elink_verify_sfp_module
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint32_t
name|val
decl_stmt|,
name|cmd
decl_stmt|;
name|uint32_t
name|fw_resp
decl_stmt|,
name|fw_cmd_param
decl_stmt|;
name|char
name|vendor_name
index|[
name|ELINK_SFP_EEPROM_VENDOR_NAME_SIZE
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|vendor_pn
index|[
name|ELINK_SFP_EEPROM_PART_NO_SIZE
operator|+
literal|1
index|]
decl_stmt|;
name|phy
operator|->
name|flags
operator|&=
operator|~
name|ELINK_FLAGS_SFP_NOT_APPROVED
expr_stmt|;
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_feature_config
index|[
name|params
operator|->
name|port
index|]
operator|.
name|config
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_MASK
operator|)
operator|==
name|PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_NO_ENFORCEMENT
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"NOT enforcing module verification\n"
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
if|if
condition|(
name|params
operator|->
name|feature_config_flags
operator|&
name|ELINK_FEATURE_CONFIG_BC_SUPPORTS_DUAL_PHY_OPT_MDL_VRFY
condition|)
block|{
comment|/* Use specific phy request */
name|cmd
operator|=
name|DRV_MSG_CODE_VRFY_SPECIFIC_PHY_OPT_MDL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|params
operator|->
name|feature_config_flags
operator|&
name|ELINK_FEATURE_CONFIG_BC_SUPPORTS_OPT_MDL_VRFY
condition|)
block|{
comment|/* Use first phy request only in case of non-dual media*/
if|if
condition|(
name|ELINK_DUAL_MEDIA
argument_list|(
name|params
argument_list|)
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"FW does not support OPT MDL verification\n"
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
name|cmd
operator|=
name|DRV_MSG_CODE_VRFY_FIRST_PHY_OPT_MDL
expr_stmt|;
block|}
else|else
block|{
comment|/* No support in OPT MDL detection */
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"FW does not support OPT MDL verification\n"
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
name|fw_cmd_param
operator|=
name|ELINK_FW_PARAM_SET
argument_list|(
name|phy
operator|->
name|addr
argument_list|,
name|phy
operator|->
name|type
argument_list|,
name|phy
operator|->
name|mdio_ctrl
argument_list|)
expr_stmt|;
name|fw_resp
operator|=
name|elink_cb_fw_command
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|,
name|fw_cmd_param
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw_resp
operator|==
name|FW_MSG_CODE_VRFY_OPT_MDL_SUCCESS
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Approved module\n"
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
comment|/* Format the warning message */
if|if
condition|(
name|elink_read_sfp_module_eeprom
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|ELINK_I2C_DEV_ADDR_A0
argument_list|,
name|ELINK_SFP_EEPROM_VENDOR_NAME_ADDR
argument_list|,
name|ELINK_SFP_EEPROM_VENDOR_NAME_SIZE
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|vendor_name
argument_list|)
condition|)
name|vendor_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
name|vendor_name
index|[
name|ELINK_SFP_EEPROM_VENDOR_NAME_SIZE
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|elink_read_sfp_module_eeprom
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|ELINK_I2C_DEV_ADDR_A0
argument_list|,
name|ELINK_SFP_EEPROM_PART_NO_ADDR
argument_list|,
name|ELINK_SFP_EEPROM_PART_NO_SIZE
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|vendor_pn
argument_list|)
condition|)
name|vendor_pn
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
name|vendor_pn
index|[
name|ELINK_SFP_EEPROM_PART_NO_SIZE
index|]
operator|=
literal|'\0'
expr_stmt|;
name|elink_cb_event_log
argument_list|(
name|sc
argument_list|,
name|ELINK_LOG_ID_UNQUAL_IO_MODULE
argument_list|,
name|params
operator|->
name|port
argument_list|,
name|vendor_name
argument_list|,
name|vendor_pn
argument_list|)
expr_stmt|;
comment|// "Warning: Unqualified SFP+ module detected,"
comment|// " Port %d from %s part number %s\n",
if|if
condition|(
operator|(
name|val
operator|&
name|PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_MASK
operator|)
operator|!=
name|PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_WARNING_MSG
condition|)
name|phy
operator|->
name|flags
operator||=
name|ELINK_FLAGS_SFP_NOT_APPROVED
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_wait_for_sfp_module_initialized
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|uint8_t
name|val
decl_stmt|;
name|elink_status_t
name|rc
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint16_t
name|timeout
decl_stmt|;
comment|/* Initialization time after hot-plug may take up to 300ms for 	 * some phys type ( e.g. JDSU ) 	 */
for|for
control|(
name|timeout
operator|=
literal|0
init|;
name|timeout
operator|<
literal|60
condition|;
name|timeout
operator|++
control|)
block|{
if|if
condition|(
name|phy
operator|->
name|type
operator|==
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT
condition|)
name|rc
operator|=
name|elink_warpcore_read_sfp_module_eeprom
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|ELINK_I2C_DEV_ADDR_A0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|&
name|val
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|rc
operator|=
name|elink_read_sfp_module_eeprom
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|ELINK_I2C_DEV_ADDR_A0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"SFP+ module initialization took %d ms\n"
argument_list|,
name|timeout
operator|*
literal|5
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
name|DELAY
argument_list|(
literal|1000
operator|*
literal|5
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|elink_read_sfp_module_eeprom
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|ELINK_I2C_DEV_ADDR_A0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_8727_power_module
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|uint8_t
name|is_power_up
parameter_list|)
block|{
comment|/* Make sure GPIOs are not using for LED mode */
name|uint16_t
name|val
decl_stmt|;
comment|/* In the GPIO register, bit 4 is use to determine if the GPIOs are 	 * operating as INPUT or as OUTPUT. Bit 1 is for input, and 0 for 	 * output 	 * Bits 0-1 determine the GPIOs value for OUTPUT in case bit 4 val is 0 	 * Bits 8-9 determine the GPIOs value for INPUT in case bit 4 val is 1 	 * where the 1st bit is the over-current(only input), and 2nd bit is 	 * for power( only output ) 	 * 	 * In case of NOC feature is disabled and power is up, set GPIO control 	 *  as input to enable listening of over-current indication 	 */
if|if
condition|(
name|phy
operator|->
name|flags
operator|&
name|ELINK_FLAGS_NOC
condition|)
return|return;
if|if
condition|(
name|is_power_up
condition|)
name|val
operator|=
operator|(
literal|1
operator|<<
literal|4
operator|)
expr_stmt|;
else|else
comment|/* Set GPIO control to OUTPUT, and set the power bit 		 * to according to the is_power_up 		 */
name|val
operator|=
operator|(
literal|1
operator|<<
literal|1
operator|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8727_GPIO_CTRL
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_8726_set_limiting_mode
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|uint16_t
name|edc_mode
parameter_list|)
block|{
name|uint16_t
name|cur_limiting_mode
decl_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_ROM_VER2
argument_list|,
operator|&
name|cur_limiting_mode
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Current Limiting mode is 0x%x\n"
argument_list|,
name|cur_limiting_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|edc_mode
operator|==
name|ELINK_EDC_MODE_LIMITING
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Setting LIMITING MODE\n"
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_ROM_VER2
argument_list|,
name|ELINK_EDC_MODE_LIMITING
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* LRM mode ( default )*/
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Setting LRM MODE\n"
argument_list|)
expr_stmt|;
comment|/* Changing to LRM mode takes quite few seconds. So do it only 		 * if current mode is limiting (default is LRM) 		 */
if|if
condition|(
name|cur_limiting_mode
operator|!=
name|ELINK_EDC_MODE_LIMITING
condition|)
return|return
name|ELINK_STATUS_OK
return|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_LRM_MODE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_ROM_VER2
argument_list|,
literal|0x128
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_MISC_CTRL0
argument_list|,
literal|0x4008
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_LRM_MODE
argument_list|,
literal|0xaaaa
argument_list|)
expr_stmt|;
block|}
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_8727_set_limiting_mode
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|uint16_t
name|edc_mode
parameter_list|)
block|{
name|uint16_t
name|phy_identifier
decl_stmt|;
name|uint16_t
name|rom_ver2_val
decl_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_PHY_IDENTIFIER
argument_list|,
operator|&
name|phy_identifier
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_PHY_IDENTIFIER
argument_list|,
operator|(
name|phy_identifier
operator|&
operator|~
operator|(
literal|1
operator|<<
literal|9
operator|)
operator|)
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_ROM_VER2
argument_list|,
operator|&
name|rom_ver2_val
argument_list|)
expr_stmt|;
comment|/* Keep the MSB 8-bits, and set the LSB 8-bits with the edc_mode */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_ROM_VER2
argument_list|,
operator|(
name|rom_ver2_val
operator|&
literal|0xff00
operator|)
operator||
operator|(
name|edc_mode
operator|&
literal|0x00ff
operator|)
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_PHY_IDENTIFIER
argument_list|,
operator|(
name|phy_identifier
operator||
operator|(
literal|1
operator|<<
literal|9
operator|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_8727_specific_func
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint32_t
name|action
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint16_t
name|val
decl_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|ELINK_DISABLE_TX
case|:
name|elink_sfp_set_transmitter
argument_list|(
name|params
argument_list|,
name|phy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ELINK_ENABLE_TX
case|:
if|if
condition|(
operator|!
operator|(
name|phy
operator|->
name|flags
operator|&
name|ELINK_FLAGS_SFP_NOT_APPROVED
operator|)
condition|)
name|elink_sfp_set_transmitter
argument_list|(
name|params
argument_list|,
name|phy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ELINK_PHY_INIT
case|:
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_LASI_RXCTRL
argument_list|,
operator|(
literal|1
operator|<<
literal|2
operator|)
operator||
operator|(
literal|1
operator|<<
literal|5
operator|)
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_LASI_TXCTRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_LASI_CTRL
argument_list|,
literal|0x0006
argument_list|)
expr_stmt|;
comment|/* Make MOD_ABS give interrupt on change */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8727_PCS_OPT_CTRL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|val
operator||=
operator|(
literal|1
operator|<<
literal|12
operator|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|flags
operator|&
name|ELINK_FLAGS_NOC
condition|)
name|val
operator||=
operator|(
literal|3
operator|<<
literal|5
operator|)
expr_stmt|;
comment|/* Set 8727 GPIOs to input to allow reading from the 8727 GPIO0 		 * status which reflect SFP+ module over-current 		 */
if|if
condition|(
operator|!
operator|(
name|phy
operator|->
name|flags
operator|&
name|ELINK_FLAGS_NOC
operator|)
condition|)
name|val
operator|&=
literal|0xff8f
expr_stmt|;
comment|/* Reset bits 4-6 */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8727_PCS_OPT_CTRL
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Function 0x%x not supported by 8727\n"
argument_list|,
name|action
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|elink_set_e1e2_module_fault_led
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint8_t
name|gpio_mode
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint32_t
name|fault_led_gpio
init|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|params
operator|->
name|port
index|]
operator|.
name|sfp_ctrl
argument_list|)
argument_list|)
operator|&
name|PORT_HW_CFG_FAULT_MODULE_LED_MASK
decl_stmt|;
switch|switch
condition|(
name|fault_led_gpio
condition|)
block|{
case|case
name|PORT_HW_CFG_FAULT_MODULE_LED_DISABLED
case|:
return|return;
case|case
name|PORT_HW_CFG_FAULT_MODULE_LED_GPIO0
case|:
case|case
name|PORT_HW_CFG_FAULT_MODULE_LED_GPIO1
case|:
case|case
name|PORT_HW_CFG_FAULT_MODULE_LED_GPIO2
case|:
case|case
name|PORT_HW_CFG_FAULT_MODULE_LED_GPIO3
case|:
block|{
name|uint8_t
name|gpio_port
init|=
name|elink_get_gpio_port
argument_list|(
name|params
argument_list|)
decl_stmt|;
name|uint16_t
name|gpio_pin
init|=
name|fault_led_gpio
operator|-
name|PORT_HW_CFG_FAULT_MODULE_LED_GPIO0
decl_stmt|;
name|ELINK_DEBUG_P3
argument_list|(
name|sc
argument_list|,
literal|"Set fault module-detected led "
literal|"pin %x port %x mode %x\n"
argument_list|,
name|gpio_pin
argument_list|,
name|gpio_port
argument_list|,
name|gpio_mode
argument_list|)
expr_stmt|;
name|elink_cb_gpio_write
argument_list|(
name|sc
argument_list|,
name|gpio_pin
argument_list|,
name|gpio_mode
argument_list|,
name|gpio_port
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Error: Invalid fault led mode 0x%x\n"
argument_list|,
name|fault_led_gpio
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|elink_set_e3_module_fault_led
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint8_t
name|gpio_mode
parameter_list|)
block|{
name|uint32_t
name|pin_cfg
decl_stmt|;
name|uint8_t
name|port
init|=
name|params
operator|->
name|port
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|pin_cfg
operator|=
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|port
index|]
operator|.
name|e3_sfp_ctrl
argument_list|)
argument_list|)
operator|&
name|PORT_HW_CFG_E3_FAULT_MDL_LED_MASK
operator|)
operator|>>
name|PORT_HW_CFG_E3_FAULT_MDL_LED_SHIFT
expr_stmt|;
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"Setting Fault LED to %d using pin cfg %d\n"
argument_list|,
name|gpio_mode
argument_list|,
name|pin_cfg
argument_list|)
expr_stmt|;
name|elink_set_cfg_pin
argument_list|(
name|sc
argument_list|,
name|pin_cfg
argument_list|,
name|gpio_mode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_set_sfp_module_fault_led
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint8_t
name|gpio_mode
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Setting SFP+ module fault LED to %d\n"
argument_list|,
name|gpio_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* Low ==> if SFP+ module is supported otherwise 		 * High ==> if SFP+ module is not on the approved vendor list 		 */
name|elink_set_e3_module_fault_led
argument_list|(
name|params
argument_list|,
name|gpio_mode
argument_list|)
expr_stmt|;
block|}
else|else
name|elink_set_e1e2_module_fault_led
argument_list|(
name|params
argument_list|,
name|gpio_mode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_warpcore_hw_reset
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|elink_warpcore_power_module
argument_list|(
name|params
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Put Warpcore in low power mode */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_WC0_RESET
argument_list|,
literal|0x0c0e
argument_list|)
expr_stmt|;
comment|/* Put LCPLL in low power mode */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_LCPLL_E40_PWRDWN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_LCPLL_E40_RESETB_ANA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_LCPLL_E40_RESETB_DIG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_power_sfp_module
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|uint8_t
name|power
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Setting SFP+ power to %x\n"
argument_list|,
name|power
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|phy
operator|->
name|type
condition|)
block|{
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727
case|:
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8722
case|:
name|elink_8727_power_module
argument_list|(
name|params
operator|->
name|sc
argument_list|,
name|phy
argument_list|,
name|power
argument_list|)
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT
case|:
name|elink_warpcore_power_module
argument_list|(
name|params
argument_list|,
name|power
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|elink_warpcore_set_limiting_mode
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|uint16_t
name|edc_mode
parameter_list|)
block|{
name|uint16_t
name|val
init|=
literal|0
decl_stmt|;
name|uint16_t
name|mode
init|=
name|MDIO_WC_REG_UC_INFO_B1_FIRMWARE_MODE_DEFAULT
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint8_t
name|lane
init|=
name|elink_get_warpcore_lane
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
decl_stmt|;
comment|/* This is a global register which controls all lanes */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_UC_INFO_B1_FIRMWARE_MODE
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
literal|0xf
operator|<<
operator|(
name|lane
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
switch|switch
condition|(
name|edc_mode
condition|)
block|{
case|case
name|ELINK_EDC_MODE_LINEAR
case|:
case|case
name|ELINK_EDC_MODE_LIMITING
case|:
name|mode
operator|=
name|MDIO_WC_REG_UC_INFO_B1_FIRMWARE_MODE_DEFAULT
expr_stmt|;
break|break;
case|case
name|ELINK_EDC_MODE_PASSIVE_DAC
case|:
case|case
name|ELINK_EDC_MODE_ACTIVE_DAC
case|:
name|mode
operator|=
name|MDIO_WC_REG_UC_INFO_B1_FIRMWARE_MODE_SFP_DAC
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|val
operator||=
operator|(
name|mode
operator|<<
operator|(
name|lane
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_UC_INFO_B1_FIRMWARE_MODE
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* A must read */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_UC_INFO_B1_FIRMWARE_MODE
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
comment|/* Restart microcode to re-read the new mode */
name|elink_warpcore_reset_lane
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|elink_warpcore_reset_lane
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_set_limiting_mode
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|uint16_t
name|edc_mode
parameter_list|)
block|{
switch|switch
condition|(
name|phy
operator|->
name|type
condition|)
block|{
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726
case|:
name|elink_8726_set_limiting_mode
argument_list|(
name|params
operator|->
name|sc
argument_list|,
name|phy
argument_list|,
name|edc_mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727
case|:
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8722
case|:
name|elink_8727_set_limiting_mode
argument_list|(
name|params
operator|->
name|sc
argument_list|,
name|phy
argument_list|,
name|edc_mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT
case|:
name|elink_warpcore_set_limiting_mode
argument_list|(
name|params
argument_list|,
name|phy
argument_list|,
name|edc_mode
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|elink_status_t
name|elink_sfp_module_detection
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint16_t
name|edc_mode
decl_stmt|;
name|elink_status_t
name|rc
init|=
name|ELINK_STATUS_OK
decl_stmt|;
name|uint32_t
name|val
init|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_feature_config
index|[
name|params
operator|->
name|port
index|]
operator|.
name|config
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Enabled transmitter by default */
name|elink_sfp_set_transmitter
argument_list|(
name|params
argument_list|,
name|phy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"SFP+ module plugged in/out detected on port %d\n"
argument_list|,
name|params
operator|->
name|port
argument_list|)
expr_stmt|;
comment|/* Power up module */
name|elink_power_sfp_module
argument_list|(
name|params
argument_list|,
name|phy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|elink_get_edc_mode
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
operator|&
name|edc_mode
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Failed to get valid module type\n"
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|elink_verify_sfp_module
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Check SFP+ module compatibility */
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Module verification failed!!\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ELINK_STATUS_ERROR
expr_stmt|;
comment|/* Turn on fault module-detected led */
name|elink_set_sfp_module_fault_led
argument_list|(
name|params
argument_list|,
name|MISC_REGISTERS_GPIO_HIGH
argument_list|)
expr_stmt|;
comment|/* Check if need to power down the SFP+ module */
if|if
condition|(
operator|(
name|val
operator|&
name|PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_MASK
operator|)
operator|==
name|PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_POWER_DOWN
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Shutdown SFP+ module!!\n"
argument_list|)
expr_stmt|;
name|elink_power_sfp_module
argument_list|(
name|params
argument_list|,
name|phy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
block|}
else|else
block|{
comment|/* Turn off fault module-detected led */
name|elink_set_sfp_module_fault_led
argument_list|(
name|params
argument_list|,
name|MISC_REGISTERS_GPIO_LOW
argument_list|)
expr_stmt|;
block|}
comment|/* Check and set limiting mode / LRM mode on 8726. On 8727 it 	 * is done automatically 	 */
name|elink_set_limiting_mode
argument_list|(
name|params
argument_list|,
name|phy
argument_list|,
name|edc_mode
argument_list|)
expr_stmt|;
comment|/* Disable transmit for this module if the module is not approved, and 	 * laser needs to be disabled. 	 */
if|if
condition|(
operator|(
name|rc
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|val
operator|&
name|PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_MASK
operator|)
operator|==
name|PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_DISABLE_TX_LASER
operator|)
condition|)
name|elink_sfp_set_transmitter
argument_list|(
name|params
argument_list|,
name|phy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|void
name|elink_handle_module_detect_int
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|struct
name|elink_phy
modifier|*
name|phy
decl_stmt|;
name|uint32_t
name|gpio_val
decl_stmt|;
name|uint8_t
name|gpio_num
decl_stmt|,
name|gpio_port
decl_stmt|;
if|if
condition|(
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|phy
operator|=
operator|&
name|params
operator|->
name|phy
index|[
name|ELINK_INT_PHY
index|]
expr_stmt|;
comment|/* Always enable TX laser,will be disabled in case of fault */
name|elink_sfp_set_transmitter
argument_list|(
name|params
argument_list|,
name|phy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|phy
operator|=
operator|&
name|params
operator|->
name|phy
index|[
name|ELINK_EXT_PHY1
index|]
expr_stmt|;
block|}
if|if
condition|(
name|elink_get_mod_abs_int_cfg
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|chip_id
argument_list|,
name|params
operator|->
name|shmem_base
argument_list|,
name|params
operator|->
name|port
argument_list|,
operator|&
name|gpio_num
argument_list|,
operator|&
name|gpio_port
argument_list|)
operator|==
name|ELINK_STATUS_ERROR
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Failed to get MOD_ABS interrupt config\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Set valid module led off */
name|elink_set_sfp_module_fault_led
argument_list|(
name|params
argument_list|,
name|MISC_REGISTERS_GPIO_HIGH
argument_list|)
expr_stmt|;
comment|/* Get current gpio val reflecting module plugged in / out*/
name|gpio_val
operator|=
name|elink_cb_gpio_read
argument_list|(
name|sc
argument_list|,
name|gpio_num
argument_list|,
name|gpio_port
argument_list|)
expr_stmt|;
comment|/* Call the handling function in case module is detected */
if|if
condition|(
name|gpio_val
operator|==
literal|0
condition|)
block|{
name|elink_set_mdio_emac_per_phy
argument_list|(
name|sc
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|elink_set_aer_mmd
argument_list|(
name|params
argument_list|,
name|phy
argument_list|)
expr_stmt|;
name|elink_power_sfp_module
argument_list|(
name|params
argument_list|,
name|phy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|elink_cb_gpio_int_write
argument_list|(
name|sc
argument_list|,
name|gpio_num
argument_list|,
name|MISC_REGISTERS_GPIO_INT_OUTPUT_CLR
argument_list|,
name|gpio_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|elink_wait_for_sfp_module_initialized
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
operator|==
literal|0
condition|)
block|{
name|elink_sfp_module_detection
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|uint16_t
name|rx_tx_in_reset
decl_stmt|;
comment|/* In case WC is out of reset, reconfigure the 				 * link speed while taking into account 1G 				 * module limitation. 				 */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_DIGITAL5_MISC6
argument_list|,
operator|&
name|rx_tx_in_reset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|rx_tx_in_reset
operator|)
operator|&&
operator|(
name|params
operator|->
name|link_flags
operator|&
name|ELINK_PHY_INITIALIZED
operator|)
condition|)
block|{
name|elink_warpcore_reset_lane
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|elink_warpcore_config_sfi
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|elink_warpcore_reset_lane
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"SFP+ module is not initialized\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|elink_cb_gpio_int_write
argument_list|(
name|sc
argument_list|,
name|gpio_num
argument_list|,
name|MISC_REGISTERS_GPIO_INT_OUTPUT_SET
argument_list|,
name|gpio_port
argument_list|)
expr_stmt|;
comment|/* Module was plugged out. 		 * Disable transmit for this module 		 */
name|phy
operator|->
name|media_type
operator|=
name|ELINK_ETH_PHY_NOT_PRESENT
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************/
end_comment

begin_comment
comment|/*		Used by 8706 and 8727                             */
end_comment

begin_comment
comment|/******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|elink_sfp_mask_fault
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|uint16_t
name|alarm_status_offset
parameter_list|,
name|uint16_t
name|alarm_ctrl_offset
parameter_list|)
block|{
name|uint16_t
name|alarm_status
decl_stmt|,
name|val
decl_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|alarm_status_offset
argument_list|,
operator|&
name|alarm_status
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|alarm_status_offset
argument_list|,
operator|&
name|alarm_status
argument_list|)
expr_stmt|;
comment|/* Mask or enable the fault event. */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|alarm_ctrl_offset
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|alarm_status
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
condition|)
name|val
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|0
operator|)
expr_stmt|;
else|else
name|val
operator||=
operator|(
literal|1
operator|<<
literal|0
operator|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|alarm_ctrl_offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************/
end_comment

begin_comment
comment|/*		common BCM8706/BCM8726 PHY SECTION		  */
end_comment

begin_comment
comment|/******************************************************************/
end_comment

begin_function
specifier|static
name|uint8_t
name|elink_8706_8726_read_status
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|uint8_t
name|link_up
init|=
literal|0
decl_stmt|;
name|uint16_t
name|val1
decl_stmt|,
name|val2
decl_stmt|,
name|rx_sd
decl_stmt|,
name|pcs_status
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"XGXS 8706/8726\n"
argument_list|)
expr_stmt|;
comment|/* Clear RX Alarm*/
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_LASI_RXSTAT
argument_list|,
operator|&
name|val2
argument_list|)
expr_stmt|;
name|elink_sfp_mask_fault
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_LASI_TXSTAT
argument_list|,
name|MDIO_PMA_LASI_TXCTRL
argument_list|)
expr_stmt|;
comment|/* Clear LASI indication*/
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_LASI_STAT
argument_list|,
operator|&
name|val1
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_LASI_STAT
argument_list|,
operator|&
name|val2
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"8706/8726 LASI status 0x%x--> 0x%x\n"
argument_list|,
name|val1
argument_list|,
name|val2
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_RX_SD
argument_list|,
operator|&
name|rx_sd
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PCS_DEVAD
argument_list|,
name|MDIO_PCS_REG_STATUS
argument_list|,
operator|&
name|pcs_status
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_LINK_STATUS
argument_list|,
operator|&
name|val2
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_LINK_STATUS
argument_list|,
operator|&
name|val2
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P3
argument_list|(
name|sc
argument_list|,
literal|"8706/8726 rx_sd 0x%x pcs_status 0x%x 1Gbps"
literal|" link_status 0x%x\n"
argument_list|,
name|rx_sd
argument_list|,
name|pcs_status
argument_list|,
name|val2
argument_list|)
expr_stmt|;
comment|/* Link is up if both bit 0 of pmd_rx_sd and bit 0 of pcs_status 	 * are set, or if the autoneg bit 1 is set 	 */
name|link_up
operator|=
operator|(
operator|(
name|rx_sd
operator|&
name|pcs_status
operator|&
literal|0x1
operator|)
operator|||
operator|(
name|val2
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|link_up
condition|)
block|{
if|if
condition|(
name|val2
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
condition|)
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_1000
expr_stmt|;
else|else
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_10000
expr_stmt|;
name|elink_ext_phy_resolve_fc
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
name|vars
operator|->
name|duplex
operator|=
name|DUPLEX_FULL
expr_stmt|;
block|}
comment|/* Capture 10G link fault. Read twice to clear stale value. */
if|if
condition|(
name|vars
operator|->
name|line_speed
operator|==
name|ELINK_SPEED_10000
condition|)
block|{
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_LASI_TXSTAT
argument_list|,
operator|&
name|val1
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_LASI_TXSTAT
argument_list|,
operator|&
name|val1
argument_list|)
expr_stmt|;
if|if
condition|(
name|val1
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
condition|)
name|vars
operator|->
name|fault_detected
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|link_up
return|;
block|}
end_function

begin_comment
comment|/******************************************************************/
end_comment

begin_comment
comment|/*			BCM8706 PHY SECTION			  */
end_comment

begin_comment
comment|/******************************************************************/
end_comment

begin_function
specifier|static
name|uint8_t
name|elink_8706_config_init
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|uint32_t
name|tx_en_mode
decl_stmt|;
name|uint16_t
name|cnt
decl_stmt|,
name|val
decl_stmt|,
name|tmp1
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|elink_cb_gpio_write
argument_list|(
name|sc
argument_list|,
name|MISC_REGISTERS_GPIO_2
argument_list|,
name|MISC_REGISTERS_GPIO_OUTPUT_HIGH
argument_list|,
name|params
operator|->
name|port
argument_list|)
expr_stmt|;
comment|/* HW reset */
name|elink_ext_phy_hw_reset
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|port
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_CTRL
argument_list|,
literal|0xa040
argument_list|)
expr_stmt|;
name|elink_wait_reset_complete
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|params
argument_list|)
expr_stmt|;
comment|/* Wait until fw is loaded */
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
literal|100
condition|;
name|cnt
operator|++
control|)
block|{
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_ROM_VER1
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
break|break;
name|DELAY
argument_list|(
literal|1000
operator|*
literal|10
argument_list|)
expr_stmt|;
block|}
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"XGXS 8706 is initialized after %d ms\n"
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|params
operator|->
name|feature_config_flags
operator|&
name|ELINK_FEATURE_CONFIG_OVERRIDE_PREEMPHASIS_ENABLED
operator|)
condition|)
block|{
name|uint8_t
name|i
decl_stmt|;
name|uint16_t
name|reg
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|reg
operator|=
name|MDIO_XS_8706_REG_BANK_RX0
operator|+
name|i
operator|*
operator|(
name|MDIO_XS_8706_REG_BANK_RX1
operator|-
name|MDIO_XS_8706_REG_BANK_RX0
operator|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_XS_DEVAD
argument_list|,
name|reg
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
comment|/* Clear first 3 bits of the control */
name|val
operator|&=
operator|~
literal|0x7
expr_stmt|;
comment|/* Set control bits according to configuration */
name|val
operator||=
operator|(
name|phy
operator|->
name|rx_preemphasis
index|[
name|i
index|]
operator|&
literal|0x7
operator|)
expr_stmt|;
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"Setting RX Equalizer to BCM8706"
literal|" reg 0x%x<-- val 0x%x\n"
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_XS_DEVAD
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Force speed */
if|if
condition|(
name|phy
operator|->
name|req_line_speed
operator|==
name|ELINK_SPEED_10000
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"XGXS 8706 force 10Gbps\n"
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_DIGITAL_CTRL
argument_list|,
literal|0x400
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_LASI_TXCTRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Arm LASI for link and Tx fault. */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_LASI_CTRL
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Force 1Gbps using autoneg with 1G advertisement */
comment|/* Allow CL37 through CL73 */
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"XGXS 8706 AutoNeg\n"
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_CL37_CL73
argument_list|,
literal|0x040c
argument_list|)
expr_stmt|;
comment|/* Enable Full-Duplex advertisement on CL37 */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_CL37_FC_LP
argument_list|,
literal|0x0020
argument_list|)
expr_stmt|;
comment|/* Enable CL37 AN */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_CL37_AN
argument_list|,
literal|0x1000
argument_list|)
expr_stmt|;
comment|/* 1G support */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_ADV
argument_list|,
operator|(
literal|1
operator|<<
literal|5
operator|)
argument_list|)
expr_stmt|;
comment|/* Enable clause 73 AN */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_CTRL
argument_list|,
literal|0x1200
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_LASI_RXCTRL
argument_list|,
literal|0x0400
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_LASI_CTRL
argument_list|,
literal|0x0004
argument_list|)
expr_stmt|;
block|}
name|elink_save_bcm_spirom_ver
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|params
operator|->
name|port
argument_list|)
expr_stmt|;
comment|/* If TX Laser is controlled by GPIO_0, do not let PHY go into low 	 * power mode, if TX Laser is disabled 	 */
name|tx_en_mode
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|params
operator|->
name|port
index|]
operator|.
name|sfp_ctrl
argument_list|)
argument_list|)
operator|&
name|PORT_HW_CFG_TX_LASER_MASK
expr_stmt|;
if|if
condition|(
name|tx_en_mode
operator|==
name|PORT_HW_CFG_TX_LASER_GPIO0
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Enabling TXONOFF_PWRDN_DIS\n"
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_DIGITAL_CTRL
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|tmp1
operator||=
literal|0x1
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_DIGITAL_CTRL
argument_list|,
name|tmp1
argument_list|)
expr_stmt|;
block|}
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_8706_read_status
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
return|return
name|elink_8706_8726_read_status
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************/
end_comment

begin_comment
comment|/*			BCM8726 PHY SECTION			  */
end_comment

begin_comment
comment|/******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|elink_8726_config_loopback
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"PMA/PMD ext_phy_loopback: 8726\n"
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_CTRL
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_8726_external_rom_boot
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
comment|/* Need to wait 100ms after reset */
name|DELAY
argument_list|(
literal|1000
operator|*
literal|100
argument_list|)
expr_stmt|;
comment|/* Micro controller re-boot */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_GEN_CTRL
argument_list|,
literal|0x018B
argument_list|)
expr_stmt|;
comment|/* Set soft reset */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_GEN_CTRL
argument_list|,
name|MDIO_PMA_REG_GEN_CTRL_ROM_MICRO_RESET
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_MISC_CTRL1
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_GEN_CTRL
argument_list|,
name|MDIO_PMA_REG_GEN_CTRL_ROM_RESET_INTERNAL_MP
argument_list|)
expr_stmt|;
comment|/* Wait for 150ms for microcode load */
name|DELAY
argument_list|(
literal|1000
operator|*
literal|150
argument_list|)
expr_stmt|;
comment|/* Disable serial boot control, tristates pins SS_N, SCK, MOSI, MISO */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_MISC_CTRL1
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
operator|*
literal|200
argument_list|)
expr_stmt|;
name|elink_save_bcm_spirom_ver
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|params
operator|->
name|port
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|elink_8726_read_status
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint16_t
name|val1
decl_stmt|;
name|uint8_t
name|link_up
init|=
name|elink_8706_8726_read_status
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|)
decl_stmt|;
if|if
condition|(
name|link_up
condition|)
block|{
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_PHY_IDENTIFIER
argument_list|,
operator|&
name|val1
argument_list|)
expr_stmt|;
if|if
condition|(
name|val1
operator|&
operator|(
literal|1
operator|<<
literal|15
operator|)
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Tx is disabled\n"
argument_list|)
expr_stmt|;
name|link_up
operator|=
literal|0
expr_stmt|;
name|vars
operator|->
name|line_speed
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|link_up
return|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_8726_config_init
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Initializing BCM8726\n"
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_CTRL
argument_list|,
literal|1
operator|<<
literal|15
argument_list|)
expr_stmt|;
name|elink_wait_reset_complete
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|elink_8726_external_rom_boot
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
expr_stmt|;
comment|/* Need to call module detected on initialization since the module 	 * detection triggered by actual module insertion might occur before 	 * driver is loaded, and when driver is loaded, it reset all 	 * registers, including the transmitter 	 */
name|elink_sfp_module_detection
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|req_line_speed
operator|==
name|ELINK_SPEED_1000
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Setting 1G force\n"
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_CTRL
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_10G_CTRL2
argument_list|,
literal|0xD
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_LASI_CTRL
argument_list|,
literal|0x5
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_LASI_RXCTRL
argument_list|,
literal|0x400
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|phy
operator|->
name|req_line_speed
operator|==
name|ELINK_SPEED_AUTO_NEG
operator|)
operator|&&
operator|(
name|phy
operator|->
name|speed_cap_mask
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_1G
operator|)
operator|&&
operator|(
operator|(
name|phy
operator|->
name|speed_cap_mask
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_10G
operator|)
operator|!=
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_10G
operator|)
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Setting 1G clause37\n"
argument_list|)
expr_stmt|;
comment|/* Set Flow control */
name|elink_ext_phy_set_pause
argument_list|(
name|params
argument_list|,
name|phy
argument_list|,
name|vars
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_ADV
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_CL37_CL73
argument_list|,
literal|0x040c
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_CL37_FC_LD
argument_list|,
literal|0x0020
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_CL37_AN
argument_list|,
literal|0x1000
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_CTRL
argument_list|,
literal|0x1200
argument_list|)
expr_stmt|;
comment|/* Enable RX-ALARM control to receive interrupt for 1G speed 		 * change 		 */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_LASI_CTRL
argument_list|,
literal|0x4
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_LASI_RXCTRL
argument_list|,
literal|0x400
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Default 10G. Set only LASI control */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_LASI_CTRL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Set TX PreEmphasis if needed */
if|if
condition|(
operator|(
name|params
operator|->
name|feature_config_flags
operator|&
name|ELINK_FEATURE_CONFIG_OVERRIDE_PREEMPHASIS_ENABLED
operator|)
condition|)
block|{
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"Setting TX_CTRL1 0x%x, TX_CTRL2 0x%x\n"
argument_list|,
name|phy
operator|->
name|tx_preemphasis
index|[
literal|0
index|]
argument_list|,
name|phy
operator|->
name|tx_preemphasis
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8726_TX_CTRL1
argument_list|,
name|phy
operator|->
name|tx_preemphasis
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8726_TX_CTRL2
argument_list|,
name|phy
operator|->
name|tx_preemphasis
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_8726_link_reset
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"elink_8726_link_reset port %d\n"
argument_list|,
name|params
operator|->
name|port
argument_list|)
expr_stmt|;
comment|/* Set serial boot control for external load */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_GEN_CTRL
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************/
end_comment

begin_comment
comment|/*			BCM8727 PHY SECTION			  */
end_comment

begin_comment
comment|/******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|elink_8727_set_link_led
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint8_t
name|mode
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint16_t
name|led_mode_bitmask
init|=
literal|0
decl_stmt|;
name|uint16_t
name|gpio_pins_bitmask
init|=
literal|0
decl_stmt|;
name|uint16_t
name|val
decl_stmt|;
comment|/* Only NOC flavor requires to set the LED specifically */
if|if
condition|(
operator|!
operator|(
name|phy
operator|->
name|flags
operator|&
name|ELINK_FLAGS_NOC
operator|)
condition|)
return|return;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|ELINK_LED_MODE_FRONT_PANEL_OFF
case|:
case|case
name|ELINK_LED_MODE_OFF
case|:
name|led_mode_bitmask
operator|=
literal|0
expr_stmt|;
name|gpio_pins_bitmask
operator|=
literal|0x03
expr_stmt|;
break|break;
case|case
name|ELINK_LED_MODE_ON
case|:
name|led_mode_bitmask
operator|=
literal|0
expr_stmt|;
name|gpio_pins_bitmask
operator|=
literal|0x02
expr_stmt|;
break|break;
case|case
name|ELINK_LED_MODE_OPER
case|:
name|led_mode_bitmask
operator|=
literal|0x60
expr_stmt|;
name|gpio_pins_bitmask
operator|=
literal|0x11
expr_stmt|;
break|break;
block|}
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8727_PCS_OPT_CTRL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|val
operator|&=
literal|0xff8f
expr_stmt|;
name|val
operator||=
name|led_mode_bitmask
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8727_PCS_OPT_CTRL
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8727_GPIO_CTRL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|val
operator|&=
literal|0xffe0
expr_stmt|;
name|val
operator||=
name|gpio_pins_bitmask
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8727_GPIO_CTRL
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_8727_hw_reset
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|uint32_t
name|swap_val
decl_stmt|,
name|swap_override
decl_stmt|;
name|uint8_t
name|port
decl_stmt|;
comment|/* The PHY reset is controlled by GPIO 1. Fake the port number 	 * to cancel the swap done in set_gpio() 	 */
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|swap_val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_PORT_SWAP
argument_list|)
expr_stmt|;
name|swap_override
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_STRAP_OVERRIDE
argument_list|)
expr_stmt|;
name|port
operator|=
operator|(
name|swap_val
operator|&&
name|swap_override
operator|)
operator|^
literal|1
expr_stmt|;
name|elink_cb_gpio_write
argument_list|(
name|sc
argument_list|,
name|MISC_REGISTERS_GPIO_1
argument_list|,
name|MISC_REGISTERS_GPIO_OUTPUT_LOW
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_8727_config_speed
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint16_t
name|tmp1
decl_stmt|,
name|val
decl_stmt|;
comment|/* Set option 1G speed */
if|if
condition|(
operator|(
name|phy
operator|->
name|req_line_speed
operator|==
name|ELINK_SPEED_1000
operator|)
operator|||
operator|(
name|phy
operator|->
name|media_type
operator|==
name|ELINK_ETH_PHY_SFP_1G_FIBER
operator|)
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Setting 1G force\n"
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_CTRL
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_10G_CTRL2
argument_list|,
literal|0xD
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_10G_CTRL2
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"1.7 = 0x%x\n"
argument_list|,
name|tmp1
argument_list|)
expr_stmt|;
comment|/* Power down the XAUI until link is up in case of dual-media 		 * and 1G 		 */
if|if
condition|(
name|ELINK_DUAL_MEDIA
argument_list|(
name|params
argument_list|)
condition|)
block|{
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8727_PCS_GP
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|val
operator||=
operator|(
literal|3
operator|<<
literal|10
operator|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8727_PCS_GP
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|phy
operator|->
name|req_line_speed
operator|==
name|ELINK_SPEED_AUTO_NEG
operator|)
operator|&&
operator|(
operator|(
name|phy
operator|->
name|speed_cap_mask
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_1G
operator|)
operator|)
operator|&&
operator|(
operator|(
name|phy
operator|->
name|speed_cap_mask
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_10G
operator|)
operator|!=
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_10G
operator|)
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Setting 1G clause37\n"
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_8727_MISC_CTRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_CL37_AN
argument_list|,
literal|0x1300
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Since the 8727 has only single reset pin, need to set the 10G 		 * registers although it is default 		 */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_8727_MISC_CTRL
argument_list|,
literal|0x0020
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_CL37_AN
argument_list|,
literal|0x0100
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_CTRL
argument_list|,
literal|0x2040
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_10G_CTRL2
argument_list|,
literal|0x0008
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_8727_config_init
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|uint32_t
name|tx_en_mode
decl_stmt|;
name|uint16_t
name|tmp1
decl_stmt|,
name|mod_abs
decl_stmt|,
name|tmp2
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
comment|/* Enable PMD link, MOD_ABS_FLT, and 1G link alarm */
name|elink_wait_reset_complete
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Initializing BCM8727\n"
argument_list|)
expr_stmt|;
name|elink_8727_specific_func
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|ELINK_PHY_INIT
argument_list|)
expr_stmt|;
comment|/* Initially configure MOD_ABS to interrupt when module is 	 * presence( bit 8) 	 */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_PHY_IDENTIFIER
argument_list|,
operator|&
name|mod_abs
argument_list|)
expr_stmt|;
comment|/* Set EDC off by setting OPTXLOS signal input to low (bit 9). 	 * When the EDC is off it locks onto a reference clock and avoids 	 * becoming 'lost' 	 */
name|mod_abs
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|8
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|phy
operator|->
name|flags
operator|&
name|ELINK_FLAGS_NOC
operator|)
condition|)
name|mod_abs
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|9
operator|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_PHY_IDENTIFIER
argument_list|,
name|mod_abs
argument_list|)
expr_stmt|;
comment|/* Enable/Disable PHY transmitter output */
name|elink_set_disable_pmd_transmit
argument_list|(
name|params
argument_list|,
name|phy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|elink_8727_power_module
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_M8051_MSGOUT_REG
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_LASI_RXSTAT
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|elink_8727_config_speed
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
expr_stmt|;
comment|/* Set TX PreEmphasis if needed */
if|if
condition|(
operator|(
name|params
operator|->
name|feature_config_flags
operator|&
name|ELINK_FEATURE_CONFIG_OVERRIDE_PREEMPHASIS_ENABLED
operator|)
condition|)
block|{
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"Setting TX_CTRL1 0x%x, TX_CTRL2 0x%x\n"
argument_list|,
name|phy
operator|->
name|tx_preemphasis
index|[
literal|0
index|]
argument_list|,
name|phy
operator|->
name|tx_preemphasis
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8727_TX_CTRL1
argument_list|,
name|phy
operator|->
name|tx_preemphasis
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8727_TX_CTRL2
argument_list|,
name|phy
operator|->
name|tx_preemphasis
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* If TX Laser is controlled by GPIO_0, do not let PHY go into low 	 * power mode, if TX Laser is disabled 	 */
name|tx_en_mode
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|params
operator|->
name|port
index|]
operator|.
name|sfp_ctrl
argument_list|)
argument_list|)
operator|&
name|PORT_HW_CFG_TX_LASER_MASK
expr_stmt|;
if|if
condition|(
name|tx_en_mode
operator|==
name|PORT_HW_CFG_TX_LASER_GPIO0
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Enabling TXONOFF_PWRDN_DIS\n"
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8727_OPT_CFG_REG
argument_list|,
operator|&
name|tmp2
argument_list|)
expr_stmt|;
name|tmp2
operator||=
literal|0x1000
expr_stmt|;
name|tmp2
operator|&=
literal|0xFFEF
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8727_OPT_CFG_REG
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_PHY_IDENTIFIER
argument_list|,
operator|&
name|tmp2
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_PHY_IDENTIFIER
argument_list|,
operator|(
name|tmp2
operator|&
literal|0x7fff
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_8727_handle_mod_abs
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint16_t
name|mod_abs
decl_stmt|,
name|rx_alarm_status
decl_stmt|;
name|uint32_t
name|val
init|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_feature_config
index|[
name|params
operator|->
name|port
index|]
operator|.
name|config
argument_list|)
argument_list|)
decl_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_PHY_IDENTIFIER
argument_list|,
operator|&
name|mod_abs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mod_abs
operator|&
operator|(
literal|1
operator|<<
literal|8
operator|)
condition|)
block|{
comment|/* Module is absent */
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"MOD_ABS indication show module is absent\n"
argument_list|)
expr_stmt|;
name|phy
operator|->
name|media_type
operator|=
name|ELINK_ETH_PHY_NOT_PRESENT
expr_stmt|;
comment|/* 1. Set mod_abs to detect next module 		 *    presence event 		 * 2. Set EDC off by setting OPTXLOS signal input to low 		 *    (bit 9). 		 *    When the EDC is off it locks onto a reference clock and 		 *    avoids becoming 'lost'. 		 */
name|mod_abs
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|8
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|phy
operator|->
name|flags
operator|&
name|ELINK_FLAGS_NOC
operator|)
condition|)
name|mod_abs
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|9
operator|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_PHY_IDENTIFIER
argument_list|,
name|mod_abs
argument_list|)
expr_stmt|;
comment|/* Clear RX alarm since it stays up as long as 		 * the mod_abs wasn't changed 		 */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_LASI_RXSTAT
argument_list|,
operator|&
name|rx_alarm_status
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Module is present */
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"MOD_ABS indication show module is present\n"
argument_list|)
expr_stmt|;
comment|/* First disable transmitter, and if the module is ok, the 		 * module_detection will enable it 		 * 1. Set mod_abs to detect next module absent event ( bit 8) 		 * 2. Restore the default polarity of the OPRXLOS signal and 		 * this signal will then correctly indicate the presence or 		 * absence of the Rx signal. (bit 9) 		 */
name|mod_abs
operator||=
operator|(
literal|1
operator|<<
literal|8
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|phy
operator|->
name|flags
operator|&
name|ELINK_FLAGS_NOC
operator|)
condition|)
name|mod_abs
operator||=
operator|(
literal|1
operator|<<
literal|9
operator|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_PHY_IDENTIFIER
argument_list|,
name|mod_abs
argument_list|)
expr_stmt|;
comment|/* Clear RX alarm since it stays up as long as the mod_abs 		 * wasn't changed. This is need to be done before calling the 		 * module detection, otherwise it will clear* the link update 		 * alarm 		 */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_LASI_RXSTAT
argument_list|,
operator|&
name|rx_alarm_status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_MASK
operator|)
operator|==
name|PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_DISABLE_TX_LASER
condition|)
name|elink_sfp_set_transmitter
argument_list|(
name|params
argument_list|,
name|phy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|elink_wait_for_sfp_module_initialized
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
operator|==
literal|0
condition|)
name|elink_sfp_module_detection
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
expr_stmt|;
else|else
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"SFP+ module is not initialized\n"
argument_list|)
expr_stmt|;
comment|/* Reconfigure link speed based on module type limitations */
name|elink_8727_config_speed
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
expr_stmt|;
block|}
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"8727 RX_ALARM_STATUS 0x%x\n"
argument_list|,
name|rx_alarm_status
argument_list|)
expr_stmt|;
comment|/* No need to check link status in case of module plugged in/out */
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|elink_8727_read_status
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint8_t
name|link_up
init|=
literal|0
decl_stmt|;
name|uint16_t
name|link_status
init|=
literal|0
decl_stmt|;
name|uint16_t
name|rx_alarm_status
decl_stmt|,
name|lasi_ctrl
decl_stmt|,
name|val1
decl_stmt|;
comment|/* If PHY is not initialized, do not check link status */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_LASI_CTRL
argument_list|,
operator|&
name|lasi_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lasi_ctrl
condition|)
return|return
literal|0
return|;
comment|/* Check the LASI on Rx */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_LASI_RXSTAT
argument_list|,
operator|&
name|rx_alarm_status
argument_list|)
expr_stmt|;
name|vars
operator|->
name|line_speed
operator|=
literal|0
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"8727 RX_ALARM_STATUS  0x%x\n"
argument_list|,
name|rx_alarm_status
argument_list|)
expr_stmt|;
name|elink_sfp_mask_fault
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_LASI_TXSTAT
argument_list|,
name|MDIO_PMA_LASI_TXCTRL
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_LASI_STAT
argument_list|,
operator|&
name|val1
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"8727 LASI status 0x%x\n"
argument_list|,
name|val1
argument_list|)
expr_stmt|;
comment|/* Clear MSG-OUT */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_M8051_MSGOUT_REG
argument_list|,
operator|&
name|val1
argument_list|)
expr_stmt|;
comment|/* If a module is present and there is need to check 	 * for over current 	 */
if|if
condition|(
operator|!
operator|(
name|phy
operator|->
name|flags
operator|&
name|ELINK_FLAGS_NOC
operator|)
operator|&&
operator|!
operator|(
name|rx_alarm_status
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
operator|)
condition|)
block|{
comment|/* Check over-current using 8727 GPIO0 input*/
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8727_GPIO_CTRL
argument_list|,
operator|&
name|val1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val1
operator|&
operator|(
literal|1
operator|<<
literal|8
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|uint8_t
name|oc_port
init|=
name|params
operator|->
name|port
decl_stmt|;
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
name|oc_port
operator|=
name|SC_PATH
argument_list|(
name|sc
argument_list|)
operator|+
operator|(
name|params
operator|->
name|port
operator|<<
literal|1
operator|)
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"8727 Power fault has been detected on port %d\n"
argument_list|,
name|oc_port
argument_list|)
expr_stmt|;
name|elink_cb_event_log
argument_list|(
name|sc
argument_list|,
name|ELINK_LOG_ID_OVER_CURRENT
argument_list|,
name|oc_port
argument_list|)
expr_stmt|;
comment|//"Error: Power fault on Port %d has "
comment|//  "been detected and the power to "
comment|//  "that SFP+ module has been removed "
comment|//  "to prevent failure of the card. "
comment|//  "Please remove the SFP+ module and "
comment|//  "restart the system to clear this "
comment|//  "error.\n",
comment|/* Disable all RX_ALARMs except for mod_abs */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_LASI_RXCTRL
argument_list|,
operator|(
literal|1
operator|<<
literal|5
operator|)
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_PHY_IDENTIFIER
argument_list|,
operator|&
name|val1
argument_list|)
expr_stmt|;
comment|/* Wait for module_absent_event */
name|val1
operator||=
operator|(
literal|1
operator|<<
literal|8
operator|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_PHY_IDENTIFIER
argument_list|,
name|val1
argument_list|)
expr_stmt|;
comment|/* Clear RX alarm */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_LASI_RXSTAT
argument_list|,
operator|&
name|rx_alarm_status
argument_list|)
expr_stmt|;
name|elink_8727_power_module
argument_list|(
name|params
operator|->
name|sc
argument_list|,
name|phy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* Over current check */
comment|/* When module absent bit is set, check module */
if|if
condition|(
name|rx_alarm_status
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
condition|)
block|{
name|elink_8727_handle_mod_abs
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
expr_stmt|;
comment|/* Enable all mod_abs and link detection bits */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_LASI_RXCTRL
argument_list|,
operator|(
operator|(
literal|1
operator|<<
literal|5
operator|)
operator||
operator|(
literal|1
operator|<<
literal|2
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|phy
operator|->
name|flags
operator|&
name|ELINK_FLAGS_SFP_NOT_APPROVED
operator|)
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Enabling 8727 TX laser\n"
argument_list|)
expr_stmt|;
name|elink_sfp_set_transmitter
argument_list|(
name|params
argument_list|,
name|phy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Tx is disabled\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8073_SPEED_LINK_STATUS
argument_list|,
operator|&
name|link_status
argument_list|)
expr_stmt|;
comment|/* Bits 0..2 --> speed detected, 	 * Bits 13..15--> link is down 	 */
if|if
condition|(
operator|(
name|link_status
operator|&
operator|(
literal|1
operator|<<
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|link_status
operator|&
operator|(
literal|1
operator|<<
literal|15
operator|)
operator|)
operator|)
condition|)
block|{
name|link_up
operator|=
literal|1
expr_stmt|;
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_10000
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"port %x: External link up in 10G\n"
argument_list|,
name|params
operator|->
name|port
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|link_status
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|link_status
operator|&
operator|(
literal|1
operator|<<
literal|13
operator|)
operator|)
operator|)
condition|)
block|{
name|link_up
operator|=
literal|1
expr_stmt|;
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_1000
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"port %x: External link up in 1G\n"
argument_list|,
name|params
operator|->
name|port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|link_up
operator|=
literal|0
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"port %x: External link is down\n"
argument_list|,
name|params
operator|->
name|port
argument_list|)
expr_stmt|;
block|}
comment|/* Capture 10G link fault. */
if|if
condition|(
name|vars
operator|->
name|line_speed
operator|==
name|ELINK_SPEED_10000
condition|)
block|{
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_LASI_TXSTAT
argument_list|,
operator|&
name|val1
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_LASI_TXSTAT
argument_list|,
operator|&
name|val1
argument_list|)
expr_stmt|;
if|if
condition|(
name|val1
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
condition|)
block|{
name|vars
operator|->
name|fault_detected
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|link_up
condition|)
block|{
name|elink_ext_phy_resolve_fc
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
name|vars
operator|->
name|duplex
operator|=
name|DUPLEX_FULL
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"duplex = 0x%x\n"
argument_list|,
name|vars
operator|->
name|duplex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ELINK_DUAL_MEDIA
argument_list|(
name|params
argument_list|)
operator|)
operator|&&
operator|(
name|phy
operator|->
name|req_line_speed
operator|==
name|ELINK_SPEED_1000
operator|)
condition|)
block|{
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8727_PCS_GP
argument_list|,
operator|&
name|val1
argument_list|)
expr_stmt|;
comment|/* In case of dual-media board and 1G, power up the XAUI side, 		 * otherwise power it down. For 10G it is done automatically 		 */
if|if
condition|(
name|link_up
condition|)
name|val1
operator|&=
operator|~
operator|(
literal|3
operator|<<
literal|10
operator|)
expr_stmt|;
else|else
name|val1
operator||=
operator|(
literal|3
operator|<<
literal|10
operator|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8727_PCS_GP
argument_list|,
name|val1
argument_list|)
expr_stmt|;
block|}
return|return
name|link_up
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_8727_link_reset
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
comment|/* Enable/Disable PHY transmitter output */
name|elink_set_disable_pmd_transmit
argument_list|(
name|params
argument_list|,
name|phy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Disable Transmitter */
name|elink_sfp_set_transmitter
argument_list|(
name|params
argument_list|,
name|phy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear LASI */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_LASI_CTRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************/
end_comment

begin_comment
comment|/*		BCM8481/BCM84823/BCM84833 PHY SECTION	          */
end_comment

begin_comment
comment|/******************************************************************/
end_comment

begin_function
specifier|static
name|int
name|elink_is_8483x_8485x
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|)
block|{
return|return
operator|(
operator|(
name|phy
operator|->
name|type
operator|==
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84833
operator|)
operator|||
operator|(
name|phy
operator|->
name|type
operator|==
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84834
operator|)
operator|||
operator|(
name|phy
operator|->
name|type
operator|==
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84858
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_save_848xx_spirom_version
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|port
parameter_list|)
block|{
name|uint16_t
name|val
decl_stmt|,
name|fw_ver2
decl_stmt|,
name|cnt
decl_stmt|,
name|i
decl_stmt|;
specifier|static
name|struct
name|elink_reg_set
name|reg_set
index|[]
init|=
block|{
block|{
name|MDIO_PMA_DEVAD
block|,
literal|0xA819
block|,
literal|0x0014
block|}
block|,
block|{
name|MDIO_PMA_DEVAD
block|,
literal|0xA81A
block|,
literal|0xc200
block|}
block|,
block|{
name|MDIO_PMA_DEVAD
block|,
literal|0xA81B
block|,
literal|0x0000
block|}
block|,
block|{
name|MDIO_PMA_DEVAD
block|,
literal|0xA81C
block|,
literal|0x0300
block|}
block|,
block|{
name|MDIO_PMA_DEVAD
block|,
literal|0xA817
block|,
literal|0x0009
block|}
block|}
decl_stmt|;
name|uint16_t
name|fw_ver1
decl_stmt|;
if|if
condition|(
name|elink_is_8483x_8485x
argument_list|(
name|phy
argument_list|)
condition|)
block|{
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_CTL_DEVAD
argument_list|,
literal|0x400f
argument_list|,
operator|&
name|fw_ver1
argument_list|)
expr_stmt|;
name|elink_save_spirom_version
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
name|fw_ver1
operator|&
literal|0xfff
argument_list|,
name|phy
operator|->
name|ver_addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* For 32-bit registers in 848xx, access via MDIO2ARM i/f. */
comment|/* (1) set reg 0xc200_0014(SPI_BRIDGE_CTRL_2) to 0x03000000 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|reg_set
argument_list|)
condition|;
name|i
operator|++
control|)
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|reg_set
index|[
name|i
index|]
operator|.
name|devad
argument_list|,
name|reg_set
index|[
name|i
index|]
operator|.
name|reg
argument_list|,
name|reg_set
index|[
name|i
index|]
operator|.
name|val
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
literal|100
condition|;
name|cnt
operator|++
control|)
block|{
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
literal|0xA818
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
literal|1
condition|)
break|break;
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cnt
operator|==
literal|100
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Unable to read 848xx "
literal|"phy fw version(1)\n"
argument_list|)
expr_stmt|;
name|elink_save_spirom_version
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
literal|0
argument_list|,
name|phy
operator|->
name|ver_addr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 2) read register 0xc200_0000 (SPI_FW_STATUS) */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
literal|0xA819
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
literal|0xA81A
argument_list|,
literal|0xc200
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
literal|0xA817
argument_list|,
literal|0x000A
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
literal|100
condition|;
name|cnt
operator|++
control|)
block|{
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
literal|0xA818
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
literal|1
condition|)
break|break;
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cnt
operator|==
literal|100
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Unable to read 848xx phy fw "
literal|"version(2)\n"
argument_list|)
expr_stmt|;
name|elink_save_spirom_version
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
literal|0
argument_list|,
name|phy
operator|->
name|ver_addr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* lower 16 bits of the register SPI_FW_STATUS */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
literal|0xA81B
argument_list|,
operator|&
name|fw_ver1
argument_list|)
expr_stmt|;
comment|/* upper 16 bits of register SPI_FW_STATUS */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
literal|0xA81C
argument_list|,
operator|&
name|fw_ver2
argument_list|)
expr_stmt|;
name|elink_save_spirom_version
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
operator|(
name|fw_ver2
operator|<<
literal|16
operator|)
operator||
name|fw_ver1
argument_list|,
name|phy
operator|->
name|ver_addr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|elink_848xx_set_led
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|)
block|{
name|uint16_t
name|val
decl_stmt|,
name|offset
decl_stmt|,
name|i
decl_stmt|;
specifier|static
name|struct
name|elink_reg_set
name|reg_set
index|[]
init|=
block|{
block|{
name|MDIO_PMA_DEVAD
block|,
name|MDIO_PMA_REG_8481_LED1_MASK
block|,
literal|0x0080
block|}
block|,
block|{
name|MDIO_PMA_DEVAD
block|,
name|MDIO_PMA_REG_8481_LED2_MASK
block|,
literal|0x0018
block|}
block|,
block|{
name|MDIO_PMA_DEVAD
block|,
name|MDIO_PMA_REG_8481_LED3_MASK
block|,
literal|0x0006
block|}
block|,
block|{
name|MDIO_PMA_DEVAD
block|,
name|MDIO_PMA_REG_8481_LED3_BLINK
block|,
literal|0x0000
block|}
block|,
block|{
name|MDIO_PMA_DEVAD
block|,
name|MDIO_PMA_REG_84823_CTL_SLOW_CLK_CNT_HIGH
block|,
name|MDIO_PMA_REG_84823_BLINK_RATE_VAL_15P9HZ
block|}
block|,
block|{
name|MDIO_AN_DEVAD
block|,
literal|0xFFFB
block|,
literal|0xFFFD
block|}
block|}
decl_stmt|;
comment|/* PHYC_CTL_LED_CTL */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8481_LINK_SIGNAL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|val
operator|&=
literal|0xFE00
expr_stmt|;
name|val
operator||=
literal|0x0092
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8481_LINK_SIGNAL
argument_list|,
name|val
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|reg_set
argument_list|)
condition|;
name|i
operator|++
control|)
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|reg_set
index|[
name|i
index|]
operator|.
name|devad
argument_list|,
name|reg_set
index|[
name|i
index|]
operator|.
name|reg
argument_list|,
name|reg_set
index|[
name|i
index|]
operator|.
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|elink_is_8483x_8485x
argument_list|(
name|phy
argument_list|)
condition|)
name|offset
operator|=
name|MDIO_PMA_REG_84833_CTL_LED_CTL_1
expr_stmt|;
else|else
name|offset
operator|=
name|MDIO_PMA_REG_84823_CTL_LED_CTL_1
expr_stmt|;
comment|/* stretch_en for LED3*/
name|elink_cl45_read_or_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|offset
argument_list|,
name|MDIO_PMA_REG_84823_LED3_STRETCH_EN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_848xx_specific_func
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint32_t
name|action
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|ELINK_PHY_INIT
case|:
if|if
condition|(
operator|!
name|elink_is_8483x_8485x
argument_list|(
name|phy
argument_list|)
condition|)
block|{
comment|/* Save spirom version */
name|elink_save_848xx_spirom_version
argument_list|(
name|phy
argument_list|,
name|sc
argument_list|,
name|params
operator|->
name|port
argument_list|)
expr_stmt|;
block|}
comment|/* This phy uses the NIG latch mechanism since link indication 		 * arrives through its LED4 and not via its LASI signal, so we 		 * get steady signal instead of clear on read 		 */
name|elink_bits_en
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LATCH_BC_0
operator|+
name|params
operator|->
name|port
operator|*
literal|4
argument_list|,
literal|1
operator|<<
name|ELINK_NIG_LATCH_BC_ENABLE_MI_INT
argument_list|)
expr_stmt|;
name|elink_848xx_set_led
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_848xx_cmn_config_init
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint16_t
name|autoneg_val
decl_stmt|,
name|an_1000_val
decl_stmt|,
name|an_10_100_val
decl_stmt|;
name|elink_848xx_specific_func
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|ELINK_PHY_INIT
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_CTRL
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
comment|/* set 1000 speed advertisement */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_8481_1000T_CTRL
argument_list|,
operator|&
name|an_1000_val
argument_list|)
expr_stmt|;
name|elink_ext_phy_set_pause
argument_list|(
name|params
argument_list|,
name|phy
argument_list|,
name|vars
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_8481_LEGACY_AN_ADV
argument_list|,
operator|&
name|an_10_100_val
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_8481_LEGACY_MII_CTRL
argument_list|,
operator|&
name|autoneg_val
argument_list|)
expr_stmt|;
comment|/* Disable forced speed */
name|autoneg_val
operator|&=
operator|~
operator|(
operator|(
literal|1
operator|<<
literal|6
operator|)
operator||
operator|(
literal|1
operator|<<
literal|8
operator|)
operator||
operator|(
literal|1
operator|<<
literal|9
operator|)
operator||
operator|(
literal|1
operator|<<
literal|12
operator|)
operator||
operator|(
literal|1
operator|<<
literal|13
operator|)
operator|)
expr_stmt|;
name|an_10_100_val
operator|&=
operator|~
operator|(
operator|(
literal|1
operator|<<
literal|5
operator|)
operator||
operator|(
literal|1
operator|<<
literal|6
operator|)
operator||
operator|(
literal|1
operator|<<
literal|7
operator|)
operator||
operator|(
literal|1
operator|<<
literal|8
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|phy
operator|->
name|req_line_speed
operator|==
name|ELINK_SPEED_AUTO_NEG
operator|)
operator|&&
operator|(
name|phy
operator|->
name|speed_cap_mask
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_1G
operator|)
operator|)
operator|||
operator|(
name|phy
operator|->
name|req_line_speed
operator|==
name|ELINK_SPEED_1000
operator|)
condition|)
block|{
name|an_1000_val
operator||=
operator|(
literal|1
operator|<<
literal|8
operator|)
expr_stmt|;
name|autoneg_val
operator||=
operator|(
literal|1
operator|<<
literal|9
operator||
literal|1
operator|<<
literal|12
operator|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|req_duplex
operator|==
name|DUPLEX_FULL
condition|)
name|an_1000_val
operator||=
operator|(
literal|1
operator|<<
literal|9
operator|)
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Advertising 1G\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|an_1000_val
operator|&=
operator|~
operator|(
operator|(
literal|1
operator|<<
literal|8
operator|)
operator||
operator|(
literal|1
operator|<<
literal|9
operator|)
operator|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_8481_1000T_CTRL
argument_list|,
name|an_1000_val
argument_list|)
expr_stmt|;
comment|/* Set 10/100 speed advertisement */
if|if
condition|(
name|phy
operator|->
name|req_line_speed
operator|==
name|ELINK_SPEED_AUTO_NEG
condition|)
block|{
if|if
condition|(
name|phy
operator|->
name|speed_cap_mask
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_100M_FULL
condition|)
block|{
comment|/* Enable autoneg and restart autoneg for legacy speeds 			 */
name|autoneg_val
operator||=
operator|(
literal|1
operator|<<
literal|9
operator||
literal|1
operator|<<
literal|12
operator|)
expr_stmt|;
name|an_10_100_val
operator||=
operator|(
literal|1
operator|<<
literal|8
operator|)
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Advertising 100M-FD\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|phy
operator|->
name|speed_cap_mask
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_100M_HALF
condition|)
block|{
comment|/* Enable autoneg and restart autoneg for legacy speeds 			 */
name|autoneg_val
operator||=
operator|(
literal|1
operator|<<
literal|9
operator||
literal|1
operator|<<
literal|12
operator|)
expr_stmt|;
name|an_10_100_val
operator||=
operator|(
literal|1
operator|<<
literal|7
operator|)
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Advertising 100M-HD\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|phy
operator|->
name|speed_cap_mask
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_10M_FULL
operator|)
operator|&&
operator|(
name|phy
operator|->
name|supported
operator|&
name|ELINK_SUPPORTED_10baseT_Full
operator|)
condition|)
block|{
name|an_10_100_val
operator||=
operator|(
literal|1
operator|<<
literal|6
operator|)
expr_stmt|;
name|autoneg_val
operator||=
operator|(
literal|1
operator|<<
literal|9
operator||
literal|1
operator|<<
literal|12
operator|)
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Advertising 10M-FD\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|phy
operator|->
name|speed_cap_mask
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_10M_HALF
operator|)
operator|&&
operator|(
name|phy
operator|->
name|supported
operator|&
name|ELINK_SUPPORTED_10baseT_Half
operator|)
condition|)
block|{
name|an_10_100_val
operator||=
operator|(
literal|1
operator|<<
literal|5
operator|)
expr_stmt|;
name|autoneg_val
operator||=
operator|(
literal|1
operator|<<
literal|9
operator||
literal|1
operator|<<
literal|12
operator|)
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Advertising 10M-HD\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Only 10/100 are allowed to work in FORCE mode */
if|if
condition|(
operator|(
name|phy
operator|->
name|req_line_speed
operator|==
name|ELINK_SPEED_100
operator|)
operator|&&
operator|(
name|phy
operator|->
name|supported
operator|&
operator|(
name|ELINK_SUPPORTED_100baseT_Half
operator||
name|ELINK_SUPPORTED_100baseT_Full
operator|)
operator|)
condition|)
block|{
name|autoneg_val
operator||=
operator|(
literal|1
operator|<<
literal|13
operator|)
expr_stmt|;
comment|/* Enabled AUTO-MDIX when autoneg is disabled */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_8481_AUX_CTRL
argument_list|,
operator|(
literal|1
operator|<<
literal|15
operator||
literal|1
operator|<<
literal|9
operator||
literal|7
operator|<<
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* The PHY needs this set even for forced link. */
name|an_10_100_val
operator||=
operator|(
literal|1
operator|<<
literal|8
operator|)
operator||
operator|(
literal|1
operator|<<
literal|7
operator|)
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Setting 100M force\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|phy
operator|->
name|req_line_speed
operator|==
name|ELINK_SPEED_10
operator|)
operator|&&
operator|(
name|phy
operator|->
name|supported
operator|&
operator|(
name|ELINK_SUPPORTED_10baseT_Half
operator||
name|ELINK_SUPPORTED_10baseT_Full
operator|)
operator|)
condition|)
block|{
comment|/* Enabled AUTO-MDIX when autoneg is disabled */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_8481_AUX_CTRL
argument_list|,
operator|(
literal|1
operator|<<
literal|15
operator||
literal|1
operator|<<
literal|9
operator||
literal|7
operator|<<
literal|0
operator|)
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Setting 10M force\n"
argument_list|)
expr_stmt|;
block|}
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_8481_LEGACY_AN_ADV
argument_list|,
name|an_10_100_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|req_duplex
operator|==
name|DUPLEX_FULL
condition|)
name|autoneg_val
operator||=
operator|(
literal|1
operator|<<
literal|8
operator|)
expr_stmt|;
comment|/* Always write this if this is not 84833/4. 	 * For 84833/4, write it only when it's a forced speed. 	 */
if|if
condition|(
operator|!
name|elink_is_8483x_8485x
argument_list|(
name|phy
argument_list|)
operator|||
operator|(
operator|(
name|autoneg_val
operator|&
operator|(
literal|1
operator|<<
literal|12
operator|)
operator|)
operator|==
literal|0
operator|)
condition|)
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_8481_LEGACY_MII_CTRL
argument_list|,
name|autoneg_val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|phy
operator|->
name|req_line_speed
operator|==
name|ELINK_SPEED_AUTO_NEG
operator|)
operator|&&
operator|(
name|phy
operator|->
name|speed_cap_mask
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_10G
operator|)
operator|)
operator|||
operator|(
name|phy
operator|->
name|req_line_speed
operator|==
name|ELINK_SPEED_10000
operator|)
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Advertising 10G\n"
argument_list|)
expr_stmt|;
comment|/* Restart autoneg for 10G*/
name|elink_cl45_read_or_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_8481_10GBASE_T_AN_CTRL
argument_list|,
literal|0x1000
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_CTRL
argument_list|,
literal|0x3200
argument_list|)
expr_stmt|;
block|}
else|else
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_8481_10GBASE_T_AN_CTRL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_8481_config_init
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
comment|/* Restore normal power mode*/
name|elink_cb_gpio_write
argument_list|(
name|sc
argument_list|,
name|MISC_REGISTERS_GPIO_2
argument_list|,
name|MISC_REGISTERS_GPIO_OUTPUT_HIGH
argument_list|,
name|params
operator|->
name|port
argument_list|)
expr_stmt|;
comment|/* HW reset */
name|elink_ext_phy_hw_reset
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|port
argument_list|)
expr_stmt|;
name|elink_wait_reset_complete
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_CTRL
argument_list|,
literal|1
operator|<<
literal|15
argument_list|)
expr_stmt|;
return|return
name|elink_848xx_cmn_config_init
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|PHY848xx_CMDHDLR_WAIT
value|300
end_define

begin_define
define|#
directive|define
name|PHY848xx_CMDHDLR_MAX_ARGS
value|5
end_define

begin_function
specifier|static
name|elink_status_t
name|elink_84858_cmd_hdlr
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint16_t
name|fw_cmd
parameter_list|,
name|uint16_t
name|cmd_args
index|[]
parameter_list|,
name|int
name|argc
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
name|uint16_t
name|val
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
comment|/* Step 1: Poll the STATUS register to see whether the previous command 	 * is in progress or the system is busy (CMD_IN_PROGRESS or 	 * SYSTEM_BUSY). If previous command is in progress or system is busy, 	 * check again until the previous command finishes execution and the 	 * system is available for taking command 	 */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|PHY848xx_CMDHDLR_WAIT
condition|;
name|idx
operator|++
control|)
block|{
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_CTL_DEVAD
argument_list|,
name|MDIO_848xx_CMD_HDLR_STATUS
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|!=
name|PHY84858_STATUS_CMD_IN_PROGRESS
operator|)
operator|&&
operator|(
name|val
operator|!=
name|PHY84858_STATUS_CMD_SYSTEM_BUSY
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|1000
operator|*
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|idx
operator|>=
name|PHY848xx_CMDHDLR_WAIT
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"FW cmd: FW not ready.\n"
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
comment|/* Step2: If any parameters are required for the function, write them 	 * to the required DATA registers 	 */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|argc
condition|;
name|idx
operator|++
control|)
block|{
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_CTL_DEVAD
argument_list|,
name|MDIO_848xx_CMD_HDLR_DATA1
operator|+
name|idx
argument_list|,
name|cmd_args
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Step3: When the firmware is ready for commands, write the 'Command 	 * code' to the CMD register 	 */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_CTL_DEVAD
argument_list|,
name|MDIO_848xx_CMD_HDLR_COMMAND
argument_list|,
name|fw_cmd
argument_list|)
expr_stmt|;
comment|/* Step4: Once the command has been written, poll the STATUS register 	 * to check whether the command has completed (CMD_COMPLETED_PASS/ 	 * CMD_FOR_CMDS or CMD_COMPLETED_ERROR). 	 */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|PHY848xx_CMDHDLR_WAIT
condition|;
name|idx
operator|++
control|)
block|{
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_CTL_DEVAD
argument_list|,
name|MDIO_848xx_CMD_HDLR_STATUS
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|==
name|PHY84858_STATUS_CMD_COMPLETE_PASS
operator|)
operator|||
operator|(
name|val
operator|==
name|PHY84858_STATUS_CMD_COMPLETE_ERROR
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|1000
operator|*
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|idx
operator|>=
name|PHY848xx_CMDHDLR_WAIT
operator|)
operator|||
operator|(
name|val
operator|==
name|PHY84858_STATUS_CMD_COMPLETE_ERROR
operator|)
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"FW cmd failed.\n"
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
comment|/* Step5: Once the command has completed, read the specficied DATA 	 * registers for any saved results for the command, if applicable 	 */
comment|/* Gather returning data */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|argc
condition|;
name|idx
operator|++
control|)
block|{
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_CTL_DEVAD
argument_list|,
name|MDIO_848xx_CMD_HDLR_DATA1
operator|+
name|idx
argument_list|,
operator|&
name|cmd_args
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_84833_cmd_hdlr
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint16_t
name|fw_cmd
parameter_list|,
name|uint16_t
name|cmd_args
index|[]
parameter_list|,
name|int
name|argc
parameter_list|,
name|int
name|process
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
name|uint16_t
name|val
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|elink_status_t
name|rc
init|=
name|ELINK_STATUS_OK
decl_stmt|;
if|if
condition|(
name|process
operator|==
name|PHY84833_MB_PROCESS2
condition|)
block|{
comment|/* Write CMD_OPEN_OVERRIDE to STATUS reg */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_CTL_DEVAD
argument_list|,
name|MDIO_848xx_CMD_HDLR_STATUS
argument_list|,
name|PHY84833_STATUS_CMD_OPEN_OVERRIDE
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|PHY848xx_CMDHDLR_WAIT
condition|;
name|idx
operator|++
control|)
block|{
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_CTL_DEVAD
argument_list|,
name|MDIO_848xx_CMD_HDLR_STATUS
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|PHY84833_STATUS_CMD_OPEN_FOR_CMDS
condition|)
break|break;
name|DELAY
argument_list|(
literal|1000
operator|*
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|idx
operator|>=
name|PHY848xx_CMDHDLR_WAIT
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"FW cmd: FW not ready.\n"
argument_list|)
expr_stmt|;
comment|/* if the status is CMD_COMPLETE_PASS or CMD_COMPLETE_ERROR 		 * clear the status to CMD_CLEAR_COMPLETE 		 */
if|if
condition|(
name|val
operator|==
name|PHY84833_STATUS_CMD_COMPLETE_PASS
operator|||
name|val
operator|==
name|PHY84833_STATUS_CMD_COMPLETE_ERROR
condition|)
block|{
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_CTL_DEVAD
argument_list|,
name|MDIO_848xx_CMD_HDLR_STATUS
argument_list|,
name|PHY84833_STATUS_CMD_CLEAR_COMPLETE
argument_list|)
expr_stmt|;
block|}
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
if|if
condition|(
name|process
operator|==
name|PHY84833_MB_PROCESS1
operator|||
name|process
operator|==
name|PHY84833_MB_PROCESS2
condition|)
block|{
comment|/* Prepare argument(s) */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|argc
condition|;
name|idx
operator|++
control|)
block|{
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_CTL_DEVAD
argument_list|,
name|MDIO_848xx_CMD_HDLR_DATA1
operator|+
name|idx
argument_list|,
name|cmd_args
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Issue command */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_CTL_DEVAD
argument_list|,
name|MDIO_848xx_CMD_HDLR_COMMAND
argument_list|,
name|fw_cmd
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|PHY848xx_CMDHDLR_WAIT
condition|;
name|idx
operator|++
control|)
block|{
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_CTL_DEVAD
argument_list|,
name|MDIO_848xx_CMD_HDLR_STATUS
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|==
name|PHY84833_STATUS_CMD_COMPLETE_PASS
operator|)
operator|||
operator|(
name|val
operator|==
name|PHY84833_STATUS_CMD_COMPLETE_ERROR
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|1000
operator|*
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|idx
operator|>=
name|PHY848xx_CMDHDLR_WAIT
operator|)
operator|||
operator|(
name|val
operator|==
name|PHY84833_STATUS_CMD_COMPLETE_ERROR
operator|)
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"FW cmd failed.\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ELINK_STATUS_ERROR
expr_stmt|;
block|}
if|if
condition|(
name|process
operator|==
name|PHY84833_MB_PROCESS3
operator|&&
name|rc
operator|==
name|ELINK_STATUS_OK
condition|)
block|{
comment|/* Gather returning data */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|argc
condition|;
name|idx
operator|++
control|)
block|{
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_CTL_DEVAD
argument_list|,
name|MDIO_848xx_CMD_HDLR_DATA1
operator|+
name|idx
argument_list|,
operator|&
name|cmd_args
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|val
operator|==
name|PHY84833_STATUS_CMD_COMPLETE_ERROR
operator|||
name|val
operator|==
name|PHY84833_STATUS_CMD_COMPLETE_PASS
condition|)
block|{
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_CTL_DEVAD
argument_list|,
name|MDIO_848xx_CMD_HDLR_STATUS
argument_list|,
name|PHY84833_STATUS_CMD_CLEAR_COMPLETE
argument_list|)
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_848xx_cmd_hdlr
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint16_t
name|fw_cmd
parameter_list|,
name|uint16_t
name|cmd_args
index|[]
parameter_list|,
name|int
name|argc
parameter_list|,
name|int
name|process
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
if|if
condition|(
operator|(
name|phy
operator|->
name|type
operator|==
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84858
operator|)
operator|||
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|shmem2_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem2_region
argument_list|,
name|link_attr_sync
index|[
name|params
operator|->
name|port
index|]
argument_list|)
argument_list|)
operator|&
name|LINK_ATTR_84858
operator|)
condition|)
block|{
return|return
name|elink_84858_cmd_hdlr
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|fw_cmd
argument_list|,
name|cmd_args
argument_list|,
name|argc
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|elink_84833_cmd_hdlr
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|fw_cmd
argument_list|,
name|cmd_args
argument_list|,
name|argc
argument_list|,
name|process
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_848xx_pair_swap_cfg
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|uint32_t
name|pair_swap
decl_stmt|;
name|uint16_t
name|data
index|[
name|PHY848xx_CMDHDLR_MAX_ARGS
index|]
decl_stmt|;
name|elink_status_t
name|status
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
comment|/* Check for configuration. */
name|pair_swap
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|params
operator|->
name|port
index|]
operator|.
name|xgbt_phy_cfg
argument_list|)
argument_list|)
operator|&
name|PORT_HW_CFG_RJ45_PAIR_SWAP_MASK
expr_stmt|;
if|if
condition|(
name|pair_swap
operator|==
literal|0
condition|)
return|return
name|ELINK_STATUS_OK
return|;
comment|/* Only the second argument is used for this command */
name|data
index|[
literal|1
index|]
operator|=
operator|(
name|uint16_t
operator|)
name|pair_swap
expr_stmt|;
name|status
operator|=
name|elink_848xx_cmd_hdlr
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|PHY848xx_CMD_SET_PAIR_SWAP
argument_list|,
name|data
argument_list|,
literal|2
argument_list|,
name|PHY84833_MB_PROCESS2
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|ELINK_STATUS_OK
condition|)
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Pairswap OK, val=0x%x\n"
argument_list|,
name|data
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|elink_84833_get_reset_gpios
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|shmem_base_path
index|[]
parameter_list|,
name|uint32_t
name|chip_id
parameter_list|)
block|{
name|uint32_t
name|reset_pin
index|[
literal|2
index|]
decl_stmt|;
name|uint32_t
name|idx
decl_stmt|;
name|uint8_t
name|reset_gpios
decl_stmt|;
if|if
condition|(
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* Assume that these will be GPIOs, not EPIOs. */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
literal|2
condition|;
name|idx
operator|++
control|)
block|{
comment|/* Map config param to register bit. */
name|reset_pin
index|[
name|idx
index|]
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|shmem_base_path
index|[
name|idx
index|]
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
literal|0
index|]
operator|.
name|e3_cmn_pin_cfg
argument_list|)
argument_list|)
expr_stmt|;
name|reset_pin
index|[
name|idx
index|]
operator|=
operator|(
name|reset_pin
index|[
name|idx
index|]
operator|&
name|PORT_HW_CFG_E3_PHY_RESET_MASK
operator|)
operator|>>
name|PORT_HW_CFG_E3_PHY_RESET_SHIFT
expr_stmt|;
name|reset_pin
index|[
name|idx
index|]
operator|-=
name|PIN_CFG_GPIO0_P0
expr_stmt|;
name|reset_pin
index|[
name|idx
index|]
operator|=
operator|(
literal|1
operator|<<
name|reset_pin
index|[
name|idx
index|]
operator|)
expr_stmt|;
block|}
name|reset_gpios
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|reset_pin
index|[
literal|0
index|]
operator||
name|reset_pin
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* E2, look from diff place of shmem. */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
literal|2
condition|;
name|idx
operator|++
control|)
block|{
name|reset_pin
index|[
name|idx
index|]
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|shmem_base_path
index|[
name|idx
index|]
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
literal|0
index|]
operator|.
name|default_cfg
argument_list|)
argument_list|)
expr_stmt|;
name|reset_pin
index|[
name|idx
index|]
operator|&=
name|PORT_HW_CFG_EXT_PHY_GPIO_RST_MASK
expr_stmt|;
name|reset_pin
index|[
name|idx
index|]
operator|-=
name|PORT_HW_CFG_EXT_PHY_GPIO_RST_GPIO0_P0
expr_stmt|;
name|reset_pin
index|[
name|idx
index|]
operator|>>=
name|PORT_HW_CFG_EXT_PHY_GPIO_RST_SHIFT
expr_stmt|;
name|reset_pin
index|[
name|idx
index|]
operator|=
operator|(
literal|1
operator|<<
name|reset_pin
index|[
name|idx
index|]
operator|)
expr_stmt|;
block|}
name|reset_gpios
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|reset_pin
index|[
literal|0
index|]
operator||
name|reset_pin
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|reset_gpios
return|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_84833_hw_reset_phy
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint8_t
name|reset_gpios
decl_stmt|;
name|uint32_t
name|other_shmem_base_addr
init|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|shmem2_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem2_region
argument_list|,
name|other_shmem_base_addr
argument_list|)
argument_list|)
decl_stmt|;
name|uint32_t
name|shmem_base_path
index|[
literal|2
index|]
decl_stmt|;
comment|/* Work around for 84833 LED failure inside RESET status */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_8481_LEGACY_MII_CTRL
argument_list|,
name|MDIO_AN_REG_8481_MII_CTRL_FORCE_1G
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_8481_1G_100T_EXT_CTRL
argument_list|,
name|MIDO_AN_REG_8481_EXT_CTRL_FORCE_LEDS_OFF
argument_list|)
expr_stmt|;
name|shmem_base_path
index|[
literal|0
index|]
operator|=
name|params
operator|->
name|shmem_base
expr_stmt|;
name|shmem_base_path
index|[
literal|1
index|]
operator|=
name|other_shmem_base_addr
expr_stmt|;
name|reset_gpios
operator|=
name|elink_84833_get_reset_gpios
argument_list|(
name|sc
argument_list|,
name|shmem_base_path
argument_list|,
name|params
operator|->
name|chip_id
argument_list|)
expr_stmt|;
name|elink_cb_gpio_mult_write
argument_list|(
name|sc
argument_list|,
name|reset_gpios
argument_list|,
name|MISC_REGISTERS_GPIO_OUTPUT_LOW
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"84833 hw reset on pin values 0x%x\n"
argument_list|,
name|reset_gpios
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_8483x_disable_eee
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|elink_status_t
name|rc
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint16_t
name|cmd_args
init|=
literal|0
decl_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Don't Advertise 10GBase-T EEE\n"
argument_list|)
expr_stmt|;
comment|/* Prevent Phy from working in EEE and advertising it */
name|rc
operator|=
name|elink_848xx_cmd_hdlr
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|PHY848xx_CMD_SET_EEE_MODE
argument_list|,
operator|&
name|cmd_args
argument_list|,
literal|1
argument_list|,
name|PHY84833_MB_PROCESS1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ELINK_STATUS_OK
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"EEE disable failed.\n"
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
return|return
name|elink_eee_disable
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_8483x_enable_eee
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|elink_status_t
name|rc
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint16_t
name|cmd_args
init|=
literal|1
decl_stmt|;
name|rc
operator|=
name|elink_848xx_cmd_hdlr
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|PHY848xx_CMD_SET_EEE_MODE
argument_list|,
operator|&
name|cmd_args
argument_list|,
literal|1
argument_list|,
name|PHY84833_MB_PROCESS1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ELINK_STATUS_OK
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"EEE enable failed.\n"
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
return|return
name|elink_eee_advertise
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|,
name|SHMEM_EEE_10G_ADV
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|PHY84833_CONSTANT_LATENCY
value|1193
end_define

begin_function
specifier|static
name|elink_status_t
name|elink_848x3_config_init
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint8_t
name|port
decl_stmt|,
name|initialize
init|=
literal|1
decl_stmt|;
name|uint16_t
name|val
decl_stmt|;
name|uint32_t
name|actual_phy_selection
decl_stmt|;
name|uint16_t
name|cmd_args
index|[
name|PHY848xx_CMDHDLR_MAX_ARGS
index|]
decl_stmt|;
name|elink_status_t
name|rc
init|=
name|ELINK_STATUS_OK
decl_stmt|;
name|DELAY
argument_list|(
literal|1000
operator|*
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
name|port
operator|=
name|SC_PATH
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|port
operator|=
name|params
operator|->
name|port
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|type
operator|==
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84823
condition|)
block|{
name|elink_cb_gpio_write
argument_list|(
name|sc
argument_list|,
name|MISC_REGISTERS_GPIO_3
argument_list|,
name|MISC_REGISTERS_GPIO_OUTPUT_HIGH
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* MDIO reset */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_CTRL
argument_list|,
literal|0x8000
argument_list|)
expr_stmt|;
block|}
name|elink_wait_reset_complete
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|params
argument_list|)
expr_stmt|;
comment|/* Wait for GPHY to come out of reset */
name|DELAY
argument_list|(
literal|1000
operator|*
literal|50
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elink_is_8483x_8485x
argument_list|(
name|phy
argument_list|)
condition|)
block|{
comment|/* BCM84823 requires that XGXS links up first @ 10G for normal 		 * behavior. 		 */
name|uint16_t
name|temp
decl_stmt|;
name|temp
operator|=
name|vars
operator|->
name|line_speed
expr_stmt|;
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_10000
expr_stmt|;
name|elink_set_autoneg
argument_list|(
operator|&
name|params
operator|->
name|phy
index|[
name|ELINK_INT_PHY
index|]
argument_list|,
name|params
argument_list|,
name|vars
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|elink_program_serdes
argument_list|(
operator|&
name|params
operator|->
name|phy
index|[
name|ELINK_INT_PHY
index|]
argument_list|,
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
name|vars
operator|->
name|line_speed
operator|=
name|temp
expr_stmt|;
block|}
comment|/* Check if this is actually BCM84858 */
if|if
condition|(
name|phy
operator|->
name|type
operator|!=
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84858
condition|)
block|{
name|uint16_t
name|hw_rev
decl_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_848xx_ID_MSB
argument_list|,
operator|&
name|hw_rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw_rev
operator|==
name|BCM84858_PHY_ID
condition|)
block|{
name|params
operator|->
name|link_attr_sync
operator||=
name|LINK_ATTR_84858
expr_stmt|;
name|elink_update_link_attr
argument_list|(
name|params
argument_list|,
name|params
operator|->
name|link_attr_sync
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Set dual-media configuration according to configuration */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_CTL_DEVAD
argument_list|,
name|MDIO_CTL_REG_84823_MEDIA
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
name|MDIO_CTL_REG_84823_MEDIA_MAC_MASK
operator||
name|MDIO_CTL_REG_84823_MEDIA_LINE_MASK
operator||
name|MDIO_CTL_REG_84823_MEDIA_COPPER_CORE_DOWN
operator||
name|MDIO_CTL_REG_84823_MEDIA_PRIORITY_MASK
operator||
name|MDIO_CTL_REG_84823_MEDIA_FIBER_1G
operator|)
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|val
operator|&=
operator|~
operator|(
name|MDIO_CTL_REG_84823_MEDIA_MAC_MASK
operator||
name|MDIO_CTL_REG_84823_MEDIA_LINE_MASK
operator|)
expr_stmt|;
block|}
else|else
block|{
name|val
operator||=
operator|(
name|MDIO_CTL_REG_84823_CTRL_MAC_XFI
operator||
name|MDIO_CTL_REG_84823_MEDIA_LINE_XAUI_L
operator|)
expr_stmt|;
block|}
name|actual_phy_selection
operator|=
name|elink_phy_selection
argument_list|(
name|params
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|actual_phy_selection
condition|)
block|{
case|case
name|PORT_HW_CFG_PHY_SELECTION_HARDWARE_DEFAULT
case|:
comment|/* Do nothing. Essentially this is like the priority copper */
break|break;
case|case
name|PORT_HW_CFG_PHY_SELECTION_FIRST_PHY_PRIORITY
case|:
name|val
operator||=
name|MDIO_CTL_REG_84823_MEDIA_PRIORITY_COPPER
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_PHY_SELECTION_SECOND_PHY_PRIORITY
case|:
name|val
operator||=
name|MDIO_CTL_REG_84823_MEDIA_PRIORITY_FIBER
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_PHY_SELECTION_FIRST_PHY
case|:
comment|/* Do nothing here. The first PHY won't be initialized at all */
break|break;
case|case
name|PORT_HW_CFG_PHY_SELECTION_SECOND_PHY
case|:
name|val
operator||=
name|MDIO_CTL_REG_84823_MEDIA_COPPER_CORE_DOWN
expr_stmt|;
name|initialize
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|params
operator|->
name|phy
index|[
name|ELINK_EXT_PHY2
index|]
operator|.
name|req_line_speed
operator|==
name|ELINK_SPEED_1000
condition|)
name|val
operator||=
name|MDIO_CTL_REG_84823_MEDIA_FIBER_1G
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_CTL_DEVAD
argument_list|,
name|MDIO_CTL_REG_84823_MEDIA
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"Multi_phy config = 0x%x, Media control = 0x%x\n"
argument_list|,
name|params
operator|->
name|multi_phy_config
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|elink_is_8483x_8485x
argument_list|(
name|phy
argument_list|)
condition|)
block|{
name|elink_848xx_pair_swap_cfg
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
comment|/* Keep AutogrEEEn disabled. */
name|cmd_args
index|[
literal|0
index|]
operator|=
literal|0x0
expr_stmt|;
name|cmd_args
index|[
literal|1
index|]
operator|=
literal|0x0
expr_stmt|;
name|cmd_args
index|[
literal|2
index|]
operator|=
name|PHY84833_CONSTANT_LATENCY
operator|+
literal|1
expr_stmt|;
name|cmd_args
index|[
literal|3
index|]
operator|=
name|PHY84833_CONSTANT_LATENCY
expr_stmt|;
name|rc
operator|=
name|elink_848xx_cmd_hdlr
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|PHY848xx_CMD_SET_EEE_MODE
argument_list|,
name|cmd_args
argument_list|,
literal|4
argument_list|,
name|PHY84833_MB_PROCESS1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ELINK_STATUS_OK
condition|)
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Cfg AutogrEEEn failed.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|initialize
condition|)
name|rc
operator|=
name|elink_848xx_cmn_config_init
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
else|else
name|elink_save_848xx_spirom_version
argument_list|(
name|phy
argument_list|,
name|sc
argument_list|,
name|params
operator|->
name|port
argument_list|)
expr_stmt|;
comment|/* 84833 PHY has a better feature and doesn't need to support this. */
if|if
condition|(
name|phy
operator|->
name|type
operator|==
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84823
condition|)
block|{
name|uint32_t
name|cms_enable
init|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|params
operator|->
name|port
index|]
operator|.
name|default_cfg
argument_list|)
argument_list|)
operator|&
name|PORT_HW_CFG_ENABLE_CMS_MASK
decl_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_CTL_DEVAD
argument_list|,
name|MDIO_CTL_REG_84823_USER_CTRL_REG
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|cms_enable
condition|)
name|val
operator||=
name|MDIO_CTL_REG_84823_USER_CTRL_CMS
expr_stmt|;
else|else
name|val
operator|&=
operator|~
name|MDIO_CTL_REG_84823_USER_CTRL_CMS
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_CTL_DEVAD
argument_list|,
name|MDIO_CTL_REG_84823_USER_CTRL_REG
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_CTL_DEVAD
argument_list|,
name|MDIO_84833_TOP_CFG_FW_REV
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
comment|/* Configure EEE support */
if|if
condition|(
operator|(
name|val
operator|>=
name|MDIO_84833_TOP_CFG_FW_EEE
operator|)
operator|&&
operator|(
name|val
operator|!=
name|MDIO_84833_TOP_CFG_FW_NO_EEE
operator|)
operator|&&
name|elink_eee_has_cap
argument_list|(
name|params
argument_list|)
condition|)
block|{
name|rc
operator|=
name|elink_eee_initial_config
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
name|SHMEM_EEE_10G_ADV
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ELINK_STATUS_OK
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Failed to configure EEE timers\n"
argument_list|)
expr_stmt|;
name|elink_8483x_disable_eee
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
if|if
condition|(
operator|(
name|phy
operator|->
name|req_duplex
operator|==
name|DUPLEX_FULL
operator|)
operator|&&
operator|(
name|params
operator|->
name|eee_mode
operator|&
name|ELINK_EEE_MODE_ADV_LPI
operator|)
operator|&&
operator|(
name|elink_eee_calc_timer
argument_list|(
name|params
argument_list|)
operator|||
operator|!
operator|(
name|params
operator|->
name|eee_mode
operator|&
name|ELINK_EEE_MODE_ENABLE_LPI
operator|)
operator|)
condition|)
name|rc
operator|=
name|elink_8483x_enable_eee
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
else|else
name|rc
operator|=
name|elink_8483x_disable_eee
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ELINK_STATUS_OK
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Failed to set EEE advertisement\n"
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
block|}
else|else
block|{
name|vars
operator|->
name|eee_status
operator|&=
operator|~
name|SHMEM_EEE_SUPPORTED_MASK
expr_stmt|;
block|}
if|if
condition|(
name|elink_is_8483x_8485x
argument_list|(
name|phy
argument_list|)
condition|)
block|{
comment|/* Bring PHY out of super isolate mode as the final step. */
name|elink_cl45_read_and_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_CTL_DEVAD
argument_list|,
name|MDIO_84833_TOP_CFG_XGPHY_STRAP1
argument_list|,
operator|(
name|uint16_t
operator|)
operator|~
name|MDIO_84833_SUPER_ISOLATE
argument_list|)
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|elink_848xx_read_status
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint16_t
name|val
decl_stmt|,
name|val1
decl_stmt|,
name|val2
decl_stmt|;
name|uint8_t
name|link_up
init|=
literal|0
decl_stmt|;
comment|/* Check 10G-BaseT link status */
comment|/* Check PMD signal ok */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
literal|0xFFFA
argument_list|,
operator|&
name|val1
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8481_PMD_SIGNAL
argument_list|,
operator|&
name|val2
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"BCM848xx: PMD_SIGNAL 1.a811 = 0x%x\n"
argument_list|,
name|val2
argument_list|)
expr_stmt|;
comment|/* Check link 10G */
if|if
condition|(
name|val2
operator|&
operator|(
literal|1
operator|<<
literal|11
operator|)
condition|)
block|{
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_10000
expr_stmt|;
name|vars
operator|->
name|duplex
operator|=
name|DUPLEX_FULL
expr_stmt|;
name|link_up
operator|=
literal|1
expr_stmt|;
name|elink_ext_phy_10G_an_resolve
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|vars
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Check Legacy speed link */
name|uint16_t
name|legacy_status
decl_stmt|,
name|legacy_speed
decl_stmt|;
comment|/* Enable expansion register 0x42 (Operation mode status) */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_8481_EXPANSION_REG_ACCESS
argument_list|,
literal|0xf42
argument_list|)
expr_stmt|;
comment|/* Get legacy speed operation status */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_8481_EXPANSION_REG_RD_RW
argument_list|,
operator|&
name|legacy_status
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Legacy speed status = 0x%x\n"
argument_list|,
name|legacy_status
argument_list|)
expr_stmt|;
name|link_up
operator|=
operator|(
operator|(
name|legacy_status
operator|&
operator|(
literal|1
operator|<<
literal|11
operator|)
operator|)
operator|==
operator|(
literal|1
operator|<<
literal|11
operator|)
operator|)
expr_stmt|;
name|legacy_speed
operator|=
operator|(
name|legacy_status
operator|&
operator|(
literal|3
operator|<<
literal|9
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|legacy_speed
operator|==
operator|(
literal|0
operator|<<
literal|9
operator|)
condition|)
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_10
expr_stmt|;
elseif|else
if|if
condition|(
name|legacy_speed
operator|==
operator|(
literal|1
operator|<<
literal|9
operator|)
condition|)
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_100
expr_stmt|;
elseif|else
if|if
condition|(
name|legacy_speed
operator|==
operator|(
literal|2
operator|<<
literal|9
operator|)
condition|)
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_1000
expr_stmt|;
else|else
block|{
comment|/* Should not happen: Treat as link down */
name|vars
operator|->
name|line_speed
operator|=
literal|0
expr_stmt|;
name|link_up
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|params
operator|->
name|feature_config_flags
operator|&
name|ELINK_FEATURE_CONFIG_IEEE_PHY_TEST
condition|)
block|{
name|uint16_t
name|mii_ctrl
decl_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_8481_LEGACY_MII_CTRL
argument_list|,
operator|&
name|mii_ctrl
argument_list|)
expr_stmt|;
comment|/* For IEEE testing, check for a fake link. */
name|link_up
operator||=
operator|(
operator|(
name|mii_ctrl
operator|&
literal|0x3040
operator|)
operator|==
literal|0x40
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|link_up
condition|)
block|{
if|if
condition|(
name|legacy_status
operator|&
operator|(
literal|1
operator|<<
literal|8
operator|)
condition|)
name|vars
operator|->
name|duplex
operator|=
name|DUPLEX_FULL
expr_stmt|;
else|else
name|vars
operator|->
name|duplex
operator|=
name|DUPLEX_HALF
expr_stmt|;
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"Link is up in %dMbps, is_duplex_full= %d\n"
argument_list|,
name|vars
operator|->
name|line_speed
argument_list|,
operator|(
name|vars
operator|->
name|duplex
operator|==
name|DUPLEX_FULL
operator|)
argument_list|)
expr_stmt|;
comment|/* Check legacy speed AN resolution */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_8481_LEGACY_MII_STATUS
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_AUTO_NEGOTIATE_COMPLETE
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_8481_LEGACY_AN_EXPANSION
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
operator|)
operator|==
literal|0
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_PARALLEL_DETECTION_USED
expr_stmt|;
block|}
block|}
if|if
condition|(
name|link_up
condition|)
block|{
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"BCM848x3: link speed is %d\n"
argument_list|,
name|vars
operator|->
name|line_speed
argument_list|)
expr_stmt|;
name|elink_ext_phy_resolve_fc
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
comment|/* Read LP advertised speeds */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_CL37_FC_LP
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_LINK_PARTNER_10THD_CAPABLE
expr_stmt|;
if|if
condition|(
name|val
operator|&
operator|(
literal|1
operator|<<
literal|6
operator|)
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_LINK_PARTNER_10TFD_CAPABLE
expr_stmt|;
if|if
condition|(
name|val
operator|&
operator|(
literal|1
operator|<<
literal|7
operator|)
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_LINK_PARTNER_100TXHD_CAPABLE
expr_stmt|;
if|if
condition|(
name|val
operator|&
operator|(
literal|1
operator|<<
literal|8
operator|)
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_LINK_PARTNER_100TXFD_CAPABLE
expr_stmt|;
if|if
condition|(
name|val
operator|&
operator|(
literal|1
operator|<<
literal|9
operator|)
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_LINK_PARTNER_100T4_CAPABLE
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_1000T_STATUS
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
operator|(
literal|1
operator|<<
literal|10
operator|)
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_LINK_PARTNER_1000THD_CAPABLE
expr_stmt|;
if|if
condition|(
name|val
operator|&
operator|(
literal|1
operator|<<
literal|11
operator|)
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_LINK_PARTNER_1000TFD_CAPABLE
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_MASTER_STATUS
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
operator|(
literal|1
operator|<<
literal|11
operator|)
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_LINK_PARTNER_10GXFD_CAPABLE
expr_stmt|;
comment|/* Determine if EEE was negotiated */
if|if
condition|(
name|elink_is_8483x_8485x
argument_list|(
name|phy
argument_list|)
condition|)
name|elink_eee_an_resolve
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
block|}
return|return
name|link_up
return|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_848xx_format_ver
parameter_list|(
name|uint32_t
name|raw_ver
parameter_list|,
name|uint8_t
modifier|*
name|str
parameter_list|,
name|uint16_t
modifier|*
name|len
parameter_list|)
block|{
name|elink_status_t
name|status
init|=
name|ELINK_STATUS_OK
decl_stmt|;
name|uint32_t
name|spirom_ver
decl_stmt|;
name|spirom_ver
operator|=
operator|(
operator|(
name|raw_ver
operator|&
literal|0xF80
operator|)
operator|>>
literal|7
operator|)
operator|<<
literal|16
operator||
operator|(
name|raw_ver
operator|&
literal|0x7F
operator|)
expr_stmt|;
name|status
operator|=
name|elink_format_ver
argument_list|(
name|spirom_ver
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_8481_hw_reset
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|elink_cb_gpio_write
argument_list|(
name|params
operator|->
name|sc
argument_list|,
name|MISC_REGISTERS_GPIO_1
argument_list|,
name|MISC_REGISTERS_GPIO_OUTPUT_LOW
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|elink_cb_gpio_write
argument_list|(
name|params
operator|->
name|sc
argument_list|,
name|MISC_REGISTERS_GPIO_1
argument_list|,
name|MISC_REGISTERS_GPIO_OUTPUT_LOW
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_8481_link_reset
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|elink_cl45_write
argument_list|(
name|params
operator|->
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_CTRL
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|params
operator|->
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_CTRL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_848x3_link_reset
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint8_t
name|port
decl_stmt|;
name|uint16_t
name|val16
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
name|port
operator|=
name|SC_PATH
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|port
operator|=
name|params
operator|->
name|port
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|type
operator|==
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84823
condition|)
block|{
name|elink_cb_gpio_write
argument_list|(
name|sc
argument_list|,
name|MISC_REGISTERS_GPIO_3
argument_list|,
name|MISC_REGISTERS_GPIO_OUTPUT_LOW
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_CTL_DEVAD
argument_list|,
name|MDIO_84833_TOP_CFG_XGPHY_STRAP1
argument_list|,
operator|&
name|val16
argument_list|)
expr_stmt|;
name|val16
operator||=
name|MDIO_84833_SUPER_ISOLATE
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_CTL_DEVAD
argument_list|,
name|MDIO_84833_TOP_CFG_XGPHY_STRAP1
argument_list|,
name|val16
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|elink_848xx_set_link_led
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint8_t
name|mode
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint16_t
name|val
decl_stmt|;
name|uint8_t
name|port
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
name|port
operator|=
name|SC_PATH
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|port
operator|=
name|params
operator|->
name|port
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|ELINK_LED_MODE_OFF
case|:
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Port 0x%x: LED MODE OFF\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|params
operator|->
name|hw_led_mode
operator|<<
name|SHARED_HW_CFG_LED_MODE_SHIFT
operator|)
operator|==
name|SHARED_HW_CFG_LED_EXTPHY1
condition|)
block|{
comment|/* Set LED masks */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8481_LED1_MASK
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8481_LED2_MASK
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8481_LED3_MASK
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8481_LED5_MASK
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8481_LED1_MASK
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ELINK_LED_MODE_FRONT_PANEL_OFF
case|:
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Port 0x%x: LED MODE FRONT PANEL OFF\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|params
operator|->
name|hw_led_mode
operator|<<
name|SHARED_HW_CFG_LED_MODE_SHIFT
operator|)
operator|==
name|SHARED_HW_CFG_LED_EXTPHY1
condition|)
block|{
comment|/* Set LED masks */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8481_LED1_MASK
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8481_LED2_MASK
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8481_LED3_MASK
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8481_LED5_MASK
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8481_LED1_MASK
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|type
operator|==
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84834
condition|)
block|{
comment|/* Disable MI_INT interrupt before setting LED4 				 * source to constant off. 				 */
if|if
condition|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_MASK_INTERRUPT_PORT0
operator|+
name|params
operator|->
name|port
operator|*
literal|4
argument_list|)
operator|&
name|ELINK_NIG_MASK_MI_INT
condition|)
block|{
name|params
operator|->
name|link_flags
operator||=
name|ELINK_LINK_FLAGS_INT_DISABLED
expr_stmt|;
name|elink_bits_dis
argument_list|(
name|sc
argument_list|,
name|NIG_REG_MASK_INTERRUPT_PORT0
operator|+
name|params
operator|->
name|port
operator|*
literal|4
argument_list|,
name|ELINK_NIG_MASK_MI_INT
argument_list|)
expr_stmt|;
block|}
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8481_SIGNAL_MASK
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ELINK_LED_MODE_ON
case|:
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Port 0x%x: LED MODE ON\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|params
operator|->
name|hw_led_mode
operator|<<
name|SHARED_HW_CFG_LED_MODE_SHIFT
operator|)
operator|==
name|SHARED_HW_CFG_LED_EXTPHY1
condition|)
block|{
comment|/* Set control reg */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8481_LINK_SIGNAL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|val
operator|&=
literal|0x8000
expr_stmt|;
name|val
operator||=
literal|0x2492
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8481_LINK_SIGNAL
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Set LED masks */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8481_LED1_MASK
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8481_LED2_MASK
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8481_LED3_MASK
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8481_LED5_MASK
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8481_LED1_MASK
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|type
operator|==
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84834
condition|)
block|{
comment|/* Disable MI_INT interrupt before setting LED4 				 * source to constant on. 				 */
if|if
condition|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_MASK_INTERRUPT_PORT0
operator|+
name|params
operator|->
name|port
operator|*
literal|4
argument_list|)
operator|&
name|ELINK_NIG_MASK_MI_INT
condition|)
block|{
name|params
operator|->
name|link_flags
operator||=
name|ELINK_LINK_FLAGS_INT_DISABLED
expr_stmt|;
name|elink_bits_dis
argument_list|(
name|sc
argument_list|,
name|NIG_REG_MASK_INTERRUPT_PORT0
operator|+
name|params
operator|->
name|port
operator|*
literal|4
argument_list|,
name|ELINK_NIG_MASK_MI_INT
argument_list|)
expr_stmt|;
block|}
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8481_SIGNAL_MASK
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ELINK_LED_MODE_OPER
case|:
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Port 0x%x: LED MODE OPER\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|params
operator|->
name|hw_led_mode
operator|<<
name|SHARED_HW_CFG_LED_MODE_SHIFT
operator|)
operator|==
name|SHARED_HW_CFG_LED_EXTPHY1
condition|)
block|{
comment|/* Set control reg */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8481_LINK_SIGNAL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|val
operator|&
name|MDIO_PMA_REG_8481_LINK_SIGNAL_LED4_ENABLE_MASK
operator|)
operator|>>
name|MDIO_PMA_REG_8481_LINK_SIGNAL_LED4_ENABLE_SHIFT
operator|)
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Setting LINK_SIGNAL\n"
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8481_LINK_SIGNAL
argument_list|,
literal|0xa492
argument_list|)
expr_stmt|;
block|}
comment|/* Set LED masks */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8481_LED1_MASK
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8481_LED2_MASK
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8481_LED3_MASK
argument_list|,
literal|0x98
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8481_LED5_MASK
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* EXTPHY2 LED mode indicate that the 100M/1G/10G LED 			 * sources are all wired through LED1, rather than only 			 * 10G in other modes. 			 */
name|val
operator|=
operator|(
operator|(
name|params
operator|->
name|hw_led_mode
operator|<<
name|SHARED_HW_CFG_LED_MODE_SHIFT
operator|)
operator|==
name|SHARED_HW_CFG_LED_EXTPHY2
operator|)
condition|?
literal|0x98
else|:
literal|0x80
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8481_LED1_MASK
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Tell LED3 to blink on source */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8481_LINK_SIGNAL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
literal|7
operator|<<
literal|6
operator|)
expr_stmt|;
name|val
operator||=
operator|(
literal|1
operator|<<
literal|6
operator|)
expr_stmt|;
comment|/* A83B[8:6]= 1 */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8481_LINK_SIGNAL
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|type
operator|==
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84834
condition|)
block|{
comment|/* Restore LED4 source to external link, 				 * and re-enable interrupts. 				 */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_8481_SIGNAL_MASK
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|link_flags
operator|&
name|ELINK_LINK_FLAGS_INT_DISABLED
condition|)
block|{
name|elink_link_int_enable
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|params
operator|->
name|link_flags
operator|&=
operator|~
name|ELINK_LINK_FLAGS_INT_DISABLED
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
comment|/* This is a workaround for E3+84833 until autoneg 	 * restart is fixed in f/w 	 */
if|if
condition|(
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_WC_DEVAD
argument_list|,
name|MDIO_WC_REG_GP2_STATUS_GP_2_1
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/******************************************************************/
end_comment

begin_comment
comment|/*			54618SE PHY SECTION			  */
end_comment

begin_comment
comment|/******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|elink_54618se_specific_func
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint32_t
name|action
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint16_t
name|temp
decl_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|ELINK_PHY_INIT
case|:
comment|/* Configure LED4: set to INTR (0x6). */
comment|/* Accessing shadow register 0xe. */
name|elink_cl22_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_GPHY_SHADOW
argument_list|,
name|MDIO_REG_GPHY_SHADOW_LED_SEL2
argument_list|)
expr_stmt|;
name|elink_cl22_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_GPHY_SHADOW
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|&=
operator|~
operator|(
literal|0xf
operator|<<
literal|4
operator|)
expr_stmt|;
name|temp
operator||=
operator|(
literal|0x6
operator|<<
literal|4
operator|)
expr_stmt|;
name|elink_cl22_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_GPHY_SHADOW
argument_list|,
name|MDIO_REG_GPHY_SHADOW_WR_ENA
operator||
name|temp
argument_list|)
expr_stmt|;
comment|/* Configure INTR based on link status change. */
name|elink_cl22_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_INTR_MASK
argument_list|,
operator|~
name|MDIO_REG_INTR_MASK_LINK_STATUS
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_54618se_config_init
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint8_t
name|port
decl_stmt|;
name|uint16_t
name|autoneg_val
decl_stmt|,
name|an_1000_val
decl_stmt|,
name|an_10_100_val
decl_stmt|,
name|fc_val
decl_stmt|,
name|temp
decl_stmt|;
name|uint32_t
name|cfg_pin
decl_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"54618SE cfg init\n"
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
operator|*
literal|1
argument_list|)
expr_stmt|;
comment|/* This works with E3 only, no need to check the chip 	 * before determining the port. 	 */
name|port
operator|=
name|params
operator|->
name|port
expr_stmt|;
name|cfg_pin
operator|=
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|port
index|]
operator|.
name|e3_cmn_pin_cfg
argument_list|)
argument_list|)
operator|&
name|PORT_HW_CFG_E3_PHY_RESET_MASK
operator|)
operator|>>
name|PORT_HW_CFG_E3_PHY_RESET_SHIFT
expr_stmt|;
comment|/* Drive pin high to bring the GPHY out of reset. */
name|elink_set_cfg_pin
argument_list|(
name|sc
argument_list|,
name|cfg_pin
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* wait for GPHY to reset */
name|DELAY
argument_list|(
literal|1000
operator|*
literal|50
argument_list|)
expr_stmt|;
comment|/* reset phy */
name|elink_cl22_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_REG_CTRL
argument_list|,
literal|0x8000
argument_list|)
expr_stmt|;
name|elink_wait_reset_complete
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|params
argument_list|)
expr_stmt|;
comment|/* Wait for GPHY to reset */
name|DELAY
argument_list|(
literal|1000
operator|*
literal|50
argument_list|)
expr_stmt|;
name|elink_54618se_specific_func
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|ELINK_PHY_INIT
argument_list|)
expr_stmt|;
comment|/* Flip the signal detect polarity (set 0x1c.0x1e[8]). */
name|elink_cl22_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_GPHY_SHADOW
argument_list|,
name|MDIO_REG_GPHY_SHADOW_AUTO_DET_MED
argument_list|)
expr_stmt|;
name|elink_cl22_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_GPHY_SHADOW
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|temp
operator||=
name|MDIO_REG_GPHY_SHADOW_INVERT_FIB_SD
expr_stmt|;
name|elink_cl22_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_GPHY_SHADOW
argument_list|,
name|MDIO_REG_GPHY_SHADOW_WR_ENA
operator||
name|temp
argument_list|)
expr_stmt|;
comment|/* Set up fc */
comment|/* Please refer to Table 28B-3 of 802.3ab-1999 spec. */
name|elink_calc_ieee_aneg_adv
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
operator|&
name|vars
operator|->
name|ieee_fc
argument_list|)
expr_stmt|;
name|fc_val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|vars
operator|->
name|ieee_fc
operator|&
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC
operator|)
operator|==
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC
condition|)
name|fc_val
operator||=
name|MDIO_AN_REG_ADV_PAUSE_ASYMMETRIC
expr_stmt|;
if|if
condition|(
operator|(
name|vars
operator|->
name|ieee_fc
operator|&
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH
operator|)
operator|==
name|MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH
condition|)
name|fc_val
operator||=
name|MDIO_AN_REG_ADV_PAUSE_PAUSE
expr_stmt|;
comment|/* Read all advertisement */
name|elink_cl22_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
literal|0x09
argument_list|,
operator|&
name|an_1000_val
argument_list|)
expr_stmt|;
name|elink_cl22_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
literal|0x04
argument_list|,
operator|&
name|an_10_100_val
argument_list|)
expr_stmt|;
name|elink_cl22_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_REG_CTRL
argument_list|,
operator|&
name|autoneg_val
argument_list|)
expr_stmt|;
comment|/* Disable forced speed */
name|autoneg_val
operator|&=
operator|~
operator|(
operator|(
literal|1
operator|<<
literal|6
operator|)
operator||
operator|(
literal|1
operator|<<
literal|8
operator|)
operator||
operator|(
literal|1
operator|<<
literal|9
operator|)
operator||
operator|(
literal|1
operator|<<
literal|12
operator|)
operator||
operator|(
literal|1
operator|<<
literal|13
operator|)
operator|)
expr_stmt|;
name|an_10_100_val
operator|&=
operator|~
operator|(
operator|(
literal|1
operator|<<
literal|5
operator|)
operator||
operator|(
literal|1
operator|<<
literal|6
operator|)
operator||
operator|(
literal|1
operator|<<
literal|7
operator|)
operator||
operator|(
literal|1
operator|<<
literal|8
operator|)
operator||
operator|(
literal|1
operator|<<
literal|10
operator|)
operator||
operator|(
literal|1
operator|<<
literal|11
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|phy
operator|->
name|req_line_speed
operator|==
name|ELINK_SPEED_AUTO_NEG
operator|)
operator|&&
operator|(
name|phy
operator|->
name|speed_cap_mask
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_1G
operator|)
operator|)
operator|||
operator|(
name|phy
operator|->
name|req_line_speed
operator|==
name|ELINK_SPEED_1000
operator|)
condition|)
block|{
name|an_1000_val
operator||=
operator|(
literal|1
operator|<<
literal|8
operator|)
expr_stmt|;
name|autoneg_val
operator||=
operator|(
literal|1
operator|<<
literal|9
operator||
literal|1
operator|<<
literal|12
operator|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|req_duplex
operator|==
name|DUPLEX_FULL
condition|)
name|an_1000_val
operator||=
operator|(
literal|1
operator|<<
literal|9
operator|)
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Advertising 1G\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|an_1000_val
operator|&=
operator|~
operator|(
operator|(
literal|1
operator|<<
literal|8
operator|)
operator||
operator|(
literal|1
operator|<<
literal|9
operator|)
operator|)
expr_stmt|;
name|elink_cl22_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
literal|0x09
argument_list|,
name|an_1000_val
argument_list|)
expr_stmt|;
name|elink_cl22_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
literal|0x09
argument_list|,
operator|&
name|an_1000_val
argument_list|)
expr_stmt|;
comment|/* Advertise 10/100 link speed */
if|if
condition|(
name|phy
operator|->
name|req_line_speed
operator|==
name|ELINK_SPEED_AUTO_NEG
condition|)
block|{
if|if
condition|(
name|phy
operator|->
name|speed_cap_mask
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_10M_HALF
condition|)
block|{
name|an_10_100_val
operator||=
operator|(
literal|1
operator|<<
literal|5
operator|)
expr_stmt|;
name|autoneg_val
operator||=
operator|(
literal|1
operator|<<
literal|9
operator||
literal|1
operator|<<
literal|12
operator|)
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Advertising 10M-HD\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|phy
operator|->
name|speed_cap_mask
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_10M_FULL
condition|)
block|{
name|an_10_100_val
operator||=
operator|(
literal|1
operator|<<
literal|6
operator|)
expr_stmt|;
name|autoneg_val
operator||=
operator|(
literal|1
operator|<<
literal|9
operator||
literal|1
operator|<<
literal|12
operator|)
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Advertising 10M-FD\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|phy
operator|->
name|speed_cap_mask
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_100M_HALF
condition|)
block|{
name|an_10_100_val
operator||=
operator|(
literal|1
operator|<<
literal|7
operator|)
expr_stmt|;
name|autoneg_val
operator||=
operator|(
literal|1
operator|<<
literal|9
operator||
literal|1
operator|<<
literal|12
operator|)
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Advertising 100M-HD\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|phy
operator|->
name|speed_cap_mask
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_100M_FULL
condition|)
block|{
name|an_10_100_val
operator||=
operator|(
literal|1
operator|<<
literal|8
operator|)
expr_stmt|;
name|autoneg_val
operator||=
operator|(
literal|1
operator|<<
literal|9
operator||
literal|1
operator|<<
literal|12
operator|)
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Advertising 100M-FD\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Only 10/100 are allowed to work in FORCE mode */
if|if
condition|(
name|phy
operator|->
name|req_line_speed
operator|==
name|ELINK_SPEED_100
condition|)
block|{
name|autoneg_val
operator||=
operator|(
literal|1
operator|<<
literal|13
operator|)
expr_stmt|;
comment|/* Enabled AUTO-MDIX when autoneg is disabled */
name|elink_cl22_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
literal|0x18
argument_list|,
operator|(
literal|1
operator|<<
literal|15
operator||
literal|1
operator|<<
literal|9
operator||
literal|7
operator|<<
literal|0
operator|)
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Setting 100M force\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|phy
operator|->
name|req_line_speed
operator|==
name|ELINK_SPEED_10
condition|)
block|{
comment|/* Enabled AUTO-MDIX when autoneg is disabled */
name|elink_cl22_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
literal|0x18
argument_list|,
operator|(
literal|1
operator|<<
literal|15
operator||
literal|1
operator|<<
literal|9
operator||
literal|7
operator|<<
literal|0
operator|)
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Setting 10M force\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|phy
operator|->
name|flags
operator|&
name|ELINK_FLAGS_EEE
operator|)
operator|&&
name|elink_eee_has_cap
argument_list|(
name|params
argument_list|)
condition|)
block|{
name|elink_status_t
name|rc
decl_stmt|;
name|elink_cl22_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_GPHY_EXP_ACCESS
argument_list|,
name|MDIO_REG_GPHY_EXP_ACCESS_TOP
operator||
name|MDIO_REG_GPHY_EXP_TOP_2K_BUF
argument_list|)
expr_stmt|;
name|elink_cl22_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_GPHY_EXP_ACCESS_GATE
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|&=
literal|0xfffe
expr_stmt|;
name|elink_cl22_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_GPHY_EXP_ACCESS_GATE
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|rc
operator|=
name|elink_eee_initial_config
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
name|SHMEM_EEE_1G_ADV
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ELINK_STATUS_OK
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Failed to configure EEE timers\n"
argument_list|)
expr_stmt|;
name|elink_eee_disable
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|params
operator|->
name|eee_mode
operator|&
name|ELINK_EEE_MODE_ADV_LPI
operator|)
operator|&&
operator|(
name|phy
operator|->
name|req_duplex
operator|==
name|DUPLEX_FULL
operator|)
operator|&&
operator|(
name|elink_eee_calc_timer
argument_list|(
name|params
argument_list|)
operator|||
operator|!
operator|(
name|params
operator|->
name|eee_mode
operator|&
name|ELINK_EEE_MODE_ENABLE_LPI
operator|)
operator|)
condition|)
block|{
comment|/* Need to advertise EEE only when requested, 			 * and either no LPI assertion was requested, 			 * or it was requested and a valid timer was set. 			 * Also notice full duplex is required for EEE. 			 */
name|elink_eee_advertise
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|,
name|SHMEM_EEE_1G_ADV
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Don't Advertise 1GBase-T EEE\n"
argument_list|)
expr_stmt|;
name|elink_eee_disable
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|vars
operator|->
name|eee_status
operator|&=
operator|(
call|(
name|uint32_t
call|)
argument_list|(
operator|~
name|SHMEM_EEE_1G_ADV
argument_list|)
operator|<<
name|SHMEM_EEE_SUPPORTED_SHIFT
operator|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|flags
operator|&
name|ELINK_FLAGS_EEE
condition|)
block|{
comment|/* Handle legacy auto-grEEEn */
if|if
condition|(
name|params
operator|->
name|feature_config_flags
operator|&
name|ELINK_FEATURE_CONFIG_AUTOGREEEN_ENABLED
condition|)
block|{
name|temp
operator|=
literal|6
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Enabling Auto-GrEEEn\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|=
literal|0
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Don't Adv. EEE\n"
argument_list|)
expr_stmt|;
block|}
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_EEE_ADV
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
name|elink_cl22_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
literal|0x04
argument_list|,
name|an_10_100_val
operator||
name|fc_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|req_duplex
operator|==
name|DUPLEX_FULL
condition|)
name|autoneg_val
operator||=
operator|(
literal|1
operator|<<
literal|8
operator|)
expr_stmt|;
name|elink_cl22_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_REG_CTRL
argument_list|,
name|autoneg_val
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_5461x_set_link_led
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint8_t
name|mode
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint16_t
name|temp
decl_stmt|;
name|elink_cl22_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_GPHY_SHADOW
argument_list|,
name|MDIO_REG_GPHY_SHADOW_LED_SEL1
argument_list|)
expr_stmt|;
name|elink_cl22_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_GPHY_SHADOW
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|&=
literal|0xff00
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"54618x set link led (mode=%x)\n"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|ELINK_LED_MODE_FRONT_PANEL_OFF
case|:
case|case
name|ELINK_LED_MODE_OFF
case|:
name|temp
operator||=
literal|0x00ee
expr_stmt|;
break|break;
case|case
name|ELINK_LED_MODE_OPER
case|:
name|temp
operator||=
literal|0x0001
expr_stmt|;
break|break;
case|case
name|ELINK_LED_MODE_ON
case|:
name|temp
operator||=
literal|0x00ff
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|elink_cl22_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_GPHY_SHADOW
argument_list|,
name|MDIO_REG_GPHY_SHADOW_WR_ENA
operator||
name|temp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_54618se_link_reset
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint32_t
name|cfg_pin
decl_stmt|;
name|uint8_t
name|port
decl_stmt|;
comment|/* In case of no EPIO routed to reset the GPHY, put it 	 * in low power mode. 	 */
name|elink_cl22_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_REG_CTRL
argument_list|,
literal|0x800
argument_list|)
expr_stmt|;
comment|/* This works with E3 only, no need to check the chip 	 * before determining the port. 	 */
name|port
operator|=
name|params
operator|->
name|port
expr_stmt|;
name|cfg_pin
operator|=
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|port
index|]
operator|.
name|e3_cmn_pin_cfg
argument_list|)
argument_list|)
operator|&
name|PORT_HW_CFG_E3_PHY_RESET_MASK
operator|)
operator|>>
name|PORT_HW_CFG_E3_PHY_RESET_SHIFT
expr_stmt|;
comment|/* Drive pin low to put GPHY in reset. */
name|elink_set_cfg_pin
argument_list|(
name|sc
argument_list|,
name|cfg_pin
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|elink_54618se_read_status
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint16_t
name|val
decl_stmt|;
name|uint8_t
name|link_up
init|=
literal|0
decl_stmt|;
name|uint16_t
name|legacy_status
decl_stmt|,
name|legacy_speed
decl_stmt|;
comment|/* Get speed operation status */
name|elink_cl22_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_GPHY_AUX_STATUS
argument_list|,
operator|&
name|legacy_status
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"54618SE read_status: 0x%x\n"
argument_list|,
name|legacy_status
argument_list|)
expr_stmt|;
comment|/* Read status to clear the PHY interrupt. */
name|elink_cl22_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_INTR_STATUS
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|link_up
operator|=
operator|(
operator|(
name|legacy_status
operator|&
operator|(
literal|1
operator|<<
literal|2
operator|)
operator|)
operator|==
operator|(
literal|1
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|link_up
condition|)
block|{
name|legacy_speed
operator|=
operator|(
name|legacy_status
operator|&
operator|(
literal|7
operator|<<
literal|8
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|legacy_speed
operator|==
operator|(
literal|7
operator|<<
literal|8
operator|)
condition|)
block|{
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_1000
expr_stmt|;
name|vars
operator|->
name|duplex
operator|=
name|DUPLEX_FULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|legacy_speed
operator|==
operator|(
literal|6
operator|<<
literal|8
operator|)
condition|)
block|{
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_1000
expr_stmt|;
name|vars
operator|->
name|duplex
operator|=
name|DUPLEX_HALF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|legacy_speed
operator|==
operator|(
literal|5
operator|<<
literal|8
operator|)
condition|)
block|{
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_100
expr_stmt|;
name|vars
operator|->
name|duplex
operator|=
name|DUPLEX_FULL
expr_stmt|;
block|}
comment|/* Omitting 100Base-T4 for now */
elseif|else
if|if
condition|(
name|legacy_speed
operator|==
operator|(
literal|3
operator|<<
literal|8
operator|)
condition|)
block|{
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_100
expr_stmt|;
name|vars
operator|->
name|duplex
operator|=
name|DUPLEX_HALF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|legacy_speed
operator|==
operator|(
literal|2
operator|<<
literal|8
operator|)
condition|)
block|{
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_10
expr_stmt|;
name|vars
operator|->
name|duplex
operator|=
name|DUPLEX_FULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|legacy_speed
operator|==
operator|(
literal|1
operator|<<
literal|8
operator|)
condition|)
block|{
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_10
expr_stmt|;
name|vars
operator|->
name|duplex
operator|=
name|DUPLEX_HALF
expr_stmt|;
block|}
else|else
comment|/* Should not happen */
name|vars
operator|->
name|line_speed
operator|=
literal|0
expr_stmt|;
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"Link is up in %dMbps, is_duplex_full= %d\n"
argument_list|,
name|vars
operator|->
name|line_speed
argument_list|,
operator|(
name|vars
operator|->
name|duplex
operator|==
name|DUPLEX_FULL
operator|)
argument_list|)
expr_stmt|;
comment|/* Check legacy speed AN resolution */
name|elink_cl22_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
literal|0x01
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_AUTO_NEGOTIATE_COMPLETE
expr_stmt|;
name|elink_cl22_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
literal|0x06
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
operator|)
operator|==
literal|0
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_PARALLEL_DETECTION_USED
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"BCM54618SE: link speed is %d\n"
argument_list|,
name|vars
operator|->
name|line_speed
argument_list|)
expr_stmt|;
name|elink_ext_phy_resolve_fc
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
if|if
condition|(
name|vars
operator|->
name|link_status
operator|&
name|LINK_STATUS_AUTO_NEGOTIATE_COMPLETE
condition|)
block|{
comment|/* Report LP advertised speeds */
name|elink_cl22_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
literal|0x5
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_LINK_PARTNER_10THD_CAPABLE
expr_stmt|;
if|if
condition|(
name|val
operator|&
operator|(
literal|1
operator|<<
literal|6
operator|)
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_LINK_PARTNER_10TFD_CAPABLE
expr_stmt|;
if|if
condition|(
name|val
operator|&
operator|(
literal|1
operator|<<
literal|7
operator|)
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_LINK_PARTNER_100TXHD_CAPABLE
expr_stmt|;
if|if
condition|(
name|val
operator|&
operator|(
literal|1
operator|<<
literal|8
operator|)
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_LINK_PARTNER_100TXFD_CAPABLE
expr_stmt|;
if|if
condition|(
name|val
operator|&
operator|(
literal|1
operator|<<
literal|9
operator|)
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_LINK_PARTNER_100T4_CAPABLE
expr_stmt|;
name|elink_cl22_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
literal|0xa
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
operator|(
literal|1
operator|<<
literal|10
operator|)
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_LINK_PARTNER_1000THD_CAPABLE
expr_stmt|;
if|if
condition|(
name|val
operator|&
operator|(
literal|1
operator|<<
literal|11
operator|)
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_LINK_PARTNER_1000TFD_CAPABLE
expr_stmt|;
if|if
condition|(
operator|(
name|phy
operator|->
name|flags
operator|&
name|ELINK_FLAGS_EEE
operator|)
operator|&&
name|elink_eee_has_cap
argument_list|(
name|params
argument_list|)
condition|)
name|elink_eee_an_resolve
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|link_up
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_54618se_config_loopback
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint16_t
name|val
decl_stmt|;
name|uint32_t
name|umac_base
init|=
name|params
operator|->
name|port
condition|?
name|GRCBASE_UMAC1
else|:
name|GRCBASE_UMAC0
decl_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"2PMA/PMD ext_phy_loopback: 54618se\n"
argument_list|)
expr_stmt|;
comment|/* Enable master/slave manual mmode and set to master */
comment|/* mii write 9 [bits set 11 12] */
name|elink_cl22_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
literal|0x09
argument_list|,
literal|3
operator|<<
literal|11
argument_list|)
expr_stmt|;
comment|/* forced 1G and disable autoneg */
comment|/* set val [mii read 0] */
comment|/* set val [expr $val& [bits clear 6 12 13]] */
comment|/* set val [expr $val | [bits set 6 8]] */
comment|/* mii write 0 $val */
name|elink_cl22_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
literal|0x00
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
operator|(
literal|1
operator|<<
literal|6
operator|)
operator||
operator|(
literal|1
operator|<<
literal|12
operator|)
operator||
operator|(
literal|1
operator|<<
literal|13
operator|)
operator|)
expr_stmt|;
name|val
operator||=
operator|(
literal|1
operator|<<
literal|6
operator|)
operator||
operator|(
literal|1
operator|<<
literal|8
operator|)
expr_stmt|;
name|elink_cl22_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
literal|0x00
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Set external loopback and Tx using 6dB coding */
comment|/* mii write 0x18 7 */
comment|/* set val [mii read 0x18] */
comment|/* mii write 0x18 [expr $val | [bits set 10 15]] */
name|elink_cl22_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
literal|0x18
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|elink_cl22_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
literal|0x18
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|elink_cl22_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
literal|0x18
argument_list|,
name|val
operator||
operator|(
literal|1
operator|<<
literal|10
operator|)
operator||
operator|(
literal|1
operator|<<
literal|15
operator|)
argument_list|)
expr_stmt|;
comment|/* This register opens the gate for the UMAC despite its name */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_EGRESS_EMAC0_PORT
operator|+
name|params
operator|->
name|port
operator|*
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Maximum Frame Length (RW). Defines a 14-Bit maximum frame 	 * length used by the MAC receive logic to check frames. 	 */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|umac_base
operator|+
name|UMAC_REG_MAXFR
argument_list|,
literal|0x2710
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************/
end_comment

begin_comment
comment|/*			SFX7101 PHY SECTION			  */
end_comment

begin_comment
comment|/******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|elink_7101_config_loopback
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
comment|/* SFX7101_XGXS_TEST1 */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_XS_DEVAD
argument_list|,
name|MDIO_XS_SFX7101_XGXS_TEST1
argument_list|,
literal|0x100
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_7101_config_init
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|uint16_t
name|fw_ver1
decl_stmt|,
name|fw_ver2
decl_stmt|,
name|val
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Setting the SFX7101 LASI indication\n"
argument_list|)
expr_stmt|;
comment|/* Restore normal power mode*/
name|elink_cb_gpio_write
argument_list|(
name|sc
argument_list|,
name|MISC_REGISTERS_GPIO_2
argument_list|,
name|MISC_REGISTERS_GPIO_OUTPUT_HIGH
argument_list|,
name|params
operator|->
name|port
argument_list|)
expr_stmt|;
comment|/* HW reset */
name|elink_ext_phy_hw_reset
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|port
argument_list|)
expr_stmt|;
name|elink_wait_reset_complete
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_LASI_CTRL
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Setting the SFX7101 LED to blink on traffic\n"
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_7107_LED_CNTL
argument_list|,
operator|(
literal|1
operator|<<
literal|3
operator|)
argument_list|)
expr_stmt|;
name|elink_ext_phy_set_pause
argument_list|(
name|params
argument_list|,
name|phy
argument_list|,
name|vars
argument_list|)
expr_stmt|;
comment|/* Restart autoneg */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_CTRL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|val
operator||=
literal|0x200
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_CTRL
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Save spirom version */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_7101_VER1
argument_list|,
operator|&
name|fw_ver1
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_7101_VER2
argument_list|,
operator|&
name|fw_ver2
argument_list|)
expr_stmt|;
name|elink_save_spirom_version
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|port
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|fw_ver1
operator|<<
literal|16
operator||
name|fw_ver2
argument_list|)
argument_list|,
name|phy
operator|->
name|ver_addr
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|elink_7101_read_status
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint8_t
name|link_up
decl_stmt|;
name|uint16_t
name|val1
decl_stmt|,
name|val2
decl_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_LASI_STAT
argument_list|,
operator|&
name|val2
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_LASI_STAT
argument_list|,
operator|&
name|val1
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"10G-base-T LASI status 0x%x->0x%x\n"
argument_list|,
name|val2
argument_list|,
name|val1
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_STATUS
argument_list|,
operator|&
name|val2
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_STATUS
argument_list|,
operator|&
name|val1
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"10G-base-T PMA status 0x%x->0x%x\n"
argument_list|,
name|val2
argument_list|,
name|val1
argument_list|)
expr_stmt|;
name|link_up
operator|=
operator|(
operator|(
name|val1
operator|&
literal|4
operator|)
operator|==
literal|4
operator|)
expr_stmt|;
comment|/* If link is up print the AN outcome of the SFX7101 PHY */
if|if
condition|(
name|link_up
condition|)
block|{
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_MASTER_STATUS
argument_list|,
operator|&
name|val2
argument_list|)
expr_stmt|;
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_10000
expr_stmt|;
name|vars
operator|->
name|duplex
operator|=
name|DUPLEX_FULL
expr_stmt|;
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"SFX7101 AN status 0x%x->Master=%x\n"
argument_list|,
name|val2
argument_list|,
operator|(
name|val2
operator|&
operator|(
literal|1
operator|<<
literal|14
operator|)
operator|)
argument_list|)
expr_stmt|;
name|elink_ext_phy_10G_an_resolve
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|vars
argument_list|)
expr_stmt|;
name|elink_ext_phy_resolve_fc
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
comment|/* Read LP advertised speeds */
if|if
condition|(
name|val2
operator|&
operator|(
literal|1
operator|<<
literal|11
operator|)
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_LINK_PARTNER_10GXFD_CAPABLE
expr_stmt|;
block|}
return|return
name|link_up
return|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_7101_format_ver
parameter_list|(
name|uint32_t
name|spirom_ver
parameter_list|,
name|uint8_t
modifier|*
name|str
parameter_list|,
name|uint16_t
modifier|*
name|len
parameter_list|)
block|{
if|if
condition|(
operator|*
name|len
operator|<
literal|5
condition|)
return|return
name|ELINK_STATUS_ERROR
return|;
name|str
index|[
literal|0
index|]
operator|=
operator|(
name|spirom_ver
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|str
index|[
literal|1
index|]
operator|=
operator|(
name|spirom_ver
operator|&
literal|0xFF00
operator|)
operator|>>
literal|8
expr_stmt|;
name|str
index|[
literal|2
index|]
operator|=
operator|(
name|spirom_ver
operator|&
literal|0xFF0000
operator|)
operator|>>
literal|16
expr_stmt|;
name|str
index|[
literal|3
index|]
operator|=
operator|(
name|spirom_ver
operator|&
literal|0xFF000000
operator|)
operator|>>
literal|24
expr_stmt|;
name|str
index|[
literal|4
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|len
operator|-=
literal|5
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
name|void
name|elink_sfx7101_sp_sw_reset
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|)
block|{
name|uint16_t
name|val
decl_stmt|,
name|cnt
decl_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_7101_RESET
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
literal|10
condition|;
name|cnt
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|1000
operator|*
literal|50
argument_list|)
expr_stmt|;
comment|/* Writes a self-clearing reset */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_7101_RESET
argument_list|,
operator|(
name|val
operator||
operator|(
literal|1
operator|<<
literal|15
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Wait for clear */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_7101_RESET
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
operator|(
literal|1
operator|<<
literal|15
operator|)
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|elink_7101_hw_reset
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
comment|/* Low power mode is controlled by GPIO 2 */
name|elink_cb_gpio_write
argument_list|(
name|params
operator|->
name|sc
argument_list|,
name|MISC_REGISTERS_GPIO_2
argument_list|,
name|MISC_REGISTERS_GPIO_OUTPUT_LOW
argument_list|,
name|params
operator|->
name|port
argument_list|)
expr_stmt|;
comment|/* The PHY reset is controlled by GPIO 1 */
name|elink_cb_gpio_write
argument_list|(
name|params
operator|->
name|sc
argument_list|,
name|MISC_REGISTERS_GPIO_1
argument_list|,
name|MISC_REGISTERS_GPIO_OUTPUT_LOW
argument_list|,
name|params
operator|->
name|port
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_7101_set_link_led
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint8_t
name|mode
parameter_list|)
block|{
name|uint16_t
name|val
init|=
literal|0
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|ELINK_LED_MODE_FRONT_PANEL_OFF
case|:
case|case
name|ELINK_LED_MODE_OFF
case|:
name|val
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|ELINK_LED_MODE_ON
case|:
name|val
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ELINK_LED_MODE_OPER
case|:
name|val
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_7107_LINK_LED_CNTL
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************/
end_comment

begin_comment
comment|/*			STATIC PHY DECLARATION			  */
end_comment

begin_comment
comment|/******************************************************************/
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|elink_phy
name|phy_null
init|=
block|{
operator|.
name|type
operator|=
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_NOT_CONN
block|,
operator|.
name|addr
operator|=
literal|0
block|,
operator|.
name|def_md_devad
operator|=
literal|0
block|,
operator|.
name|flags
operator|=
name|ELINK_FLAGS_INIT_XGXS_FIRST
block|,
operator|.
name|rx_preemphasis
operator|=
block|{
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|}
block|,
operator|.
name|tx_preemphasis
operator|=
block|{
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|}
block|,
operator|.
name|mdio_ctrl
operator|=
literal|0
block|,
operator|.
name|supported
operator|=
literal|0
block|,
operator|.
name|media_type
operator|=
name|ELINK_ETH_PHY_NOT_PRESENT
block|,
operator|.
name|ver_addr
operator|=
literal|0
block|,
operator|.
name|req_flow_ctrl
operator|=
literal|0
block|,
operator|.
name|req_line_speed
operator|=
literal|0
block|,
operator|.
name|speed_cap_mask
operator|=
literal|0
block|,
operator|.
name|req_duplex
operator|=
literal|0
block|,
operator|.
name|rsrv
operator|=
literal|0
block|,
operator|.
name|config_init
operator|=
operator|(
name|config_init_t
operator|)
name|NULL
block|,
operator|.
name|read_status
operator|=
operator|(
name|read_status_t
operator|)
name|NULL
block|,
operator|.
name|link_reset
operator|=
operator|(
name|link_reset_t
operator|)
name|NULL
block|,
operator|.
name|config_loopback
operator|=
operator|(
name|config_loopback_t
operator|)
name|NULL
block|,
operator|.
name|format_fw_ver
operator|=
operator|(
name|format_fw_ver_t
operator|)
name|NULL
block|,
operator|.
name|hw_reset
operator|=
operator|(
name|hw_reset_t
operator|)
name|NULL
block|,
operator|.
name|set_link_led
operator|=
operator|(
name|set_link_led_t
operator|)
name|NULL
block|,
operator|.
name|phy_specific_func
operator|=
operator|(
name|phy_specific_func_t
operator|)
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|elink_phy
name|phy_serdes
init|=
block|{
operator|.
name|type
operator|=
name|PORT_HW_CFG_SERDES_EXT_PHY_TYPE_DIRECT
block|,
operator|.
name|addr
operator|=
literal|0xff
block|,
operator|.
name|def_md_devad
operator|=
literal|0
block|,
operator|.
name|flags
operator|=
literal|0
block|,
operator|.
name|rx_preemphasis
operator|=
block|{
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|}
block|,
operator|.
name|tx_preemphasis
operator|=
block|{
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|}
block|,
operator|.
name|mdio_ctrl
operator|=
literal|0
block|,
operator|.
name|supported
operator|=
operator|(
name|ELINK_SUPPORTED_10baseT_Half
operator||
name|ELINK_SUPPORTED_10baseT_Full
operator||
name|ELINK_SUPPORTED_100baseT_Half
operator||
name|ELINK_SUPPORTED_100baseT_Full
operator||
name|ELINK_SUPPORTED_1000baseT_Full
operator||
name|ELINK_SUPPORTED_2500baseX_Full
operator||
name|ELINK_SUPPORTED_TP
operator||
name|ELINK_SUPPORTED_Autoneg
operator||
name|ELINK_SUPPORTED_Pause
operator||
name|ELINK_SUPPORTED_Asym_Pause
operator|)
block|,
operator|.
name|media_type
operator|=
name|ELINK_ETH_PHY_BASE_T
block|,
operator|.
name|ver_addr
operator|=
literal|0
block|,
operator|.
name|req_flow_ctrl
operator|=
literal|0
block|,
operator|.
name|req_line_speed
operator|=
literal|0
block|,
operator|.
name|speed_cap_mask
operator|=
literal|0
block|,
operator|.
name|req_duplex
operator|=
literal|0
block|,
operator|.
name|rsrv
operator|=
literal|0
block|,
operator|.
name|config_init
operator|=
operator|(
name|config_init_t
operator|)
name|elink_xgxs_config_init
block|,
operator|.
name|read_status
operator|=
operator|(
name|read_status_t
operator|)
name|elink_link_settings_status
block|,
operator|.
name|link_reset
operator|=
operator|(
name|link_reset_t
operator|)
name|elink_int_link_reset
block|,
operator|.
name|config_loopback
operator|=
operator|(
name|config_loopback_t
operator|)
name|NULL
block|,
operator|.
name|format_fw_ver
operator|=
operator|(
name|format_fw_ver_t
operator|)
name|NULL
block|,
operator|.
name|hw_reset
operator|=
operator|(
name|hw_reset_t
operator|)
name|NULL
block|,
operator|.
name|set_link_led
operator|=
operator|(
name|set_link_led_t
operator|)
name|NULL
block|,
operator|.
name|phy_specific_func
operator|=
operator|(
name|phy_specific_func_t
operator|)
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|elink_phy
name|phy_xgxs
init|=
block|{
operator|.
name|type
operator|=
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT
block|,
operator|.
name|addr
operator|=
literal|0xff
block|,
operator|.
name|def_md_devad
operator|=
literal|0
block|,
operator|.
name|flags
operator|=
literal|0
block|,
operator|.
name|rx_preemphasis
operator|=
block|{
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|}
block|,
operator|.
name|tx_preemphasis
operator|=
block|{
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|}
block|,
operator|.
name|mdio_ctrl
operator|=
literal|0
block|,
operator|.
name|supported
operator|=
operator|(
name|ELINK_SUPPORTED_10baseT_Half
operator||
name|ELINK_SUPPORTED_10baseT_Full
operator||
name|ELINK_SUPPORTED_100baseT_Half
operator||
name|ELINK_SUPPORTED_100baseT_Full
operator||
name|ELINK_SUPPORTED_1000baseT_Full
operator||
name|ELINK_SUPPORTED_2500baseX_Full
operator||
name|ELINK_SUPPORTED_10000baseT_Full
operator||
name|ELINK_SUPPORTED_FIBRE
operator||
name|ELINK_SUPPORTED_Autoneg
operator||
name|ELINK_SUPPORTED_Pause
operator||
name|ELINK_SUPPORTED_Asym_Pause
operator|)
block|,
operator|.
name|media_type
operator|=
name|ELINK_ETH_PHY_CX4
block|,
operator|.
name|ver_addr
operator|=
literal|0
block|,
operator|.
name|req_flow_ctrl
operator|=
literal|0
block|,
operator|.
name|req_line_speed
operator|=
literal|0
block|,
operator|.
name|speed_cap_mask
operator|=
literal|0
block|,
operator|.
name|req_duplex
operator|=
literal|0
block|,
operator|.
name|rsrv
operator|=
literal|0
block|,
operator|.
name|config_init
operator|=
operator|(
name|config_init_t
operator|)
name|elink_xgxs_config_init
block|,
operator|.
name|read_status
operator|=
operator|(
name|read_status_t
operator|)
name|elink_link_settings_status
block|,
operator|.
name|link_reset
operator|=
operator|(
name|link_reset_t
operator|)
name|elink_int_link_reset
block|,
operator|.
name|config_loopback
operator|=
operator|(
name|config_loopback_t
operator|)
name|elink_set_xgxs_loopback
block|,
operator|.
name|format_fw_ver
operator|=
operator|(
name|format_fw_ver_t
operator|)
name|NULL
block|,
operator|.
name|hw_reset
operator|=
operator|(
name|hw_reset_t
operator|)
name|NULL
block|,
operator|.
name|set_link_led
operator|=
operator|(
name|set_link_led_t
operator|)
name|NULL
block|,
operator|.
name|phy_specific_func
operator|=
operator|(
name|phy_specific_func_t
operator|)
name|elink_xgxs_specific_func
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|elink_phy
name|phy_warpcore
init|=
block|{
operator|.
name|type
operator|=
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT
block|,
operator|.
name|addr
operator|=
literal|0xff
block|,
operator|.
name|def_md_devad
operator|=
literal|0
block|,
operator|.
name|flags
operator|=
name|ELINK_FLAGS_TX_ERROR_CHECK
block|,
operator|.
name|rx_preemphasis
operator|=
block|{
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|}
block|,
operator|.
name|tx_preemphasis
operator|=
block|{
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|}
block|,
operator|.
name|mdio_ctrl
operator|=
literal|0
block|,
operator|.
name|supported
operator|=
operator|(
name|ELINK_SUPPORTED_10baseT_Half
operator||
name|ELINK_SUPPORTED_10baseT_Full
operator||
name|ELINK_SUPPORTED_100baseT_Half
operator||
name|ELINK_SUPPORTED_100baseT_Full
operator||
name|ELINK_SUPPORTED_1000baseT_Full
operator||
name|ELINK_SUPPORTED_1000baseKX_Full
operator||
name|ELINK_SUPPORTED_10000baseT_Full
operator||
name|ELINK_SUPPORTED_10000baseKR_Full
operator||
name|ELINK_SUPPORTED_20000baseKR2_Full
operator||
name|ELINK_SUPPORTED_20000baseMLD2_Full
operator||
name|ELINK_SUPPORTED_FIBRE
operator||
name|ELINK_SUPPORTED_Autoneg
operator||
name|ELINK_SUPPORTED_Pause
operator||
name|ELINK_SUPPORTED_Asym_Pause
operator|)
block|,
operator|.
name|media_type
operator|=
name|ELINK_ETH_PHY_UNSPECIFIED
block|,
operator|.
name|ver_addr
operator|=
literal|0
block|,
operator|.
name|req_flow_ctrl
operator|=
literal|0
block|,
operator|.
name|req_line_speed
operator|=
literal|0
block|,
operator|.
name|speed_cap_mask
operator|=
literal|0
block|,
comment|/* req_duplex = */
literal|0
block|,
comment|/* rsrv = */
literal|0
block|,
operator|.
name|config_init
operator|=
operator|(
name|config_init_t
operator|)
name|elink_warpcore_config_init
block|,
operator|.
name|read_status
operator|=
operator|(
name|read_status_t
operator|)
name|elink_warpcore_read_status
block|,
operator|.
name|link_reset
operator|=
operator|(
name|link_reset_t
operator|)
name|elink_warpcore_link_reset
block|,
operator|.
name|config_loopback
operator|=
operator|(
name|config_loopback_t
operator|)
name|elink_set_warpcore_loopback
block|,
operator|.
name|format_fw_ver
operator|=
operator|(
name|format_fw_ver_t
operator|)
name|NULL
block|,
operator|.
name|hw_reset
operator|=
operator|(
name|hw_reset_t
operator|)
name|elink_warpcore_hw_reset
block|,
operator|.
name|set_link_led
operator|=
operator|(
name|set_link_led_t
operator|)
name|NULL
block|,
operator|.
name|phy_specific_func
operator|=
operator|(
name|phy_specific_func_t
operator|)
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|elink_phy
name|phy_7101
init|=
block|{
operator|.
name|type
operator|=
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_SFX7101
block|,
operator|.
name|addr
operator|=
literal|0xff
block|,
operator|.
name|def_md_devad
operator|=
literal|0
block|,
operator|.
name|flags
operator|=
name|ELINK_FLAGS_FAN_FAILURE_DET_REQ
block|,
operator|.
name|rx_preemphasis
operator|=
block|{
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|}
block|,
operator|.
name|tx_preemphasis
operator|=
block|{
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|}
block|,
operator|.
name|mdio_ctrl
operator|=
literal|0
block|,
operator|.
name|supported
operator|=
operator|(
name|ELINK_SUPPORTED_10000baseT_Full
operator||
name|ELINK_SUPPORTED_TP
operator||
name|ELINK_SUPPORTED_Autoneg
operator||
name|ELINK_SUPPORTED_Pause
operator||
name|ELINK_SUPPORTED_Asym_Pause
operator|)
block|,
operator|.
name|media_type
operator|=
name|ELINK_ETH_PHY_BASE_T
block|,
operator|.
name|ver_addr
operator|=
literal|0
block|,
operator|.
name|req_flow_ctrl
operator|=
literal|0
block|,
operator|.
name|req_line_speed
operator|=
literal|0
block|,
operator|.
name|speed_cap_mask
operator|=
literal|0
block|,
operator|.
name|req_duplex
operator|=
literal|0
block|,
operator|.
name|rsrv
operator|=
literal|0
block|,
operator|.
name|config_init
operator|=
operator|(
name|config_init_t
operator|)
name|elink_7101_config_init
block|,
operator|.
name|read_status
operator|=
operator|(
name|read_status_t
operator|)
name|elink_7101_read_status
block|,
operator|.
name|link_reset
operator|=
operator|(
name|link_reset_t
operator|)
name|elink_common_ext_link_reset
block|,
operator|.
name|config_loopback
operator|=
operator|(
name|config_loopback_t
operator|)
name|elink_7101_config_loopback
block|,
operator|.
name|format_fw_ver
operator|=
operator|(
name|format_fw_ver_t
operator|)
name|elink_7101_format_ver
block|,
operator|.
name|hw_reset
operator|=
operator|(
name|hw_reset_t
operator|)
name|elink_7101_hw_reset
block|,
operator|.
name|set_link_led
operator|=
operator|(
name|set_link_led_t
operator|)
name|elink_7101_set_link_led
block|,
operator|.
name|phy_specific_func
operator|=
operator|(
name|phy_specific_func_t
operator|)
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|elink_phy
name|phy_8073
init|=
block|{
operator|.
name|type
operator|=
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073
block|,
operator|.
name|addr
operator|=
literal|0xff
block|,
operator|.
name|def_md_devad
operator|=
literal|0
block|,
operator|.
name|flags
operator|=
literal|0
block|,
operator|.
name|rx_preemphasis
operator|=
block|{
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|}
block|,
operator|.
name|tx_preemphasis
operator|=
block|{
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|}
block|,
operator|.
name|mdio_ctrl
operator|=
literal|0
block|,
operator|.
name|supported
operator|=
operator|(
name|ELINK_SUPPORTED_10000baseT_Full
operator||
name|ELINK_SUPPORTED_2500baseX_Full
operator||
name|ELINK_SUPPORTED_1000baseT_Full
operator||
name|ELINK_SUPPORTED_FIBRE
operator||
name|ELINK_SUPPORTED_Autoneg
operator||
name|ELINK_SUPPORTED_Pause
operator||
name|ELINK_SUPPORTED_Asym_Pause
operator|)
block|,
operator|.
name|media_type
operator|=
name|ELINK_ETH_PHY_KR
block|,
operator|.
name|ver_addr
operator|=
literal|0
block|,
operator|.
name|req_flow_ctrl
operator|=
literal|0
block|,
operator|.
name|req_line_speed
operator|=
literal|0
block|,
operator|.
name|speed_cap_mask
operator|=
literal|0
block|,
operator|.
name|req_duplex
operator|=
literal|0
block|,
operator|.
name|rsrv
operator|=
literal|0
block|,
operator|.
name|config_init
operator|=
operator|(
name|config_init_t
operator|)
name|elink_8073_config_init
block|,
operator|.
name|read_status
operator|=
operator|(
name|read_status_t
operator|)
name|elink_8073_read_status
block|,
operator|.
name|link_reset
operator|=
operator|(
name|link_reset_t
operator|)
name|elink_8073_link_reset
block|,
operator|.
name|config_loopback
operator|=
operator|(
name|config_loopback_t
operator|)
name|NULL
block|,
operator|.
name|format_fw_ver
operator|=
operator|(
name|format_fw_ver_t
operator|)
name|elink_format_ver
block|,
operator|.
name|hw_reset
operator|=
operator|(
name|hw_reset_t
operator|)
name|NULL
block|,
operator|.
name|set_link_led
operator|=
operator|(
name|set_link_led_t
operator|)
name|NULL
block|,
operator|.
name|phy_specific_func
operator|=
operator|(
name|phy_specific_func_t
operator|)
name|elink_8073_specific_func
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|elink_phy
name|phy_8705
init|=
block|{
operator|.
name|type
operator|=
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8705
block|,
operator|.
name|addr
operator|=
literal|0xff
block|,
operator|.
name|def_md_devad
operator|=
literal|0
block|,
operator|.
name|flags
operator|=
name|ELINK_FLAGS_INIT_XGXS_FIRST
block|,
operator|.
name|rx_preemphasis
operator|=
block|{
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|}
block|,
operator|.
name|tx_preemphasis
operator|=
block|{
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|}
block|,
operator|.
name|mdio_ctrl
operator|=
literal|0
block|,
operator|.
name|supported
operator|=
operator|(
name|ELINK_SUPPORTED_10000baseT_Full
operator||
name|ELINK_SUPPORTED_FIBRE
operator||
name|ELINK_SUPPORTED_Pause
operator||
name|ELINK_SUPPORTED_Asym_Pause
operator|)
block|,
operator|.
name|media_type
operator|=
name|ELINK_ETH_PHY_XFP_FIBER
block|,
operator|.
name|ver_addr
operator|=
literal|0
block|,
operator|.
name|req_flow_ctrl
operator|=
literal|0
block|,
operator|.
name|req_line_speed
operator|=
literal|0
block|,
operator|.
name|speed_cap_mask
operator|=
literal|0
block|,
operator|.
name|req_duplex
operator|=
literal|0
block|,
operator|.
name|rsrv
operator|=
literal|0
block|,
operator|.
name|config_init
operator|=
operator|(
name|config_init_t
operator|)
name|elink_8705_config_init
block|,
operator|.
name|read_status
operator|=
operator|(
name|read_status_t
operator|)
name|elink_8705_read_status
block|,
operator|.
name|link_reset
operator|=
operator|(
name|link_reset_t
operator|)
name|elink_common_ext_link_reset
block|,
operator|.
name|config_loopback
operator|=
operator|(
name|config_loopback_t
operator|)
name|NULL
block|,
operator|.
name|format_fw_ver
operator|=
operator|(
name|format_fw_ver_t
operator|)
name|elink_null_format_ver
block|,
operator|.
name|hw_reset
operator|=
operator|(
name|hw_reset_t
operator|)
name|NULL
block|,
operator|.
name|set_link_led
operator|=
operator|(
name|set_link_led_t
operator|)
name|NULL
block|,
operator|.
name|phy_specific_func
operator|=
operator|(
name|phy_specific_func_t
operator|)
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|elink_phy
name|phy_8706
init|=
block|{
operator|.
name|type
operator|=
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8706
block|,
operator|.
name|addr
operator|=
literal|0xff
block|,
operator|.
name|def_md_devad
operator|=
literal|0
block|,
operator|.
name|flags
operator|=
name|ELINK_FLAGS_INIT_XGXS_FIRST
block|,
operator|.
name|rx_preemphasis
operator|=
block|{
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|}
block|,
operator|.
name|tx_preemphasis
operator|=
block|{
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|}
block|,
operator|.
name|mdio_ctrl
operator|=
literal|0
block|,
operator|.
name|supported
operator|=
operator|(
name|ELINK_SUPPORTED_10000baseT_Full
operator||
name|ELINK_SUPPORTED_1000baseT_Full
operator||
name|ELINK_SUPPORTED_FIBRE
operator||
name|ELINK_SUPPORTED_Pause
operator||
name|ELINK_SUPPORTED_Asym_Pause
operator|)
block|,
operator|.
name|media_type
operator|=
name|ELINK_ETH_PHY_SFPP_10G_FIBER
block|,
operator|.
name|ver_addr
operator|=
literal|0
block|,
operator|.
name|req_flow_ctrl
operator|=
literal|0
block|,
operator|.
name|req_line_speed
operator|=
literal|0
block|,
operator|.
name|speed_cap_mask
operator|=
literal|0
block|,
operator|.
name|req_duplex
operator|=
literal|0
block|,
operator|.
name|rsrv
operator|=
literal|0
block|,
operator|.
name|config_init
operator|=
operator|(
name|config_init_t
operator|)
name|elink_8706_config_init
block|,
operator|.
name|read_status
operator|=
operator|(
name|read_status_t
operator|)
name|elink_8706_read_status
block|,
operator|.
name|link_reset
operator|=
operator|(
name|link_reset_t
operator|)
name|elink_common_ext_link_reset
block|,
operator|.
name|config_loopback
operator|=
operator|(
name|config_loopback_t
operator|)
name|NULL
block|,
operator|.
name|format_fw_ver
operator|=
operator|(
name|format_fw_ver_t
operator|)
name|elink_format_ver
block|,
operator|.
name|hw_reset
operator|=
operator|(
name|hw_reset_t
operator|)
name|NULL
block|,
operator|.
name|set_link_led
operator|=
operator|(
name|set_link_led_t
operator|)
name|NULL
block|,
operator|.
name|phy_specific_func
operator|=
operator|(
name|phy_specific_func_t
operator|)
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|elink_phy
name|phy_8726
init|=
block|{
operator|.
name|type
operator|=
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726
block|,
operator|.
name|addr
operator|=
literal|0xff
block|,
operator|.
name|def_md_devad
operator|=
literal|0
block|,
operator|.
name|flags
operator|=
operator|(
name|ELINK_FLAGS_INIT_XGXS_FIRST
operator||
name|ELINK_FLAGS_TX_ERROR_CHECK
operator|)
block|,
operator|.
name|rx_preemphasis
operator|=
block|{
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|}
block|,
operator|.
name|tx_preemphasis
operator|=
block|{
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|}
block|,
operator|.
name|mdio_ctrl
operator|=
literal|0
block|,
operator|.
name|supported
operator|=
operator|(
name|ELINK_SUPPORTED_10000baseT_Full
operator||
name|ELINK_SUPPORTED_1000baseT_Full
operator||
name|ELINK_SUPPORTED_Autoneg
operator||
name|ELINK_SUPPORTED_FIBRE
operator||
name|ELINK_SUPPORTED_Pause
operator||
name|ELINK_SUPPORTED_Asym_Pause
operator|)
block|,
operator|.
name|media_type
operator|=
name|ELINK_ETH_PHY_NOT_PRESENT
block|,
operator|.
name|ver_addr
operator|=
literal|0
block|,
operator|.
name|req_flow_ctrl
operator|=
literal|0
block|,
operator|.
name|req_line_speed
operator|=
literal|0
block|,
operator|.
name|speed_cap_mask
operator|=
literal|0
block|,
operator|.
name|req_duplex
operator|=
literal|0
block|,
operator|.
name|rsrv
operator|=
literal|0
block|,
operator|.
name|config_init
operator|=
operator|(
name|config_init_t
operator|)
name|elink_8726_config_init
block|,
operator|.
name|read_status
operator|=
operator|(
name|read_status_t
operator|)
name|elink_8726_read_status
block|,
operator|.
name|link_reset
operator|=
operator|(
name|link_reset_t
operator|)
name|elink_8726_link_reset
block|,
operator|.
name|config_loopback
operator|=
operator|(
name|config_loopback_t
operator|)
name|elink_8726_config_loopback
block|,
operator|.
name|format_fw_ver
operator|=
operator|(
name|format_fw_ver_t
operator|)
name|elink_format_ver
block|,
operator|.
name|hw_reset
operator|=
operator|(
name|hw_reset_t
operator|)
name|NULL
block|,
operator|.
name|set_link_led
operator|=
operator|(
name|set_link_led_t
operator|)
name|NULL
block|,
operator|.
name|phy_specific_func
operator|=
operator|(
name|phy_specific_func_t
operator|)
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|elink_phy
name|phy_8727
init|=
block|{
operator|.
name|type
operator|=
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727
block|,
operator|.
name|addr
operator|=
literal|0xff
block|,
operator|.
name|def_md_devad
operator|=
literal|0
block|,
operator|.
name|flags
operator|=
operator|(
name|ELINK_FLAGS_FAN_FAILURE_DET_REQ
operator||
name|ELINK_FLAGS_TX_ERROR_CHECK
operator|)
block|,
operator|.
name|rx_preemphasis
operator|=
block|{
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|}
block|,
operator|.
name|tx_preemphasis
operator|=
block|{
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|}
block|,
operator|.
name|mdio_ctrl
operator|=
literal|0
block|,
operator|.
name|supported
operator|=
operator|(
name|ELINK_SUPPORTED_10000baseT_Full
operator||
name|ELINK_SUPPORTED_1000baseT_Full
operator||
name|ELINK_SUPPORTED_FIBRE
operator||
name|ELINK_SUPPORTED_Pause
operator||
name|ELINK_SUPPORTED_Asym_Pause
operator|)
block|,
operator|.
name|media_type
operator|=
name|ELINK_ETH_PHY_NOT_PRESENT
block|,
operator|.
name|ver_addr
operator|=
literal|0
block|,
operator|.
name|req_flow_ctrl
operator|=
literal|0
block|,
operator|.
name|req_line_speed
operator|=
literal|0
block|,
operator|.
name|speed_cap_mask
operator|=
literal|0
block|,
operator|.
name|req_duplex
operator|=
literal|0
block|,
operator|.
name|rsrv
operator|=
literal|0
block|,
operator|.
name|config_init
operator|=
operator|(
name|config_init_t
operator|)
name|elink_8727_config_init
block|,
operator|.
name|read_status
operator|=
operator|(
name|read_status_t
operator|)
name|elink_8727_read_status
block|,
operator|.
name|link_reset
operator|=
operator|(
name|link_reset_t
operator|)
name|elink_8727_link_reset
block|,
operator|.
name|config_loopback
operator|=
operator|(
name|config_loopback_t
operator|)
name|NULL
block|,
operator|.
name|format_fw_ver
operator|=
operator|(
name|format_fw_ver_t
operator|)
name|elink_format_ver
block|,
operator|.
name|hw_reset
operator|=
operator|(
name|hw_reset_t
operator|)
name|elink_8727_hw_reset
block|,
operator|.
name|set_link_led
operator|=
operator|(
name|set_link_led_t
operator|)
name|elink_8727_set_link_led
block|,
operator|.
name|phy_specific_func
operator|=
operator|(
name|phy_specific_func_t
operator|)
name|elink_8727_specific_func
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|elink_phy
name|phy_8481
init|=
block|{
operator|.
name|type
operator|=
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8481
block|,
operator|.
name|addr
operator|=
literal|0xff
block|,
operator|.
name|def_md_devad
operator|=
literal|0
block|,
operator|.
name|flags
operator|=
name|ELINK_FLAGS_FAN_FAILURE_DET_REQ
operator||
name|ELINK_FLAGS_REARM_LATCH_SIGNAL
block|,
operator|.
name|rx_preemphasis
operator|=
block|{
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|}
block|,
operator|.
name|tx_preemphasis
operator|=
block|{
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|}
block|,
operator|.
name|mdio_ctrl
operator|=
literal|0
block|,
operator|.
name|supported
operator|=
operator|(
name|ELINK_SUPPORTED_10baseT_Half
operator||
name|ELINK_SUPPORTED_10baseT_Full
operator||
name|ELINK_SUPPORTED_100baseT_Half
operator||
name|ELINK_SUPPORTED_100baseT_Full
operator||
name|ELINK_SUPPORTED_1000baseT_Full
operator||
name|ELINK_SUPPORTED_10000baseT_Full
operator||
name|ELINK_SUPPORTED_TP
operator||
name|ELINK_SUPPORTED_Autoneg
operator||
name|ELINK_SUPPORTED_Pause
operator||
name|ELINK_SUPPORTED_Asym_Pause
operator|)
block|,
operator|.
name|media_type
operator|=
name|ELINK_ETH_PHY_BASE_T
block|,
operator|.
name|ver_addr
operator|=
literal|0
block|,
operator|.
name|req_flow_ctrl
operator|=
literal|0
block|,
operator|.
name|req_line_speed
operator|=
literal|0
block|,
operator|.
name|speed_cap_mask
operator|=
literal|0
block|,
operator|.
name|req_duplex
operator|=
literal|0
block|,
operator|.
name|rsrv
operator|=
literal|0
block|,
operator|.
name|config_init
operator|=
operator|(
name|config_init_t
operator|)
name|elink_8481_config_init
block|,
operator|.
name|read_status
operator|=
operator|(
name|read_status_t
operator|)
name|elink_848xx_read_status
block|,
operator|.
name|link_reset
operator|=
operator|(
name|link_reset_t
operator|)
name|elink_8481_link_reset
block|,
operator|.
name|config_loopback
operator|=
operator|(
name|config_loopback_t
operator|)
name|NULL
block|,
operator|.
name|format_fw_ver
operator|=
operator|(
name|format_fw_ver_t
operator|)
name|elink_848xx_format_ver
block|,
operator|.
name|hw_reset
operator|=
operator|(
name|hw_reset_t
operator|)
name|elink_8481_hw_reset
block|,
operator|.
name|set_link_led
operator|=
operator|(
name|set_link_led_t
operator|)
name|elink_848xx_set_link_led
block|,
operator|.
name|phy_specific_func
operator|=
operator|(
name|phy_specific_func_t
operator|)
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|elink_phy
name|phy_84823
init|=
block|{
operator|.
name|type
operator|=
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84823
block|,
operator|.
name|addr
operator|=
literal|0xff
block|,
operator|.
name|def_md_devad
operator|=
literal|0
block|,
operator|.
name|flags
operator|=
operator|(
name|ELINK_FLAGS_FAN_FAILURE_DET_REQ
operator||
name|ELINK_FLAGS_REARM_LATCH_SIGNAL
operator||
name|ELINK_FLAGS_TX_ERROR_CHECK
operator|)
block|,
operator|.
name|rx_preemphasis
operator|=
block|{
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|}
block|,
operator|.
name|tx_preemphasis
operator|=
block|{
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|}
block|,
operator|.
name|mdio_ctrl
operator|=
literal|0
block|,
operator|.
name|supported
operator|=
operator|(
name|ELINK_SUPPORTED_10baseT_Half
operator||
name|ELINK_SUPPORTED_10baseT_Full
operator||
name|ELINK_SUPPORTED_100baseT_Half
operator||
name|ELINK_SUPPORTED_100baseT_Full
operator||
name|ELINK_SUPPORTED_1000baseT_Full
operator||
name|ELINK_SUPPORTED_10000baseT_Full
operator||
name|ELINK_SUPPORTED_TP
operator||
name|ELINK_SUPPORTED_Autoneg
operator||
name|ELINK_SUPPORTED_Pause
operator||
name|ELINK_SUPPORTED_Asym_Pause
operator|)
block|,
operator|.
name|media_type
operator|=
name|ELINK_ETH_PHY_BASE_T
block|,
operator|.
name|ver_addr
operator|=
literal|0
block|,
operator|.
name|req_flow_ctrl
operator|=
literal|0
block|,
operator|.
name|req_line_speed
operator|=
literal|0
block|,
operator|.
name|speed_cap_mask
operator|=
literal|0
block|,
operator|.
name|req_duplex
operator|=
literal|0
block|,
operator|.
name|rsrv
operator|=
literal|0
block|,
operator|.
name|config_init
operator|=
operator|(
name|config_init_t
operator|)
name|elink_848x3_config_init
block|,
operator|.
name|read_status
operator|=
operator|(
name|read_status_t
operator|)
name|elink_848xx_read_status
block|,
operator|.
name|link_reset
operator|=
operator|(
name|link_reset_t
operator|)
name|elink_848x3_link_reset
block|,
operator|.
name|config_loopback
operator|=
operator|(
name|config_loopback_t
operator|)
name|NULL
block|,
operator|.
name|format_fw_ver
operator|=
operator|(
name|format_fw_ver_t
operator|)
name|elink_848xx_format_ver
block|,
operator|.
name|hw_reset
operator|=
operator|(
name|hw_reset_t
operator|)
name|NULL
block|,
operator|.
name|set_link_led
operator|=
operator|(
name|set_link_led_t
operator|)
name|elink_848xx_set_link_led
block|,
operator|.
name|phy_specific_func
operator|=
operator|(
name|phy_specific_func_t
operator|)
name|elink_848xx_specific_func
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|elink_phy
name|phy_84833
init|=
block|{
operator|.
name|type
operator|=
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84833
block|,
operator|.
name|addr
operator|=
literal|0xff
block|,
operator|.
name|def_md_devad
operator|=
literal|0
block|,
operator|.
name|flags
operator|=
operator|(
name|ELINK_FLAGS_FAN_FAILURE_DET_REQ
operator||
name|ELINK_FLAGS_REARM_LATCH_SIGNAL
operator||
name|ELINK_FLAGS_TX_ERROR_CHECK
operator||
name|ELINK_FLAGS_TEMPERATURE
operator|)
block|,
operator|.
name|rx_preemphasis
operator|=
block|{
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|}
block|,
operator|.
name|tx_preemphasis
operator|=
block|{
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|}
block|,
operator|.
name|mdio_ctrl
operator|=
literal|0
block|,
operator|.
name|supported
operator|=
operator|(
name|ELINK_SUPPORTED_100baseT_Half
operator||
name|ELINK_SUPPORTED_100baseT_Full
operator||
name|ELINK_SUPPORTED_1000baseT_Full
operator||
name|ELINK_SUPPORTED_10000baseT_Full
operator||
name|ELINK_SUPPORTED_TP
operator||
name|ELINK_SUPPORTED_Autoneg
operator||
name|ELINK_SUPPORTED_Pause
operator||
name|ELINK_SUPPORTED_Asym_Pause
operator|)
block|,
operator|.
name|media_type
operator|=
name|ELINK_ETH_PHY_BASE_T
block|,
operator|.
name|ver_addr
operator|=
literal|0
block|,
operator|.
name|req_flow_ctrl
operator|=
literal|0
block|,
operator|.
name|req_line_speed
operator|=
literal|0
block|,
operator|.
name|speed_cap_mask
operator|=
literal|0
block|,
operator|.
name|req_duplex
operator|=
literal|0
block|,
operator|.
name|rsrv
operator|=
literal|0
block|,
operator|.
name|config_init
operator|=
operator|(
name|config_init_t
operator|)
name|elink_848x3_config_init
block|,
operator|.
name|read_status
operator|=
operator|(
name|read_status_t
operator|)
name|elink_848xx_read_status
block|,
operator|.
name|link_reset
operator|=
operator|(
name|link_reset_t
operator|)
name|elink_848x3_link_reset
block|,
operator|.
name|config_loopback
operator|=
operator|(
name|config_loopback_t
operator|)
name|NULL
block|,
operator|.
name|format_fw_ver
operator|=
operator|(
name|format_fw_ver_t
operator|)
name|elink_848xx_format_ver
block|,
operator|.
name|hw_reset
operator|=
operator|(
name|hw_reset_t
operator|)
name|elink_84833_hw_reset_phy
block|,
operator|.
name|set_link_led
operator|=
operator|(
name|set_link_led_t
operator|)
name|elink_848xx_set_link_led
block|,
operator|.
name|phy_specific_func
operator|=
operator|(
name|phy_specific_func_t
operator|)
name|elink_848xx_specific_func
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|elink_phy
name|phy_84834
init|=
block|{
operator|.
name|type
operator|=
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84834
block|,
operator|.
name|addr
operator|=
literal|0xff
block|,
operator|.
name|def_md_devad
operator|=
literal|0
block|,
operator|.
name|flags
operator|=
name|ELINK_FLAGS_FAN_FAILURE_DET_REQ
operator||
name|ELINK_FLAGS_REARM_LATCH_SIGNAL
block|,
operator|.
name|rx_preemphasis
operator|=
block|{
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|}
block|,
operator|.
name|tx_preemphasis
operator|=
block|{
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|}
block|,
operator|.
name|mdio_ctrl
operator|=
literal|0
block|,
operator|.
name|supported
operator|=
operator|(
name|ELINK_SUPPORTED_100baseT_Half
operator||
name|ELINK_SUPPORTED_100baseT_Full
operator||
name|ELINK_SUPPORTED_1000baseT_Full
operator||
name|ELINK_SUPPORTED_10000baseT_Full
operator||
name|ELINK_SUPPORTED_TP
operator||
name|ELINK_SUPPORTED_Autoneg
operator||
name|ELINK_SUPPORTED_Pause
operator||
name|ELINK_SUPPORTED_Asym_Pause
operator|)
block|,
operator|.
name|media_type
operator|=
name|ELINK_ETH_PHY_BASE_T
block|,
operator|.
name|ver_addr
operator|=
literal|0
block|,
operator|.
name|req_flow_ctrl
operator|=
literal|0
block|,
operator|.
name|req_line_speed
operator|=
literal|0
block|,
operator|.
name|speed_cap_mask
operator|=
literal|0
block|,
operator|.
name|req_duplex
operator|=
literal|0
block|,
operator|.
name|rsrv
operator|=
literal|0
block|,
operator|.
name|config_init
operator|=
operator|(
name|config_init_t
operator|)
name|elink_848x3_config_init
block|,
operator|.
name|read_status
operator|=
operator|(
name|read_status_t
operator|)
name|elink_848xx_read_status
block|,
operator|.
name|link_reset
operator|=
operator|(
name|link_reset_t
operator|)
name|elink_848x3_link_reset
block|,
operator|.
name|config_loopback
operator|=
operator|(
name|config_loopback_t
operator|)
name|NULL
block|,
operator|.
name|format_fw_ver
operator|=
operator|(
name|format_fw_ver_t
operator|)
name|elink_848xx_format_ver
block|,
operator|.
name|hw_reset
operator|=
operator|(
name|hw_reset_t
operator|)
name|elink_84833_hw_reset_phy
block|,
operator|.
name|set_link_led
operator|=
operator|(
name|set_link_led_t
operator|)
name|elink_848xx_set_link_led
block|,
operator|.
name|phy_specific_func
operator|=
operator|(
name|phy_specific_func_t
operator|)
name|elink_848xx_specific_func
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|elink_phy
name|phy_84858
init|=
block|{
operator|.
name|type
operator|=
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84858
block|,
operator|.
name|addr
operator|=
literal|0xff
block|,
operator|.
name|def_md_devad
operator|=
literal|0
block|,
operator|.
name|flags
operator|=
name|ELINK_FLAGS_FAN_FAILURE_DET_REQ
operator||
name|ELINK_FLAGS_REARM_LATCH_SIGNAL
block|,
operator|.
name|rx_preemphasis
operator|=
block|{
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|}
block|,
operator|.
name|tx_preemphasis
operator|=
block|{
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|}
block|,
operator|.
name|mdio_ctrl
operator|=
literal|0
block|,
operator|.
name|supported
operator|=
operator|(
name|ELINK_SUPPORTED_100baseT_Half
operator||
name|ELINK_SUPPORTED_100baseT_Full
operator||
name|ELINK_SUPPORTED_1000baseT_Full
operator||
name|ELINK_SUPPORTED_10000baseT_Full
operator||
name|ELINK_SUPPORTED_TP
operator||
name|ELINK_SUPPORTED_Autoneg
operator||
name|ELINK_SUPPORTED_Pause
operator||
name|ELINK_SUPPORTED_Asym_Pause
operator|)
block|,
operator|.
name|media_type
operator|=
name|ELINK_ETH_PHY_BASE_T
block|,
operator|.
name|ver_addr
operator|=
literal|0
block|,
operator|.
name|req_flow_ctrl
operator|=
literal|0
block|,
operator|.
name|req_line_speed
operator|=
literal|0
block|,
operator|.
name|speed_cap_mask
operator|=
literal|0
block|,
operator|.
name|req_duplex
operator|=
literal|0
block|,
operator|.
name|rsrv
operator|=
literal|0
block|,
operator|.
name|config_init
operator|=
operator|(
name|config_init_t
operator|)
name|elink_848x3_config_init
block|,
operator|.
name|read_status
operator|=
operator|(
name|read_status_t
operator|)
name|elink_848xx_read_status
block|,
operator|.
name|link_reset
operator|=
operator|(
name|link_reset_t
operator|)
name|elink_848x3_link_reset
block|,
operator|.
name|config_loopback
operator|=
operator|(
name|config_loopback_t
operator|)
name|NULL
block|,
operator|.
name|format_fw_ver
operator|=
operator|(
name|format_fw_ver_t
operator|)
name|elink_848xx_format_ver
block|,
operator|.
name|hw_reset
operator|=
operator|(
name|hw_reset_t
operator|)
name|elink_84833_hw_reset_phy
block|,
operator|.
name|set_link_led
operator|=
operator|(
name|set_link_led_t
operator|)
name|elink_848xx_set_link_led
block|,
operator|.
name|phy_specific_func
operator|=
operator|(
name|phy_specific_func_t
operator|)
name|elink_848xx_specific_func
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|elink_phy
name|phy_54618se
init|=
block|{
operator|.
name|type
operator|=
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM54618SE
block|,
operator|.
name|addr
operator|=
literal|0xff
block|,
operator|.
name|def_md_devad
operator|=
literal|0
block|,
operator|.
name|flags
operator|=
name|ELINK_FLAGS_INIT_XGXS_FIRST
block|,
operator|.
name|rx_preemphasis
operator|=
block|{
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|}
block|,
operator|.
name|tx_preemphasis
operator|=
block|{
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|,
literal|0xffff
block|}
block|,
operator|.
name|mdio_ctrl
operator|=
literal|0
block|,
operator|.
name|supported
operator|=
operator|(
name|ELINK_SUPPORTED_10baseT_Half
operator||
name|ELINK_SUPPORTED_10baseT_Full
operator||
name|ELINK_SUPPORTED_100baseT_Half
operator||
name|ELINK_SUPPORTED_100baseT_Full
operator||
name|ELINK_SUPPORTED_1000baseT_Full
operator||
name|ELINK_SUPPORTED_TP
operator||
name|ELINK_SUPPORTED_Autoneg
operator||
name|ELINK_SUPPORTED_Pause
operator||
name|ELINK_SUPPORTED_Asym_Pause
operator|)
block|,
operator|.
name|media_type
operator|=
name|ELINK_ETH_PHY_BASE_T
block|,
operator|.
name|ver_addr
operator|=
literal|0
block|,
operator|.
name|req_flow_ctrl
operator|=
literal|0
block|,
operator|.
name|req_line_speed
operator|=
literal|0
block|,
operator|.
name|speed_cap_mask
operator|=
literal|0
block|,
comment|/* req_duplex = */
literal|0
block|,
comment|/* rsrv = */
literal|0
block|,
operator|.
name|config_init
operator|=
operator|(
name|config_init_t
operator|)
name|elink_54618se_config_init
block|,
operator|.
name|read_status
operator|=
operator|(
name|read_status_t
operator|)
name|elink_54618se_read_status
block|,
operator|.
name|link_reset
operator|=
operator|(
name|link_reset_t
operator|)
name|elink_54618se_link_reset
block|,
operator|.
name|config_loopback
operator|=
operator|(
name|config_loopback_t
operator|)
name|elink_54618se_config_loopback
block|,
operator|.
name|format_fw_ver
operator|=
operator|(
name|format_fw_ver_t
operator|)
name|NULL
block|,
operator|.
name|hw_reset
operator|=
operator|(
name|hw_reset_t
operator|)
name|NULL
block|,
operator|.
name|set_link_led
operator|=
operator|(
name|set_link_led_t
operator|)
name|elink_5461x_set_link_led
block|,
operator|.
name|phy_specific_func
operator|=
operator|(
name|phy_specific_func_t
operator|)
name|elink_54618se_specific_func
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*****************************************************************/
end_comment

begin_comment
comment|/*                                                               */
end_comment

begin_comment
comment|/* Populate the phy according. Main function: elink_populate_phy   */
end_comment

begin_comment
comment|/*                                                               */
end_comment

begin_comment
comment|/*****************************************************************/
end_comment

begin_function
specifier|static
name|void
name|elink_populate_preemphasis
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|shmem_base
parameter_list|,
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|uint8_t
name|port
parameter_list|,
name|uint8_t
name|phy_index
parameter_list|)
block|{
comment|/* Get the 4 lanes xgxs config rx and tx */
name|uint32_t
name|rx
init|=
literal|0
decl_stmt|,
name|tx
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
comment|/* INT_PHY and ELINK_EXT_PHY1 share the same value location in 		 * the shmem. When num_phys is greater than 1, than this value 		 * applies only to ELINK_EXT_PHY1 		 */
if|if
condition|(
name|phy_index
operator|==
name|ELINK_INT_PHY
operator|||
name|phy_index
operator|==
name|ELINK_EXT_PHY1
condition|)
block|{
name|rx
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|port
index|]
operator|.
name|xgxs_config_rx
index|[
name|i
operator|<<
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|tx
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|port
index|]
operator|.
name|xgxs_config_tx
index|[
name|i
operator|<<
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rx
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|port
index|]
operator|.
name|xgxs_config2_rx
index|[
name|i
operator|<<
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|tx
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|port
index|]
operator|.
name|xgxs_config2_rx
index|[
name|i
operator|<<
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|phy
operator|->
name|rx_preemphasis
index|[
name|i
operator|<<
literal|1
index|]
operator|=
operator|(
operator|(
name|rx
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|phy
operator|->
name|rx_preemphasis
index|[
operator|(
name|i
operator|<<
literal|1
operator|)
operator|+
literal|1
index|]
operator|=
operator|(
name|rx
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|phy
operator|->
name|tx_preemphasis
index|[
name|i
operator|<<
literal|1
index|]
operator|=
operator|(
operator|(
name|tx
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|phy
operator|->
name|tx_preemphasis
index|[
operator|(
name|i
operator|<<
literal|1
operator|)
operator|+
literal|1
index|]
operator|=
operator|(
name|tx
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"phy->rx_preemphasis = %x, phy->tx_preemphasis = %x\n"
argument_list|,
name|phy
operator|->
name|rx_preemphasis
index|[
name|i
operator|<<
literal|1
index|]
argument_list|,
name|phy
operator|->
name|tx_preemphasis
index|[
name|i
operator|<<
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|elink_get_ext_phy_config
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|shmem_base
parameter_list|,
name|uint8_t
name|phy_index
parameter_list|,
name|uint8_t
name|port
parameter_list|)
block|{
name|uint32_t
name|ext_phy_config
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|phy_index
condition|)
block|{
case|case
name|ELINK_EXT_PHY1
case|:
name|ext_phy_config
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|port
index|]
operator|.
name|external_phy_config
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ELINK_EXT_PHY2
case|:
name|ext_phy_config
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|port
index|]
operator|.
name|external_phy_config2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Invalid phy_index %d\n"
argument_list|,
name|phy_index
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
return|return
name|ext_phy_config
return|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_populate_int_phy
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|shmem_base
parameter_list|,
name|uint8_t
name|port
parameter_list|,
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|)
block|{
name|uint32_t
name|phy_addr
decl_stmt|;
name|uint32_t
name|chip_id
decl_stmt|;
name|uint32_t
name|switch_cfg
init|=
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_feature_config
index|[
name|port
index|]
operator|.
name|link_config
argument_list|)
argument_list|)
operator|&
name|PORT_FEATURE_CONNECTED_SWITCH_MASK
operator|)
decl_stmt|;
name|chip_id
operator|=
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_CHIP_NUM
argument_list|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_CHIP_REV
argument_list|)
operator|&
literal|0xf
operator|)
operator|<<
literal|12
operator|)
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|":chip_id = 0x%x\n"
argument_list|,
name|chip_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|USES_WARPCORE
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|uint32_t
name|serdes_net_if
decl_stmt|;
name|phy_addr
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_WC0_CTRL_PHY_ADDR
argument_list|)
expr_stmt|;
operator|*
name|phy
operator|=
name|phy_warpcore
expr_stmt|;
if|if
condition|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_PORT4MODE_EN_OVWR
argument_list|)
operator|==
literal|0x3
condition|)
name|phy
operator|->
name|flags
operator||=
name|ELINK_FLAGS_4_PORT_MODE
expr_stmt|;
else|else
name|phy
operator|->
name|flags
operator|&=
operator|~
name|ELINK_FLAGS_4_PORT_MODE
expr_stmt|;
comment|/* Check Dual mode */
name|serdes_net_if
operator|=
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|port
index|]
operator|.
name|default_cfg
argument_list|)
argument_list|)
operator|&
name|PORT_HW_CFG_NET_SERDES_IF_MASK
operator|)
expr_stmt|;
comment|/* Set the appropriate supported and flags indications per 		 * interface type of the chip 		 */
switch|switch
condition|(
name|serdes_net_if
condition|)
block|{
case|case
name|PORT_HW_CFG_NET_SERDES_IF_SGMII
case|:
name|phy
operator|->
name|supported
operator|&=
operator|(
name|ELINK_SUPPORTED_10baseT_Half
operator||
name|ELINK_SUPPORTED_10baseT_Full
operator||
name|ELINK_SUPPORTED_100baseT_Half
operator||
name|ELINK_SUPPORTED_100baseT_Full
operator||
name|ELINK_SUPPORTED_1000baseT_Full
operator||
name|ELINK_SUPPORTED_FIBRE
operator||
name|ELINK_SUPPORTED_Autoneg
operator||
name|ELINK_SUPPORTED_Pause
operator||
name|ELINK_SUPPORTED_Asym_Pause
operator|)
expr_stmt|;
name|phy
operator|->
name|media_type
operator|=
name|ELINK_ETH_PHY_BASE_T
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_NET_SERDES_IF_XFI
case|:
name|phy
operator|->
name|supported
operator|&=
operator|(
name|ELINK_SUPPORTED_1000baseT_Full
operator||
name|ELINK_SUPPORTED_10000baseT_Full
operator||
name|ELINK_SUPPORTED_FIBRE
operator||
name|ELINK_SUPPORTED_Pause
operator||
name|ELINK_SUPPORTED_Asym_Pause
operator|)
expr_stmt|;
name|phy
operator|->
name|media_type
operator|=
name|ELINK_ETH_PHY_XFP_FIBER
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_NET_SERDES_IF_SFI
case|:
name|phy
operator|->
name|supported
operator|&=
operator|(
name|ELINK_SUPPORTED_1000baseT_Full
operator||
name|ELINK_SUPPORTED_10000baseT_Full
operator||
name|ELINK_SUPPORTED_FIBRE
operator||
name|ELINK_SUPPORTED_Pause
operator||
name|ELINK_SUPPORTED_Asym_Pause
operator|)
expr_stmt|;
name|phy
operator|->
name|media_type
operator|=
name|ELINK_ETH_PHY_SFPP_10G_FIBER
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_NET_SERDES_IF_KR
case|:
name|phy
operator|->
name|media_type
operator|=
name|ELINK_ETH_PHY_KR
expr_stmt|;
name|phy
operator|->
name|supported
operator|&=
operator|(
name|ELINK_SUPPORTED_1000baseKX_Full
operator||
name|ELINK_SUPPORTED_10000baseKR_Full
operator||
name|ELINK_SUPPORTED_FIBRE
operator||
name|ELINK_SUPPORTED_Autoneg
operator||
name|ELINK_SUPPORTED_Pause
operator||
name|ELINK_SUPPORTED_Asym_Pause
operator|)
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_NET_SERDES_IF_DXGXS
case|:
name|phy
operator|->
name|media_type
operator|=
name|ELINK_ETH_PHY_KR
expr_stmt|;
name|phy
operator|->
name|flags
operator||=
name|ELINK_FLAGS_WC_DUAL_MODE
expr_stmt|;
name|phy
operator|->
name|supported
operator|&=
operator|(
name|ELINK_SUPPORTED_20000baseMLD2_Full
operator||
name|ELINK_SUPPORTED_FIBRE
operator||
name|ELINK_SUPPORTED_Pause
operator||
name|ELINK_SUPPORTED_Asym_Pause
operator|)
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_NET_SERDES_IF_KR2
case|:
name|phy
operator|->
name|media_type
operator|=
name|ELINK_ETH_PHY_KR
expr_stmt|;
name|phy
operator|->
name|flags
operator||=
name|ELINK_FLAGS_WC_DUAL_MODE
expr_stmt|;
name|phy
operator|->
name|supported
operator|&=
operator|(
name|ELINK_SUPPORTED_20000baseKR2_Full
operator||
name|ELINK_SUPPORTED_10000baseKR_Full
operator||
name|ELINK_SUPPORTED_1000baseKX_Full
operator||
name|ELINK_SUPPORTED_Autoneg
operator||
name|ELINK_SUPPORTED_FIBRE
operator||
name|ELINK_SUPPORTED_Pause
operator||
name|ELINK_SUPPORTED_Asym_Pause
operator|)
expr_stmt|;
name|phy
operator|->
name|flags
operator|&=
operator|~
name|ELINK_FLAGS_TX_ERROR_CHECK
expr_stmt|;
break|break;
default|default:
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Unknown WC interface type 0x%x\n"
argument_list|,
name|serdes_net_if
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Enable MDC/MDIO work-around for E3 A0 since free running MDC 		 * was not set as expected. For B0, ECO will be enabled so there 		 * won't be an issue there 		 */
if|if
condition|(
name|CHIP_REV
argument_list|(
name|sc
argument_list|)
operator|==
name|CHIP_REV_Ax
condition|)
name|phy
operator|->
name|flags
operator||=
name|ELINK_FLAGS_MDC_MDIO_WA
expr_stmt|;
else|else
name|phy
operator|->
name|flags
operator||=
name|ELINK_FLAGS_MDC_MDIO_WA_B0
expr_stmt|;
name|ELINK_DEBUG_P3
argument_list|(
name|sc
argument_list|,
literal|"media_type = %x, flags = %x, supported = %x\n"
argument_list|,
name|phy
operator|->
name|media_type
argument_list|,
name|phy
operator|->
name|flags
argument_list|,
name|phy
operator|->
name|supported
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|switch_cfg
condition|)
block|{
case|case
name|ELINK_SWITCH_CFG_1G
case|:
name|phy_addr
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_SERDES0_CTRL_PHY_ADDR
operator|+
name|port
operator|*
literal|0x10
argument_list|)
expr_stmt|;
operator|*
name|phy
operator|=
name|phy_serdes
expr_stmt|;
break|break;
case|case
name|ELINK_SWITCH_CFG_10G
case|:
name|phy_addr
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_XGXS0_CTRL_PHY_ADDR
operator|+
name|port
operator|*
literal|0x18
argument_list|)
expr_stmt|;
operator|*
name|phy
operator|=
name|phy_xgxs
expr_stmt|;
break|break;
default|default:
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Invalid switch_cfg\n"
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
block|}
name|phy
operator|->
name|addr
operator|=
operator|(
name|uint8_t
operator|)
name|phy_addr
expr_stmt|;
name|phy
operator|->
name|mdio_ctrl
operator|=
name|elink_get_emac_base
argument_list|(
name|sc
argument_list|,
name|SHARED_HW_CFG_MDC_MDIO_ACCESS1_BOTH
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E2
argument_list|(
name|sc
argument_list|)
condition|)
name|phy
operator|->
name|def_md_devad
operator|=
name|ELINK_E2_DEFAULT_PHY_DEV_ADDR
expr_stmt|;
else|else
name|phy
operator|->
name|def_md_devad
operator|=
name|ELINK_DEFAULT_PHY_DEV_ADDR
expr_stmt|;
name|ELINK_DEBUG_P3
argument_list|(
name|sc
argument_list|,
literal|"Internal phy port=%d, addr=0x%x, mdio_ctl=0x%x\n"
argument_list|,
name|port
argument_list|,
name|phy
operator|->
name|addr
argument_list|,
name|phy
operator|->
name|mdio_ctrl
argument_list|)
expr_stmt|;
name|elink_populate_preemphasis
argument_list|(
name|sc
argument_list|,
name|shmem_base
argument_list|,
name|phy
argument_list|,
name|port
argument_list|,
name|ELINK_INT_PHY
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_populate_ext_phy
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|phy_index
parameter_list|,
name|uint32_t
name|shmem_base
parameter_list|,
name|uint32_t
name|shmem2_base
parameter_list|,
name|uint8_t
name|port
parameter_list|,
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|)
block|{
name|uint32_t
name|ext_phy_config
decl_stmt|,
name|phy_type
decl_stmt|,
name|config2
decl_stmt|;
name|uint32_t
name|mdc_mdio_access
init|=
name|SHARED_HW_CFG_MDC_MDIO_ACCESS1_BOTH
decl_stmt|;
name|ext_phy_config
operator|=
name|elink_get_ext_phy_config
argument_list|(
name|sc
argument_list|,
name|shmem_base
argument_list|,
name|phy_index
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|phy_type
operator|=
name|ELINK_XGXS_EXT_PHY_TYPE
argument_list|(
name|ext_phy_config
argument_list|)
expr_stmt|;
comment|/* Select the phy type */
switch|switch
condition|(
name|phy_type
condition|)
block|{
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073
case|:
name|mdc_mdio_access
operator|=
name|SHARED_HW_CFG_MDC_MDIO_ACCESS1_SWAPPED
expr_stmt|;
operator|*
name|phy
operator|=
name|phy_8073
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8705
case|:
operator|*
name|phy
operator|=
name|phy_8705
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8706
case|:
operator|*
name|phy
operator|=
name|phy_8706
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726
case|:
name|mdc_mdio_access
operator|=
name|SHARED_HW_CFG_MDC_MDIO_ACCESS1_EMAC1
expr_stmt|;
operator|*
name|phy
operator|=
name|phy_8726
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727_NOC
case|:
comment|/* BCM8727_NOC => BCM8727 no over current */
name|mdc_mdio_access
operator|=
name|SHARED_HW_CFG_MDC_MDIO_ACCESS1_EMAC1
expr_stmt|;
operator|*
name|phy
operator|=
name|phy_8727
expr_stmt|;
name|phy
operator|->
name|flags
operator||=
name|ELINK_FLAGS_NOC
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8722
case|:
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727
case|:
name|mdc_mdio_access
operator|=
name|SHARED_HW_CFG_MDC_MDIO_ACCESS1_EMAC1
expr_stmt|;
operator|*
name|phy
operator|=
name|phy_8727
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8481
case|:
operator|*
name|phy
operator|=
name|phy_8481
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84823
case|:
operator|*
name|phy
operator|=
name|phy_84823
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84833
case|:
operator|*
name|phy
operator|=
name|phy_84833
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84834
case|:
operator|*
name|phy
operator|=
name|phy_84834
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84858
case|:
operator|*
name|phy
operator|=
name|phy_84858
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM54616
case|:
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM54618SE
case|:
operator|*
name|phy
operator|=
name|phy_54618se
expr_stmt|;
if|if
condition|(
name|phy_type
operator|==
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM54618SE
condition|)
name|phy
operator|->
name|flags
operator||=
name|ELINK_FLAGS_EEE
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_SFX7101
case|:
operator|*
name|phy
operator|=
name|phy_7101
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_FAILURE
case|:
operator|*
name|phy
operator|=
name|phy_null
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
default|default:
operator|*
name|phy
operator|=
name|phy_null
expr_stmt|;
comment|/* In case external PHY wasn't found */
if|if
condition|(
operator|(
name|phy_type
operator|!=
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT
operator|)
operator|&&
operator|(
name|phy_type
operator|!=
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_NOT_CONN
operator|)
condition|)
return|return
name|ELINK_STATUS_ERROR
return|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
name|phy
operator|->
name|addr
operator|=
name|ELINK_XGXS_EXT_PHY_ADDR
argument_list|(
name|ext_phy_config
argument_list|)
expr_stmt|;
name|elink_populate_preemphasis
argument_list|(
name|sc
argument_list|,
name|shmem_base
argument_list|,
name|phy
argument_list|,
name|port
argument_list|,
name|phy_index
argument_list|)
expr_stmt|;
comment|/* The shmem address of the phy version is located on different 	 * structures. In case this structure is too old, do not set 	 * the address 	 */
name|config2
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|shared_hw_config
operator|.
name|config2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_index
operator|==
name|ELINK_EXT_PHY1
condition|)
block|{
name|phy
operator|->
name|ver_addr
operator|=
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|port_mb
index|[
name|port
index|]
operator|.
name|ext_phy_fw_version
argument_list|)
expr_stmt|;
comment|/* Check specific mdc mdio settings */
if|if
condition|(
name|config2
operator|&
name|SHARED_HW_CFG_MDC_MDIO_ACCESS1_MASK
condition|)
name|mdc_mdio_access
operator|=
name|config2
operator|&
name|SHARED_HW_CFG_MDC_MDIO_ACCESS1_MASK
expr_stmt|;
block|}
else|else
block|{
name|uint32_t
name|size
init|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|shmem2_base
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|offsetof
argument_list|(
expr|struct
name|shmem2_region
argument_list|,
name|ext_phy_fw_version2
argument_list|)
condition|)
block|{
name|phy
operator|->
name|ver_addr
operator|=
name|shmem2_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem2_region
argument_list|,
name|ext_phy_fw_version2
index|[
name|port
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Check specific mdc mdio settings */
if|if
condition|(
name|config2
operator|&
name|SHARED_HW_CFG_MDC_MDIO_ACCESS2_MASK
condition|)
name|mdc_mdio_access
operator|=
operator|(
name|config2
operator|&
name|SHARED_HW_CFG_MDC_MDIO_ACCESS2_MASK
operator|)
operator|>>
operator|(
name|SHARED_HW_CFG_MDC_MDIO_ACCESS2_SHIFT
operator|-
name|SHARED_HW_CFG_MDC_MDIO_ACCESS1_SHIFT
operator|)
expr_stmt|;
block|}
name|phy
operator|->
name|mdio_ctrl
operator|=
name|elink_get_emac_base
argument_list|(
name|sc
argument_list|,
name|mdc_mdio_access
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|elink_is_8483x_8485x
argument_list|(
name|phy
argument_list|)
operator|&&
operator|(
name|phy
operator|->
name|ver_addr
operator|)
condition|)
block|{
comment|/* Remove 100Mb link supported for BCM84833/4 when phy fw 		 * version lower than or equal to 1.39 		 */
name|uint32_t
name|raw_ver
init|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|phy
operator|->
name|ver_addr
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|raw_ver
operator|&
literal|0x7F
operator|)
operator|<=
literal|39
operator|)
operator|&&
operator|(
operator|(
operator|(
name|raw_ver
operator|&
literal|0xF80
operator|)
operator|>>
literal|7
operator|)
operator|<=
literal|1
operator|)
condition|)
name|phy
operator|->
name|supported
operator|&=
operator|~
operator|(
name|ELINK_SUPPORTED_100baseT_Half
operator||
name|ELINK_SUPPORTED_100baseT_Full
operator|)
expr_stmt|;
block|}
name|ELINK_DEBUG_P3
argument_list|(
name|sc
argument_list|,
literal|"phy_type 0x%x port %d found in index %d\n"
argument_list|,
name|phy_type
argument_list|,
name|port
argument_list|,
name|phy_index
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"             addr=0x%x, mdio_ctl=0x%x\n"
argument_list|,
name|phy
operator|->
name|addr
argument_list|,
name|phy
operator|->
name|mdio_ctrl
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_populate_phy
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|phy_index
parameter_list|,
name|uint32_t
name|shmem_base
parameter_list|,
name|uint32_t
name|shmem2_base
parameter_list|,
name|uint8_t
name|port
parameter_list|,
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|)
block|{
name|elink_status_t
name|status
init|=
name|ELINK_STATUS_OK
decl_stmt|;
name|phy
operator|->
name|type
operator|=
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_NOT_CONN
expr_stmt|;
if|if
condition|(
name|phy_index
operator|==
name|ELINK_INT_PHY
condition|)
return|return
name|elink_populate_int_phy
argument_list|(
name|sc
argument_list|,
name|shmem_base
argument_list|,
name|port
argument_list|,
name|phy
argument_list|)
return|;
name|status
operator|=
name|elink_populate_ext_phy
argument_list|(
name|sc
argument_list|,
name|phy_index
argument_list|,
name|shmem_base
argument_list|,
name|shmem2_base
argument_list|,
name|port
argument_list|,
name|phy
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_phy_def_cfg
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|uint8_t
name|phy_index
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint32_t
name|link_config
decl_stmt|;
comment|/* Populate the default phy configuration for MF mode */
if|if
condition|(
name|phy_index
operator|==
name|ELINK_EXT_PHY2
condition|)
block|{
name|link_config
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_feature_config
index|[
name|params
operator|->
name|port
index|]
operator|.
name|link_config2
argument_list|)
argument_list|)
expr_stmt|;
name|phy
operator|->
name|speed_cap_mask
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|params
operator|->
name|port
index|]
operator|.
name|speed_capability_mask2
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|link_config
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_feature_config
index|[
name|params
operator|->
name|port
index|]
operator|.
name|link_config
argument_list|)
argument_list|)
expr_stmt|;
name|phy
operator|->
name|speed_cap_mask
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|params
operator|->
name|port
index|]
operator|.
name|speed_capability_mask
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ELINK_DEBUG_P3
argument_list|(
name|sc
argument_list|,
literal|"Default config phy idx %x cfg 0x%x speed_cap_mask 0x%x\n"
argument_list|,
name|phy_index
argument_list|,
name|link_config
argument_list|,
name|phy
operator|->
name|speed_cap_mask
argument_list|)
expr_stmt|;
name|phy
operator|->
name|req_duplex
operator|=
name|DUPLEX_FULL
expr_stmt|;
switch|switch
condition|(
name|link_config
operator|&
name|PORT_FEATURE_LINK_SPEED_MASK
condition|)
block|{
case|case
name|PORT_FEATURE_LINK_SPEED_10M_HALF
case|:
name|phy
operator|->
name|req_duplex
operator|=
name|DUPLEX_HALF
expr_stmt|;
case|case
name|PORT_FEATURE_LINK_SPEED_10M_FULL
case|:
name|phy
operator|->
name|req_line_speed
operator|=
name|ELINK_SPEED_10
expr_stmt|;
break|break;
case|case
name|PORT_FEATURE_LINK_SPEED_100M_HALF
case|:
name|phy
operator|->
name|req_duplex
operator|=
name|DUPLEX_HALF
expr_stmt|;
case|case
name|PORT_FEATURE_LINK_SPEED_100M_FULL
case|:
name|phy
operator|->
name|req_line_speed
operator|=
name|ELINK_SPEED_100
expr_stmt|;
break|break;
case|case
name|PORT_FEATURE_LINK_SPEED_1G
case|:
name|phy
operator|->
name|req_line_speed
operator|=
name|ELINK_SPEED_1000
expr_stmt|;
break|break;
case|case
name|PORT_FEATURE_LINK_SPEED_2_5G
case|:
name|phy
operator|->
name|req_line_speed
operator|=
name|ELINK_SPEED_2500
expr_stmt|;
break|break;
case|case
name|PORT_FEATURE_LINK_SPEED_10G_CX4
case|:
name|phy
operator|->
name|req_line_speed
operator|=
name|ELINK_SPEED_10000
expr_stmt|;
break|break;
default|default:
name|phy
operator|->
name|req_line_speed
operator|=
name|ELINK_SPEED_AUTO_NEG
expr_stmt|;
break|break;
block|}
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"Default config phy idx %x, req_duplex config %x\n"
argument_list|,
name|phy_index
argument_list|,
name|phy
operator|->
name|req_duplex
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|link_config
operator|&
name|PORT_FEATURE_FLOW_CONTROL_MASK
condition|)
block|{
case|case
name|PORT_FEATURE_FLOW_CONTROL_AUTO
case|:
name|phy
operator|->
name|req_flow_ctrl
operator|=
name|ELINK_FLOW_CTRL_AUTO
expr_stmt|;
break|break;
case|case
name|PORT_FEATURE_FLOW_CONTROL_TX
case|:
name|phy
operator|->
name|req_flow_ctrl
operator|=
name|ELINK_FLOW_CTRL_TX
expr_stmt|;
break|break;
case|case
name|PORT_FEATURE_FLOW_CONTROL_RX
case|:
name|phy
operator|->
name|req_flow_ctrl
operator|=
name|ELINK_FLOW_CTRL_RX
expr_stmt|;
break|break;
case|case
name|PORT_FEATURE_FLOW_CONTROL_BOTH
case|:
name|phy
operator|->
name|req_flow_ctrl
operator|=
name|ELINK_FLOW_CTRL_BOTH
expr_stmt|;
break|break;
default|default:
name|phy
operator|->
name|req_flow_ctrl
operator|=
name|ELINK_FLOW_CTRL_NONE
expr_stmt|;
break|break;
block|}
name|ELINK_DEBUG_P3
argument_list|(
name|sc
argument_list|,
literal|"Requested Duplex = %x, line_speed = %x, flow_ctrl = %x\n"
argument_list|,
name|phy
operator|->
name|req_duplex
argument_list|,
name|phy
operator|->
name|req_line_speed
argument_list|,
name|phy
operator|->
name|req_flow_ctrl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint32_t
name|elink_phy_selection
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|uint32_t
name|phy_config_swapped
decl_stmt|,
name|prio_cfg
decl_stmt|;
name|uint32_t
name|return_cfg
init|=
name|PORT_HW_CFG_PHY_SELECTION_HARDWARE_DEFAULT
decl_stmt|;
name|phy_config_swapped
operator|=
name|params
operator|->
name|multi_phy_config
operator|&
name|PORT_HW_CFG_PHY_SWAPPED_ENABLED
expr_stmt|;
name|prio_cfg
operator|=
name|params
operator|->
name|multi_phy_config
operator|&
name|PORT_HW_CFG_PHY_SELECTION_MASK
expr_stmt|;
if|if
condition|(
name|phy_config_swapped
condition|)
block|{
switch|switch
condition|(
name|prio_cfg
condition|)
block|{
case|case
name|PORT_HW_CFG_PHY_SELECTION_FIRST_PHY_PRIORITY
case|:
name|return_cfg
operator|=
name|PORT_HW_CFG_PHY_SELECTION_SECOND_PHY_PRIORITY
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_PHY_SELECTION_SECOND_PHY_PRIORITY
case|:
name|return_cfg
operator|=
name|PORT_HW_CFG_PHY_SELECTION_FIRST_PHY_PRIORITY
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_PHY_SELECTION_SECOND_PHY
case|:
name|return_cfg
operator|=
name|PORT_HW_CFG_PHY_SELECTION_FIRST_PHY
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_PHY_SELECTION_FIRST_PHY
case|:
name|return_cfg
operator|=
name|PORT_HW_CFG_PHY_SELECTION_SECOND_PHY
expr_stmt|;
break|break;
block|}
block|}
else|else
name|return_cfg
operator|=
name|prio_cfg
expr_stmt|;
return|return
name|return_cfg
return|;
block|}
end_function

begin_function
name|elink_status_t
name|elink_phy_probe
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|uint8_t
name|phy_index
decl_stmt|,
name|actual_phy_idx
decl_stmt|;
name|uint32_t
name|phy_config_swapped
decl_stmt|,
name|sync_offset
decl_stmt|,
name|media_types
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|struct
name|elink_phy
modifier|*
name|phy
decl_stmt|;
name|params
operator|->
name|num_phys
operator|=
literal|0
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Begin phy probe\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ELINK_INCLUDE_EMUL
if|if
condition|(
name|CHIP_REV_IS_EMUL
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|ELINK_STATUS_OK
return|;
endif|#
directive|endif
name|phy_config_swapped
operator|=
name|params
operator|->
name|multi_phy_config
operator|&
name|PORT_HW_CFG_PHY_SWAPPED_ENABLED
expr_stmt|;
for|for
control|(
name|phy_index
operator|=
name|ELINK_INT_PHY
init|;
name|phy_index
operator|<
name|ELINK_MAX_PHYS
condition|;
name|phy_index
operator|++
control|)
block|{
name|actual_phy_idx
operator|=
name|phy_index
expr_stmt|;
if|if
condition|(
name|phy_config_swapped
condition|)
block|{
if|if
condition|(
name|phy_index
operator|==
name|ELINK_EXT_PHY1
condition|)
name|actual_phy_idx
operator|=
name|ELINK_EXT_PHY2
expr_stmt|;
elseif|else
if|if
condition|(
name|phy_index
operator|==
name|ELINK_EXT_PHY2
condition|)
name|actual_phy_idx
operator|=
name|ELINK_EXT_PHY1
expr_stmt|;
block|}
name|ELINK_DEBUG_P3
argument_list|(
name|sc
argument_list|,
literal|"phy_config_swapped %x, phy_index %x,"
literal|" actual_phy_idx %x\n"
argument_list|,
name|phy_config_swapped
argument_list|,
name|phy_index
argument_list|,
name|actual_phy_idx
argument_list|)
expr_stmt|;
name|phy
operator|=
operator|&
name|params
operator|->
name|phy
index|[
name|actual_phy_idx
index|]
expr_stmt|;
if|if
condition|(
name|elink_populate_phy
argument_list|(
name|sc
argument_list|,
name|phy_index
argument_list|,
name|params
operator|->
name|shmem_base
argument_list|,
name|params
operator|->
name|shmem2_base
argument_list|,
name|params
operator|->
name|port
argument_list|,
name|phy
argument_list|)
operator|!=
name|ELINK_STATUS_OK
condition|)
block|{
name|params
operator|->
name|num_phys
operator|=
literal|0
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"phy probe failed in phy index %d\n"
argument_list|,
name|phy_index
argument_list|)
expr_stmt|;
for|for
control|(
name|phy_index
operator|=
name|ELINK_INT_PHY
init|;
name|phy_index
operator|<
name|ELINK_MAX_PHYS
condition|;
name|phy_index
operator|++
control|)
operator|*
name|phy
operator|=
name|phy_null
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
if|if
condition|(
name|phy
operator|->
name|type
operator|==
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_NOT_CONN
condition|)
break|break;
if|if
condition|(
name|params
operator|->
name|feature_config_flags
operator|&
name|ELINK_FEATURE_CONFIG_DISABLE_REMOTE_FAULT_DET
condition|)
name|phy
operator|->
name|flags
operator|&=
operator|~
name|ELINK_FLAGS_TX_ERROR_CHECK
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|params
operator|->
name|feature_config_flags
operator|&
name|ELINK_FEATURE_CONFIG_MT_SUPPORT
operator|)
condition|)
name|phy
operator|->
name|flags
operator||=
name|ELINK_FLAGS_MDC_MDIO_WA_G
expr_stmt|;
name|sync_offset
operator|=
name|params
operator|->
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|params
operator|->
name|port
index|]
operator|.
name|media_type
argument_list|)
expr_stmt|;
name|media_types
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|sync_offset
argument_list|)
expr_stmt|;
comment|/* Update media type for non-PMF sync only for the first time 		 * In case the media type changes afterwards, it will be updated 		 * using the update_status function 		 */
if|if
condition|(
operator|(
name|media_types
operator|&
operator|(
name|PORT_HW_CFG_MEDIA_TYPE_PHY0_MASK
operator|<<
operator|(
name|PORT_HW_CFG_MEDIA_TYPE_PHY1_SHIFT
operator|*
name|actual_phy_idx
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|media_types
operator||=
operator|(
operator|(
name|phy
operator|->
name|media_type
operator|&
name|PORT_HW_CFG_MEDIA_TYPE_PHY0_MASK
operator|)
operator|<<
operator|(
name|PORT_HW_CFG_MEDIA_TYPE_PHY1_SHIFT
operator|*
name|actual_phy_idx
operator|)
operator|)
expr_stmt|;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|sync_offset
argument_list|,
name|media_types
argument_list|)
expr_stmt|;
name|elink_phy_def_cfg
argument_list|(
name|params
argument_list|,
name|phy
argument_list|,
name|phy_index
argument_list|)
expr_stmt|;
name|params
operator|->
name|num_phys
operator|++
expr_stmt|;
block|}
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"End phy probe. #phys found %x\n"
argument_list|,
name|params
operator|->
name|num_phys
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ELINK_INCLUDE_EMUL
end_ifdef

begin_function
specifier|static
name|elink_status_t
name|elink_init_e3_emul_mac
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|vars
operator|->
name|line_speed
operator|=
name|params
operator|->
name|req_line_speed
index|[
literal|0
index|]
expr_stmt|;
comment|/* In case link speed is auto, set speed the highest as possible */
if|if
condition|(
name|params
operator|->
name|req_line_speed
index|[
literal|0
index|]
operator|==
name|ELINK_SPEED_AUTO_NEG
condition|)
block|{
if|if
condition|(
name|params
operator|->
name|feature_config_flags
operator|&
name|ELINK_FEATURE_CONFIG_EMUL_DISABLE_XMAC
condition|)
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_2500
expr_stmt|;
elseif|else
if|if
condition|(
name|elink_is_4_port_mode
argument_list|(
name|sc
argument_list|)
condition|)
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_10000
expr_stmt|;
else|else
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_20000
expr_stmt|;
block|}
if|if
condition|(
name|vars
operator|->
name|line_speed
operator|<
name|ELINK_SPEED_10000
condition|)
block|{
if|if
condition|(
operator|(
name|params
operator|->
name|feature_config_flags
operator|&
name|ELINK_FEATURE_CONFIG_EMUL_DISABLE_UMAC
operator|)
condition|)
block|{
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Invalid line speed %d while UMAC is"
literal|" disabled!\n"
argument_list|,
name|params
operator|->
name|req_line_speed
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
switch|switch
condition|(
name|vars
operator|->
name|line_speed
condition|)
block|{
case|case
name|ELINK_SPEED_10
case|:
name|vars
operator|->
name|link_status
operator|=
name|ELINK_LINK_10TFD
expr_stmt|;
break|break;
case|case
name|ELINK_SPEED_100
case|:
name|vars
operator|->
name|link_status
operator|=
name|ELINK_LINK_100TXFD
expr_stmt|;
break|break;
case|case
name|ELINK_SPEED_1000
case|:
name|vars
operator|->
name|link_status
operator|=
name|ELINK_LINK_1000TFD
expr_stmt|;
break|break;
case|case
name|ELINK_SPEED_2500
case|:
name|vars
operator|->
name|link_status
operator|=
name|ELINK_LINK_2500TFD
expr_stmt|;
break|break;
default|default:
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Invalid line speed %d for UMAC\n"
argument_list|,
name|vars
operator|->
name|line_speed
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_LINK_UP
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|loopback_mode
operator|==
name|ELINK_LOOPBACK_UMAC
condition|)
name|elink_umac_enable
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|elink_umac_enable
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Link speed>= 10000 requires XMAC enabled */
if|if
condition|(
name|params
operator|->
name|feature_config_flags
operator|&
name|ELINK_FEATURE_CONFIG_EMUL_DISABLE_XMAC
condition|)
block|{
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Invalid line speed %d while XMAC is"
literal|" disabled!\n"
argument_list|,
name|params
operator|->
name|req_line_speed
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
comment|/* Check link speed */
switch|switch
condition|(
name|vars
operator|->
name|line_speed
condition|)
block|{
case|case
name|ELINK_SPEED_10000
case|:
name|vars
operator|->
name|link_status
operator|=
name|ELINK_LINK_10GTFD
expr_stmt|;
break|break;
case|case
name|ELINK_SPEED_20000
case|:
name|vars
operator|->
name|link_status
operator|=
name|ELINK_LINK_20GTFD
expr_stmt|;
break|break;
default|default:
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Invalid line speed %d for XMAC\n"
argument_list|,
name|vars
operator|->
name|line_speed
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_LINK_UP
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|loopback_mode
operator|==
name|ELINK_LOOPBACK_XMAC
condition|)
name|elink_xmac_enable
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|elink_xmac_enable
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_init_emul
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
if|if
condition|(
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
block|{
if|if
condition|(
name|elink_init_e3_emul_mac
argument_list|(
name|params
argument_list|,
name|vars
argument_list|)
operator|!=
name|ELINK_STATUS_OK
condition|)
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
else|else
block|{
if|if
condition|(
name|params
operator|->
name|feature_config_flags
operator|&
name|ELINK_FEATURE_CONFIG_EMUL_DISABLE_BMAC
condition|)
block|{
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_1000
expr_stmt|;
name|vars
operator|->
name|link_status
operator|=
operator|(
name|LINK_STATUS_LINK_UP
operator||
name|ELINK_LINK_1000XFD
operator|)
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|loopback_mode
operator|==
name|ELINK_LOOPBACK_EMAC
condition|)
name|elink_emac_enable
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|elink_emac_enable
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_10000
expr_stmt|;
name|vars
operator|->
name|link_status
operator|=
operator|(
name|LINK_STATUS_LINK_UP
operator||
name|ELINK_LINK_10GTFD
operator|)
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|loopback_mode
operator|==
name|ELINK_LOOPBACK_BMAC
condition|)
name|elink_bmac_enable
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|elink_bmac_enable
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|vars
operator|->
name|link_up
operator|=
literal|1
expr_stmt|;
name|vars
operator|->
name|duplex
operator|=
name|DUPLEX_FULL
expr_stmt|;
name|vars
operator|->
name|flow_ctrl
operator|=
name|ELINK_FLOW_CTRL_NONE
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
name|elink_pbf_update
argument_list|(
name|params
argument_list|,
name|vars
operator|->
name|flow_ctrl
argument_list|,
name|vars
operator|->
name|line_speed
argument_list|)
expr_stmt|;
comment|/* Disable drain */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_EGRESS_DRAIN0_MODE
operator|+
name|params
operator|->
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* update shared memory */
name|elink_update_mng
argument_list|(
name|params
argument_list|,
name|vars
operator|->
name|link_status
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ELINK_INCLUDE_FPGA
end_ifdef

begin_function
specifier|static
name|elink_status_t
name|elink_init_fpga
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
comment|/* Enable on E1.5 FPGA */
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|vars
operator|->
name|duplex
operator|=
name|DUPLEX_FULL
expr_stmt|;
name|vars
operator|->
name|flow_ctrl
operator|=
name|ELINK_FLOW_CTRL_NONE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
block|{
name|vars
operator|->
name|flow_ctrl
operator|=
operator|(
name|ELINK_FLOW_CTRL_TX
operator||
name|ELINK_FLOW_CTRL_RX
operator|)
expr_stmt|;
name|vars
operator|->
name|link_status
operator||=
operator|(
name|LINK_STATUS_TX_FLOW_CONTROL_ENABLED
operator||
name|LINK_STATUS_RX_FLOW_CONTROL_ENABLED
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|vars
operator|->
name|line_speed
operator|=
name|params
operator|->
name|req_line_speed
index|[
literal|0
index|]
expr_stmt|;
switch|switch
condition|(
name|vars
operator|->
name|line_speed
condition|)
block|{
case|case
name|ELINK_SPEED_AUTO_NEG
case|:
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_2500
expr_stmt|;
case|case
name|ELINK_SPEED_2500
case|:
name|vars
operator|->
name|link_status
operator|=
name|ELINK_LINK_2500TFD
expr_stmt|;
break|break;
case|case
name|ELINK_SPEED_1000
case|:
name|vars
operator|->
name|link_status
operator|=
name|ELINK_LINK_1000XFD
expr_stmt|;
break|break;
case|case
name|ELINK_SPEED_100
case|:
name|vars
operator|->
name|link_status
operator|=
name|ELINK_LINK_100TXFD
expr_stmt|;
break|break;
case|case
name|ELINK_SPEED_10
case|:
name|vars
operator|->
name|link_status
operator|=
name|ELINK_LINK_10TFD
expr_stmt|;
break|break;
default|default:
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Invalid link speed %d\n"
argument_list|,
name|params
operator|->
name|req_line_speed
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_LINK_UP
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|loopback_mode
operator|==
name|ELINK_LOOPBACK_UMAC
condition|)
name|elink_umac_enable
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|elink_umac_enable
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_10000
expr_stmt|;
name|vars
operator|->
name|link_status
operator|=
operator|(
name|LINK_STATUS_LINK_UP
operator||
name|ELINK_LINK_10GTFD
operator|)
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|loopback_mode
operator|==
name|ELINK_LOOPBACK_EMAC
condition|)
name|elink_emac_enable
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|elink_emac_enable
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|vars
operator|->
name|link_up
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
name|elink_pbf_update
argument_list|(
name|params
argument_list|,
name|vars
operator|->
name|flow_ctrl
argument_list|,
name|vars
operator|->
name|line_speed
argument_list|)
expr_stmt|;
comment|/* Disable drain */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_EGRESS_DRAIN0_MODE
operator|+
name|params
operator|->
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Update shared memory */
name|elink_update_mng
argument_list|(
name|params
argument_list|,
name|vars
operator|->
name|link_status
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|elink_init_bmac_loopback
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|vars
operator|->
name|link_up
operator|=
literal|1
expr_stmt|;
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_10000
expr_stmt|;
name|vars
operator|->
name|duplex
operator|=
name|DUPLEX_FULL
expr_stmt|;
name|vars
operator|->
name|flow_ctrl
operator|=
name|ELINK_FLOW_CTRL_NONE
expr_stmt|;
name|vars
operator|->
name|mac_type
operator|=
name|ELINK_MAC_TYPE_BMAC
expr_stmt|;
name|vars
operator|->
name|phy_flags
operator|=
name|PHY_XGXS_FLAG
expr_stmt|;
name|elink_xgxs_deassert
argument_list|(
name|params
argument_list|)
expr_stmt|;
comment|/* Set bmac loopback */
name|elink_bmac_enable
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_EGRESS_DRAIN0_MODE
operator|+
name|params
operator|->
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_init_emac_loopback
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|vars
operator|->
name|link_up
operator|=
literal|1
expr_stmt|;
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_1000
expr_stmt|;
name|vars
operator|->
name|duplex
operator|=
name|DUPLEX_FULL
expr_stmt|;
name|vars
operator|->
name|flow_ctrl
operator|=
name|ELINK_FLOW_CTRL_NONE
expr_stmt|;
name|vars
operator|->
name|mac_type
operator|=
name|ELINK_MAC_TYPE_EMAC
expr_stmt|;
name|vars
operator|->
name|phy_flags
operator|=
name|PHY_XGXS_FLAG
expr_stmt|;
name|elink_xgxs_deassert
argument_list|(
name|params
argument_list|)
expr_stmt|;
comment|/* Set bmac loopback */
name|elink_emac_enable
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|elink_emac_program
argument_list|(
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_EGRESS_DRAIN0_MODE
operator|+
name|params
operator|->
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_init_xmac_loopback
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|vars
operator|->
name|link_up
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|params
operator|->
name|req_line_speed
index|[
literal|0
index|]
condition|)
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_10000
expr_stmt|;
else|else
name|vars
operator|->
name|line_speed
operator|=
name|params
operator|->
name|req_line_speed
index|[
literal|0
index|]
expr_stmt|;
name|vars
operator|->
name|duplex
operator|=
name|DUPLEX_FULL
expr_stmt|;
name|vars
operator|->
name|flow_ctrl
operator|=
name|ELINK_FLOW_CTRL_NONE
expr_stmt|;
name|vars
operator|->
name|mac_type
operator|=
name|ELINK_MAC_TYPE_XMAC
expr_stmt|;
name|vars
operator|->
name|phy_flags
operator|=
name|PHY_XGXS_FLAG
expr_stmt|;
comment|/* Set WC to loopback mode since link is required to provide clock 	 * to the XMAC in 20G mode 	 */
name|elink_set_aer_mmd
argument_list|(
name|params
argument_list|,
operator|&
name|params
operator|->
name|phy
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|elink_warpcore_reset_lane
argument_list|(
name|sc
argument_list|,
operator|&
name|params
operator|->
name|phy
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|params
operator|->
name|phy
index|[
name|ELINK_INT_PHY
index|]
operator|.
name|config_loopback
argument_list|(
operator|&
name|params
operator|->
name|phy
index|[
name|ELINK_INT_PHY
index|]
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|elink_xmac_enable
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_EGRESS_DRAIN0_MODE
operator|+
name|params
operator|->
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_init_umac_loopback
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|vars
operator|->
name|link_up
operator|=
literal|1
expr_stmt|;
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_1000
expr_stmt|;
name|vars
operator|->
name|duplex
operator|=
name|DUPLEX_FULL
expr_stmt|;
name|vars
operator|->
name|flow_ctrl
operator|=
name|ELINK_FLOW_CTRL_NONE
expr_stmt|;
name|vars
operator|->
name|mac_type
operator|=
name|ELINK_MAC_TYPE_UMAC
expr_stmt|;
name|vars
operator|->
name|phy_flags
operator|=
name|PHY_XGXS_FLAG
expr_stmt|;
name|elink_umac_enable
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_EGRESS_DRAIN0_MODE
operator|+
name|params
operator|->
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_init_xgxs_loopback
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|struct
name|elink_phy
modifier|*
name|int_phy
init|=
operator|&
name|params
operator|->
name|phy
index|[
name|ELINK_INT_PHY
index|]
decl_stmt|;
name|vars
operator|->
name|link_up
operator|=
literal|1
expr_stmt|;
name|vars
operator|->
name|flow_ctrl
operator|=
name|ELINK_FLOW_CTRL_NONE
expr_stmt|;
name|vars
operator|->
name|duplex
operator|=
name|DUPLEX_FULL
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|req_line_speed
index|[
literal|0
index|]
operator|==
name|ELINK_SPEED_1000
condition|)
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_1000
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|params
operator|->
name|req_line_speed
index|[
literal|0
index|]
operator|==
name|ELINK_SPEED_20000
operator|)
operator|||
operator|(
name|int_phy
operator|->
name|flags
operator|&
name|ELINK_FLAGS_WC_DUAL_MODE
operator|)
condition|)
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_20000
expr_stmt|;
else|else
name|vars
operator|->
name|line_speed
operator|=
name|ELINK_SPEED_10000
expr_stmt|;
if|if
condition|(
operator|!
name|USES_WARPCORE
argument_list|(
name|sc
argument_list|)
condition|)
name|elink_xgxs_deassert
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|elink_link_initialize
argument_list|(
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|req_line_speed
index|[
literal|0
index|]
operator|==
name|ELINK_SPEED_1000
condition|)
block|{
if|if
condition|(
name|USES_WARPCORE
argument_list|(
name|sc
argument_list|)
condition|)
name|elink_umac_enable
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|elink_emac_program
argument_list|(
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
name|elink_emac_enable
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|USES_WARPCORE
argument_list|(
name|sc
argument_list|)
condition|)
name|elink_xmac_enable
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|elink_bmac_enable
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|params
operator|->
name|loopback_mode
operator|==
name|ELINK_LOOPBACK_XGXS
condition|)
block|{
comment|/* Set 10G XGXS loopback */
name|int_phy
operator|->
name|config_loopback
argument_list|(
name|int_phy
argument_list|,
name|params
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Set external phy loopback */
name|uint8_t
name|phy_index
decl_stmt|;
for|for
control|(
name|phy_index
operator|=
name|ELINK_EXT_PHY1
init|;
name|phy_index
operator|<
name|params
operator|->
name|num_phys
condition|;
name|phy_index
operator|++
control|)
if|if
condition|(
name|params
operator|->
name|phy
index|[
name|phy_index
index|]
operator|.
name|config_loopback
condition|)
name|params
operator|->
name|phy
index|[
name|phy_index
index|]
operator|.
name|config_loopback
argument_list|(
operator|&
name|params
operator|->
name|phy
index|[
name|phy_index
index|]
argument_list|,
name|params
argument_list|)
expr_stmt|;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_EGRESS_DRAIN0_MODE
operator|+
name|params
operator|->
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|elink_set_led
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
name|ELINK_LED_MODE_OPER
argument_list|,
name|vars
operator|->
name|line_speed
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|elink_set_rx_filter
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|uint8_t
name|en
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint8_t
name|val
init|=
name|en
operator|*
literal|0x1F
decl_stmt|;
comment|/* Open / close the gate between the NIG and the BRB */
if|if
condition|(
operator|!
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
name|val
operator||=
name|en
operator|*
literal|0x20
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LLH0_BRB1_DRV_MASK
operator|+
name|params
operator|->
name|port
operator|*
literal|4
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CHIP_IS_E1
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LLH0_BRB1_DRV_MASK_MF
operator|+
name|params
operator|->
name|port
operator|*
literal|4
argument_list|,
name|en
operator|*
literal|0x3
argument_list|)
expr_stmt|;
block|}
name|REG_WR
argument_list|(
name|sc
argument_list|,
operator|(
name|params
operator|->
name|port
condition|?
name|NIG_REG_LLH1_BRB1_NOT_MCP
else|:
name|NIG_REG_LLH0_BRB1_NOT_MCP
operator|)
argument_list|,
name|en
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_avoid_link_flap
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|uint32_t
name|phy_idx
decl_stmt|;
name|uint32_t
name|dont_clear_stat
decl_stmt|,
name|lfa_sts
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|elink_set_mdio_emac_per_phy
argument_list|(
name|sc
argument_list|,
name|params
argument_list|)
expr_stmt|;
comment|/* Sync the link parameters */
name|elink_link_status_update
argument_list|(
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
comment|/* 	 * The module verification was already done by previous link owner, 	 * so this call is meant only to get warning message 	 */
for|for
control|(
name|phy_idx
operator|=
name|ELINK_INT_PHY
init|;
name|phy_idx
operator|<
name|params
operator|->
name|num_phys
condition|;
name|phy_idx
operator|++
control|)
block|{
name|struct
name|elink_phy
modifier|*
name|phy
init|=
operator|&
name|params
operator|->
name|phy
index|[
name|phy_idx
index|]
decl_stmt|;
if|if
condition|(
name|phy
operator|->
name|phy_specific_func
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Calling PHY specific func\n"
argument_list|)
expr_stmt|;
name|phy
operator|->
name|phy_specific_func
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|ELINK_PHY_INIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|phy
operator|->
name|media_type
operator|==
name|ELINK_ETH_PHY_SFPP_10G_FIBER
operator|)
operator|||
operator|(
name|phy
operator|->
name|media_type
operator|==
name|ELINK_ETH_PHY_SFP_1G_FIBER
operator|)
operator|||
operator|(
name|phy
operator|->
name|media_type
operator|==
name|ELINK_ETH_PHY_DA_TWINAX
operator|)
condition|)
name|elink_verify_sfp_module
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
expr_stmt|;
block|}
name|lfa_sts
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|lfa_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_lfa
argument_list|,
name|lfa_sts
argument_list|)
argument_list|)
expr_stmt|;
name|dont_clear_stat
operator|=
name|lfa_sts
operator|&
name|SHMEM_LFA_DONT_CLEAR_STAT
expr_stmt|;
comment|/* Re-enable the NIG/MAC */
if|if
condition|(
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|dont_clear_stat
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_2_CLEAR
argument_list|,
operator|(
name|MISC_REGISTERS_RESET_REG_2_MSTAT0
operator|<<
name|params
operator|->
name|port
operator|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_2_SET
argument_list|,
operator|(
name|MISC_REGISTERS_RESET_REG_2_MSTAT0
operator|<<
name|params
operator|->
name|port
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vars
operator|->
name|line_speed
operator|<
name|ELINK_SPEED_10000
condition|)
name|elink_umac_enable
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|elink_xmac_enable
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|vars
operator|->
name|line_speed
operator|<
name|ELINK_SPEED_10000
condition|)
name|elink_emac_enable
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|elink_bmac_enable
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
literal|0
argument_list|,
operator|!
name|dont_clear_stat
argument_list|)
expr_stmt|;
block|}
comment|/* Increment LFA count */
name|lfa_sts
operator|=
operator|(
operator|(
name|lfa_sts
operator|&
operator|~
name|LINK_FLAP_AVOIDANCE_COUNT_MASK
operator|)
operator||
operator|(
operator|(
operator|(
operator|(
operator|(
name|lfa_sts
operator|&
name|LINK_FLAP_AVOIDANCE_COUNT_MASK
operator|)
operator|>>
name|LINK_FLAP_AVOIDANCE_COUNT_OFFSET
operator|)
operator|+
literal|1
operator|)
operator|&
literal|0xff
operator|)
operator|<<
name|LINK_FLAP_AVOIDANCE_COUNT_OFFSET
operator|)
operator|)
expr_stmt|;
comment|/* Clear link flap reason */
name|lfa_sts
operator|&=
operator|~
name|LFA_LINK_FLAP_REASON_MASK
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|lfa_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_lfa
argument_list|,
name|lfa_sts
argument_list|)
argument_list|,
name|lfa_sts
argument_list|)
expr_stmt|;
comment|/* Disable NIG DRAIN */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_EGRESS_DRAIN0_MODE
operator|+
name|params
operator|->
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Enable interrupts */
name|elink_link_int_enable
argument_list|(
name|params
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_cannot_avoid_link_flap
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|,
name|int
name|lfa_status
parameter_list|)
block|{
name|uint32_t
name|lfa_sts
decl_stmt|,
name|cfg_idx
decl_stmt|,
name|tmp_val
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|elink_link_reset
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|params
operator|->
name|lfa_base
condition|)
return|return;
comment|/* Store the new link parameters */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|lfa_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_lfa
argument_list|,
name|req_duplex
argument_list|)
argument_list|,
name|params
operator|->
name|req_duplex
index|[
literal|0
index|]
operator||
operator|(
name|params
operator|->
name|req_duplex
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|lfa_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_lfa
argument_list|,
name|req_flow_ctrl
argument_list|)
argument_list|,
name|params
operator|->
name|req_flow_ctrl
index|[
literal|0
index|]
operator||
operator|(
name|params
operator|->
name|req_flow_ctrl
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|lfa_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_lfa
argument_list|,
name|req_line_speed
argument_list|)
argument_list|,
name|params
operator|->
name|req_line_speed
index|[
literal|0
index|]
operator||
operator|(
name|params
operator|->
name|req_line_speed
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|cfg_idx
operator|=
literal|0
init|;
name|cfg_idx
operator|<
name|SHMEM_LINK_CONFIG_SIZE
condition|;
name|cfg_idx
operator|++
control|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|lfa_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_lfa
argument_list|,
name|speed_cap_mask
index|[
name|cfg_idx
index|]
argument_list|)
argument_list|,
name|params
operator|->
name|speed_cap_mask
index|[
name|cfg_idx
index|]
argument_list|)
expr_stmt|;
block|}
name|tmp_val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|lfa_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_lfa
argument_list|,
name|additional_config
argument_list|)
argument_list|)
expr_stmt|;
name|tmp_val
operator|&=
operator|~
name|REQ_FC_AUTO_ADV_MASK
expr_stmt|;
name|tmp_val
operator||=
name|params
operator|->
name|req_fc_auto_adv
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|lfa_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_lfa
argument_list|,
name|additional_config
argument_list|)
argument_list|,
name|tmp_val
argument_list|)
expr_stmt|;
name|lfa_sts
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|lfa_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_lfa
argument_list|,
name|lfa_sts
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Clear the "Don't Clear Statistics" bit, and set reason */
name|lfa_sts
operator|&=
operator|~
name|SHMEM_LFA_DONT_CLEAR_STAT
expr_stmt|;
comment|/* Set link flap reason */
name|lfa_sts
operator|&=
operator|~
name|LFA_LINK_FLAP_REASON_MASK
expr_stmt|;
name|lfa_sts
operator||=
operator|(
operator|(
name|lfa_status
operator|&
name|LFA_LINK_FLAP_REASON_MASK
operator|)
operator|<<
name|LFA_LINK_FLAP_REASON_OFFSET
operator|)
expr_stmt|;
comment|/* Increment link flap counter */
name|lfa_sts
operator|=
operator|(
operator|(
name|lfa_sts
operator|&
operator|~
name|LINK_FLAP_COUNT_MASK
operator|)
operator||
operator|(
operator|(
operator|(
operator|(
operator|(
name|lfa_sts
operator|&
name|LINK_FLAP_COUNT_MASK
operator|)
operator|>>
name|LINK_FLAP_COUNT_OFFSET
operator|)
operator|+
literal|1
operator|)
operator|&
literal|0xff
operator|)
operator|<<
name|LINK_FLAP_COUNT_OFFSET
operator|)
operator|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|lfa_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_lfa
argument_list|,
name|lfa_sts
argument_list|)
argument_list|,
name|lfa_sts
argument_list|)
expr_stmt|;
comment|/* Proceed with regular link initialization */
block|}
end_function

begin_function
name|elink_status_t
name|elink_phy_init
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|int
name|lfa_status
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Phy Initialization started\n"
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"(1) req_speed %d, req_flowctrl %d\n"
argument_list|,
name|params
operator|->
name|req_line_speed
index|[
literal|0
index|]
argument_list|,
name|params
operator|->
name|req_flow_ctrl
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"(2) req_speed %d, req_flowctrl %d\n"
argument_list|,
name|params
operator|->
name|req_line_speed
index|[
literal|1
index|]
argument_list|,
name|params
operator|->
name|req_flow_ctrl
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"req_adv_flow_ctrl 0x%x\n"
argument_list|,
name|params
operator|->
name|req_fc_auto_adv
argument_list|)
expr_stmt|;
name|vars
operator|->
name|link_status
operator|=
literal|0
expr_stmt|;
name|vars
operator|->
name|phy_link_up
operator|=
literal|0
expr_stmt|;
name|vars
operator|->
name|link_up
operator|=
literal|0
expr_stmt|;
name|vars
operator|->
name|line_speed
operator|=
literal|0
expr_stmt|;
name|vars
operator|->
name|duplex
operator|=
name|DUPLEX_FULL
expr_stmt|;
name|vars
operator|->
name|flow_ctrl
operator|=
name|ELINK_FLOW_CTRL_NONE
expr_stmt|;
name|vars
operator|->
name|mac_type
operator|=
name|ELINK_MAC_TYPE_NONE
expr_stmt|;
name|vars
operator|->
name|phy_flags
operator|=
literal|0
expr_stmt|;
name|vars
operator|->
name|check_kr2_recovery_cnt
operator|=
literal|0
expr_stmt|;
name|params
operator|->
name|link_flags
operator|=
name|ELINK_PHY_INITIALIZED
expr_stmt|;
comment|/* Driver opens NIG-BRB filters */
name|elink_set_rx_filter
argument_list|(
name|params
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|elink_chng_link_count
argument_list|(
name|params
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Check if link flap can be avoided */
name|lfa_status
operator|=
name|elink_check_lfa
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P3
argument_list|(
name|sc
argument_list|,
literal|" params : port = %x, loopback_mode = %x req_duplex = %x\n"
argument_list|,
name|params
operator|->
name|port
argument_list|,
name|params
operator|->
name|loopback_mode
argument_list|,
name|params
operator|->
name|req_duplex
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P3
argument_list|(
name|sc
argument_list|,
literal|" params : switch_cfg = %x, lane_config = %x req_duplex[1] = %x\n"
argument_list|,
name|params
operator|->
name|switch_cfg
argument_list|,
name|params
operator|->
name|lane_config
argument_list|,
name|params
operator|->
name|req_duplex
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P3
argument_list|(
name|sc
argument_list|,
literal|" params : chip_id = %x, feature_config_flags = %x, num_phys = %x\n"
argument_list|,
name|params
operator|->
name|chip_id
argument_list|,
name|params
operator|->
name|feature_config_flags
argument_list|,
name|params
operator|->
name|num_phys
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P3
argument_list|(
name|sc
argument_list|,
literal|" params : rsrv = %x, eee_mode = %x, hw_led_mode = x\n"
argument_list|,
name|params
operator|->
name|rsrv
argument_list|,
name|params
operator|->
name|eee_mode
argument_list|,
name|params
operator|->
name|hw_led_mode
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P3
argument_list|(
name|sc
argument_list|,
literal|" params : multi_phy = %x, req_fc_auto_adv = %x, link_flags = %x\n"
argument_list|,
name|params
operator|->
name|multi_phy_config
argument_list|,
name|params
operator|->
name|req_fc_auto_adv
argument_list|,
name|params
operator|->
name|link_flags
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|" params : lfa_base = %x, link_attr = %x\n"
argument_list|,
name|params
operator|->
name|lfa_base
argument_list|,
name|params
operator|->
name|link_attr_sync
argument_list|)
expr_stmt|;
if|if
condition|(
name|lfa_status
operator|==
literal|0
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Link Flap Avoidance in progress\n"
argument_list|)
expr_stmt|;
return|return
name|elink_avoid_link_flap
argument_list|(
name|params
argument_list|,
name|vars
argument_list|)
return|;
block|}
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Cannot avoid link flap lfa_sta=0x%x\n"
argument_list|,
name|lfa_status
argument_list|)
expr_stmt|;
name|elink_cannot_avoid_link_flap
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
name|lfa_status
argument_list|)
expr_stmt|;
comment|/* Disable attentions */
name|elink_bits_dis
argument_list|(
name|sc
argument_list|,
name|NIG_REG_MASK_INTERRUPT_PORT0
operator|+
name|params
operator|->
name|port
operator|*
literal|4
argument_list|,
operator|(
name|ELINK_NIG_MASK_XGXS0_LINK_STATUS
operator||
name|ELINK_NIG_MASK_XGXS0_LINK10G
operator||
name|ELINK_NIG_MASK_SERDES0_LINK_STATUS
operator||
name|ELINK_NIG_MASK_MI_INT
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ELINK_INCLUDE_EMUL
if|if
condition|(
operator|!
operator|(
name|params
operator|->
name|feature_config_flags
operator|&
name|ELINK_FEATURE_CONFIG_EMUL_DISABLE_EMAC
operator|)
condition|)
endif|#
directive|endif
name|elink_emac_init
argument_list|(
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|feature_config_flags
operator|&
name|ELINK_FEATURE_CONFIG_PFC_ENABLED
condition|)
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_PFC_ENABLED
expr_stmt|;
if|if
condition|(
operator|(
name|params
operator|->
name|num_phys
operator|==
literal|0
operator|)
operator|&&
operator|!
name|CHIP_REV_IS_SLOW
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"No phy found for initialization !!\n"
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
name|set_phy_vars
argument_list|(
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Num of phys on board: %d\n"
argument_list|,
name|params
operator|->
name|num_phys
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ELINK_INCLUDE_FPGA
if|if
condition|(
name|CHIP_REV_IS_FPGA
argument_list|(
name|sc
argument_list|)
condition|)
block|{
return|return
name|elink_init_fpga
argument_list|(
name|params
argument_list|,
name|vars
argument_list|)
return|;
block|}
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ELINK_INCLUDE_EMUL
if|if
condition|(
name|CHIP_REV_IS_EMUL
argument_list|(
name|sc
argument_list|)
condition|)
block|{
return|return
name|elink_init_emul
argument_list|(
name|params
argument_list|,
name|vars
argument_list|)
return|;
block|}
else|else
endif|#
directive|endif
switch|switch
condition|(
name|params
operator|->
name|loopback_mode
condition|)
block|{
case|case
name|ELINK_LOOPBACK_BMAC
case|:
name|elink_init_bmac_loopback
argument_list|(
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
break|break;
case|case
name|ELINK_LOOPBACK_EMAC
case|:
name|elink_init_emac_loopback
argument_list|(
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
break|break;
case|case
name|ELINK_LOOPBACK_XMAC
case|:
name|elink_init_xmac_loopback
argument_list|(
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
break|break;
case|case
name|ELINK_LOOPBACK_UMAC
case|:
name|elink_init_umac_loopback
argument_list|(
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
break|break;
case|case
name|ELINK_LOOPBACK_XGXS
case|:
case|case
name|ELINK_LOOPBACK_EXT_PHY
case|:
name|elink_init_xgxs_loopback
argument_list|(
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
block|{
if|if
condition|(
name|params
operator|->
name|switch_cfg
operator|==
name|ELINK_SWITCH_CFG_10G
condition|)
name|elink_xgxs_deassert
argument_list|(
name|params
argument_list|)
expr_stmt|;
else|else
name|elink_serdes_deassert
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|port
argument_list|)
expr_stmt|;
block|}
name|elink_link_initialize
argument_list|(
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
operator|*
literal|30
argument_list|)
expr_stmt|;
name|elink_link_int_enable
argument_list|(
name|params
argument_list|)
expr_stmt|;
break|break;
block|}
name|elink_update_mng
argument_list|(
name|params
argument_list|,
name|vars
operator|->
name|link_status
argument_list|)
expr_stmt|;
name|elink_update_mng_eee
argument_list|(
name|params
argument_list|,
name|vars
operator|->
name|eee_status
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
name|elink_status_t
name|elink_link_reset
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|,
name|uint8_t
name|reset_ext_phy
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint8_t
name|phy_index
decl_stmt|,
name|port
init|=
name|params
operator|->
name|port
decl_stmt|,
name|clear_latch_ind
init|=
literal|0
decl_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Resetting the link of port %d\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/* Disable attentions */
name|vars
operator|->
name|link_status
operator|=
literal|0
expr_stmt|;
name|elink_chng_link_count
argument_list|(
name|params
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|elink_update_mng
argument_list|(
name|params
argument_list|,
name|vars
operator|->
name|link_status
argument_list|)
expr_stmt|;
name|vars
operator|->
name|eee_status
operator|&=
operator|~
operator|(
name|SHMEM_EEE_LP_ADV_STATUS_MASK
operator||
name|SHMEM_EEE_ACTIVE_BIT
operator|)
expr_stmt|;
name|elink_update_mng_eee
argument_list|(
name|params
argument_list|,
name|vars
operator|->
name|eee_status
argument_list|)
expr_stmt|;
name|elink_bits_dis
argument_list|(
name|sc
argument_list|,
name|NIG_REG_MASK_INTERRUPT_PORT0
operator|+
name|port
operator|*
literal|4
argument_list|,
operator|(
name|ELINK_NIG_MASK_XGXS0_LINK_STATUS
operator||
name|ELINK_NIG_MASK_XGXS0_LINK10G
operator||
name|ELINK_NIG_MASK_SERDES0_LINK_STATUS
operator||
name|ELINK_NIG_MASK_MI_INT
operator|)
argument_list|)
expr_stmt|;
comment|/* Activate nig drain */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_EGRESS_DRAIN0_MODE
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Disable nig egress interface */
if|if
condition|(
operator|!
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_BMAC0_OUT_EN
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_EGRESS_EMAC0_OUT_EN
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ELINK_INCLUDE_EMUL
comment|/* Stop BigMac rx */
if|if
condition|(
operator|!
operator|(
name|params
operator|->
name|feature_config_flags
operator|&
name|ELINK_FEATURE_CONFIG_EMUL_DISABLE_BMAC
operator|)
condition|)
endif|#
directive|endif
if|if
condition|(
operator|!
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
name|elink_set_bmac_rx
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|chip_id
argument_list|,
name|port
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ELINK_INCLUDE_EMUL
comment|/* Stop XMAC/UMAC rx */
if|if
condition|(
operator|!
operator|(
name|params
operator|->
name|feature_config_flags
operator|&
name|ELINK_FEATURE_CONFIG_EMUL_DISABLE_XMAC
operator|)
condition|)
endif|#
directive|endif
if|if
condition|(
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
operator|&&
operator|!
name|CHIP_REV_IS_FPGA
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|elink_set_xmac_rxtx
argument_list|(
name|params
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|elink_set_umac_rxtx
argument_list|(
name|params
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Disable emac */
if|if
condition|(
operator|!
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_NIG_EMAC0_EN
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
operator|*
literal|10
argument_list|)
expr_stmt|;
comment|/* The PHY reset is controlled by GPIO 1 	 * Hold it as vars low 	 */
comment|/* Clear link led */
name|elink_set_mdio_emac_per_phy
argument_list|(
name|sc
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|elink_set_led
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
name|ELINK_LED_MODE_OFF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|reset_ext_phy
operator|&&
operator|(
operator|!
name|CHIP_REV_IS_SLOW
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
block|{
for|for
control|(
name|phy_index
operator|=
name|ELINK_EXT_PHY1
init|;
name|phy_index
operator|<
name|params
operator|->
name|num_phys
condition|;
name|phy_index
operator|++
control|)
block|{
if|if
condition|(
name|params
operator|->
name|phy
index|[
name|phy_index
index|]
operator|.
name|link_reset
condition|)
block|{
name|elink_set_aer_mmd
argument_list|(
name|params
argument_list|,
operator|&
name|params
operator|->
name|phy
index|[
name|phy_index
index|]
argument_list|)
expr_stmt|;
name|params
operator|->
name|phy
index|[
name|phy_index
index|]
operator|.
name|link_reset
argument_list|(
operator|&
name|params
operator|->
name|phy
index|[
name|phy_index
index|]
argument_list|,
name|params
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|params
operator|->
name|phy
index|[
name|phy_index
index|]
operator|.
name|flags
operator|&
name|ELINK_FLAGS_REARM_LATCH_SIGNAL
condition|)
name|clear_latch_ind
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|clear_latch_ind
condition|)
block|{
comment|/* Clear latching indication */
name|elink_rearm_latch_signal
argument_list|(
name|sc
argument_list|,
name|port
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|elink_bits_dis
argument_list|(
name|sc
argument_list|,
name|NIG_REG_LATCH_BC_0
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|1
operator|<<
name|ELINK_NIG_LATCH_BC_ENABLE_MI_INT
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|ELINK_INCLUDE_EMUL
argument_list|)
operator|||
name|defined
argument_list|(
name|ELINK_INCLUDE_FPGA
argument_list|)
if|if
condition|(
operator|!
name|CHIP_REV_IS_SLOW
argument_list|(
name|sc
argument_list|)
condition|)
endif|#
directive|endif
if|if
condition|(
name|params
operator|->
name|phy
index|[
name|ELINK_INT_PHY
index|]
operator|.
name|link_reset
condition|)
name|params
operator|->
name|phy
index|[
name|ELINK_INT_PHY
index|]
operator|.
name|link_reset
argument_list|(
operator|&
name|params
operator|->
name|phy
index|[
name|ELINK_INT_PHY
index|]
argument_list|,
name|params
argument_list|)
expr_stmt|;
comment|/* Disable nig ingress interface */
if|if
condition|(
operator|!
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* Reset BigMac */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|GRCBASE_MISC
operator|+
name|MISC_REGISTERS_RESET_REG_2_CLEAR
argument_list|,
operator|(
name|MISC_REGISTERS_RESET_REG_2_RST_BMAC0
operator|<<
name|port
operator|)
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_BMAC0_IN_EN
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_EMAC0_IN_EN
operator|+
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uint32_t
name|xmac_base
init|=
operator|(
name|params
operator|->
name|port
operator|)
condition|?
name|GRCBASE_XMAC1
else|:
name|GRCBASE_XMAC0
decl_stmt|;
name|elink_set_xumac_nig
argument_list|(
name|params
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_RESET_REG_2
argument_list|)
operator|&
name|MISC_REGISTERS_RESET_REG_2_XMAC
condition|)
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|xmac_base
operator|+
name|XMAC_REG_CTRL
argument_list|,
name|XMAC_CTRL_REG_SOFT_RESET
argument_list|)
expr_stmt|;
block|}
name|vars
operator|->
name|link_up
operator|=
literal|0
expr_stmt|;
name|vars
operator|->
name|phy_flags
operator|=
literal|0
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
name|elink_status_t
name|elink_lfa_reset
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|vars
operator|->
name|link_up
operator|=
literal|0
expr_stmt|;
name|vars
operator|->
name|phy_flags
operator|=
literal|0
expr_stmt|;
name|params
operator|->
name|link_flags
operator|&=
operator|~
name|ELINK_PHY_INITIALIZED
expr_stmt|;
if|if
condition|(
operator|!
name|params
operator|->
name|lfa_base
condition|)
return|return
name|elink_link_reset
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
literal|1
argument_list|)
return|;
comment|/* 	 * Activate NIG drain so that during this time the device won't send 	 * anything while it is unable to response. 	 */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_EGRESS_DRAIN0_MODE
operator|+
name|params
operator|->
name|port
operator|*
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Close gracefully the gate from BMAC to NIG such that no half packets 	 * are passed. 	 */
if|if
condition|(
operator|!
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
name|elink_set_bmac_rx
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|chip_id
argument_list|,
name|params
operator|->
name|port
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|elink_set_xmac_rxtx
argument_list|(
name|params
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|elink_set_umac_rxtx
argument_list|(
name|params
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Wait 10ms for the pipe to clean up*/
name|DELAY
argument_list|(
literal|1000
operator|*
literal|10
argument_list|)
expr_stmt|;
comment|/* Clean the NIG-BRB using the network filters in a way that will 	 * not cut a packet in the middle. 	 */
name|elink_set_rx_filter
argument_list|(
name|params
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Re-open the gate between the BMAC and the NIG, after verifying the 	 * gate to the BRB is closed, otherwise packets may arrive to the 	 * firmware before driver had initialized it. The target is to achieve 	 * minimum management protocol down time. 	 */
if|if
condition|(
operator|!
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
name|elink_set_bmac_rx
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|chip_id
argument_list|,
name|params
operator|->
name|port
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|elink_set_xmac_rxtx
argument_list|(
name|params
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|elink_set_umac_rxtx
argument_list|(
name|params
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Disable NIG drain */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_EGRESS_DRAIN0_MODE
operator|+
name|params
operator|->
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/*				Common function				    */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_function
specifier|static
name|elink_status_t
name|elink_8073_common_init_phy
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|shmem_base_path
index|[]
parameter_list|,
name|uint32_t
name|shmem2_base_path
index|[]
parameter_list|,
name|uint8_t
name|phy_index
parameter_list|,
name|uint32_t
name|chip_id
parameter_list|)
block|{
name|struct
name|elink_phy
name|phy
index|[
name|PORT_MAX
index|]
decl_stmt|;
name|struct
name|elink_phy
modifier|*
name|phy_blk
index|[
name|PORT_MAX
index|]
decl_stmt|;
name|uint16_t
name|val
decl_stmt|;
name|int8_t
name|port
init|=
literal|0
decl_stmt|;
name|int8_t
name|port_of_path
init|=
literal|0
decl_stmt|;
name|uint32_t
name|swap_val
decl_stmt|,
name|swap_override
decl_stmt|;
name|swap_val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_PORT_SWAP
argument_list|)
expr_stmt|;
name|swap_override
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_STRAP_OVERRIDE
argument_list|)
expr_stmt|;
name|port
operator|^=
operator|(
name|swap_val
operator|&&
name|swap_override
operator|)
expr_stmt|;
name|elink_ext_phy_hw_reset
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/* PART1 - Reset both phys */
for|for
control|(
name|port
operator|=
name|PORT_MAX
operator|-
literal|1
init|;
name|port
operator|>=
name|PORT_0
condition|;
name|port
operator|--
control|)
block|{
name|uint32_t
name|shmem_base
decl_stmt|,
name|shmem2_base
decl_stmt|;
comment|/* In E2, same phy is using for port0 of the two paths */
if|if
condition|(
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|shmem_base
operator|=
name|shmem_base_path
index|[
literal|0
index|]
expr_stmt|;
name|shmem2_base
operator|=
name|shmem2_base_path
index|[
literal|0
index|]
expr_stmt|;
name|port_of_path
operator|=
name|port
expr_stmt|;
block|}
else|else
block|{
name|shmem_base
operator|=
name|shmem_base_path
index|[
name|port
index|]
expr_stmt|;
name|shmem2_base
operator|=
name|shmem2_base_path
index|[
name|port
index|]
expr_stmt|;
name|port_of_path
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Extract the ext phy address for the port */
if|if
condition|(
name|elink_populate_phy
argument_list|(
name|sc
argument_list|,
name|phy_index
argument_list|,
name|shmem_base
argument_list|,
name|shmem2_base
argument_list|,
name|port_of_path
argument_list|,
operator|&
name|phy
index|[
name|port
index|]
argument_list|)
operator|!=
name|ELINK_STATUS_OK
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"populate_phy failed\n"
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
comment|/* Disable attentions */
name|elink_bits_dis
argument_list|(
name|sc
argument_list|,
name|NIG_REG_MASK_INTERRUPT_PORT0
operator|+
name|port_of_path
operator|*
literal|4
argument_list|,
operator|(
name|ELINK_NIG_MASK_XGXS0_LINK_STATUS
operator||
name|ELINK_NIG_MASK_XGXS0_LINK10G
operator||
name|ELINK_NIG_MASK_SERDES0_LINK_STATUS
operator||
name|ELINK_NIG_MASK_MI_INT
operator|)
argument_list|)
expr_stmt|;
comment|/* Need to take the phy out of low power mode in order 		 * to write to access its registers 		 */
name|elink_cb_gpio_write
argument_list|(
name|sc
argument_list|,
name|MISC_REGISTERS_GPIO_2
argument_list|,
name|MISC_REGISTERS_GPIO_OUTPUT_HIGH
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/* Reset the phy */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
operator|&
name|phy
index|[
name|port
index|]
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_CTRL
argument_list|,
literal|1
operator|<<
literal|15
argument_list|)
expr_stmt|;
block|}
comment|/* Add delay of 150ms after reset */
name|DELAY
argument_list|(
literal|1000
operator|*
literal|150
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
index|[
name|PORT_0
index|]
operator|.
name|addr
operator|&
literal|0x1
condition|)
block|{
name|phy_blk
index|[
name|PORT_0
index|]
operator|=
operator|&
operator|(
name|phy
index|[
name|PORT_1
index|]
operator|)
expr_stmt|;
name|phy_blk
index|[
name|PORT_1
index|]
operator|=
operator|&
operator|(
name|phy
index|[
name|PORT_0
index|]
operator|)
expr_stmt|;
block|}
else|else
block|{
name|phy_blk
index|[
name|PORT_0
index|]
operator|=
operator|&
operator|(
name|phy
index|[
name|PORT_0
index|]
operator|)
expr_stmt|;
name|phy_blk
index|[
name|PORT_1
index|]
operator|=
operator|&
operator|(
name|phy
index|[
name|PORT_1
index|]
operator|)
expr_stmt|;
block|}
comment|/* PART2 - Download firmware to both phys */
for|for
control|(
name|port
operator|=
name|PORT_MAX
operator|-
literal|1
init|;
name|port
operator|>=
name|PORT_0
condition|;
name|port
operator|--
control|)
block|{
if|if
condition|(
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
name|port_of_path
operator|=
name|port
expr_stmt|;
else|else
name|port_of_path
operator|=
literal|0
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Loading spirom for phy address 0x%x\n"
argument_list|,
name|phy_blk
index|[
name|port
index|]
operator|->
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|elink_8073_8727_external_rom_boot
argument_list|(
name|sc
argument_list|,
name|phy_blk
index|[
name|port
index|]
argument_list|,
name|port_of_path
argument_list|)
condition|)
return|return
name|ELINK_STATUS_ERROR
return|;
comment|/* Only set bit 10 = 1 (Tx power down) */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy_blk
index|[
name|port
index|]
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_TX_POWER_DOWN
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
comment|/* Phase1 of TX_POWER_DOWN reset */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy_blk
index|[
name|port
index|]
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_TX_POWER_DOWN
argument_list|,
operator|(
name|val
operator||
literal|1
operator|<<
literal|10
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Toggle Transmitter: Power down and then up with 600ms delay 	 * between 	 */
name|DELAY
argument_list|(
literal|1000
operator|*
literal|600
argument_list|)
expr_stmt|;
comment|/* PART3 - complete TX_POWER_DOWN process, and set GPIO2 back to low */
for|for
control|(
name|port
operator|=
name|PORT_MAX
operator|-
literal|1
init|;
name|port
operator|>=
name|PORT_0
condition|;
name|port
operator|--
control|)
block|{
comment|/* Phase2 of POWER_DOWN_RESET */
comment|/* Release bit 10 (Release Tx power down) */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy_blk
index|[
name|port
index|]
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_TX_POWER_DOWN
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy_blk
index|[
name|port
index|]
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_TX_POWER_DOWN
argument_list|,
operator|(
name|val
operator|&
operator|(
operator|~
operator|(
literal|1
operator|<<
literal|10
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
operator|*
literal|15
argument_list|)
expr_stmt|;
comment|/* Read modify write the SPI-ROM version select register */
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy_blk
index|[
name|port
index|]
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_EDC_FFE_MAIN
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy_blk
index|[
name|port
index|]
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_EDC_FFE_MAIN
argument_list|,
operator|(
name|val
operator||
operator|(
literal|1
operator|<<
literal|12
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* set GPIO2 back to LOW */
name|elink_cb_gpio_write
argument_list|(
name|sc
argument_list|,
name|MISC_REGISTERS_GPIO_2
argument_list|,
name|MISC_REGISTERS_GPIO_OUTPUT_LOW
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_8726_common_init_phy
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|shmem_base_path
index|[]
parameter_list|,
name|uint32_t
name|shmem2_base_path
index|[]
parameter_list|,
name|uint8_t
name|phy_index
parameter_list|,
name|uint32_t
name|chip_id
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|int8_t
name|port
decl_stmt|;
name|struct
name|elink_phy
name|phy
decl_stmt|;
comment|/* Use port1 because of the static port-swap */
comment|/* Enable the module detection interrupt */
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_GPIO_EVENT_EN
argument_list|)
expr_stmt|;
name|val
operator||=
operator|(
operator|(
literal|1
operator|<<
name|MISC_REGISTERS_GPIO_3
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|MISC_REGISTERS_GPIO_3
operator|+
name|MISC_REGISTERS_GPIO_PORT_SHIFT
operator|)
operator|)
operator|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_GPIO_EVENT_EN
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|elink_ext_phy_hw_reset
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
operator|*
literal|5
argument_list|)
expr_stmt|;
for|for
control|(
name|port
operator|=
literal|0
init|;
name|port
operator|<
name|PORT_MAX
condition|;
name|port
operator|++
control|)
block|{
name|uint32_t
name|shmem_base
decl_stmt|,
name|shmem2_base
decl_stmt|;
comment|/* In E2, same phy is using for port0 of the two paths */
if|if
condition|(
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|shmem_base
operator|=
name|shmem_base_path
index|[
literal|0
index|]
expr_stmt|;
name|shmem2_base
operator|=
name|shmem2_base_path
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|shmem_base
operator|=
name|shmem_base_path
index|[
name|port
index|]
expr_stmt|;
name|shmem2_base
operator|=
name|shmem2_base_path
index|[
name|port
index|]
expr_stmt|;
block|}
comment|/* Extract the ext phy address for the port */
if|if
condition|(
name|elink_populate_phy
argument_list|(
name|sc
argument_list|,
name|phy_index
argument_list|,
name|shmem_base
argument_list|,
name|shmem2_base
argument_list|,
name|port
argument_list|,
operator|&
name|phy
argument_list|)
operator|!=
name|ELINK_STATUS_OK
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"populate phy failed\n"
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
comment|/* Reset phy*/
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
operator|&
name|phy
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_GEN_CTRL
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
comment|/* Set fault module detected LED on */
name|elink_cb_gpio_write
argument_list|(
name|sc
argument_list|,
name|MISC_REGISTERS_GPIO_0
argument_list|,
name|MISC_REGISTERS_GPIO_HIGH
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_get_ext_phy_reset_gpio
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|shmem_base
parameter_list|,
name|uint8_t
modifier|*
name|io_gpio
parameter_list|,
name|uint8_t
modifier|*
name|io_port
parameter_list|)
block|{
name|uint32_t
name|phy_gpio_reset
init|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|PORT_0
index|]
operator|.
name|default_cfg
argument_list|)
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|phy_gpio_reset
condition|)
block|{
case|case
name|PORT_HW_CFG_EXT_PHY_GPIO_RST_GPIO0_P0
case|:
operator|*
name|io_gpio
operator|=
literal|0
expr_stmt|;
operator|*
name|io_port
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_EXT_PHY_GPIO_RST_GPIO1_P0
case|:
operator|*
name|io_gpio
operator|=
literal|1
expr_stmt|;
operator|*
name|io_port
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_EXT_PHY_GPIO_RST_GPIO2_P0
case|:
operator|*
name|io_gpio
operator|=
literal|2
expr_stmt|;
operator|*
name|io_port
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_EXT_PHY_GPIO_RST_GPIO3_P0
case|:
operator|*
name|io_gpio
operator|=
literal|3
expr_stmt|;
operator|*
name|io_port
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_EXT_PHY_GPIO_RST_GPIO0_P1
case|:
operator|*
name|io_gpio
operator|=
literal|0
expr_stmt|;
operator|*
name|io_port
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_EXT_PHY_GPIO_RST_GPIO1_P1
case|:
operator|*
name|io_gpio
operator|=
literal|1
expr_stmt|;
operator|*
name|io_port
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_EXT_PHY_GPIO_RST_GPIO2_P1
case|:
operator|*
name|io_gpio
operator|=
literal|2
expr_stmt|;
operator|*
name|io_port
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_EXT_PHY_GPIO_RST_GPIO3_P1
case|:
operator|*
name|io_gpio
operator|=
literal|3
expr_stmt|;
operator|*
name|io_port
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* Don't override the io_gpio and io_port */
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_8727_common_init_phy
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|shmem_base_path
index|[]
parameter_list|,
name|uint32_t
name|shmem2_base_path
index|[]
parameter_list|,
name|uint8_t
name|phy_index
parameter_list|,
name|uint32_t
name|chip_id
parameter_list|)
block|{
name|int8_t
name|port
decl_stmt|,
name|reset_gpio
decl_stmt|;
name|uint32_t
name|swap_val
decl_stmt|,
name|swap_override
decl_stmt|;
name|struct
name|elink_phy
name|phy
index|[
name|PORT_MAX
index|]
decl_stmt|;
name|struct
name|elink_phy
modifier|*
name|phy_blk
index|[
name|PORT_MAX
index|]
decl_stmt|;
name|int8_t
name|port_of_path
decl_stmt|;
name|swap_val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_PORT_SWAP
argument_list|)
expr_stmt|;
name|swap_override
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_STRAP_OVERRIDE
argument_list|)
expr_stmt|;
name|reset_gpio
operator|=
name|MISC_REGISTERS_GPIO_1
expr_stmt|;
name|port
operator|=
literal|1
expr_stmt|;
comment|/* Retrieve the reset gpio/port which control the reset. 	 * Default is GPIO1, PORT1 	 */
name|elink_get_ext_phy_reset_gpio
argument_list|(
name|sc
argument_list|,
name|shmem_base_path
index|[
literal|0
index|]
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|reset_gpio
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|port
argument_list|)
expr_stmt|;
comment|/* Calculate the port based on port swap */
name|port
operator|^=
operator|(
name|swap_val
operator|&&
name|swap_override
operator|)
expr_stmt|;
comment|/* Initiate PHY reset*/
name|elink_cb_gpio_write
argument_list|(
name|sc
argument_list|,
name|reset_gpio
argument_list|,
name|MISC_REGISTERS_GPIO_OUTPUT_LOW
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
operator|*
literal|1
argument_list|)
expr_stmt|;
name|elink_cb_gpio_write
argument_list|(
name|sc
argument_list|,
name|reset_gpio
argument_list|,
name|MISC_REGISTERS_GPIO_OUTPUT_HIGH
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
operator|*
literal|5
argument_list|)
expr_stmt|;
comment|/* PART1 - Reset both phys */
for|for
control|(
name|port
operator|=
name|PORT_MAX
operator|-
literal|1
init|;
name|port
operator|>=
name|PORT_0
condition|;
name|port
operator|--
control|)
block|{
name|uint32_t
name|shmem_base
decl_stmt|,
name|shmem2_base
decl_stmt|;
comment|/* In E2, same phy is using for port0 of the two paths */
if|if
condition|(
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|shmem_base
operator|=
name|shmem_base_path
index|[
literal|0
index|]
expr_stmt|;
name|shmem2_base
operator|=
name|shmem2_base_path
index|[
literal|0
index|]
expr_stmt|;
name|port_of_path
operator|=
name|port
expr_stmt|;
block|}
else|else
block|{
name|shmem_base
operator|=
name|shmem_base_path
index|[
name|port
index|]
expr_stmt|;
name|shmem2_base
operator|=
name|shmem2_base_path
index|[
name|port
index|]
expr_stmt|;
name|port_of_path
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Extract the ext phy address for the port */
if|if
condition|(
name|elink_populate_phy
argument_list|(
name|sc
argument_list|,
name|phy_index
argument_list|,
name|shmem_base
argument_list|,
name|shmem2_base
argument_list|,
name|port_of_path
argument_list|,
operator|&
name|phy
index|[
name|port
index|]
argument_list|)
operator|!=
name|ELINK_STATUS_OK
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"populate phy failed\n"
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_ERROR
return|;
block|}
comment|/* disable attentions */
name|elink_bits_dis
argument_list|(
name|sc
argument_list|,
name|NIG_REG_MASK_INTERRUPT_PORT0
operator|+
name|port_of_path
operator|*
literal|4
argument_list|,
operator|(
name|ELINK_NIG_MASK_XGXS0_LINK_STATUS
operator||
name|ELINK_NIG_MASK_XGXS0_LINK10G
operator||
name|ELINK_NIG_MASK_SERDES0_LINK_STATUS
operator||
name|ELINK_NIG_MASK_MI_INT
operator|)
argument_list|)
expr_stmt|;
comment|/* Reset the phy */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
operator|&
name|phy
index|[
name|port
index|]
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_CTRL
argument_list|,
literal|1
operator|<<
literal|15
argument_list|)
expr_stmt|;
block|}
comment|/* Add delay of 150ms after reset */
name|DELAY
argument_list|(
literal|1000
operator|*
literal|150
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
index|[
name|PORT_0
index|]
operator|.
name|addr
operator|&
literal|0x1
condition|)
block|{
name|phy_blk
index|[
name|PORT_0
index|]
operator|=
operator|&
operator|(
name|phy
index|[
name|PORT_1
index|]
operator|)
expr_stmt|;
name|phy_blk
index|[
name|PORT_1
index|]
operator|=
operator|&
operator|(
name|phy
index|[
name|PORT_0
index|]
operator|)
expr_stmt|;
block|}
else|else
block|{
name|phy_blk
index|[
name|PORT_0
index|]
operator|=
operator|&
operator|(
name|phy
index|[
name|PORT_0
index|]
operator|)
expr_stmt|;
name|phy_blk
index|[
name|PORT_1
index|]
operator|=
operator|&
operator|(
name|phy
index|[
name|PORT_1
index|]
operator|)
expr_stmt|;
block|}
comment|/* PART2 - Download firmware to both phys */
for|for
control|(
name|port
operator|=
name|PORT_MAX
operator|-
literal|1
init|;
name|port
operator|>=
name|PORT_0
condition|;
name|port
operator|--
control|)
block|{
if|if
condition|(
name|CHIP_IS_E1x
argument_list|(
name|sc
argument_list|)
condition|)
name|port_of_path
operator|=
name|port
expr_stmt|;
else|else
name|port_of_path
operator|=
literal|0
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Loading spirom for phy address 0x%x\n"
argument_list|,
name|phy_blk
index|[
name|port
index|]
operator|->
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|elink_8073_8727_external_rom_boot
argument_list|(
name|sc
argument_list|,
name|phy_blk
index|[
name|port
index|]
argument_list|,
name|port_of_path
argument_list|)
condition|)
return|return
name|ELINK_STATUS_ERROR
return|;
comment|/* Disable PHY transmitter output */
name|elink_cl45_write
argument_list|(
name|sc
argument_list|,
name|phy_blk
index|[
name|port
index|]
argument_list|,
name|MDIO_PMA_DEVAD
argument_list|,
name|MDIO_PMA_REG_TX_DISABLE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_84833_common_init_phy
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|shmem_base_path
index|[]
parameter_list|,
name|uint32_t
name|shmem2_base_path
index|[]
parameter_list|,
name|uint8_t
name|phy_index
parameter_list|,
name|uint32_t
name|chip_id
parameter_list|)
block|{
name|uint8_t
name|reset_gpios
decl_stmt|;
name|reset_gpios
operator|=
name|elink_84833_get_reset_gpios
argument_list|(
name|sc
argument_list|,
name|shmem_base_path
argument_list|,
name|chip_id
argument_list|)
expr_stmt|;
name|elink_cb_gpio_mult_write
argument_list|(
name|sc
argument_list|,
name|reset_gpios
argument_list|,
name|MISC_REGISTERS_GPIO_OUTPUT_LOW
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|elink_cb_gpio_mult_write
argument_list|(
name|sc
argument_list|,
name|reset_gpios
argument_list|,
name|MISC_REGISTERS_GPIO_OUTPUT_HIGH
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"84833 reset pulse on pin values 0x%x\n"
argument_list|,
name|reset_gpios
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|static
name|elink_status_t
name|elink_ext_phy_common_init
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|shmem_base_path
index|[]
parameter_list|,
name|uint32_t
name|shmem2_base_path
index|[]
parameter_list|,
name|uint8_t
name|phy_index
parameter_list|,
name|uint32_t
name|ext_phy_type
parameter_list|,
name|uint32_t
name|chip_id
parameter_list|)
block|{
name|elink_status_t
name|rc
init|=
name|ELINK_STATUS_OK
decl_stmt|;
switch|switch
condition|(
name|ext_phy_type
condition|)
block|{
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073
case|:
name|rc
operator|=
name|elink_8073_common_init_phy
argument_list|(
name|sc
argument_list|,
name|shmem_base_path
argument_list|,
name|shmem2_base_path
argument_list|,
name|phy_index
argument_list|,
name|chip_id
argument_list|)
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8722
case|:
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727
case|:
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727_NOC
case|:
name|rc
operator|=
name|elink_8727_common_init_phy
argument_list|(
name|sc
argument_list|,
name|shmem_base_path
argument_list|,
name|shmem2_base_path
argument_list|,
name|phy_index
argument_list|,
name|chip_id
argument_list|)
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726
case|:
comment|/* GPIO1 affects both ports, so there's need to pull 		 * it for single port alone 		 */
name|rc
operator|=
name|elink_8726_common_init_phy
argument_list|(
name|sc
argument_list|,
name|shmem_base_path
argument_list|,
name|shmem2_base_path
argument_list|,
name|phy_index
argument_list|,
name|chip_id
argument_list|)
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84833
case|:
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84834
case|:
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84858
case|:
comment|/* GPIO3's are linked, and so both need to be toggled 		 * to obtain required 2us pulse. 		 */
name|rc
operator|=
name|elink_84833_common_init_phy
argument_list|(
name|sc
argument_list|,
name|shmem_base_path
argument_list|,
name|shmem2_base_path
argument_list|,
name|phy_index
argument_list|,
name|chip_id
argument_list|)
expr_stmt|;
break|break;
case|case
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_FAILURE
case|:
name|rc
operator|=
name|ELINK_STATUS_ERROR
expr_stmt|;
break|break;
default|default:
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"ext_phy 0x%x common init not required\n"
argument_list|,
name|ext_phy_type
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rc
operator|!=
name|ELINK_STATUS_OK
condition|)
name|elink_cb_event_log
argument_list|(
name|sc
argument_list|,
name|ELINK_LOG_ID_PHY_UNINITIALIZED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// "Warning: PHY was not initialized,"
comment|// " Port %d\n",
return|return
name|rc
return|;
block|}
end_function

begin_function
name|elink_status_t
name|elink_common_init_phy
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|shmem_base_path
index|[]
parameter_list|,
name|uint32_t
name|shmem2_base_path
index|[]
parameter_list|,
name|uint32_t
name|chip_id
parameter_list|,
name|uint8_t
name|one_port_enabled
parameter_list|)
block|{
name|elink_status_t
name|rc
init|=
name|ELINK_STATUS_OK
decl_stmt|;
name|uint32_t
name|phy_ver
decl_stmt|,
name|val
decl_stmt|;
name|uint8_t
name|phy_index
init|=
literal|0
decl_stmt|;
name|uint32_t
name|ext_phy_type
decl_stmt|,
name|ext_phy_config
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ELINK_INCLUDE_EMUL
argument_list|)
operator|||
name|defined
argument_list|(
name|ELINK_INCLUDE_FPGA
argument_list|)
if|if
condition|(
name|CHIP_REV_IS_EMUL
argument_list|(
name|sc
argument_list|)
operator|||
name|CHIP_REV_IS_FPGA
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|ELINK_STATUS_OK
return|;
endif|#
directive|endif
name|elink_set_mdio_clk
argument_list|(
name|sc
argument_list|,
name|chip_id
argument_list|,
name|GRCBASE_EMAC0
argument_list|)
expr_stmt|;
name|elink_set_mdio_clk
argument_list|(
name|sc
argument_list|,
name|chip_id
argument_list|,
name|GRCBASE_EMAC1
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Begin common phy init\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* Enable EPIO */
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_GEN_PURP_HWG
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_GEN_PURP_HWG
argument_list|,
name|val
operator||
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Check if common init was already done */
name|phy_ver
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|shmem_base_path
index|[
literal|0
index|]
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|port_mb
index|[
name|PORT_0
index|]
operator|.
name|ext_phy_fw_version
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_ver
condition|)
block|{
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Not doing common init; phy ver is 0x%x\n"
argument_list|,
name|phy_ver
argument_list|)
expr_stmt|;
return|return
name|ELINK_STATUS_OK
return|;
block|}
comment|/* Read the ext_phy_type for arbitrary port(0) */
for|for
control|(
name|phy_index
operator|=
name|ELINK_EXT_PHY1
init|;
name|phy_index
operator|<
name|ELINK_MAX_PHYS
condition|;
name|phy_index
operator|++
control|)
block|{
name|ext_phy_config
operator|=
name|elink_get_ext_phy_config
argument_list|(
name|sc
argument_list|,
name|shmem_base_path
index|[
literal|0
index|]
argument_list|,
name|phy_index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ext_phy_type
operator|=
name|ELINK_XGXS_EXT_PHY_TYPE
argument_list|(
name|ext_phy_config
argument_list|)
expr_stmt|;
name|rc
operator||=
name|elink_ext_phy_common_init
argument_list|(
name|sc
argument_list|,
name|shmem_base_path
argument_list|,
name|shmem2_base_path
argument_list|,
name|phy_index
argument_list|,
name|ext_phy_type
argument_list|,
name|chip_id
argument_list|)
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_check_over_curr
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint32_t
name|cfg_pin
decl_stmt|;
name|uint8_t
name|port
init|=
name|params
operator|->
name|port
decl_stmt|;
name|uint32_t
name|pin_val
decl_stmt|;
name|cfg_pin
operator|=
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|port
index|]
operator|.
name|e3_cmn_pin_cfg1
argument_list|)
argument_list|)
operator|&
name|PORT_HW_CFG_E3_OVER_CURRENT_MASK
operator|)
operator|>>
name|PORT_HW_CFG_E3_OVER_CURRENT_SHIFT
expr_stmt|;
comment|/* Ignore check if no external input PIN available */
if|if
condition|(
name|elink_get_cfg_pin
argument_list|(
name|sc
argument_list|,
name|cfg_pin
argument_list|,
operator|&
name|pin_val
argument_list|)
operator|!=
name|ELINK_STATUS_OK
condition|)
return|return;
if|if
condition|(
operator|!
name|pin_val
condition|)
block|{
if|if
condition|(
operator|(
name|vars
operator|->
name|phy_flags
operator|&
name|PHY_OVER_CURRENT_FLAG
operator|)
operator|==
literal|0
condition|)
block|{
name|elink_cb_event_log
argument_list|(
name|sc
argument_list|,
name|ELINK_LOG_ID_OVER_CURRENT
argument_list|,
name|params
operator|->
name|port
argument_list|)
expr_stmt|;
comment|//"Error:  Power fault on Port %d has"
comment|//  " been detected and the power to "
comment|//  "that SFP+ module has been removed"
comment|//  " to prevent failure of the card."
comment|//  " Please remove the SFP+ module and"
comment|//  " restart the system to clear this"
comment|//  " error.\n",
name|vars
operator|->
name|phy_flags
operator||=
name|PHY_OVER_CURRENT_FLAG
expr_stmt|;
name|elink_warpcore_power_module
argument_list|(
name|params
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|vars
operator|->
name|phy_flags
operator|&=
operator|~
name|PHY_OVER_CURRENT_FLAG
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns 0 if no change occurred since last check; 1 otherwise. */
end_comment

begin_function
specifier|static
name|uint8_t
name|elink_analyze_link_error
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|,
name|uint32_t
name|status
parameter_list|,
name|uint32_t
name|phy_flag
parameter_list|,
name|uint32_t
name|link_flag
parameter_list|,
name|uint8_t
name|notify
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
comment|/* Compare new value with previous value */
name|uint8_t
name|led_mode
decl_stmt|;
name|uint32_t
name|old_status
init|=
operator|(
name|vars
operator|->
name|phy_flags
operator|&
name|phy_flag
operator|)
condition|?
literal|1
else|:
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|status
operator|^
name|old_status
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If values differ */
switch|switch
condition|(
name|phy_flag
condition|)
block|{
case|case
name|PHY_HALF_OPEN_CONN_FLAG
case|:
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Analyze Remote Fault\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PHY_SFP_TX_FAULT_FLAG
case|:
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Analyze TX Fault\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Analyze UNKNOWN\n"
argument_list|)
expr_stmt|;
block|}
name|ELINK_DEBUG_P3
argument_list|(
name|sc
argument_list|,
literal|"Link changed:[%x %x]->%x\n"
argument_list|,
name|vars
operator|->
name|link_up
argument_list|,
name|old_status
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* Do not touch the link in case physical link down */
if|if
condition|(
operator|(
name|vars
operator|->
name|phy_flags
operator|&
name|PHY_PHYSICAL_LINK_FLAG
operator|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* a. Update shmem->link_status accordingly 	 * b. Update elink_vars->link_up 	 */
if|if
condition|(
name|status
condition|)
block|{
name|vars
operator|->
name|link_status
operator|&=
operator|~
name|LINK_STATUS_LINK_UP
expr_stmt|;
name|vars
operator|->
name|link_status
operator||=
name|link_flag
expr_stmt|;
name|vars
operator|->
name|link_up
operator|=
literal|0
expr_stmt|;
name|vars
operator|->
name|phy_flags
operator||=
name|phy_flag
expr_stmt|;
comment|/* activate nig drain */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_EGRESS_DRAIN0_MODE
operator|+
name|params
operator|->
name|port
operator|*
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Set LED mode to off since the PHY doesn't know about these 		 * errors 		 */
name|led_mode
operator|=
name|ELINK_LED_MODE_OFF
expr_stmt|;
block|}
else|else
block|{
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_LINK_UP
expr_stmt|;
name|vars
operator|->
name|link_status
operator|&=
operator|~
name|link_flag
expr_stmt|;
name|vars
operator|->
name|link_up
operator|=
literal|1
expr_stmt|;
name|vars
operator|->
name|phy_flags
operator|&=
operator|~
name|phy_flag
expr_stmt|;
name|led_mode
operator|=
name|ELINK_LED_MODE_OPER
expr_stmt|;
comment|/* Clear nig drain */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|NIG_REG_EGRESS_DRAIN0_MODE
operator|+
name|params
operator|->
name|port
operator|*
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|elink_sync_link
argument_list|(
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
comment|/* Update the LED according to the link state */
name|elink_set_led
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
name|led_mode
argument_list|,
name|ELINK_SPEED_10000
argument_list|)
expr_stmt|;
comment|/* Update link status in the shared memory */
name|elink_update_mng
argument_list|(
name|params
argument_list|,
name|vars
operator|->
name|link_status
argument_list|)
expr_stmt|;
comment|/* C. Trigger General Attention */
name|vars
operator|->
name|periodic_flags
operator||=
name|ELINK_PERIODIC_FLAGS_LINK_EVENT
expr_stmt|;
if|if
condition|(
name|notify
condition|)
name|elink_cb_notify_link_changed
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************** * Description: *	This function checks for half opened connection change indication. *	When such change occurs, it calls the elink_analyze_link_error *	to check if Remote Fault is set or cleared. Reception of remote fault *	status message in the MAC indicates that the peer's MAC has detected *	a fault, for example, due to break in the TX side of fiber. * ******************************************************************************/
end_comment

begin_function
specifier|static
name|elink_status_t
name|elink_check_half_open_conn
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|,
name|uint8_t
name|notify
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint32_t
name|lss_status
init|=
literal|0
decl_stmt|;
name|uint32_t
name|mac_base
decl_stmt|;
comment|/* In case link status is physically up @ 10G do */
if|if
condition|(
operator|(
operator|(
name|vars
operator|->
name|phy_flags
operator|&
name|PHY_PHYSICAL_LINK_FLAG
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_EGRESS_EMAC0_PORT
operator|+
name|params
operator|->
name|port
operator|*
literal|4
argument_list|)
operator|)
condition|)
return|return
name|ELINK_STATUS_OK
return|;
if|if
condition|(
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
operator|&&
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_RESET_REG_2
argument_list|)
operator|&
operator|(
name|MISC_REGISTERS_RESET_REG_2_XMAC
operator|)
operator|)
condition|)
block|{
comment|/* Check E3 XMAC */
comment|/* Note that link speed cannot be queried here, since it may be 		 * zero while link is down. In case UMAC is active, LSS will 		 * simply not be set 		 */
name|mac_base
operator|=
operator|(
name|params
operator|->
name|port
operator|)
condition|?
name|GRCBASE_XMAC1
else|:
name|GRCBASE_XMAC0
expr_stmt|;
comment|/* Clear stick bits (Requires rising edge) */
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|mac_base
operator|+
name|XMAC_REG_CLEAR_RX_LSS_STATUS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|mac_base
operator|+
name|XMAC_REG_CLEAR_RX_LSS_STATUS
argument_list|,
name|XMAC_CLEAR_RX_LSS_STATUS_REG_CLEAR_LOCAL_FAULT_STATUS
operator||
name|XMAC_CLEAR_RX_LSS_STATUS_REG_CLEAR_REMOTE_FAULT_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|mac_base
operator|+
name|XMAC_REG_RX_LSS_STATUS
argument_list|)
condition|)
name|lss_status
operator|=
literal|1
expr_stmt|;
name|elink_analyze_link_error
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
name|lss_status
argument_list|,
name|PHY_HALF_OPEN_CONN_FLAG
argument_list|,
name|LINK_STATUS_NONE
argument_list|,
name|notify
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_RESET_REG_2
argument_list|)
operator|&
operator|(
name|MISC_REGISTERS_RESET_REG_2_RST_BMAC0
operator|<<
name|params
operator|->
name|port
operator|)
condition|)
block|{
comment|/* Check E1X / E2 BMAC */
name|uint32_t
name|lss_status_reg
decl_stmt|;
name|uint32_t
name|wb_data
index|[
literal|2
index|]
decl_stmt|;
name|mac_base
operator|=
name|params
operator|->
name|port
condition|?
name|NIG_REG_INGRESS_BMAC1_MEM
else|:
name|NIG_REG_INGRESS_BMAC0_MEM
expr_stmt|;
comment|/*  Read BIGMAC_REGISTER_RX_LSS_STATUS */
if|if
condition|(
name|CHIP_IS_E2
argument_list|(
name|sc
argument_list|)
condition|)
name|lss_status_reg
operator|=
name|BIGMAC2_REGISTER_RX_LSS_STAT
expr_stmt|;
else|else
name|lss_status_reg
operator|=
name|BIGMAC_REGISTER_RX_LSS_STATUS
expr_stmt|;
name|REG_RD_DMAE
argument_list|(
name|sc
argument_list|,
name|mac_base
operator|+
name|lss_status_reg
argument_list|,
name|wb_data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|lss_status
operator|=
operator|(
name|wb_data
index|[
literal|0
index|]
operator|>
literal|0
operator|)
expr_stmt|;
name|elink_analyze_link_error
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
name|lss_status
argument_list|,
name|PHY_HALF_OPEN_CONN_FLAG
argument_list|,
name|LINK_STATUS_NONE
argument_list|,
name|notify
argument_list|)
expr_stmt|;
block|}
return|return
name|ELINK_STATUS_OK
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_sfp_tx_fault_detection
parameter_list|(
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|,
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint32_t
name|cfg_pin
decl_stmt|,
name|value
init|=
literal|0
decl_stmt|;
name|uint8_t
name|led_change
decl_stmt|,
name|port
init|=
name|params
operator|->
name|port
decl_stmt|;
comment|/* Get The SFP+ TX_Fault controlling pin ([eg]pio) */
name|cfg_pin
operator|=
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|port
index|]
operator|.
name|e3_cmn_pin_cfg
argument_list|)
argument_list|)
operator|&
name|PORT_HW_CFG_E3_TX_FAULT_MASK
operator|)
operator|>>
name|PORT_HW_CFG_E3_TX_FAULT_SHIFT
expr_stmt|;
if|if
condition|(
name|elink_get_cfg_pin
argument_list|(
name|sc
argument_list|,
name|cfg_pin
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Failed to read pin 0x%02x\n"
argument_list|,
name|cfg_pin
argument_list|)
expr_stmt|;
return|return;
block|}
name|led_change
operator|=
name|elink_analyze_link_error
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
name|value
argument_list|,
name|PHY_SFP_TX_FAULT_FLAG
argument_list|,
name|LINK_STATUS_SFP_TX_FAULT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|led_change
condition|)
block|{
comment|/* Change TX_Fault led, set link status for further syncs */
name|uint8_t
name|led_mode
decl_stmt|;
if|if
condition|(
name|vars
operator|->
name|phy_flags
operator|&
name|PHY_SFP_TX_FAULT_FLAG
condition|)
block|{
name|led_mode
operator|=
name|MISC_REGISTERS_GPIO_HIGH
expr_stmt|;
name|vars
operator|->
name|link_status
operator||=
name|LINK_STATUS_SFP_TX_FAULT
expr_stmt|;
block|}
else|else
block|{
name|led_mode
operator|=
name|MISC_REGISTERS_GPIO_LOW
expr_stmt|;
name|vars
operator|->
name|link_status
operator|&=
operator|~
name|LINK_STATUS_SFP_TX_FAULT
expr_stmt|;
block|}
comment|/* If module is unapproved, led should be on regardless */
if|if
condition|(
operator|!
operator|(
name|phy
operator|->
name|flags
operator|&
name|ELINK_FLAGS_SFP_NOT_APPROVED
operator|)
condition|)
block|{
name|ELINK_DEBUG_P1
argument_list|(
name|sc
argument_list|,
literal|"Change TX_Fault LED: ->%x\n"
argument_list|,
name|led_mode
argument_list|)
expr_stmt|;
name|elink_set_e3_module_fault_led
argument_list|(
name|params
argument_list|,
name|led_mode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|elink_kr2_recovery
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|,
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"KR2 recovery\n"
argument_list|)
expr_stmt|;
name|elink_warpcore_enable_AN_KR2
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
name|elink_warpcore_restart_AN_KR
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elink_check_kr2_wa
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|,
name|struct
name|elink_phy
modifier|*
name|phy
parameter_list|)
block|{
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|uint16_t
name|base_page
decl_stmt|,
name|next_page
decl_stmt|,
name|not_kr2_device
decl_stmt|,
name|lane
decl_stmt|;
name|int
name|sigdet
decl_stmt|;
comment|/* Once KR2 was disabled, wait 5 seconds before checking KR2 recovery 	 * Since some switches tend to reinit the AN process and clear the 	 * the advertised BP/NP after ~2 seconds causing the KR2 to be disabled 	 * and recovered many times 	 */
if|if
condition|(
name|vars
operator|->
name|check_kr2_recovery_cnt
operator|>
literal|0
condition|)
block|{
name|vars
operator|->
name|check_kr2_recovery_cnt
operator|--
expr_stmt|;
return|return;
block|}
name|sigdet
operator|=
name|elink_warpcore_get_sigdet
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sigdet
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|params
operator|->
name|link_attr_sync
operator|&
name|LINK_ATTR_SYNC_KR2_ENABLE
operator|)
condition|)
block|{
name|elink_kr2_recovery
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
name|phy
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"No sigdet\n"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|lane
operator|=
name|elink_get_warpcore_lane
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|CL22_WR_OVER_CL45
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_REG_BANK_AER_BLOCK
argument_list|,
name|MDIO_AER_BLOCK_AER_REG
argument_list|,
name|lane
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_LP_AUTO_NEG
argument_list|,
operator|&
name|base_page
argument_list|)
expr_stmt|;
name|elink_cl45_read
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|MDIO_AN_DEVAD
argument_list|,
name|MDIO_AN_REG_LP_AUTO_NEG2
argument_list|,
operator|&
name|next_page
argument_list|)
expr_stmt|;
name|elink_set_aer_mmd
argument_list|(
name|params
argument_list|,
name|phy
argument_list|)
expr_stmt|;
comment|/* CL73 has not begun yet */
if|if
condition|(
name|base_page
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|params
operator|->
name|link_attr_sync
operator|&
name|LINK_ATTR_SYNC_KR2_ENABLE
operator|)
condition|)
block|{
name|elink_kr2_recovery
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
name|phy
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"No BP\n"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* In case NP bit is not set in the BasePage, or it is set, 	 * but only KX is advertised, declare this link partner as non-KR2 	 * device. 	 */
name|not_kr2_device
operator|=
operator|(
operator|(
operator|(
name|base_page
operator|&
literal|0x8000
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
operator|(
name|base_page
operator|&
literal|0x8000
operator|)
operator|&&
operator|(
operator|(
name|next_page
operator|&
literal|0xe0
operator|)
operator|==
literal|0x20
operator|)
operator|)
operator|)
operator|)
expr_stmt|;
comment|/* In case KR2 is already disabled, check if we need to re-enable it */
if|if
condition|(
operator|!
operator|(
name|params
operator|->
name|link_attr_sync
operator|&
name|LINK_ATTR_SYNC_KR2_ENABLE
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|not_kr2_device
condition|)
block|{
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"BP=0x%x, NP=0x%x\n"
argument_list|,
name|base_page
argument_list|,
name|next_page
argument_list|)
expr_stmt|;
name|elink_kr2_recovery
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
name|phy
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* KR2 is enabled, but not KR2 device */
if|if
condition|(
name|not_kr2_device
condition|)
block|{
comment|/* Disable KR2 on both lanes */
name|ELINK_DEBUG_P2
argument_list|(
name|sc
argument_list|,
literal|"BP=0x%x, NP=0x%x\n"
argument_list|,
name|base_page
argument_list|,
name|next_page
argument_list|)
expr_stmt|;
name|elink_disable_kr2
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
name|phy
argument_list|)
expr_stmt|;
comment|/* Restart AN on leading lane */
name|elink_warpcore_restart_AN_KR
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
name|void
name|elink_period_func
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|)
block|{
name|uint16_t
name|phy_idx
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
for|for
control|(
name|phy_idx
operator|=
name|ELINK_INT_PHY
init|;
name|phy_idx
operator|<
name|ELINK_MAX_PHYS
condition|;
name|phy_idx
operator|++
control|)
block|{
if|if
condition|(
name|params
operator|->
name|phy
index|[
name|phy_idx
index|]
operator|.
name|flags
operator|&
name|ELINK_FLAGS_TX_ERROR_CHECK
condition|)
block|{
name|elink_set_aer_mmd
argument_list|(
name|params
argument_list|,
operator|&
name|params
operator|->
name|phy
index|[
name|phy_idx
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|elink_check_half_open_conn
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
literal|1
argument_list|)
operator|!=
name|ELINK_STATUS_OK
condition|)
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"Fault detection failed\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|struct
name|elink_phy
modifier|*
name|phy
init|=
operator|&
name|params
operator|->
name|phy
index|[
name|ELINK_INT_PHY
index|]
decl_stmt|;
name|elink_set_aer_mmd
argument_list|(
name|params
argument_list|,
name|phy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|phy
operator|->
name|req_line_speed
operator|==
name|ELINK_SPEED_AUTO_NEG
operator|)
operator|&&
operator|(
name|phy
operator|->
name|speed_cap_mask
operator|&
name|PORT_HW_CFG_SPEED_CAPABILITY_D0_20G
operator|)
operator|)
operator|||
operator|(
name|phy
operator|->
name|req_line_speed
operator|==
name|ELINK_SPEED_20000
operator|)
condition|)
name|elink_check_kr2_wa
argument_list|(
name|params
argument_list|,
name|vars
argument_list|,
name|phy
argument_list|)
expr_stmt|;
name|elink_check_over_curr
argument_list|(
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
if|if
condition|(
name|vars
operator|->
name|rx_tx_asic_rst
condition|)
name|elink_warpcore_config_runtime
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|params
operator|->
name|port
index|]
operator|.
name|default_cfg
argument_list|)
argument_list|)
operator|&
name|PORT_HW_CFG_NET_SERDES_IF_MASK
operator|)
operator|==
name|PORT_HW_CFG_NET_SERDES_IF_SFI
condition|)
block|{
if|if
condition|(
name|elink_is_sfp_module_plugged
argument_list|(
name|phy
argument_list|,
name|params
argument_list|)
condition|)
block|{
name|elink_sfp_tx_fault_detection
argument_list|(
name|phy
argument_list|,
name|params
argument_list|,
name|vars
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vars
operator|->
name|link_status
operator|&
name|LINK_STATUS_SFP_TX_FAULT
condition|)
block|{
comment|/* Clean trail, interrupt corrects the leds */
name|vars
operator|->
name|link_status
operator|&=
operator|~
name|LINK_STATUS_SFP_TX_FAULT
expr_stmt|;
name|vars
operator|->
name|phy_flags
operator|&=
operator|~
name|PHY_SFP_TX_FAULT_FLAG
expr_stmt|;
comment|/* Update link status in the shared memory */
name|elink_update_mng
argument_list|(
name|params
argument_list|,
name|vars
operator|->
name|link_status
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|uint8_t
name|elink_fan_failure_det_req
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|shmem_base
parameter_list|,
name|uint32_t
name|shmem2_base
parameter_list|,
name|uint8_t
name|port
parameter_list|)
block|{
name|uint8_t
name|phy_index
decl_stmt|,
name|fan_failure_det_req
init|=
literal|0
decl_stmt|;
name|struct
name|elink_phy
name|phy
decl_stmt|;
for|for
control|(
name|phy_index
operator|=
name|ELINK_EXT_PHY1
init|;
name|phy_index
operator|<
name|ELINK_MAX_PHYS
condition|;
name|phy_index
operator|++
control|)
block|{
if|if
condition|(
name|elink_populate_phy
argument_list|(
name|sc
argument_list|,
name|phy_index
argument_list|,
name|shmem_base
argument_list|,
name|shmem2_base
argument_list|,
name|port
argument_list|,
operator|&
name|phy
argument_list|)
operator|!=
name|ELINK_STATUS_OK
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"populate phy failed\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|fan_failure_det_req
operator||=
operator|(
name|phy
operator|.
name|flags
operator|&
name|ELINK_FLAGS_FAN_FAILURE_DET_REQ
operator|)
expr_stmt|;
block|}
return|return
name|fan_failure_det_req
return|;
block|}
end_function

begin_function
name|void
name|elink_hw_reset_phy
parameter_list|(
name|struct
name|elink_params
modifier|*
name|params
parameter_list|)
block|{
name|uint8_t
name|phy_index
decl_stmt|;
name|struct
name|bxe_softc
modifier|*
name|sc
init|=
name|params
operator|->
name|sc
decl_stmt|;
name|elink_update_mng
argument_list|(
name|params
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|elink_bits_dis
argument_list|(
name|sc
argument_list|,
name|NIG_REG_MASK_INTERRUPT_PORT0
operator|+
name|params
operator|->
name|port
operator|*
literal|4
argument_list|,
operator|(
name|ELINK_NIG_MASK_XGXS0_LINK_STATUS
operator||
name|ELINK_NIG_MASK_XGXS0_LINK10G
operator||
name|ELINK_NIG_MASK_SERDES0_LINK_STATUS
operator||
name|ELINK_NIG_MASK_MI_INT
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|phy_index
operator|=
name|ELINK_INT_PHY
init|;
name|phy_index
operator|<
name|ELINK_MAX_PHYS
condition|;
name|phy_index
operator|++
control|)
block|{
if|if
condition|(
name|params
operator|->
name|phy
index|[
name|phy_index
index|]
operator|.
name|hw_reset
condition|)
block|{
name|params
operator|->
name|phy
index|[
name|phy_index
index|]
operator|.
name|hw_reset
argument_list|(
operator|&
name|params
operator|->
name|phy
index|[
name|phy_index
index|]
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|params
operator|->
name|phy
index|[
name|phy_index
index|]
operator|=
name|phy_null
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|elink_init_mod_abs_int
parameter_list|(
name|struct
name|bxe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|elink_vars
modifier|*
name|vars
parameter_list|,
name|uint32_t
name|chip_id
parameter_list|,
name|uint32_t
name|shmem_base
parameter_list|,
name|uint32_t
name|shmem2_base
parameter_list|,
name|uint8_t
name|port
parameter_list|)
block|{
name|uint8_t
name|gpio_num
init|=
literal|0xff
decl_stmt|,
name|gpio_port
init|=
literal|0xff
decl_stmt|,
name|phy_index
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|uint32_t
name|offset
decl_stmt|,
name|aeu_mask
decl_stmt|,
name|swap_val
decl_stmt|,
name|swap_override
decl_stmt|,
name|sync_offset
decl_stmt|;
if|if
condition|(
name|CHIP_IS_E3
argument_list|(
name|sc
argument_list|)
condition|)
block|{
if|if
condition|(
name|elink_get_mod_abs_int_cfg
argument_list|(
name|sc
argument_list|,
name|chip_id
argument_list|,
name|shmem_base
argument_list|,
name|port
argument_list|,
operator|&
name|gpio_num
argument_list|,
operator|&
name|gpio_port
argument_list|)
operator|!=
name|ELINK_STATUS_OK
condition|)
return|return;
block|}
else|else
block|{
name|struct
name|elink_phy
name|phy
decl_stmt|;
for|for
control|(
name|phy_index
operator|=
name|ELINK_EXT_PHY1
init|;
name|phy_index
operator|<
name|ELINK_MAX_PHYS
condition|;
name|phy_index
operator|++
control|)
block|{
if|if
condition|(
name|elink_populate_phy
argument_list|(
name|sc
argument_list|,
name|phy_index
argument_list|,
name|shmem_base
argument_list|,
name|shmem2_base
argument_list|,
name|port
argument_list|,
operator|&
name|phy
argument_list|)
operator|!=
name|ELINK_STATUS_OK
condition|)
block|{
name|ELINK_DEBUG_P0
argument_list|(
name|sc
argument_list|,
literal|"populate phy failed\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|phy
operator|.
name|type
operator|==
name|PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726
condition|)
block|{
name|gpio_num
operator|=
name|MISC_REGISTERS_GPIO_3
expr_stmt|;
name|gpio_port
operator|=
name|port
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|gpio_num
operator|==
literal|0xff
condition|)
return|return;
comment|/* Set GPIO3 to trigger SFP+ module insertion/removal */
name|elink_cb_gpio_write
argument_list|(
name|sc
argument_list|,
name|gpio_num
argument_list|,
name|MISC_REGISTERS_GPIO_INPUT_HI_Z
argument_list|,
name|gpio_port
argument_list|)
expr_stmt|;
name|swap_val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_PORT_SWAP
argument_list|)
expr_stmt|;
name|swap_override
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|NIG_REG_STRAP_OVERRIDE
argument_list|)
expr_stmt|;
name|gpio_port
operator|^=
operator|(
name|swap_val
operator|&&
name|swap_override
operator|)
expr_stmt|;
name|vars
operator|->
name|aeu_int_mask
operator|=
name|AEU_INPUTS_ATTN_BITS_GPIO0_FUNCTION_0
operator|<<
operator|(
name|gpio_num
operator|+
operator|(
name|gpio_port
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
name|sync_offset
operator|=
name|shmem_base
operator|+
name|offsetof
argument_list|(
expr|struct
name|shmem_region
argument_list|,
name|dev_info
operator|.
name|port_hw_config
index|[
name|port
index|]
operator|.
name|aeu_int_mask
argument_list|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|sync_offset
argument_list|,
name|vars
operator|->
name|aeu_int_mask
argument_list|)
expr_stmt|;
name|ELINK_DEBUG_P3
argument_list|(
name|sc
argument_list|,
literal|"Setting MOD_ABS (GPIO%d_P%d) AEU to 0x%x\n"
argument_list|,
name|gpio_num
argument_list|,
name|gpio_port
argument_list|,
name|vars
operator|->
name|aeu_int_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|==
literal|0
condition|)
name|offset
operator|=
name|MISC_REG_AEU_ENABLE1_FUNC_0_OUT_0
expr_stmt|;
else|else
name|offset
operator|=
name|MISC_REG_AEU_ENABLE1_FUNC_1_OUT_0
expr_stmt|;
comment|/* Open appropriate AEU for interrupts */
name|aeu_mask
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|aeu_mask
operator||=
name|vars
operator|->
name|aeu_int_mask
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|offset
argument_list|,
name|aeu_mask
argument_list|)
expr_stmt|;
comment|/* Enable the GPIO to trigger interrupt */
name|val
operator|=
name|REG_RD
argument_list|(
name|sc
argument_list|,
name|MISC_REG_GPIO_EVENT_EN
argument_list|)
expr_stmt|;
name|val
operator||=
literal|1
operator|<<
operator|(
name|gpio_num
operator|+
operator|(
name|gpio_port
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
name|REG_WR
argument_list|(
name|sc
argument_list|,
name|MISC_REG_GPIO_EVENT_EN
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

