begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2017 Stormshield.  * Copyright (c) 2017 Semihalf.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"opt_platform.h"
end_include

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MVNETA_KTR
end_ifdef

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_lro.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/mii.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/miivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/openfirm.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus_subr.h>
end_include

begin_include
include|#
directive|include
file|<dev/mdio/mdio.h>
end_include

begin_include
include|#
directive|include
file|<arm/mv/mvreg.h>
end_include

begin_include
include|#
directive|include
file|<arm/mv/mvvar.h>
end_include

begin_include
include|#
directive|include
file|<arm/mv/mvwin.h>
end_include

begin_include
include|#
directive|include
file|"if_mvnetareg.h"
end_include

begin_include
include|#
directive|include
file|"if_mvnetavar.h"
end_include

begin_include
include|#
directive|include
file|"miibus_if.h"
end_include

begin_include
include|#
directive|include
file|"mdio_if.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MVNETA_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|STATIC
end_define

begin_comment
comment|/* nothing */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|STATIC
value|static
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DASSERT
parameter_list|(
name|x
parameter_list|)
value|KASSERT((x), (#x))
end_define

begin_comment
comment|/* Device Register Initialization */
end_comment

begin_function_decl
name|STATIC
name|int
name|mvneta_initreg
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Descriptor Ring Control for each of queues */
end_comment

begin_function_decl
name|STATIC
name|int
name|mvneta_ring_alloc_rx_queue
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|mvneta_ring_alloc_tx_queue
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|mvneta_ring_dealloc_rx_queue
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|mvneta_ring_dealloc_tx_queue
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|mvneta_ring_init_rx_queue
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|mvneta_ring_init_tx_queue
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|mvneta_ring_flush_rx_queue
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|mvneta_ring_flush_tx_queue
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|mvneta_dmamap_cb
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_dma_segment_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|mvneta_dma_create
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Rx/Tx Queue Control */
end_comment

begin_function_decl
name|STATIC
name|int
name|mvneta_rx_queue_init
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|mvneta_tx_queue_init
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|mvneta_rx_queue_enable
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|mvneta_tx_queue_enable
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|mvneta_rx_lockq
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|mvneta_rx_unlockq
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|mvneta_tx_lockq
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|mvneta_tx_unlockq
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Interrupt Handlers */
end_comment

begin_function_decl
name|STATIC
name|void
name|mvneta_disable_intr
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|mvneta_enable_intr
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|mvneta_rxtxth_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|mvneta_misc_intr
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|mvneta_tick
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* struct ifnet and mii callbacks*/
end_comment

begin_function_decl
name|STATIC
name|int
name|mvneta_xmitfast_locked
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|mvneta_xmit_locked
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|MVNETA_MULTIQUEUE
end_ifdef

begin_function_decl
name|STATIC
name|int
name|mvneta_transmit
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !MVNETA_MULTIQUEUE */
end_comment

begin_function_decl
name|STATIC
name|void
name|mvneta_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|STATIC
name|void
name|mvneta_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|mvneta_tx_task
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|mvneta_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|mvneta_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|mvneta_init_locked
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|mvneta_stop
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|mvneta_stop_locked
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|mvneta_mediachange
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|mvneta_mediastatus
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|mvneta_portup
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|mvneta_portdown
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Link State Notify */
end_comment

begin_function_decl
name|STATIC
name|void
name|mvneta_update_autoneg
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|mvneta_update_media
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|mvneta_adjust_link
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|mvneta_update_eee
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|mvneta_update_fc
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|mvneta_link_isr
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|mvneta_linkupdate
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
parameter_list|,
name|boolean_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|mvneta_linkup
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|mvneta_linkdown
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|mvneta_linkreset
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Tx Subroutines */
end_comment

begin_function_decl
name|STATIC
name|int
name|mvneta_tx_queue
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|mvneta_tx_set_csumflag
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mvneta_tx_desc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|mvneta_tx_queue_complete
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|mvneta_tx_drain
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Rx Subroutines */
end_comment

begin_function_decl
name|STATIC
name|int
name|mvneta_rx
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|mvneta_rx_queue
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|mvneta_rx_queue_refill
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|mvneta_rx_set_csumflag
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mvneta_rx_desc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|mvneta_rx_buf_free
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
parameter_list|,
name|struct
name|mvneta_buf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* MAC address filter */
end_comment

begin_function_decl
name|STATIC
name|void
name|mvneta_filter_setup
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* sysctl(9) */
end_comment

begin_function_decl
name|STATIC
name|int
name|sysctl_read_mib
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|sysctl_clear_mib
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|sysctl_set_queue_rxthtime
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|sysctl_mvneta_init
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* MIB */
end_comment

begin_function_decl
name|STATIC
name|void
name|mvneta_clear_mib
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|mvneta_update_mib
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Switch */
end_comment

begin_function_decl
name|STATIC
name|boolean_t
name|mvneta_has_switch
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|mvneta_sc_lock
parameter_list|(
name|sc
parameter_list|)
value|mtx_lock(&sc->mtx)
end_define

begin_define
define|#
directive|define
name|mvneta_sc_unlock
parameter_list|(
name|sc
parameter_list|)
value|mtx_unlock(&sc->mtx)
end_define

begin_decl_stmt
name|STATIC
name|struct
name|mtx
name|mii_mutex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|mii_init
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Device */
end_comment

begin_function_decl
name|STATIC
name|int
name|mvneta_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* MII */
end_comment

begin_function_decl
name|STATIC
name|int
name|mvneta_miibus_readreg
parameter_list|(
name|device_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|mvneta_miibus_writereg
parameter_list|(
name|device_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|mvneta_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|mvneta_detach
argument_list|)
block|,
comment|/* MII interface */
name|DEVMETHOD
argument_list|(
name|miibus_readreg
argument_list|,
name|mvneta_miibus_readreg
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_writereg
argument_list|,
name|mvneta_miibus_writereg
argument_list|)
block|,
comment|/* MDIO interface */
name|DEVMETHOD
argument_list|(
name|mdio_readreg
argument_list|,
name|mvneta_miibus_readreg
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|mdio_writereg
argument_list|,
name|mvneta_miibus_writereg
argument_list|)
block|,
comment|/* End */
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEFINE_CLASS_0
argument_list|(
name|mvneta
argument_list|,
name|mvneta_driver
argument_list|,
name|mvneta_methods
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mvneta_softc
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|miibus
argument_list|,
name|mvneta
argument_list|,
name|miibus_driver
argument_list|,
name|miibus_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|mdio
argument_list|,
name|mvneta
argument_list|,
name|mdio_driver
argument_list|,
name|mdio_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|mvneta
argument_list|,
name|mdio
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|mvneta
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|mvneta
argument_list|,
name|miibus
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|mvneta
argument_list|,
name|mvxpbm
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * List of MIB register and names  */
end_comment

begin_enum
enum|enum
name|mvneta_mib_idx
block|{
name|MVNETA_MIB_RX_GOOD_OCT_IDX
block|,
name|MVNETA_MIB_RX_BAD_OCT_IDX
block|,
name|MVNETA_MIB_TX_MAC_TRNS_ERR_IDX
block|,
name|MVNETA_MIB_RX_GOOD_FRAME_IDX
block|,
name|MVNETA_MIB_RX_BAD_FRAME_IDX
block|,
name|MVNETA_MIB_RX_BCAST_FRAME_IDX
block|,
name|MVNETA_MIB_RX_MCAST_FRAME_IDX
block|,
name|MVNETA_MIB_RX_FRAME64_OCT_IDX
block|,
name|MVNETA_MIB_RX_FRAME127_OCT_IDX
block|,
name|MVNETA_MIB_RX_FRAME255_OCT_IDX
block|,
name|MVNETA_MIB_RX_FRAME511_OCT_IDX
block|,
name|MVNETA_MIB_RX_FRAME1023_OCT_IDX
block|,
name|MVNETA_MIB_RX_FRAMEMAX_OCT_IDX
block|,
name|MVNETA_MIB_TX_GOOD_OCT_IDX
block|,
name|MVNETA_MIB_TX_GOOD_FRAME_IDX
block|,
name|MVNETA_MIB_TX_EXCES_COL_IDX
block|,
name|MVNETA_MIB_TX_MCAST_FRAME_IDX
block|,
name|MVNETA_MIB_TX_BCAST_FRAME_IDX
block|,
name|MVNETA_MIB_TX_MAC_CTL_ERR_IDX
block|,
name|MVNETA_MIB_FC_SENT_IDX
block|,
name|MVNETA_MIB_FC_GOOD_IDX
block|,
name|MVNETA_MIB_FC_BAD_IDX
block|,
name|MVNETA_MIB_PKT_UNDERSIZE_IDX
block|,
name|MVNETA_MIB_PKT_FRAGMENT_IDX
block|,
name|MVNETA_MIB_PKT_OVERSIZE_IDX
block|,
name|MVNETA_MIB_PKT_JABBER_IDX
block|,
name|MVNETA_MIB_MAC_RX_ERR_IDX
block|,
name|MVNETA_MIB_MAC_CRC_ERR_IDX
block|,
name|MVNETA_MIB_MAC_COL_IDX
block|,
name|MVNETA_MIB_MAC_LATE_COL_IDX
block|, }
enum|;
end_enum

begin_macro
name|STATIC
end_macro

begin_struct
struct|struct
name|mvneta_mib_def
block|{
name|uint32_t
name|regnum
decl_stmt|;
name|int
name|reg64
decl_stmt|;
specifier|const
name|char
modifier|*
name|sysctl_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|desc
decl_stmt|;
block|}
name|mvneta_mib_list
index|[]
init|=
block|{
index|[
name|MVNETA_MIB_RX_GOOD_OCT_IDX
index|]
operator|=
block|{
name|MVNETA_MIB_RX_GOOD_OCT
block|,
literal|1
block|,
literal|"rx_good_oct"
block|,
literal|"Good Octets Rx"
block|}
block|,
index|[
name|MVNETA_MIB_RX_BAD_OCT_IDX
index|]
operator|=
block|{
name|MVNETA_MIB_RX_BAD_OCT
block|,
literal|0
block|,
literal|"rx_bad_oct"
block|,
literal|"Bad  Octets Rx"
block|}
block|,
index|[
name|MVNETA_MIB_TX_MAC_TRNS_ERR_IDX
index|]
operator|=
block|{
name|MVNETA_MIB_TX_MAC_TRNS_ERR
block|,
literal|0
block|,
literal|"tx_mac_err"
block|,
literal|"MAC Transmit Error"
block|}
block|,
index|[
name|MVNETA_MIB_RX_GOOD_FRAME_IDX
index|]
operator|=
block|{
name|MVNETA_MIB_RX_GOOD_FRAME
block|,
literal|0
block|,
literal|"rx_good_frame"
block|,
literal|"Good Frames Rx"
block|}
block|,
index|[
name|MVNETA_MIB_RX_BAD_FRAME_IDX
index|]
operator|=
block|{
name|MVNETA_MIB_RX_BAD_FRAME
block|,
literal|0
block|,
literal|"rx_bad_frame"
block|,
literal|"Bad Frames Rx"
block|}
block|,
index|[
name|MVNETA_MIB_RX_BCAST_FRAME_IDX
index|]
operator|=
block|{
name|MVNETA_MIB_RX_BCAST_FRAME
block|,
literal|0
block|,
literal|"rx_bcast_frame"
block|,
literal|"Broadcast Frames Rx"
block|}
block|,
index|[
name|MVNETA_MIB_RX_MCAST_FRAME_IDX
index|]
operator|=
block|{
name|MVNETA_MIB_RX_MCAST_FRAME
block|,
literal|0
block|,
literal|"rx_mcast_frame"
block|,
literal|"Multicast Frames Rx"
block|}
block|,
index|[
name|MVNETA_MIB_RX_FRAME64_OCT_IDX
index|]
operator|=
block|{
name|MVNETA_MIB_RX_FRAME64_OCT
block|,
literal|0
block|,
literal|"rx_frame_1_64"
block|,
literal|"Frame Size    1 -   64"
block|}
block|,
index|[
name|MVNETA_MIB_RX_FRAME127_OCT_IDX
index|]
operator|=
block|{
name|MVNETA_MIB_RX_FRAME127_OCT
block|,
literal|0
block|,
literal|"rx_frame_65_127"
block|,
literal|"Frame Size   65 -  127"
block|}
block|,
index|[
name|MVNETA_MIB_RX_FRAME255_OCT_IDX
index|]
operator|=
block|{
name|MVNETA_MIB_RX_FRAME255_OCT
block|,
literal|0
block|,
literal|"rx_frame_128_255"
block|,
literal|"Frame Size  128 -  255"
block|}
block|,
index|[
name|MVNETA_MIB_RX_FRAME511_OCT_IDX
index|]
operator|=
block|{
name|MVNETA_MIB_RX_FRAME511_OCT
block|,
literal|0
block|,
literal|"rx_frame_256_511"
block|,
literal|"Frame Size  256 -  511"
block|}
block|,
index|[
name|MVNETA_MIB_RX_FRAME1023_OCT_IDX
index|]
operator|=
block|{
name|MVNETA_MIB_RX_FRAME1023_OCT
block|,
literal|0
block|,
literal|"rx_frame_512_1023"
block|,
literal|"Frame Size  512 - 1023"
block|}
block|,
index|[
name|MVNETA_MIB_RX_FRAMEMAX_OCT_IDX
index|]
operator|=
block|{
name|MVNETA_MIB_RX_FRAMEMAX_OCT
block|,
literal|0
block|,
literal|"rx_fame_1024_max"
block|,
literal|"Frame Size 1024 -  Max"
block|}
block|,
index|[
name|MVNETA_MIB_TX_GOOD_OCT_IDX
index|]
operator|=
block|{
name|MVNETA_MIB_TX_GOOD_OCT
block|,
literal|1
block|,
literal|"tx_good_oct"
block|,
literal|"Good Octets Tx"
block|}
block|,
index|[
name|MVNETA_MIB_TX_GOOD_FRAME_IDX
index|]
operator|=
block|{
name|MVNETA_MIB_TX_GOOD_FRAME
block|,
literal|0
block|,
literal|"tx_good_frame"
block|,
literal|"Good Frames Tx"
block|}
block|,
index|[
name|MVNETA_MIB_TX_EXCES_COL_IDX
index|]
operator|=
block|{
name|MVNETA_MIB_TX_EXCES_COL
block|,
literal|0
block|,
literal|"tx_exces_collision"
block|,
literal|"Excessive Collision"
block|}
block|,
index|[
name|MVNETA_MIB_TX_MCAST_FRAME_IDX
index|]
operator|=
block|{
name|MVNETA_MIB_TX_MCAST_FRAME
block|,
literal|0
block|,
literal|"tx_mcast_frame"
block|,
literal|"Multicast Frames Tx"
block|}
block|,
index|[
name|MVNETA_MIB_TX_BCAST_FRAME_IDX
index|]
operator|=
block|{
name|MVNETA_MIB_TX_BCAST_FRAME
block|,
literal|0
block|,
literal|"tx_bcast_frame"
block|,
literal|"Broadcast Frames Tx"
block|}
block|,
index|[
name|MVNETA_MIB_TX_MAC_CTL_ERR_IDX
index|]
operator|=
block|{
name|MVNETA_MIB_TX_MAC_CTL_ERR
block|,
literal|0
block|,
literal|"tx_mac_ctl_err"
block|,
literal|"Unknown MAC Control"
block|}
block|,
index|[
name|MVNETA_MIB_FC_SENT_IDX
index|]
operator|=
block|{
name|MVNETA_MIB_FC_SENT
block|,
literal|0
block|,
literal|"fc_tx"
block|,
literal|"Flow Control Tx"
block|}
block|,
index|[
name|MVNETA_MIB_FC_GOOD_IDX
index|]
operator|=
block|{
name|MVNETA_MIB_FC_GOOD
block|,
literal|0
block|,
literal|"fc_rx_good"
block|,
literal|"Good Flow Control Rx"
block|}
block|,
index|[
name|MVNETA_MIB_FC_BAD_IDX
index|]
operator|=
block|{
name|MVNETA_MIB_FC_BAD
block|,
literal|0
block|,
literal|"fc_rx_bad"
block|,
literal|"Bad Flow Control Rx"
block|}
block|,
index|[
name|MVNETA_MIB_PKT_UNDERSIZE_IDX
index|]
operator|=
block|{
name|MVNETA_MIB_PKT_UNDERSIZE
block|,
literal|0
block|,
literal|"pkt_undersize"
block|,
literal|"Undersized Packets Rx"
block|}
block|,
index|[
name|MVNETA_MIB_PKT_FRAGMENT_IDX
index|]
operator|=
block|{
name|MVNETA_MIB_PKT_FRAGMENT
block|,
literal|0
block|,
literal|"pkt_fragment"
block|,
literal|"Fragmented Packets Rx"
block|}
block|,
index|[
name|MVNETA_MIB_PKT_OVERSIZE_IDX
index|]
operator|=
block|{
name|MVNETA_MIB_PKT_OVERSIZE
block|,
literal|0
block|,
literal|"pkt_oversize"
block|,
literal|"Oversized Packets Rx"
block|}
block|,
index|[
name|MVNETA_MIB_PKT_JABBER_IDX
index|]
operator|=
block|{
name|MVNETA_MIB_PKT_JABBER
block|,
literal|0
block|,
literal|"pkt_jabber"
block|,
literal|"Jabber Packets Rx"
block|}
block|,
index|[
name|MVNETA_MIB_MAC_RX_ERR_IDX
index|]
operator|=
block|{
name|MVNETA_MIB_MAC_RX_ERR
block|,
literal|0
block|,
literal|"mac_rx_err"
block|,
literal|"MAC Rx Errors"
block|}
block|,
index|[
name|MVNETA_MIB_MAC_CRC_ERR_IDX
index|]
operator|=
block|{
name|MVNETA_MIB_MAC_CRC_ERR
block|,
literal|0
block|,
literal|"mac_crc_err"
block|,
literal|"MAC CRC Errors"
block|}
block|,
index|[
name|MVNETA_MIB_MAC_COL_IDX
index|]
operator|=
block|{
name|MVNETA_MIB_MAC_COL
block|,
literal|0
block|,
literal|"mac_collision"
block|,
literal|"MAC Collision"
block|}
block|,
index|[
name|MVNETA_MIB_MAC_LATE_COL_IDX
index|]
operator|=
block|{
name|MVNETA_MIB_MAC_LATE_COL
block|,
literal|0
block|,
literal|"mac_late_collision"
block|,
literal|"MAC Late Collision"
block|}
block|, }
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|resource_spec
name|res_spec
index|[]
init|=
block|{
block|{
name|SYS_RES_MEMORY
block|,
literal|0
block|,
name|RF_ACTIVE
block|}
block|,
block|{
name|SYS_RES_IRQ
block|,
literal|0
block|,
name|RF_ACTIVE
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
block|{
name|driver_intr_t
modifier|*
name|handler
decl_stmt|;
name|char
modifier|*
name|description
decl_stmt|;
block|}
name|mvneta_intrs
index|[]
init|=
block|{
block|{
name|mvneta_rxtxth_intr
block|,
literal|"MVNETA aggregated interrupt"
block|}
block|, }
struct|;
end_struct

begin_function
specifier|static
name|int
name|mvneta_set_mac_address
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
modifier|*
name|addr
parameter_list|)
block|{
name|unsigned
name|int
name|mac_h
decl_stmt|;
name|unsigned
name|int
name|mac_l
decl_stmt|;
name|mac_l
operator|=
operator|(
name|addr
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|addr
index|[
literal|5
index|]
operator|)
expr_stmt|;
name|mac_h
operator|=
operator|(
name|addr
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|addr
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|addr
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|addr
index|[
literal|3
index|]
operator|<<
literal|0
operator|)
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_MACAL
argument_list|,
name|mac_l
argument_list|)
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_MACAH
argument_list|,
name|mac_h
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mvneta_get_mac_address
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
modifier|*
name|addr
parameter_list|)
block|{
name|uint32_t
name|mac_l
decl_stmt|,
name|mac_h
decl_stmt|;
ifdef|#
directive|ifdef
name|FDT
if|if
condition|(
name|mvneta_fdt_mac_address
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* 	 * Fall back -- use the currently programmed address. 	 */
name|mac_l
operator|=
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_MACAL
argument_list|)
expr_stmt|;
name|mac_h
operator|=
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_MACAH
argument_list|)
expr_stmt|;
if|if
condition|(
name|mac_l
operator|==
literal|0
operator|&&
name|mac_h
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Generate pseudo-random MAC. 		 * Set lower part to random number | unit number. 		 */
name|mac_l
operator|=
name|arc4random
argument_list|()
operator|&
operator|~
literal|0xff
expr_stmt|;
name|mac_l
operator||=
name|device_get_unit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
operator|&
literal|0xff
expr_stmt|;
name|mac_h
operator|=
name|arc4random
argument_list|()
expr_stmt|;
name|mac_h
operator|&=
operator|~
operator|(
literal|3
operator|<<
literal|24
operator|)
expr_stmt|;
comment|/* Clear multicast and LAA bits */
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Could not acquire MAC address. "
literal|"Using randomized one.\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|addr
index|[
literal|0
index|]
operator|=
operator|(
name|mac_h
operator|&
literal|0xff000000
operator|)
operator|>>
literal|24
expr_stmt|;
name|addr
index|[
literal|1
index|]
operator|=
operator|(
name|mac_h
operator|&
literal|0x00ff0000
operator|)
operator|>>
literal|16
expr_stmt|;
name|addr
index|[
literal|2
index|]
operator|=
operator|(
name|mac_h
operator|&
literal|0x0000ff00
operator|)
operator|>>
literal|8
expr_stmt|;
name|addr
index|[
literal|3
index|]
operator|=
operator|(
name|mac_h
operator|&
literal|0x000000ff
operator|)
expr_stmt|;
name|addr
index|[
literal|4
index|]
operator|=
operator|(
name|mac_l
operator|&
literal|0x0000ff00
operator|)
operator|>>
literal|8
expr_stmt|;
name|addr
index|[
literal|5
index|]
operator|=
operator|(
name|mac_l
operator|&
literal|0x000000ff
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|boolean_t
name|mvneta_has_switch
parameter_list|(
name|device_t
name|self
parameter_list|)
block|{
name|phandle_t
name|node
decl_stmt|,
name|switch_node
decl_stmt|,
name|switch_eth
decl_stmt|,
name|switch_eth_handle
decl_stmt|;
name|node
operator|=
name|ofw_bus_get_node
argument_list|(
name|self
argument_list|)
expr_stmt|;
name|switch_node
operator|=
name|ofw_bus_find_compatible
argument_list|(
name|OF_finddevice
argument_list|(
literal|"/"
argument_list|)
argument_list|,
literal|"marvell,dsa"
argument_list|)
expr_stmt|;
name|switch_eth
operator|=
literal|0
expr_stmt|;
name|OF_getencprop
argument_list|(
name|switch_node
argument_list|,
literal|"dsa,ethernet"
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|switch_eth_handle
argument_list|,
sizeof|sizeof
argument_list|(
name|switch_eth_handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|switch_eth_handle
operator|>
literal|0
condition|)
name|switch_eth
operator|=
name|OF_node_from_xref
argument_list|(
name|switch_eth_handle
argument_list|)
expr_stmt|;
comment|/* Return true if dsa,ethernet cell points to us */
return|return
operator|(
name|node
operator|==
name|switch_eth
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|mvneta_dma_create
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|)
block|{
name|size_t
name|maxsize
decl_stmt|,
name|maxsegsz
decl_stmt|;
name|size_t
name|q
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Create Tx DMA 	 */
name|maxsize
operator|=
name|maxsegsz
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mvneta_tx_desc
argument_list|)
operator|*
name|MVNETA_TX_RING_CNT
expr_stmt|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
comment|/* parent */
literal|16
argument_list|,
literal|0
argument_list|,
comment|/* alignment, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filtfunc, filtfuncarg */
name|maxsize
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|maxsegsz
argument_list|,
comment|/* maxsegsz */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockfuncarg */
operator|&
name|sc
operator|->
name|tx_dtag
argument_list|)
expr_stmt|;
comment|/* dmat */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Failed to create DMA tag for Tx descriptors.\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* alignment, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filtfunc, filtfuncarg */
name|MVNETA_PACKET_SIZE
argument_list|,
comment|/* maxsize */
name|MVNETA_TX_SEGLIMIT
argument_list|,
comment|/* nsegments */
name|MVNETA_PACKET_SIZE
argument_list|,
comment|/* maxsegsz */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockfuncarg */
operator|&
name|sc
operator|->
name|txmbuf_dtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Failed to create DMA tag for Tx mbufs.\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
for|for
control|(
name|q
operator|=
literal|0
init|;
name|q
operator|<
name|MVNETA_TX_QNUM_MAX
condition|;
name|q
operator|++
control|)
block|{
name|error
operator|=
name|mvneta_ring_alloc_tx_queue
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Failed to allocate DMA safe memory for TxQ: %d\n"
argument_list|,
name|q
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* 	 * Create Rx DMA. 	 */
comment|/* Create tag for Rx descripors */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
comment|/* parent */
literal|32
argument_list|,
literal|0
argument_list|,
comment|/* alignment, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filtfunc, filtfuncarg */
sizeof|sizeof
argument_list|(
expr|struct
name|mvneta_rx_desc
argument_list|)
operator|*
name|MVNETA_RX_RING_CNT
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
sizeof|sizeof
argument_list|(
expr|struct
name|mvneta_rx_desc
argument_list|)
operator|*
name|MVNETA_RX_RING_CNT
argument_list|,
comment|/* maxsegsz */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockfuncarg */
operator|&
name|sc
operator|->
name|rx_dtag
argument_list|)
expr_stmt|;
comment|/* dmat */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Failed to create DMA tag for Rx descriptors.\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Create tag for Rx buffers */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
comment|/* parent */
literal|32
argument_list|,
literal|0
argument_list|,
comment|/* alignment, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filtfunc, filtfuncarg */
name|MVNETA_PACKET_SIZE
argument_list|,
literal|1
argument_list|,
comment|/* maxsize, nsegments */
name|MVNETA_PACKET_SIZE
argument_list|,
comment|/* maxsegsz */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockfuncarg */
operator|&
name|sc
operator|->
name|rxbuf_dtag
argument_list|)
expr_stmt|;
comment|/* dmat */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Failed to create DMA tag for Rx buffers.\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
for|for
control|(
name|q
operator|=
literal|0
init|;
name|q
operator|<
name|MVNETA_RX_QNUM_MAX
condition|;
name|q
operator|++
control|)
block|{
if|if
condition|(
name|mvneta_ring_alloc_rx_queue
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Failed to allocate DMA safe memory for RxQ: %d\n"
argument_list|,
name|q
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|mvneta_detach
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|mvneta_attach
parameter_list|(
name|device_t
name|self
parameter_list|)
block|{
name|struct
name|mvneta_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|device_t
name|child
decl_stmt|;
name|int
name|ifm_target
decl_stmt|;
name|int
name|q
decl_stmt|,
name|error
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|self
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|self
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|,
literal|"mvneta_sc"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_alloc_resources
argument_list|(
name|self
argument_list|,
name|res_spec
argument_list|,
name|sc
operator|->
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|self
argument_list|,
literal|"could not allocate resources\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|version
operator|=
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_PV
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|self
argument_list|,
literal|"version is %x\n"
argument_list|,
name|sc
operator|->
name|version
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|tick_ch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * make sure DMA engines are in reset state 	 */
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PRXINIT
argument_list|,
literal|0x00000001
argument_list|)
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PTXINIT
argument_list|,
literal|0x00000001
argument_list|)
expr_stmt|;
comment|/* 	 * Disable port snoop for buffers and descriptors 	 * to avoid L2 caching of both without DRAM copy. 	 * Obtain coherency settings from the first MBUS 	 * window attribute. 	 */
if|if
condition|(
operator|(
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MV_WIN_NETA_BASE
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|&
name|IO_WIN_COH_ATTR_MASK
operator|)
operator|==
literal|0
condition|)
block|{
name|reg
operator|=
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_PSNPCFG
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|MVNETA_PSNPCFG_DESCSNP_MASK
expr_stmt|;
name|reg
operator|&=
operator|~
name|MVNETA_PSNPCFG_BUFSNP_MASK
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PSNPCFG
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * MAC address 	 */
if|if
condition|(
name|mvneta_get_mac_address
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|enaddr
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|self
argument_list|,
literal|"no mac address.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|mvneta_set_mac_address
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|enaddr
argument_list|)
expr_stmt|;
name|mvneta_disable_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Allocate network interface */
name|ifp
operator|=
name|sc
operator|->
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|self
argument_list|,
literal|"if_alloc() failed\n"
argument_list|)
expr_stmt|;
name|mvneta_detach
argument_list|(
name|self
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|self
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|self
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * We can support 802.1Q VLAN-sized frames and jumbo 	 * Ethernet frames. 	 */
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_MTU
operator||
name|IFCAP_JUMBO_MTU
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
ifdef|#
directive|ifdef
name|MVNETA_MULTIQUEUE
name|ifp
operator|->
name|if_transmit
operator|=
name|mvneta_transmit
expr_stmt|;
name|ifp
operator|->
name|if_qflush
operator|=
name|mvneta_qflush
expr_stmt|;
else|#
directive|else
comment|/* !MVNETA_MULTIQUEUE */
name|ifp
operator|->
name|if_start
operator|=
name|mvneta_start
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|MVNETA_TX_RING_CNT
operator|-
literal|1
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
argument_list|)
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_init
operator|=
name|mvneta_init
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|mvneta_ioctl
expr_stmt|;
comment|/* 	 * We can do IPv4/TCPv4/UDPv4/TCPv6/UDPv6 checksums in hardware. 	 */
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_HWCSUM
expr_stmt|;
comment|/* 	 * As VLAN hardware tagging is not supported 	 * but is necessary to perform VLAN hardware checksums, 	 * it is done in the driver 	 */
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_HWTAGGING
operator||
name|IFCAP_VLAN_HWCSUM
expr_stmt|;
comment|/* 	 * Currently IPv6 HW checksum is broken, so make sure it is disabled. 	 */
name|ifp
operator|->
name|if_capabilities
operator|&=
operator|~
name|IFCAP_HWCSUM_IPV6
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
comment|/* 	 * Disabled option(s): 	 * - Support for Large Receive Offload 	 */
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_LRO
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|=
name|CSUM_IP
operator||
name|CSUM_TCP
operator||
name|CSUM_UDP
expr_stmt|;
comment|/* 	 * Device DMA Buffer allocation. 	 * Handles resource deallocation in case of failure. 	 */
name|error
operator|=
name|mvneta_dma_create
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|mvneta_detach
argument_list|(
name|self
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Initialize queues */
for|for
control|(
name|q
operator|=
literal|0
init|;
name|q
operator|<
name|MVNETA_TX_QNUM_MAX
condition|;
name|q
operator|++
control|)
block|{
name|error
operator|=
name|mvneta_ring_init_tx_queue
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|mvneta_detach
argument_list|(
name|self
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
for|for
control|(
name|q
operator|=
literal|0
init|;
name|q
operator|<
name|MVNETA_RX_QNUM_MAX
condition|;
name|q
operator|++
control|)
block|{
name|error
operator|=
name|mvneta_ring_init_rx_queue
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|mvneta_detach
argument_list|(
name|self
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|sc
operator|->
name|enaddr
argument_list|)
expr_stmt|;
comment|/* 	 * Enable DMA engines and Initialize Device Registers. 	 */
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PRXINIT
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PTXINIT
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PACC
argument_list|,
name|MVNETA_PACC_ACCELERATIONMODE_EDM
argument_list|)
expr_stmt|;
name|mvneta_sc_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mvneta_filter_setup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mvneta_sc_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mvneta_initreg
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * Now MAC is working, setup MII. 	 */
if|if
condition|(
name|mii_init
operator|==
literal|0
condition|)
block|{
comment|/* 		 * MII bus is shared by all MACs and all PHYs in SoC. 		 * serializing the bus access should be safe. 		 */
name|mtx_init
argument_list|(
operator|&
name|mii_mutex
argument_list|,
literal|"mvneta_mii"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mii_init
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Attach PHY(s) */
if|if
condition|(
operator|(
name|sc
operator|->
name|phy_addr
operator|!=
name|MII_PHY_ANY
operator|)
operator|&&
operator|(
operator|!
name|sc
operator|->
name|use_inband_status
operator|)
condition|)
block|{
name|error
operator|=
name|mii_attach
argument_list|(
name|self
argument_list|,
operator|&
name|sc
operator|->
name|miibus
argument_list|,
name|ifp
argument_list|,
name|mvneta_mediachange
argument_list|,
name|mvneta_mediastatus
argument_list|,
name|BMSR_DEFCAPMASK
argument_list|,
name|sc
operator|->
name|phy_addr
argument_list|,
name|MII_OFFSET_ANY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|self
argument_list|,
literal|"MII attach failed, error: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|ether_ifdetach
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|mvneta_detach
argument_list|(
name|self
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|sc
operator|->
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|miibus
argument_list|)
expr_stmt|;
name|sc
operator|->
name|phy_attached
operator|=
literal|1
expr_stmt|;
comment|/* Disable auto-negotiation in MAC - rely on PHY layer */
name|mvneta_update_autoneg
argument_list|(
name|sc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|use_inband_status
operator|==
name|TRUE
condition|)
block|{
comment|/* In-band link status */
name|ifmedia_init
argument_list|(
operator|&
name|sc
operator|->
name|mvneta_ifmedia
argument_list|,
literal|0
argument_list|,
name|mvneta_mediachange
argument_list|,
name|mvneta_mediastatus
argument_list|)
expr_stmt|;
comment|/* Configure media */
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|mvneta_ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_T
operator||
name|IFM_FDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|mvneta_ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|IFM_100_TX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|mvneta_ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|IFM_100_TX
operator||
name|IFM_FDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|mvneta_ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10_T
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|mvneta_ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10_T
operator||
name|IFM_FDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|mvneta_ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|mvneta_ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
comment|/* Enable auto-negotiation */
name|mvneta_update_autoneg
argument_list|(
name|sc
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|mvneta_sc_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|MVNETA_IS_LINKUP
argument_list|(
name|sc
argument_list|)
condition|)
name|mvneta_linkup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|mvneta_linkdown
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mvneta_sc_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Fixed-link, use predefined values */
name|ifmedia_init
argument_list|(
operator|&
name|sc
operator|->
name|mvneta_ifmedia
argument_list|,
literal|0
argument_list|,
name|mvneta_mediachange
argument_list|,
name|mvneta_mediastatus
argument_list|)
expr_stmt|;
name|ifm_target
operator|=
name|IFM_ETHER
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|phy_speed
condition|)
block|{
case|case
literal|2500
case|:
if|if
condition|(
name|sc
operator|->
name|phy_mode
operator|!=
name|MVNETA_PHY_SGMII
operator|&&
name|sc
operator|->
name|phy_mode
operator|!=
name|MVNETA_PHY_QSGMII
condition|)
block|{
name|device_printf
argument_list|(
name|self
argument_list|,
literal|"2.5G speed can work only in (Q)SGMII mode\n"
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|mvneta_detach
argument_list|(
name|self
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|ifm_target
operator||=
name|IFM_2500_T
expr_stmt|;
break|break;
case|case
literal|1000
case|:
name|ifm_target
operator||=
name|IFM_1000_T
expr_stmt|;
break|break;
case|case
literal|100
case|:
name|ifm_target
operator||=
name|IFM_100_TX
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|ifm_target
operator||=
name|IFM_10_T
expr_stmt|;
break|break;
default|default:
name|ether_ifdetach
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|mvneta_detach
argument_list|(
name|self
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|phy_fdx
condition|)
name|ifm_target
operator||=
name|IFM_FDX
expr_stmt|;
else|else
name|ifm_target
operator||=
name|IFM_HDX
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|mvneta_ifmedia
argument_list|,
name|ifm_target
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|mvneta_ifmedia
argument_list|,
name|ifm_target
argument_list|)
expr_stmt|;
name|if_link_state_change
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
if|if
condition|(
name|mvneta_has_switch
argument_list|(
name|self
argument_list|)
condition|)
block|{
name|child
operator|=
name|device_add_child
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"mdio"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
block|{
name|ether_ifdetach
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|mvneta_detach
argument_list|(
name|self
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|bus_generic_attach
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|bus_generic_attach
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
comment|/* Configure MAC media */
name|mvneta_update_media
argument_list|(
name|sc
argument_list|,
name|ifm_target
argument_list|)
expr_stmt|;
block|}
name|sysctl_mvneta_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|tick_ch
argument_list|,
literal|0
argument_list|,
name|mvneta_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|self
argument_list|,
name|sc
operator|->
name|res
index|[
literal|1
index|]
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|mvneta_intrs
index|[
literal|0
index|]
operator|.
name|handler
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|ih_cookie
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|self
argument_list|,
literal|"could not setup %s\n"
argument_list|,
name|mvneta_intrs
index|[
literal|0
index|]
operator|.
name|description
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|mvneta_detach
argument_list|(
name|self
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|mvneta_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|mvneta_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|q
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
name|mvneta_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Detach network interface */
if|if
condition|(
name|sc
operator|->
name|ifp
condition|)
name|if_free
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
literal|0
init|;
name|q
operator|<
name|MVNETA_RX_QNUM_MAX
condition|;
name|q
operator|++
control|)
name|mvneta_ring_dealloc_rx_queue
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
literal|0
init|;
name|q
operator|<
name|MVNETA_TX_QNUM_MAX
condition|;
name|q
operator|++
control|)
name|mvneta_ring_dealloc_tx_queue
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tx_dtag
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|tx_dtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rx_dtag
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|rx_dtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|txmbuf_dtag
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|txmbuf_dtag
argument_list|)
expr_stmt|;
name|bus_release_resources
argument_list|(
name|dev
argument_list|,
name|res_spec
argument_list|,
name|sc
operator|->
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * MII  */
end_comment

begin_function
name|STATIC
name|int
name|mvneta_miibus_readreg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|struct
name|mvneta_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|uint32_t
name|smi
decl_stmt|,
name|val
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|mii_mutex
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MVNETA_PHY_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_SMI
argument_list|)
operator|&
name|MVNETA_SMI_BUSY
operator|)
operator|==
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|MVNETA_PHY_TIMEOUT
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"SMI busy timeout\n"
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|mii_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|smi
operator|=
name|MVNETA_SMI_PHYAD
argument_list|(
name|phy
argument_list|)
operator||
name|MVNETA_SMI_REGAD
argument_list|(
name|reg
argument_list|)
operator||
name|MVNETA_SMI_OPCODE_READ
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_SMI
argument_list|,
name|smi
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MVNETA_PHY_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_SMI
argument_list|)
operator|&
name|MVNETA_SMI_BUSY
operator|)
operator|==
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|MVNETA_PHY_TIMEOUT
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"SMI busy timeout\n"
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|mii_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MVNETA_PHY_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
name|smi
operator|=
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_SMI
argument_list|)
expr_stmt|;
if|if
condition|(
name|smi
operator|&
name|MVNETA_SMI_READVALID
condition|)
break|break;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|MVNETA_PHY_TIMEOUT
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"SMI busy timeout\n"
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|mii_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|mii_mutex
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MVNETA_KTR
name|CTR3
argument_list|(
name|KTR_SPARE2
argument_list|,
literal|"%s i=%d, timeout=%d\n"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|i
argument_list|,
name|MVNETA_PHY_TIMEOUT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|val
operator|=
name|smi
operator|&
name|MVNETA_SMI_DATA_MASK
expr_stmt|;
ifdef|#
directive|ifdef
name|MVNETA_KTR
name|CTR4
argument_list|(
name|KTR_SPARE2
argument_list|,
literal|"%s phy=%d, reg=%#x, val=%#x\n"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|phy
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|mvneta_miibus_writereg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|struct
name|mvneta_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|uint32_t
name|smi
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
ifdef|#
directive|ifdef
name|MVNETA_KTR
name|CTR4
argument_list|(
name|KTR_SPARE2
argument_list|,
literal|"%s phy=%d, reg=%#x, val=%#x\n"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|phy
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mtx_lock
argument_list|(
operator|&
name|mii_mutex
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MVNETA_PHY_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_SMI
argument_list|)
operator|&
name|MVNETA_SMI_BUSY
operator|)
operator|==
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|MVNETA_PHY_TIMEOUT
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"SMI busy timeout\n"
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|mii_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|smi
operator|=
name|MVNETA_SMI_PHYAD
argument_list|(
name|phy
argument_list|)
operator||
name|MVNETA_SMI_REGAD
argument_list|(
name|reg
argument_list|)
operator||
name|MVNETA_SMI_OPCODE_WRITE
operator||
operator|(
name|val
operator|&
name|MVNETA_SMI_DATA_MASK
operator|)
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_SMI
argument_list|,
name|smi
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MVNETA_PHY_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_SMI
argument_list|)
operator|&
name|MVNETA_SMI_BUSY
operator|)
operator|==
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|mii_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|MVNETA_PHY_TIMEOUT
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"phy write timed out\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|mvneta_portup
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
literal|0
init|;
name|q
operator|<
name|MVNETA_RX_QNUM_MAX
condition|;
name|q
operator|++
control|)
block|{
name|mvneta_rx_lockq
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|mvneta_rx_queue_enable
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|mvneta_rx_unlockq
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|q
operator|=
literal|0
init|;
name|q
operator|<
name|MVNETA_TX_QNUM_MAX
condition|;
name|q
operator|++
control|)
block|{
name|mvneta_tx_lockq
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|mvneta_tx_queue_enable
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|mvneta_tx_unlockq
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|STATIC
name|void
name|mvneta_portdown
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mvneta_rx_ring
modifier|*
name|rx
decl_stmt|;
name|struct
name|mvneta_tx_ring
modifier|*
name|tx
decl_stmt|;
name|int
name|q
decl_stmt|,
name|cnt
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
for|for
control|(
name|q
operator|=
literal|0
init|;
name|q
operator|<
name|MVNETA_RX_QNUM_MAX
condition|;
name|q
operator|++
control|)
block|{
name|rx
operator|=
name|MVNETA_RX_RING
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|mvneta_rx_lockq
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|rx
operator|->
name|queue_status
operator|=
name|MVNETA_QUEUE_DISABLED
expr_stmt|;
name|mvneta_rx_unlockq
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|q
operator|=
literal|0
init|;
name|q
operator|<
name|MVNETA_TX_QNUM_MAX
condition|;
name|q
operator|++
control|)
block|{
name|tx
operator|=
name|MVNETA_TX_RING
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|mvneta_tx_lockq
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|tx
operator|->
name|queue_status
operator|=
name|MVNETA_QUEUE_DISABLED
expr_stmt|;
name|mvneta_tx_unlockq
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
comment|/* Wait for all Rx activity to terminate. */
name|reg
operator|=
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_RQC
argument_list|)
operator|&
name|MVNETA_RQC_EN_MASK
expr_stmt|;
name|reg
operator|=
name|MVNETA_RQC_DIS
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_RQC
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|cnt
operator|>=
name|RX_DISABLE_TIMEOUT
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"timeout for RX stopped. rqc 0x%x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
block|}
name|cnt
operator|++
expr_stmt|;
name|reg
operator|=
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_RQC
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|reg
operator|&
name|MVNETA_RQC_EN_MASK
operator|)
operator|!=
literal|0
condition|)
do|;
comment|/* Wait for all Tx activity to terminate. */
name|reg
operator|=
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_PIE
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|MVNETA_PIE_TXPKTINTRPTENB_MASK
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PIE
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_PRXTXTIM
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|MVNETA_PRXTXTI_TBTCQ_MASK
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PRXTXTIM
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_TQC
argument_list|)
operator|&
name|MVNETA_TQC_EN_MASK
expr_stmt|;
name|reg
operator|=
name|MVNETA_TQC_DIS
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_TQC
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|cnt
operator|>=
name|TX_DISABLE_TIMEOUT
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"timeout for TX stopped. tqc 0x%x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
block|}
name|cnt
operator|++
expr_stmt|;
name|reg
operator|=
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_TQC
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|reg
operator|&
name|MVNETA_TQC_EN_MASK
operator|)
operator|!=
literal|0
condition|)
do|;
comment|/* Wait for all Tx FIFO is empty */
name|cnt
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|cnt
operator|>=
name|TX_FIFO_EMPTY_TIMEOUT
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"timeout for TX FIFO drained. ps0 0x%x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
block|}
name|cnt
operator|++
expr_stmt|;
name|reg
operator|=
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_PS0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
operator|(
name|reg
operator|&
name|MVNETA_PS0_TXFIFOEMP
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|reg
operator|&
name|MVNETA_PS0_TXINPROG
operator|)
operator|!=
literal|0
operator|)
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Device Register Initialization  *  reset device registers to device driver default value.  *  the device is not enabled here.  */
end_comment

begin_function
name|STATIC
name|int
name|mvneta_initreg
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|mvneta_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|q
decl_stmt|,
name|i
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
ifdef|#
directive|ifdef
name|MVNETA_KTR
name|CTR1
argument_list|(
name|KTR_SPARE2
argument_list|,
literal|"%s initializing device register"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Disable Legacy WRR, Disable EJP, Release from reset. */
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_TQC_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Enable mbus retry. */
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_MBUS_CONF
argument_list|,
name|MVNETA_MBUS_RETRY_EN
argument_list|)
expr_stmt|;
comment|/* Init TX/RX Queue Registers */
for|for
control|(
name|q
operator|=
literal|0
init|;
name|q
operator|<
name|MVNETA_RX_QNUM_MAX
condition|;
name|q
operator|++
control|)
block|{
name|mvneta_rx_lockq
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|mvneta_rx_queue_init
argument_list|(
name|ifp
argument_list|,
name|q
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"initialization failed: cannot initialize queue\n"
argument_list|)
expr_stmt|;
name|mvneta_rx_unlockq
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|mvneta_rx_unlockq
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|q
operator|=
literal|0
init|;
name|q
operator|<
name|MVNETA_TX_QNUM_MAX
condition|;
name|q
operator|++
control|)
block|{
name|mvneta_tx_lockq
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|mvneta_tx_queue_init
argument_list|(
name|ifp
argument_list|,
name|q
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"initialization failed: cannot initialize queue\n"
argument_list|)
expr_stmt|;
name|mvneta_tx_unlockq
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|mvneta_tx_unlockq
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Ethernet Unit Control - disable automatic PHY management by HW. 	 * In case the port uses SMI-controlled PHY, poll its status with 	 * mii_tick() and update MAC settings accordingly. 	 */
name|reg
operator|=
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_EUC
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|MVNETA_EUC_POLLING
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_EUC
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* EEE: Low Power Idle */
name|reg
operator|=
name|MVNETA_LPIC0_LILIMIT
argument_list|(
name|MVNETA_LPI_LI
argument_list|)
expr_stmt|;
name|reg
operator||=
name|MVNETA_LPIC0_TSLIMIT
argument_list|(
name|MVNETA_LPI_TS
argument_list|)
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_LPIC0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|MVNETA_LPIC1_TWLIMIT
argument_list|(
name|MVNETA_LPI_TW
argument_list|)
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_LPIC1
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|MVNETA_LPIC2_MUSTSET
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_LPIC2
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Port MAC Control set 0 */
name|reg
operator|=
name|MVNETA_PMACC0_MUSTSET
expr_stmt|;
comment|/* must write 0x1 */
name|reg
operator|&=
operator|~
name|MVNETA_PMACC0_PORTEN
expr_stmt|;
comment|/* port is still disabled */
name|reg
operator||=
name|MVNETA_PMACC0_FRAMESIZELIMIT
argument_list|(
name|MVNETA_MAX_FRAME
argument_list|)
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PMACC0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Port MAC Control set 2 */
name|reg
operator|=
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_PMACC2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|phy_mode
condition|)
block|{
case|case
name|MVNETA_PHY_QSGMII
case|:
name|reg
operator||=
operator|(
name|MVNETA_PMACC2_PCSEN
operator||
name|MVNETA_PMACC2_RGMIIEN
operator|)
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PSERDESCFG
argument_list|,
name|MVNETA_PSERDESCFG_QSGMII
argument_list|)
expr_stmt|;
break|break;
case|case
name|MVNETA_PHY_SGMII
case|:
name|reg
operator||=
operator|(
name|MVNETA_PMACC2_PCSEN
operator||
name|MVNETA_PMACC2_RGMIIEN
operator|)
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PSERDESCFG
argument_list|,
name|MVNETA_PSERDESCFG_SGMII
argument_list|)
expr_stmt|;
break|break;
case|case
name|MVNETA_PHY_RGMII
case|:
case|case
name|MVNETA_PHY_RGMII_ID
case|:
name|reg
operator||=
name|MVNETA_PMACC2_RGMIIEN
expr_stmt|;
break|break;
block|}
name|reg
operator||=
name|MVNETA_PMACC2_MUSTSET
expr_stmt|;
name|reg
operator|&=
operator|~
name|MVNETA_PMACC2_PORTMACRESET
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PMACC2
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Port Configuration Extended: enable Tx CRC generation */
name|reg
operator|=
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_PXCX
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|MVNETA_PXCX_TXCRCDIS
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PXCX
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* clear MIB counter registers(clear by read) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|mvneta_mib_list
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mvneta_mib_list
index|[
name|i
index|]
operator|.
name|reg64
condition|)
name|MVNETA_READ_MIB_8
argument_list|(
name|sc
argument_list|,
name|mvneta_mib_list
index|[
name|i
index|]
operator|.
name|regnum
argument_list|)
expr_stmt|;
else|else
name|MVNETA_READ_MIB_4
argument_list|(
name|sc
argument_list|,
name|mvneta_mib_list
index|[
name|i
index|]
operator|.
name|regnum
argument_list|)
expr_stmt|;
block|}
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_PDFC
argument_list|)
expr_stmt|;
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_POFC
argument_list|)
expr_stmt|;
comment|/* Set SDC register except IPGINT bits */
name|reg
operator|=
name|MVNETA_SDC_RXBSZ_16_64BITWORDS
expr_stmt|;
name|reg
operator||=
name|MVNETA_SDC_TXBSZ_16_64BITWORDS
expr_stmt|;
name|reg
operator||=
name|MVNETA_SDC_BLMR
expr_stmt|;
name|reg
operator||=
name|MVNETA_SDC_BLMT
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_SDC
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|mvneta_dmamap_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return;
operator|*
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|int
name|mvneta_ring_alloc_rx_queue
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|,
name|int
name|q
parameter_list|)
block|{
name|struct
name|mvneta_rx_ring
modifier|*
name|rx
decl_stmt|;
name|struct
name|mvneta_buf
modifier|*
name|rxbuf
decl_stmt|;
name|bus_dmamap_t
name|dmap
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
name|q
operator|>=
name|MVNETA_RX_QNUM_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|rx
operator|=
name|MVNETA_RX_RING
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|rx
operator|->
name|ring_mtx
argument_list|,
literal|"mvneta_rx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* Allocate DMA memory for Rx descriptors */
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|rx_dtag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
operator|(
name|rx
operator|->
name|desc
operator|)
argument_list|,
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_ZERO
argument_list|,
operator|&
name|rx
operator|->
name|desc_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|rx
operator|->
name|desc
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|rx_dtag
argument_list|,
name|rx
operator|->
name|desc_map
argument_list|,
name|rx
operator|->
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mvneta_rx_desc
argument_list|)
operator|*
name|MVNETA_RX_RING_CNT
argument_list|,
name|mvneta_dmamap_cb
argument_list|,
operator|&
name|rx
operator|->
name|desc_pa
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MVNETA_RX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|rxbuf_dtag
argument_list|,
literal|0
argument_list|,
operator|&
name|dmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Failed to create DMA map for Rx buffer num: %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|rxbuf
operator|=
operator|&
name|rx
operator|->
name|rxbuf
index|[
name|i
index|]
expr_stmt|;
name|rxbuf
operator|->
name|dmap
operator|=
name|dmap
expr_stmt|;
name|rxbuf
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|mvneta_ring_dealloc_rx_queue
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"DMA Ring buffer allocation failure.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|mvneta_ring_alloc_tx_queue
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|,
name|int
name|q
parameter_list|)
block|{
name|struct
name|mvneta_tx_ring
modifier|*
name|tx
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|q
operator|>=
name|MVNETA_TX_QNUM_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|tx
operator|=
name|MVNETA_TX_RING
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|tx
operator|->
name|ring_mtx
argument_list|,
literal|"mvneta_tx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|tx_dtag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
operator|(
name|tx
operator|->
name|desc
operator|)
argument_list|,
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_ZERO
argument_list|,
operator|&
name|tx
operator|->
name|desc_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|tx
operator|->
name|desc
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|tx_dtag
argument_list|,
name|tx
operator|->
name|desc_map
argument_list|,
name|tx
operator|->
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mvneta_tx_desc
argument_list|)
operator|*
name|MVNETA_TX_RING_CNT
argument_list|,
name|mvneta_dmamap_cb
argument_list|,
operator|&
name|tx
operator|->
name|desc_pa
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
ifdef|#
directive|ifdef
name|MVNETA_MULTIQUEUE
name|tx
operator|->
name|br
operator|=
name|buf_ring_alloc
argument_list|(
name|MVNETA_BUFRING_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|,
operator|&
name|tx
operator|->
name|ring_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx
operator|->
name|br
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Could not setup buffer ring for TxQ(%d)\n"
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|mvneta_ring_dealloc_tx_queue
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"DMA Ring buffer allocation failure.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|mvneta_ring_dealloc_tx_queue
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|,
name|int
name|q
parameter_list|)
block|{
name|struct
name|mvneta_tx_ring
modifier|*
name|tx
decl_stmt|;
name|struct
name|mvneta_buf
modifier|*
name|txbuf
decl_stmt|;
name|void
modifier|*
name|kva
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|q
operator|>=
name|MVNETA_TX_QNUM_MAX
condition|)
return|return;
name|tx
operator|=
name|MVNETA_TX_RING
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx
operator|->
name|taskq
operator|!=
name|NULL
condition|)
block|{
comment|/* Remove task */
while|while
condition|(
name|taskqueue_cancel
argument_list|(
name|tx
operator|->
name|taskq
argument_list|,
operator|&
name|tx
operator|->
name|task
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
name|taskqueue_drain
argument_list|(
name|tx
operator|->
name|taskq
argument_list|,
operator|&
name|tx
operator|->
name|task
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MVNETA_MULTIQUEUE
if|if
condition|(
name|tx
operator|->
name|br
operator|!=
name|NULL
condition|)
name|drbr_free
argument_list|(
name|tx
operator|->
name|br
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|txmbuf_dtag
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|mtx_name
argument_list|(
operator|&
name|tx
operator|->
name|ring_mtx
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * It is assumed that maps are being loaded after mutex 			 * is initialized. Therefore we can skip unloading maps 			 * when mutex is empty. 			 */
name|mvneta_tx_lockq
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|mvneta_ring_flush_tx_queue
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|mvneta_tx_unlockq
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MVNETA_TX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|txbuf
operator|=
operator|&
name|tx
operator|->
name|txbuf
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|txbuf
operator|->
name|dmap
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|txmbuf_dtag
argument_list|,
name|txbuf
operator|->
name|dmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"%s: map busy for Tx descriptor (Q%d, %d)"
argument_list|,
name|__func__
argument_list|,
name|q
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|tx
operator|->
name|desc_pa
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|tx_dtag
argument_list|,
name|tx
operator|->
name|desc_map
argument_list|)
expr_stmt|;
name|kva
operator|=
operator|(
name|void
operator|*
operator|)
name|tx
operator|->
name|desc
expr_stmt|;
if|if
condition|(
name|kva
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|tx_dtag
argument_list|,
name|tx
operator|->
name|desc
argument_list|,
name|tx
operator|->
name|desc_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtx_name
argument_list|(
operator|&
name|tx
operator|->
name|ring_mtx
argument_list|)
operator|!=
name|NULL
condition|)
name|mtx_destroy
argument_list|(
operator|&
name|tx
operator|->
name|ring_mtx
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|tx
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|mvneta_ring_dealloc_rx_queue
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|,
name|int
name|q
parameter_list|)
block|{
name|struct
name|mvneta_rx_ring
modifier|*
name|rx
decl_stmt|;
name|struct
name|lro_ctrl
modifier|*
name|lro
decl_stmt|;
name|void
modifier|*
name|kva
decl_stmt|;
if|if
condition|(
name|q
operator|>=
name|MVNETA_RX_QNUM_MAX
condition|)
return|return;
name|rx
operator|=
name|MVNETA_RX_RING
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|mvneta_ring_flush_rx_queue
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|rx
operator|->
name|desc_pa
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|rx_dtag
argument_list|,
name|rx
operator|->
name|desc_map
argument_list|)
expr_stmt|;
name|kva
operator|=
operator|(
name|void
operator|*
operator|)
name|rx
operator|->
name|desc
expr_stmt|;
if|if
condition|(
name|kva
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|rx_dtag
argument_list|,
name|rx
operator|->
name|desc
argument_list|,
name|rx
operator|->
name|desc_map
argument_list|)
expr_stmt|;
name|lro
operator|=
operator|&
name|rx
operator|->
name|lro
expr_stmt|;
name|tcp_lro_free
argument_list|(
name|lro
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtx_name
argument_list|(
operator|&
name|rx
operator|->
name|ring_mtx
argument_list|)
operator|!=
name|NULL
condition|)
name|mtx_destroy
argument_list|(
operator|&
name|rx
operator|->
name|ring_mtx
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|rx
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rx
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|int
name|mvneta_ring_init_rx_queue
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|,
name|int
name|q
parameter_list|)
block|{
name|struct
name|mvneta_rx_ring
modifier|*
name|rx
decl_stmt|;
name|struct
name|lro_ctrl
modifier|*
name|lro
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|q
operator|>=
name|MVNETA_RX_QNUM_MAX
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|rx
operator|=
name|MVNETA_RX_RING
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|rx
operator|->
name|dma
operator|=
name|rx
operator|->
name|cpu
operator|=
literal|0
expr_stmt|;
name|rx
operator|->
name|queue_th_received
operator|=
name|MVNETA_RXTH_COUNT
expr_stmt|;
name|rx
operator|->
name|queue_th_time
operator|=
operator|(
name|get_tclk
argument_list|()
operator|/
literal|1000
operator|)
operator|/
literal|10
expr_stmt|;
comment|/* 0.1 [ms] */
comment|/* Initialize LRO */
name|rx
operator|->
name|lro_enabled
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_LRO
operator|)
operator|!=
literal|0
condition|)
block|{
name|lro
operator|=
operator|&
name|rx
operator|->
name|lro
expr_stmt|;
name|error
operator|=
name|tcp_lro_init
argument_list|(
name|lro
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"LRO Initialization failed!\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|rx
operator|->
name|lro_enabled
operator|=
name|TRUE
expr_stmt|;
name|lro
operator|->
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|mvneta_ring_init_tx_queue
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|,
name|int
name|q
parameter_list|)
block|{
name|struct
name|mvneta_tx_ring
modifier|*
name|tx
decl_stmt|;
name|struct
name|mvneta_buf
modifier|*
name|txbuf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
name|q
operator|>=
name|MVNETA_TX_QNUM_MAX
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|tx
operator|=
name|MVNETA_TX_RING
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
comment|/* Tx handle */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MVNETA_TX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|txbuf
operator|=
operator|&
name|tx
operator|->
name|txbuf
index|[
name|i
index|]
expr_stmt|;
name|txbuf
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
comment|/* Tx handle needs DMA map for busdma_load_mbuf() */
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|txmbuf_dtag
argument_list|,
literal|0
argument_list|,
operator|&
name|txbuf
operator|->
name|dmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"can't create dma map (tx ring %d)\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|tx
operator|->
name|dma
operator|=
name|tx
operator|->
name|cpu
operator|=
literal|0
expr_stmt|;
name|tx
operator|->
name|used
operator|=
literal|0
expr_stmt|;
name|tx
operator|->
name|drv_error
operator|=
literal|0
expr_stmt|;
name|tx
operator|->
name|queue_status
operator|=
name|MVNETA_QUEUE_DISABLED
expr_stmt|;
name|tx
operator|->
name|queue_hung
operator|=
name|FALSE
expr_stmt|;
name|tx
operator|->
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
name|tx
operator|->
name|qidx
operator|=
name|q
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|tx
operator|->
name|task
argument_list|,
literal|0
argument_list|,
name|mvneta_tx_task
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|tx
operator|->
name|taskq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"mvneta_tx_taskq"
argument_list|,
name|M_WAITOK
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|tx
operator|->
name|taskq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|tx
operator|->
name|taskq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s: tx_taskq(%d)"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|q
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|mvneta_ring_flush_tx_queue
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|,
name|int
name|q
parameter_list|)
block|{
name|struct
name|mvneta_tx_ring
modifier|*
name|tx
decl_stmt|;
name|struct
name|mvneta_buf
modifier|*
name|txbuf
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tx
operator|=
name|MVNETA_TX_RING
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|KASSERT_TX_MTX
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
comment|/* Tx handle */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MVNETA_TX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|txbuf
operator|=
operator|&
name|tx
operator|->
name|txbuf
index|[
name|i
index|]
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|txmbuf_dtag
argument_list|,
name|txbuf
operator|->
name|dmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|txbuf
operator|->
name|m
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|txbuf
operator|->
name|m
argument_list|)
expr_stmt|;
name|txbuf
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|tx
operator|->
name|dma
operator|=
name|tx
operator|->
name|cpu
operator|=
literal|0
expr_stmt|;
name|tx
operator|->
name|used
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|mvneta_ring_flush_rx_queue
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|,
name|int
name|q
parameter_list|)
block|{
name|struct
name|mvneta_rx_ring
modifier|*
name|rx
decl_stmt|;
name|struct
name|mvneta_buf
modifier|*
name|rxbuf
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rx
operator|=
name|MVNETA_RX_RING
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|KASSERT_RX_MTX
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
comment|/* Rx handle */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MVNETA_RX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|rxbuf
operator|=
operator|&
name|rx
operator|->
name|rxbuf
index|[
name|i
index|]
expr_stmt|;
name|mvneta_rx_buf_free
argument_list|(
name|sc
argument_list|,
name|rxbuf
argument_list|)
expr_stmt|;
block|}
name|rx
operator|->
name|dma
operator|=
name|rx
operator|->
name|cpu
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Rx/Tx Queue Control  */
end_comment

begin_function
name|STATIC
name|int
name|mvneta_rx_queue_init
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|q
parameter_list|)
block|{
name|struct
name|mvneta_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mvneta_rx_ring
modifier|*
name|rx
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|KASSERT_RX_MTX
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|rx
operator|=
name|MVNETA_RX_RING
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|DASSERT
argument_list|(
name|rx
operator|->
name|desc_pa
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* descriptor address */
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PRXDQA
argument_list|(
name|q
argument_list|)
argument_list|,
name|rx
operator|->
name|desc_pa
argument_list|)
expr_stmt|;
comment|/* Rx buffer size and descriptor ring size */
name|reg
operator|=
name|MVNETA_PRXDQS_BUFFERSIZE
argument_list|(
name|MVNETA_PACKET_SIZE
operator|>>
literal|3
argument_list|)
expr_stmt|;
name|reg
operator||=
name|MVNETA_PRXDQS_DESCRIPTORSQUEUESIZE
argument_list|(
name|MVNETA_RX_RING_CNT
argument_list|)
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PRXDQS
argument_list|(
name|q
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MVNETA_KTR
name|CTR3
argument_list|(
name|KTR_SPARE2
argument_list|,
literal|"%s PRXDQS(%d): %#x"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|q
argument_list|,
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_PRXDQS
argument_list|(
name|q
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Rx packet offset address */
name|reg
operator|=
name|MVNETA_PRXC_PACKETOFFSET
argument_list|(
name|MVNETA_PACKET_OFFSET
operator|>>
literal|3
argument_list|)
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PRXC
argument_list|(
name|q
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MVNETA_KTR
name|CTR3
argument_list|(
name|KTR_SPARE2
argument_list|,
literal|"%s PRXC(%d): %#x"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|q
argument_list|,
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_PRXC
argument_list|(
name|q
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* if DMA is not working, register is not updated */
name|DASSERT
argument_list|(
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_PRXDQA
argument_list|(
name|q
argument_list|)
argument_list|)
operator|==
name|rx
operator|->
name|desc_pa
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|mvneta_tx_queue_init
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|q
parameter_list|)
block|{
name|struct
name|mvneta_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mvneta_tx_ring
modifier|*
name|tx
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|KASSERT_TX_MTX
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|tx
operator|=
name|MVNETA_TX_RING
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|DASSERT
argument_list|(
name|tx
operator|->
name|desc_pa
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* descriptor address */
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PTXDQA
argument_list|(
name|q
argument_list|)
argument_list|,
name|tx
operator|->
name|desc_pa
argument_list|)
expr_stmt|;
comment|/* descriptor ring size */
name|reg
operator|=
name|MVNETA_PTXDQS_DQS
argument_list|(
name|MVNETA_TX_RING_CNT
argument_list|)
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PTXDQS
argument_list|(
name|q
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* if DMA is not working, register is not updated */
name|DASSERT
argument_list|(
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_PTXDQA
argument_list|(
name|q
argument_list|)
argument_list|)
operator|==
name|tx
operator|->
name|desc_pa
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|mvneta_rx_queue_enable
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|q
parameter_list|)
block|{
name|struct
name|mvneta_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mvneta_rx_ring
modifier|*
name|rx
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|rx
operator|=
name|MVNETA_RX_RING
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|KASSERT_RX_MTX
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
comment|/* Set Rx interrupt threshold */
name|reg
operator|=
name|MVNETA_PRXDQTH_ODT
argument_list|(
name|rx
operator|->
name|queue_th_received
argument_list|)
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PRXDQTH
argument_list|(
name|q
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|MVNETA_PRXITTH_RITT
argument_list|(
name|rx
operator|->
name|queue_th_time
argument_list|)
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PRXITTH
argument_list|(
name|q
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Unmask RXTX_TH Intr. */
name|reg
operator|=
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_PRXTXTIM
argument_list|)
expr_stmt|;
name|reg
operator||=
name|MVNETA_PRXTXTI_RBICTAPQ
argument_list|(
name|q
argument_list|)
expr_stmt|;
comment|/* Rx Buffer Interrupt Coalese */
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PRXTXTIM
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Enable Rx queue */
name|reg
operator|=
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_RQC
argument_list|)
operator|&
name|MVNETA_RQC_EN_MASK
expr_stmt|;
name|reg
operator||=
name|MVNETA_RQC_ENQ
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_RQC
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|rx
operator|->
name|queue_status
operator|=
name|MVNETA_QUEUE_WORKING
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|mvneta_tx_queue_enable
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|q
parameter_list|)
block|{
name|struct
name|mvneta_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mvneta_tx_ring
modifier|*
name|tx
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|tx
operator|=
name|MVNETA_TX_RING
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|KASSERT_TX_MTX
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
comment|/* Enable Tx queue */
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_TQC
argument_list|,
name|MVNETA_TQC_ENQ
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|tx
operator|->
name|queue_status
operator|=
name|MVNETA_QUEUE_IDLE
expr_stmt|;
name|tx
operator|->
name|queue_hung
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|__inline
name|void
name|mvneta_rx_lockq
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|,
name|int
name|q
parameter_list|)
block|{
name|DASSERT
argument_list|(
name|q
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|DASSERT
argument_list|(
name|q
operator|<
name|MVNETA_RX_QNUM_MAX
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|rx_ring
index|[
name|q
index|]
operator|.
name|ring_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|__inline
name|void
name|mvneta_rx_unlockq
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|,
name|int
name|q
parameter_list|)
block|{
name|DASSERT
argument_list|(
name|q
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|DASSERT
argument_list|(
name|q
operator|<
name|MVNETA_RX_QNUM_MAX
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|rx_ring
index|[
name|q
index|]
operator|.
name|ring_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|__inline
name|int
name|__unused
name|mvneta_tx_trylockq
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|,
name|int
name|q
parameter_list|)
block|{
name|DASSERT
argument_list|(
name|q
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|DASSERT
argument_list|(
name|q
operator|<
name|MVNETA_TX_QNUM_MAX
argument_list|)
expr_stmt|;
return|return
operator|(
name|mtx_trylock
argument_list|(
operator|&
name|sc
operator|->
name|tx_ring
index|[
name|q
index|]
operator|.
name|ring_mtx
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|__inline
name|void
name|mvneta_tx_lockq
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|,
name|int
name|q
parameter_list|)
block|{
name|DASSERT
argument_list|(
name|q
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|DASSERT
argument_list|(
name|q
operator|<
name|MVNETA_TX_QNUM_MAX
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|tx_ring
index|[
name|q
index|]
operator|.
name|ring_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|__inline
name|void
name|mvneta_tx_unlockq
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|,
name|int
name|q
parameter_list|)
block|{
name|DASSERT
argument_list|(
name|q
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|DASSERT
argument_list|(
name|q
operator|<
name|MVNETA_TX_QNUM_MAX
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|tx_ring
index|[
name|q
index|]
operator|.
name|ring_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Interrupt Handlers  */
end_comment

begin_function
name|STATIC
name|void
name|mvneta_disable_intr
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|)
block|{
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_EUIM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_EUIC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PRXTXTIM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PRXTXTIC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PRXTXIM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PRXTXIC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PMIM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PMIC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PIE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|mvneta_enable_intr
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
comment|/* Enable Summary Bit to check all interrupt cause. */
name|reg
operator|=
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_PRXTXTIM
argument_list|)
expr_stmt|;
name|reg
operator||=
name|MVNETA_PRXTXTI_PMISCICSUMMARY
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PRXTXTIM
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|use_inband_status
condition|)
block|{
comment|/* Enable Port MISC Intr. (via RXTX_TH_Summary bit) */
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PMIM
argument_list|,
name|MVNETA_PMI_PHYSTATUSCHNG
operator||
name|MVNETA_PMI_LINKCHANGE
operator||
name|MVNETA_PMI_PSCSYNCCHANGE
argument_list|)
expr_stmt|;
block|}
comment|/* Enable All Queue Interrupt */
name|reg
operator|=
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_PIE
argument_list|)
expr_stmt|;
name|reg
operator||=
name|MVNETA_PIE_RXPKTINTRPTENB_MASK
expr_stmt|;
name|reg
operator||=
name|MVNETA_PIE_TXPKTINTRPTENB_MASK
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PIE
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|mvneta_rxtxth_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|mvneta_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|uint32_t
name|ic
decl_stmt|,
name|queues
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
ifdef|#
directive|ifdef
name|MVNETA_KTR
name|CTR1
argument_list|(
name|KTR_SPARE2
argument_list|,
literal|"%s got RXTX_TH_Intr"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ic
operator|=
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_PRXTXTIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|==
literal|0
condition|)
return|return;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PRXTXTIC
argument_list|,
operator|~
name|ic
argument_list|)
expr_stmt|;
comment|/* Ack maintance interrupt first */
if|if
condition|(
name|__predict_false
argument_list|(
operator|(
name|ic
operator|&
name|MVNETA_PRXTXTI_PMISCICSUMMARY
operator|)
operator|&&
name|sc
operator|->
name|use_inband_status
argument_list|)
condition|)
block|{
name|mvneta_sc_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mvneta_misc_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mvneta_sc_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
argument_list|)
condition|)
return|return;
comment|/* RxTxTH interrupt */
name|queues
operator|=
name|MVNETA_PRXTXTI_GET_RBICTAPQ
argument_list|(
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
name|queues
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|MVNETA_KTR
name|CTR1
argument_list|(
name|KTR_SPARE2
argument_list|,
literal|"%s got PRXTXTIC: +RXEOF"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* At the moment the driver support only one RX queue. */
name|DASSERT
argument_list|(
name|MVNETA_IS_QUEUE_SET
argument_list|(
name|queues
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|mvneta_rx
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|STATIC
name|int
name|mvneta_misc_intr
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|ic
decl_stmt|;
name|int
name|claimed
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|MVNETA_KTR
name|CTR1
argument_list|(
name|KTR_SPARE2
argument_list|,
literal|"%s got MISC_INTR"
argument_list|,
name|sc
operator|->
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|KASSERT_SC_MTX
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ic
operator|=
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_PMIC
argument_list|)
expr_stmt|;
name|ic
operator|&=
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_PMIM
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|==
literal|0
condition|)
break|break;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PMIC
argument_list|,
operator|~
name|ic
argument_list|)
expr_stmt|;
name|claimed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ic
operator|&
operator|(
name|MVNETA_PMI_PHYSTATUSCHNG
operator||
name|MVNETA_PMI_LINKCHANGE
operator||
name|MVNETA_PMI_PSCSYNCCHANGE
operator|)
condition|)
name|mvneta_link_isr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|claimed
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|mvneta_tick
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|mvneta_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mvneta_tx_ring
modifier|*
name|tx
decl_stmt|;
name|struct
name|mvneta_rx_ring
modifier|*
name|rx
decl_stmt|;
name|int
name|q
decl_stmt|;
name|uint32_t
name|fc_prev
decl_stmt|,
name|fc_curr
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
comment|/* 	 * This is done before mib update to get the right stats 	 * for this tick. 	 */
name|mvneta_tx_drain
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Extract previous flow-control frame received counter. */
name|fc_prev
operator|=
name|sc
operator|->
name|sysctl_mib
index|[
name|MVNETA_MIB_FC_GOOD_IDX
index|]
operator|.
name|counter
expr_stmt|;
comment|/* Read mib registers (clear by read). */
name|mvneta_update_mib
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Extract current flow-control frame received counter. */
name|fc_curr
operator|=
name|sc
operator|->
name|sysctl_mib
index|[
name|MVNETA_MIB_FC_GOOD_IDX
index|]
operator|.
name|counter
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|phy_attached
operator|&&
name|sc
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
name|mvneta_sc_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mii_tick
argument_list|(
name|sc
operator|->
name|mii
argument_list|)
expr_stmt|;
comment|/* Adjust MAC settings */
name|mvneta_adjust_link
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mvneta_sc_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We were unable to refill the rx queue and left the rx func, leaving 	 * the ring without mbuf and no way to call the refill func. 	 */
for|for
control|(
name|q
operator|=
literal|0
init|;
name|q
operator|<
name|MVNETA_RX_QNUM_MAX
condition|;
name|q
operator|++
control|)
block|{
name|rx
operator|=
name|MVNETA_RX_RING
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|rx
operator|->
name|needs_refill
operator|==
name|TRUE
condition|)
block|{
name|mvneta_rx_lockq
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|mvneta_rx_queue_refill
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|mvneta_rx_unlockq
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Watchdog: 	 * - check if queue is mark as hung. 	 * - ignore hung status if we received some pause frame 	 *   as hardware may have paused packet transmit. 	 */
for|for
control|(
name|q
operator|=
literal|0
init|;
name|q
operator|<
name|MVNETA_TX_QNUM_MAX
condition|;
name|q
operator|++
control|)
block|{
comment|/* 		 * We should take queue lock, but as we only read 		 * queue status we can do it without lock, we may 		 * only missdetect queue status for one tick. 		 */
name|tx
operator|=
name|MVNETA_TX_RING
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx
operator|->
name|queue_hung
operator|&&
operator|(
name|fc_curr
operator|-
name|fc_prev
operator|)
operator|==
literal|0
condition|)
goto|goto
name|timeout
goto|;
block|}
name|callout_schedule
argument_list|(
operator|&
name|sc
operator|->
name|tick_ch
argument_list|,
name|hz
argument_list|)
expr_stmt|;
return|return;
name|timeout
label|:
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"watchdog timeout\n"
argument_list|)
expr_stmt|;
name|mvneta_sc_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|counter_watchdog
operator|++
expr_stmt|;
name|sc
operator|->
name|counter_watchdog_mib
operator|++
expr_stmt|;
comment|/* Trigger reinitialize sequence. */
name|mvneta_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mvneta_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mvneta_sc_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|mvneta_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|MVNETA_MULTIQUEUE
name|struct
name|mvneta_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mvneta_tx_ring
modifier|*
name|tx
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|size_t
name|q
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
for|for
control|(
name|q
operator|=
literal|0
init|;
name|q
operator|<
name|MVNETA_TX_QNUM_MAX
condition|;
name|q
operator|++
control|)
block|{
name|tx
operator|=
name|MVNETA_TX_RING
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|mvneta_tx_lockq
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|buf_ring_dequeue_sc
argument_list|(
name|tx
operator|->
name|br
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|mvneta_tx_unlockq
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|if_qflush
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|mvneta_tx_task
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|mvneta_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mvneta_tx_ring
modifier|*
name|tx
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|tx
operator|=
name|arg
expr_stmt|;
name|ifp
operator|=
name|tx
operator|->
name|ifp
expr_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|mvneta_tx_lockq
argument_list|(
name|sc
argument_list|,
name|tx
operator|->
name|qidx
argument_list|)
expr_stmt|;
name|error
operator|=
name|mvneta_xmit_locked
argument_list|(
name|sc
argument_list|,
name|tx
operator|->
name|qidx
argument_list|)
expr_stmt|;
name|mvneta_tx_unlockq
argument_list|(
name|sc
argument_list|,
name|tx
operator|->
name|qidx
argument_list|)
expr_stmt|;
comment|/* Try again */
if|if
condition|(
name|__predict_false
argument_list|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|ENETDOWN
argument_list|)
condition|)
block|{
name|pause
argument_list|(
literal|"mvneta_tx_task_sleep"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|tx
operator|->
name|taskq
argument_list|,
operator|&
name|tx
operator|->
name|task
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|STATIC
name|int
name|mvneta_xmitfast_locked
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|,
name|int
name|q
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|mvneta_tx_ring
modifier|*
name|tx
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|KASSERT_TX_MTX
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|tx
operator|=
name|MVNETA_TX_RING
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
comment|/* Dont enqueue packet if the queue is disabled. */
if|if
condition|(
name|__predict_false
argument_list|(
name|tx
operator|->
name|queue_status
operator|==
name|MVNETA_QUEUE_DISABLED
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|m
argument_list|)
expr_stmt|;
operator|*
name|m
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
block|}
comment|/* Reclaim mbuf if above threshold. */
if|if
condition|(
name|__predict_true
argument_list|(
name|tx
operator|->
name|used
operator|>
name|MVNETA_TX_RECLAIM_COUNT
argument_list|)
condition|)
name|mvneta_tx_queue_complete
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
comment|/* Do not call transmit path if queue is already too full. */
if|if
condition|(
name|__predict_false
argument_list|(
name|tx
operator|->
name|used
operator|>
name|MVNETA_TX_RING_CNT
operator|-
name|MVNETA_TX_SEGLIMIT
argument_list|)
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|error
operator|=
name|mvneta_tx_queue
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|error
operator|!=
literal|0
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Send a copy of the frame to the BPF listener */
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
operator|*
name|m
argument_list|)
expr_stmt|;
comment|/* Set watchdog on */
name|tx
operator|->
name|watchdog_time
operator|=
name|ticks
expr_stmt|;
name|tx
operator|->
name|queue_status
operator|=
name|MVNETA_QUEUE_WORKING
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MVNETA_MULTIQUEUE
end_ifdef

begin_function
name|STATIC
name|int
name|mvneta_transmit
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|mvneta_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mvneta_tx_ring
modifier|*
name|tx
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|q
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
comment|/* Use default queue if there is no flow id as thread can migrate. */
if|if
condition|(
name|__predict_true
argument_list|(
name|M_HASHTYPE_GET
argument_list|(
name|m
argument_list|)
operator|!=
name|M_HASHTYPE_NONE
argument_list|)
condition|)
name|q
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|%
name|MVNETA_TX_QNUM_MAX
expr_stmt|;
else|else
name|q
operator|=
literal|0
expr_stmt|;
name|tx
operator|=
name|MVNETA_TX_RING
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
comment|/* If buf_ring is full start transmit immediatly. */
if|if
condition|(
name|buf_ring_full
argument_list|(
name|tx
operator|->
name|br
argument_list|)
condition|)
block|{
name|mvneta_tx_lockq
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|mvneta_xmit_locked
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|mvneta_tx_unlockq
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the buf_ring is empty we will not reorder packets. 	 * If the lock is available transmit without using buf_ring. 	 */
if|if
condition|(
name|buf_ring_empty
argument_list|(
name|tx
operator|->
name|br
argument_list|)
operator|&&
name|mvneta_tx_trylockq
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|mvneta_xmitfast_locked
argument_list|(
name|sc
argument_list|,
name|q
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
name|mvneta_tx_unlockq
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
name|error
operator|==
literal|0
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Transmit can fail in fastpath. */
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|==
name|NULL
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Enqueue then schedule taskqueue. */
name|error
operator|=
name|drbr_enqueue
argument_list|(
name|ifp
argument_list|,
name|tx
operator|->
name|br
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|error
operator|!=
literal|0
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|taskqueue_enqueue
argument_list|(
name|tx
operator|->
name|taskq
argument_list|,
operator|&
name|tx
operator|->
name|task
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|mvneta_xmit_locked
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|,
name|int
name|q
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mvneta_tx_ring
modifier|*
name|tx
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
name|KASSERT_TX_MTX
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
name|tx
operator|=
name|MVNETA_TX_RING
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|drbr_peek
argument_list|(
name|ifp
argument_list|,
name|tx
operator|->
name|br
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|mvneta_xmitfast_locked
argument_list|(
name|sc
argument_list|,
name|q
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|error
operator|!=
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|drbr_putback
argument_list|(
name|ifp
argument_list|,
name|tx
operator|->
name|br
argument_list|,
name|m
argument_list|)
expr_stmt|;
else|else
name|drbr_advance
argument_list|(
name|ifp
argument_list|,
name|tx
operator|->
name|br
argument_list|)
expr_stmt|;
break|break;
block|}
name|drbr_advance
argument_list|(
name|ifp
argument_list|,
name|tx
operator|->
name|br
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !MVNETA_MULTIQUEUE */
end_comment

begin_function
name|STATIC
name|void
name|mvneta_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|mvneta_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mvneta_tx_ring
modifier|*
name|tx
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|tx
operator|=
name|MVNETA_TX_RING
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mvneta_tx_lockq
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|mvneta_xmit_locked
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mvneta_tx_unlockq
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Handle retransmit in the background taskq. */
if|if
condition|(
name|__predict_false
argument_list|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|ENETDOWN
argument_list|)
condition|)
name|taskqueue_enqueue
argument_list|(
name|tx
operator|->
name|taskq
argument_list|,
operator|&
name|tx
operator|->
name|task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|int
name|mvneta_xmit_locked
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|,
name|int
name|q
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mvneta_tx_ring
modifier|*
name|tx
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
name|KASSERT_TX_MTX
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
name|tx
operator|=
name|MVNETA_TX_RING
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
block|{
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|error
operator|=
name|mvneta_xmitfast_locked
argument_list|(
name|sc
argument_list|,
name|q
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|error
operator|!=
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|IFQ_DRV_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|STATIC
name|int
name|mvneta_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|mvneta_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mvneta_rx_ring
modifier|*
name|rx
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
name|int
name|error
decl_stmt|,
name|mask
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|int
name|q
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|ifr
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
name|mvneta_sc_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|flags
operator|=
name|ifp
operator|->
name|if_flags
operator|^
name|sc
operator|->
name|mvneta_if_flags
expr_stmt|;
if|if
condition|(
name|flags
operator|!=
literal|0
condition|)
name|sc
operator|->
name|mvneta_if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|IFF_PROMISC
operator|)
operator|!=
literal|0
condition|)
name|mvneta_filter_setup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mvneta_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mvneta_if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|phy_attached
condition|)
name|mii_mediachg
argument_list|(
name|sc
operator|->
name|mii
argument_list|)
expr_stmt|;
name|mvneta_sc_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|mvneta_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mvneta_if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|mvneta_sc_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
if|if
condition|(
name|ifp
operator|->
name|if_mtu
operator|>
name|MVNETA_MAX_CSUM_MTU
operator|&&
name|ifr
operator|->
name|ifr_reqcap
operator|&
name|IFCAP_TXCSUM
condition|)
name|ifr
operator|->
name|ifr_reqcap
operator|&=
operator|~
name|IFCAP_TXCSUM
expr_stmt|;
name|mask
operator|=
name|ifp
operator|->
name|if_capenable
operator|^
name|ifr
operator|->
name|ifr_reqcap
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_HWCSUM
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_HWCSUM
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_HWCSUM
operator|&
name|ifr
operator|->
name|ifr_reqcap
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
condition|)
name|ifp
operator|->
name|if_hwassist
operator|=
name|CSUM_IP
operator||
name|CSUM_TCP
operator||
name|CSUM_UDP
expr_stmt|;
else|else
name|ifp
operator|->
name|if_hwassist
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_LRO
condition|)
block|{
name|mvneta_sc_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_LRO
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|q
operator|=
literal|0
init|;
name|q
operator|<
name|MVNETA_RX_QNUM_MAX
condition|;
name|q
operator|++
control|)
block|{
name|rx
operator|=
name|MVNETA_RX_RING
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|rx
operator|->
name|lro_enabled
operator|=
operator|!
name|rx
operator|->
name|lro_enabled
expr_stmt|;
block|}
block|}
name|mvneta_sc_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|VLAN_CAPABILITIES
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMEDIA
case|:
if|if
condition|(
operator|(
name|IFM_SUBTYPE
argument_list|(
name|ifr
operator|->
name|ifr_media
argument_list|)
operator|==
name|IFM_1000_T
operator|||
name|IFM_SUBTYPE
argument_list|(
name|ifr
operator|->
name|ifr_media
argument_list|)
operator|==
name|IFM_2500_T
operator|)
operator|&&
operator|(
name|ifr
operator|->
name|ifr_media
operator|&
name|IFM_FDX
operator|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s half-duplex unsupported\n"
argument_list|,
name|IFM_SUBTYPE
argument_list|(
name|ifr
operator|->
name|ifr_media
argument_list|)
operator|==
name|IFM_1000_T
condition|?
literal|"1000Base-T"
else|:
literal|"2500Base-T"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
case|case
name|SIOCGIFMEDIA
case|:
comment|/* FALLTHROUGH */
if|if
condition|(
operator|!
name|sc
operator|->
name|phy_attached
condition|)
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|mvneta_ifmedia
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|mii
operator|->
name|mii_media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMTU
case|:
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|<
literal|68
operator|||
name|ifr
operator|->
name|ifr_mtu
operator|>
name|MVNETA_MAX_FRAME
operator|-
name|MVNETA_ETHER_SIZE
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
name|mvneta_sc_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_mtu
operator|>
name|MVNETA_MAX_CSUM_MTU
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_TXCSUM
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TXCSUM
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|=
name|CSUM_IP
operator||
name|CSUM_TCP
operator||
name|CSUM_UDP
expr_stmt|;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
comment|/* Trigger reinitialize sequence */
name|mvneta_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mvneta_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|mvneta_sc_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|mvneta_init_locked
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|mvneta_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
name|int
name|q
decl_stmt|,
name|cpu
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
if|if
condition|(
operator|!
name|device_is_attached
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
operator|||
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
return|return;
name|mvneta_disable_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|tick_ch
argument_list|)
expr_stmt|;
comment|/* Get the latest mac address */
name|bcopy
argument_list|(
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|sc
operator|->
name|enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|mvneta_set_mac_address
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|enaddr
argument_list|)
expr_stmt|;
name|mvneta_filter_setup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Start DMA Engine */
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PRXINIT
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PTXINIT
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PACC
argument_list|,
name|MVNETA_PACC_ACCELERATIONMODE_EDM
argument_list|)
expr_stmt|;
comment|/* Enable port */
name|reg
operator|=
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_PMACC0
argument_list|)
expr_stmt|;
name|reg
operator||=
name|MVNETA_PMACC0_PORTEN
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PMACC0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Allow access to each TXQ/RXQ from both CPU's */
for|for
control|(
name|cpu
operator|=
literal|0
init|;
name|cpu
operator|<
name|mp_ncpus
condition|;
operator|++
name|cpu
control|)
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PCP2Q
argument_list|(
name|cpu
argument_list|)
argument_list|,
name|MVNETA_PCP2Q_TXQEN_MASK
operator||
name|MVNETA_PCP2Q_RXQEN_MASK
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
literal|0
init|;
name|q
operator|<
name|MVNETA_RX_QNUM_MAX
condition|;
name|q
operator|++
control|)
block|{
name|mvneta_rx_lockq
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|mvneta_rx_queue_refill
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|mvneta_rx_unlockq
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sc
operator|->
name|phy_attached
condition|)
name|mvneta_linkup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Enable interrupt */
name|mvneta_enable_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Set Counter */
name|callout_schedule
argument_list|(
operator|&
name|sc
operator|->
name|tick_ch
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|mvneta_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|mvneta_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|mvneta_sc_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mvneta_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|phy_attached
condition|)
name|mii_mediachg
argument_list|(
name|sc
operator|->
name|mii
argument_list|)
expr_stmt|;
name|mvneta_sc_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|STATIC
name|void
name|mvneta_stop_locked
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mvneta_rx_ring
modifier|*
name|rx
decl_stmt|;
name|struct
name|mvneta_tx_ring
modifier|*
name|tx
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
name|int
name|q
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
operator|||
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
name|mvneta_disable_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|tick_ch
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
comment|/* Link down */
if|if
condition|(
name|sc
operator|->
name|linkup
operator|==
name|TRUE
condition|)
name|mvneta_linkdown
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Reset the MAC Port Enable bit */
name|reg
operator|=
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_PMACC0
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|MVNETA_PMACC0_PORTEN
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PMACC0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Disable each of queue */
for|for
control|(
name|q
operator|=
literal|0
init|;
name|q
operator|<
name|MVNETA_RX_QNUM_MAX
condition|;
name|q
operator|++
control|)
block|{
name|rx
operator|=
name|MVNETA_RX_RING
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|mvneta_rx_lockq
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|mvneta_ring_flush_rx_queue
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|mvneta_rx_unlockq
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Hold Reset state of DMA Engine 	 * (must write 0x0 to restart it) 	 */
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PRXINIT
argument_list|,
literal|0x00000001
argument_list|)
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PTXINIT
argument_list|,
literal|0x00000001
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
literal|0
init|;
name|q
operator|<
name|MVNETA_TX_QNUM_MAX
condition|;
name|q
operator|++
control|)
block|{
name|tx
operator|=
name|MVNETA_TX_RING
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|mvneta_tx_lockq
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|mvneta_ring_flush_tx_queue
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|mvneta_tx_unlockq
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|STATIC
name|void
name|mvneta_stop
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|)
block|{
name|mvneta_sc_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mvneta_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mvneta_sc_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|int
name|mvneta_mediachange
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|mvneta_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|phy_attached
operator|&&
operator|!
name|sc
operator|->
name|use_inband_status
condition|)
block|{
comment|/* We shouldn't be here */
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"Cannot change media in fixed-link mode!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|use_inband_status
condition|)
block|{
name|mvneta_update_media
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mvneta_ifmedia
operator|.
name|ifm_media
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|mvneta_sc_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Update PHY */
name|mii_mediachg
argument_list|(
name|sc
operator|->
name|mii
argument_list|)
expr_stmt|;
name|mvneta_sc_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|mvneta_get_media
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|uint32_t
name|psr
decl_stmt|;
name|psr
operator|=
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_PSR
argument_list|)
expr_stmt|;
comment|/* Speed */
if|if
condition|(
name|psr
operator|&
name|MVNETA_PSR_GMIISPEED
condition|)
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER_SUBTYPE_SET
argument_list|(
name|IFM_1000_T
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|psr
operator|&
name|MVNETA_PSR_MIISPEED
condition|)
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER_SUBTYPE_SET
argument_list|(
name|IFM_100_TX
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|psr
operator|&
name|MVNETA_PSR_LINKUP
condition|)
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER_SUBTYPE_SET
argument_list|(
name|IFM_10_T
argument_list|)
expr_stmt|;
comment|/* Duplex */
if|if
condition|(
name|psr
operator|&
name|MVNETA_PSR_FULLDX
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_FDX
expr_stmt|;
comment|/* Link */
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
if|if
condition|(
name|psr
operator|&
name|MVNETA_PSR_LINKUP
condition|)
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|mvneta_mediastatus
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|mvneta_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|phy_attached
operator|&&
operator|!
name|sc
operator|->
name|use_inband_status
condition|)
block|{
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
operator||
name|IFM_ACTIVE
expr_stmt|;
return|return;
block|}
name|mvneta_sc_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|use_inband_status
condition|)
block|{
name|mvneta_get_media
argument_list|(
name|sc
argument_list|,
name|ifmr
argument_list|)
expr_stmt|;
name|mvneta_sc_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|mii
operator|=
name|sc
operator|->
name|mii
expr_stmt|;
name|mii_pollstat
argument_list|(
name|mii
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|mii
operator|->
name|mii_media_active
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|mii
operator|->
name|mii_media_status
expr_stmt|;
name|mvneta_sc_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Link State Notify  */
end_comment

begin_function
name|STATIC
name|void
name|mvneta_update_autoneg
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
if|if
condition|(
name|enable
condition|)
block|{
name|reg
operator|=
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_PANC
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
operator|(
name|MVNETA_PANC_FORCELINKFAIL
operator||
name|MVNETA_PANC_FORCELINKPASS
operator||
name|MVNETA_PANC_ANFCEN
operator|)
expr_stmt|;
name|reg
operator||=
name|MVNETA_PANC_ANDUPLEXEN
operator||
name|MVNETA_PANC_ANSPEEDEN
operator||
name|MVNETA_PANC_INBANDANEN
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PANC
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_PMACC2
argument_list|)
expr_stmt|;
name|reg
operator||=
name|MVNETA_PMACC2_INBANDANMODE
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PMACC2
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_PSOMSCD
argument_list|)
expr_stmt|;
name|reg
operator||=
name|MVNETA_PSOMSCD_ENABLE
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PSOMSCD
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reg
operator|=
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_PANC
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
operator|(
name|MVNETA_PANC_FORCELINKFAIL
operator||
name|MVNETA_PANC_FORCELINKPASS
operator||
name|MVNETA_PANC_ANDUPLEXEN
operator||
name|MVNETA_PANC_ANSPEEDEN
operator||
name|MVNETA_PANC_INBANDANEN
operator|)
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PANC
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_PMACC2
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|MVNETA_PMACC2_INBANDANMODE
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PMACC2
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_PSOMSCD
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|MVNETA_PSOMSCD_ENABLE
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PSOMSCD
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|STATIC
name|int
name|mvneta_update_media
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|,
name|int
name|media
parameter_list|)
block|{
name|int
name|reg
decl_stmt|,
name|err
decl_stmt|;
name|boolean_t
name|running
decl_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
name|mvneta_sc_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mvneta_linkreset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|running
operator|=
operator|(
name|sc
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|running
condition|)
name|mvneta_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|autoneg
operator|=
operator|(
name|IFM_SUBTYPE
argument_list|(
name|media
argument_list|)
operator|==
name|IFM_AUTO
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|use_inband_status
condition|)
name|mvneta_update_autoneg
argument_list|(
name|sc
argument_list|,
name|IFM_SUBTYPE
argument_list|(
name|media
argument_list|)
operator|==
name|IFM_AUTO
argument_list|)
expr_stmt|;
name|mvneta_update_eee
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mvneta_update_fc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|media
argument_list|)
operator|!=
name|IFM_AUTO
condition|)
block|{
name|reg
operator|=
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_PANC
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
operator|(
name|MVNETA_PANC_SETGMIISPEED
operator||
name|MVNETA_PANC_SETMIISPEED
operator||
name|MVNETA_PANC_SETFULLDX
operator|)
expr_stmt|;
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|media
argument_list|)
operator|==
name|IFM_1000_T
operator|||
name|IFM_SUBTYPE
argument_list|(
name|media
argument_list|)
operator|==
name|IFM_2500_T
condition|)
block|{
if|if
condition|(
operator|(
name|media
operator|&
name|IFM_FDX
operator|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s half-duplex unsupported\n"
argument_list|,
name|IFM_SUBTYPE
argument_list|(
name|media
argument_list|)
operator|==
name|IFM_1000_T
condition|?
literal|"1000Base-T"
else|:
literal|"2500Base-T"
argument_list|)
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|reg
operator||=
name|MVNETA_PANC_SETGMIISPEED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|media
argument_list|)
operator|==
name|IFM_100_TX
condition|)
name|reg
operator||=
name|MVNETA_PANC_SETMIISPEED
expr_stmt|;
if|if
condition|(
name|media
operator|&
name|IFM_FDX
condition|)
name|reg
operator||=
name|MVNETA_PANC_SETFULLDX
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PANC
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|running
condition|)
name|mvneta_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mvneta_sc_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|mvneta_adjust_link
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|)
block|{
name|boolean_t
name|phy_linkup
decl_stmt|;
name|int
name|reg
decl_stmt|;
comment|/* Update eee/fc */
name|mvneta_update_eee
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mvneta_update_fc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Check for link change */
name|phy_linkup
operator|=
operator|(
name|sc
operator|->
name|mii
operator|->
name|mii_media_status
operator|&
operator|(
name|IFM_AVALID
operator||
name|IFM_ACTIVE
operator|)
operator|)
operator|==
operator|(
name|IFM_AVALID
operator||
name|IFM_ACTIVE
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|linkup
operator|!=
name|phy_linkup
condition|)
name|mvneta_linkupdate
argument_list|(
name|sc
argument_list|,
name|phy_linkup
argument_list|)
expr_stmt|;
comment|/* Don't update media on disabled link */
if|if
condition|(
operator|!
name|phy_linkup
condition|)
return|return;
comment|/* Check for media type change */
if|if
condition|(
name|sc
operator|->
name|mvneta_media
operator|!=
name|sc
operator|->
name|mii
operator|->
name|mii_media_active
condition|)
block|{
name|sc
operator|->
name|mvneta_media
operator|=
name|sc
operator|->
name|mii
operator|->
name|mii_media_active
expr_stmt|;
name|reg
operator|=
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_PANC
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
operator|(
name|MVNETA_PANC_SETGMIISPEED
operator||
name|MVNETA_PANC_SETMIISPEED
operator||
name|MVNETA_PANC_SETFULLDX
operator|)
expr_stmt|;
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|sc
operator|->
name|mvneta_media
argument_list|)
operator|==
name|IFM_1000_T
operator|||
name|IFM_SUBTYPE
argument_list|(
name|sc
operator|->
name|mvneta_media
argument_list|)
operator|==
name|IFM_2500_T
condition|)
block|{
name|reg
operator||=
name|MVNETA_PANC_SETGMIISPEED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|sc
operator|->
name|mvneta_media
argument_list|)
operator|==
name|IFM_100_TX
condition|)
name|reg
operator||=
name|MVNETA_PANC_SETMIISPEED
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mvneta_media
operator|&
name|IFM_FDX
condition|)
name|reg
operator||=
name|MVNETA_PANC_SETFULLDX
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PANC
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|STATIC
name|void
name|mvneta_link_isr
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|linkup
decl_stmt|;
name|KASSERT_SC_MTX
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|linkup
operator|=
name|MVNETA_IS_LINKUP
argument_list|(
name|sc
argument_list|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|linkup
operator|==
name|linkup
condition|)
return|return;
if|if
condition|(
name|linkup
operator|==
name|TRUE
condition|)
name|mvneta_linkup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|mvneta_linkdown
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s: link %s\n"
argument_list|,
name|device_xname
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|linkup
condition|?
literal|"up"
else|:
literal|"down"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|STATIC
name|void
name|mvneta_linkupdate
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|,
name|boolean_t
name|linkup
parameter_list|)
block|{
name|KASSERT_SC_MTX
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|linkup
operator|==
name|TRUE
condition|)
name|mvneta_linkup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|mvneta_linkdown
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s: link %s\n"
argument_list|,
name|device_xname
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|linkup
condition|?
literal|"up"
else|:
literal|"down"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|STATIC
name|void
name|mvneta_update_eee
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|KASSERT_SC_MTX
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* set EEE parameters */
name|reg
operator|=
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_LPIC1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cf_lpi
condition|)
name|reg
operator||=
name|MVNETA_LPIC1_LPIRE
expr_stmt|;
else|else
name|reg
operator|&=
operator|~
name|MVNETA_LPIC1_LPIRE
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_LPIC1
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|mvneta_update_fc
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|KASSERT_SC_MTX
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|reg
operator|=
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_PANC
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cf_fc
condition|)
block|{
comment|/* Flow control negotiation */
name|reg
operator||=
name|MVNETA_PANC_PAUSEADV
expr_stmt|;
name|reg
operator||=
name|MVNETA_PANC_ANFCEN
expr_stmt|;
block|}
else|else
block|{
comment|/* Disable flow control negotiation */
name|reg
operator|&=
operator|~
name|MVNETA_PANC_PAUSEADV
expr_stmt|;
name|reg
operator|&=
operator|~
name|MVNETA_PANC_ANFCEN
expr_stmt|;
block|}
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PANC
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|mvneta_linkup
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|KASSERT_SC_MTX
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|use_inband_status
condition|)
block|{
name|reg
operator|=
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_PANC
argument_list|)
expr_stmt|;
name|reg
operator||=
name|MVNETA_PANC_FORCELINKPASS
expr_stmt|;
name|reg
operator|&=
operator|~
name|MVNETA_PANC_FORCELINKFAIL
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PANC
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
name|mvneta_qflush
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|mvneta_portup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|linkup
operator|=
name|TRUE
expr_stmt|;
name|if_link_state_change
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|mvneta_linkdown
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|KASSERT_SC_MTX
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|use_inband_status
condition|)
block|{
name|reg
operator|=
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_PANC
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|MVNETA_PANC_FORCELINKPASS
expr_stmt|;
name|reg
operator||=
name|MVNETA_PANC_FORCELINKFAIL
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PANC
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
name|mvneta_portdown
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mvneta_qflush
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|linkup
operator|=
name|FALSE
expr_stmt|;
name|if_link_state_change
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|mvneta_linkreset
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mii_softc
modifier|*
name|mii
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|phy_attached
condition|)
block|{
comment|/* Force reset PHY */
name|mii
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|mii
operator|->
name|mii_phys
argument_list|)
expr_stmt|;
if|if
condition|(
name|mii
condition|)
name|mii_phy_reset
argument_list|(
name|mii
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Tx Subroutines  */
end_comment

begin_function
name|STATIC
name|int
name|mvneta_tx_queue
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mbufp
parameter_list|,
name|int
name|q
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|bus_dma_segment_t
name|txsegs
index|[
name|MVNETA_TX_SEGLIMIT
index|]
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mtmp
decl_stmt|,
modifier|*
name|mbuf
decl_stmt|;
name|struct
name|mvneta_tx_ring
modifier|*
name|tx
decl_stmt|;
name|struct
name|mvneta_buf
modifier|*
name|txbuf
decl_stmt|;
name|struct
name|mvneta_tx_desc
modifier|*
name|t
decl_stmt|;
name|uint32_t
name|ptxsu
decl_stmt|;
name|int
name|start
decl_stmt|,
name|used
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|,
name|txnsegs
decl_stmt|;
name|mbuf
operator|=
operator|*
name|mbufp
expr_stmt|;
name|tx
operator|=
name|MVNETA_TX_RING
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|DASSERT
argument_list|(
name|tx
operator|->
name|used
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|DASSERT
argument_list|(
name|tx
operator|->
name|used
operator|<=
name|MVNETA_TX_RING_CNT
argument_list|)
expr_stmt|;
name|t
operator|=
name|NULL
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|mbuf
operator|->
name|m_flags
operator|&
name|M_VLANTAG
argument_list|)
condition|)
block|{
name|mbuf
operator|=
name|ether_vlanencap
argument_list|(
name|mbuf
argument_list|,
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbuf
operator|==
name|NULL
condition|)
block|{
name|tx
operator|->
name|drv_error
operator|++
expr_stmt|;
operator|*
name|mbufp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|mbuf
operator|->
name|m_flags
operator|&=
operator|~
name|M_VLANTAG
expr_stmt|;
operator|*
name|mbufp
operator|=
name|mbuf
expr_stmt|;
block|}
if|if
condition|(
name|__predict_false
argument_list|(
name|mbuf
operator|->
name|m_next
operator|!=
name|NULL
operator|&&
operator|(
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_IP
operator||
name|CSUM_TCP
operator||
name|CSUM_UDP
operator|)
operator|)
operator|!=
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|M_WRITABLE
argument_list|(
name|mbuf
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mtmp
operator|=
name|m_dup
argument_list|(
name|mbuf
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtmp
operator|==
name|NULL
condition|)
block|{
name|tx
operator|->
name|drv_error
operator|++
expr_stmt|;
operator|*
name|mbufp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
operator|*
name|mbufp
operator|=
name|mbuf
operator|=
name|mtmp
expr_stmt|;
block|}
block|}
comment|/* load mbuf using dmamap of 1st descriptor */
name|txbuf
operator|=
operator|&
name|tx
operator|->
name|txbuf
index|[
name|tx
operator|->
name|cpu
index|]
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|txmbuf_dtag
argument_list|,
name|txbuf
operator|->
name|dmap
argument_list|,
name|mbuf
argument_list|,
name|txsegs
argument_list|,
operator|&
name|txnsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|error
operator|!=
literal|0
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|MVNETA_KTR
name|CTR3
argument_list|(
name|KTR_SPARE2
argument_list|,
literal|"%s:%u bus_dmamap_load_mbuf_sg error=%d"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|q
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* This is the only recoverable error (except EFBIG). */
if|if
condition|(
name|error
operator|!=
name|ENOMEM
condition|)
block|{
name|tx
operator|->
name|drv_error
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|mbuf
argument_list|)
expr_stmt|;
operator|*
name|mbufp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|__predict_false
argument_list|(
name|txnsegs
operator|<=
literal|0
operator|||
operator|(
name|txnsegs
operator|+
name|tx
operator|->
name|used
operator|)
operator|>
name|MVNETA_TX_RING_CNT
argument_list|)
condition|)
block|{
comment|/* we have no enough descriptors or mbuf is broken */
ifdef|#
directive|ifdef
name|MVNETA_KTR
name|CTR3
argument_list|(
name|KTR_SPARE2
argument_list|,
literal|"%s:%u not enough descriptors txnsegs=%d"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|q
argument_list|,
name|txnsegs
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|txmbuf_dtag
argument_list|,
name|txbuf
operator|->
name|dmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|DASSERT
argument_list|(
name|txbuf
operator|->
name|m
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* remember mbuf using 1st descriptor */
name|txbuf
operator|->
name|m
operator|=
name|mbuf
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|txmbuf_dtag
argument_list|,
name|txbuf
operator|->
name|dmap
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* load to tx descriptors */
name|start
operator|=
name|tx
operator|->
name|cpu
expr_stmt|;
name|used
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|txnsegs
condition|;
name|i
operator|++
control|)
block|{
name|t
operator|=
operator|&
name|tx
operator|->
name|desc
index|[
name|tx
operator|->
name|cpu
index|]
expr_stmt|;
name|t
operator|->
name|command
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|l4ichk
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
name|i
operator|==
literal|0
argument_list|)
condition|)
block|{
comment|/* 1st descriptor */
name|t
operator|->
name|command
operator||=
name|MVNETA_TX_CMD_W_PACKET_OFFSET
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|t
operator|->
name|command
operator||=
name|MVNETA_TX_CMD_F
expr_stmt|;
name|mvneta_tx_set_csumflag
argument_list|(
name|ifp
argument_list|,
name|t
argument_list|,
name|mbuf
argument_list|)
expr_stmt|;
block|}
name|t
operator|->
name|bufptr_pa
operator|=
name|txsegs
index|[
name|i
index|]
operator|.
name|ds_addr
expr_stmt|;
name|t
operator|->
name|bytecnt
operator|=
name|txsegs
index|[
name|i
index|]
operator|.
name|ds_len
expr_stmt|;
name|tx
operator|->
name|cpu
operator|=
name|tx_counter_adv
argument_list|(
name|tx
operator|->
name|cpu
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tx
operator|->
name|used
operator|++
expr_stmt|;
name|used
operator|++
expr_stmt|;
block|}
comment|/* t is last descriptor here */
name|DASSERT
argument_list|(
name|t
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|t
operator|->
name|command
operator||=
name|MVNETA_TX_CMD_L
operator||
name|MVNETA_TX_CMD_PADDING
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|tx_dtag
argument_list|,
name|tx
operator|->
name|desc_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
while|while
condition|(
name|__predict_false
argument_list|(
name|used
operator|>
literal|255
argument_list|)
condition|)
block|{
name|ptxsu
operator|=
name|MVNETA_PTXSU_NOWD
argument_list|(
literal|255
argument_list|)
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PTXSU
argument_list|(
name|q
argument_list|)
argument_list|,
name|ptxsu
argument_list|)
expr_stmt|;
name|used
operator|-=
literal|255
expr_stmt|;
block|}
if|if
condition|(
name|__predict_true
argument_list|(
name|used
operator|>
literal|0
argument_list|)
condition|)
block|{
name|ptxsu
operator|=
name|MVNETA_PTXSU_NOWD
argument_list|(
name|used
argument_list|)
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PTXSU
argument_list|(
name|q
argument_list|)
argument_list|,
name|ptxsu
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|mvneta_tx_set_csumflag
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mvneta_tx_desc
modifier|*
name|t
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|int
name|csum_flags
decl_stmt|;
name|uint32_t
name|iphl
decl_stmt|,
name|ipoff
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|iphl
operator|=
name|ipoff
operator|=
literal|0
expr_stmt|;
name|csum_flags
operator|=
name|ifp
operator|->
name|if_hwassist
operator|&
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
expr_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ntohs
argument_list|(
name|eh
operator|->
name|ether_type
argument_list|)
condition|)
block|{
case|case
name|ETHERTYPE_IP
case|:
name|ipoff
operator|=
name|ETHER_HDR_LEN
expr_stmt|;
break|break;
case|case
name|ETHERTYPE_IPV6
case|:
return|return;
case|case
name|ETHERTYPE_VLAN
case|:
name|ipoff
operator|=
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|__predict_true
argument_list|(
name|csum_flags
operator|&
operator|(
name|CSUM_IP
operator||
name|CSUM_IP_TCP
operator||
name|CSUM_IP_UDP
operator|)
argument_list|)
condition|)
block|{
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|m
operator|->
name|m_data
operator|+
name|ipoff
operator|)
expr_stmt|;
name|iphl
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
name|t
operator|->
name|command
operator||=
name|MVNETA_TX_CMD_L3_IP4
expr_stmt|;
block|}
else|else
block|{
name|t
operator|->
name|command
operator||=
name|MVNETA_TX_CMD_L4_CHECKSUM_NONE
expr_stmt|;
return|return;
block|}
comment|/* L3 */
if|if
condition|(
name|csum_flags
operator|&
name|CSUM_IP
condition|)
block|{
name|t
operator|->
name|command
operator||=
name|MVNETA_TX_CMD_IP4_CHECKSUM
expr_stmt|;
block|}
comment|/* L4 */
if|if
condition|(
name|csum_flags
operator|&
name|CSUM_IP_TCP
condition|)
block|{
name|t
operator|->
name|command
operator||=
name|MVNETA_TX_CMD_L4_CHECKSUM_NOFRAG
expr_stmt|;
name|t
operator|->
name|command
operator||=
name|MVNETA_TX_CMD_L4_TCP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|csum_flags
operator|&
name|CSUM_IP_UDP
condition|)
block|{
name|t
operator|->
name|command
operator||=
name|MVNETA_TX_CMD_L4_CHECKSUM_NOFRAG
expr_stmt|;
name|t
operator|->
name|command
operator||=
name|MVNETA_TX_CMD_L4_UDP
expr_stmt|;
block|}
else|else
name|t
operator|->
name|command
operator||=
name|MVNETA_TX_CMD_L4_CHECKSUM_NONE
expr_stmt|;
name|t
operator|->
name|l4ichk
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|command
operator||=
name|MVNETA_TX_CMD_IP_HEADER_LEN
argument_list|(
name|iphl
operator|>>
literal|2
argument_list|)
expr_stmt|;
name|t
operator|->
name|command
operator||=
name|MVNETA_TX_CMD_L3_OFFSET
argument_list|(
name|ipoff
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|mvneta_tx_queue_complete
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|,
name|int
name|q
parameter_list|)
block|{
name|struct
name|mvneta_tx_ring
modifier|*
name|tx
decl_stmt|;
name|struct
name|mvneta_buf
modifier|*
name|txbuf
decl_stmt|;
name|struct
name|mvneta_tx_desc
modifier|*
name|t
decl_stmt|;
name|uint32_t
name|ptxs
decl_stmt|,
name|ptxsu
decl_stmt|,
name|ndesc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|KASSERT_TX_MTX
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|tx
operator|=
name|MVNETA_TX_RING
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|tx
operator|->
name|queue_status
operator|==
name|MVNETA_QUEUE_DISABLED
argument_list|)
condition|)
return|return;
name|ptxs
operator|=
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_PTXS
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|ndesc
operator|=
name|MVNETA_PTXS_GET_TBC
argument_list|(
name|ptxs
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|ndesc
operator|==
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|tx
operator|->
name|used
operator|==
literal|0
condition|)
name|tx
operator|->
name|queue_status
operator|=
name|MVNETA_QUEUE_IDLE
expr_stmt|;
elseif|else
if|if
condition|(
name|tx
operator|->
name|queue_status
operator|==
name|MVNETA_QUEUE_WORKING
operator|&&
operator|(
operator|(
name|ticks
operator|-
name|tx
operator|->
name|watchdog_time
operator|)
operator|>
name|MVNETA_WATCHDOG
operator|)
condition|)
name|tx
operator|->
name|queue_hung
operator|=
name|TRUE
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|MVNETA_KTR
name|CTR3
argument_list|(
name|KTR_SPARE2
argument_list|,
literal|"%s:%u tx_complete begin ndesc=%u"
argument_list|,
name|sc
operator|->
name|ifp
operator|->
name|if_xname
argument_list|,
name|q
argument_list|,
name|ndesc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|tx_dtag
argument_list|,
name|tx
operator|->
name|desc_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndesc
condition|;
name|i
operator|++
control|)
block|{
name|t
operator|=
operator|&
name|tx
operator|->
name|desc
index|[
name|tx
operator|->
name|dma
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|MVNETA_KTR
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|MVNETA_TX_F_ES
condition|)
name|CTR3
argument_list|(
name|KTR_SPARE2
argument_list|,
literal|"%s tx error queue %d desc %d"
argument_list|,
name|sc
operator|->
name|ifp
operator|->
name|if_xname
argument_list|,
name|q
argument_list|,
name|tx
operator|->
name|dma
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|txbuf
operator|=
operator|&
name|tx
operator|->
name|txbuf
index|[
name|tx
operator|->
name|dma
index|]
expr_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
name|txbuf
operator|->
name|m
operator|!=
name|NULL
argument_list|)
condition|)
block|{
name|DASSERT
argument_list|(
operator|(
name|t
operator|->
name|command
operator|&
name|MVNETA_TX_CMD_F
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|txmbuf_dtag
argument_list|,
name|txbuf
operator|->
name|dmap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|txbuf
operator|->
name|m
argument_list|)
expr_stmt|;
name|txbuf
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|DASSERT
argument_list|(
operator|(
name|t
operator|->
name|flags
operator|&
name|MVNETA_TX_CMD_F
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|tx
operator|->
name|dma
operator|=
name|tx_counter_adv
argument_list|(
name|tx
operator|->
name|dma
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tx
operator|->
name|used
operator|--
expr_stmt|;
block|}
name|DASSERT
argument_list|(
name|tx
operator|->
name|used
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|DASSERT
argument_list|(
name|tx
operator|->
name|used
operator|<=
name|MVNETA_TX_RING_CNT
argument_list|)
expr_stmt|;
while|while
condition|(
name|__predict_false
argument_list|(
name|ndesc
operator|>
literal|255
argument_list|)
condition|)
block|{
name|ptxsu
operator|=
name|MVNETA_PTXSU_NORB
argument_list|(
literal|255
argument_list|)
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PTXSU
argument_list|(
name|q
argument_list|)
argument_list|,
name|ptxsu
argument_list|)
expr_stmt|;
name|ndesc
operator|-=
literal|255
expr_stmt|;
block|}
if|if
condition|(
name|__predict_true
argument_list|(
name|ndesc
operator|>
literal|0
argument_list|)
condition|)
block|{
name|ptxsu
operator|=
name|MVNETA_PTXSU_NORB
argument_list|(
name|ndesc
argument_list|)
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PTXSU
argument_list|(
name|q
argument_list|)
argument_list|,
name|ptxsu
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MVNETA_KTR
name|CTR5
argument_list|(
name|KTR_SPARE2
argument_list|,
literal|"%s:%u tx_complete tx_cpu=%d tx_dma=%d tx_used=%d"
argument_list|,
name|sc
operator|->
name|ifp
operator|->
name|if_xname
argument_list|,
name|q
argument_list|,
name|tx
operator|->
name|cpu
argument_list|,
name|tx
operator|->
name|dma
argument_list|,
name|tx
operator|->
name|used
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tx
operator|->
name|watchdog_time
operator|=
name|ticks
expr_stmt|;
if|if
condition|(
name|tx
operator|->
name|used
operator|==
literal|0
condition|)
name|tx
operator|->
name|queue_status
operator|=
name|MVNETA_QUEUE_IDLE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Do a final TX complete when TX is idle.  */
end_comment

begin_function
name|STATIC
name|void
name|mvneta_tx_drain
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mvneta_tx_ring
modifier|*
name|tx
decl_stmt|;
name|int
name|q
decl_stmt|;
comment|/* 	 * Handle trailing mbuf on TX queue. 	 * Check is done lockess to avoid TX path contention. 	 */
for|for
control|(
name|q
operator|=
literal|0
init|;
name|q
operator|<
name|MVNETA_TX_QNUM_MAX
condition|;
name|q
operator|++
control|)
block|{
name|tx
operator|=
name|MVNETA_TX_RING
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ticks
operator|-
name|tx
operator|->
name|watchdog_time
operator|)
operator|>
name|MVNETA_WATCHDOG_TXCOMP
operator|&&
name|tx
operator|->
name|used
operator|>
literal|0
condition|)
block|{
name|mvneta_tx_lockq
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|mvneta_tx_queue_complete
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|mvneta_tx_unlockq
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Rx Subroutines  */
end_comment

begin_function
name|STATIC
name|int
name|mvneta_rx
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|,
name|int
name|q
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|uint32_t
name|prxs
decl_stmt|,
name|npkt
decl_stmt|;
name|int
name|more
decl_stmt|;
name|more
operator|=
literal|0
expr_stmt|;
name|mvneta_rx_lockq
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|prxs
operator|=
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_PRXS
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|npkt
operator|=
name|MVNETA_PRXS_GET_ODC
argument_list|(
name|prxs
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|npkt
operator|==
literal|0
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|count
operator|>
literal|0
operator|&&
name|npkt
operator|>
name|count
condition|)
block|{
name|more
operator|=
literal|1
expr_stmt|;
name|npkt
operator|=
name|count
expr_stmt|;
block|}
name|mvneta_rx_queue
argument_list|(
name|sc
argument_list|,
name|q
argument_list|,
name|npkt
argument_list|)
expr_stmt|;
name|out
label|:
name|mvneta_rx_unlockq
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
return|return
name|more
return|;
block|}
end_function

begin_comment
comment|/*  * Helper routine for updating PRXSU register of a given queue.  * Handles number of processed descriptors bigger than maximum acceptable value.  */
end_comment

begin_function
name|STATIC
name|__inline
name|void
name|mvneta_prxsu_update
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|,
name|int
name|q
parameter_list|,
name|int
name|processed
parameter_list|)
block|{
name|uint32_t
name|prxsu
decl_stmt|;
while|while
condition|(
name|__predict_false
argument_list|(
name|processed
operator|>
literal|255
argument_list|)
condition|)
block|{
name|prxsu
operator|=
name|MVNETA_PRXSU_NOOFPROCESSEDDESCRIPTORS
argument_list|(
literal|255
argument_list|)
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PRXSU
argument_list|(
name|q
argument_list|)
argument_list|,
name|prxsu
argument_list|)
expr_stmt|;
name|processed
operator|-=
literal|255
expr_stmt|;
block|}
name|prxsu
operator|=
name|MVNETA_PRXSU_NOOFPROCESSEDDESCRIPTORS
argument_list|(
name|processed
argument_list|)
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PRXSU
argument_list|(
name|q
argument_list|)
argument_list|,
name|prxsu
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|mvneta_prefetch
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|__builtin_prefetch
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|mvneta_rx_queue
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|,
name|int
name|q
parameter_list|,
name|int
name|npkt
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mvneta_rx_ring
modifier|*
name|rx
decl_stmt|;
name|struct
name|mvneta_rx_desc
modifier|*
name|r
decl_stmt|;
name|struct
name|mvneta_buf
modifier|*
name|rxbuf
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|lro_ctrl
modifier|*
name|lro
decl_stmt|;
name|struct
name|lro_entry
modifier|*
name|queued
decl_stmt|;
name|void
modifier|*
name|pktbuf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|pktlen
decl_stmt|,
name|processed
decl_stmt|,
name|ndma
decl_stmt|;
name|KASSERT_RX_MTX
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
name|rx
operator|=
name|MVNETA_RX_RING
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|processed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|rx
operator|->
name|queue_status
operator|==
name|MVNETA_QUEUE_DISABLED
argument_list|)
condition|)
return|return;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rx_dtag
argument_list|,
name|rx
operator|->
name|desc_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npkt
condition|;
name|i
operator|++
control|)
block|{
comment|/* Prefetch next desc, rxbuf. */
name|ndma
operator|=
name|rx_counter_adv
argument_list|(
name|rx
operator|->
name|dma
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mvneta_prefetch
argument_list|(
operator|&
name|rx
operator|->
name|desc
index|[
name|ndma
index|]
argument_list|)
expr_stmt|;
name|mvneta_prefetch
argument_list|(
operator|&
name|rx
operator|->
name|rxbuf
index|[
name|ndma
index|]
argument_list|)
expr_stmt|;
comment|/* get descriptor and packet */
name|r
operator|=
operator|&
name|rx
operator|->
name|desc
index|[
name|rx
operator|->
name|dma
index|]
expr_stmt|;
name|rxbuf
operator|=
operator|&
name|rx
operator|->
name|rxbuf
index|[
name|rx
operator|->
name|dma
index|]
expr_stmt|;
name|m
operator|=
name|rxbuf
operator|->
name|m
expr_stmt|;
name|rxbuf
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|DASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rxbuf_dtag
argument_list|,
name|rxbuf
operator|->
name|dmap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|rxbuf_dtag
argument_list|,
name|rxbuf
operator|->
name|dmap
argument_list|)
expr_stmt|;
comment|/* Prefetch mbuf header. */
name|mvneta_prefetch
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|processed
operator|++
expr_stmt|;
comment|/* Drop desc with error status or not in a single buffer. */
name|DASSERT
argument_list|(
operator|(
name|r
operator|->
name|status
operator|&
operator|(
name|MVNETA_RX_F
operator||
name|MVNETA_RX_L
operator|)
operator|)
operator|==
operator|(
name|MVNETA_RX_F
operator||
name|MVNETA_RX_L
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|(
name|r
operator|->
name|status
operator|&
name|MVNETA_RX_ES
operator|)
operator|||
operator|(
name|r
operator|->
name|status
operator|&
operator|(
name|MVNETA_RX_F
operator||
name|MVNETA_RX_L
operator|)
operator|)
operator|!=
operator|(
name|MVNETA_RX_F
operator||
name|MVNETA_RX_L
operator|)
argument_list|)
condition|)
goto|goto
name|rx_error
goto|;
comment|/* 		 * [ OFF | MH | PKT | CRC ] 		 * bytecnt cover MH, PKT, CRC 		 */
name|pktlen
operator|=
name|r
operator|->
name|bytecnt
operator|-
name|ETHER_CRC_LEN
operator|-
name|MVNETA_HWHEADER_SIZE
expr_stmt|;
name|pktbuf
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|r
operator|->
name|bufptr_va
operator|+
name|MVNETA_PACKET_OFFSET
operator|+
name|MVNETA_HWHEADER_SIZE
expr_stmt|;
comment|/* Prefetch mbuf data. */
name|mvneta_prefetch
argument_list|(
name|pktbuf
argument_list|)
expr_stmt|;
comment|/* Write value to mbuf (avoid read). */
name|m
operator|->
name|m_data
operator|=
name|pktbuf
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|pktlen
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|mvneta_rx_set_csumflag
argument_list|(
name|ifp
argument_list|,
name|r
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* Increase rx_dma before releasing the lock. */
name|rx
operator|->
name|dma
operator|=
name|ndma
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|rx
operator|->
name|lro_enabled
operator|&&
operator|(
operator|(
name|r
operator|->
name|status
operator|&
name|MVNETA_RX_L3_IP
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|r
operator|->
name|status
operator|&
name|MVNETA_RX_L4_MASK
operator|)
operator|==
name|MVNETA_RX_L4_TCP
operator|)
operator|&&
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
operator|)
operator|==
operator|(
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|rx
operator|->
name|lro
operator|.
name|lro_cnt
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|tcp_lro_rx
argument_list|(
operator|&
name|rx
operator|->
name|lro
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|rx_done
goto|;
block|}
block|}
name|mvneta_rx_unlockq
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|mvneta_rx_lockq
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
comment|/* 		 * Check whether this queue has been disabled in the 		 * meantime. If yes, then clear LRO and exit. 		 */
if|if
condition|(
name|__predict_false
argument_list|(
name|rx
operator|->
name|queue_status
operator|==
name|MVNETA_QUEUE_DISABLED
argument_list|)
condition|)
goto|goto
name|rx_lro
goto|;
name|rx_done
label|:
comment|/* Refresh receive ring to avoid stall and minimize jitter. */
if|if
condition|(
name|processed
operator|>=
name|MVNETA_RX_REFILL_COUNT
condition|)
block|{
name|mvneta_prxsu_update
argument_list|(
name|sc
argument_list|,
name|q
argument_list|,
name|processed
argument_list|)
expr_stmt|;
name|mvneta_rx_queue_refill
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|processed
operator|=
literal|0
expr_stmt|;
block|}
continue|continue;
name|rx_error
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|rx
operator|->
name|dma
operator|=
name|ndma
expr_stmt|;
comment|/* Refresh receive ring to avoid stall and minimize jitter. */
if|if
condition|(
name|processed
operator|>=
name|MVNETA_RX_REFILL_COUNT
condition|)
block|{
name|mvneta_prxsu_update
argument_list|(
name|sc
argument_list|,
name|q
argument_list|,
name|processed
argument_list|)
expr_stmt|;
name|mvneta_rx_queue_refill
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|processed
operator|=
literal|0
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|MVNETA_KTR
name|CTR3
argument_list|(
name|KTR_SPARE2
argument_list|,
literal|"%s:%u %u packets received"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|q
argument_list|,
name|npkt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DMA status update */
name|mvneta_prxsu_update
argument_list|(
name|sc
argument_list|,
name|q
argument_list|,
name|processed
argument_list|)
expr_stmt|;
comment|/* Refill the rest of buffers if there are any to refill */
name|mvneta_rx_queue_refill
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|rx_lro
label|:
comment|/* 	 * Flush any outstanding LRO work 	 */
name|lro
operator|=
operator|&
name|rx
operator|->
name|lro
expr_stmt|;
while|while
condition|(
name|__predict_false
argument_list|(
operator|(
name|queued
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|lro
operator|->
name|lro_active
argument_list|)
operator|)
operator|!=
name|NULL
argument_list|)
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|LIST_FIRST
argument_list|(
operator|(
operator|&
name|lro
operator|->
name|lro_active
operator|)
argument_list|)
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|tcp_lro_flush
argument_list|(
name|lro
argument_list|,
name|queued
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|STATIC
name|void
name|mvneta_rx_buf_free
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mvneta_buf
modifier|*
name|rxbuf
parameter_list|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|rxbuf_dtag
argument_list|,
name|rxbuf
operator|->
name|dmap
argument_list|)
expr_stmt|;
comment|/* This will remove all data at once */
name|m_freem
argument_list|(
name|rxbuf
operator|->
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|mvneta_rx_queue_refill
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|,
name|int
name|q
parameter_list|)
block|{
name|struct
name|mvneta_rx_ring
modifier|*
name|rx
decl_stmt|;
name|struct
name|mvneta_rx_desc
modifier|*
name|r
decl_stmt|;
name|struct
name|mvneta_buf
modifier|*
name|rxbuf
decl_stmt|;
name|bus_dma_segment_t
name|segs
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint32_t
name|prxs
decl_stmt|,
name|prxsu
decl_stmt|,
name|ndesc
decl_stmt|;
name|int
name|npkt
decl_stmt|,
name|refill
decl_stmt|,
name|nsegs
decl_stmt|,
name|error
decl_stmt|;
name|KASSERT_RX_MTX
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|rx
operator|=
name|MVNETA_RX_RING
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|prxs
operator|=
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_PRXS
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|ndesc
operator|=
name|MVNETA_PRXS_GET_NODC
argument_list|(
name|prxs
argument_list|)
operator|+
name|MVNETA_PRXS_GET_ODC
argument_list|(
name|prxs
argument_list|)
expr_stmt|;
name|refill
operator|=
name|MVNETA_RX_RING_CNT
operator|-
name|ndesc
expr_stmt|;
ifdef|#
directive|ifdef
name|MVNETA_KTR
name|CTR3
argument_list|(
name|KTR_SPARE2
argument_list|,
literal|"%s:%u refill %u packets"
argument_list|,
name|sc
operator|->
name|ifp
operator|->
name|if_xname
argument_list|,
name|q
argument_list|,
name|refill
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|__predict_false
argument_list|(
name|refill
operator|<=
literal|0
argument_list|)
condition|)
return|return;
for|for
control|(
name|npkt
operator|=
literal|0
init|;
name|npkt
operator|<
name|refill
condition|;
name|npkt
operator|++
control|)
block|{
name|rxbuf
operator|=
operator|&
name|rx
operator|->
name|rxbuf
index|[
name|rx
operator|->
name|cpu
index|]
expr_stmt|;
name|m
operator|=
name|m_getcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
break|break;
block|}
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_ext
operator|.
name|ext_size
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|rxbuf_dtag
argument_list|,
name|rxbuf
operator|->
name|dmap
argument_list|,
name|m
argument_list|,
operator|&
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|error
operator|!=
literal|0
operator|||
name|nsegs
operator|!=
literal|1
argument_list|)
condition|)
block|{
name|KASSERT
argument_list|(
literal|1
argument_list|,
operator|(
literal|"Failed to load Rx mbuf DMA map"
operator|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Add the packet to the ring */
name|rxbuf
operator|->
name|m
operator|=
name|m
expr_stmt|;
name|r
operator|=
operator|&
name|rx
operator|->
name|desc
index|[
name|rx
operator|->
name|cpu
index|]
expr_stmt|;
name|r
operator|->
name|bufptr_pa
operator|=
name|segs
operator|.
name|ds_addr
expr_stmt|;
name|r
operator|->
name|bufptr_va
operator|=
operator|(
name|uint32_t
operator|)
name|m
operator|->
name|m_data
expr_stmt|;
name|rx
operator|->
name|cpu
operator|=
name|rx_counter_adv
argument_list|(
name|rx
operator|->
name|cpu
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|npkt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|refill
operator|==
name|MVNETA_RX_RING_CNT
condition|)
name|rx
operator|->
name|needs_refill
operator|=
name|TRUE
expr_stmt|;
return|return;
block|}
name|rx
operator|->
name|needs_refill
operator|=
name|FALSE
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rx_dtag
argument_list|,
name|rx
operator|->
name|desc_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
while|while
condition|(
name|__predict_false
argument_list|(
name|npkt
operator|>
literal|255
argument_list|)
condition|)
block|{
name|prxsu
operator|=
name|MVNETA_PRXSU_NOOFNEWDESCRIPTORS
argument_list|(
literal|255
argument_list|)
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PRXSU
argument_list|(
name|q
argument_list|)
argument_list|,
name|prxsu
argument_list|)
expr_stmt|;
name|npkt
operator|-=
literal|255
expr_stmt|;
block|}
if|if
condition|(
name|__predict_true
argument_list|(
name|npkt
operator|>
literal|0
argument_list|)
condition|)
block|{
name|prxsu
operator|=
name|MVNETA_PRXSU_NOOFNEWDESCRIPTORS
argument_list|(
name|npkt
argument_list|)
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PRXSU
argument_list|(
name|q
argument_list|)
argument_list|,
name|prxsu
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|STATIC
name|__inline
name|void
name|mvneta_rx_set_csumflag
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mvneta_rx_desc
modifier|*
name|r
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|uint32_t
name|csum_flags
decl_stmt|;
name|csum_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|(
name|r
operator|->
name|status
operator|&
operator|(
name|MVNETA_RX_IP_HEADER_OK
operator||
name|MVNETA_RX_L3_IP
operator|)
operator|)
operator|==
literal|0
argument_list|)
condition|)
return|return;
comment|/* not a IP packet */
comment|/* L3 */
if|if
condition|(
name|__predict_true
argument_list|(
operator|(
name|r
operator|->
name|status
operator|&
name|MVNETA_RX_IP_HEADER_OK
operator|)
operator|==
name|MVNETA_RX_IP_HEADER_OK
argument_list|)
condition|)
name|csum_flags
operator||=
name|CSUM_L3_CALC
operator||
name|CSUM_L3_VALID
expr_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
operator|(
name|r
operator|->
name|status
operator|&
operator|(
name|MVNETA_RX_IP_HEADER_OK
operator||
name|MVNETA_RX_L3_IP
operator|)
operator|)
operator|==
operator|(
name|MVNETA_RX_IP_HEADER_OK
operator||
name|MVNETA_RX_L3_IP
operator|)
argument_list|)
condition|)
block|{
comment|/* L4 */
switch|switch
condition|(
name|r
operator|->
name|status
operator|&
name|MVNETA_RX_L4_MASK
condition|)
block|{
case|case
name|MVNETA_RX_L4_TCP
case|:
case|case
name|MVNETA_RX_L4_UDP
case|:
name|csum_flags
operator||=
name|CSUM_L4_CALC
expr_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
operator|(
name|r
operator|->
name|status
operator|&
name|MVNETA_RX_L4_CHECKSUM_OK
operator|)
operator|==
name|MVNETA_RX_L4_CHECKSUM_OK
argument_list|)
condition|)
block|{
name|csum_flags
operator||=
name|CSUM_L4_VALID
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
name|htons
argument_list|(
literal|0xffff
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MVNETA_RX_L4_OTH
case|:
default|default:
break|break;
block|}
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
name|csum_flags
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * MAC address filter  */
end_comment

begin_function
name|STATIC
name|void
name|mvneta_filter_setup
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|uint32_t
name|dfut
index|[
name|MVNETA_NDFUT
index|]
decl_stmt|,
name|dfsmt
index|[
name|MVNETA_NDFSMT
index|]
decl_stmt|,
name|dfomt
index|[
name|MVNETA_NDFOMT
index|]
decl_stmt|;
name|uint32_t
name|pxc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|KASSERT_SC_MTX
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|dfut
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dfut
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|dfsmt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dfsmt
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|dfomt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dfomt
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_ALLMULTI
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_ALLMULTI
operator||
name|IFF_PROMISC
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MVNETA_NDFSMT
condition|;
name|i
operator|++
control|)
block|{
name|dfsmt
index|[
name|i
index|]
operator|=
name|dfomt
index|[
name|i
index|]
operator|=
name|MVNETA_DF
argument_list|(
literal|0
argument_list|,
name|MVNETA_DF_QUEUE
argument_list|(
literal|0
argument_list|)
operator||
name|MVNETA_DF_PASS
argument_list|)
operator||
name|MVNETA_DF
argument_list|(
literal|1
argument_list|,
name|MVNETA_DF_QUEUE
argument_list|(
literal|0
argument_list|)
operator||
name|MVNETA_DF_PASS
argument_list|)
operator||
name|MVNETA_DF
argument_list|(
literal|2
argument_list|,
name|MVNETA_DF_QUEUE
argument_list|(
literal|0
argument_list|)
operator||
name|MVNETA_DF_PASS
argument_list|)
operator||
name|MVNETA_DF
argument_list|(
literal|3
argument_list|,
name|MVNETA_DF_QUEUE
argument_list|(
literal|0
argument_list|)
operator||
name|MVNETA_DF_PASS
argument_list|)
expr_stmt|;
block|}
block|}
name|pxc
operator|=
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_PXC
argument_list|)
expr_stmt|;
name|pxc
operator|&=
operator|~
operator|(
name|MVNETA_PXC_UPM
operator||
name|MVNETA_PXC_RXQ_MASK
operator||
name|MVNETA_PXC_RXQARP_MASK
operator||
name|MVNETA_PXC_TCPQ_MASK
operator||
name|MVNETA_PXC_UDPQ_MASK
operator||
name|MVNETA_PXC_BPDUQ_MASK
operator|)
expr_stmt|;
name|pxc
operator||=
name|MVNETA_PXC_RXQ
argument_list|(
name|MVNETA_RX_QNUM_MAX
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pxc
operator||=
name|MVNETA_PXC_RXQARP
argument_list|(
name|MVNETA_RX_QNUM_MAX
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pxc
operator||=
name|MVNETA_PXC_TCPQ
argument_list|(
name|MVNETA_RX_QNUM_MAX
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pxc
operator||=
name|MVNETA_PXC_UDPQ
argument_list|(
name|MVNETA_RX_QNUM_MAX
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pxc
operator||=
name|MVNETA_PXC_BPDUQ
argument_list|(
name|MVNETA_RX_QNUM_MAX
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pxc
operator||=
name|MVNETA_PXC_RB
operator||
name|MVNETA_PXC_RBIP
operator||
name|MVNETA_PXC_RBARP
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_BROADCAST
condition|)
block|{
name|pxc
operator|&=
operator|~
operator|(
name|MVNETA_PXC_RB
operator||
name|MVNETA_PXC_RBIP
operator||
name|MVNETA_PXC_RBARP
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|pxc
operator||=
name|MVNETA_PXC_UPM
expr_stmt|;
block|}
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PXC
argument_list|,
name|pxc
argument_list|)
expr_stmt|;
comment|/* Set Destination Address Filter Unicast Table */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
comment|/* pass all unicast addresses */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MVNETA_NDFUT
condition|;
name|i
operator|++
control|)
block|{
name|dfut
index|[
name|i
index|]
operator|=
name|MVNETA_DF
argument_list|(
literal|0
argument_list|,
name|MVNETA_DF_QUEUE
argument_list|(
literal|0
argument_list|)
operator||
name|MVNETA_DF_PASS
argument_list|)
operator||
name|MVNETA_DF
argument_list|(
literal|1
argument_list|,
name|MVNETA_DF_QUEUE
argument_list|(
literal|0
argument_list|)
operator||
name|MVNETA_DF_PASS
argument_list|)
operator||
name|MVNETA_DF
argument_list|(
literal|2
argument_list|,
name|MVNETA_DF_QUEUE
argument_list|(
literal|0
argument_list|)
operator||
name|MVNETA_DF_PASS
argument_list|)
operator||
name|MVNETA_DF
argument_list|(
literal|3
argument_list|,
name|MVNETA_DF_QUEUE
argument_list|(
literal|0
argument_list|)
operator||
name|MVNETA_DF_PASS
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|i
operator|=
name|sc
operator|->
name|enaddr
index|[
literal|5
index|]
operator|&
literal|0xf
expr_stmt|;
comment|/* last nibble */
name|dfut
index|[
name|i
operator|>>
literal|2
index|]
operator|=
name|MVNETA_DF
argument_list|(
name|i
operator|&
literal|3
argument_list|,
name|MVNETA_DF_QUEUE
argument_list|(
literal|0
argument_list|)
operator||
name|MVNETA_DF_PASS
argument_list|)
expr_stmt|;
block|}
name|MVNETA_WRITE_REGION
argument_list|(
name|sc
argument_list|,
name|MVNETA_DFUT
argument_list|(
literal|0
argument_list|)
argument_list|,
name|dfut
argument_list|,
name|MVNETA_NDFUT
argument_list|)
expr_stmt|;
comment|/* Set Destination Address Filter Multicast Tables */
name|MVNETA_WRITE_REGION
argument_list|(
name|sc
argument_list|,
name|MVNETA_DFSMT
argument_list|(
literal|0
argument_list|)
argument_list|,
name|dfsmt
argument_list|,
name|MVNETA_NDFSMT
argument_list|)
expr_stmt|;
name|MVNETA_WRITE_REGION
argument_list|(
name|sc
argument_list|,
name|MVNETA_DFOMT
argument_list|(
literal|0
argument_list|)
argument_list|,
name|dfomt
argument_list|,
name|MVNETA_NDFOMT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * sysctl(9)  */
end_comment

begin_function
name|STATIC
name|int
name|sysctl_read_mib
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|mvneta_sysctl_mib
modifier|*
name|arg
decl_stmt|;
name|struct
name|mvneta_softc
modifier|*
name|sc
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
name|arg
operator|=
operator|(
expr|struct
name|mvneta_sysctl_mib
operator|*
operator|)
name|arg1
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sc
operator|=
name|arg
operator|->
name|sc
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|arg
operator|->
name|index
operator|<
literal|0
operator|||
name|arg
operator|->
name|index
operator|>
name|MVNETA_PORTMIB_NOCOUNTER
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mvneta_sc_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|val
operator|=
name|arg
operator|->
name|counter
expr_stmt|;
name|mvneta_sc_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|sysctl_handle_64
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|sysctl_clear_mib
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|mvneta_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|err
decl_stmt|,
name|val
decl_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|mvneta_softc
operator|*
operator|)
name|arg1
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|err
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|val
operator|<
literal|0
operator|||
name|val
operator|>
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|val
operator|==
literal|1
condition|)
block|{
name|mvneta_sc_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mvneta_clear_mib
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mvneta_sc_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|sysctl_set_queue_rxthtime
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|mvneta_sysctl_queue
modifier|*
name|arg
decl_stmt|;
name|struct
name|mvneta_rx_ring
modifier|*
name|rx
decl_stmt|;
name|struct
name|mvneta_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|,
name|time_mvtclk
decl_stmt|;
name|int
name|err
decl_stmt|,
name|time_us
decl_stmt|;
name|rx
operator|=
name|NULL
expr_stmt|;
name|arg
operator|=
operator|(
expr|struct
name|mvneta_sysctl_queue
operator|*
operator|)
name|arg1
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|arg
operator|->
name|queue
operator|<
literal|0
operator|||
name|arg
operator|->
name|queue
operator|>
name|MVNETA_RX_RING_CNT
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|arg
operator|->
name|rxtx
operator|!=
name|MVNETA_SYSCTL_RX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sc
operator|=
name|arg
operator|->
name|sc
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* read queue length */
name|mvneta_sc_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mvneta_rx_lockq
argument_list|(
name|sc
argument_list|,
name|arg
operator|->
name|queue
argument_list|)
expr_stmt|;
name|rx
operator|=
name|MVNETA_RX_RING
argument_list|(
name|sc
argument_list|,
name|arg
operator|->
name|queue
argument_list|)
expr_stmt|;
name|time_mvtclk
operator|=
name|rx
operator|->
name|queue_th_time
expr_stmt|;
name|time_us
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|time_mvtclk
operator|*
literal|1000ULL
operator|*
literal|1000ULL
operator|)
operator|/
name|get_tclk
argument_list|()
expr_stmt|;
name|mvneta_rx_unlockq
argument_list|(
name|sc
argument_list|,
name|arg
operator|->
name|queue
argument_list|)
expr_stmt|;
name|mvneta_sc_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|err
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|time_us
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|mvneta_sc_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mvneta_rx_lockq
argument_list|(
name|sc
argument_list|,
name|arg
operator|->
name|queue
argument_list|)
expr_stmt|;
comment|/* update queue length (0[sec] - 1[sec]) */
if|if
condition|(
name|time_us
operator|<
literal|0
operator|||
name|time_us
operator|>
operator|(
literal|1000
operator|*
literal|1000
operator|)
condition|)
block|{
name|mvneta_rx_unlockq
argument_list|(
name|sc
argument_list|,
name|arg
operator|->
name|queue
argument_list|)
expr_stmt|;
name|mvneta_sc_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|time_mvtclk
operator|=
operator|(
name|uint64_t
operator|)
name|get_tclk
argument_list|()
operator|*
operator|(
name|uint64_t
operator|)
name|time_us
operator|/
operator|(
literal|1000ULL
operator|*
literal|1000ULL
operator|)
expr_stmt|;
name|rx
operator|->
name|queue_th_time
operator|=
name|time_mvtclk
expr_stmt|;
name|reg
operator|=
name|MVNETA_PRXITTH_RITT
argument_list|(
name|rx
operator|->
name|queue_th_time
argument_list|)
expr_stmt|;
name|MVNETA_WRITE
argument_list|(
name|sc
argument_list|,
name|MVNETA_PRXITTH
argument_list|(
name|arg
operator|->
name|queue
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|mvneta_rx_unlockq
argument_list|(
name|sc
argument_list|,
name|arg
operator|->
name|queue
argument_list|)
expr_stmt|;
name|mvneta_sc_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|sysctl_mvneta_init
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|children
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|rxchildren
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|qchildren
decl_stmt|,
modifier|*
name|mchildren
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|tree
decl_stmt|;
name|int
name|i
decl_stmt|,
name|q
decl_stmt|;
name|struct
name|mvneta_sysctl_queue
modifier|*
name|rxarg
decl_stmt|;
define|#
directive|define
name|MVNETA_SYSCTL_NAME
parameter_list|(
name|num
parameter_list|)
value|"queue" # num
specifier|static
specifier|const
name|char
modifier|*
name|sysctl_queue_names
index|[]
init|=
block|{
name|MVNETA_SYSCTL_NAME
argument_list|(
literal|0
argument_list|)
block|,
name|MVNETA_SYSCTL_NAME
argument_list|(
literal|1
argument_list|)
block|,
name|MVNETA_SYSCTL_NAME
argument_list|(
literal|2
argument_list|)
block|,
name|MVNETA_SYSCTL_NAME
argument_list|(
literal|3
argument_list|)
block|,
name|MVNETA_SYSCTL_NAME
argument_list|(
literal|4
argument_list|)
block|,
name|MVNETA_SYSCTL_NAME
argument_list|(
literal|5
argument_list|)
block|,
name|MVNETA_SYSCTL_NAME
argument_list|(
literal|6
argument_list|)
block|,
name|MVNETA_SYSCTL_NAME
argument_list|(
literal|7
argument_list|)
block|, 	}
decl_stmt|;
undef|#
directive|undef
name|MVNETA_SYSCTL_NAME
define|#
directive|define
name|MVNETA_SYSCTL_DESCR
parameter_list|(
name|num
parameter_list|)
value|"configuration parameters for queue " # num
specifier|static
specifier|const
name|char
modifier|*
name|sysctl_queue_descrs
index|[]
init|=
block|{
name|MVNETA_SYSCTL_DESCR
argument_list|(
literal|0
argument_list|)
block|,
name|MVNETA_SYSCTL_DESCR
argument_list|(
literal|1
argument_list|)
block|,
name|MVNETA_SYSCTL_DESCR
argument_list|(
literal|2
argument_list|)
block|,
name|MVNETA_SYSCTL_DESCR
argument_list|(
literal|3
argument_list|)
block|,
name|MVNETA_SYSCTL_DESCR
argument_list|(
literal|4
argument_list|)
block|,
name|MVNETA_SYSCTL_DESCR
argument_list|(
literal|5
argument_list|)
block|,
name|MVNETA_SYSCTL_DESCR
argument_list|(
literal|6
argument_list|)
block|,
name|MVNETA_SYSCTL_DESCR
argument_list|(
literal|7
argument_list|)
block|, 	}
decl_stmt|;
undef|#
directive|undef
name|MVNETA_SYSCTL_DESCR
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx"
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"NETA RX"
argument_list|)
expr_stmt|;
name|rxchildren
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mib"
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"NETA MIB"
argument_list|)
expr_stmt|;
name|mchildren
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"flow_control"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|cf_fc
argument_list|,
literal|0
argument_list|,
literal|"flow control"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lpi"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|cf_lpi
argument_list|,
literal|0
argument_list|,
literal|"Low Power Idle"
argument_list|)
expr_stmt|;
comment|/* 	 * MIB access 	 */
comment|/* dev.mvneta.[unit].mib.<mibs> */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MVNETA_PORTMIB_NOCOUNTER
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|mvneta_mib_list
index|[
name|i
index|]
operator|.
name|sysctl_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|desc
init|=
name|mvneta_mib_list
index|[
name|i
index|]
operator|.
name|desc
decl_stmt|;
name|struct
name|mvneta_sysctl_mib
modifier|*
name|mib_arg
init|=
operator|&
name|sc
operator|->
name|sysctl_mib
index|[
name|i
index|]
decl_stmt|;
name|mib_arg
operator|->
name|sc
operator|=
name|sc
expr_stmt|;
name|mib_arg
operator|->
name|index
operator|=
name|i
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|mchildren
argument_list|,
name|OID_AUTO
argument_list|,
name|name
argument_list|,
name|CTLTYPE_U64
operator||
name|CTLFLAG_RD
argument_list|,
operator|(
name|void
operator|*
operator|)
name|mib_arg
argument_list|,
literal|0
argument_list|,
name|sysctl_read_mib
argument_list|,
literal|"I"
argument_list|,
name|desc
argument_list|)
expr_stmt|;
block|}
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|mchildren
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_discard"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|counter_pdfc
argument_list|,
literal|"Port Rx Discard Frame Counter"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|mchildren
argument_list|,
name|OID_AUTO
argument_list|,
literal|"overrun"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|counter_pofc
argument_list|,
literal|"Port Overrun Frame Counter"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|mchildren
argument_list|,
name|OID_AUTO
argument_list|,
literal|"watchdog"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|counter_watchdog
argument_list|,
literal|0
argument_list|,
literal|"TX Watchdog Counter"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|mchildren
argument_list|,
name|OID_AUTO
argument_list|,
literal|"reset"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
literal|0
argument_list|,
name|sysctl_clear_mib
argument_list|,
literal|"I"
argument_list|,
literal|"Reset MIB counters"
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
literal|0
init|;
name|q
operator|<
name|MVNETA_RX_QNUM_MAX
condition|;
name|q
operator|++
control|)
block|{
name|rxarg
operator|=
operator|&
name|sc
operator|->
name|sysctl_rx_queue
index|[
name|q
index|]
expr_stmt|;
name|rxarg
operator|->
name|sc
operator|=
name|sc
expr_stmt|;
name|rxarg
operator|->
name|queue
operator|=
name|q
expr_stmt|;
name|rxarg
operator|->
name|rxtx
operator|=
name|MVNETA_SYSCTL_RX
expr_stmt|;
comment|/* hw.mvneta.mvneta[unit].rx.[queue] */
name|tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|rxchildren
argument_list|,
name|OID_AUTO
argument_list|,
name|sysctl_queue_names
index|[
name|q
index|]
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
name|sysctl_queue_descrs
index|[
name|q
index|]
argument_list|)
expr_stmt|;
name|qchildren
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
expr_stmt|;
comment|/* hw.mvneta.mvneta[unit].rx.[queue].threshold_timer_us */
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|qchildren
argument_list|,
name|OID_AUTO
argument_list|,
literal|"threshold_timer_us"
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RW
argument_list|,
name|rxarg
argument_list|,
literal|0
argument_list|,
name|sysctl_set_queue_rxthtime
argument_list|,
literal|"I"
argument_list|,
literal|"interrupt coalescing threshold timer [us]"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * MIB  */
end_comment

begin_function
name|STATIC
name|void
name|mvneta_clear_mib
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|KASSERT_SC_MTX
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|mvneta_mib_list
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mvneta_mib_list
index|[
name|i
index|]
operator|.
name|reg64
condition|)
name|MVNETA_READ_MIB_8
argument_list|(
name|sc
argument_list|,
name|mvneta_mib_list
index|[
name|i
index|]
operator|.
name|regnum
argument_list|)
expr_stmt|;
else|else
name|MVNETA_READ_MIB_4
argument_list|(
name|sc
argument_list|,
name|mvneta_mib_list
index|[
name|i
index|]
operator|.
name|regnum
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sysctl_mib
index|[
name|i
index|]
operator|.
name|counter
operator|=
literal|0
expr_stmt|;
block|}
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_PDFC
argument_list|)
expr_stmt|;
name|sc
operator|->
name|counter_pdfc
operator|=
literal|0
expr_stmt|;
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_POFC
argument_list|)
expr_stmt|;
name|sc
operator|->
name|counter_pofc
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|counter_watchdog
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|mvneta_update_mib
parameter_list|(
name|struct
name|mvneta_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mvneta_tx_ring
modifier|*
name|tx
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|mvneta_mib_list
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mvneta_mib_list
index|[
name|i
index|]
operator|.
name|reg64
condition|)
name|val
operator|=
name|MVNETA_READ_MIB_8
argument_list|(
name|sc
argument_list|,
name|mvneta_mib_list
index|[
name|i
index|]
operator|.
name|regnum
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|MVNETA_READ_MIB_4
argument_list|(
name|sc
argument_list|,
name|mvneta_mib_list
index|[
name|i
index|]
operator|.
name|regnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
continue|continue;
name|sc
operator|->
name|sysctl_mib
index|[
name|i
index|]
operator|.
name|counter
operator|+=
name|val
expr_stmt|;
switch|switch
condition|(
name|mvneta_mib_list
index|[
name|i
index|]
operator|.
name|regnum
condition|)
block|{
case|case
name|MVNETA_MIB_RX_GOOD_OCT
case|:
name|if_inc_counter
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|IFCOUNTER_IBYTES
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|MVNETA_MIB_RX_BAD_FRAME
case|:
name|if_inc_counter
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|IFCOUNTER_IERRORS
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|MVNETA_MIB_RX_GOOD_FRAME
case|:
name|if_inc_counter
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|IFCOUNTER_IPACKETS
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|MVNETA_MIB_RX_MCAST_FRAME
case|:
name|if_inc_counter
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|IFCOUNTER_IMCASTS
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|MVNETA_MIB_TX_GOOD_OCT
case|:
name|if_inc_counter
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|IFCOUNTER_OBYTES
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|MVNETA_MIB_TX_GOOD_FRAME
case|:
name|if_inc_counter
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|IFCOUNTER_OPACKETS
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|MVNETA_MIB_TX_MCAST_FRAME
case|:
name|if_inc_counter
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|IFCOUNTER_OMCASTS
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|MVNETA_MIB_MAC_COL
case|:
name|if_inc_counter
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|IFCOUNTER_COLLISIONS
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|MVNETA_MIB_TX_MAC_TRNS_ERR
case|:
case|case
name|MVNETA_MIB_TX_EXCES_COL
case|:
case|case
name|MVNETA_MIB_MAC_LATE_COL
case|:
name|if_inc_counter
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|reg
operator|=
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_PDFC
argument_list|)
expr_stmt|;
name|sc
operator|->
name|counter_pdfc
operator|+=
name|reg
expr_stmt|;
name|if_inc_counter
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|IFCOUNTER_IQDROPS
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|MVNETA_READ
argument_list|(
name|sc
argument_list|,
name|MVNETA_POFC
argument_list|)
expr_stmt|;
name|sc
operator|->
name|counter_pofc
operator|+=
name|reg
expr_stmt|;
name|if_inc_counter
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|IFCOUNTER_IQDROPS
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* TX watchdog. */
if|if
condition|(
name|sc
operator|->
name|counter_watchdog_mib
operator|>
literal|0
condition|)
block|{
name|if_inc_counter
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
name|sc
operator|->
name|counter_watchdog_mib
argument_list|)
expr_stmt|;
name|sc
operator|->
name|counter_watchdog_mib
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * TX driver errors: 	 * We do not take queue locks to not disrupt TX path. 	 * We may only miss one drv error which will be fixed at 	 * next mib update. We may also clear counter when TX path 	 * is incrementing it but we only do it if counter was not zero 	 * thus we may only loose one error. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MVNETA_TX_QNUM_MAX
condition|;
name|i
operator|++
control|)
block|{
name|tx
operator|=
name|MVNETA_TX_RING
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx
operator|->
name|drv_error
operator|>
literal|0
condition|)
block|{
name|if_inc_counter
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
name|tx
operator|->
name|drv_error
argument_list|)
expr_stmt|;
name|tx
operator|->
name|drv_error
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

