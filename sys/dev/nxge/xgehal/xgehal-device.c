begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002-2007 Neterion, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<dev/nxge/include/xgehal-device.h>
end_include

begin_include
include|#
directive|include
file|<dev/nxge/include/xgehal-channel.h>
end_include

begin_include
include|#
directive|include
file|<dev/nxge/include/xgehal-fifo.h>
end_include

begin_include
include|#
directive|include
file|<dev/nxge/include/xgehal-ring.h>
end_include

begin_include
include|#
directive|include
file|<dev/nxge/include/xgehal-driver.h>
end_include

begin_include
include|#
directive|include
file|<dev/nxge/include/xgehal-mgmt.h>
end_include

begin_define
define|#
directive|define
name|SWITCH_SIGN
value|0xA5A5A5A5A5A5A5A5ULL
end_define

begin_define
define|#
directive|define
name|END_SIGN
value|0x0
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|XGE_HAL_HERC_EMULATION
end_ifdef

begin_undef
undef|#
directive|undef
name|XGE_HAL_PROCESS_LINK_INT_IN_ISR
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Jenkins hash key length(in bytes)  */
end_comment

begin_define
define|#
directive|define
name|XGE_HAL_JHASH_MSG_LEN
value|50
end_define

begin_comment
comment|/*  * mix(a,b,c) used in Jenkins hash algorithm  */
end_comment

begin_define
define|#
directive|define
name|mix
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|{ \ 	a -= b; a -= c; a ^= (c>>13); \ 	b -= c; b -= a; b ^= (a<<8);  \ 	c -= a; c -= b; c ^= (b>>13); \ 	a -= b; a -= c; a ^= (c>>12); \ 	b -= c; b -= a; b ^= (a<<16); \ 	c -= a; c -= b; c ^= (b>>5);  \ 	a -= b; a -= c; a ^= (c>>3);  \ 	b -= c; b -= a; b ^= (a<<10); \ 	c -= a; c -= b; c ^= (b>>15); \ }
end_define

begin_comment
comment|/*  * __hal_device_event_queued  * @data: pointer to xge_hal_device_t structure  *  * Will be called when new event succesfully queued.  */
end_comment

begin_function
name|void
name|__hal_device_event_queued
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|int
name|event_type
parameter_list|)
block|{
name|xge_assert
argument_list|(
operator|(
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|data
operator|)
operator|->
name|magic
operator|==
name|XGE_HAL_MAGIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_xge_hal_driver
operator|->
name|uld_callbacks
operator|.
name|event_queued
condition|)
block|{
name|g_xge_hal_driver
operator|->
name|uld_callbacks
operator|.
name|event_queued
argument_list|(
name|data
argument_list|,
name|event_type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * __hal_pio_mem_write32_upper  *  * Endiann-aware implementation of xge_os_pio_mem_write32().  * Since Xframe has 64bit registers, we differintiate uppper and lower  * parts.  */
end_comment

begin_function
name|void
name|__hal_pio_mem_write32_upper
parameter_list|(
name|pci_dev_h
name|pdev
parameter_list|,
name|pci_reg_h
name|regh
parameter_list|,
name|u32
name|val
parameter_list|,
name|void
modifier|*
name|addr
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|XGE_OS_HOST_BIG_ENDIAN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|XGE_OS_PIO_LITTLE_ENDIAN
argument_list|)
name|xge_os_pio_mem_write32
argument_list|(
name|pdev
argument_list|,
name|regh
argument_list|,
name|val
argument_list|,
name|addr
argument_list|)
expr_stmt|;
else|#
directive|else
name|xge_os_pio_mem_write32
argument_list|(
name|pdev
argument_list|,
name|regh
argument_list|,
name|val
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|addr
operator|+
literal|4
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * __hal_pio_mem_write32_upper  *  * Endiann-aware implementation of xge_os_pio_mem_write32().  * Since Xframe has 64bit registers, we differintiate uppper and lower  * parts.  */
end_comment

begin_function
name|void
name|__hal_pio_mem_write32_lower
parameter_list|(
name|pci_dev_h
name|pdev
parameter_list|,
name|pci_reg_h
name|regh
parameter_list|,
name|u32
name|val
parameter_list|,
name|void
modifier|*
name|addr
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|XGE_OS_HOST_BIG_ENDIAN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|XGE_OS_PIO_LITTLE_ENDIAN
argument_list|)
name|xge_os_pio_mem_write32
argument_list|(
name|pdev
argument_list|,
name|regh
argument_list|,
name|val
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|addr
operator|+
literal|4
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|xge_os_pio_mem_write32
argument_list|(
name|pdev
argument_list|,
name|regh
argument_list|,
name|val
argument_list|,
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * __hal_device_register_poll  * @hldev: pointer to xge_hal_device_t structure  * @reg: register to poll for  * @op: 0 - bit reset, 1 - bit set  * @mask: mask for logical "and" condition based on %op  * @max_millis: maximum time to try to poll in milliseconds  *  * Will poll certain register for specified amount of time.  * Will poll until masked bit is not cleared.  */
end_comment

begin_function
name|xge_hal_status_e
name|__hal_device_register_poll
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|,
name|u64
modifier|*
name|reg
parameter_list|,
name|int
name|op
parameter_list|,
name|u64
name|mask
parameter_list|,
name|int
name|max_millis
parameter_list|)
block|{
name|u64
name|val64
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|xge_hal_status_e
name|ret
init|=
name|XGE_HAL_FAIL
decl_stmt|;
name|xge_os_udelay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
do|do
block|{
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0
operator|&&
operator|!
operator|(
name|val64
operator|&
name|mask
operator|)
condition|)
return|return
name|XGE_HAL_OK
return|;
elseif|else
if|if
condition|(
name|op
operator|==
literal|1
operator|&&
operator|(
name|val64
operator|&
name|mask
operator|)
operator|==
name|mask
condition|)
return|return
name|XGE_HAL_OK
return|;
name|xge_os_udelay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|i
operator|<=
literal|9
condition|)
do|;
do|do
block|{
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0
operator|&&
operator|!
operator|(
name|val64
operator|&
name|mask
operator|)
condition|)
return|return
name|XGE_HAL_OK
return|;
elseif|else
if|if
condition|(
name|op
operator|==
literal|1
operator|&&
operator|(
name|val64
operator|&
name|mask
operator|)
operator|==
name|mask
condition|)
return|return
name|XGE_HAL_OK
return|;
name|xge_os_udelay
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|i
operator|<
name|max_millis
condition|)
do|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * __hal_device_wait_quiescent  * @hldev: the device  * @hw_status: hw_status in case of error  *  * Will wait until device is quiescent for some blocks.  */
end_comment

begin_function
specifier|static
name|xge_hal_status_e
name|__hal_device_wait_quiescent
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|,
name|u64
modifier|*
name|hw_status
parameter_list|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
comment|/* poll and wait first */
ifdef|#
directive|ifdef
name|XGE_HAL_HERC_EMULATION
operator|(
name|void
operator|)
name|__hal_device_register_poll
argument_list|(
name|hldev
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_status
argument_list|,
literal|1
argument_list|,
operator|(
name|XGE_HAL_ADAPTER_STATUS_TDMA_READY
operator||
name|XGE_HAL_ADAPTER_STATUS_RDMA_READY
operator||
name|XGE_HAL_ADAPTER_STATUS_PFC_READY
operator||
name|XGE_HAL_ADAPTER_STATUS_TMAC_BUF_EMPTY
operator||
name|XGE_HAL_ADAPTER_STATUS_PIC_QUIESCENT
operator||
name|XGE_HAL_ADAPTER_STATUS_MC_DRAM_READY
operator||
name|XGE_HAL_ADAPTER_STATUS_MC_QUEUES_READY
operator||
name|XGE_HAL_ADAPTER_STATUS_M_PLL_LOCK
operator|)
argument_list|,
name|XGE_HAL_DEVICE_QUIESCENT_WAIT_MAX_MILLIS
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|__hal_device_register_poll
argument_list|(
name|hldev
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_status
argument_list|,
literal|1
argument_list|,
operator|(
name|XGE_HAL_ADAPTER_STATUS_TDMA_READY
operator||
name|XGE_HAL_ADAPTER_STATUS_RDMA_READY
operator||
name|XGE_HAL_ADAPTER_STATUS_PFC_READY
operator||
name|XGE_HAL_ADAPTER_STATUS_TMAC_BUF_EMPTY
operator||
name|XGE_HAL_ADAPTER_STATUS_PIC_QUIESCENT
operator||
name|XGE_HAL_ADAPTER_STATUS_MC_DRAM_READY
operator||
name|XGE_HAL_ADAPTER_STATUS_MC_QUEUES_READY
operator||
name|XGE_HAL_ADAPTER_STATUS_M_PLL_LOCK
operator||
name|XGE_HAL_ADAPTER_STATUS_P_PLL_LOCK
operator|)
argument_list|,
name|XGE_HAL_DEVICE_QUIESCENT_WAIT_MAX_MILLIS
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|xge_hal_device_status
argument_list|(
name|hldev
argument_list|,
name|hw_status
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_device_is_slot_freeze  * @devh: the device  *  * Returns non-zero if the slot is freezed.  * The determination is made based on the adapter_status  * register which will never give all FFs, unless PCI read  * cannot go through.  */
end_comment

begin_function
name|int
name|xge_hal_device_is_slot_freeze
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|)
block|{
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u16
name|device_id
decl_stmt|;
name|u64
name|adapter_status
init|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_status
argument_list|)
decl_stmt|;
name|xge_os_pci_read16
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_le_t
argument_list|,
name|device_id
argument_list|)
argument_list|,
operator|&
name|device_id
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TX_DEBUG
if|if
condition|(
name|adapter_status
operator|==
name|XGE_HAL_ALL_FOXES
condition|)
block|{
name|u64
name|dummy
decl_stmt|;
name|dummy
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|pcc_enable
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|">>> Slot is frozen!\n"
argument_list|)
expr_stmt|;
name|brkpoint
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
operator|(
name|adapter_status
operator|==
name|XGE_HAL_ALL_FOXES
operator|)
operator|||
operator|(
name|device_id
operator|==
literal|0xffff
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * __hal_device_led_actifity_fix  * @hldev: pointer to xge_hal_device_t structure  *  * SXE-002: Configure link and activity LED to turn it off  */
end_comment

begin_function
specifier|static
name|void
name|__hal_device_led_actifity_fix
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u16
name|subid
decl_stmt|;
name|u64
name|val64
decl_stmt|;
name|xge_os_pci_read16
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_le_t
argument_list|,
name|subsystem_id
argument_list|)
argument_list|,
operator|&
name|subid
argument_list|)
expr_stmt|;
comment|/* 	 *  In the case of Herc, there is a new register named beacon control 	 *  is added which was not present in Xena. 	 *  Beacon control register in Herc is at the same offset as 	 *  gpio control register in Xena.  It means they are one and same in 	 *  the case of Xena. Also, gpio control register offset in Herc and 	 *  Xena is different. 	 *  The current register map represents Herc(It means we have 	 *  both beacon  and gpio control registers in register map). 	 *  WRT transition from Xena to Herc, all the code in Xena which was 	 *  using  gpio control register for LED handling would  have to 	 *  use beacon control register in Herc and the rest of the code 	 *  which uses gpio control in Xena  would use the same register 	 *  in Herc. 	 *  WRT LED handling(following code), In the case of Herc, beacon 	 *  control register has to be used. This is applicable for Xena also, 	 *  since it represents the gpio control register in Xena. 	 */
if|if
condition|(
operator|(
name|subid
operator|&
literal|0xFF
operator|)
operator|>=
literal|0x07
condition|)
block|{
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|beacon_control
argument_list|)
expr_stmt|;
name|val64
operator||=
literal|0x0000800000000000ULL
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|beacon_control
argument_list|)
expr_stmt|;
name|val64
operator|=
literal|0x0411040400000000ULL
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|u8
operator|*
operator|)
name|bar0
operator|+
literal|0x2700
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Constants for Fixing the MacAddress problem seen mostly on  * Alpha machines.  */
end_comment

begin_decl_stmt
specifier|static
name|u64
name|xena_fix_mac
index|[]
init|=
block|{
literal|0x0060000000000000ULL
block|,
literal|0x0060600000000000ULL
block|,
literal|0x0040600000000000ULL
block|,
literal|0x0000600000000000ULL
block|,
literal|0x0020600000000000ULL
block|,
literal|0x0060600000000000ULL
block|,
literal|0x0020600000000000ULL
block|,
literal|0x0060600000000000ULL
block|,
literal|0x0020600000000000ULL
block|,
literal|0x0060600000000000ULL
block|,
literal|0x0020600000000000ULL
block|,
literal|0x0060600000000000ULL
block|,
literal|0x0020600000000000ULL
block|,
literal|0x0060600000000000ULL
block|,
literal|0x0020600000000000ULL
block|,
literal|0x0060600000000000ULL
block|,
literal|0x0020600000000000ULL
block|,
literal|0x0060600000000000ULL
block|,
literal|0x0020600000000000ULL
block|,
literal|0x0060600000000000ULL
block|,
literal|0x0020600000000000ULL
block|,
literal|0x0060600000000000ULL
block|,
literal|0x0020600000000000ULL
block|,
literal|0x0060600000000000ULL
block|,
literal|0x0020600000000000ULL
block|,
literal|0x0000600000000000ULL
block|,
literal|0x0040600000000000ULL
block|,
literal|0x0060600000000000ULL
block|,
name|END_SIGN
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * __hal_device_fix_mac  * @hldev: HAL device handle.  *  * Fix for all "FFs" MAC address problems observed on Alpha platforms.  */
end_comment

begin_function
specifier|static
name|void
name|__hal_device_xena_fix_mac
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
comment|/* 	 *  In the case of Herc, there is a new register named beacon control 	 *  is added which was not present in Xena. 	 *  Beacon control register in Herc is at the same offset as 	 *  gpio control register in Xena.  It means they are one and same in 	 *  the case of Xena. Also, gpio control register offset in Herc and 	 *  Xena is different. 	 *  The current register map represents Herc(It means we have 	 *  both beacon  and gpio control registers in register map). 	 *  WRT transition from Xena to Herc, all the code in Xena which was 	 *  using  gpio control register for LED handling would  have to 	 *  use beacon control register in Herc and the rest of the code 	 *  which uses gpio control in Xena  would use the same register 	 *  in Herc. 	 *  In the following code(xena_fix_mac), beacon control register has 	 *  to be used in the case of Xena, since it represents gpio control 	 *  register. In the case of Herc, there is no change required. 	 */
while|while
condition|(
name|xena_fix_mac
index|[
name|i
index|]
operator|!=
name|END_SIGN
condition|)
block|{
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|xena_fix_mac
index|[
name|i
operator|++
index|]
argument_list|,
operator|&
name|bar0
operator|->
name|beacon_control
argument_list|)
expr_stmt|;
name|xge_os_mdelay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * xge_hal_device_bcast_enable  * @hldev: HAL device handle.  *  * Enable receiving broadcasts.  * The host must first write RMAC_CFG_KEY "key"  * register, and then - MAC_CFG register.  */
end_comment

begin_function
name|void
name|xge_hal_device_bcast_enable
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|)
block|{
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|mac_cfg
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_MAC_RMAC_BCAST_ENABLE
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|XGE_HAL_RMAC_CFG_KEY
argument_list|(
literal|0x4C0D
argument_list|)
argument_list|,
operator|&
name|bar0
operator|->
name|rmac_cfg_key
argument_list|)
expr_stmt|;
name|__hal_pio_mem_write32_upper
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
call|(
name|u32
call|)
argument_list|(
name|val64
operator|>>
literal|32
argument_list|)
argument_list|,
operator|&
name|bar0
operator|->
name|mac_cfg
argument_list|)
expr_stmt|;
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"mac_cfg 0x"
name|XGE_OS_LLXFMT
literal|": broadcast %s"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|val64
argument_list|,
name|hldev
operator|->
name|config
operator|.
name|mac
operator|.
name|rmac_bcast_en
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * xge_hal_device_bcast_disable  * @hldev: HAL device handle.  *  * Disable receiving broadcasts.  * The host must first write RMAC_CFG_KEY "key"  * register, and then - MAC_CFG register.  */
end_comment

begin_function
name|void
name|xge_hal_device_bcast_disable
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|)
block|{
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|mac_cfg
argument_list|)
expr_stmt|;
name|val64
operator|&=
operator|~
operator|(
name|XGE_HAL_MAC_RMAC_BCAST_ENABLE
operator|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|XGE_HAL_RMAC_CFG_KEY
argument_list|(
literal|0x4C0D
argument_list|)
argument_list|,
operator|&
name|bar0
operator|->
name|rmac_cfg_key
argument_list|)
expr_stmt|;
name|__hal_pio_mem_write32_upper
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
call|(
name|u32
call|)
argument_list|(
name|val64
operator|>>
literal|32
argument_list|)
argument_list|,
operator|&
name|bar0
operator|->
name|mac_cfg
argument_list|)
expr_stmt|;
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"mac_cfg 0x"
name|XGE_OS_LLXFMT
literal|": broadcast %s"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|val64
argument_list|,
name|hldev
operator|->
name|config
operator|.
name|mac
operator|.
name|rmac_bcast_en
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * __hal_device_shared_splits_configure  * @hldev: HAL device handle.  *  * TxDMA will stop Read request if the number of read split had exceeded  * the limit set by shared_splits  */
end_comment

begin_function
specifier|static
name|void
name|__hal_device_shared_splits_configure
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|pic_control
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_PIC_CNTL_SHARED_SPLITS
argument_list|(
name|hldev
operator|->
name|config
operator|.
name|shared_splits
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|pic_control
argument_list|)
expr_stmt|;
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"%s"
argument_list|,
literal|"shared splits configured"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * __hal_device_rmac_padding_configure  * @hldev: HAL device handle.  *  * Configure RMAC frame padding. Depends on configuration, it  * can be send to host or removed by MAC.  */
end_comment

begin_function
specifier|static
name|void
name|__hal_device_rmac_padding_configure
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|XGE_HAL_RMAC_CFG_KEY
argument_list|(
literal|0x4C0D
argument_list|)
argument_list|,
operator|&
name|bar0
operator|->
name|rmac_cfg_key
argument_list|)
expr_stmt|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|mac_cfg
argument_list|)
expr_stmt|;
name|val64
operator|&=
operator|(
operator|~
name|XGE_HAL_MAC_RMAC_ALL_ADDR_ENABLE
operator|)
expr_stmt|;
name|val64
operator|&=
operator|(
operator|~
name|XGE_HAL_MAC_CFG_RMAC_PROM_ENABLE
operator|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_MAC_CFG_TMAC_APPEND_PAD
expr_stmt|;
comment|/* 	 * If the RTH enable bit is not set, strip the FCS 	 */
if|if
condition|(
operator|!
name|hldev
operator|->
name|config
operator|.
name|rth_en
operator|||
operator|!
operator|(
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|rts_rth_cfg
argument_list|)
operator|&
name|XGE_HAL_RTS_RTH_EN
operator|)
condition|)
block|{
name|val64
operator||=
name|XGE_HAL_MAC_CFG_RMAC_STRIP_FCS
expr_stmt|;
block|}
name|val64
operator|&=
operator|(
operator|~
name|XGE_HAL_MAC_CFG_RMAC_STRIP_PAD
operator|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_MAC_RMAC_DISCARD_PFRM
expr_stmt|;
name|__hal_pio_mem_write32_upper
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
call|(
name|u32
call|)
argument_list|(
name|val64
operator|>>
literal|32
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|bar0
operator|->
name|mac_cfg
argument_list|)
expr_stmt|;
name|xge_os_mdelay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"mac_cfg 0x"
name|XGE_OS_LLXFMT
literal|": frame padding configured"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|val64
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * __hal_device_pause_frames_configure  * @hldev: HAL device handle.  *  * Set Pause threshold.  *  * Pause frame is generated if the amount of data outstanding  * on any queue exceeded the ratio of  * (mac_control.mc_pause_threshold_q0q3 or q4q7)/256  */
end_comment

begin_function
specifier|static
name|void
name|__hal_device_pause_frames_configure
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u64
name|val64
decl_stmt|;
switch|switch
condition|(
name|hldev
operator|->
name|config
operator|.
name|mac
operator|.
name|media
condition|)
block|{
case|case
name|XGE_HAL_MEDIA_SR
case|:
case|case
name|XGE_HAL_MEDIA_SW
case|:
name|val64
operator|=
literal|0xfffbfffbfffbfffbULL
expr_stmt|;
break|break;
case|case
name|XGE_HAL_MEDIA_LR
case|:
case|case
name|XGE_HAL_MEDIA_LW
case|:
name|val64
operator|=
literal|0xffbbffbbffbbffbbULL
expr_stmt|;
break|break;
case|case
name|XGE_HAL_MEDIA_ER
case|:
case|case
name|XGE_HAL_MEDIA_EW
case|:
default|default:
name|val64
operator|=
literal|0xffbbffbbffbbffbbULL
expr_stmt|;
break|break;
block|}
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|mc_pause_thresh_q0q3
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|mc_pause_thresh_q4q7
argument_list|)
expr_stmt|;
comment|/* Set the time value  to be inserted in the pause frame generated 	 * by Xframe */
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|rmac_pause_cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|hldev
operator|->
name|config
operator|.
name|mac
operator|.
name|rmac_pause_gen_en
condition|)
name|val64
operator||=
name|XGE_HAL_RMAC_PAUSE_GEN_EN
expr_stmt|;
else|else
name|val64
operator|&=
operator|~
operator|(
name|XGE_HAL_RMAC_PAUSE_GEN_EN
operator|)
expr_stmt|;
if|if
condition|(
name|hldev
operator|->
name|config
operator|.
name|mac
operator|.
name|rmac_pause_rcv_en
condition|)
name|val64
operator||=
name|XGE_HAL_RMAC_PAUSE_RCV_EN
expr_stmt|;
else|else
name|val64
operator|&=
operator|~
operator|(
name|XGE_HAL_RMAC_PAUSE_RCV_EN
operator|)
expr_stmt|;
name|val64
operator|&=
operator|~
operator|(
name|XGE_HAL_RMAC_PAUSE_HG_PTIME
argument_list|(
literal|0xffff
argument_list|)
operator|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_RMAC_PAUSE_HG_PTIME
argument_list|(
name|hldev
operator|->
name|config
operator|.
name|mac
operator|.
name|rmac_pause_time
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rmac_pause_cfg
argument_list|)
expr_stmt|;
name|val64
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|val64
operator||=
operator|(
operator|(
operator|(
name|u64
operator|)
literal|0xFF00
operator||
name|hldev
operator|->
name|config
operator|.
name|mac
operator|.
name|mc_pause_threshold_q0q3
operator|)
operator|<<
operator|(
name|i
operator|*
literal|2
operator|*
literal|8
operator|)
operator|)
expr_stmt|;
block|}
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|mc_pause_thresh_q0q3
argument_list|)
expr_stmt|;
name|val64
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|val64
operator||=
operator|(
operator|(
operator|(
name|u64
operator|)
literal|0xFF00
operator||
name|hldev
operator|->
name|config
operator|.
name|mac
operator|.
name|mc_pause_threshold_q4q7
operator|)
operator|<<
operator|(
name|i
operator|*
literal|2
operator|*
literal|8
operator|)
operator|)
expr_stmt|;
block|}
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|mc_pause_thresh_q4q7
argument_list|)
expr_stmt|;
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"%s"
argument_list|,
literal|"pause frames configured"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Herc's clock rate doubled, unless the slot is 33MHz.  */
end_comment

begin_function
name|unsigned
name|int
name|__hal_fix_time_ival_herc
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|,
name|unsigned
name|int
name|time_ival
parameter_list|)
block|{
if|if
condition|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_XENA
condition|)
return|return
name|time_ival
return|;
name|xge_assert
argument_list|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_HERC
argument_list|)
expr_stmt|;
if|if
condition|(
name|hldev
operator|->
name|bus_frequency
operator|!=
name|XGE_HAL_PCI_BUS_FREQUENCY_UNKNOWN
operator|&&
name|hldev
operator|->
name|bus_frequency
operator|!=
name|XGE_HAL_PCI_BUS_FREQUENCY_33MHZ
condition|)
name|time_ival
operator|*=
literal|2
expr_stmt|;
return|return
name|time_ival
return|;
block|}
end_function

begin_comment
comment|/*  * __hal_device_bus_master_disable  * @hldev: HAL device handle.  *  * Disable bus mastership.  */
end_comment

begin_function
specifier|static
name|void
name|__hal_device_bus_master_disable
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{
name|u16
name|cmd
decl_stmt|;
name|u16
name|bus_master
init|=
literal|4
decl_stmt|;
name|xge_os_pci_read16
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_le_t
argument_list|,
name|command
argument_list|)
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|&=
operator|~
name|bus_master
expr_stmt|;
name|xge_os_pci_write16
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_le_t
argument_list|,
name|command
argument_list|)
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * __hal_device_bus_master_enable  * @hldev: HAL device handle.  *  * Disable bus mastership.  */
end_comment

begin_function
specifier|static
name|void
name|__hal_device_bus_master_enable
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{
name|u16
name|cmd
decl_stmt|;
name|u16
name|bus_master
init|=
literal|4
decl_stmt|;
name|xge_os_pci_read16
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_le_t
argument_list|,
name|command
argument_list|)
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
comment|/* already enabled? do nothing */
if|if
condition|(
name|cmd
operator|&
name|bus_master
condition|)
return|return;
name|cmd
operator||=
name|bus_master
expr_stmt|;
name|xge_os_pci_write16
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_le_t
argument_list|,
name|command
argument_list|)
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * __hal_device_intr_mgmt  * @hldev: HAL device handle.  * @mask: mask indicating which Intr block must be modified.  * @flag: if true - enable, otherwise - disable interrupts.  *  * Disable or enable device interrupts. Mask is used to specify  * which hardware blocks should produce interrupts. For details  * please refer to Xframe User Guide.  */
end_comment

begin_function
specifier|static
name|void
name|__hal_device_intr_mgmt
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|,
name|u64
name|mask
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
init|=
literal|0
decl_stmt|,
name|temp64
init|=
literal|0
decl_stmt|;
name|u64
name|gim
decl_stmt|,
name|gim_saved
decl_stmt|;
name|gim_saved
operator|=
name|gim
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|general_int_mask
argument_list|)
expr_stmt|;
comment|/* Top level interrupt classification */
comment|/* PIC Interrupts */
if|if
condition|(
operator|(
name|mask
operator|&
operator|(
name|XGE_HAL_TX_PIC_INTR
comment|/* | XGE_HAL_RX_PIC_INTR*/
operator|)
operator|)
condition|)
block|{
comment|/* Enable PIC Intrs in the general intr mask register */
name|val64
operator|=
name|XGE_HAL_TXPIC_INT_M
comment|/* | XGE_HAL_PIC_RX_INT_M*/
expr_stmt|;
if|if
condition|(
name|flag
condition|)
block|{
name|gim
operator|&=
operator|~
operator|(
operator|(
name|u64
operator|)
name|val64
operator|)
expr_stmt|;
name|temp64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|pic_int_mask
argument_list|)
expr_stmt|;
name|temp64
operator|&=
operator|~
name|XGE_HAL_PIC_INT_TX
expr_stmt|;
ifdef|#
directive|ifdef
name|XGE_HAL_PROCESS_LINK_INT_IN_ISR
if|if
condition|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_HERC
condition|)
block|{
name|temp64
operator|&=
operator|~
name|XGE_HAL_PIC_INT_MISC
expr_stmt|;
block|}
endif|#
directive|endif
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|temp64
argument_list|,
operator|&
name|bar0
operator|->
name|pic_int_mask
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XGE_HAL_PROCESS_LINK_INT_IN_ISR
if|if
condition|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_HERC
condition|)
block|{
comment|/* 	             * Unmask only Link Up interrupt 	             */
name|temp64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|misc_int_mask
argument_list|)
expr_stmt|;
name|temp64
operator|&=
operator|~
name|XGE_HAL_MISC_INT_REG_LINK_UP_INT
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|temp64
argument_list|,
operator|&
name|bar0
operator|->
name|misc_int_mask
argument_list|)
expr_stmt|;
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"unmask link up flag "
name|XGE_OS_LLXFMT
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|temp64
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
comment|/* flag == 0 */
ifdef|#
directive|ifdef
name|XGE_HAL_PROCESS_LINK_INT_IN_ISR
if|if
condition|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_HERC
condition|)
block|{
comment|/* 	             * Mask both Link Up and Down interrupts 	             */
name|temp64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|misc_int_mask
argument_list|)
expr_stmt|;
name|temp64
operator||=
name|XGE_HAL_MISC_INT_REG_LINK_UP_INT
expr_stmt|;
name|temp64
operator||=
name|XGE_HAL_MISC_INT_REG_LINK_DOWN_INT
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|temp64
argument_list|,
operator|&
name|bar0
operator|->
name|misc_int_mask
argument_list|)
expr_stmt|;
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"mask link up/down flag "
name|XGE_OS_LLXFMT
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|temp64
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Disable PIC Intrs in the general intr mask 	         * register */
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|XGE_HAL_ALL_INTRS_DIS
argument_list|,
operator|&
name|bar0
operator|->
name|pic_int_mask
argument_list|)
expr_stmt|;
name|gim
operator||=
name|val64
expr_stmt|;
block|}
block|}
comment|/*  DMA Interrupts */
comment|/*  Enabling/Disabling Tx DMA interrupts */
if|if
condition|(
name|mask
operator|&
name|XGE_HAL_TX_DMA_INTR
condition|)
block|{
comment|/*  Enable TxDMA Intrs in the general intr mask register */
name|val64
operator|=
name|XGE_HAL_TXDMA_INT_M
expr_stmt|;
if|if
condition|(
name|flag
condition|)
block|{
name|gim
operator|&=
operator|~
operator|(
operator|(
name|u64
operator|)
name|val64
operator|)
expr_stmt|;
comment|/* Enable all TxDMA interrupts */
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
literal|0x0
argument_list|,
operator|&
name|bar0
operator|->
name|txdma_int_mask
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
literal|0x0
argument_list|,
operator|&
name|bar0
operator|->
name|pfc_err_mask
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
literal|0x0
argument_list|,
operator|&
name|bar0
operator|->
name|tda_err_mask
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
literal|0x0
argument_list|,
operator|&
name|bar0
operator|->
name|pcc_err_mask
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
literal|0x0
argument_list|,
operator|&
name|bar0
operator|->
name|tti_err_mask
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
literal|0x0
argument_list|,
operator|&
name|bar0
operator|->
name|lso_err_mask
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
literal|0x0
argument_list|,
operator|&
name|bar0
operator|->
name|tpa_err_mask
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
literal|0x0
argument_list|,
operator|&
name|bar0
operator|->
name|sm_err_mask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* flag == 0 */
comment|/*  Disable TxDMA Intrs in the general intr mask 	         *  register */
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|XGE_HAL_ALL_INTRS_DIS
argument_list|,
operator|&
name|bar0
operator|->
name|txdma_int_mask
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|XGE_HAL_ALL_INTRS_DIS
argument_list|,
operator|&
name|bar0
operator|->
name|pfc_err_mask
argument_list|)
expr_stmt|;
name|gim
operator||=
name|val64
expr_stmt|;
block|}
block|}
comment|/*  Enabling/Disabling Rx DMA interrupts */
if|if
condition|(
name|mask
operator|&
name|XGE_HAL_RX_DMA_INTR
condition|)
block|{
comment|/*  Enable RxDMA Intrs in the general intr mask register */
name|val64
operator|=
name|XGE_HAL_RXDMA_INT_M
expr_stmt|;
if|if
condition|(
name|flag
condition|)
block|{
name|gim
operator|&=
operator|~
operator|(
operator|(
name|u64
operator|)
name|val64
operator|)
expr_stmt|;
comment|/* All RxDMA block interrupts are disabled for now 	         * TODO */
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|XGE_HAL_ALL_INTRS_DIS
argument_list|,
operator|&
name|bar0
operator|->
name|rxdma_int_mask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* flag == 0 */
comment|/*  Disable RxDMA Intrs in the general intr mask 	         *  register */
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|XGE_HAL_ALL_INTRS_DIS
argument_list|,
operator|&
name|bar0
operator|->
name|rxdma_int_mask
argument_list|)
expr_stmt|;
name|gim
operator||=
name|val64
expr_stmt|;
block|}
block|}
comment|/*  MAC Interrupts */
comment|/*  Enabling/Disabling MAC interrupts */
if|if
condition|(
name|mask
operator|&
operator|(
name|XGE_HAL_TX_MAC_INTR
operator||
name|XGE_HAL_RX_MAC_INTR
operator|)
condition|)
block|{
name|val64
operator|=
name|XGE_HAL_TXMAC_INT_M
operator||
name|XGE_HAL_RXMAC_INT_M
expr_stmt|;
if|if
condition|(
name|flag
condition|)
block|{
name|gim
operator|&=
operator|~
operator|(
operator|(
name|u64
operator|)
name|val64
operator|)
expr_stmt|;
comment|/* All MAC block error inter. are disabled for now. */
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|XGE_HAL_ALL_INTRS_DIS
argument_list|,
operator|&
name|bar0
operator|->
name|mac_int_mask
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|XGE_HAL_ALL_INTRS_DIS
argument_list|,
operator|&
name|bar0
operator|->
name|mac_rmac_err_mask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* flag == 0 */
comment|/* Disable MAC Intrs in the general intr mask 	         * register */
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|XGE_HAL_ALL_INTRS_DIS
argument_list|,
operator|&
name|bar0
operator|->
name|mac_int_mask
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|XGE_HAL_ALL_INTRS_DIS
argument_list|,
operator|&
name|bar0
operator|->
name|mac_rmac_err_mask
argument_list|)
expr_stmt|;
name|gim
operator||=
name|val64
expr_stmt|;
block|}
block|}
comment|/*  XGXS Interrupts */
if|if
condition|(
name|mask
operator|&
operator|(
name|XGE_HAL_TX_XGXS_INTR
operator||
name|XGE_HAL_RX_XGXS_INTR
operator|)
condition|)
block|{
name|val64
operator|=
name|XGE_HAL_TXXGXS_INT_M
operator||
name|XGE_HAL_RXXGXS_INT_M
expr_stmt|;
if|if
condition|(
name|flag
condition|)
block|{
name|gim
operator|&=
operator|~
operator|(
operator|(
name|u64
operator|)
name|val64
operator|)
expr_stmt|;
comment|/* All XGXS block error interrupts are disabled for now 	         * TODO */
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|XGE_HAL_ALL_INTRS_DIS
argument_list|,
operator|&
name|bar0
operator|->
name|xgxs_int_mask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* flag == 0 */
comment|/* Disable MC Intrs in the general intr mask register */
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|XGE_HAL_ALL_INTRS_DIS
argument_list|,
operator|&
name|bar0
operator|->
name|xgxs_int_mask
argument_list|)
expr_stmt|;
name|gim
operator||=
name|val64
expr_stmt|;
block|}
block|}
comment|/*  Memory Controller(MC) interrupts */
if|if
condition|(
name|mask
operator|&
name|XGE_HAL_MC_INTR
condition|)
block|{
name|val64
operator|=
name|XGE_HAL_MC_INT_M
expr_stmt|;
if|if
condition|(
name|flag
condition|)
block|{
name|gim
operator|&=
operator|~
operator|(
operator|(
name|u64
operator|)
name|val64
operator|)
expr_stmt|;
comment|/* Enable all MC blocks error interrupts */
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
literal|0x0ULL
argument_list|,
operator|&
name|bar0
operator|->
name|mc_int_mask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* flag == 0 */
comment|/* Disable MC Intrs in the general intr mask 	         * register */
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|XGE_HAL_ALL_INTRS_DIS
argument_list|,
operator|&
name|bar0
operator|->
name|mc_int_mask
argument_list|)
expr_stmt|;
name|gim
operator||=
name|val64
expr_stmt|;
block|}
block|}
comment|/*  Tx traffic interrupts */
if|if
condition|(
name|mask
operator|&
name|XGE_HAL_TX_TRAFFIC_INTR
condition|)
block|{
name|val64
operator|=
name|XGE_HAL_TXTRAFFIC_INT_M
expr_stmt|;
if|if
condition|(
name|flag
condition|)
block|{
name|gim
operator|&=
operator|~
operator|(
operator|(
name|u64
operator|)
name|val64
operator|)
expr_stmt|;
comment|/* Enable all the Tx side interrupts */
comment|/* '0' Enables all 64 TX interrupt levels. */
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
literal|0x0
argument_list|,
operator|&
name|bar0
operator|->
name|tx_traffic_mask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* flag == 0 */
comment|/* Disable Tx Traffic Intrs in the general intr mask 	         * register. */
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|XGE_HAL_ALL_INTRS_DIS
argument_list|,
operator|&
name|bar0
operator|->
name|tx_traffic_mask
argument_list|)
expr_stmt|;
name|gim
operator||=
name|val64
expr_stmt|;
block|}
block|}
comment|/*  Rx traffic interrupts */
if|if
condition|(
name|mask
operator|&
name|XGE_HAL_RX_TRAFFIC_INTR
condition|)
block|{
name|val64
operator|=
name|XGE_HAL_RXTRAFFIC_INT_M
expr_stmt|;
if|if
condition|(
name|flag
condition|)
block|{
name|gim
operator|&=
operator|~
operator|(
operator|(
name|u64
operator|)
name|val64
operator|)
expr_stmt|;
comment|/* '0' Enables all 8 RX interrupt levels. */
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
literal|0x0
argument_list|,
operator|&
name|bar0
operator|->
name|rx_traffic_mask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* flag == 0 */
comment|/* Disable Rx Traffic Intrs in the general intr mask 	         * register. 	         */
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|XGE_HAL_ALL_INTRS_DIS
argument_list|,
operator|&
name|bar0
operator|->
name|rx_traffic_mask
argument_list|)
expr_stmt|;
name|gim
operator||=
name|val64
expr_stmt|;
block|}
block|}
comment|/* Sched Timer interrupt */
if|if
condition|(
name|mask
operator|&
name|XGE_HAL_SCHED_INTR
condition|)
block|{
if|if
condition|(
name|flag
condition|)
block|{
name|temp64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|txpic_int_mask
argument_list|)
expr_stmt|;
name|temp64
operator|&=
operator|~
name|XGE_HAL_TXPIC_INT_SCHED_INTR
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|temp64
argument_list|,
operator|&
name|bar0
operator|->
name|txpic_int_mask
argument_list|)
expr_stmt|;
name|xge_hal_device_sched_timer
argument_list|(
name|hldev
argument_list|,
name|hldev
operator|->
name|config
operator|.
name|sched_timer_us
argument_list|,
name|hldev
operator|->
name|config
operator|.
name|sched_timer_one_shot
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|temp64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|txpic_int_mask
argument_list|)
expr_stmt|;
name|temp64
operator||=
name|XGE_HAL_TXPIC_INT_SCHED_INTR
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|temp64
argument_list|,
operator|&
name|bar0
operator|->
name|txpic_int_mask
argument_list|)
expr_stmt|;
name|xge_hal_device_sched_timer
argument_list|(
name|hldev
argument_list|,
name|XGE_HAL_SCHED_TIMER_DISABLED
argument_list|,
name|XGE_HAL_SCHED_TIMER_ON_SHOT_ENABLE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gim
operator|!=
name|gim_saved
condition|)
block|{
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|gim
argument_list|,
operator|&
name|bar0
operator|->
name|general_int_mask
argument_list|)
expr_stmt|;
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"general_int_mask updated "
name|XGE_OS_LLXFMT
literal|" => "
name|XGE_OS_LLXFMT
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|gim_saved
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|gim
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * __hal_device_bimodal_configure  * @hldev: HAL device handle.  *  * Bimodal parameters initialization.  */
end_comment

begin_function
specifier|static
name|void
name|__hal_device_bimodal_configure
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XGE_HAL_MAX_RING_NUM
condition|;
name|i
operator|++
control|)
block|{
name|xge_hal_tti_config_t
modifier|*
name|tti
decl_stmt|;
name|xge_hal_rti_config_t
modifier|*
name|rti
decl_stmt|;
if|if
condition|(
operator|!
name|hldev
operator|->
name|config
operator|.
name|ring
operator|.
name|queue
index|[
name|i
index|]
operator|.
name|configured
condition|)
continue|continue;
name|rti
operator|=
operator|&
name|hldev
operator|->
name|config
operator|.
name|ring
operator|.
name|queue
index|[
name|i
index|]
operator|.
name|rti
expr_stmt|;
name|tti
operator|=
operator|&
name|hldev
operator|->
name|bimodal_tti
index|[
name|i
index|]
expr_stmt|;
name|tti
operator|->
name|enabled
operator|=
literal|1
expr_stmt|;
name|tti
operator|->
name|urange_a
operator|=
name|hldev
operator|->
name|bimodal_urange_a_en
operator|*
literal|10
expr_stmt|;
name|tti
operator|->
name|urange_b
operator|=
literal|20
expr_stmt|;
name|tti
operator|->
name|urange_c
operator|=
literal|30
expr_stmt|;
name|tti
operator|->
name|ufc_a
operator|=
name|hldev
operator|->
name|bimodal_urange_a_en
operator|*
literal|8
expr_stmt|;
name|tti
operator|->
name|ufc_b
operator|=
literal|16
expr_stmt|;
name|tti
operator|->
name|ufc_c
operator|=
literal|32
expr_stmt|;
name|tti
operator|->
name|ufc_d
operator|=
literal|64
expr_stmt|;
name|tti
operator|->
name|timer_val_us
operator|=
name|hldev
operator|->
name|bimodal_timer_val_us
expr_stmt|;
name|tti
operator|->
name|timer_ac_en
operator|=
literal|1
expr_stmt|;
name|tti
operator|->
name|timer_ci_en
operator|=
literal|0
expr_stmt|;
name|rti
operator|->
name|urange_a
operator|=
literal|10
expr_stmt|;
name|rti
operator|->
name|urange_b
operator|=
literal|20
expr_stmt|;
name|rti
operator|->
name|urange_c
operator|=
literal|30
expr_stmt|;
name|rti
operator|->
name|ufc_a
operator|=
literal|1
expr_stmt|;
comment|/*<= for netpipe type of tests */
name|rti
operator|->
name|ufc_b
operator|=
literal|4
expr_stmt|;
name|rti
operator|->
name|ufc_c
operator|=
literal|4
expr_stmt|;
name|rti
operator|->
name|ufc_d
operator|=
literal|4
expr_stmt|;
comment|/*<= 99% of a bandwidth traffic counts here */
name|rti
operator|->
name|timer_ac_en
operator|=
literal|1
expr_stmt|;
name|rti
operator|->
name|timer_val_us
operator|=
literal|5
expr_stmt|;
comment|/* for optimal bus efficiency usage */
block|}
block|}
end_function

begin_comment
comment|/*  * __hal_device_tti_apply  * @hldev: HAL device handle.  *  * apply TTI configuration.  */
end_comment

begin_function
specifier|static
name|xge_hal_status_e
name|__hal_device_tti_apply
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|,
name|xge_hal_tti_config_t
modifier|*
name|tti
parameter_list|,
name|int
name|num
parameter_list|,
name|int
name|runtime
parameter_list|)
block|{
name|u64
name|val64
decl_stmt|,
name|data1
init|=
literal|0
decl_stmt|,
name|data2
init|=
literal|0
decl_stmt|;
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
decl_stmt|;
if|if
condition|(
name|runtime
condition|)
name|bar0
operator|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|isrbar0
expr_stmt|;
else|else
name|bar0
operator|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
expr_stmt|;
if|if
condition|(
name|tti
operator|->
name|timer_val_us
condition|)
block|{
name|unsigned
name|int
name|tx_interval
decl_stmt|;
if|if
condition|(
name|hldev
operator|->
name|config
operator|.
name|pci_freq_mherz
condition|)
block|{
name|tx_interval
operator|=
name|hldev
operator|->
name|config
operator|.
name|pci_freq_mherz
operator|*
name|tti
operator|->
name|timer_val_us
operator|/
literal|64
expr_stmt|;
name|tx_interval
operator|=
name|__hal_fix_time_ival_herc
argument_list|(
name|hldev
argument_list|,
name|tx_interval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tx_interval
operator|=
name|tti
operator|->
name|timer_val_us
expr_stmt|;
block|}
name|data1
operator||=
name|XGE_HAL_TTI_DATA1_MEM_TX_TIMER_VAL
argument_list|(
name|tx_interval
argument_list|)
expr_stmt|;
if|if
condition|(
name|tti
operator|->
name|timer_ac_en
condition|)
block|{
name|data1
operator||=
name|XGE_HAL_TTI_DATA1_MEM_TX_TIMER_AC_EN
expr_stmt|;
block|}
if|if
condition|(
name|tti
operator|->
name|timer_ci_en
condition|)
block|{
name|data1
operator||=
name|XGE_HAL_TTI_DATA1_MEM_TX_TIMER_CI_EN
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|runtime
condition|)
block|{
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"TTI[%d] timer enabled to %d, ci %s"
argument_list|,
name|num
argument_list|,
name|tx_interval
argument_list|,
name|tti
operator|->
name|timer_ci_en
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tti
operator|->
name|urange_a
operator|||
name|tti
operator|->
name|urange_b
operator|||
name|tti
operator|->
name|urange_c
operator|||
name|tti
operator|->
name|ufc_a
operator|||
name|tti
operator|->
name|ufc_b
operator|||
name|tti
operator|->
name|ufc_c
operator|||
name|tti
operator|->
name|ufc_d
condition|)
block|{
name|data1
operator||=
name|XGE_HAL_TTI_DATA1_MEM_TX_URNG_A
argument_list|(
name|tti
operator|->
name|urange_a
argument_list|)
operator||
name|XGE_HAL_TTI_DATA1_MEM_TX_URNG_B
argument_list|(
name|tti
operator|->
name|urange_b
argument_list|)
operator||
name|XGE_HAL_TTI_DATA1_MEM_TX_URNG_C
argument_list|(
name|tti
operator|->
name|urange_c
argument_list|)
expr_stmt|;
name|data2
operator||=
name|XGE_HAL_TTI_DATA2_MEM_TX_UFC_A
argument_list|(
name|tti
operator|->
name|ufc_a
argument_list|)
operator||
name|XGE_HAL_TTI_DATA2_MEM_TX_UFC_B
argument_list|(
name|tti
operator|->
name|ufc_b
argument_list|)
operator||
name|XGE_HAL_TTI_DATA2_MEM_TX_UFC_C
argument_list|(
name|tti
operator|->
name|ufc_c
argument_list|)
operator||
name|XGE_HAL_TTI_DATA2_MEM_TX_UFC_D
argument_list|(
name|tti
operator|->
name|ufc_d
argument_list|)
expr_stmt|;
block|}
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|data1
argument_list|,
operator|&
name|bar0
operator|->
name|tti_data1_mem
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|tti_data1_mem
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|data2
argument_list|,
operator|&
name|bar0
operator|->
name|tti_data2_mem
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|tti_data2_mem
argument_list|)
expr_stmt|;
name|xge_os_wmb
argument_list|()
expr_stmt|;
name|val64
operator|=
name|XGE_HAL_TTI_CMD_MEM_WE
operator||
name|XGE_HAL_TTI_CMD_MEM_STROBE_NEW_CMD
operator||
name|XGE_HAL_TTI_CMD_MEM_OFFSET
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|tti_command_mem
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|runtime
operator|&&
name|__hal_device_register_poll
argument_list|(
name|hldev
argument_list|,
operator|&
name|bar0
operator|->
name|tti_command_mem
argument_list|,
literal|0
argument_list|,
name|XGE_HAL_TTI_CMD_MEM_STROBE_NEW_CMD
argument_list|,
name|XGE_HAL_DEVICE_CMDMEM_WAIT_MAX_MILLIS
argument_list|)
operator|!=
name|XGE_HAL_OK
condition|)
block|{
comment|/* upper layer may require to repeat */
return|return
name|XGE_HAL_INF_MEM_STROBE_CMD_EXECUTING
return|;
block|}
if|if
condition|(
operator|!
name|runtime
condition|)
block|{
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"TTI[%d] configured: tti_data1_mem 0x"
name|XGE_OS_LLXFMT
argument_list|,
name|num
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|tti_data1_mem
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/*  * __hal_device_tti_configure  * @hldev: HAL device handle.  *  * TTI Initialization.  * Initialize Transmit Traffic Interrupt Scheme.  */
end_comment

begin_function
specifier|static
name|xge_hal_status_e
name|__hal_device_tti_configure
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|,
name|int
name|runtime
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XGE_HAL_MAX_FIFO_NUM
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|hldev
operator|->
name|config
operator|.
name|fifo
operator|.
name|queue
index|[
name|i
index|]
operator|.
name|configured
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XGE_HAL_MAX_FIFO_TTI_NUM
condition|;
name|j
operator|++
control|)
block|{
name|xge_hal_status_e
name|status
decl_stmt|;
if|if
condition|(
operator|!
name|hldev
operator|->
name|config
operator|.
name|fifo
operator|.
name|queue
index|[
name|i
index|]
operator|.
name|tti
index|[
name|j
index|]
operator|.
name|enabled
condition|)
continue|continue;
comment|/* at least some TTI enabled. Record it. */
name|hldev
operator|->
name|tti_enabled
operator|=
literal|1
expr_stmt|;
name|status
operator|=
name|__hal_device_tti_apply
argument_list|(
name|hldev
argument_list|,
operator|&
name|hldev
operator|->
name|config
operator|.
name|fifo
operator|.
name|queue
index|[
name|i
index|]
operator|.
name|tti
index|[
name|j
index|]
argument_list|,
name|i
operator|*
name|XGE_HAL_MAX_FIFO_TTI_NUM
operator|+
name|j
argument_list|,
name|runtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
return|return
name|status
return|;
block|}
block|}
comment|/* processing bimodal TTIs */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XGE_HAL_MAX_RING_NUM
condition|;
name|i
operator|++
control|)
block|{
name|xge_hal_status_e
name|status
decl_stmt|;
if|if
condition|(
operator|!
name|hldev
operator|->
name|bimodal_tti
index|[
name|i
index|]
operator|.
name|enabled
condition|)
continue|continue;
comment|/* at least some bimodal TTI enabled. Record it. */
name|hldev
operator|->
name|tti_enabled
operator|=
literal|1
expr_stmt|;
name|status
operator|=
name|__hal_device_tti_apply
argument_list|(
name|hldev
argument_list|,
operator|&
name|hldev
operator|->
name|bimodal_tti
index|[
name|i
index|]
argument_list|,
name|XGE_HAL_MAX_FIFO_TTI_RING_0
operator|+
name|i
argument_list|,
name|runtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
return|return
name|status
return|;
block|}
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/*  * __hal_device_rti_configure  * @hldev: HAL device handle.  *  * RTI Initialization.  * Initialize Receive Traffic Interrupt Scheme.  */
end_comment

begin_function
name|xge_hal_status_e
name|__hal_device_rti_configure
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|,
name|int
name|runtime
parameter_list|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
decl_stmt|;
name|u64
name|val64
decl_stmt|,
name|data1
init|=
literal|0
decl_stmt|,
name|data2
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|runtime
condition|)
block|{
comment|/* 	     * we don't want to re-configure RTI in case when 	     * bimodal interrupts are in use. Instead reconfigure TTI 	     * with new RTI values. 	     */
if|if
condition|(
name|hldev
operator|->
name|config
operator|.
name|bimodal_interrupts
condition|)
block|{
name|__hal_device_bimodal_configure
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
return|return
name|__hal_device_tti_configure
argument_list|(
name|hldev
argument_list|,
literal|1
argument_list|)
return|;
block|}
name|bar0
operator|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|isrbar0
expr_stmt|;
block|}
else|else
name|bar0
operator|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XGE_HAL_MAX_RING_NUM
condition|;
name|i
operator|++
control|)
block|{
name|xge_hal_rti_config_t
modifier|*
name|rti
init|=
operator|&
name|hldev
operator|->
name|config
operator|.
name|ring
operator|.
name|queue
index|[
name|i
index|]
operator|.
name|rti
decl_stmt|;
if|if
condition|(
operator|!
name|hldev
operator|->
name|config
operator|.
name|ring
operator|.
name|queue
index|[
name|i
index|]
operator|.
name|configured
condition|)
continue|continue;
if|if
condition|(
name|rti
operator|->
name|timer_val_us
condition|)
block|{
name|unsigned
name|int
name|rx_interval
decl_stmt|;
if|if
condition|(
name|hldev
operator|->
name|config
operator|.
name|pci_freq_mherz
condition|)
block|{
name|rx_interval
operator|=
name|hldev
operator|->
name|config
operator|.
name|pci_freq_mherz
operator|*
name|rti
operator|->
name|timer_val_us
operator|/
literal|8
expr_stmt|;
name|rx_interval
operator|=
name|__hal_fix_time_ival_herc
argument_list|(
name|hldev
argument_list|,
name|rx_interval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rx_interval
operator|=
name|rti
operator|->
name|timer_val_us
expr_stmt|;
block|}
name|data1
operator||=
name|XGE_HAL_RTI_DATA1_MEM_RX_TIMER_VAL
argument_list|(
name|rx_interval
argument_list|)
expr_stmt|;
if|if
condition|(
name|rti
operator|->
name|timer_ac_en
condition|)
block|{
name|data1
operator||=
name|XGE_HAL_RTI_DATA1_MEM_RX_TIMER_AC_EN
expr_stmt|;
block|}
name|data1
operator||=
name|XGE_HAL_RTI_DATA1_MEM_RX_TIMER_CI_EN
expr_stmt|;
block|}
if|if
condition|(
name|rti
operator|->
name|urange_a
operator|||
name|rti
operator|->
name|urange_b
operator|||
name|rti
operator|->
name|urange_c
operator|||
name|rti
operator|->
name|ufc_a
operator|||
name|rti
operator|->
name|ufc_b
operator|||
name|rti
operator|->
name|ufc_c
operator|||
name|rti
operator|->
name|ufc_d
condition|)
block|{
name|data1
operator||=
name|XGE_HAL_RTI_DATA1_MEM_RX_URNG_A
argument_list|(
name|rti
operator|->
name|urange_a
argument_list|)
operator||
name|XGE_HAL_RTI_DATA1_MEM_RX_URNG_B
argument_list|(
name|rti
operator|->
name|urange_b
argument_list|)
operator||
name|XGE_HAL_RTI_DATA1_MEM_RX_URNG_C
argument_list|(
name|rti
operator|->
name|urange_c
argument_list|)
expr_stmt|;
name|data2
operator||=
name|XGE_HAL_RTI_DATA2_MEM_RX_UFC_A
argument_list|(
name|rti
operator|->
name|ufc_a
argument_list|)
operator||
name|XGE_HAL_RTI_DATA2_MEM_RX_UFC_B
argument_list|(
name|rti
operator|->
name|ufc_b
argument_list|)
operator||
name|XGE_HAL_RTI_DATA2_MEM_RX_UFC_C
argument_list|(
name|rti
operator|->
name|ufc_c
argument_list|)
operator||
name|XGE_HAL_RTI_DATA2_MEM_RX_UFC_D
argument_list|(
name|rti
operator|->
name|ufc_d
argument_list|)
expr_stmt|;
block|}
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|data1
argument_list|,
operator|&
name|bar0
operator|->
name|rti_data1_mem
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|rti_data1_mem
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|data2
argument_list|,
operator|&
name|bar0
operator|->
name|rti_data2_mem
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|rti_data2_mem
argument_list|)
expr_stmt|;
name|xge_os_wmb
argument_list|()
expr_stmt|;
name|val64
operator|=
name|XGE_HAL_RTI_CMD_MEM_WE
operator||
name|XGE_HAL_RTI_CMD_MEM_STROBE_NEW_CMD
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_RTI_CMD_MEM_OFFSET
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rti_command_mem
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|runtime
operator|&&
name|__hal_device_register_poll
argument_list|(
name|hldev
argument_list|,
operator|&
name|bar0
operator|->
name|rti_command_mem
argument_list|,
literal|0
argument_list|,
name|XGE_HAL_RTI_CMD_MEM_STROBE_NEW_CMD
argument_list|,
name|XGE_HAL_DEVICE_CMDMEM_WAIT_MAX_MILLIS
argument_list|)
operator|!=
name|XGE_HAL_OK
condition|)
block|{
comment|/* upper layer may require to repeat */
return|return
name|XGE_HAL_INF_MEM_STROBE_CMD_EXECUTING
return|;
block|}
if|if
condition|(
operator|!
name|runtime
condition|)
block|{
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"RTI[%d] configured: rti_data1_mem 0x"
name|XGE_OS_LLXFMT
argument_list|,
name|i
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|rti_data1_mem
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/* Constants to be programmed into the Xena's registers to configure  * the XAUI. */
end_comment

begin_decl_stmt
specifier|static
name|u64
name|default_xena_mdio_cfg
index|[]
init|=
block|{
comment|/* Reset PMA PLL */
literal|0xC001010000000000ULL
block|,
literal|0xC0010100000000E0ULL
block|,
literal|0xC0010100008000E4ULL
block|,
comment|/* Remove Reset from PMA PLL */
literal|0xC001010000000000ULL
block|,
literal|0xC0010100000000E0ULL
block|,
literal|0xC0010100000000E4ULL
block|,
name|END_SIGN
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u64
name|default_herc_mdio_cfg
index|[]
init|=
block|{
name|END_SIGN
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u64
name|default_xena_dtx_cfg
index|[]
init|=
block|{
literal|0x8000051500000000ULL
block|,
literal|0x80000515000000E0ULL
block|,
literal|0x80000515D93500E4ULL
block|,
literal|0x8001051500000000ULL
block|,
literal|0x80010515000000E0ULL
block|,
literal|0x80010515001E00E4ULL
block|,
literal|0x8002051500000000ULL
block|,
literal|0x80020515000000E0ULL
block|,
literal|0x80020515F21000E4ULL
block|,
comment|/* Set PADLOOPBACKN */
literal|0x8002051500000000ULL
block|,
literal|0x80020515000000E0ULL
block|,
literal|0x80020515B20000E4ULL
block|,
literal|0x8003051500000000ULL
block|,
literal|0x80030515000000E0ULL
block|,
literal|0x80030515B20000E4ULL
block|,
literal|0x8004051500000000ULL
block|,
literal|0x80040515000000E0ULL
block|,
literal|0x80040515B20000E4ULL
block|,
literal|0x8005051500000000ULL
block|,
literal|0x80050515000000E0ULL
block|,
literal|0x80050515B20000E4ULL
block|,
name|SWITCH_SIGN
block|,
comment|/* Remove PADLOOPBACKN */
literal|0x8002051500000000ULL
block|,
literal|0x80020515000000E0ULL
block|,
literal|0x80020515F20000E4ULL
block|,
literal|0x8003051500000000ULL
block|,
literal|0x80030515000000E0ULL
block|,
literal|0x80030515F20000E4ULL
block|,
literal|0x8004051500000000ULL
block|,
literal|0x80040515000000E0ULL
block|,
literal|0x80040515F20000E4ULL
block|,
literal|0x8005051500000000ULL
block|,
literal|0x80050515000000E0ULL
block|,
literal|0x80050515F20000E4ULL
block|,
name|END_SIGN
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* static u64 default_herc_dtx_cfg[] = { 	0x80000515BA750000ULL, 0x80000515BA7500E0ULL, 	0x80000515BA750004ULL, 0x80000515BA7500E4ULL, 	0x80010515003F0000ULL, 0x80010515003F00E0ULL, 	0x80010515003F0004ULL, 0x80010515003F00E4ULL, 	0x80020515F2100000ULL, 0x80020515F21000E0ULL, 	0x80020515F2100004ULL, 0x80020515F21000E4ULL, 	END_SIGN }; */
end_comment

begin_decl_stmt
specifier|static
name|u64
name|default_herc_dtx_cfg
index|[]
init|=
block|{
literal|0x8000051536750000ULL
block|,
literal|0x80000515367500E0ULL
block|,
literal|0x8000051536750004ULL
block|,
literal|0x80000515367500E4ULL
block|,
literal|0x80010515003F0000ULL
block|,
literal|0x80010515003F00E0ULL
block|,
literal|0x80010515003F0004ULL
block|,
literal|0x80010515003F00E4ULL
block|,
literal|0x801205150D440000ULL
block|,
literal|0x801205150D4400E0ULL
block|,
literal|0x801205150D440004ULL
block|,
literal|0x801205150D4400E4ULL
block|,
literal|0x80020515F2100000ULL
block|,
literal|0x80020515F21000E0ULL
block|,
literal|0x80020515F2100004ULL
block|,
literal|0x80020515F21000E4ULL
block|,
name|END_SIGN
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|__hal_serial_mem_write64
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|,
name|u64
name|value
parameter_list|,
name|u64
modifier|*
name|reg
parameter_list|)
block|{
name|__hal_pio_mem_write32_upper
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
call|(
name|u32
call|)
argument_list|(
name|value
operator|>>
literal|32
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|xge_os_wmb
argument_list|()
expr_stmt|;
name|__hal_pio_mem_write32_lower
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|(
name|u32
operator|)
name|value
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|xge_os_wmb
argument_list|()
expr_stmt|;
name|xge_os_mdelay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|u64
name|__hal_serial_mem_read64
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|,
name|u64
modifier|*
name|reg
parameter_list|)
block|{
name|u64
name|val64
init|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|reg
argument_list|)
decl_stmt|;
name|xge_os_mdelay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|val64
return|;
block|}
end_function

begin_comment
comment|/*  * __hal_device_xaui_configure  * @hldev: HAL device handle.  *  * Configure XAUI Interface of Xena.  *  * To Configure the Xena's XAUI, one has to write a series  * of 64 bit values into two registers in a particular  * sequence. Hence a macro 'SWITCH_SIGN' has been defined  * which will be defined in the array of configuration values  * (default_dtx_cfg& default_mdio_cfg) at appropriate places  * to switch writing from one regsiter to another. We continue  * writing these values until we encounter the 'END_SIGN' macro.  * For example, After making a series of 21 writes into  * dtx_control register the 'SWITCH_SIGN' appears and hence we  * start writing into mdio_control until we encounter END_SIGN.  */
end_comment

begin_function
specifier|static
name|void
name|__hal_device_xaui_configure
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|int
name|mdio_cnt
init|=
literal|0
decl_stmt|,
name|dtx_cnt
init|=
literal|0
decl_stmt|;
name|u64
modifier|*
name|default_dtx_cfg
init|=
name|NULL
decl_stmt|,
modifier|*
name|default_mdio_cfg
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_XENA
condition|)
block|{
name|default_dtx_cfg
operator|=
name|default_xena_dtx_cfg
expr_stmt|;
name|default_mdio_cfg
operator|=
name|default_xena_mdio_cfg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_HERC
condition|)
block|{
name|default_dtx_cfg
operator|=
name|default_herc_dtx_cfg
expr_stmt|;
name|default_mdio_cfg
operator|=
name|default_herc_mdio_cfg
expr_stmt|;
block|}
else|else
block|{
name|xge_assert
argument_list|(
name|default_dtx_cfg
argument_list|)
expr_stmt|;
return|return;
block|}
do|do
block|{
name|dtx_cfg
label|:
while|while
condition|(
name|default_dtx_cfg
index|[
name|dtx_cnt
index|]
operator|!=
name|END_SIGN
condition|)
block|{
if|if
condition|(
name|default_dtx_cfg
index|[
name|dtx_cnt
index|]
operator|==
name|SWITCH_SIGN
condition|)
block|{
name|dtx_cnt
operator|++
expr_stmt|;
goto|goto
name|mdio_cfg
goto|;
block|}
name|__hal_serial_mem_write64
argument_list|(
name|hldev
argument_list|,
name|default_dtx_cfg
index|[
name|dtx_cnt
index|]
argument_list|,
operator|&
name|bar0
operator|->
name|dtx_control
argument_list|)
expr_stmt|;
name|dtx_cnt
operator|++
expr_stmt|;
block|}
name|mdio_cfg
label|:
while|while
condition|(
name|default_mdio_cfg
index|[
name|mdio_cnt
index|]
operator|!=
name|END_SIGN
condition|)
block|{
if|if
condition|(
name|default_mdio_cfg
index|[
name|mdio_cnt
index|]
operator|==
name|SWITCH_SIGN
condition|)
block|{
name|mdio_cnt
operator|++
expr_stmt|;
goto|goto
name|dtx_cfg
goto|;
block|}
name|__hal_serial_mem_write64
argument_list|(
name|hldev
argument_list|,
name|default_mdio_cfg
index|[
name|mdio_cnt
index|]
argument_list|,
operator|&
name|bar0
operator|->
name|mdio_control
argument_list|)
expr_stmt|;
name|mdio_cnt
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
operator|(
operator|(
name|default_dtx_cfg
index|[
name|dtx_cnt
index|]
operator|==
name|END_SIGN
operator|)
operator|&&
operator|(
name|default_mdio_cfg
index|[
name|mdio_cnt
index|]
operator|==
name|END_SIGN
operator|)
operator|)
condition|)
do|;
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"%s"
argument_list|,
literal|"XAUI interface configured"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * __hal_device_mac_link_util_set  * @hldev: HAL device handle.  *  * Set sampling rate to calculate link utilization.  */
end_comment

begin_function
specifier|static
name|void
name|__hal_device_mac_link_util_set
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
name|val64
operator|=
name|XGE_HAL_MAC_TX_LINK_UTIL_VAL
argument_list|(
name|hldev
operator|->
name|config
operator|.
name|mac
operator|.
name|tmac_util_period
argument_list|)
operator||
name|XGE_HAL_MAC_RX_LINK_UTIL_VAL
argument_list|(
name|hldev
operator|->
name|config
operator|.
name|mac
operator|.
name|rmac_util_period
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|mac_link_util
argument_list|)
expr_stmt|;
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"%s"
argument_list|,
literal|"bandwidth link utilization configured"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * __hal_device_set_swapper  * @hldev: HAL device handle.  *  * Set the Xframe's byte "swapper" in accordance with  * endianness of the host.  */
end_comment

begin_function
name|xge_hal_status_e
name|__hal_device_set_swapper
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
comment|/* 	 * from 32bit errarta: 	 * 	 * The SWAPPER_CONTROL register determines how the adapter accesses 	 * host memory as well as how it responds to read and write requests 	 * from the host system. Writes to this register should be performed 	 * carefully, since the byte swappers could reverse the order of bytes. 	 * When configuring this register keep in mind that writes to the PIF 	 * read and write swappers could reverse the order of the upper and 	 * lower 32-bit words. This means that the driver may have to write 	 * to the upper 32 bits of the SWAPPER_CONTROL twice in order to 	 * configure the entire register. */
comment|/* 	 * The device by default set to a big endian format, so a big endian 	 * driver need not set anything. 	 */
if|#
directive|if
name|defined
argument_list|(
name|XGE_HAL_CUSTOM_HW_SWAPPER
argument_list|)
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
literal|0xffffffffffffffffULL
argument_list|,
operator|&
name|bar0
operator|->
name|swapper_ctrl
argument_list|)
expr_stmt|;
name|val64
operator|=
name|XGE_HAL_CUSTOM_HW_SWAPPER
expr_stmt|;
name|xge_os_wmb
argument_list|()
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|swapper_ctrl
argument_list|)
expr_stmt|;
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"using custom HW swapper 0x"
name|XGE_OS_LLXFMT
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|val64
argument_list|)
expr_stmt|;
elif|#
directive|elif
operator|!
name|defined
argument_list|(
name|XGE_OS_HOST_BIG_ENDIAN
argument_list|)
comment|/* 	 * Initially we enable all bits to make it accessible by the driver, 	 * then we selectively enable only those bits that we want to set. 	 * i.e. force swapper to swap for the first time since second write 	 * will overwrite with the final settings. 	 * 	 * Use only for little endian platforms. 	 */
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
literal|0xffffffffffffffffULL
argument_list|,
operator|&
name|bar0
operator|->
name|swapper_ctrl
argument_list|)
expr_stmt|;
name|xge_os_wmb
argument_list|()
expr_stmt|;
name|val64
operator|=
operator|(
name|XGE_HAL_SWAPPER_CTRL_PIF_R_FE
operator||
name|XGE_HAL_SWAPPER_CTRL_PIF_R_SE
operator||
name|XGE_HAL_SWAPPER_CTRL_PIF_W_FE
operator||
name|XGE_HAL_SWAPPER_CTRL_PIF_W_SE
operator||
name|XGE_HAL_SWAPPER_CTRL_RTH_FE
operator||
name|XGE_HAL_SWAPPER_CTRL_RTH_SE
operator||
name|XGE_HAL_SWAPPER_CTRL_TXP_FE
operator||
name|XGE_HAL_SWAPPER_CTRL_TXP_SE
operator||
name|XGE_HAL_SWAPPER_CTRL_TXD_R_FE
operator||
name|XGE_HAL_SWAPPER_CTRL_TXD_R_SE
operator||
name|XGE_HAL_SWAPPER_CTRL_TXD_W_FE
operator||
name|XGE_HAL_SWAPPER_CTRL_TXD_W_SE
operator||
name|XGE_HAL_SWAPPER_CTRL_TXF_R_FE
operator||
name|XGE_HAL_SWAPPER_CTRL_RXD_R_FE
operator||
name|XGE_HAL_SWAPPER_CTRL_RXD_R_SE
operator||
name|XGE_HAL_SWAPPER_CTRL_RXD_W_FE
operator||
name|XGE_HAL_SWAPPER_CTRL_RXD_W_SE
operator||
name|XGE_HAL_SWAPPER_CTRL_RXF_W_FE
operator||
name|XGE_HAL_SWAPPER_CTRL_XMSI_FE
operator||
name|XGE_HAL_SWAPPER_CTRL_STATS_FE
operator||
name|XGE_HAL_SWAPPER_CTRL_STATS_SE
operator|)
expr_stmt|;
comment|/* 	if (hldev->config.intr_mode == XGE_HAL_INTR_MODE_MSIX) { 	     val64 |= XGE_HAL_SWAPPER_CTRL_XMSI_SE; 	} */
name|__hal_pio_mem_write32_lower
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|(
name|u32
operator|)
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|swapper_ctrl
argument_list|)
expr_stmt|;
name|xge_os_wmb
argument_list|()
expr_stmt|;
name|__hal_pio_mem_write32_upper
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
call|(
name|u32
call|)
argument_list|(
name|val64
operator|>>
literal|32
argument_list|)
argument_list|,
operator|&
name|bar0
operator|->
name|swapper_ctrl
argument_list|)
expr_stmt|;
name|xge_os_wmb
argument_list|()
expr_stmt|;
name|__hal_pio_mem_write32_upper
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
call|(
name|u32
call|)
argument_list|(
name|val64
operator|>>
literal|32
argument_list|)
argument_list|,
operator|&
name|bar0
operator|->
name|swapper_ctrl
argument_list|)
expr_stmt|;
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"%s"
argument_list|,
literal|"using little endian set"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*  Verifying if endian settings are accurate by reading a feedback 	 *  register.  */
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|pif_rd_swapper_fb
argument_list|)
expr_stmt|;
if|if
condition|(
name|val64
operator|!=
name|XGE_HAL_IF_RD_SWAPPER_FB
condition|)
block|{
name|xge_debug_device
argument_list|(
name|XGE_ERR
argument_list|,
literal|"pif_rd_swapper_fb read "
name|XGE_OS_LLXFMT
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|val64
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_ERR_SWAPPER_CTRL
return|;
block|}
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"%s"
argument_list|,
literal|"be/le swapper enabled"
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/*  * __hal_device_rts_mac_configure - Configure RTS steering based on  * destination mac address.  * @hldev: HAL device handle.  *  */
end_comment

begin_function
name|xge_hal_status_e
name|__hal_device_rts_mac_configure
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
if|if
condition|(
operator|!
name|hldev
operator|->
name|config
operator|.
name|rts_mac_en
condition|)
block|{
return|return
name|XGE_HAL_OK
return|;
block|}
comment|/* 	* Set the receive traffic steering mode from default(classic) 	* to enhanced. 	*/
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|rts_ctrl
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_RTS_CTRL_ENHANCED_MODE
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rts_ctrl
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/*  * __hal_device_rts_port_configure - Configure RTS steering based on  * destination or source port number.  * @hldev: HAL device handle.  *  */
end_comment

begin_function
name|xge_hal_status_e
name|__hal_device_rts_port_configure
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
name|int
name|rnum
decl_stmt|;
if|if
condition|(
operator|!
name|hldev
operator|->
name|config
operator|.
name|rts_port_en
condition|)
block|{
return|return
name|XGE_HAL_OK
return|;
block|}
comment|/* 	 * Set the receive traffic steering mode from default(classic) 	 * to enhanced. 	 */
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|rts_ctrl
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_RTS_CTRL_ENHANCED_MODE
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rts_ctrl
argument_list|)
expr_stmt|;
comment|/* 	 * Initiate port steering according to per-ring configuration 	 */
for|for
control|(
name|rnum
operator|=
literal|0
init|;
name|rnum
operator|<
name|XGE_HAL_MAX_RING_NUM
condition|;
name|rnum
operator|++
control|)
block|{
name|int
name|pnum
decl_stmt|;
name|xge_hal_ring_queue_t
modifier|*
name|queue
init|=
operator|&
name|hldev
operator|->
name|config
operator|.
name|ring
operator|.
name|queue
index|[
name|rnum
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|queue
operator|->
name|configured
operator|||
name|queue
operator|->
name|rts_port_en
condition|)
continue|continue;
for|for
control|(
name|pnum
operator|=
literal|0
init|;
name|pnum
operator|<
name|XGE_HAL_MAX_STEERABLE_PORTS
condition|;
name|pnum
operator|++
control|)
block|{
name|xge_hal_rts_port_t
modifier|*
name|port
init|=
operator|&
name|queue
operator|->
name|rts_ports
index|[
name|pnum
index|]
decl_stmt|;
comment|/* 	         * Skip and clear empty ports 	         */
if|if
condition|(
operator|!
name|port
operator|->
name|num
condition|)
block|{
comment|/* 	             * Clear CAM memory 	             */
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
literal|0ULL
argument_list|,
operator|&
name|bar0
operator|->
name|rts_pn_cam_data
argument_list|)
expr_stmt|;
name|val64
operator|=
name|BIT
argument_list|(
literal|7
argument_list|)
operator||
name|BIT
argument_list|(
literal|15
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	             * Assign new Port values according 	             * to configuration 	             */
name|val64
operator|=
name|vBIT
argument_list|(
name|port
operator|->
name|num
argument_list|,
literal|8
argument_list|,
literal|16
argument_list|)
operator||
name|vBIT
argument_list|(
name|rnum
argument_list|,
literal|37
argument_list|,
literal|3
argument_list|)
operator||
name|BIT
argument_list|(
literal|63
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|src
condition|)
name|val64
operator|=
name|BIT
argument_list|(
literal|47
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|port
operator|->
name|udp
condition|)
name|val64
operator|=
name|BIT
argument_list|(
literal|7
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rts_pn_cam_data
argument_list|)
expr_stmt|;
name|val64
operator|=
name|BIT
argument_list|(
literal|7
argument_list|)
operator||
name|BIT
argument_list|(
literal|15
argument_list|)
operator||
name|vBIT
argument_list|(
name|pnum
argument_list|,
literal|24
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rts_pn_cam_ctrl
argument_list|)
expr_stmt|;
comment|/* poll until done */
if|if
condition|(
name|__hal_device_register_poll
argument_list|(
name|hldev
argument_list|,
operator|&
name|bar0
operator|->
name|rts_pn_cam_ctrl
argument_list|,
literal|0
argument_list|,
name|XGE_HAL_RTS_PN_CAM_CTRL_STROBE_BEING_EXECUTED
argument_list|,
name|XGE_HAL_DEVICE_CMDMEM_WAIT_MAX_MILLIS
argument_list|)
operator|!=
name|XGE_HAL_OK
condition|)
block|{
comment|/* upper layer may require to repeat */
return|return
name|XGE_HAL_INF_MEM_STROBE_CMD_EXECUTING
return|;
block|}
block|}
block|}
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/*  * __hal_device_rts_qos_configure - Configure RTS steering based on  * qos.  * @hldev: HAL device handle.  *  */
end_comment

begin_function
name|xge_hal_status_e
name|__hal_device_rts_qos_configure
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
name|int
name|j
decl_stmt|,
name|rx_ring_num
decl_stmt|;
if|if
condition|(
operator|!
name|hldev
operator|->
name|config
operator|.
name|rts_qos_en
condition|)
block|{
return|return
name|XGE_HAL_OK
return|;
block|}
comment|/* First clear the RTS_DS_MEM_DATA */
name|val64
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|64
condition|;
name|j
operator|++
control|)
block|{
comment|/* First clear the value */
name|val64
operator|=
name|XGE_HAL_RTS_DS_MEM_DATA
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rts_ds_mem_data
argument_list|)
expr_stmt|;
name|val64
operator|=
name|XGE_HAL_RTS_DS_MEM_CTRL_WE
operator||
name|XGE_HAL_RTS_DS_MEM_CTRL_STROBE_NEW_CMD
operator||
name|XGE_HAL_RTS_DS_MEM_CTRL_OFFSET
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rts_ds_mem_ctrl
argument_list|)
expr_stmt|;
comment|/* poll until done */
if|if
condition|(
name|__hal_device_register_poll
argument_list|(
name|hldev
argument_list|,
operator|&
name|bar0
operator|->
name|rts_ds_mem_ctrl
argument_list|,
literal|0
argument_list|,
name|XGE_HAL_RTS_DS_MEM_CTRL_STROBE_CMD_BEING_EXECUTED
argument_list|,
name|XGE_HAL_DEVICE_CMDMEM_WAIT_MAX_MILLIS
argument_list|)
operator|!=
name|XGE_HAL_OK
condition|)
block|{
comment|/* upper layer may require to repeat */
return|return
name|XGE_HAL_INF_MEM_STROBE_CMD_EXECUTING
return|;
block|}
block|}
name|rx_ring_num
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XGE_HAL_MAX_RING_NUM
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|hldev
operator|->
name|config
operator|.
name|ring
operator|.
name|queue
index|[
name|j
index|]
operator|.
name|configured
condition|)
name|rx_ring_num
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
name|rx_ring_num
condition|)
block|{
case|case
literal|1
case|:
name|val64
operator|=
literal|0x0
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_w_round_robin_0
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_w_round_robin_1
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_w_round_robin_2
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_w_round_robin_3
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_w_round_robin_4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|val64
operator|=
literal|0x0001000100010001ULL
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_w_round_robin_0
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_w_round_robin_1
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_w_round_robin_2
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_w_round_robin_3
argument_list|)
expr_stmt|;
name|val64
operator|=
literal|0x0001000100000000ULL
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_w_round_robin_4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|val64
operator|=
literal|0x0001020001020001ULL
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_w_round_robin_0
argument_list|)
expr_stmt|;
name|val64
operator|=
literal|0x0200010200010200ULL
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_w_round_robin_1
argument_list|)
expr_stmt|;
name|val64
operator|=
literal|0x0102000102000102ULL
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_w_round_robin_2
argument_list|)
expr_stmt|;
name|val64
operator|=
literal|0x0001020001020001ULL
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_w_round_robin_3
argument_list|)
expr_stmt|;
name|val64
operator|=
literal|0x0200010200000000ULL
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_w_round_robin_4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|val64
operator|=
literal|0x0001020300010203ULL
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_w_round_robin_0
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_w_round_robin_1
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_w_round_robin_2
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_w_round_robin_3
argument_list|)
expr_stmt|;
name|val64
operator|=
literal|0x0001020300000000ULL
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_w_round_robin_4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|val64
operator|=
literal|0x0001020304000102ULL
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_w_round_robin_0
argument_list|)
expr_stmt|;
name|val64
operator|=
literal|0x0304000102030400ULL
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_w_round_robin_1
argument_list|)
expr_stmt|;
name|val64
operator|=
literal|0x0102030400010203ULL
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_w_round_robin_2
argument_list|)
expr_stmt|;
name|val64
operator|=
literal|0x0400010203040001ULL
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_w_round_robin_3
argument_list|)
expr_stmt|;
name|val64
operator|=
literal|0x0203040000000000ULL
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_w_round_robin_4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|val64
operator|=
literal|0x0001020304050001ULL
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_w_round_robin_0
argument_list|)
expr_stmt|;
name|val64
operator|=
literal|0x0203040500010203ULL
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_w_round_robin_1
argument_list|)
expr_stmt|;
name|val64
operator|=
literal|0x0405000102030405ULL
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_w_round_robin_2
argument_list|)
expr_stmt|;
name|val64
operator|=
literal|0x0001020304050001ULL
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_w_round_robin_3
argument_list|)
expr_stmt|;
name|val64
operator|=
literal|0x0203040500000000ULL
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_w_round_robin_4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|val64
operator|=
literal|0x0001020304050600ULL
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_w_round_robin_0
argument_list|)
expr_stmt|;
name|val64
operator|=
literal|0x0102030405060001ULL
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_w_round_robin_1
argument_list|)
expr_stmt|;
name|val64
operator|=
literal|0x0203040506000102ULL
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_w_round_robin_2
argument_list|)
expr_stmt|;
name|val64
operator|=
literal|0x0304050600010203ULL
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_w_round_robin_3
argument_list|)
expr_stmt|;
name|val64
operator|=
literal|0x0405060000000000ULL
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_w_round_robin_4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|val64
operator|=
literal|0x0001020304050607ULL
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_w_round_robin_0
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_w_round_robin_1
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_w_round_robin_2
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_w_round_robin_3
argument_list|)
expr_stmt|;
name|val64
operator|=
literal|0x0001020300000000ULL
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_w_round_robin_4
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/*  * xge__hal_device_rts_mac_enable  *  * @devh: HAL device handle.  * @index: index number where the MAC addr will be stored  * @macaddr: MAC address  *  * - Enable RTS steering for the given MAC address. This function has to be  * called with lock acquired.  *  * NOTE:  * 1. ULD has to call this function with the index value which  *    statisfies the following condition:  *  ring_num = (index % 8)  * 2.ULD also needs to make sure that the index is not  *   occupied by any MAC address. If that index has any MAC address  *   it will be overwritten and HAL will not check for it.  *  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_device_rts_mac_enable
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|,
name|int
name|index
parameter_list|,
name|macaddr_t
name|macaddr
parameter_list|)
block|{
name|int
name|max_addr
init|=
name|XGE_HAL_MAX_MAC_ADDRESSES
decl_stmt|;
name|xge_hal_status_e
name|status
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
if|if
condition|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_HERC
condition|)
name|max_addr
operator|=
name|XGE_HAL_MAX_MAC_ADDRESSES_HERC
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|max_addr
condition|)
return|return
name|XGE_HAL_ERR_OUT_OF_MAC_ADDRESSES
return|;
comment|/* 	 * Set the MAC address at the given location marked by index. 	 */
name|status
operator|=
name|xge_hal_device_macaddr_set
argument_list|(
name|hldev
argument_list|,
name|index
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_debug_device
argument_list|(
name|XGE_ERR
argument_list|,
literal|"%s"
argument_list|,
literal|"Not able to set the mac addr"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
return|return
name|xge_hal_device_rts_section_enable
argument_list|(
name|hldev
argument_list|,
name|index
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * xge__hal_device_rts_mac_disable  * @hldev: HAL device handle.  * @index: index number where to disable the MAC addr  *  * Disable RTS Steering based on the MAC address.  * This function should be called with lock acquired.  *  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_device_rts_mac_disable
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|xge_hal_status_e
name|status
decl_stmt|;
name|u8
name|macaddr
index|[
literal|6
index|]
init|=
block|{
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|}
decl_stmt|;
name|int
name|max_addr
init|=
name|XGE_HAL_MAX_MAC_ADDRESSES
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
name|xge_debug_ll
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"the index value is %d "
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_HERC
condition|)
name|max_addr
operator|=
name|XGE_HAL_MAX_MAC_ADDRESSES_HERC
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|max_addr
condition|)
return|return
name|XGE_HAL_ERR_OUT_OF_MAC_ADDRESSES
return|;
comment|/* 	 * Disable MAC address @ given index location 	 */
name|status
operator|=
name|xge_hal_device_macaddr_set
argument_list|(
name|hldev
argument_list|,
name|index
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_debug_device
argument_list|(
name|XGE_ERR
argument_list|,
literal|"%s"
argument_list|,
literal|"Not able to set the mac addr"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/*  * __hal_device_rth_configure - Configure RTH for the device  * @hldev: HAL device handle.  *  * Using IT (Indirection Table).  */
end_comment

begin_function
name|xge_hal_status_e
name|__hal_device_rth_it_configure
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
name|int
name|rings
index|[
name|XGE_HAL_MAX_RING_NUM
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|rnum
decl_stmt|;
name|int
name|rmax
decl_stmt|;
name|int
name|buckets_num
decl_stmt|;
name|int
name|bucket
decl_stmt|;
if|if
condition|(
operator|!
name|hldev
operator|->
name|config
operator|.
name|rth_en
condition|)
block|{
return|return
name|XGE_HAL_OK
return|;
block|}
comment|/* 	 * Set the receive traffic steering mode from default(classic) 	 * to enhanced. 	 */
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|rts_ctrl
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_RTS_CTRL_ENHANCED_MODE
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rts_ctrl
argument_list|)
expr_stmt|;
name|buckets_num
operator|=
operator|(
literal|1
operator|<<
name|hldev
operator|->
name|config
operator|.
name|rth_bucket_size
operator|)
expr_stmt|;
name|rmax
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|rnum
operator|=
literal|0
init|;
name|rnum
operator|<
name|XGE_HAL_MAX_RING_NUM
condition|;
name|rnum
operator|++
control|)
block|{
if|if
condition|(
name|hldev
operator|->
name|config
operator|.
name|ring
operator|.
name|queue
index|[
name|rnum
index|]
operator|.
name|configured
operator|&&
name|hldev
operator|->
name|config
operator|.
name|ring
operator|.
name|queue
index|[
name|rnum
index|]
operator|.
name|rth_en
condition|)
name|rings
index|[
name|rmax
operator|++
index|]
operator|=
name|rnum
expr_stmt|;
block|}
name|rnum
operator|=
literal|0
expr_stmt|;
comment|/* for starters: fill in all the buckets with rings "equally" */
for|for
control|(
name|bucket
operator|=
literal|0
init|;
name|bucket
operator|<
name|buckets_num
condition|;
name|bucket
operator|++
control|)
block|{
if|if
condition|(
name|rnum
operator|==
name|rmax
condition|)
name|rnum
operator|=
literal|0
expr_stmt|;
comment|/* write data */
name|val64
operator|=
name|XGE_HAL_RTS_RTH_MAP_MEM_DATA_ENTRY_EN
operator||
name|XGE_HAL_RTS_RTH_MAP_MEM_DATA
argument_list|(
name|rings
index|[
name|rnum
index|]
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rts_rth_map_mem_data
argument_list|)
expr_stmt|;
comment|/* execute */
name|val64
operator|=
name|XGE_HAL_RTS_RTH_MAP_MEM_CTRL_WE
operator||
name|XGE_HAL_RTS_RTH_MAP_MEM_CTRL_STROBE
operator||
name|XGE_HAL_RTS_RTH_MAP_MEM_CTRL_OFFSET
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rts_rth_map_mem_ctrl
argument_list|)
expr_stmt|;
comment|/* poll until done */
if|if
condition|(
name|__hal_device_register_poll
argument_list|(
name|hldev
argument_list|,
operator|&
name|bar0
operator|->
name|rts_rth_map_mem_ctrl
argument_list|,
literal|0
argument_list|,
name|XGE_HAL_RTS_RTH_MAP_MEM_CTRL_STROBE
argument_list|,
name|XGE_HAL_DEVICE_CMDMEM_WAIT_MAX_MILLIS
argument_list|)
operator|!=
name|XGE_HAL_OK
condition|)
block|{
return|return
name|XGE_HAL_INF_MEM_STROBE_CMD_EXECUTING
return|;
block|}
name|rnum
operator|++
expr_stmt|;
block|}
name|val64
operator|=
name|XGE_HAL_RTS_RTH_EN
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_RTS_RTH_BUCKET_SIZE
argument_list|(
name|hldev
operator|->
name|config
operator|.
name|rth_bucket_size
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_RTS_RTH_TCP_IPV4_EN
operator||
name|XGE_HAL_RTS_RTH_UDP_IPV4_EN
operator||
name|XGE_HAL_RTS_RTH_IPV4_EN
operator||
name|XGE_HAL_RTS_RTH_TCP_IPV6_EN
operator||
name|XGE_HAL_RTS_RTH_UDP_IPV6_EN
operator||
name|XGE_HAL_RTS_RTH_IPV6_EN
operator||
name|XGE_HAL_RTS_RTH_TCP_IPV6_EX_EN
operator||
name|XGE_HAL_RTS_RTH_UDP_IPV6_EX_EN
operator||
name|XGE_HAL_RTS_RTH_IPV6_EX_EN
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rts_rth_cfg
argument_list|)
expr_stmt|;
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"RTH configured, bucket_size %d"
argument_list|,
name|hldev
operator|->
name|config
operator|.
name|rth_bucket_size
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/*  * __hal_spdm_entry_add - Add a new entry to the SPDM table.  *  * Add a new entry to the SPDM table  *  * This function add a new entry to the SPDM table.  *  * Note:  *   This function should be called with spdm_lock.  *  * See also: xge_hal_spdm_entry_add , xge_hal_spdm_entry_remove.  */
end_comment

begin_function
specifier|static
name|xge_hal_status_e
name|__hal_spdm_entry_add
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|,
name|xge_hal_ipaddr_t
modifier|*
name|src_ip
parameter_list|,
name|xge_hal_ipaddr_t
modifier|*
name|dst_ip
parameter_list|,
name|u16
name|l4_sp
parameter_list|,
name|u16
name|l4_dp
parameter_list|,
name|u8
name|is_tcp
parameter_list|,
name|u8
name|is_ipv4
parameter_list|,
name|u8
name|tgt_queue
parameter_list|,
name|u32
name|jhash_value
parameter_list|,
name|u16
name|spdm_entry
parameter_list|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
name|u64
name|spdm_line_arr
index|[
literal|8
index|]
decl_stmt|;
name|u8
name|line_no
decl_stmt|;
comment|/* 	 * Clear the SPDM READY bit 	 */
name|val64
operator|=
name|XGE_HAL_RX_PIC_INT_REG_SPDM_READY
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rxpic_int_reg
argument_list|)
expr_stmt|;
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"L4 SP %x:DP %x: hash %x tgt_queue %d "
argument_list|,
name|l4_sp
argument_list|,
name|l4_dp
argument_list|,
name|jhash_value
argument_list|,
name|tgt_queue
argument_list|)
expr_stmt|;
name|xge_os_memzero
argument_list|(
operator|&
name|spdm_line_arr
argument_list|,
sizeof|sizeof
argument_list|(
name|spdm_line_arr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Construct the SPDM entry. 	 */
name|spdm_line_arr
index|[
literal|0
index|]
operator|=
name|vBIT
argument_list|(
name|l4_sp
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|)
operator||
name|vBIT
argument_list|(
name|l4_dp
argument_list|,
literal|16
argument_list|,
literal|32
argument_list|)
operator||
name|vBIT
argument_list|(
name|tgt_queue
argument_list|,
literal|53
argument_list|,
literal|3
argument_list|)
operator||
name|vBIT
argument_list|(
name|is_tcp
argument_list|,
literal|59
argument_list|,
literal|1
argument_list|)
operator||
name|vBIT
argument_list|(
name|is_ipv4
argument_list|,
literal|63
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_ipv4
condition|)
block|{
name|spdm_line_arr
index|[
literal|1
index|]
operator|=
name|vBIT
argument_list|(
name|src_ip
operator|->
name|ipv4
operator|.
name|addr
argument_list|,
literal|0
argument_list|,
literal|32
argument_list|)
operator||
name|vBIT
argument_list|(
name|dst_ip
operator|->
name|ipv4
operator|.
name|addr
argument_list|,
literal|32
argument_list|,
literal|32
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xge_os_memcpy
argument_list|(
operator|&
name|spdm_line_arr
index|[
literal|1
index|]
argument_list|,
operator|&
name|src_ip
operator|->
name|ipv6
operator|.
name|addr
index|[
literal|0
index|]
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|xge_os_memcpy
argument_list|(
operator|&
name|spdm_line_arr
index|[
literal|2
index|]
argument_list|,
operator|&
name|src_ip
operator|->
name|ipv6
operator|.
name|addr
index|[
literal|1
index|]
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|xge_os_memcpy
argument_list|(
operator|&
name|spdm_line_arr
index|[
literal|3
index|]
argument_list|,
operator|&
name|dst_ip
operator|->
name|ipv6
operator|.
name|addr
index|[
literal|0
index|]
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|xge_os_memcpy
argument_list|(
operator|&
name|spdm_line_arr
index|[
literal|4
index|]
argument_list|,
operator|&
name|dst_ip
operator|->
name|ipv6
operator|.
name|addr
index|[
literal|1
index|]
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
name|spdm_line_arr
index|[
literal|7
index|]
operator|=
name|vBIT
argument_list|(
name|jhash_value
argument_list|,
literal|0
argument_list|,
literal|32
argument_list|)
operator||
name|BIT
argument_list|(
literal|63
argument_list|)
expr_stmt|;
comment|/* entry enable bit */
comment|/* 	 * Add the entry to the SPDM table 	 */
for|for
control|(
name|line_no
operator|=
literal|0
init|;
name|line_no
operator|<
literal|8
condition|;
name|line_no
operator|++
control|)
block|{
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|spdm_line_arr
index|[
name|line_no
index|]
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|hldev
operator|->
name|spdm_mem_base
operator|+
operator|(
name|spdm_entry
operator|*
literal|64
operator|)
operator|+
operator|(
name|line_no
operator|*
literal|8
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Wait for the operation to be completed. 	 */
if|if
condition|(
name|__hal_device_register_poll
argument_list|(
name|hldev
argument_list|,
operator|&
name|bar0
operator|->
name|rxpic_int_reg
argument_list|,
literal|1
argument_list|,
name|XGE_HAL_RX_PIC_INT_REG_SPDM_READY
argument_list|,
name|XGE_HAL_DEVICE_CMDMEM_WAIT_MAX_MILLIS
argument_list|)
operator|!=
name|XGE_HAL_OK
condition|)
block|{
return|return
name|XGE_HAL_INF_MEM_STROBE_CMD_EXECUTING
return|;
block|}
comment|/* 	 * Add this information to a local SPDM table. The purpose of 	 * maintaining a local SPDM table is to avoid a search in the 	 * adapter SPDM table for spdm entry lookup which is very costly 	 * in terms of time. 	 */
name|hldev
operator|->
name|spdm_table
index|[
name|spdm_entry
index|]
operator|->
name|in_use
operator|=
literal|1
expr_stmt|;
name|xge_os_memcpy
argument_list|(
operator|&
name|hldev
operator|->
name|spdm_table
index|[
name|spdm_entry
index|]
operator|->
name|src_ip
argument_list|,
name|src_ip
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_ipaddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|xge_os_memcpy
argument_list|(
operator|&
name|hldev
operator|->
name|spdm_table
index|[
name|spdm_entry
index|]
operator|->
name|dst_ip
argument_list|,
name|dst_ip
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_ipaddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|hldev
operator|->
name|spdm_table
index|[
name|spdm_entry
index|]
operator|->
name|l4_sp
operator|=
name|l4_sp
expr_stmt|;
name|hldev
operator|->
name|spdm_table
index|[
name|spdm_entry
index|]
operator|->
name|l4_dp
operator|=
name|l4_dp
expr_stmt|;
name|hldev
operator|->
name|spdm_table
index|[
name|spdm_entry
index|]
operator|->
name|is_tcp
operator|=
name|is_tcp
expr_stmt|;
name|hldev
operator|->
name|spdm_table
index|[
name|spdm_entry
index|]
operator|->
name|is_ipv4
operator|=
name|is_ipv4
expr_stmt|;
name|hldev
operator|->
name|spdm_table
index|[
name|spdm_entry
index|]
operator|->
name|tgt_queue
operator|=
name|tgt_queue
expr_stmt|;
name|hldev
operator|->
name|spdm_table
index|[
name|spdm_entry
index|]
operator|->
name|jhash_value
operator|=
name|jhash_value
expr_stmt|;
name|hldev
operator|->
name|spdm_table
index|[
name|spdm_entry
index|]
operator|->
name|spdm_entry
operator|=
name|spdm_entry
expr_stmt|;
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/*  * __hal_device_rth_spdm_configure - Configure RTH for the device  * @hldev: HAL device handle.  *  * Using SPDM (Socket-Pair Direct Match).  */
end_comment

begin_function
name|xge_hal_status_e
name|__hal_device_rth_spdm_configure
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
name|u8
name|spdm_bar_num
decl_stmt|;
name|u32
name|spdm_bar_offset
decl_stmt|;
name|int
name|spdm_table_size
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|hldev
operator|->
name|config
operator|.
name|rth_spdm_en
condition|)
block|{
return|return
name|XGE_HAL_OK
return|;
block|}
comment|/* 	 * Retrieve the base address of SPDM Table. 	 */
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|spdm_bir_offset
argument_list|)
expr_stmt|;
name|spdm_bar_num
operator|=
name|XGE_HAL_SPDM_PCI_BAR_NUM
argument_list|(
name|val64
argument_list|)
expr_stmt|;
name|spdm_bar_offset
operator|=
name|XGE_HAL_SPDM_PCI_BAR_OFFSET
argument_list|(
name|val64
argument_list|)
expr_stmt|;
comment|/* 	 * spdm_bar_num specifies the PCI bar num register used to 	 * address the memory space. spdm_bar_offset specifies the offset 	 * of the SPDM memory with in the bar num memory space. 	 */
switch|switch
condition|(
name|spdm_bar_num
condition|)
block|{
case|case
literal|0
case|:
block|{
name|hldev
operator|->
name|spdm_mem_base
operator|=
operator|(
name|char
operator|*
operator|)
name|bar0
operator|+
operator|(
name|spdm_bar_offset
operator|*
literal|8
operator|)
expr_stmt|;
break|break;
block|}
case|case
literal|1
case|:
block|{
name|char
modifier|*
name|bar1
init|=
operator|(
name|char
operator|*
operator|)
name|hldev
operator|->
name|bar1
decl_stmt|;
name|hldev
operator|->
name|spdm_mem_base
operator|=
name|bar1
operator|+
operator|(
name|spdm_bar_offset
operator|*
literal|8
operator|)
expr_stmt|;
break|break;
block|}
default|default:
name|xge_assert
argument_list|(
operator|(
operator|(
name|spdm_bar_num
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|spdm_bar_num
operator|!=
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Retrieve the size of SPDM table(number of entries). 	 */
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|spdm_structure
argument_list|)
expr_stmt|;
name|hldev
operator|->
name|spdm_max_entries
operator|=
name|XGE_HAL_SPDM_MAX_ENTRIES
argument_list|(
name|val64
argument_list|)
expr_stmt|;
name|spdm_table_size
operator|=
name|hldev
operator|->
name|spdm_max_entries
operator|*
sizeof|sizeof
argument_list|(
name|xge_hal_spdm_entry_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|hldev
operator|->
name|spdm_table
operator|==
name|NULL
condition|)
block|{
name|void
modifier|*
name|mem
decl_stmt|;
comment|/* 	     * Allocate memory to hold the copy of SPDM table. 	     */
if|if
condition|(
operator|(
name|hldev
operator|->
name|spdm_table
operator|=
operator|(
name|xge_hal_spdm_entry_t
operator|*
operator|*
operator|)
name|xge_os_malloc
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|xge_hal_spdm_entry_t
operator|*
argument_list|)
operator|*
name|hldev
operator|->
name|spdm_max_entries
operator|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
name|XGE_HAL_ERR_OUT_OF_MEMORY
return|;
block|}
if|if
condition|(
operator|(
name|mem
operator|=
name|xge_os_malloc
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|spdm_table_size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|xge_os_free
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|spdm_table
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|xge_hal_spdm_entry_t
operator|*
argument_list|)
operator|*
name|hldev
operator|->
name|spdm_max_entries
operator|)
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_ERR_OUT_OF_MEMORY
return|;
block|}
name|xge_os_memzero
argument_list|(
name|mem
argument_list|,
name|spdm_table_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hldev
operator|->
name|spdm_max_entries
condition|;
name|i
operator|++
control|)
block|{
name|hldev
operator|->
name|spdm_table
index|[
name|i
index|]
operator|=
operator|(
name|xge_hal_spdm_entry_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|mem
operator|+
name|i
operator|*
sizeof|sizeof
argument_list|(
name|xge_hal_spdm_entry_t
argument_list|)
operator|)
expr_stmt|;
block|}
name|xge_os_spin_lock_init
argument_list|(
operator|&
name|hldev
operator|->
name|spdm_lock
argument_list|,
name|hldev
operator|->
name|pdev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * We are here because the host driver tries to 	     * do a soft reset on the device. 	     * Since the device soft reset clears the SPDM table, copy 	     * the entries from the local SPDM table to the actual one. 	     */
name|xge_os_spin_lock
argument_list|(
operator|&
name|hldev
operator|->
name|spdm_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hldev
operator|->
name|spdm_max_entries
condition|;
name|i
operator|++
control|)
block|{
name|xge_hal_spdm_entry_t
modifier|*
name|spdm_entry
init|=
name|hldev
operator|->
name|spdm_table
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|spdm_entry
operator|->
name|in_use
condition|)
block|{
if|if
condition|(
name|__hal_spdm_entry_add
argument_list|(
name|hldev
argument_list|,
operator|&
name|spdm_entry
operator|->
name|src_ip
argument_list|,
operator|&
name|spdm_entry
operator|->
name|dst_ip
argument_list|,
name|spdm_entry
operator|->
name|l4_sp
argument_list|,
name|spdm_entry
operator|->
name|l4_dp
argument_list|,
name|spdm_entry
operator|->
name|is_tcp
argument_list|,
name|spdm_entry
operator|->
name|is_ipv4
argument_list|,
name|spdm_entry
operator|->
name|tgt_queue
argument_list|,
name|spdm_entry
operator|->
name|jhash_value
argument_list|,
name|spdm_entry
operator|->
name|spdm_entry
argument_list|)
operator|!=
name|XGE_HAL_OK
condition|)
block|{
comment|/* Log an warning */
name|xge_debug_device
argument_list|(
name|XGE_ERR
argument_list|,
literal|"SPDM table update from local"
literal|" memory failed"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|xge_os_spin_unlock
argument_list|(
operator|&
name|hldev
operator|->
name|spdm_lock
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set the receive traffic steering mode from default(classic) 	 * to enhanced. 	 */
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|rts_ctrl
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_RTS_CTRL_ENHANCED_MODE
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rts_ctrl
argument_list|)
expr_stmt|;
comment|/* 	 * We may not need to configure rts_rth_jhash_cfg register as the 	 * default values are good enough to calculate the hash. 	 */
comment|/* 	 * As of now, set all the rth mask registers to zero. TODO. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
literal|0
argument_list|,
operator|&
name|bar0
operator|->
name|rts_rth_hash_mask
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
literal|0
argument_list|,
operator|&
name|bar0
operator|->
name|rts_rth_hash_mask_5
argument_list|)
expr_stmt|;
if|if
condition|(
name|hldev
operator|->
name|config
operator|.
name|rth_spdm_use_l4
condition|)
block|{
name|val64
operator|=
name|XGE_HAL_RTH_STATUS_SPDM_USE_L4
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rts_rth_status
argument_list|)
expr_stmt|;
block|}
name|val64
operator|=
name|XGE_HAL_RTS_RTH_EN
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_RTS_RTH_IPV4_EN
operator||
name|XGE_HAL_RTS_RTH_TCP_IPV4_EN
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rts_rth_cfg
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/*  * __hal_device_pci_init  * @hldev: HAL device handle.  *  * Initialize certain PCI/PCI-X configuration registers  * with recommended values. Save config space for future hw resets.  */
end_comment

begin_function
specifier|static
name|void
name|__hal_device_pci_init
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|pcisize
init|=
literal|0
decl_stmt|;
name|u16
name|cmd
init|=
literal|0
decl_stmt|;
name|u8
name|val
decl_stmt|;
comment|/* Store PCI device ID and revision for future references where in we 	 * decide Xena revision using PCI sub system ID */
name|xge_os_pci_read16
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_le_t
argument_list|,
name|device_id
argument_list|)
argument_list|,
operator|&
name|hldev
operator|->
name|device_id
argument_list|)
expr_stmt|;
name|xge_os_pci_read8
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_le_t
argument_list|,
name|revision
argument_list|)
argument_list|,
operator|&
name|hldev
operator|->
name|revision
argument_list|)
expr_stmt|;
if|if
condition|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_HERC
condition|)
name|pcisize
operator|=
name|XGE_HAL_PCISIZE_HERC
expr_stmt|;
elseif|else
if|if
condition|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_XENA
condition|)
name|pcisize
operator|=
name|XGE_HAL_PCISIZE_XENA
expr_stmt|;
comment|/* save original PCI config space to restore it on device_terminate() */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pcisize
condition|;
name|i
operator|++
control|)
block|{
name|xge_os_pci_read32
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
name|i
operator|*
literal|4
argument_list|,
operator|(
name|u32
operator|*
operator|)
operator|&
name|hldev
operator|->
name|pci_config_space_bios
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Set the PErr Repconse bit and SERR in PCI command register. */
name|xge_os_pci_read16
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_le_t
argument_list|,
name|command
argument_list|)
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator||=
literal|0x140
expr_stmt|;
name|xge_os_pci_write16
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_le_t
argument_list|,
name|command
argument_list|)
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
comment|/* Set user spcecified value for the PCI Latency Timer */
if|if
condition|(
name|hldev
operator|->
name|config
operator|.
name|latency_timer
operator|&&
name|hldev
operator|->
name|config
operator|.
name|latency_timer
operator|!=
name|XGE_HAL_USE_BIOS_DEFAULT_LATENCY
condition|)
block|{
name|xge_os_pci_write8
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_le_t
argument_list|,
name|latency_timer
argument_list|)
argument_list|,
operator|(
name|u8
operator|)
name|hldev
operator|->
name|config
operator|.
name|latency_timer
argument_list|)
expr_stmt|;
block|}
comment|/* Read back latency timer to reflect it into user level */
name|xge_os_pci_read8
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_le_t
argument_list|,
name|latency_timer
argument_list|)
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|hldev
operator|->
name|config
operator|.
name|latency_timer
operator|=
name|val
expr_stmt|;
comment|/* Enable Data Parity Error Recovery in PCI-X command register. */
name|xge_os_pci_read16
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_le_t
argument_list|,
name|pcix_command
argument_list|)
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator||=
literal|1
expr_stmt|;
name|xge_os_pci_write16
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_le_t
argument_list|,
name|pcix_command
argument_list|)
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
comment|/* Set MMRB count in PCI-X command register. */
if|if
condition|(
name|hldev
operator|->
name|config
operator|.
name|mmrb_count
operator|!=
name|XGE_HAL_DEFAULT_BIOS_MMRB_COUNT
condition|)
block|{
name|cmd
operator|&=
literal|0xFFF3
expr_stmt|;
name|cmd
operator||=
name|hldev
operator|->
name|config
operator|.
name|mmrb_count
operator|<<
literal|2
expr_stmt|;
name|xge_os_pci_write16
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_le_t
argument_list|,
name|pcix_command
argument_list|)
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
comment|/* Read back MMRB count to reflect it into user level */
name|xge_os_pci_read16
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_le_t
argument_list|,
name|pcix_command
argument_list|)
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|&=
literal|0x000C
expr_stmt|;
name|hldev
operator|->
name|config
operator|.
name|mmrb_count
operator|=
name|cmd
operator|>>
literal|2
expr_stmt|;
comment|/*  Setting Maximum outstanding splits based on system type. */
if|if
condition|(
name|hldev
operator|->
name|config
operator|.
name|max_splits_trans
operator|!=
name|XGE_HAL_USE_BIOS_DEFAULT_SPLITS
condition|)
block|{
name|xge_os_pci_read16
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_le_t
argument_list|,
name|pcix_command
argument_list|)
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|&=
literal|0xFF8F
expr_stmt|;
name|cmd
operator||=
name|hldev
operator|->
name|config
operator|.
name|max_splits_trans
operator|<<
literal|4
expr_stmt|;
name|xge_os_pci_write16
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_le_t
argument_list|,
name|pcix_command
argument_list|)
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
comment|/* Read back max split trans to reflect it into user level */
name|xge_os_pci_read16
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_le_t
argument_list|,
name|pcix_command
argument_list|)
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|&=
literal|0x0070
expr_stmt|;
name|hldev
operator|->
name|config
operator|.
name|max_splits_trans
operator|=
name|cmd
operator|>>
literal|4
expr_stmt|;
comment|/* Forcibly disabling relaxed ordering capability of the card. */
name|xge_os_pci_read16
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_le_t
argument_list|,
name|pcix_command
argument_list|)
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|&=
literal|0xFFFD
expr_stmt|;
name|xge_os_pci_write16
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_le_t
argument_list|,
name|pcix_command
argument_list|)
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
comment|/* save PCI config space for future resets */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pcisize
condition|;
name|i
operator|++
control|)
block|{
name|xge_os_pci_read32
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
name|i
operator|*
literal|4
argument_list|,
operator|(
name|u32
operator|*
operator|)
operator|&
name|hldev
operator|->
name|pci_config_space
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * __hal_device_pci_info_get - Get PCI bus informations such as width, frequency  *                               and mode.  * @devh: HAL device handle.  * @pci_mode:       pointer to a variable of enumerated type  *          xge_hal_pci_mode_e{}.  * @bus_frequency:  pointer to a variable of enumerated type  *          xge_hal_pci_bus_frequency_e{}.  * @bus_width:      pointer to a variable of enumerated type  *          xge_hal_pci_bus_width_e{}.  *  * Get pci mode, frequency, and PCI bus width.  *  * Returns: one of the xge_hal_status_e{} enumerated types.  * XGE_HAL_OK           - for success.  * XGE_HAL_ERR_INVALID_PCI_INFO - for invalid PCI information from the card.  * XGE_HAL_ERR_BAD_DEVICE_ID    - for invalid card.  *  * See Also: xge_hal_pci_mode_e, xge_hal_pci_mode_e, xge_hal_pci_width_e.  */
end_comment

begin_function
specifier|static
name|xge_hal_status_e
name|__hal_device_pci_info_get
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|,
name|xge_hal_pci_mode_e
modifier|*
name|pci_mode
parameter_list|,
name|xge_hal_pci_bus_frequency_e
modifier|*
name|bus_frequency
parameter_list|,
name|xge_hal_pci_bus_width_e
modifier|*
name|bus_width
parameter_list|)
block|{
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
name|xge_hal_status_e
name|rc_status
init|=
name|XGE_HAL_OK
decl_stmt|;
name|xge_hal_card_e
name|card_id
init|=
name|xge_hal_device_check_id
argument_list|(
name|devh
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|XGE_HAL_HERC_EMULATION
name|hldev
operator|->
name|config
operator|.
name|pci_freq_mherz
operator|=
name|XGE_HAL_PCI_BUS_FREQUENCY_66MHZ
expr_stmt|;
operator|*
name|bus_frequency
operator|=
name|XGE_HAL_PCI_BUS_FREQUENCY_66MHZ
expr_stmt|;
operator|*
name|pci_mode
operator|=
name|XGE_HAL_PCI_66MHZ_MODE
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|card_id
operator|==
name|XGE_HAL_CARD_HERC
condition|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|pci_info
init|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|pci_info
argument_list|)
decl_stmt|;
if|if
condition|(
name|XGE_HAL_PCI_32_BIT
operator|&
name|pci_info
condition|)
operator|*
name|bus_width
operator|=
name|XGE_HAL_PCI_BUS_WIDTH_32BIT
expr_stmt|;
else|else
operator|*
name|bus_width
operator|=
name|XGE_HAL_PCI_BUS_WIDTH_64BIT
expr_stmt|;
switch|switch
condition|(
operator|(
name|pci_info
operator|&
name|XGE_HAL_PCI_INFO
operator|)
operator|>>
literal|60
condition|)
block|{
case|case
name|XGE_HAL_PCI_33MHZ_MODE
case|:
operator|*
name|bus_frequency
operator|=
name|XGE_HAL_PCI_BUS_FREQUENCY_33MHZ
expr_stmt|;
operator|*
name|pci_mode
operator|=
name|XGE_HAL_PCI_33MHZ_MODE
expr_stmt|;
break|break;
case|case
name|XGE_HAL_PCI_66MHZ_MODE
case|:
operator|*
name|bus_frequency
operator|=
name|XGE_HAL_PCI_BUS_FREQUENCY_66MHZ
expr_stmt|;
operator|*
name|pci_mode
operator|=
name|XGE_HAL_PCI_66MHZ_MODE
expr_stmt|;
break|break;
case|case
name|XGE_HAL_PCIX_M1_66MHZ_MODE
case|:
operator|*
name|bus_frequency
operator|=
name|XGE_HAL_PCI_BUS_FREQUENCY_66MHZ
expr_stmt|;
operator|*
name|pci_mode
operator|=
name|XGE_HAL_PCIX_M1_66MHZ_MODE
expr_stmt|;
break|break;
case|case
name|XGE_HAL_PCIX_M1_100MHZ_MODE
case|:
operator|*
name|bus_frequency
operator|=
name|XGE_HAL_PCI_BUS_FREQUENCY_100MHZ
expr_stmt|;
operator|*
name|pci_mode
operator|=
name|XGE_HAL_PCIX_M1_100MHZ_MODE
expr_stmt|;
break|break;
case|case
name|XGE_HAL_PCIX_M1_133MHZ_MODE
case|:
operator|*
name|bus_frequency
operator|=
name|XGE_HAL_PCI_BUS_FREQUENCY_133MHZ
expr_stmt|;
operator|*
name|pci_mode
operator|=
name|XGE_HAL_PCIX_M1_133MHZ_MODE
expr_stmt|;
break|break;
case|case
name|XGE_HAL_PCIX_M2_66MHZ_MODE
case|:
operator|*
name|bus_frequency
operator|=
name|XGE_HAL_PCI_BUS_FREQUENCY_133MHZ
expr_stmt|;
operator|*
name|pci_mode
operator|=
name|XGE_HAL_PCIX_M2_66MHZ_MODE
expr_stmt|;
break|break;
case|case
name|XGE_HAL_PCIX_M2_100MHZ_MODE
case|:
operator|*
name|bus_frequency
operator|=
name|XGE_HAL_PCI_BUS_FREQUENCY_200MHZ
expr_stmt|;
operator|*
name|pci_mode
operator|=
name|XGE_HAL_PCIX_M2_100MHZ_MODE
expr_stmt|;
break|break;
case|case
name|XGE_HAL_PCIX_M2_133MHZ_MODE
case|:
operator|*
name|bus_frequency
operator|=
name|XGE_HAL_PCI_BUS_FREQUENCY_266MHZ
expr_stmt|;
operator|*
name|pci_mode
operator|=
name|XGE_HAL_PCIX_M2_133MHZ_MODE
expr_stmt|;
break|break;
case|case
name|XGE_HAL_PCIX_M1_RESERVED
case|:
case|case
name|XGE_HAL_PCIX_M1_66MHZ_NS
case|:
case|case
name|XGE_HAL_PCIX_M1_100MHZ_NS
case|:
case|case
name|XGE_HAL_PCIX_M1_133MHZ_NS
case|:
case|case
name|XGE_HAL_PCIX_M2_RESERVED
case|:
case|case
name|XGE_HAL_PCIX_533_RESERVED
case|:
default|default:
name|rc_status
operator|=
name|XGE_HAL_ERR_INVALID_PCI_INFO
expr_stmt|;
name|xge_debug_device
argument_list|(
name|XGE_ERR
argument_list|,
literal|"invalid pci info "
name|XGE_OS_LLXFMT
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|pci_info
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rc_status
operator|!=
name|XGE_HAL_ERR_INVALID_PCI_INFO
condition|)
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"PCI info: mode %d width "
literal|"%d frequency %d"
argument_list|,
operator|*
name|pci_mode
argument_list|,
operator|*
name|bus_width
argument_list|,
operator|*
name|bus_frequency
argument_list|)
expr_stmt|;
if|if
condition|(
name|hldev
operator|->
name|config
operator|.
name|pci_freq_mherz
operator|==
name|XGE_HAL_DEFAULT_USE_HARDCODE
condition|)
block|{
name|hldev
operator|->
name|config
operator|.
name|pci_freq_mherz
operator|=
operator|*
name|bus_frequency
expr_stmt|;
block|}
block|}
comment|/* for XENA, we report PCI mode, only. PCI bus frequency, and bus width 	 * are set to unknown */
elseif|else
if|if
condition|(
name|card_id
operator|==
name|XGE_HAL_CARD_XENA
condition|)
block|{
name|u32
name|pcix_status
decl_stmt|;
name|u8
name|dev_num
decl_stmt|,
name|bus_num
decl_stmt|;
comment|/* initialize defaults for XENA */
operator|*
name|bus_frequency
operator|=
name|XGE_HAL_PCI_BUS_FREQUENCY_UNKNOWN
expr_stmt|;
operator|*
name|bus_width
operator|=
name|XGE_HAL_PCI_BUS_WIDTH_UNKNOWN
expr_stmt|;
name|xge_os_pci_read32
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_le_t
argument_list|,
name|pcix_status
argument_list|)
argument_list|,
operator|&
name|pcix_status
argument_list|)
expr_stmt|;
name|dev_num
operator|=
call|(
name|u8
call|)
argument_list|(
operator|(
name|pcix_status
operator|&
literal|0xF8
operator|)
operator|>>
literal|3
argument_list|)
expr_stmt|;
name|bus_num
operator|=
call|(
name|u8
call|)
argument_list|(
operator|(
name|pcix_status
operator|&
literal|0xFF00
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_num
operator|==
literal|0
operator|&&
name|bus_num
operator|==
literal|0
condition|)
operator|*
name|pci_mode
operator|=
name|XGE_HAL_PCI_BASIC_MODE
expr_stmt|;
else|else
operator|*
name|pci_mode
operator|=
name|XGE_HAL_PCIX_BASIC_MODE
expr_stmt|;
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"PCI info: mode %d"
argument_list|,
operator|*
name|pci_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|hldev
operator|->
name|config
operator|.
name|pci_freq_mherz
operator|==
name|XGE_HAL_DEFAULT_USE_HARDCODE
condition|)
block|{
comment|/* 	         * There is no way to detect BUS frequency on Xena, 	         * so, in case of automatic configuration we hopelessly 	         * assume 133MHZ. 	         */
name|hldev
operator|->
name|config
operator|.
name|pci_freq_mherz
operator|=
name|XGE_HAL_PCI_BUS_FREQUENCY_133MHZ
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|card_id
operator|==
name|XGE_HAL_CARD_TITAN
condition|)
block|{
operator|*
name|bus_width
operator|=
name|XGE_HAL_PCI_BUS_WIDTH_64BIT
expr_stmt|;
operator|*
name|bus_frequency
operator|=
name|XGE_HAL_PCI_BUS_FREQUENCY_250MHZ
expr_stmt|;
if|if
condition|(
name|hldev
operator|->
name|config
operator|.
name|pci_freq_mherz
operator|==
name|XGE_HAL_DEFAULT_USE_HARDCODE
condition|)
block|{
name|hldev
operator|->
name|config
operator|.
name|pci_freq_mherz
operator|=
operator|*
name|bus_frequency
expr_stmt|;
block|}
block|}
else|else
block|{
name|rc_status
operator|=
name|XGE_HAL_ERR_BAD_DEVICE_ID
expr_stmt|;
name|xge_debug_device
argument_list|(
name|XGE_ERR
argument_list|,
literal|"invalid device id %d"
argument_list|,
name|card_id
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|rc_status
return|;
block|}
end_function

begin_comment
comment|/*  * __hal_device_handle_link_up_ind  * @hldev: HAL device handle.  *  * Link up indication handler. The function is invoked by HAL when  * Xframe indicates that the link is up for programmable amount of time.  */
end_comment

begin_function
specifier|static
name|int
name|__hal_device_handle_link_up_ind
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
comment|/* 	 * If the previous link state is not down, return. 	 */
if|if
condition|(
name|hldev
operator|->
name|link_state
operator|==
name|XGE_HAL_LINK_UP
condition|)
block|{
ifdef|#
directive|ifdef
name|XGE_HAL_PROCESS_LINK_INT_IN_ISR
if|if
condition|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_HERC
condition|)
block|{
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|misc_int_mask
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_MISC_INT_REG_LINK_UP_INT
expr_stmt|;
name|val64
operator|&=
operator|~
name|XGE_HAL_MISC_INT_REG_LINK_DOWN_INT
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|misc_int_mask
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"link up indication while link is up, ignoring.."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Now re-enable it as due to noise, hardware turned it off */
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_control
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_ADAPTER_CNTL_EN
expr_stmt|;
name|val64
operator|=
name|val64
operator|&
operator|(
operator|~
name|XGE_HAL_ADAPTER_ECC_EN
operator|)
expr_stmt|;
comment|/* ECC enable */
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_control
argument_list|)
expr_stmt|;
comment|/* Turn on the Laser */
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_control
argument_list|)
expr_stmt|;
name|val64
operator|=
name|val64
operator||
operator|(
name|XGE_HAL_ADAPTER_EOI_TX_ON
operator||
name|XGE_HAL_ADAPTER_LED_ON
operator|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_control
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XGE_HAL_PROCESS_LINK_INT_IN_ISR
if|if
condition|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_HERC
condition|)
block|{
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|val64
operator|&
operator|(
name|XGE_HAL_ADAPTER_STATUS_RMAC_REMOTE_FAULT
operator||
name|XGE_HAL_ADAPTER_STATUS_RMAC_LOCAL_FAULT
operator|)
condition|)
block|{
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"%s"
argument_list|,
literal|"fail to transition link to up..."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* 	             * Mask the Link Up interrupt and unmask the Link Down 	             * interrupt. 	             */
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|misc_int_mask
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_MISC_INT_REG_LINK_UP_INT
expr_stmt|;
name|val64
operator|&=
operator|~
name|XGE_HAL_MISC_INT_REG_LINK_DOWN_INT
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|misc_int_mask
argument_list|)
expr_stmt|;
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"calling link up.."
argument_list|)
expr_stmt|;
name|hldev
operator|->
name|link_state
operator|=
name|XGE_HAL_LINK_UP
expr_stmt|;
comment|/* notify ULD */
if|if
condition|(
name|g_xge_hal_driver
operator|->
name|uld_callbacks
operator|.
name|link_up
condition|)
block|{
name|g_xge_hal_driver
operator|->
name|uld_callbacks
operator|.
name|link_up
argument_list|(
name|hldev
operator|->
name|upper_layer_info
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
block|}
endif|#
directive|endif
name|xge_os_mdelay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|__hal_device_register_poll
argument_list|(
name|hldev
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_status
argument_list|,
literal|0
argument_list|,
operator|(
name|XGE_HAL_ADAPTER_STATUS_RMAC_REMOTE_FAULT
operator||
name|XGE_HAL_ADAPTER_STATUS_RMAC_LOCAL_FAULT
operator|)
argument_list|,
name|XGE_HAL_DEVICE_FAULT_WAIT_MAX_MILLIS
argument_list|)
operator|==
name|XGE_HAL_OK
condition|)
block|{
comment|/* notify ULD */
operator|(
name|void
operator|)
name|xge_queue_produce_context
argument_list|(
name|hldev
operator|->
name|queueh
argument_list|,
name|XGE_HAL_EVENT_LINK_IS_UP
argument_list|,
name|hldev
argument_list|)
expr_stmt|;
comment|/* link is up after been enabled */
return|return
literal|1
return|;
block|}
else|else
block|{
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"%s"
argument_list|,
literal|"fail to transition link to up..."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * __hal_device_handle_link_down_ind  * @hldev: HAL device handle.  *  * Link down indication handler. The function is invoked by HAL when  * Xframe indicates that the link is down.  */
end_comment

begin_function
specifier|static
name|int
name|__hal_device_handle_link_down_ind
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
comment|/* 	 * If the previous link state is not up, return. 	 */
if|if
condition|(
name|hldev
operator|->
name|link_state
operator|==
name|XGE_HAL_LINK_DOWN
condition|)
block|{
ifdef|#
directive|ifdef
name|XGE_HAL_PROCESS_LINK_INT_IN_ISR
if|if
condition|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_HERC
condition|)
block|{
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|misc_int_mask
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_MISC_INT_REG_LINK_DOWN_INT
expr_stmt|;
name|val64
operator|&=
operator|~
name|XGE_HAL_MISC_INT_REG_LINK_UP_INT
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|misc_int_mask
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"link down indication while link is down, ignoring.."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|xge_os_mdelay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_control
argument_list|)
expr_stmt|;
comment|/* try to debounce the link only if the adapter is enabled. */
if|if
condition|(
name|val64
operator|&
name|XGE_HAL_ADAPTER_CNTL_EN
condition|)
block|{
if|if
condition|(
name|__hal_device_register_poll
argument_list|(
name|hldev
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_status
argument_list|,
literal|0
argument_list|,
operator|(
name|XGE_HAL_ADAPTER_STATUS_RMAC_REMOTE_FAULT
operator||
name|XGE_HAL_ADAPTER_STATUS_RMAC_LOCAL_FAULT
operator|)
argument_list|,
name|XGE_HAL_DEVICE_FAULT_WAIT_MAX_MILLIS
argument_list|)
operator|==
name|XGE_HAL_OK
condition|)
block|{
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"link is actually up (possible noisy link?), ignoring."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_control
argument_list|)
expr_stmt|;
comment|/* turn off LED */
name|val64
operator|=
name|val64
operator|&
operator|(
operator|~
name|XGE_HAL_ADAPTER_LED_ON
operator|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_control
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XGE_HAL_PROCESS_LINK_INT_IN_ISR
if|if
condition|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_HERC
condition|)
block|{
comment|/* 	     * Mask the Link Down interrupt and unmask the Link up 	     * interrupt 	     */
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|misc_int_mask
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_MISC_INT_REG_LINK_DOWN_INT
expr_stmt|;
name|val64
operator|&=
operator|~
name|XGE_HAL_MISC_INT_REG_LINK_UP_INT
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|misc_int_mask
argument_list|)
expr_stmt|;
comment|/* link is down */
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"calling link down.."
argument_list|)
expr_stmt|;
name|hldev
operator|->
name|link_state
operator|=
name|XGE_HAL_LINK_DOWN
expr_stmt|;
comment|/* notify ULD */
if|if
condition|(
name|g_xge_hal_driver
operator|->
name|uld_callbacks
operator|.
name|link_down
condition|)
block|{
name|g_xge_hal_driver
operator|->
name|uld_callbacks
operator|.
name|link_down
argument_list|(
name|hldev
operator|->
name|upper_layer_info
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* notify ULD */
operator|(
name|void
operator|)
name|xge_queue_produce_context
argument_list|(
name|hldev
operator|->
name|queueh
argument_list|,
name|XGE_HAL_EVENT_LINK_IS_DOWN
argument_list|,
name|hldev
argument_list|)
expr_stmt|;
comment|/* link is down */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * __hal_device_handle_link_state_change  * @hldev: HAL device handle.  *  * Link state change handler. The function is invoked by HAL when  * Xframe indicates link state change condition. The code here makes sure to  * 1) ignore redundant state change indications;  * 2) execute link-up sequence, and handle the failure to bring the link up;  * 3) generate XGE_HAL_LINK_UP/DOWN event for the subsequent handling by  *    upper-layer driver (ULD).  */
end_comment

begin_function
specifier|static
name|int
name|__hal_device_handle_link_state_change
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{
name|u64
name|hw_status
decl_stmt|;
name|int
name|hw_link_state
decl_stmt|;
name|int
name|retcode
decl_stmt|;
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_control
argument_list|)
expr_stmt|;
comment|/* If the adapter is not enabled but the hal thinks we are in the up 	 * state then transition to the down state. 	 */
if|if
condition|(
operator|!
operator|(
name|val64
operator|&
name|XGE_HAL_ADAPTER_CNTL_EN
operator|)
operator|&&
operator|(
name|hldev
operator|->
name|link_state
operator|==
name|XGE_HAL_LINK_UP
operator|)
condition|)
block|{
return|return
operator|(
name|__hal_device_handle_link_down_ind
argument_list|(
name|hldev
argument_list|)
operator|)
return|;
block|}
do|do
block|{
name|xge_os_mdelay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|xge_hal_device_status
argument_list|(
name|hldev
argument_list|,
operator|&
name|hw_status
argument_list|)
expr_stmt|;
name|hw_link_state
operator|=
operator|(
name|hw_status
operator|&
operator|(
name|XGE_HAL_ADAPTER_STATUS_RMAC_REMOTE_FAULT
operator||
name|XGE_HAL_ADAPTER_STATUS_RMAC_LOCAL_FAULT
operator|)
operator|)
condition|?
name|XGE_HAL_LINK_DOWN
else|:
name|XGE_HAL_LINK_UP
expr_stmt|;
comment|/* check if the current link state is still considered 	     * to be changed. This way we will make sure that this is 	     * not a noise which needs to be filtered out */
if|if
condition|(
name|hldev
operator|->
name|link_state
operator|==
name|hw_link_state
condition|)
break|break;
block|}
do|while
condition|(
name|i
operator|++
operator|<
name|hldev
operator|->
name|config
operator|.
name|link_valid_cnt
condition|)
do|;
comment|/* If the current link state is same as previous, just return */
if|if
condition|(
name|hldev
operator|->
name|link_state
operator|==
name|hw_link_state
condition|)
name|retcode
operator|=
literal|0
expr_stmt|;
comment|/* detected state change */
elseif|else
if|if
condition|(
name|hw_link_state
operator|==
name|XGE_HAL_LINK_UP
condition|)
name|retcode
operator|=
name|__hal_device_handle_link_up_ind
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
else|else
name|retcode
operator|=
name|__hal_device_handle_link_down_ind
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
return|return
name|retcode
return|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
specifier|static
name|void
name|__hal_device_handle_serr
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|,
name|char
modifier|*
name|reg
parameter_list|,
name|u64
name|value
parameter_list|)
block|{
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_err_stats
operator|.
name|serr_cnt
operator|++
expr_stmt|;
if|if
condition|(
name|hldev
operator|->
name|config
operator|.
name|dump_on_serr
condition|)
block|{
ifdef|#
directive|ifdef
name|XGE_HAL_USE_MGMT_AUX
operator|(
name|void
operator|)
name|xge_hal_aux_device_dump
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
operator|(
name|void
operator|)
name|xge_queue_produce
argument_list|(
name|hldev
operator|->
name|queueh
argument_list|,
name|XGE_HAL_EVENT_SERR
argument_list|,
name|hldev
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|value
argument_list|)
expr_stmt|;
name|xge_debug_device
argument_list|(
name|XGE_ERR
argument_list|,
literal|"%s: read "
name|XGE_OS_LLXFMT
argument_list|,
name|reg
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
specifier|static
name|void
name|__hal_device_handle_eccerr
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|,
name|char
modifier|*
name|reg
parameter_list|,
name|u64
name|value
parameter_list|)
block|{
if|if
condition|(
name|hldev
operator|->
name|config
operator|.
name|dump_on_eccerr
condition|)
block|{
ifdef|#
directive|ifdef
name|XGE_HAL_USE_MGMT_AUX
operator|(
name|void
operator|)
name|xge_hal_aux_device_dump
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Herc smart enough to recover on its own! */
if|if
condition|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_XENA
condition|)
block|{
operator|(
name|void
operator|)
name|xge_queue_produce
argument_list|(
name|hldev
operator|->
name|queueh
argument_list|,
name|XGE_HAL_EVENT_ECCERR
argument_list|,
name|hldev
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|value
argument_list|)
expr_stmt|;
block|}
name|xge_debug_device
argument_list|(
name|XGE_ERR
argument_list|,
literal|"%s: read "
name|XGE_OS_LLXFMT
argument_list|,
name|reg
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
specifier|static
name|void
name|__hal_device_handle_parityerr
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|,
name|char
modifier|*
name|reg
parameter_list|,
name|u64
name|value
parameter_list|)
block|{
if|if
condition|(
name|hldev
operator|->
name|config
operator|.
name|dump_on_parityerr
condition|)
block|{
ifdef|#
directive|ifdef
name|XGE_HAL_USE_MGMT_AUX
operator|(
name|void
operator|)
name|xge_hal_aux_device_dump
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
operator|(
name|void
operator|)
name|xge_queue_produce_context
argument_list|(
name|hldev
operator|->
name|queueh
argument_list|,
name|XGE_HAL_EVENT_PARITYERR
argument_list|,
name|hldev
argument_list|)
expr_stmt|;
name|xge_debug_device
argument_list|(
name|XGE_ERR
argument_list|,
literal|"%s: read "
name|XGE_OS_LLXFMT
argument_list|,
name|reg
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
specifier|static
name|void
name|__hal_device_handle_targetabort
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{
operator|(
name|void
operator|)
name|xge_queue_produce_context
argument_list|(
name|hldev
operator|->
name|queueh
argument_list|,
name|XGE_HAL_EVENT_TARGETABORT
argument_list|,
name|hldev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * __hal_device_hw_initialize  * @hldev: HAL device handle.  *  * Initialize Xframe hardware.  */
end_comment

begin_function
specifier|static
name|xge_hal_status_e
name|__hal_device_hw_initialize
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|xge_hal_status_e
name|status
decl_stmt|;
name|u64
name|val64
decl_stmt|;
comment|/* Set proper endian settings and verify the same by reading the PIF 	 * Feed-back register. */
name|status
operator|=
name|__hal_device_set_swapper
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
block|{
return|return
name|status
return|;
block|}
comment|/* update the pci mode, frequency, and width */
if|if
condition|(
name|__hal_device_pci_info_get
argument_list|(
name|hldev
argument_list|,
operator|&
name|hldev
operator|->
name|pci_mode
argument_list|,
operator|&
name|hldev
operator|->
name|bus_frequency
argument_list|,
operator|&
name|hldev
operator|->
name|bus_width
argument_list|)
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|hldev
operator|->
name|pci_mode
operator|=
name|XGE_HAL_PCI_INVALID_MODE
expr_stmt|;
name|hldev
operator|->
name|bus_frequency
operator|=
name|XGE_HAL_PCI_BUS_FREQUENCY_UNKNOWN
expr_stmt|;
name|hldev
operator|->
name|bus_width
operator|=
name|XGE_HAL_PCI_BUS_WIDTH_UNKNOWN
expr_stmt|;
comment|/* 	     * FIXME: this cannot happen. 	     * But if it happens we cannot continue just like that 	     */
name|xge_debug_device
argument_list|(
name|XGE_ERR
argument_list|,
literal|"unable to get pci info"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|hldev
operator|->
name|pci_mode
operator|==
name|XGE_HAL_PCI_33MHZ_MODE
operator|)
operator|||
operator|(
name|hldev
operator|->
name|pci_mode
operator|==
name|XGE_HAL_PCI_66MHZ_MODE
operator|)
operator|||
operator|(
name|hldev
operator|->
name|pci_mode
operator|==
name|XGE_HAL_PCI_BASIC_MODE
operator|)
condition|)
block|{
comment|/* PCI optimization: set TxReqTimeOut 	     * register (0x800+0x120) to 0x1ff or 	     * something close to this. 	     * Note: not to be used for PCI-X! */
name|val64
operator|=
name|XGE_HAL_TXREQTO_VAL
argument_list|(
literal|0x1FF
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_TXREQTO_EN
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|txreqtimeout
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
literal|0ULL
argument_list|,
operator|&
name|bar0
operator|->
name|read_retry_delay
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
literal|0ULL
argument_list|,
operator|&
name|bar0
operator|->
name|write_retry_delay
argument_list|)
expr_stmt|;
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"%s"
argument_list|,
literal|"optimizing for PCI mode"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hldev
operator|->
name|bus_frequency
operator|==
name|XGE_HAL_PCI_BUS_FREQUENCY_266MHZ
operator|||
name|hldev
operator|->
name|bus_frequency
operator|==
name|XGE_HAL_PCI_BUS_FREQUENCY_250MHZ
condition|)
block|{
comment|/* Optimizing for PCI-X 266/250 */
name|val64
operator|=
name|XGE_HAL_TXREQTO_VAL
argument_list|(
literal|0x7F
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_TXREQTO_EN
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|txreqtimeout
argument_list|)
expr_stmt|;
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"%s"
argument_list|,
literal|"optimizing for PCI-X 266/250 modes"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_HERC
condition|)
block|{
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
literal|0x4000000000000ULL
argument_list|,
operator|&
name|bar0
operator|->
name|read_retry_delay
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
literal|0x4000000000000ULL
argument_list|,
operator|&
name|bar0
operator|->
name|write_retry_delay
argument_list|)
expr_stmt|;
block|}
comment|/* added this to set the no of bytes used to update lso_bytes_sent 	   returned TxD0 */
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|pic_control_2
argument_list|)
expr_stmt|;
name|val64
operator|&=
operator|~
name|XGE_HAL_TXD_WRITE_BC
argument_list|(
literal|0x2
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_TXD_WRITE_BC
argument_list|(
literal|0x4
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|pic_control_2
argument_list|)
expr_stmt|;
comment|/* added this to clear the EOI_RESET field while leaving XGXS_RESET 	 * in reset, then a 1-second delay */
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|XGE_HAL_SW_RESET_XGXS
argument_list|,
operator|&
name|bar0
operator|->
name|sw_reset
argument_list|)
expr_stmt|;
name|xge_os_mdelay
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* Clear the XGXS_RESET field of the SW_RESET register in order to 	 * release the XGXS from reset. Its reset value is 0xA5; write 0x00 	 * to activate the XGXS. The core requires a minimum 500 us reset.*/
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
literal|0
argument_list|,
operator|&
name|bar0
operator|->
name|sw_reset
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|sw_reset
argument_list|)
expr_stmt|;
name|xge_os_mdelay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* read registers in all blocks */
operator|(
name|void
operator|)
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|mac_int_mask
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|mc_int_mask
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|xgxs_int_mask
argument_list|)
expr_stmt|;
comment|/* set default MTU and steer based on length*/
name|__hal_ring_mtu_set
argument_list|(
name|hldev
argument_list|,
name|hldev
operator|->
name|config
operator|.
name|mtu
operator|+
literal|22
argument_list|)
expr_stmt|;
comment|// Alway set 22 bytes extra for steering to work
if|if
condition|(
name|hldev
operator|->
name|config
operator|.
name|mac
operator|.
name|rmac_bcast_en
condition|)
block|{
name|xge_hal_device_bcast_enable
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xge_hal_device_bcast_disable
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|XGE_HAL_HERC_EMULATION
name|__hal_device_xaui_configure
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|__hal_device_mac_link_util_set
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
name|__hal_device_mac_link_util_set
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
comment|/* 	 * Keep its PCI REQ# line asserted during a write 	 * transaction up to the end of the transaction 	 */
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|misc_control
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_MISC_CONTROL_EXT_REQ_EN
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|misc_control
argument_list|)
expr_stmt|;
if|if
condition|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_HERC
condition|)
block|{
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|misc_control
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_MISC_CONTROL_LINK_FAULT
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|misc_control
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * bimodal interrupts is when all Rx traffic interrupts 	 * will go to TTI, so we need to adjust RTI settings and 	 * use adaptive TTI timer. We need to make sure RTI is 	 * properly configured to sane value which will not 	 * distrupt bimodal behavior. 	 */
if|if
condition|(
name|hldev
operator|->
name|config
operator|.
name|bimodal_interrupts
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* force polling_cnt to be "0", otherwise 	     * IRQ workload statistics will be screwed. This could 	     * be worked out in TXPIC handler later. */
name|hldev
operator|->
name|config
operator|.
name|isr_polling_cnt
operator|=
literal|0
expr_stmt|;
name|hldev
operator|->
name|config
operator|.
name|sched_timer_us
operator|=
literal|10000
expr_stmt|;
comment|/* disable all TTI< 56 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XGE_HAL_MAX_FIFO_NUM
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|hldev
operator|->
name|config
operator|.
name|fifo
operator|.
name|queue
index|[
name|i
index|]
operator|.
name|configured
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XGE_HAL_MAX_FIFO_TTI_NUM
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|hldev
operator|->
name|config
operator|.
name|fifo
operator|.
name|queue
index|[
name|i
index|]
operator|.
name|tti
index|[
name|j
index|]
operator|.
name|enabled
condition|)
name|hldev
operator|->
name|config
operator|.
name|fifo
operator|.
name|queue
index|[
name|i
index|]
operator|.
name|tti
index|[
name|j
index|]
operator|.
name|enabled
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* now configure bimodal interrupts */
name|__hal_device_bimodal_configure
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
name|__hal_device_tti_configure
argument_list|(
name|hldev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
return|return
name|status
return|;
name|status
operator|=
name|__hal_device_rti_configure
argument_list|(
name|hldev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
return|return
name|status
return|;
name|status
operator|=
name|__hal_device_rth_it_configure
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
return|return
name|status
return|;
name|status
operator|=
name|__hal_device_rth_spdm_configure
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
return|return
name|status
return|;
name|status
operator|=
name|__hal_device_rts_mac_configure
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_debug_device
argument_list|(
name|XGE_ERR
argument_list|,
literal|"__hal_device_rts_mac_configure Failed "
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
name|status
operator|=
name|__hal_device_rts_port_configure
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_debug_device
argument_list|(
name|XGE_ERR
argument_list|,
literal|"__hal_device_rts_port_configure Failed "
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
name|status
operator|=
name|__hal_device_rts_qos_configure
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_debug_device
argument_list|(
name|XGE_ERR
argument_list|,
literal|"__hal_device_rts_qos_configure Failed "
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
name|__hal_device_pause_frames_configure
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
name|__hal_device_rmac_padding_configure
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
name|__hal_device_shared_splits_configure
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
comment|/* make sure all interrupts going to be disabled at the moment */
name|__hal_device_intr_mgmt
argument_list|(
name|hldev
argument_list|,
name|XGE_HAL_ALL_INTRS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* SXE-008 Transmit DMA arbitration issue */
if|if
condition|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_XENA
operator|&&
name|hldev
operator|->
name|revision
operator|<
literal|4
condition|)
block|{
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|XGE_HAL_ADAPTER_PCC_ENABLE_FOUR
argument_list|,
operator|&
name|bar0
operator|->
name|pcc_enable
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|// Removing temporarily as FreeBSD is seeing lower performance
comment|// attributable to this fix.
comment|/* SXE-2-010 */
block|if (xge_hal_device_check_id(hldev) == XGE_HAL_CARD_HERC) {
comment|/* Turn off the ECC error reporting for RLDRAM interface */
block|if ((status = xge_hal_fix_rldram_ecc_error(hldev)) != XGE_HAL_OK) 	        return status; 	}
endif|#
directive|endif
name|__hal_fifo_hw_initialize
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
name|__hal_ring_hw_initialize
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
if|if
condition|(
name|__hal_device_wait_quiescent
argument_list|(
name|hldev
argument_list|,
operator|&
name|val64
argument_list|)
condition|)
block|{
return|return
name|XGE_HAL_ERR_DEVICE_IS_NOT_QUIESCENT
return|;
block|}
if|if
condition|(
name|__hal_device_register_poll
argument_list|(
name|hldev
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_status
argument_list|,
literal|1
argument_list|,
name|XGE_HAL_ADAPTER_STATUS_RC_PRC_QUIESCENT
argument_list|,
name|XGE_HAL_DEVICE_QUIESCENT_WAIT_MAX_MILLIS
argument_list|)
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"%s"
argument_list|,
literal|"PRC is not QUIESCENT!"
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_ERR_DEVICE_IS_NOT_QUIESCENT
return|;
block|}
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"device 0x"
name|XGE_OS_LLXFMT
literal|" is quiescent"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
operator|(
name|ulong_t
operator|)
name|hldev
argument_list|)
expr_stmt|;
if|if
condition|(
name|hldev
operator|->
name|config
operator|.
name|intr_mode
operator|==
name|XGE_HAL_INTR_MODE_MSIX
operator|||
name|hldev
operator|->
name|config
operator|.
name|intr_mode
operator|==
name|XGE_HAL_INTR_MODE_MSI
condition|)
block|{
comment|/* 	     * If MSI is enabled, ensure that One Shot for MSI in PCI_CTRL 	     * is disabled. 	     */
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|pic_control
argument_list|)
expr_stmt|;
name|val64
operator|&=
operator|~
operator|(
name|XGE_HAL_PIC_CNTL_ONE_SHOT_TINT
operator|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|pic_control
argument_list|)
expr_stmt|;
block|}
name|hldev
operator|->
name|hw_is_initialized
operator|=
literal|1
expr_stmt|;
name|hldev
operator|->
name|terminating
operator|=
literal|0
expr_stmt|;
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/*  * __hal_device_reset - Reset device only.  * @hldev: HAL device handle.  *  * Reset the device, and subsequently restore  * the previously saved PCI configuration space.  */
end_comment

begin_define
define|#
directive|define
name|XGE_HAL_MAX_PCI_CONFIG_SPACE_REINIT
value|50
end_define

begin_function
specifier|static
name|xge_hal_status_e
name|__hal_device_reset
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|swap_done
decl_stmt|,
name|pcisize
init|=
literal|0
decl_stmt|;
name|u64
name|val64
decl_stmt|,
name|rawval
init|=
literal|0ULL
decl_stmt|;
if|if
condition|(
name|hldev
operator|->
name|config
operator|.
name|intr_mode
operator|==
name|XGE_HAL_INTR_MODE_MSIX
condition|)
block|{
if|if
condition|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_HERC
condition|)
block|{
if|if
condition|(
name|hldev
operator|->
name|bar2
condition|)
block|{
name|u64
modifier|*
name|msix_vetor_table
init|=
operator|(
name|u64
operator|*
operator|)
name|hldev
operator|->
name|bar2
decl_stmt|;
comment|// 2 64bit words for each entry
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XGE_HAL_MAX_MSIX_MESSAGES
operator|*
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|hldev
operator|->
name|msix_vector_table
index|[
name|i
index|]
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh2
argument_list|,
operator|&
name|msix_vetor_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|pif_rd_swapper_fb
argument_list|)
expr_stmt|;
name|swap_done
operator|=
operator|(
name|val64
operator|==
name|XGE_HAL_IF_RD_SWAPPER_FB
operator|)
expr_stmt|;
if|if
condition|(
name|swap_done
condition|)
block|{
name|__hal_pio_mem_write32_upper
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
call|(
name|u32
call|)
argument_list|(
name|XGE_HAL_SW_RESET_ALL
operator|>>
literal|32
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|bar0
operator|->
name|sw_reset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|u32
name|val
init|=
call|(
name|u32
call|)
argument_list|(
name|XGE_HAL_SW_RESET_ALL
operator|>>
literal|32
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|XGE_OS_HOST_LITTLE_ENDIAN
argument_list|)
operator|||
name|defined
argument_list|(
name|XGE_OS_PIO_LITTLE_ENDIAN
argument_list|)
comment|/* swap it */
name|val
operator|=
operator|(
operator|(
operator|(
name|val
operator|&
operator|(
name|u32
operator|)
literal|0x000000ffUL
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|val
operator|&
operator|(
name|u32
operator|)
literal|0x0000ff00UL
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|val
operator|&
operator|(
name|u32
operator|)
literal|0x00ff0000UL
operator|)
operator|>>
literal|8
operator|)
operator||
operator|(
operator|(
name|val
operator|&
operator|(
name|u32
operator|)
literal|0xff000000UL
operator|)
operator|>>
literal|24
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
name|xge_os_pio_mem_write32
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val
argument_list|,
operator|&
name|bar0
operator|->
name|sw_reset
argument_list|)
expr_stmt|;
block|}
name|pcisize
operator|=
operator|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_HERC
operator|)
condition|?
name|XGE_HAL_PCISIZE_HERC
else|:
name|XGE_HAL_PCISIZE_XENA
expr_stmt|;
name|xge_os_mdelay
argument_list|(
literal|20
argument_list|)
expr_stmt|;
comment|/* Wait for 20 ms after reset */
block|{
comment|/* Poll for no more than 1 second */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XGE_HAL_MAX_PCI_CONFIG_SPACE_REINIT
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pcisize
condition|;
name|j
operator|++
control|)
block|{
name|xge_os_pci_write32
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
name|j
operator|*
literal|4
argument_list|,
operator|*
operator|(
operator|(
name|u32
operator|*
operator|)
operator|&
name|hldev
operator|->
name|pci_config_space
operator|+
name|j
operator|)
argument_list|)
expr_stmt|;
block|}
name|xge_os_pci_read16
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_le_t
argument_list|,
name|device_id
argument_list|)
argument_list|,
operator|&
name|hldev
operator|->
name|device_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|!=
name|XGE_HAL_CARD_UNKNOWN
condition|)
break|break;
name|xge_os_mdelay
argument_list|(
literal|20
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_UNKNOWN
condition|)
block|{
name|xge_debug_device
argument_list|(
name|XGE_ERR
argument_list|,
literal|"device reset failed"
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_ERR_RESET_FAILED
return|;
block|}
if|if
condition|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_HERC
condition|)
block|{
name|int
name|cnt
init|=
literal|0
decl_stmt|;
name|rawval
operator|=
name|XGE_HAL_SW_RESET_RAW_VAL_HERC
expr_stmt|;
name|pcisize
operator|=
name|XGE_HAL_PCISIZE_HERC
expr_stmt|;
name|xge_os_mdelay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|sw_reset
argument_list|)
expr_stmt|;
if|if
condition|(
name|val64
operator|!=
name|rawval
condition|)
block|{
break|break;
block|}
name|cnt
operator|++
expr_stmt|;
name|xge_os_mdelay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Wait for 1ms before retry */
block|}
do|while
condition|(
name|cnt
operator|<
literal|20
condition|)
do|;
block|}
elseif|else
if|if
condition|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_XENA
condition|)
block|{
name|rawval
operator|=
name|XGE_HAL_SW_RESET_RAW_VAL_XENA
expr_stmt|;
name|pcisize
operator|=
name|XGE_HAL_PCISIZE_XENA
expr_stmt|;
name|xge_os_mdelay
argument_list|(
name|XGE_HAL_DEVICE_RESET_WAIT_MAX_MILLIS
argument_list|)
expr_stmt|;
block|}
comment|/* Restore MSI-X vector table */
if|if
condition|(
name|hldev
operator|->
name|config
operator|.
name|intr_mode
operator|==
name|XGE_HAL_INTR_MODE_MSIX
condition|)
block|{
if|if
condition|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_HERC
condition|)
block|{
if|if
condition|(
name|hldev
operator|->
name|bar2
condition|)
block|{
comment|/* 	             * 94: MSIXTable 00000004  ( BIR:4  Offset:0x0 ) 	             * 98: PBATable  00000404  ( BIR:4  Offset:0x400 ) 	             */
name|u64
modifier|*
name|msix_vetor_table
init|=
operator|(
name|u64
operator|*
operator|)
name|hldev
operator|->
name|bar2
decl_stmt|;
comment|/* 2 64bit words for each entry */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XGE_HAL_MAX_MSIX_MESSAGES
operator|*
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh2
argument_list|,
name|hldev
operator|->
name|msix_vector_table
index|[
name|i
index|]
argument_list|,
operator|&
name|msix_vetor_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|hldev
operator|->
name|link_state
operator|=
name|XGE_HAL_LINK_DOWN
expr_stmt|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|sw_reset
argument_list|)
expr_stmt|;
if|if
condition|(
name|val64
operator|!=
name|rawval
condition|)
block|{
name|xge_debug_device
argument_list|(
name|XGE_ERR
argument_list|,
literal|"device has not been reset "
literal|"got 0x"
name|XGE_OS_LLXFMT
literal|", expected 0x"
name|XGE_OS_LLXFMT
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|val64
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|rawval
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_ERR_RESET_FAILED
return|;
block|}
name|hldev
operator|->
name|hw_is_initialized
operator|=
literal|0
expr_stmt|;
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/*  * __hal_device_poll - General private routine to poll the device.  * @hldev: HAL device handle.  *  * Returns: one of the xge_hal_status_e{} enumerated types.  * XGE_HAL_OK           - for success.  * XGE_HAL_ERR_CRITICAL         - when encounters critical error.  */
end_comment

begin_function
specifier|static
name|xge_hal_status_e
name|__hal_device_poll
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
decl_stmt|;
name|u64
name|err_reg
decl_stmt|;
name|bar0
operator|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
expr_stmt|;
comment|/* Handling SERR errors by forcing a H/W reset. */
name|err_reg
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|serr_source
argument_list|)
expr_stmt|;
if|if
condition|(
name|err_reg
operator|&
name|XGE_HAL_SERR_SOURCE_ANY
condition|)
block|{
name|__hal_device_handle_serr
argument_list|(
name|hldev
argument_list|,
literal|"serr_source"
argument_list|,
name|err_reg
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_ERR_CRITICAL
return|;
block|}
name|err_reg
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|misc_int_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|err_reg
operator|&
name|XGE_HAL_MISC_INT_REG_DP_ERR_INT
condition|)
block|{
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_err_stats
operator|.
name|parity_err_cnt
operator|++
expr_stmt|;
name|__hal_device_handle_parityerr
argument_list|(
name|hldev
argument_list|,
literal|"misc_int_reg"
argument_list|,
name|err_reg
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_ERR_CRITICAL
return|;
block|}
ifdef|#
directive|ifdef
name|XGE_HAL_PROCESS_LINK_INT_IN_ISR
if|if
condition|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_XENA
condition|)
endif|#
directive|endif
block|{
comment|/* Handling link status change error Intr */
name|err_reg
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|mac_rmac_err_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|__hal_device_handle_link_state_change
argument_list|(
name|hldev
argument_list|)
condition|)
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|err_reg
argument_list|,
operator|&
name|bar0
operator|->
name|mac_rmac_err_reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hldev
operator|->
name|inject_serr
operator|!=
literal|0
condition|)
block|{
name|err_reg
operator|=
name|hldev
operator|->
name|inject_serr
expr_stmt|;
name|hldev
operator|->
name|inject_serr
operator|=
literal|0
expr_stmt|;
name|__hal_device_handle_serr
argument_list|(
name|hldev
argument_list|,
literal|"inject_serr"
argument_list|,
name|err_reg
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_ERR_CRITICAL
return|;
block|}
if|if
condition|(
name|hldev
operator|->
name|inject_ecc
operator|!=
literal|0
condition|)
block|{
name|err_reg
operator|=
name|hldev
operator|->
name|inject_ecc
expr_stmt|;
name|hldev
operator|->
name|inject_ecc
operator|=
literal|0
expr_stmt|;
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_err_stats
operator|.
name|ecc_err_cnt
operator|++
expr_stmt|;
name|__hal_device_handle_eccerr
argument_list|(
name|hldev
argument_list|,
literal|"inject_ecc"
argument_list|,
name|err_reg
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_ERR_CRITICAL
return|;
block|}
if|if
condition|(
name|hldev
operator|->
name|inject_bad_tcode
operator|!=
literal|0
condition|)
block|{
name|u8
name|t_code
init|=
name|hldev
operator|->
name|inject_bad_tcode
decl_stmt|;
name|xge_hal_channel_t
name|channel
decl_stmt|;
name|xge_hal_fifo_txd_t
name|txd
decl_stmt|;
name|xge_hal_ring_rxd_1_t
name|rxd
decl_stmt|;
name|channel
operator|.
name|devh
operator|=
name|hldev
expr_stmt|;
if|if
condition|(
name|hldev
operator|->
name|inject_bad_tcode_for_chan_type
operator|==
name|XGE_HAL_CHANNEL_TYPE_FIFO
condition|)
block|{
name|channel
operator|.
name|type
operator|=
name|XGE_HAL_CHANNEL_TYPE_FIFO
expr_stmt|;
block|}
else|else
block|{
name|channel
operator|.
name|type
operator|=
name|XGE_HAL_CHANNEL_TYPE_RING
expr_stmt|;
block|}
name|hldev
operator|->
name|inject_bad_tcode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|channel
operator|.
name|type
operator|==
name|XGE_HAL_CHANNEL_TYPE_FIFO
condition|)
return|return
name|xge_hal_device_handle_tcode
argument_list|(
operator|&
name|channel
argument_list|,
operator|&
name|txd
argument_list|,
name|t_code
argument_list|)
return|;
else|else
return|return
name|xge_hal_device_handle_tcode
argument_list|(
operator|&
name|channel
argument_list|,
operator|&
name|rxd
argument_list|,
name|t_code
argument_list|)
return|;
block|}
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/*  * __hal_verify_pcc_idle - Verify All Enbled PCC are IDLE or not  * @hldev: HAL device handle.  * @adp_status: Adapter Status value  * Usage: See xge_hal_device_enable{}.  */
end_comment

begin_function
name|xge_hal_status_e
name|__hal_verify_pcc_idle
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|,
name|u64
name|adp_status
parameter_list|)
block|{
if|if
condition|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_XENA
operator|&&
name|hldev
operator|->
name|revision
operator|<
literal|4
condition|)
block|{
comment|/* 	     * For Xena 1,2,3 we enable only 4 PCCs Due to 	     * SXE-008 (Transmit DMA arbitration issue) 	     */
if|if
condition|(
operator|(
name|adp_status
operator|&
name|XGE_HAL_ADAPTER_STATUS_RMAC_PCC_4_IDLE
operator|)
operator|!=
name|XGE_HAL_ADAPTER_STATUS_RMAC_PCC_4_IDLE
condition|)
block|{
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"%s"
argument_list|,
literal|"PCC is not IDLE after adapter enabled!"
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_ERR_DEVICE_IS_NOT_QUIESCENT
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|adp_status
operator|&
name|XGE_HAL_ADAPTER_STATUS_RMAC_PCC_IDLE
operator|)
operator|!=
name|XGE_HAL_ADAPTER_STATUS_RMAC_PCC_IDLE
condition|)
block|{
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"%s"
argument_list|,
literal|"PCC is not IDLE after adapter enabled!"
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_ERR_DEVICE_IS_NOT_QUIESCENT
return|;
block|}
block|}
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|__hal_update_bimodal
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|,
name|int
name|ring_no
parameter_list|)
block|{
name|int
name|tval
decl_stmt|,
name|d
decl_stmt|,
name|iwl_avg
decl_stmt|,
name|len_avg
decl_stmt|,
name|bytes_avg
decl_stmt|,
name|bytes_hist
decl_stmt|,
name|d_hist
decl_stmt|;
name|int
name|iwl_rxcnt
decl_stmt|,
name|iwl_txcnt
decl_stmt|,
name|iwl_txavg
decl_stmt|,
name|len_rxavg
decl_stmt|,
name|iwl_rxavg
decl_stmt|,
name|len_txavg
decl_stmt|;
name|int
name|iwl_cnt
decl_stmt|,
name|i
decl_stmt|;
define|#
directive|define
name|_HIST_SIZE
value|50
comment|/* 0.5 sec history */
define|#
directive|define
name|_HIST_ADJ_TIMER
value|1
define|#
directive|define
name|_STEP
value|2
specifier|static
name|int
name|bytes_avg_history
index|[
name|_HIST_SIZE
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
specifier|static
name|int
name|d_avg_history
index|[
name|_HIST_SIZE
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
specifier|static
name|int
name|history_idx
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|pstep
init|=
literal|1
decl_stmt|;
specifier|static
name|int
name|hist_adj_timer
init|=
literal|0
decl_stmt|;
comment|/* 	 * tval - current value of this bimodal timer 	 */
name|tval
operator|=
name|hldev
operator|->
name|bimodal_tti
index|[
name|ring_no
index|]
operator|.
name|timer_val_us
expr_stmt|;
comment|/* 	 * d - how many interrupts we were getting since last 	 *     bimodal timer tick. 	 */
name|d
operator|=
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_info_stats
operator|.
name|tx_traffic_intr_cnt
operator|-
name|hldev
operator|->
name|bimodal_intr_cnt
expr_stmt|;
comment|/* advance bimodal interrupt counter */
name|hldev
operator|->
name|bimodal_intr_cnt
operator|=
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_info_stats
operator|.
name|tx_traffic_intr_cnt
expr_stmt|;
comment|/* 	 * iwl_cnt - how many interrupts we've got since last 	 *           bimodal timer tick. 	 */
name|iwl_rxcnt
operator|=
operator|(
name|hldev
operator|->
name|irq_workload_rxcnt
index|[
name|ring_no
index|]
condition|?
name|hldev
operator|->
name|irq_workload_rxcnt
index|[
name|ring_no
index|]
else|:
literal|1
operator|)
expr_stmt|;
name|iwl_txcnt
operator|=
operator|(
name|hldev
operator|->
name|irq_workload_txcnt
index|[
name|ring_no
index|]
condition|?
name|hldev
operator|->
name|irq_workload_txcnt
index|[
name|ring_no
index|]
else|:
literal|1
operator|)
expr_stmt|;
name|iwl_cnt
operator|=
name|iwl_rxcnt
operator|+
name|iwl_txcnt
expr_stmt|;
name|iwl_cnt
operator|=
name|iwl_cnt
expr_stmt|;
comment|/* just to remove the lint warning */
comment|/* 	 * we need to take hldev->config.isr_polling_cnt into account 	 * but for some reason this line causing GCC to produce wrong 	 * code on Solaris. As of now, if bimodal_interrupts is configured 	 * hldev->config.isr_polling_cnt is forced to be "0". 	 * 	 * iwl_cnt = iwl_cnt / (hldev->config.isr_polling_cnt + 1); */
comment|/* 	 * iwl_avg - how many RXDs on avarage been processed since 	 *           last bimodal timer tick. This indirectly includes 	 *           CPU utilizations. 	 */
name|iwl_rxavg
operator|=
name|hldev
operator|->
name|irq_workload_rxd
index|[
name|ring_no
index|]
operator|/
name|iwl_rxcnt
expr_stmt|;
name|iwl_txavg
operator|=
name|hldev
operator|->
name|irq_workload_txd
index|[
name|ring_no
index|]
operator|/
name|iwl_txcnt
expr_stmt|;
name|iwl_avg
operator|=
name|iwl_rxavg
operator|+
name|iwl_txavg
expr_stmt|;
name|iwl_avg
operator|=
name|iwl_avg
operator|==
literal|0
condition|?
literal|1
else|:
name|iwl_avg
expr_stmt|;
comment|/* 	 * len_avg - how many bytes on avarage been processed since 	 *           last bimodal timer tick. i.e. avarage frame size. 	 */
name|len_rxavg
operator|=
literal|1
operator|+
name|hldev
operator|->
name|irq_workload_rxlen
index|[
name|ring_no
index|]
operator|/
operator|(
name|hldev
operator|->
name|irq_workload_rxd
index|[
name|ring_no
index|]
condition|?
name|hldev
operator|->
name|irq_workload_rxd
index|[
name|ring_no
index|]
else|:
literal|1
operator|)
expr_stmt|;
name|len_txavg
operator|=
literal|1
operator|+
name|hldev
operator|->
name|irq_workload_txlen
index|[
name|ring_no
index|]
operator|/
operator|(
name|hldev
operator|->
name|irq_workload_txd
index|[
name|ring_no
index|]
condition|?
name|hldev
operator|->
name|irq_workload_txd
index|[
name|ring_no
index|]
else|:
literal|1
operator|)
expr_stmt|;
name|len_avg
operator|=
name|len_rxavg
operator|+
name|len_txavg
expr_stmt|;
if|if
condition|(
name|len_avg
operator|<
literal|60
condition|)
name|len_avg
operator|=
literal|60
expr_stmt|;
comment|/* align on low boundary */
if|if
condition|(
operator|(
name|tval
operator|-
name|_STEP
operator|)
operator|<
name|hldev
operator|->
name|config
operator|.
name|bimodal_timer_lo_us
condition|)
name|tval
operator|=
name|hldev
operator|->
name|config
operator|.
name|bimodal_timer_lo_us
expr_stmt|;
comment|/* reset faster */
if|if
condition|(
name|iwl_avg
operator|==
literal|1
condition|)
block|{
name|tval
operator|=
name|hldev
operator|->
name|config
operator|.
name|bimodal_timer_lo_us
expr_stmt|;
comment|/* reset history */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|_HIST_SIZE
condition|;
name|i
operator|++
control|)
name|bytes_avg_history
index|[
name|i
index|]
operator|=
name|d_avg_history
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|history_idx
operator|=
literal|0
expr_stmt|;
name|pstep
operator|=
literal|1
expr_stmt|;
name|hist_adj_timer
operator|=
literal|0
expr_stmt|;
block|}
comment|/* always try to ajust timer to the best throughput value */
name|bytes_avg
operator|=
name|iwl_avg
operator|*
name|len_avg
expr_stmt|;
name|history_idx
operator|%=
name|_HIST_SIZE
expr_stmt|;
name|bytes_avg_history
index|[
name|history_idx
index|]
operator|=
name|bytes_avg
expr_stmt|;
name|d_avg_history
index|[
name|history_idx
index|]
operator|=
name|d
expr_stmt|;
name|history_idx
operator|++
expr_stmt|;
name|d_hist
operator|=
name|bytes_hist
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|_HIST_SIZE
condition|;
name|i
operator|++
control|)
block|{
comment|/* do not re-configure until history is gathered */
if|if
condition|(
operator|!
name|bytes_avg_history
index|[
name|i
index|]
condition|)
block|{
name|tval
operator|=
name|hldev
operator|->
name|config
operator|.
name|bimodal_timer_lo_us
expr_stmt|;
goto|goto
name|_end
goto|;
block|}
name|bytes_hist
operator|+=
name|bytes_avg_history
index|[
name|i
index|]
expr_stmt|;
name|d_hist
operator|+=
name|d_avg_history
index|[
name|i
index|]
expr_stmt|;
block|}
name|bytes_hist
operator|/=
name|_HIST_SIZE
expr_stmt|;
name|d_hist
operator|/=
name|_HIST_SIZE
expr_stmt|;
comment|//  xge_os_printf("d %d iwl_avg %d len_avg %d:%d:%d tval %d avg %d hist %d pstep %d",
comment|//            d, iwl_avg, len_txavg, len_rxavg, len_avg, tval, d*bytes_avg,
comment|//            d_hist*bytes_hist, pstep);
comment|/* make an adaptive step */
if|if
condition|(
name|d
operator|*
name|bytes_avg
operator|<
name|d_hist
operator|*
name|bytes_hist
operator|&&
name|hist_adj_timer
operator|++
operator|>
name|_HIST_ADJ_TIMER
condition|)
block|{
name|pstep
operator|=
operator|!
name|pstep
expr_stmt|;
name|hist_adj_timer
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pstep
operator|&&
operator|(
name|tval
operator|+
name|_STEP
operator|)
operator|<=
name|hldev
operator|->
name|config
operator|.
name|bimodal_timer_hi_us
condition|)
block|{
name|tval
operator|+=
name|_STEP
expr_stmt|;
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_info_stats
operator|.
name|bimodal_hi_adjust_cnt
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tval
operator|-
name|_STEP
operator|)
operator|>=
name|hldev
operator|->
name|config
operator|.
name|bimodal_timer_lo_us
condition|)
block|{
name|tval
operator|-=
name|_STEP
expr_stmt|;
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_info_stats
operator|.
name|bimodal_lo_adjust_cnt
operator|++
expr_stmt|;
block|}
comment|/* enable TTI range A for better latencies */
name|hldev
operator|->
name|bimodal_urange_a_en
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tval
operator|<=
name|hldev
operator|->
name|config
operator|.
name|bimodal_timer_lo_us
operator|&&
name|iwl_avg
operator|>
literal|2
condition|)
name|hldev
operator|->
name|bimodal_urange_a_en
operator|=
literal|1
expr_stmt|;
name|_end
label|:
comment|/* reset workload statistics counters */
name|hldev
operator|->
name|irq_workload_rxcnt
index|[
name|ring_no
index|]
operator|=
literal|0
expr_stmt|;
name|hldev
operator|->
name|irq_workload_rxd
index|[
name|ring_no
index|]
operator|=
literal|0
expr_stmt|;
name|hldev
operator|->
name|irq_workload_rxlen
index|[
name|ring_no
index|]
operator|=
literal|0
expr_stmt|;
name|hldev
operator|->
name|irq_workload_txcnt
index|[
name|ring_no
index|]
operator|=
literal|0
expr_stmt|;
name|hldev
operator|->
name|irq_workload_txd
index|[
name|ring_no
index|]
operator|=
literal|0
expr_stmt|;
name|hldev
operator|->
name|irq_workload_txlen
index|[
name|ring_no
index|]
operator|=
literal|0
expr_stmt|;
comment|/* reconfigure TTI56 + ring_no with new timer value */
name|hldev
operator|->
name|bimodal_timer_val_us
operator|=
name|tval
expr_stmt|;
operator|(
name|void
operator|)
name|__hal_device_rti_configure
argument_list|(
name|hldev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__hal_update_rxufca
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|,
name|int
name|ring_no
parameter_list|)
block|{
name|int
name|ufc
decl_stmt|,
name|ic
decl_stmt|,
name|i
decl_stmt|;
name|ufc
operator|=
name|hldev
operator|->
name|config
operator|.
name|ring
operator|.
name|queue
index|[
name|ring_no
index|]
operator|.
name|rti
operator|.
name|ufc_a
expr_stmt|;
name|ic
operator|=
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_info_stats
operator|.
name|rx_traffic_intr_cnt
expr_stmt|;
comment|/* urange_a adaptive coalescing */
if|if
condition|(
name|hldev
operator|->
name|rxufca_lbolt
operator|>
name|hldev
operator|->
name|rxufca_lbolt_time
condition|)
block|{
if|if
condition|(
name|ic
operator|>
name|hldev
operator|->
name|rxufca_intr_thres
condition|)
block|{
if|if
condition|(
name|ufc
operator|<
name|hldev
operator|->
name|config
operator|.
name|rxufca_hi_lim
condition|)
block|{
name|ufc
operator|+=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XGE_HAL_MAX_RING_NUM
condition|;
name|i
operator|++
control|)
name|hldev
operator|->
name|config
operator|.
name|ring
operator|.
name|queue
index|[
name|i
index|]
operator|.
name|rti
operator|.
name|ufc_a
operator|=
name|ufc
expr_stmt|;
operator|(
name|void
operator|)
name|__hal_device_rti_configure
argument_list|(
name|hldev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_info_stats
operator|.
name|rxufca_hi_adjust_cnt
operator|++
expr_stmt|;
block|}
name|hldev
operator|->
name|rxufca_intr_thres
operator|=
name|ic
operator|+
name|hldev
operator|->
name|config
operator|.
name|rxufca_intr_thres
expr_stmt|;
comment|/* def: 30 */
block|}
else|else
block|{
if|if
condition|(
name|ufc
operator|>
name|hldev
operator|->
name|config
operator|.
name|rxufca_lo_lim
condition|)
block|{
name|ufc
operator|-=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XGE_HAL_MAX_RING_NUM
condition|;
name|i
operator|++
control|)
name|hldev
operator|->
name|config
operator|.
name|ring
operator|.
name|queue
index|[
name|i
index|]
operator|.
name|rti
operator|.
name|ufc_a
operator|=
name|ufc
expr_stmt|;
operator|(
name|void
operator|)
name|__hal_device_rti_configure
argument_list|(
name|hldev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_info_stats
operator|.
name|rxufca_lo_adjust_cnt
operator|++
expr_stmt|;
block|}
block|}
name|hldev
operator|->
name|rxufca_lbolt_time
operator|=
name|hldev
operator|->
name|rxufca_lbolt
operator|+
name|hldev
operator|->
name|config
operator|.
name|rxufca_lbolt_period
expr_stmt|;
block|}
name|hldev
operator|->
name|rxufca_lbolt
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * __hal_device_handle_mc - Handle MC interrupt reason  * @hldev: HAL device handle.  * @reason: interrupt reason  */
end_comment

begin_function
name|xge_hal_status_e
name|__hal_device_handle_mc
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|,
name|u64
name|reason
parameter_list|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|isrbar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|isrbar0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|isrbar0
operator|->
name|mc_int_status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val64
operator|&
name|XGE_HAL_MC_INT_STATUS_MC_INT
operator|)
condition|)
return|return
name|XGE_HAL_OK
return|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|isrbar0
operator|->
name|mc_err_reg
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|isrbar0
operator|->
name|mc_err_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val64
operator|&
name|XGE_HAL_MC_ERR_REG_ETQ_ECC_SG_ERR_L
operator|||
name|val64
operator|&
name|XGE_HAL_MC_ERR_REG_ETQ_ECC_SG_ERR_U
operator|||
name|val64
operator|&
name|XGE_HAL_MC_ERR_REG_MIRI_ECC_SG_ERR_0
operator|||
name|val64
operator|&
name|XGE_HAL_MC_ERR_REG_MIRI_ECC_SG_ERR_1
operator|||
operator|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|!=
name|XGE_HAL_CARD_XENA
operator|&&
operator|(
name|val64
operator|&
name|XGE_HAL_MC_ERR_REG_ITQ_ECC_SG_ERR_L
operator|||
name|val64
operator|&
name|XGE_HAL_MC_ERR_REG_ITQ_ECC_SG_ERR_U
operator|||
name|val64
operator|&
name|XGE_HAL_MC_ERR_REG_RLD_ECC_SG_ERR_L
operator|||
name|val64
operator|&
name|XGE_HAL_MC_ERR_REG_RLD_ECC_SG_ERR_U
operator|)
operator|)
condition|)
block|{
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_err_stats
operator|.
name|single_ecc_err_cnt
operator|++
expr_stmt|;
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_err_stats
operator|.
name|ecc_err_cnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|val64
operator|&
name|XGE_HAL_MC_ERR_REG_ETQ_ECC_DB_ERR_L
operator|||
name|val64
operator|&
name|XGE_HAL_MC_ERR_REG_ETQ_ECC_DB_ERR_U
operator|||
name|val64
operator|&
name|XGE_HAL_MC_ERR_REG_MIRI_ECC_DB_ERR_0
operator|||
name|val64
operator|&
name|XGE_HAL_MC_ERR_REG_MIRI_ECC_DB_ERR_1
operator|||
operator|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|!=
name|XGE_HAL_CARD_XENA
operator|&&
operator|(
name|val64
operator|&
name|XGE_HAL_MC_ERR_REG_ITQ_ECC_DB_ERR_L
operator|||
name|val64
operator|&
name|XGE_HAL_MC_ERR_REG_ITQ_ECC_DB_ERR_U
operator|||
name|val64
operator|&
name|XGE_HAL_MC_ERR_REG_RLD_ECC_DB_ERR_L
operator|||
name|val64
operator|&
name|XGE_HAL_MC_ERR_REG_RLD_ECC_DB_ERR_U
operator|)
operator|)
condition|)
block|{
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_err_stats
operator|.
name|double_ecc_err_cnt
operator|++
expr_stmt|;
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_err_stats
operator|.
name|ecc_err_cnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|val64
operator|&
name|XGE_HAL_MC_ERR_REG_SM_ERR
condition|)
block|{
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_err_stats
operator|.
name|sm_err_cnt
operator|++
expr_stmt|;
block|}
comment|/* those two should result in device reset */
if|if
condition|(
name|val64
operator|&
name|XGE_HAL_MC_ERR_REG_MIRI_ECC_DB_ERR_0
operator|||
name|val64
operator|&
name|XGE_HAL_MC_ERR_REG_MIRI_ECC_DB_ERR_1
condition|)
block|{
name|__hal_device_handle_eccerr
argument_list|(
name|hldev
argument_list|,
literal|"mc_err_reg"
argument_list|,
name|val64
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_ERR_CRITICAL
return|;
block|}
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/*  * __hal_device_handle_pic - Handle non-traffic PIC interrupt reason  * @hldev: HAL device handle.  * @reason: interrupt reason  */
end_comment

begin_function
name|xge_hal_status_e
name|__hal_device_handle_pic
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|,
name|u64
name|reason
parameter_list|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|isrbar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|isrbar0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
if|if
condition|(
name|reason
operator|&
name|XGE_HAL_PIC_INT_FLSH
condition|)
block|{
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|isrbar0
operator|->
name|flsh_int_reg
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|isrbar0
operator|->
name|flsh_int_reg
argument_list|)
expr_stmt|;
comment|/* FIXME: handle register */
block|}
if|if
condition|(
name|reason
operator|&
name|XGE_HAL_PIC_INT_MDIO
condition|)
block|{
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|isrbar0
operator|->
name|mdio_int_reg
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|isrbar0
operator|->
name|mdio_int_reg
argument_list|)
expr_stmt|;
comment|/* FIXME: handle register */
block|}
if|if
condition|(
name|reason
operator|&
name|XGE_HAL_PIC_INT_IIC
condition|)
block|{
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|isrbar0
operator|->
name|iic_int_reg
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|isrbar0
operator|->
name|iic_int_reg
argument_list|)
expr_stmt|;
comment|/* FIXME: handle register */
block|}
if|if
condition|(
name|reason
operator|&
name|XGE_HAL_PIC_INT_MISC
condition|)
block|{
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|isrbar0
operator|->
name|misc_int_reg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XGE_HAL_PROCESS_LINK_INT_IN_ISR
if|if
condition|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_HERC
condition|)
block|{
comment|/*  Check for Link interrupts. If both Link Up/Down 	         *  bits are set, clear both and check adapter status 	         */
if|if
condition|(
operator|(
name|val64
operator|&
name|XGE_HAL_MISC_INT_REG_LINK_UP_INT
operator|)
operator|&&
operator|(
name|val64
operator|&
name|XGE_HAL_MISC_INT_REG_LINK_DOWN_INT
operator|)
condition|)
block|{
name|u64
name|temp64
decl_stmt|;
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"both link up and link down detected "
name|XGE_OS_LLXFMT
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|val64
argument_list|)
expr_stmt|;
name|temp64
operator|=
operator|(
name|XGE_HAL_MISC_INT_REG_LINK_DOWN_INT
operator||
name|XGE_HAL_MISC_INT_REG_LINK_UP_INT
operator|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|temp64
argument_list|,
operator|&
name|isrbar0
operator|->
name|misc_int_reg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val64
operator|&
name|XGE_HAL_MISC_INT_REG_LINK_UP_INT
condition|)
block|{
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"link up call request, misc_int "
name|XGE_OS_LLXFMT
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|val64
argument_list|)
expr_stmt|;
name|__hal_device_handle_link_up_ind
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val64
operator|&
name|XGE_HAL_MISC_INT_REG_LINK_DOWN_INT
condition|)
block|{
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"link down request, misc_int "
name|XGE_OS_LLXFMT
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|val64
argument_list|)
expr_stmt|;
name|__hal_device_handle_link_down_ind
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|isrbar0
operator|->
name|misc_int_reg
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/*  * __hal_device_handle_txpic - Handle TxPIC interrupt reason  * @hldev: HAL device handle.  * @reason: interrupt reason  */
end_comment

begin_function
name|xge_hal_status_e
name|__hal_device_handle_txpic
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|,
name|u64
name|reason
parameter_list|)
block|{
name|xge_hal_status_e
name|status
init|=
name|XGE_HAL_OK
decl_stmt|;
name|xge_hal_pci_bar0_t
modifier|*
name|isrbar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|isrbar0
decl_stmt|;
specifier|volatile
name|u64
name|val64
decl_stmt|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|isrbar0
operator|->
name|pic_int_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|val64
operator|&
operator|(
name|XGE_HAL_PIC_INT_FLSH
operator||
name|XGE_HAL_PIC_INT_MDIO
operator||
name|XGE_HAL_PIC_INT_IIC
operator||
name|XGE_HAL_PIC_INT_MISC
operator|)
condition|)
block|{
name|status
operator|=
name|__hal_device_handle_pic
argument_list|(
name|hldev
argument_list|,
name|val64
argument_list|)
expr_stmt|;
name|xge_os_wmb
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|val64
operator|&
name|XGE_HAL_PIC_INT_TX
operator|)
condition|)
return|return
name|status
return|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|isrbar0
operator|->
name|txpic_int_reg
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|isrbar0
operator|->
name|txpic_int_reg
argument_list|)
expr_stmt|;
name|xge_os_wmb
argument_list|()
expr_stmt|;
if|if
condition|(
name|val64
operator|&
name|XGE_HAL_TXPIC_INT_SCHED_INTR
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|g_xge_hal_driver
operator|->
name|uld_callbacks
operator|.
name|sched_timer
operator|!=
name|NULL
condition|)
name|g_xge_hal_driver
operator|->
name|uld_callbacks
operator|.
name|sched_timer
argument_list|(
name|hldev
argument_list|,
name|hldev
operator|->
name|upper_layer_info
argument_list|)
expr_stmt|;
comment|/* 	     * This feature implements adaptive receive interrupt 	     * coalecing. It is disabled by default. To enable it 	     * set hldev->config.rxufca_lo_lim to be not equal to 	     * hldev->config.rxufca_hi_lim. 	     * 	     * We are using HW timer for this feature, so 	     * use needs to configure hldev->config.rxufca_lbolt_period 	     * which is essentially a time slice of timer. 	     * 	     * For those who familiar with Linux, lbolt means jiffies 	     * of this timer. I.e. timer tick. 	     */
if|if
condition|(
name|hldev
operator|->
name|config
operator|.
name|rxufca_lo_lim
operator|!=
name|hldev
operator|->
name|config
operator|.
name|rxufca_hi_lim
operator|&&
name|hldev
operator|->
name|config
operator|.
name|rxufca_lo_lim
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XGE_HAL_MAX_RING_NUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|hldev
operator|->
name|config
operator|.
name|ring
operator|.
name|queue
index|[
name|i
index|]
operator|.
name|configured
condition|)
continue|continue;
if|if
condition|(
name|hldev
operator|->
name|config
operator|.
name|ring
operator|.
name|queue
index|[
name|i
index|]
operator|.
name|rti
operator|.
name|urange_a
condition|)
name|__hal_update_rxufca
argument_list|(
name|hldev
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	     * This feature implements adaptive TTI timer re-calculation 	     * based on host utilization, number of interrupt processed, 	     * number of RXD per tick and avarage length of packets per 	     * tick. 	     */
if|if
condition|(
name|hldev
operator|->
name|config
operator|.
name|bimodal_interrupts
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XGE_HAL_MAX_RING_NUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|hldev
operator|->
name|config
operator|.
name|ring
operator|.
name|queue
index|[
name|i
index|]
operator|.
name|configured
condition|)
continue|continue;
if|if
condition|(
name|hldev
operator|->
name|bimodal_tti
index|[
name|i
index|]
operator|.
name|enabled
condition|)
name|__hal_update_bimodal
argument_list|(
name|hldev
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/*  * __hal_device_handle_txdma - Handle TxDMA interrupt reason  * @hldev: HAL device handle.  * @reason: interrupt reason  */
end_comment

begin_function
name|xge_hal_status_e
name|__hal_device_handle_txdma
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|,
name|u64
name|reason
parameter_list|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|isrbar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|isrbar0
decl_stmt|;
name|u64
name|val64
decl_stmt|,
name|temp64
decl_stmt|,
name|err
decl_stmt|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|isrbar0
operator|->
name|txdma_int_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|val64
operator|&
name|XGE_HAL_TXDMA_PFC_INT
condition|)
block|{
name|err
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|isrbar0
operator|->
name|pfc_err_reg
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|err
argument_list|,
operator|&
name|isrbar0
operator|->
name|pfc_err_reg
argument_list|)
expr_stmt|;
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_info_stats
operator|.
name|pfc_err_cnt
operator|++
expr_stmt|;
name|temp64
operator|=
name|XGE_HAL_PFC_ECC_DB_ERR
operator||
name|XGE_HAL_PFC_SM_ERR_ALARM
operator||
name|XGE_HAL_PFC_MISC_0_ERR
operator||
name|XGE_HAL_PFC_MISC_1_ERR
operator||
name|XGE_HAL_PFC_PCIX_ERR
expr_stmt|;
if|if
condition|(
name|val64
operator|&
name|temp64
condition|)
goto|goto
name|reset
goto|;
block|}
if|if
condition|(
name|val64
operator|&
name|XGE_HAL_TXDMA_TDA_INT
condition|)
block|{
name|err
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|isrbar0
operator|->
name|tda_err_reg
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|err
argument_list|,
operator|&
name|isrbar0
operator|->
name|tda_err_reg
argument_list|)
expr_stmt|;
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_info_stats
operator|.
name|tda_err_cnt
operator|++
expr_stmt|;
name|temp64
operator|=
name|XGE_HAL_TDA_Fn_ECC_DB_ERR
operator||
name|XGE_HAL_TDA_SM0_ERR_ALARM
operator||
name|XGE_HAL_TDA_SM1_ERR_ALARM
expr_stmt|;
if|if
condition|(
name|val64
operator|&
name|temp64
condition|)
goto|goto
name|reset
goto|;
block|}
if|if
condition|(
name|val64
operator|&
name|XGE_HAL_TXDMA_PCC_INT
condition|)
block|{
name|err
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|isrbar0
operator|->
name|pcc_err_reg
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|err
argument_list|,
operator|&
name|isrbar0
operator|->
name|pcc_err_reg
argument_list|)
expr_stmt|;
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_info_stats
operator|.
name|pcc_err_cnt
operator|++
expr_stmt|;
name|temp64
operator|=
name|XGE_HAL_PCC_FB_ECC_DB_ERR
operator||
name|XGE_HAL_PCC_TXB_ECC_DB_ERR
operator||
name|XGE_HAL_PCC_SM_ERR_ALARM
operator||
name|XGE_HAL_PCC_WR_ERR_ALARM
operator||
name|XGE_HAL_PCC_N_SERR
operator||
name|XGE_HAL_PCC_6_COF_OV_ERR
operator||
name|XGE_HAL_PCC_7_COF_OV_ERR
operator||
name|XGE_HAL_PCC_6_LSO_OV_ERR
operator||
name|XGE_HAL_PCC_7_LSO_OV_ERR
expr_stmt|;
if|if
condition|(
name|val64
operator|&
name|temp64
condition|)
goto|goto
name|reset
goto|;
block|}
if|if
condition|(
name|val64
operator|&
name|XGE_HAL_TXDMA_TTI_INT
condition|)
block|{
name|err
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|isrbar0
operator|->
name|tti_err_reg
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|err
argument_list|,
operator|&
name|isrbar0
operator|->
name|tti_err_reg
argument_list|)
expr_stmt|;
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_info_stats
operator|.
name|tti_err_cnt
operator|++
expr_stmt|;
name|temp64
operator|=
name|XGE_HAL_TTI_SM_ERR_ALARM
expr_stmt|;
if|if
condition|(
name|val64
operator|&
name|temp64
condition|)
goto|goto
name|reset
goto|;
block|}
if|if
condition|(
name|val64
operator|&
name|XGE_HAL_TXDMA_LSO_INT
condition|)
block|{
name|err
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|isrbar0
operator|->
name|lso_err_reg
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|err
argument_list|,
operator|&
name|isrbar0
operator|->
name|lso_err_reg
argument_list|)
expr_stmt|;
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_info_stats
operator|.
name|lso_err_cnt
operator|++
expr_stmt|;
name|temp64
operator|=
name|XGE_HAL_LSO6_ABORT
operator||
name|XGE_HAL_LSO7_ABORT
operator||
name|XGE_HAL_LSO6_SM_ERR_ALARM
operator||
name|XGE_HAL_LSO7_SM_ERR_ALARM
expr_stmt|;
if|if
condition|(
name|val64
operator|&
name|temp64
condition|)
goto|goto
name|reset
goto|;
block|}
if|if
condition|(
name|val64
operator|&
name|XGE_HAL_TXDMA_TPA_INT
condition|)
block|{
name|err
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|isrbar0
operator|->
name|tpa_err_reg
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|err
argument_list|,
operator|&
name|isrbar0
operator|->
name|tpa_err_reg
argument_list|)
expr_stmt|;
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_info_stats
operator|.
name|tpa_err_cnt
operator|++
expr_stmt|;
name|temp64
operator|=
name|XGE_HAL_TPA_SM_ERR_ALARM
expr_stmt|;
if|if
condition|(
name|val64
operator|&
name|temp64
condition|)
goto|goto
name|reset
goto|;
block|}
if|if
condition|(
name|val64
operator|&
name|XGE_HAL_TXDMA_SM_INT
condition|)
block|{
name|err
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|isrbar0
operator|->
name|sm_err_reg
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|err
argument_list|,
operator|&
name|isrbar0
operator|->
name|sm_err_reg
argument_list|)
expr_stmt|;
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_info_stats
operator|.
name|sm_err_cnt
operator|++
expr_stmt|;
name|temp64
operator|=
name|XGE_HAL_SM_SM_ERR_ALARM
expr_stmt|;
if|if
condition|(
name|val64
operator|&
name|temp64
condition|)
goto|goto
name|reset
goto|;
block|}
return|return
name|XGE_HAL_OK
return|;
name|reset
label|:
name|xge_hal_device_reset
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
name|xge_hal_device_enable
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
name|xge_hal_device_intr_enable
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/*  * __hal_device_handle_txmac - Handle TxMAC interrupt reason  * @hldev: HAL device handle.  * @reason: interrupt reason  */
end_comment

begin_function
name|xge_hal_status_e
name|__hal_device_handle_txmac
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|,
name|u64
name|reason
parameter_list|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|isrbar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|isrbar0
decl_stmt|;
name|u64
name|val64
decl_stmt|,
name|temp64
decl_stmt|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|isrbar0
operator|->
name|mac_int_status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val64
operator|&
name|XGE_HAL_MAC_INT_STATUS_TMAC_INT
operator|)
condition|)
return|return
name|XGE_HAL_OK
return|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|isrbar0
operator|->
name|mac_tmac_err_reg
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|isrbar0
operator|->
name|mac_tmac_err_reg
argument_list|)
expr_stmt|;
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_info_stats
operator|.
name|mac_tmac_err_cnt
operator|++
expr_stmt|;
name|temp64
operator|=
name|XGE_HAL_TMAC_TX_BUF_OVRN
operator||
name|XGE_HAL_TMAC_TX_SM_ERR
expr_stmt|;
if|if
condition|(
name|val64
operator|&
name|temp64
condition|)
block|{
name|xge_hal_device_reset
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
name|xge_hal_device_enable
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
name|xge_hal_device_intr_enable
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
block|}
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/*  * __hal_device_handle_txxgxs - Handle TxXGXS interrupt reason  * @hldev: HAL device handle.  * @reason: interrupt reason  */
end_comment

begin_function
name|xge_hal_status_e
name|__hal_device_handle_txxgxs
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|,
name|u64
name|reason
parameter_list|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|isrbar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|isrbar0
decl_stmt|;
name|u64
name|val64
decl_stmt|,
name|temp64
decl_stmt|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|isrbar0
operator|->
name|xgxs_int_status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val64
operator|&
name|XGE_HAL_XGXS_INT_STATUS_TXGXS
operator|)
condition|)
return|return
name|XGE_HAL_OK
return|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|isrbar0
operator|->
name|xgxs_txgxs_err_reg
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|isrbar0
operator|->
name|xgxs_txgxs_err_reg
argument_list|)
expr_stmt|;
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_info_stats
operator|.
name|xgxs_txgxs_err_cnt
operator|++
expr_stmt|;
name|temp64
operator|=
name|XGE_HAL_TXGXS_ESTORE_UFLOW
operator||
name|XGE_HAL_TXGXS_TX_SM_ERR
expr_stmt|;
if|if
condition|(
name|val64
operator|&
name|temp64
condition|)
block|{
name|xge_hal_device_reset
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
name|xge_hal_device_enable
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
name|xge_hal_device_intr_enable
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
block|}
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/*  * __hal_device_handle_rxpic - Handle RxPIC interrupt reason  * @hldev: HAL device handle.  * @reason: interrupt reason  */
end_comment

begin_function
name|xge_hal_status_e
name|__hal_device_handle_rxpic
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|,
name|u64
name|reason
parameter_list|)
block|{
comment|/* FIXME: handle register */
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/*  * __hal_device_handle_rxdma - Handle RxDMA interrupt reason  * @hldev: HAL device handle.  * @reason: interrupt reason  */
end_comment

begin_function
name|xge_hal_status_e
name|__hal_device_handle_rxdma
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|,
name|u64
name|reason
parameter_list|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|isrbar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|isrbar0
decl_stmt|;
name|u64
name|val64
decl_stmt|,
name|err
decl_stmt|,
name|temp64
decl_stmt|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|isrbar0
operator|->
name|rxdma_int_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|val64
operator|&
name|XGE_HAL_RXDMA_RC_INT
condition|)
block|{
name|err
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|isrbar0
operator|->
name|rc_err_reg
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|err
argument_list|,
operator|&
name|isrbar0
operator|->
name|rc_err_reg
argument_list|)
expr_stmt|;
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_info_stats
operator|.
name|rc_err_cnt
operator|++
expr_stmt|;
name|temp64
operator|=
name|XGE_HAL_RC_PRCn_ECC_DB_ERR
operator||
name|XGE_HAL_RC_FTC_ECC_DB_ERR
operator||
name|XGE_HAL_RC_PRCn_SM_ERR_ALARM
operator||
name|XGE_HAL_RC_FTC_SM_ERR_ALARM
expr_stmt|;
if|if
condition|(
name|val64
operator|&
name|temp64
condition|)
goto|goto
name|reset
goto|;
block|}
if|if
condition|(
name|val64
operator|&
name|XGE_HAL_RXDMA_RPA_INT
condition|)
block|{
name|err
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|isrbar0
operator|->
name|rpa_err_reg
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|err
argument_list|,
operator|&
name|isrbar0
operator|->
name|rpa_err_reg
argument_list|)
expr_stmt|;
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_info_stats
operator|.
name|rpa_err_cnt
operator|++
expr_stmt|;
name|temp64
operator|=
name|XGE_HAL_RPA_SM_ERR_ALARM
operator||
name|XGE_HAL_RPA_CREDIT_ERR
expr_stmt|;
if|if
condition|(
name|val64
operator|&
name|temp64
condition|)
goto|goto
name|reset
goto|;
block|}
if|if
condition|(
name|val64
operator|&
name|XGE_HAL_RXDMA_RDA_INT
condition|)
block|{
name|err
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|isrbar0
operator|->
name|rda_err_reg
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|err
argument_list|,
operator|&
name|isrbar0
operator|->
name|rda_err_reg
argument_list|)
expr_stmt|;
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_info_stats
operator|.
name|rda_err_cnt
operator|++
expr_stmt|;
name|temp64
operator|=
name|XGE_HAL_RDA_RXDn_ECC_DB_ERR
operator||
name|XGE_HAL_RDA_FRM_ECC_DB_N_AERR
operator||
name|XGE_HAL_RDA_SM1_ERR_ALARM
operator||
name|XGE_HAL_RDA_SM0_ERR_ALARM
operator||
name|XGE_HAL_RDA_RXD_ECC_DB_SERR
expr_stmt|;
if|if
condition|(
name|val64
operator|&
name|temp64
condition|)
goto|goto
name|reset
goto|;
block|}
if|if
condition|(
name|val64
operator|&
name|XGE_HAL_RXDMA_RTI_INT
condition|)
block|{
name|err
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|isrbar0
operator|->
name|rti_err_reg
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|err
argument_list|,
operator|&
name|isrbar0
operator|->
name|rti_err_reg
argument_list|)
expr_stmt|;
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_info_stats
operator|.
name|rti_err_cnt
operator|++
expr_stmt|;
name|temp64
operator|=
name|XGE_HAL_RTI_SM_ERR_ALARM
expr_stmt|;
if|if
condition|(
name|val64
operator|&
name|temp64
condition|)
goto|goto
name|reset
goto|;
block|}
return|return
name|XGE_HAL_OK
return|;
name|reset
label|:
name|xge_hal_device_reset
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
name|xge_hal_device_enable
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
name|xge_hal_device_intr_enable
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/*  * __hal_device_handle_rxmac - Handle RxMAC interrupt reason  * @hldev: HAL device handle.  * @reason: interrupt reason  */
end_comment

begin_function
name|xge_hal_status_e
name|__hal_device_handle_rxmac
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|,
name|u64
name|reason
parameter_list|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|isrbar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|isrbar0
decl_stmt|;
name|u64
name|val64
decl_stmt|,
name|temp64
decl_stmt|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|isrbar0
operator|->
name|mac_int_status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val64
operator|&
name|XGE_HAL_MAC_INT_STATUS_RMAC_INT
operator|)
condition|)
return|return
name|XGE_HAL_OK
return|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|isrbar0
operator|->
name|mac_rmac_err_reg
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|isrbar0
operator|->
name|mac_rmac_err_reg
argument_list|)
expr_stmt|;
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_info_stats
operator|.
name|mac_rmac_err_cnt
operator|++
expr_stmt|;
name|temp64
operator|=
name|XGE_HAL_RMAC_RX_BUFF_OVRN
operator||
name|XGE_HAL_RMAC_RX_SM_ERR
expr_stmt|;
if|if
condition|(
name|val64
operator|&
name|temp64
condition|)
block|{
name|xge_hal_device_reset
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
name|xge_hal_device_enable
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
name|xge_hal_device_intr_enable
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
block|}
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/*  * __hal_device_handle_rxxgxs - Handle RxXGXS interrupt reason  * @hldev: HAL device handle.  * @reason: interrupt reason  */
end_comment

begin_function
name|xge_hal_status_e
name|__hal_device_handle_rxxgxs
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|,
name|u64
name|reason
parameter_list|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|isrbar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|isrbar0
decl_stmt|;
name|u64
name|val64
decl_stmt|,
name|temp64
decl_stmt|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|isrbar0
operator|->
name|xgxs_int_status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val64
operator|&
name|XGE_HAL_XGXS_INT_STATUS_RXGXS
operator|)
condition|)
return|return
name|XGE_HAL_OK
return|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|isrbar0
operator|->
name|xgxs_rxgxs_err_reg
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|isrbar0
operator|->
name|xgxs_rxgxs_err_reg
argument_list|)
expr_stmt|;
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_info_stats
operator|.
name|xgxs_rxgxs_err_cnt
operator|++
expr_stmt|;
name|temp64
operator|=
name|XGE_HAL_RXGXS_ESTORE_OFLOW
operator||
name|XGE_HAL_RXGXS_RX_SM_ERR
expr_stmt|;
if|if
condition|(
name|val64
operator|&
name|temp64
condition|)
block|{
name|xge_hal_device_reset
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
name|xge_hal_device_enable
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
name|xge_hal_device_intr_enable
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
block|}
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_device_enable - Enable device.  * @hldev: HAL device handle.  *  * Enable the specified device: bring up the link/interface.  * Returns:  XGE_HAL_OK - success.  * XGE_HAL_ERR_DEVICE_IS_NOT_QUIESCENT - Failed to restore the device  * to a "quiescent" state.  *  * See also: xge_hal_status_e{}.  *  * Usage: See ex_open{}.  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_device_enable
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
name|u64
name|adp_status
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|hldev
operator|->
name|hw_is_initialized
condition|)
block|{
name|xge_hal_status_e
name|status
decl_stmt|;
name|status
operator|=
name|__hal_device_hw_initialize
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
block|{
return|return
name|status
return|;
block|}
block|}
comment|/* 	 * Not needed in most cases, i.e. 	 * when device_disable() is followed by reset - 	 * the latter copies back PCI config space, along with 	 * the bus mastership - see __hal_device_reset(). 	 * However, there are/may-in-future be other cases, and 	 * does not hurt. 	 */
name|__hal_device_bus_master_enable
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
if|if
condition|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_HERC
condition|)
block|{
comment|/* 	     * Configure the link stability period. 	     */
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|misc_control
argument_list|)
expr_stmt|;
if|if
condition|(
name|hldev
operator|->
name|config
operator|.
name|link_stability_period
operator|!=
name|XGE_HAL_DEFAULT_USE_HARDCODE
condition|)
block|{
name|val64
operator||=
name|XGE_HAL_MISC_CONTROL_LINK_STABILITY_PERIOD
argument_list|(
name|hldev
operator|->
name|config
operator|.
name|link_stability_period
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	         * Use the link stability period 1 ms as default 	         */
name|val64
operator||=
name|XGE_HAL_MISC_CONTROL_LINK_STABILITY_PERIOD
argument_list|(
name|XGE_HAL_DEFAULT_LINK_STABILITY_PERIOD
argument_list|)
expr_stmt|;
block|}
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|misc_control
argument_list|)
expr_stmt|;
comment|/* 	     * Clearing any possible Link up/down interrupts that 	     * could have popped up just before Enabling the card. 	     */
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|misc_int_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val64
condition|)
block|{
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|misc_int_reg
argument_list|)
expr_stmt|;
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"%s"
argument_list|,
literal|"link state cleared"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_XENA
condition|)
block|{
comment|/* 	     * Clearing any possible Link state change interrupts that 	     * could have popped up just before Enabling the card. 	     */
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|mac_rmac_err_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val64
condition|)
block|{
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|mac_rmac_err_reg
argument_list|)
expr_stmt|;
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"%s"
argument_list|,
literal|"link state cleared"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|__hal_device_wait_quiescent
argument_list|(
name|hldev
argument_list|,
operator|&
name|val64
argument_list|)
condition|)
block|{
return|return
name|XGE_HAL_ERR_DEVICE_IS_NOT_QUIESCENT
return|;
block|}
comment|/* Enabling Laser. */
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_control
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_ADAPTER_EOI_TX_ON
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_control
argument_list|)
expr_stmt|;
comment|/* let link establish */
name|xge_os_mdelay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* set link down untill poll() routine will set it up (maybe) */
name|hldev
operator|->
name|link_state
operator|=
name|XGE_HAL_LINK_DOWN
expr_stmt|;
comment|/* If link is UP (adpter is connected) then enable the adapter */
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|val64
operator|&
operator|(
name|XGE_HAL_ADAPTER_STATUS_RMAC_REMOTE_FAULT
operator||
name|XGE_HAL_ADAPTER_STATUS_RMAC_LOCAL_FAULT
operator|)
condition|)
block|{
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_control
argument_list|)
expr_stmt|;
name|val64
operator|=
name|val64
operator|&
operator|(
operator|~
name|XGE_HAL_ADAPTER_LED_ON
operator|)
expr_stmt|;
block|}
else|else
block|{
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_control
argument_list|)
expr_stmt|;
name|val64
operator|=
name|val64
operator||
operator|(
name|XGE_HAL_ADAPTER_EOI_TX_ON
operator||
name|XGE_HAL_ADAPTER_LED_ON
operator|)
expr_stmt|;
block|}
name|val64
operator|=
name|val64
operator||
name|XGE_HAL_ADAPTER_CNTL_EN
expr_stmt|;
comment|/* adapter enable */
name|val64
operator|=
name|val64
operator|&
operator|(
operator|~
name|XGE_HAL_ADAPTER_ECC_EN
operator|)
expr_stmt|;
comment|/* ECC enable */
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_control
argument_list|)
expr_stmt|;
comment|/* We spin here waiting for the Link to come up. 	 * This is the fix for the Link being unstable after the reset. */
name|i
operator|=
literal|0
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|adp_status
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_status
argument_list|)
expr_stmt|;
comment|/* Read the adapter control register for Adapter_enable bit */
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_control
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|adp_status
operator|&
operator|(
name|XGE_HAL_ADAPTER_STATUS_RMAC_REMOTE_FAULT
operator||
name|XGE_HAL_ADAPTER_STATUS_RMAC_LOCAL_FAULT
operator|)
operator|)
operator|&&
operator|(
name|val64
operator|&
name|XGE_HAL_ADAPTER_CNTL_EN
operator|)
condition|)
block|{
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|hldev
operator|->
name|config
operator|.
name|link_valid_cnt
condition|)
block|{
if|if
condition|(
name|xge_hal_device_status
argument_list|(
name|hldev
argument_list|,
operator|&
name|adp_status
argument_list|)
operator|==
name|XGE_HAL_OK
condition|)
block|{
if|if
condition|(
name|__hal_verify_pcc_idle
argument_list|(
name|hldev
argument_list|,
name|adp_status
argument_list|)
operator|!=
name|XGE_HAL_OK
condition|)
block|{
return|return
name|XGE_HAL_ERR_DEVICE_IS_NOT_QUIESCENT
return|;
block|}
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"adp_status: "
name|XGE_OS_LLXFMT
literal|", link is up on "
literal|"adapter enable!"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|adp_status
argument_list|)
expr_stmt|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_control
argument_list|)
expr_stmt|;
name|val64
operator|=
name|val64
operator||
operator|(
name|XGE_HAL_ADAPTER_EOI_TX_ON
operator||
name|XGE_HAL_ADAPTER_LED_ON
operator|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_control
argument_list|)
expr_stmt|;
name|xge_os_mdelay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_control
argument_list|)
expr_stmt|;
break|break;
comment|/* out of for loop */
block|}
else|else
block|{
return|return
name|XGE_HAL_ERR_DEVICE_IS_NOT_QUIESCENT
return|;
block|}
block|}
block|}
else|else
block|{
name|j
operator|=
literal|0
expr_stmt|;
comment|/* Reset the count */
comment|/* Turn on the Laser */
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_control
argument_list|)
expr_stmt|;
name|val64
operator|=
name|val64
operator||
name|XGE_HAL_ADAPTER_EOI_TX_ON
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_control
argument_list|)
expr_stmt|;
name|xge_os_mdelay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Now re-enable it as due to noise, hardware 	         * turned it off */
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_control
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_ADAPTER_CNTL_EN
expr_stmt|;
name|val64
operator|=
name|val64
operator|&
operator|(
operator|~
name|XGE_HAL_ADAPTER_ECC_EN
operator|)
expr_stmt|;
comment|/*ECC enable*/
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_control
argument_list|)
expr_stmt|;
block|}
name|xge_os_mdelay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Sleep for 1 msec */
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|<
name|hldev
operator|->
name|config
operator|.
name|link_retry_cnt
condition|)
do|;
name|__hal_device_led_actifity_fix
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|XGE_HAL_PROCESS_LINK_INT_IN_ISR
comment|/* Here we are performing soft reset on XGXS to force link down. 	 * Since link is already up, we will get link state change 	 * poll notificatoin after adapter is enabled */
name|__hal_serial_mem_write64
argument_list|(
name|hldev
argument_list|,
literal|0x80010515001E0000ULL
argument_list|,
operator|&
name|bar0
operator|->
name|dtx_control
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|__hal_serial_mem_read64
argument_list|(
name|hldev
argument_list|,
operator|&
name|bar0
operator|->
name|dtx_control
argument_list|)
expr_stmt|;
name|__hal_serial_mem_write64
argument_list|(
name|hldev
argument_list|,
literal|0x80010515001E00E0ULL
argument_list|,
operator|&
name|bar0
operator|->
name|dtx_control
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|__hal_serial_mem_read64
argument_list|(
name|hldev
argument_list|,
operator|&
name|bar0
operator|->
name|dtx_control
argument_list|)
expr_stmt|;
name|__hal_serial_mem_write64
argument_list|(
name|hldev
argument_list|,
literal|0x80070515001F00E4ULL
argument_list|,
operator|&
name|bar0
operator|->
name|dtx_control
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|__hal_serial_mem_read64
argument_list|(
name|hldev
argument_list|,
operator|&
name|bar0
operator|->
name|dtx_control
argument_list|)
expr_stmt|;
name|xge_os_mdelay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* Sleep for 500 msec */
else|#
directive|else
if|if
condition|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_XENA
condition|)
endif|#
directive|endif
block|{
comment|/* 	     * With some switches the link state change interrupt does not 	     * occur even though the xgxs reset is done as per SPN-006. So, 	     * poll the adapter status register and check if the link state 	     * is ok. 	     */
name|adp_status
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|adp_status
operator|&
operator|(
name|XGE_HAL_ADAPTER_STATUS_RMAC_REMOTE_FAULT
operator||
name|XGE_HAL_ADAPTER_STATUS_RMAC_LOCAL_FAULT
operator|)
operator|)
condition|)
block|{
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"%s"
argument_list|,
literal|"enable device causing link state change ind.."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|__hal_device_handle_link_state_change
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hldev
operator|->
name|config
operator|.
name|stats_refresh_time_sec
operator|!=
name|XGE_HAL_STATS_REFRESH_DISABLE
condition|)
name|__hal_stats_enable
argument_list|(
operator|&
name|hldev
operator|->
name|stats
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_device_disable - Disable Xframe adapter.  * @hldev: Device handle.  *  * Disable this device. To gracefully reset the adapter, the host should:  *  *  - call xge_hal_device_disable();  *  *  - call xge_hal_device_intr_disable();  *  *  - close all opened channels and clean up outstanding resources;  *  *  - do some work (error recovery, change mtu, reset, etc);  *  *  - call xge_hal_device_enable();  *  *  - open channels, replenish RxDs, etc.  *  *  - call xge_hal_device_intr_enable().  *  * Note: Disabling the device does _not_ include disabling of interrupts.  * After disabling the device stops receiving new frames but those frames  * that were already in the pipe will keep coming for some few milliseconds.  *  * Returns:  XGE_HAL_OK - success.  * XGE_HAL_ERR_DEVICE_IS_NOT_QUIESCENT - Failed to restore the device to  * a "quiescent" state.  *  * See also: xge_hal_status_e{}.  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_device_disable
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{
name|xge_hal_status_e
name|status
init|=
name|XGE_HAL_OK
decl_stmt|;
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"%s"
argument_list|,
literal|"turn off laser, cleanup hardware"
argument_list|)
expr_stmt|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_control
argument_list|)
expr_stmt|;
name|val64
operator|=
name|val64
operator|&
operator|(
operator|~
name|XGE_HAL_ADAPTER_CNTL_EN
operator|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_control
argument_list|)
expr_stmt|;
if|if
condition|(
name|__hal_device_wait_quiescent
argument_list|(
name|hldev
argument_list|,
operator|&
name|val64
argument_list|)
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|status
operator|=
name|XGE_HAL_ERR_DEVICE_IS_NOT_QUIESCENT
expr_stmt|;
block|}
if|if
condition|(
name|__hal_device_register_poll
argument_list|(
name|hldev
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_status
argument_list|,
literal|1
argument_list|,
name|XGE_HAL_ADAPTER_STATUS_RC_PRC_QUIESCENT
argument_list|,
name|XGE_HAL_DEVICE_QUIESCENT_WAIT_MAX_MILLIS
argument_list|)
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"%s"
argument_list|,
literal|"PRC is not QUIESCENT!"
argument_list|)
expr_stmt|;
name|status
operator|=
name|XGE_HAL_ERR_DEVICE_IS_NOT_QUIESCENT
expr_stmt|;
block|}
if|if
condition|(
name|hldev
operator|->
name|config
operator|.
name|stats_refresh_time_sec
operator|!=
name|XGE_HAL_STATS_REFRESH_DISABLE
condition|)
name|__hal_stats_disable
argument_list|(
operator|&
name|hldev
operator|->
name|stats
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XGE_DEBUG_ASSERT
else|else
name|xge_assert
argument_list|(
operator|!
name|hldev
operator|->
name|stats
operator|.
name|is_enabled
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|XGE_HAL_DONT_DISABLE_BUS_MASTER_ON_STOP
name|__hal_device_bus_master_disable
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_device_reset - Reset device.  * @hldev: HAL device handle.  *  * Soft-reset the device, reset the device stats except reset_cnt.  *  * After reset is done, will try to re-initialize HW.  *  * Returns:  XGE_HAL_OK - success.  * XGE_HAL_ERR_DEVICE_NOT_INITIALIZED - Device is not initialized.  * XGE_HAL_ERR_RESET_FAILED - Reset failed.  *  * See also: xge_hal_status_e{}.  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_device_reset
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{
name|xge_hal_status_e
name|status
decl_stmt|;
comment|/* increment the soft reset counter */
name|u32
name|reset_cnt
init|=
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_info_stats
operator|.
name|soft_reset_cnt
decl_stmt|;
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"%s (%d)"
argument_list|,
literal|"resetting the device"
argument_list|,
name|reset_cnt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hldev
operator|->
name|is_initialized
condition|)
return|return
name|XGE_HAL_ERR_DEVICE_NOT_INITIALIZED
return|;
comment|/* actual "soft" reset of the adapter */
name|status
operator|=
name|__hal_device_reset
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
comment|/* reset all stats including saved */
name|__hal_stats_soft_reset
argument_list|(
name|hldev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* increment reset counter */
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_info_stats
operator|.
name|soft_reset_cnt
operator|=
name|reset_cnt
operator|+
literal|1
expr_stmt|;
comment|/* re-initialize rxufca_intr_thres */
name|hldev
operator|->
name|rxufca_intr_thres
operator|=
name|hldev
operator|->
name|config
operator|.
name|rxufca_intr_thres
expr_stmt|;
name|hldev
operator|->
name|reset_needed_after_close
operator|=
literal|0
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_device_status - Check whether Xframe hardware is ready for  * operation.  * @hldev: HAL device handle.  * @hw_status: Xframe status register. Returned by HAL.  *  * Check whether Xframe hardware is ready for operation.  * The checking includes TDMA, RDMA, PFC, PIC, MC_DRAM, and the rest  * hardware functional blocks.  *  * Returns: XGE_HAL_OK if the device is ready for operation. Otherwise  * returns XGE_HAL_FAIL. Also, fills in  adapter status (in @hw_status).  *  * See also: xge_hal_status_e{}.  * Usage: See ex_open{}.  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_device_status
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|,
name|u64
modifier|*
name|hw_status
parameter_list|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|tmp64
decl_stmt|;
name|tmp64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_status
argument_list|)
expr_stmt|;
operator|*
name|hw_status
operator|=
name|tmp64
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tmp64
operator|&
name|XGE_HAL_ADAPTER_STATUS_TDMA_READY
operator|)
condition|)
block|{
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"%s"
argument_list|,
literal|"TDMA is not ready!"
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_FAIL
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|tmp64
operator|&
name|XGE_HAL_ADAPTER_STATUS_RDMA_READY
operator|)
condition|)
block|{
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"%s"
argument_list|,
literal|"RDMA is not ready!"
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_FAIL
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|tmp64
operator|&
name|XGE_HAL_ADAPTER_STATUS_PFC_READY
operator|)
condition|)
block|{
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"%s"
argument_list|,
literal|"PFC is not ready!"
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_FAIL
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|tmp64
operator|&
name|XGE_HAL_ADAPTER_STATUS_TMAC_BUF_EMPTY
operator|)
condition|)
block|{
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"%s"
argument_list|,
literal|"TMAC BUF is not empty!"
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_FAIL
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|tmp64
operator|&
name|XGE_HAL_ADAPTER_STATUS_PIC_QUIESCENT
operator|)
condition|)
block|{
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"%s"
argument_list|,
literal|"PIC is not QUIESCENT!"
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_FAIL
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|tmp64
operator|&
name|XGE_HAL_ADAPTER_STATUS_MC_DRAM_READY
operator|)
condition|)
block|{
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"%s"
argument_list|,
literal|"MC_DRAM is not ready!"
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_FAIL
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|tmp64
operator|&
name|XGE_HAL_ADAPTER_STATUS_MC_QUEUES_READY
operator|)
condition|)
block|{
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"%s"
argument_list|,
literal|"MC_QUEUES is not ready!"
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_FAIL
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|tmp64
operator|&
name|XGE_HAL_ADAPTER_STATUS_M_PLL_LOCK
operator|)
condition|)
block|{
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"%s"
argument_list|,
literal|"M_PLL is not locked!"
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_FAIL
return|;
block|}
ifndef|#
directive|ifndef
name|XGE_HAL_HERC_EMULATION
comment|/* 	 * Andrew: in PCI 33 mode, the P_PLL is not used, and therefore, 	 * the the P_PLL_LOCK bit in the adapter_status register will 	 * not be asserted. 	 */
if|if
condition|(
operator|!
operator|(
name|tmp64
operator|&
name|XGE_HAL_ADAPTER_STATUS_P_PLL_LOCK
operator|)
operator|&&
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_HERC
operator|&&
name|hldev
operator|->
name|pci_mode
operator|!=
name|XGE_HAL_PCI_33MHZ_MODE
condition|)
block|{
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"%s"
argument_list|,
literal|"P_PLL is not locked!"
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_FAIL
return|;
block|}
endif|#
directive|endif
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_function
name|void
name|__hal_device_msi_intr_endis
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|u16
name|msi_control_reg
decl_stmt|;
name|xge_os_pci_read16
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_le_t
argument_list|,
name|msi_control
argument_list|)
argument_list|,
operator|&
name|msi_control_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
condition|)
name|msi_control_reg
operator||=
literal|0x1
expr_stmt|;
else|else
name|msi_control_reg
operator|&=
operator|~
literal|0x1
expr_stmt|;
name|xge_os_pci_write16
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_le_t
argument_list|,
name|msi_control
argument_list|)
argument_list|,
name|msi_control_reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__hal_device_msix_intr_endis
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|,
name|xge_hal_channel_t
modifier|*
name|channel
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|u64
name|val64
decl_stmt|;
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|xmsi_mask_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
condition|)
name|val64
operator|&=
operator|~
operator|(
literal|1LL
operator|<<
operator|(
literal|63
operator|-
name|channel
operator|->
name|msix_idx
operator|)
operator|)
expr_stmt|;
else|else
name|val64
operator||=
operator|(
literal|1LL
operator|<<
operator|(
literal|63
operator|-
name|channel
operator|->
name|msix_idx
operator|)
operator|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|xmsi_mask_reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_device_intr_enable - Enable Xframe interrupts.  * @hldev: HAL device handle.  * @op: One of the xge_hal_device_intr_e enumerated values specifying  *      the type(s) of interrupts to enable.  *  * Enable Xframe interrupts. The function is to be executed the last in  * Xframe initialization sequence.  *  * See also: xge_hal_device_intr_disable()  */
end_comment

begin_function
name|void
name|xge_hal_device_intr_enable
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{
name|xge_list_t
modifier|*
name|item
decl_stmt|;
name|u64
name|val64
decl_stmt|;
comment|/* PRC initialization and configuration */
name|xge_list_for_each
argument_list|(
argument|item
argument_list|,
argument|&hldev->ring_channels
argument_list|)
block|{
name|xge_hal_channel_h
name|channel
decl_stmt|;
name|channel
operator|=
name|xge_container_of
argument_list|(
name|item
argument_list|,
name|xge_hal_channel_t
argument_list|,
name|item
argument_list|)
expr_stmt|;
name|__hal_ring_prc_enable
argument_list|(
name|channel
argument_list|)
expr_stmt|;
block|}
comment|/* enable traffic only interrupts */
if|if
condition|(
name|hldev
operator|->
name|config
operator|.
name|intr_mode
operator|!=
name|XGE_HAL_INTR_MODE_IRQLINE
condition|)
block|{
comment|/* 	     * make sure all interrupts going to be disabled if MSI 	     * is enabled. 	     */
name|__hal_device_intr_mgmt
argument_list|(
name|hldev
argument_list|,
name|XGE_HAL_ALL_INTRS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * Enable the Tx traffic interrupts only if the TTI feature is 	     * enabled. 	     */
name|val64
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hldev
operator|->
name|tti_enabled
condition|)
name|val64
operator|=
name|XGE_HAL_TX_TRAFFIC_INTR
expr_stmt|;
if|if
condition|(
operator|!
name|hldev
operator|->
name|config
operator|.
name|bimodal_interrupts
condition|)
name|val64
operator||=
name|XGE_HAL_RX_TRAFFIC_INTR
expr_stmt|;
if|if
condition|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_XENA
condition|)
name|val64
operator||=
name|XGE_HAL_RX_TRAFFIC_INTR
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_TX_PIC_INTR
operator||
name|XGE_HAL_MC_INTR
operator||
name|XGE_HAL_TX_DMA_INTR
operator||
operator|(
name|hldev
operator|->
name|config
operator|.
name|sched_timer_us
operator|!=
name|XGE_HAL_SCHED_TIMER_DISABLED
condition|?
name|XGE_HAL_SCHED_INTR
else|:
literal|0
operator|)
expr_stmt|;
name|__hal_device_intr_mgmt
argument_list|(
name|hldev
argument_list|,
name|val64
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Enable MSI-X interrupts 	 */
if|if
condition|(
name|hldev
operator|->
name|config
operator|.
name|intr_mode
operator|==
name|XGE_HAL_INTR_MODE_MSIX
condition|)
block|{
if|if
condition|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_HERC
condition|)
block|{
comment|/* 	         * To enable MSI-X, MSI also needs to be enabled, 	         * due to a bug in the herc NIC. 	         */
name|__hal_device_msi_intr_endis
argument_list|(
name|hldev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Enable the MSI-X interrupt for each configured channel */
name|xge_list_for_each
argument_list|(
argument|item
argument_list|,
argument|&hldev->fifo_channels
argument_list|)
block|{
name|xge_hal_channel_t
modifier|*
name|channel
decl_stmt|;
name|channel
operator|=
name|xge_container_of
argument_list|(
name|item
argument_list|,
name|xge_hal_channel_t
argument_list|,
name|item
argument_list|)
expr_stmt|;
comment|/* 0 vector is reserved for alarms */
if|if
condition|(
operator|!
name|channel
operator|->
name|msix_idx
condition|)
continue|continue;
name|__hal_device_msix_intr_endis
argument_list|(
name|hldev
argument_list|,
name|channel
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|xge_list_for_each
argument_list|(
argument|item
argument_list|,
argument|&hldev->ring_channels
argument_list|)
block|{
name|xge_hal_channel_t
modifier|*
name|channel
decl_stmt|;
name|channel
operator|=
name|xge_container_of
argument_list|(
name|item
argument_list|,
name|xge_hal_channel_t
argument_list|,
name|item
argument_list|)
expr_stmt|;
comment|/* 0 vector is reserved for alarms */
if|if
condition|(
operator|!
name|channel
operator|->
name|msix_idx
condition|)
continue|continue;
name|__hal_device_msix_intr_endis
argument_list|(
name|hldev
argument_list|,
name|channel
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"%s"
argument_list|,
literal|"interrupts are enabled"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_device_intr_disable - Disable Xframe interrupts.  * @hldev: HAL device handle.  * @op: One of the xge_hal_device_intr_e enumerated values specifying  *      the type(s) of interrupts to disable.  *  * Disable Xframe interrupts.  *  * See also: xge_hal_device_intr_enable()  */
end_comment

begin_function
name|void
name|xge_hal_device_intr_disable
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{
name|xge_list_t
modifier|*
name|item
decl_stmt|;
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
if|if
condition|(
name|hldev
operator|->
name|config
operator|.
name|intr_mode
operator|==
name|XGE_HAL_INTR_MODE_MSIX
condition|)
block|{
if|if
condition|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_HERC
condition|)
block|{
comment|/* 	         * To disable MSI-X, MSI also needs to be disabled, 	         * due to a bug in the herc NIC. 	         */
name|__hal_device_msi_intr_endis
argument_list|(
name|hldev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Disable the MSI-X interrupt for each configured channel */
name|xge_list_for_each
argument_list|(
argument|item
argument_list|,
argument|&hldev->fifo_channels
argument_list|)
block|{
name|xge_hal_channel_t
modifier|*
name|channel
decl_stmt|;
name|channel
operator|=
name|xge_container_of
argument_list|(
name|item
argument_list|,
name|xge_hal_channel_t
argument_list|,
name|item
argument_list|)
expr_stmt|;
comment|/* 0 vector is reserved for alarms */
if|if
condition|(
operator|!
name|channel
operator|->
name|msix_idx
condition|)
continue|continue;
name|__hal_device_msix_intr_endis
argument_list|(
name|hldev
argument_list|,
name|channel
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
literal|0xFFFFFFFFFFFFFFFFULL
argument_list|,
operator|&
name|bar0
operator|->
name|tx_traffic_mask
argument_list|)
expr_stmt|;
name|xge_list_for_each
argument_list|(
argument|item
argument_list|,
argument|&hldev->ring_channels
argument_list|)
block|{
name|xge_hal_channel_t
modifier|*
name|channel
decl_stmt|;
name|channel
operator|=
name|xge_container_of
argument_list|(
name|item
argument_list|,
name|xge_hal_channel_t
argument_list|,
name|item
argument_list|)
expr_stmt|;
comment|/* 0 vector is reserved for alarms */
if|if
condition|(
operator|!
name|channel
operator|->
name|msix_idx
condition|)
continue|continue;
name|__hal_device_msix_intr_endis
argument_list|(
name|hldev
argument_list|,
name|channel
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
literal|0xFFFFFFFFFFFFFFFFULL
argument_list|,
operator|&
name|bar0
operator|->
name|rx_traffic_mask
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Disable traffic only interrupts. 	 * Tx traffic interrupts are used only if the TTI feature is 	 * enabled. 	 */
name|val64
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hldev
operator|->
name|tti_enabled
condition|)
name|val64
operator|=
name|XGE_HAL_TX_TRAFFIC_INTR
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_RX_TRAFFIC_INTR
operator||
name|XGE_HAL_TX_PIC_INTR
operator||
name|XGE_HAL_MC_INTR
operator||
operator|(
name|hldev
operator|->
name|config
operator|.
name|sched_timer_us
operator|!=
name|XGE_HAL_SCHED_TIMER_DISABLED
condition|?
name|XGE_HAL_SCHED_INTR
else|:
literal|0
operator|)
expr_stmt|;
name|__hal_device_intr_mgmt
argument_list|(
name|hldev
argument_list|,
name|val64
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
literal|0xFFFFFFFFFFFFFFFFULL
argument_list|,
operator|&
name|bar0
operator|->
name|general_int_mask
argument_list|)
expr_stmt|;
comment|/* disable all configured PRCs */
name|xge_list_for_each
argument_list|(
argument|item
argument_list|,
argument|&hldev->ring_channels
argument_list|)
block|{
name|xge_hal_channel_h
name|channel
decl_stmt|;
name|channel
operator|=
name|xge_container_of
argument_list|(
name|item
argument_list|,
name|xge_hal_channel_t
argument_list|,
name|item
argument_list|)
expr_stmt|;
name|__hal_ring_prc_disable
argument_list|(
name|channel
argument_list|)
expr_stmt|;
block|}
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"%s"
argument_list|,
literal|"interrupts are disabled"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_device_mcast_enable - Enable Xframe multicast addresses.  * @hldev: HAL device handle.  *  * Enable Xframe multicast addresses.  * Returns: XGE_HAL_OK on success.  * XGE_HAL_INF_MEM_STROBE_CMD_EXECUTING - Failed to enable mcast  * feature within the time(timeout).  *  * See also: xge_hal_device_mcast_disable(), xge_hal_status_e{}.  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_device_mcast_enable
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{
name|u64
name|val64
decl_stmt|;
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
decl_stmt|;
name|int
name|mc_offset
init|=
name|XGE_HAL_MAC_MC_ALL_MC_ADDR_OFFSET
decl_stmt|;
if|if
condition|(
name|hldev
operator|==
name|NULL
condition|)
return|return
name|XGE_HAL_ERR_INVALID_DEVICE
return|;
if|if
condition|(
name|hldev
operator|->
name|mcast_refcnt
condition|)
return|return
name|XGE_HAL_OK
return|;
if|if
condition|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_HERC
condition|)
name|mc_offset
operator|=
name|XGE_HAL_MAC_MC_ALL_MC_ADDR_OFFSET_HERC
expr_stmt|;
name|hldev
operator|->
name|mcast_refcnt
operator|=
literal|1
expr_stmt|;
name|bar0
operator|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
expr_stmt|;
comment|/*  Enable all Multicast addresses */
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|XGE_HAL_RMAC_ADDR_DATA0_MEM_ADDR
argument_list|(
literal|0x010203040506ULL
argument_list|)
argument_list|,
operator|&
name|bar0
operator|->
name|rmac_addr_data0_mem
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|XGE_HAL_RMAC_ADDR_DATA1_MEM_MASK
argument_list|(
literal|0xfeffffffffffULL
argument_list|)
argument_list|,
operator|&
name|bar0
operator|->
name|rmac_addr_data1_mem
argument_list|)
expr_stmt|;
name|val64
operator|=
name|XGE_HAL_RMAC_ADDR_CMD_MEM_WE
operator||
name|XGE_HAL_RMAC_ADDR_CMD_MEM_STROBE_NEW_CMD
operator||
name|XGE_HAL_RMAC_ADDR_CMD_MEM_OFFSET
argument_list|(
name|mc_offset
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rmac_addr_cmd_mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|__hal_device_register_poll
argument_list|(
name|hldev
argument_list|,
operator|&
name|bar0
operator|->
name|rmac_addr_cmd_mem
argument_list|,
literal|0
argument_list|,
name|XGE_HAL_RMAC_ADDR_CMD_MEM_STROBE_CMD_EXECUTING
argument_list|,
name|XGE_HAL_DEVICE_CMDMEM_WAIT_MAX_MILLIS
argument_list|)
operator|!=
name|XGE_HAL_OK
condition|)
block|{
comment|/* upper layer may require to repeat */
return|return
name|XGE_HAL_INF_MEM_STROBE_CMD_EXECUTING
return|;
block|}
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_device_mcast_disable - Disable Xframe multicast addresses.  * @hldev: HAL device handle.  *  * Disable Xframe multicast addresses.  * Returns: XGE_HAL_OK - success.  * XGE_HAL_INF_MEM_STROBE_CMD_EXECUTING - Failed to disable mcast  * feature within the time(timeout).  *  * See also: xge_hal_device_mcast_enable(), xge_hal_status_e{}.  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_device_mcast_disable
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{
name|u64
name|val64
decl_stmt|;
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
decl_stmt|;
name|int
name|mc_offset
init|=
name|XGE_HAL_MAC_MC_ALL_MC_ADDR_OFFSET
decl_stmt|;
if|if
condition|(
name|hldev
operator|==
name|NULL
condition|)
return|return
name|XGE_HAL_ERR_INVALID_DEVICE
return|;
if|if
condition|(
name|hldev
operator|->
name|mcast_refcnt
operator|==
literal|0
condition|)
return|return
name|XGE_HAL_OK
return|;
if|if
condition|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_HERC
condition|)
name|mc_offset
operator|=
name|XGE_HAL_MAC_MC_ALL_MC_ADDR_OFFSET_HERC
expr_stmt|;
name|hldev
operator|->
name|mcast_refcnt
operator|=
literal|0
expr_stmt|;
name|bar0
operator|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
expr_stmt|;
comment|/*  Disable all Multicast addresses */
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|XGE_HAL_RMAC_ADDR_DATA0_MEM_ADDR
argument_list|(
literal|0xffffffffffffULL
argument_list|)
argument_list|,
operator|&
name|bar0
operator|->
name|rmac_addr_data0_mem
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|XGE_HAL_RMAC_ADDR_DATA1_MEM_MASK
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|bar0
operator|->
name|rmac_addr_data1_mem
argument_list|)
expr_stmt|;
name|val64
operator|=
name|XGE_HAL_RMAC_ADDR_CMD_MEM_WE
operator||
name|XGE_HAL_RMAC_ADDR_CMD_MEM_STROBE_NEW_CMD
operator||
name|XGE_HAL_RMAC_ADDR_CMD_MEM_OFFSET
argument_list|(
name|mc_offset
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rmac_addr_cmd_mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|__hal_device_register_poll
argument_list|(
name|hldev
argument_list|,
operator|&
name|bar0
operator|->
name|rmac_addr_cmd_mem
argument_list|,
literal|0
argument_list|,
name|XGE_HAL_RMAC_ADDR_CMD_MEM_STROBE_CMD_EXECUTING
argument_list|,
name|XGE_HAL_DEVICE_CMDMEM_WAIT_MAX_MILLIS
argument_list|)
operator|!=
name|XGE_HAL_OK
condition|)
block|{
comment|/* upper layer may require to repeat */
return|return
name|XGE_HAL_INF_MEM_STROBE_CMD_EXECUTING
return|;
block|}
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_device_promisc_enable - Enable promiscuous mode.  * @hldev: HAL device handle.  *  * Enable promiscuous mode of Xframe operation.  *  * See also: xge_hal_device_promisc_disable().  */
end_comment

begin_function
name|void
name|xge_hal_device_promisc_enable
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{
name|u64
name|val64
decl_stmt|;
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
decl_stmt|;
name|xge_assert
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
name|bar0
operator|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
expr_stmt|;
if|if
condition|(
operator|!
name|hldev
operator|->
name|is_promisc
condition|)
block|{
comment|/*  Put the NIC into promiscuous mode */
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|mac_cfg
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_MAC_CFG_RMAC_PROM_ENABLE
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|XGE_HAL_RMAC_CFG_KEY
argument_list|(
literal|0x4C0D
argument_list|)
argument_list|,
operator|&
name|bar0
operator|->
name|rmac_cfg_key
argument_list|)
expr_stmt|;
name|__hal_pio_mem_write32_upper
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
call|(
name|u32
call|)
argument_list|(
name|val64
operator|>>
literal|32
argument_list|)
argument_list|,
operator|&
name|bar0
operator|->
name|mac_cfg
argument_list|)
expr_stmt|;
name|hldev
operator|->
name|is_promisc
operator|=
literal|1
expr_stmt|;
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"mac_cfg 0x"
name|XGE_OS_LLXFMT
literal|": promisc enabled"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|val64
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * xge_hal_device_promisc_disable - Disable promiscuous mode.  * @hldev: HAL device handle.  *  * Disable promiscuous mode of Xframe operation.  *  * See also: xge_hal_device_promisc_enable().  */
end_comment

begin_function
name|void
name|xge_hal_device_promisc_disable
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{
name|u64
name|val64
decl_stmt|;
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
decl_stmt|;
name|xge_assert
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
name|bar0
operator|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
expr_stmt|;
if|if
condition|(
name|hldev
operator|->
name|is_promisc
condition|)
block|{
comment|/*  Remove the NIC from promiscuous mode */
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|mac_cfg
argument_list|)
expr_stmt|;
name|val64
operator|&=
operator|~
name|XGE_HAL_MAC_CFG_RMAC_PROM_ENABLE
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|XGE_HAL_RMAC_CFG_KEY
argument_list|(
literal|0x4C0D
argument_list|)
argument_list|,
operator|&
name|bar0
operator|->
name|rmac_cfg_key
argument_list|)
expr_stmt|;
name|__hal_pio_mem_write32_upper
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
call|(
name|u32
call|)
argument_list|(
name|val64
operator|>>
literal|32
argument_list|)
argument_list|,
operator|&
name|bar0
operator|->
name|mac_cfg
argument_list|)
expr_stmt|;
name|hldev
operator|->
name|is_promisc
operator|=
literal|0
expr_stmt|;
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"mac_cfg 0x"
name|XGE_OS_LLXFMT
literal|": promisc disabled"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|val64
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * xge_hal_device_macaddr_get - Get MAC addresses.  * @hldev: HAL device handle.  * @index: MAC address index, in the range from 0 to  * XGE_HAL_MAX_MAC_ADDRESSES.  * @macaddr: MAC address. Returned by HAL.  *  * Retrieve one of the stored MAC addresses by reading non-volatile  * memory on the chip.  *  * Up to %XGE_HAL_MAX_MAC_ADDRESSES addresses is supported.  *  * Returns: XGE_HAL_OK - success.  * XGE_HAL_INF_MEM_STROBE_CMD_EXECUTING - Failed to retrieve the mac  * address within the time(timeout).  * XGE_HAL_ERR_OUT_OF_MAC_ADDRESSES - Invalid MAC address index.  *  * See also: xge_hal_device_macaddr_set(), xge_hal_status_e{}.  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_device_macaddr_get
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|,
name|int
name|index
parameter_list|,
name|macaddr_t
modifier|*
name|macaddr
parameter_list|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|hldev
operator|==
name|NULL
condition|)
block|{
return|return
name|XGE_HAL_ERR_INVALID_DEVICE
return|;
block|}
name|bar0
operator|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|XGE_HAL_MAX_MAC_ADDRESSES
condition|)
block|{
return|return
name|XGE_HAL_ERR_OUT_OF_MAC_ADDRESSES
return|;
block|}
ifdef|#
directive|ifdef
name|XGE_HAL_HERC_EMULATION
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
literal|0x0000010000000000
argument_list|,
operator|&
name|bar0
operator|->
name|rmac_addr_data0_mem
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
literal|0x0000000000000000
argument_list|,
operator|&
name|bar0
operator|->
name|rmac_addr_data1_mem
argument_list|)
expr_stmt|;
name|val64
operator|=
name|XGE_HAL_RMAC_ADDR_CMD_MEM_RD
operator||
name|XGE_HAL_RMAC_ADDR_CMD_MEM_STROBE_NEW_CMD
operator||
name|XGE_HAL_RMAC_ADDR_CMD_MEM_OFFSET
argument_list|(
operator|(
name|index
operator|)
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rmac_addr_cmd_mem
argument_list|)
expr_stmt|;
comment|/* poll until done */
name|__hal_device_register_poll
argument_list|(
name|hldev
argument_list|,
operator|&
name|bar0
operator|->
name|rmac_addr_cmd_mem
argument_list|,
literal|0
argument_list|,
name|XGE_HAL_RMAC_ADDR_CMD_MEM_STROBE_NEW_CMD
argument_list|,
name|XGE_HAL_DEVICE_CMDMEM_WAIT_MAX_MILLIS
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|val64
operator|=
operator|(
name|XGE_HAL_RMAC_ADDR_CMD_MEM_RD
operator||
name|XGE_HAL_RMAC_ADDR_CMD_MEM_STROBE_NEW_CMD
operator||
name|XGE_HAL_RMAC_ADDR_CMD_MEM_OFFSET
argument_list|(
operator|(
name|index
operator|)
argument_list|)
operator|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rmac_addr_cmd_mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|__hal_device_register_poll
argument_list|(
name|hldev
argument_list|,
operator|&
name|bar0
operator|->
name|rmac_addr_cmd_mem
argument_list|,
literal|0
argument_list|,
name|XGE_HAL_RMAC_ADDR_CMD_MEM_STROBE_CMD_EXECUTING
argument_list|,
name|XGE_HAL_DEVICE_CMDMEM_WAIT_MAX_MILLIS
argument_list|)
operator|!=
name|XGE_HAL_OK
condition|)
block|{
comment|/* upper layer may require to repeat */
return|return
name|XGE_HAL_INF_MEM_STROBE_CMD_EXECUTING
return|;
block|}
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|rmac_addr_data0_mem
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XGE_HAL_ETH_ALEN
condition|;
name|i
operator|++
control|)
block|{
operator|(
operator|*
name|macaddr
operator|)
index|[
name|i
index|]
operator|=
call|(
name|u8
call|)
argument_list|(
name|val64
operator|>>
operator|(
operator|(
literal|64
operator|-
literal|8
operator|)
operator|-
operator|(
name|i
operator|*
literal|8
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|XGE_HAL_HERC_EMULATION
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XGE_HAL_ETH_ALEN
condition|;
name|i
operator|++
control|)
block|{
operator|(
operator|*
name|macaddr
operator|)
index|[
name|i
index|]
operator|=
operator|(
name|u8
operator|)
literal|0
expr_stmt|;
block|}
operator|(
operator|*
name|macaddr
operator|)
index|[
literal|1
index|]
operator|=
operator|(
name|u8
operator|)
literal|1
expr_stmt|;
endif|#
directive|endif
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_device_macaddr_set - Set MAC address.  * @hldev: HAL device handle.  * @index: MAC address index, in the range from 0 to  * XGE_HAL_MAX_MAC_ADDRESSES.  * @macaddr: New MAC address to configure.  *  * Configure one of the available MAC address "slots".  *  * Up to %XGE_HAL_MAX_MAC_ADDRESSES addresses is supported.  *  * Returns: XGE_HAL_OK - success.  * XGE_HAL_INF_MEM_STROBE_CMD_EXECUTING - Failed to set the new mac  * address within the time(timeout).  * XGE_HAL_ERR_OUT_OF_MAC_ADDRESSES - Invalid MAC address index.  *  * See also: xge_hal_device_macaddr_get(), xge_hal_status_e{}.  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_device_macaddr_set
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|,
name|int
name|index
parameter_list|,
name|macaddr_t
name|macaddr
parameter_list|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
decl_stmt|,
name|temp64
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|index
operator|>=
name|XGE_HAL_MAX_MAC_ADDRESSES
condition|)
return|return
name|XGE_HAL_ERR_OUT_OF_MAC_ADDRESSES
return|;
name|temp64
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XGE_HAL_ETH_ALEN
condition|;
name|i
operator|++
control|)
block|{
name|temp64
operator||=
name|macaddr
index|[
name|i
index|]
expr_stmt|;
name|temp64
operator|<<=
literal|8
expr_stmt|;
block|}
name|temp64
operator|>>=
literal|8
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|XGE_HAL_RMAC_ADDR_DATA0_MEM_ADDR
argument_list|(
name|temp64
argument_list|)
argument_list|,
operator|&
name|bar0
operator|->
name|rmac_addr_data0_mem
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|XGE_HAL_RMAC_ADDR_DATA1_MEM_MASK
argument_list|(
literal|0ULL
argument_list|)
argument_list|,
operator|&
name|bar0
operator|->
name|rmac_addr_data1_mem
argument_list|)
expr_stmt|;
name|val64
operator|=
operator|(
name|XGE_HAL_RMAC_ADDR_CMD_MEM_WE
operator||
name|XGE_HAL_RMAC_ADDR_CMD_MEM_STROBE_NEW_CMD
operator||
name|XGE_HAL_RMAC_ADDR_CMD_MEM_OFFSET
argument_list|(
operator|(
name|index
operator|)
argument_list|)
operator|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rmac_addr_cmd_mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|__hal_device_register_poll
argument_list|(
name|hldev
argument_list|,
operator|&
name|bar0
operator|->
name|rmac_addr_cmd_mem
argument_list|,
literal|0
argument_list|,
name|XGE_HAL_RMAC_ADDR_CMD_MEM_STROBE_CMD_EXECUTING
argument_list|,
name|XGE_HAL_DEVICE_CMDMEM_WAIT_MAX_MILLIS
argument_list|)
operator|!=
name|XGE_HAL_OK
condition|)
block|{
comment|/* upper layer may require to repeat */
return|return
name|XGE_HAL_INF_MEM_STROBE_CMD_EXECUTING
return|;
block|}
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_device_macaddr_clear - Set MAC address.  * @hldev: HAL device handle.  * @index: MAC address index, in the range from 0 to  * XGE_HAL_MAX_MAC_ADDRESSES.  *  * Clear one of the available MAC address "slots".  *  * Returns: XGE_HAL_OK - success.  * XGE_HAL_INF_MEM_STROBE_CMD_EXECUTING - Failed to set the new mac  * address within the time(timeout).  * XGE_HAL_ERR_OUT_OF_MAC_ADDRESSES - Invalid MAC address index.  *  * See also: xge_hal_device_macaddr_set(), xge_hal_status_e{}.  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_device_macaddr_clear
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|xge_hal_status_e
name|status
decl_stmt|;
name|u8
name|macaddr
index|[
literal|6
index|]
init|=
block|{
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|,
literal|0xFF
block|}
decl_stmt|;
name|status
operator|=
name|xge_hal_device_macaddr_set
argument_list|(
name|hldev
argument_list|,
name|index
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_debug_device
argument_list|(
name|XGE_ERR
argument_list|,
literal|"%s"
argument_list|,
literal|"Not able to set the mac addr"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_device_macaddr_find - Finds index in the rmac table.  * @hldev: HAL device handle.  * @wanted: Wanted MAC address.  *  * See also: xge_hal_device_macaddr_set().  */
end_comment

begin_function
name|int
name|xge_hal_device_macaddr_find
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|,
name|macaddr_t
name|wanted
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|hldev
operator|==
name|NULL
condition|)
block|{
return|return
name|XGE_HAL_ERR_INVALID_DEVICE
return|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|XGE_HAL_MAX_MAC_ADDRESSES
condition|;
name|i
operator|++
control|)
block|{
name|macaddr_t
name|macaddr
decl_stmt|;
operator|(
name|void
operator|)
name|xge_hal_device_macaddr_get
argument_list|(
name|hldev
argument_list|,
name|i
argument_list|,
operator|&
name|macaddr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xge_os_memcmp
argument_list|(
name|macaddr
argument_list|,
name|wanted
argument_list|,
sizeof|sizeof
argument_list|(
name|macaddr_t
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_device_mtu_set - Set MTU.  * @hldev: HAL device handle.  * @new_mtu: New MTU size to configure.  *  * Set new MTU value. Example, to use jumbo frames:  * xge_hal_device_mtu_set(my_device, my_channel, 9600);  *  * Returns: XGE_HAL_OK on success.  * XGE_HAL_ERR_SWAPPER_CTRL - Failed to configure swapper control  * register.  * XGE_HAL_INF_MEM_STROBE_CMD_EXECUTING - Failed to initialize TTI/RTI  * schemes.  * XGE_HAL_ERR_DEVICE_IS_NOT_QUIESCENT - Failed to restore the device to  * a "quiescent" state.  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_device_mtu_set
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|,
name|int
name|new_mtu
parameter_list|)
block|{
name|xge_hal_status_e
name|status
decl_stmt|;
comment|/* 	 * reset needed if 1) new MTU differs, and 	 * 2a) device was closed or 	 * 2b) device is being upped for first time. 	 */
if|if
condition|(
name|hldev
operator|->
name|config
operator|.
name|mtu
operator|!=
name|new_mtu
condition|)
block|{
if|if
condition|(
name|hldev
operator|->
name|reset_needed_after_close
operator|||
operator|!
name|hldev
operator|->
name|mtu_first_time_set
condition|)
block|{
name|status
operator|=
name|xge_hal_device_reset
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"%s"
argument_list|,
literal|"fatal: can not reset the device"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
block|}
comment|/* store the new MTU in device, reset will use it */
name|hldev
operator|->
name|config
operator|.
name|mtu
operator|=
name|new_mtu
expr_stmt|;
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"new MTU %d applied"
argument_list|,
name|new_mtu
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hldev
operator|->
name|mtu_first_time_set
condition|)
name|hldev
operator|->
name|mtu_first_time_set
operator|=
literal|1
expr_stmt|;
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_device_initialize - Initialize Xframe device.  * @hldev: HAL device handle.  * @attr: pointer to xge_hal_device_attr_t structure  * @device_config: Configuration to be _applied_ to the device,  *                 For the Xframe configuration "knobs" please  *                 refer to xge_hal_device_config_t and Xframe  *                 User Guide.  *  * Initialize Xframe device. Note that all the arguments of this public API  * are 'IN', including @hldev. Upper-layer driver (ULD) cooperates with  * OS to find new Xframe device, locate its PCI and memory spaces.  *  * When done, the ULD allocates sizeof(xge_hal_device_t) bytes for HAL  * to enable the latter to perform Xframe hardware initialization.  *  * Returns: XGE_HAL_OK - success.  * XGE_HAL_ERR_DRIVER_NOT_INITIALIZED - Driver is not initialized.  * XGE_HAL_ERR_BAD_DEVICE_CONFIG - Device configuration params are not  * valid.  * XGE_HAL_ERR_OUT_OF_MEMORY - Memory allocation failed.  * XGE_HAL_ERR_BAD_SUBSYSTEM_ID - Device subsystem id is invalid.  * XGE_HAL_ERR_INVALID_MAC_ADDRESS - Device mac address in not valid.  * XGE_HAL_INF_MEM_STROBE_CMD_EXECUTING - Failed to retrieve the mac  * address within the time(timeout) or TTI/RTI initialization failed.  * XGE_HAL_ERR_SWAPPER_CTRL - Failed to configure swapper control.  * XGE_HAL_ERR_DEVICE_IS_NOT_QUIESCENT -Device is not queiscent.  *  * See also: xge_hal_device_terminate(), xge_hal_status_e{}  * xge_hal_device_attr_t{}.  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_device_initialize
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|,
name|xge_hal_device_attr_t
modifier|*
name|attr
parameter_list|,
name|xge_hal_device_config_t
modifier|*
name|device_config
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|xge_hal_status_e
name|status
decl_stmt|;
name|xge_hal_channel_t
modifier|*
name|channel
decl_stmt|;
name|u16
name|subsys_device
decl_stmt|;
name|u16
name|subsys_vendor
decl_stmt|;
name|int
name|total_dram_size
decl_stmt|,
name|ring_auto_dram_cfg
decl_stmt|,
name|left_dram_size
decl_stmt|;
name|int
name|total_dram_size_max
init|=
literal|0
decl_stmt|;
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"device 0x"
name|XGE_OS_LLXFMT
literal|" is initializing"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
operator|(
name|ulong_t
operator|)
name|hldev
argument_list|)
expr_stmt|;
comment|/* sanity check */
if|if
condition|(
name|g_xge_hal_driver
operator|==
name|NULL
operator|||
operator|!
name|g_xge_hal_driver
operator|->
name|is_initialized
condition|)
block|{
return|return
name|XGE_HAL_ERR_DRIVER_NOT_INITIALIZED
return|;
block|}
name|xge_os_memzero
argument_list|(
name|hldev
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_device_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * validate a common part of Xframe-I/II configuration 	 * (and run check_card() later, once PCI inited - see below) 	 */
name|status
operator|=
name|__hal_device_config_check_common
argument_list|(
name|device_config
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
return|return
name|status
return|;
comment|/* apply config */
name|xge_os_memcpy
argument_list|(
operator|&
name|hldev
operator|->
name|config
argument_list|,
name|device_config
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_device_config_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* save original attr */
name|xge_os_memcpy
argument_list|(
operator|&
name|hldev
operator|->
name|orig_attr
argument_list|,
name|attr
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_device_attr_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* initialize rxufca_intr_thres */
name|hldev
operator|->
name|rxufca_intr_thres
operator|=
name|hldev
operator|->
name|config
operator|.
name|rxufca_intr_thres
expr_stmt|;
name|hldev
operator|->
name|regh0
operator|=
name|attr
operator|->
name|regh0
expr_stmt|;
name|hldev
operator|->
name|regh1
operator|=
name|attr
operator|->
name|regh1
expr_stmt|;
name|hldev
operator|->
name|regh2
operator|=
name|attr
operator|->
name|regh2
expr_stmt|;
name|hldev
operator|->
name|isrbar0
operator|=
name|hldev
operator|->
name|bar0
operator|=
name|attr
operator|->
name|bar0
expr_stmt|;
name|hldev
operator|->
name|bar1
operator|=
name|attr
operator|->
name|bar1
expr_stmt|;
name|hldev
operator|->
name|bar2
operator|=
name|attr
operator|->
name|bar2
expr_stmt|;
name|hldev
operator|->
name|pdev
operator|=
name|attr
operator|->
name|pdev
expr_stmt|;
name|hldev
operator|->
name|irqh
operator|=
name|attr
operator|->
name|irqh
expr_stmt|;
name|hldev
operator|->
name|cfgh
operator|=
name|attr
operator|->
name|cfgh
expr_stmt|;
comment|/* set initial bimodal timer for bimodal adaptive schema */
name|hldev
operator|->
name|bimodal_timer_val_us
operator|=
name|hldev
operator|->
name|config
operator|.
name|bimodal_timer_lo_us
expr_stmt|;
name|hldev
operator|->
name|queueh
operator|=
name|xge_queue_create
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|irqh
argument_list|,
name|g_xge_hal_driver
operator|->
name|config
operator|.
name|queue_size_initial
argument_list|,
name|g_xge_hal_driver
operator|->
name|config
operator|.
name|queue_size_max
argument_list|,
name|__hal_device_event_queued
argument_list|,
name|hldev
argument_list|)
expr_stmt|;
if|if
condition|(
name|hldev
operator|->
name|queueh
operator|==
name|NULL
condition|)
return|return
name|XGE_HAL_ERR_OUT_OF_MEMORY
return|;
name|hldev
operator|->
name|magic
operator|=
name|XGE_HAL_MAGIC
expr_stmt|;
name|xge_assert
argument_list|(
name|hldev
operator|->
name|regh0
argument_list|)
expr_stmt|;
name|xge_assert
argument_list|(
name|hldev
operator|->
name|regh1
argument_list|)
expr_stmt|;
name|xge_assert
argument_list|(
name|hldev
operator|->
name|bar0
argument_list|)
expr_stmt|;
name|xge_assert
argument_list|(
name|hldev
operator|->
name|bar1
argument_list|)
expr_stmt|;
name|xge_assert
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|)
expr_stmt|;
name|xge_assert
argument_list|(
name|hldev
operator|->
name|irqh
argument_list|)
expr_stmt|;
name|xge_assert
argument_list|(
name|hldev
operator|->
name|cfgh
argument_list|)
expr_stmt|;
comment|/* initialize some PCI/PCI-X fields of this PCI device. */
name|__hal_device_pci_init
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
comment|/* 	 * initlialize lists to properly handling a potential 	 * terminate request 	 */
name|xge_list_init
argument_list|(
operator|&
name|hldev
operator|->
name|free_channels
argument_list|)
expr_stmt|;
name|xge_list_init
argument_list|(
operator|&
name|hldev
operator|->
name|fifo_channels
argument_list|)
expr_stmt|;
name|xge_list_init
argument_list|(
operator|&
name|hldev
operator|->
name|ring_channels
argument_list|)
expr_stmt|;
if|if
condition|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_XENA
condition|)
block|{
comment|/* fixups for xena */
name|hldev
operator|->
name|config
operator|.
name|rth_en
operator|=
literal|0
expr_stmt|;
name|hldev
operator|->
name|config
operator|.
name|rth_spdm_en
operator|=
literal|0
expr_stmt|;
name|hldev
operator|->
name|config
operator|.
name|rts_mac_en
operator|=
literal|0
expr_stmt|;
name|total_dram_size_max
operator|=
name|XGE_HAL_MAX_RING_QUEUE_SIZE_XENA
expr_stmt|;
name|status
operator|=
name|__hal_device_config_check_xena
argument_list|(
name|device_config
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_hal_device_terminate
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
if|if
condition|(
name|hldev
operator|->
name|config
operator|.
name|bimodal_interrupts
operator|==
literal|1
condition|)
block|{
name|xge_hal_device_terminate
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_BADCFG_BIMODAL_XENA_NOT_ALLOWED
return|;
block|}
elseif|else
if|if
condition|(
name|hldev
operator|->
name|config
operator|.
name|bimodal_interrupts
operator|==
name|XGE_HAL_DEFAULT_USE_HARDCODE
condition|)
name|hldev
operator|->
name|config
operator|.
name|bimodal_interrupts
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_HERC
condition|)
block|{
comment|/* fixups for herc */
name|total_dram_size_max
operator|=
name|XGE_HAL_MAX_RING_QUEUE_SIZE_HERC
expr_stmt|;
name|status
operator|=
name|__hal_device_config_check_herc
argument_list|(
name|device_config
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_hal_device_terminate
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
if|if
condition|(
name|hldev
operator|->
name|config
operator|.
name|bimodal_interrupts
operator|==
name|XGE_HAL_DEFAULT_USE_HARDCODE
condition|)
name|hldev
operator|->
name|config
operator|.
name|bimodal_interrupts
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|xge_debug_device
argument_list|(
name|XGE_ERR
argument_list|,
literal|"detected unknown device_id 0x%x"
argument_list|,
name|hldev
operator|->
name|device_id
argument_list|)
expr_stmt|;
name|xge_hal_device_terminate
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_ERR_BAD_DEVICE_ID
return|;
block|}
comment|/* allocate and initialize FIFO types of channels according to 	 * configuration */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XGE_HAL_MAX_FIFO_NUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|device_config
operator|->
name|fifo
operator|.
name|queue
index|[
name|i
index|]
operator|.
name|configured
condition|)
continue|continue;
name|channel
operator|=
name|__hal_channel_allocate
argument_list|(
name|hldev
argument_list|,
name|i
argument_list|,
name|XGE_HAL_CHANNEL_TYPE_FIFO
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|==
name|NULL
condition|)
block|{
name|xge_debug_device
argument_list|(
name|XGE_ERR
argument_list|,
literal|"fifo: __hal_channel_allocate failed"
argument_list|)
expr_stmt|;
name|xge_hal_device_terminate
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_ERR_OUT_OF_MEMORY
return|;
block|}
comment|/* add new channel to the device */
name|xge_list_insert
argument_list|(
operator|&
name|channel
operator|->
name|item
argument_list|,
operator|&
name|hldev
operator|->
name|free_channels
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * automatic DRAM adjustment 	 */
name|total_dram_size
operator|=
literal|0
expr_stmt|;
name|ring_auto_dram_cfg
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XGE_HAL_MAX_RING_NUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|device_config
operator|->
name|ring
operator|.
name|queue
index|[
name|i
index|]
operator|.
name|configured
condition|)
continue|continue;
if|if
condition|(
name|device_config
operator|->
name|ring
operator|.
name|queue
index|[
name|i
index|]
operator|.
name|dram_size_mb
operator|==
name|XGE_HAL_DEFAULT_USE_HARDCODE
condition|)
block|{
name|ring_auto_dram_cfg
operator|++
expr_stmt|;
continue|continue;
block|}
name|total_dram_size
operator|+=
name|device_config
operator|->
name|ring
operator|.
name|queue
index|[
name|i
index|]
operator|.
name|dram_size_mb
expr_stmt|;
block|}
name|left_dram_size
operator|=
name|total_dram_size_max
operator|-
name|total_dram_size
expr_stmt|;
if|if
condition|(
name|left_dram_size
operator|<
literal|0
operator|||
operator|(
name|ring_auto_dram_cfg
operator|&&
name|left_dram_size
operator|/
name|ring_auto_dram_cfg
operator|==
literal|0
operator|)
condition|)
block|{
name|xge_debug_device
argument_list|(
name|XGE_ERR
argument_list|,
literal|"ring config: exceeded DRAM size %d MB"
argument_list|,
name|total_dram_size_max
argument_list|)
expr_stmt|;
name|xge_hal_device_terminate
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_BADCFG_RING_QUEUE_SIZE
return|;
block|}
comment|/* 	 * allocate and initialize RING types of channels according to 	 * configuration 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XGE_HAL_MAX_RING_NUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|device_config
operator|->
name|ring
operator|.
name|queue
index|[
name|i
index|]
operator|.
name|configured
condition|)
continue|continue;
if|if
condition|(
name|device_config
operator|->
name|ring
operator|.
name|queue
index|[
name|i
index|]
operator|.
name|dram_size_mb
operator|==
name|XGE_HAL_DEFAULT_USE_HARDCODE
condition|)
block|{
name|hldev
operator|->
name|config
operator|.
name|ring
operator|.
name|queue
index|[
name|i
index|]
operator|.
name|dram_size_mb
operator|=
name|device_config
operator|->
name|ring
operator|.
name|queue
index|[
name|i
index|]
operator|.
name|dram_size_mb
operator|=
name|left_dram_size
operator|/
name|ring_auto_dram_cfg
expr_stmt|;
block|}
name|channel
operator|=
name|__hal_channel_allocate
argument_list|(
name|hldev
argument_list|,
name|i
argument_list|,
name|XGE_HAL_CHANNEL_TYPE_RING
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|==
name|NULL
condition|)
block|{
name|xge_debug_device
argument_list|(
name|XGE_ERR
argument_list|,
literal|"ring: __hal_channel_allocate failed"
argument_list|)
expr_stmt|;
name|xge_hal_device_terminate
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_ERR_OUT_OF_MEMORY
return|;
block|}
comment|/* add new channel to the device */
name|xge_list_insert
argument_list|(
operator|&
name|channel
operator|->
name|item
argument_list|,
operator|&
name|hldev
operator|->
name|free_channels
argument_list|)
expr_stmt|;
block|}
comment|/* get subsystem IDs */
name|xge_os_pci_read16
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_le_t
argument_list|,
name|subsystem_id
argument_list|)
argument_list|,
operator|&
name|subsys_device
argument_list|)
expr_stmt|;
name|xge_os_pci_read16
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_le_t
argument_list|,
name|subsystem_vendor_id
argument_list|)
argument_list|,
operator|&
name|subsys_vendor
argument_list|)
expr_stmt|;
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"subsystem_id %04x:%04x"
argument_list|,
name|subsys_vendor
argument_list|,
name|subsys_device
argument_list|)
expr_stmt|;
comment|/* reset device initially */
operator|(
name|void
operator|)
name|__hal_device_reset
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
comment|/* set host endian before, to assure proper action */
name|status
operator|=
name|__hal_device_set_swapper
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_debug_device
argument_list|(
name|XGE_ERR
argument_list|,
literal|"__hal_device_set_swapper failed"
argument_list|)
expr_stmt|;
name|xge_hal_device_terminate
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|__hal_device_reset
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
ifndef|#
directive|ifndef
name|XGE_HAL_HERC_EMULATION
if|if
condition|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_XENA
condition|)
name|__hal_device_xena_fix_mac
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*  MAC address initialization. 	 *  For now only one mac address will be read and used.  */
name|status
operator|=
name|xge_hal_device_macaddr_get
argument_list|(
name|hldev
argument_list|,
literal|0
argument_list|,
operator|&
name|hldev
operator|->
name|macaddr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_debug_device
argument_list|(
name|XGE_ERR
argument_list|,
literal|"xge_hal_device_macaddr_get failed"
argument_list|)
expr_stmt|;
name|xge_hal_device_terminate
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
if|if
condition|(
name|hldev
operator|->
name|macaddr
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|0xFF
operator|&&
name|hldev
operator|->
name|macaddr
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|==
literal|0xFF
operator|&&
name|hldev
operator|->
name|macaddr
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|==
literal|0xFF
operator|&&
name|hldev
operator|->
name|macaddr
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|==
literal|0xFF
operator|&&
name|hldev
operator|->
name|macaddr
index|[
literal|0
index|]
index|[
literal|4
index|]
operator|==
literal|0xFF
operator|&&
name|hldev
operator|->
name|macaddr
index|[
literal|0
index|]
index|[
literal|5
index|]
operator|==
literal|0xFF
condition|)
block|{
name|xge_debug_device
argument_list|(
name|XGE_ERR
argument_list|,
literal|"xge_hal_device_macaddr_get returns all FFs"
argument_list|)
expr_stmt|;
name|xge_hal_device_terminate
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_ERR_INVALID_MAC_ADDRESS
return|;
block|}
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"default macaddr: 0x%02x-%02x-%02x-%02x-%02x-%02x"
argument_list|,
name|hldev
operator|->
name|macaddr
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|,
name|hldev
operator|->
name|macaddr
index|[
literal|0
index|]
index|[
literal|1
index|]
argument_list|,
name|hldev
operator|->
name|macaddr
index|[
literal|0
index|]
index|[
literal|2
index|]
argument_list|,
name|hldev
operator|->
name|macaddr
index|[
literal|0
index|]
index|[
literal|3
index|]
argument_list|,
name|hldev
operator|->
name|macaddr
index|[
literal|0
index|]
index|[
literal|4
index|]
argument_list|,
name|hldev
operator|->
name|macaddr
index|[
literal|0
index|]
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|status
operator|=
name|__hal_stats_initialize
argument_list|(
operator|&
name|hldev
operator|->
name|stats
argument_list|,
name|hldev
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_debug_device
argument_list|(
name|XGE_ERR
argument_list|,
literal|"__hal_stats_initialize failed"
argument_list|)
expr_stmt|;
name|xge_hal_device_terminate
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
name|status
operator|=
name|__hal_device_hw_initialize
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_debug_device
argument_list|(
name|XGE_ERR
argument_list|,
literal|"__hal_device_hw_initialize failed"
argument_list|)
expr_stmt|;
name|xge_hal_device_terminate
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
name|hldev
operator|->
name|dump_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xge_os_malloc
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|XGE_HAL_DUMP_BUF_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|hldev
operator|->
name|dump_buf
operator|==
name|NULL
condition|)
block|{
name|xge_debug_device
argument_list|(
name|XGE_ERR
argument_list|,
literal|"__hal_device_hw_initialize failed"
argument_list|)
expr_stmt|;
name|xge_hal_device_terminate
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_ERR_OUT_OF_MEMORY
return|;
block|}
comment|/* Xena-only: need to serialize fifo posts across all device fifos */
if|#
directive|if
name|defined
argument_list|(
name|XGE_HAL_TX_MULTI_POST
argument_list|)
name|xge_os_spin_lock_init
argument_list|(
operator|&
name|hldev
operator|->
name|xena_post_lock
argument_list|,
name|hldev
operator|->
name|pdev
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|XGE_HAL_TX_MULTI_POST_IRQ
argument_list|)
name|xge_os_spin_lock_init_irq
argument_list|(
operator|&
name|hldev
operator|->
name|xena_post_lock
argument_list|,
name|hldev
operator|->
name|irqh
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Getting VPD data */
name|__hal_device_get_vpd_data
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
name|hldev
operator|->
name|is_initialized
operator|=
literal|1
expr_stmt|;
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_device_terminating - Mark the device as 'terminating'.  * @devh: HAL device handle.  *  * Mark the device as 'terminating', going to terminate. Can be used  * to serialize termination with other running processes/contexts.  *  * See also: xge_hal_device_terminate().  */
end_comment

begin_function
name|void
name|xge_hal_device_terminating
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|)
block|{
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
name|xge_list_t
modifier|*
name|item
decl_stmt|;
name|xge_hal_channel_t
modifier|*
name|channel
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|XGE_HAL_TX_MULTI_RESERVE_IRQ
argument_list|)
name|unsigned
name|long
name|flags
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * go through each opened tx channel and aquire 	 * lock, so it will serialize with HAL termination flag 	 */
name|xge_list_for_each
argument_list|(
argument|item
argument_list|,
argument|&hldev->fifo_channels
argument_list|)
block|{
name|channel
operator|=
name|xge_container_of
argument_list|(
name|item
argument_list|,
name|xge_hal_channel_t
argument_list|,
name|item
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|XGE_HAL_TX_MULTI_RESERVE
argument_list|)
name|xge_os_spin_lock
argument_list|(
operator|&
name|channel
operator|->
name|reserve_lock
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|XGE_HAL_TX_MULTI_RESERVE_IRQ
argument_list|)
name|xge_os_spin_lock_irq
argument_list|(
operator|&
name|channel
operator|->
name|reserve_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|channel
operator|->
name|terminating
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|XGE_HAL_TX_MULTI_RESERVE
argument_list|)
name|xge_os_spin_unlock
argument_list|(
operator|&
name|channel
operator|->
name|reserve_lock
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|XGE_HAL_TX_MULTI_RESERVE_IRQ
argument_list|)
name|xge_os_spin_unlock_irq
argument_list|(
operator|&
name|channel
operator|->
name|reserve_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|hldev
operator|->
name|terminating
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_device_terminate - Terminate Xframe device.  * @hldev: HAL device handle.  *  * Terminate HAL device.  *  * See also: xge_hal_device_initialize().  */
end_comment

begin_function
name|void
name|xge_hal_device_terminate
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{
name|xge_assert
argument_list|(
name|g_xge_hal_driver
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|xge_assert
argument_list|(
name|hldev
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|xge_assert
argument_list|(
name|hldev
operator|->
name|magic
operator|==
name|XGE_HAL_MAGIC
argument_list|)
expr_stmt|;
name|xge_queue_flush
argument_list|(
name|hldev
operator|->
name|queueh
argument_list|)
expr_stmt|;
name|hldev
operator|->
name|terminating
operator|=
literal|1
expr_stmt|;
name|hldev
operator|->
name|is_initialized
operator|=
literal|0
expr_stmt|;
name|hldev
operator|->
name|in_poll
operator|=
literal|0
expr_stmt|;
name|hldev
operator|->
name|magic
operator|=
name|XGE_HAL_DEAD
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|XGE_HAL_TX_MULTI_POST
argument_list|)
name|xge_os_spin_lock_destroy
argument_list|(
operator|&
name|hldev
operator|->
name|xena_post_lock
argument_list|,
name|hldev
operator|->
name|pdev
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|XGE_HAL_TX_MULTI_POST_IRQ
argument_list|)
name|xge_os_spin_lock_destroy_irq
argument_list|(
operator|&
name|hldev
operator|->
name|xena_post_lock
argument_list|,
name|hldev
operator|->
name|pdev
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"device "
name|XGE_OS_LLXFMT
literal|" is terminating"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
operator|(
name|ulong_t
operator|)
name|hldev
argument_list|)
expr_stmt|;
name|xge_assert
argument_list|(
name|xge_list_is_empty
argument_list|(
operator|&
name|hldev
operator|->
name|fifo_channels
argument_list|)
argument_list|)
expr_stmt|;
name|xge_assert
argument_list|(
name|xge_list_is_empty
argument_list|(
operator|&
name|hldev
operator|->
name|ring_channels
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hldev
operator|->
name|stats
operator|.
name|is_initialized
condition|)
block|{
name|__hal_stats_terminate
argument_list|(
operator|&
name|hldev
operator|->
name|stats
argument_list|)
expr_stmt|;
block|}
comment|/* close if open and free all channels */
while|while
condition|(
operator|!
name|xge_list_is_empty
argument_list|(
operator|&
name|hldev
operator|->
name|free_channels
argument_list|)
condition|)
block|{
name|xge_hal_channel_t
modifier|*
name|channel
init|=
operator|(
name|xge_hal_channel_t
operator|*
operator|)
name|hldev
operator|->
name|free_channels
operator|.
name|next
decl_stmt|;
name|xge_assert
argument_list|(
operator|!
name|channel
operator|->
name|is_open
argument_list|)
expr_stmt|;
name|xge_list_remove
argument_list|(
operator|&
name|channel
operator|->
name|item
argument_list|)
expr_stmt|;
name|__hal_channel_free
argument_list|(
name|channel
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hldev
operator|->
name|queueh
condition|)
block|{
name|xge_queue_destroy
argument_list|(
name|hldev
operator|->
name|queueh
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hldev
operator|->
name|spdm_table
condition|)
block|{
name|xge_os_free
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|spdm_table
index|[
literal|0
index|]
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|xge_hal_spdm_entry_t
argument_list|)
operator|*
name|hldev
operator|->
name|spdm_max_entries
operator|)
argument_list|)
expr_stmt|;
name|xge_os_free
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|spdm_table
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|xge_hal_spdm_entry_t
operator|*
argument_list|)
operator|*
name|hldev
operator|->
name|spdm_max_entries
operator|)
argument_list|)
expr_stmt|;
name|xge_os_spin_lock_destroy
argument_list|(
operator|&
name|hldev
operator|->
name|spdm_lock
argument_list|,
name|hldev
operator|->
name|pdev
argument_list|)
expr_stmt|;
name|hldev
operator|->
name|spdm_table
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|hldev
operator|->
name|dump_buf
condition|)
block|{
name|xge_os_free
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|dump_buf
argument_list|,
name|XGE_HAL_DUMP_BUF_SIZE
argument_list|)
expr_stmt|;
name|hldev
operator|->
name|dump_buf
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|hldev
operator|->
name|device_id
operator|!=
literal|0
condition|)
block|{
name|int
name|j
decl_stmt|,
name|pcisize
decl_stmt|;
name|pcisize
operator|=
operator|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_HERC
operator|)
condition|?
name|XGE_HAL_PCISIZE_HERC
else|:
name|XGE_HAL_PCISIZE_XENA
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pcisize
condition|;
name|j
operator|++
control|)
block|{
name|xge_os_pci_write32
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
name|j
operator|*
literal|4
argument_list|,
operator|*
operator|(
operator|(
name|u32
operator|*
operator|)
operator|&
name|hldev
operator|->
name|pci_config_space_bios
operator|+
name|j
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * __hal_device_get_vpd_data - Getting vpd_data.  *  *   @hldev: HAL device handle.  *  *   Getting  product name and serial number from vpd capabilites structure  *  */
end_comment

begin_function
name|void
name|__hal_device_get_vpd_data
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{
name|u8
modifier|*
name|vpd_data
decl_stmt|;
name|u8
name|data
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|,
name|count
decl_stmt|,
name|fail
init|=
literal|0
decl_stmt|;
name|u8
name|vpd_addr
init|=
name|XGE_HAL_CARD_XENA_VPD_ADDR
decl_stmt|;
if|if
condition|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_HERC
condition|)
name|vpd_addr
operator|=
name|XGE_HAL_CARD_HERC_VPD_ADDR
expr_stmt|;
name|xge_os_strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hldev
operator|->
name|vpd_data
operator|.
name|product_name
argument_list|,
literal|"10 Gigabit Ethernet Adapter"
argument_list|)
expr_stmt|;
name|xge_os_strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hldev
operator|->
name|vpd_data
operator|.
name|serial_num
argument_list|,
literal|"not available"
argument_list|)
expr_stmt|;
name|vpd_data
operator|=
operator|(
name|u8
operator|*
operator|)
name|xge_os_malloc
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|XGE_HAL_VPD_BUFFER_SIZE
operator|+
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|vpd_data
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|XGE_HAL_VPD_BUFFER_SIZE
condition|;
name|index
operator|+=
literal|4
control|)
block|{
name|xge_os_pci_write8
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
operator|(
name|vpd_addr
operator|+
literal|2
operator|)
argument_list|,
operator|(
name|u8
operator|)
name|index
argument_list|)
expr_stmt|;
name|xge_os_pci_read8
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
operator|(
name|vpd_addr
operator|+
literal|2
operator|)
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|xge_os_pci_write8
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
operator|(
name|vpd_addr
operator|+
literal|3
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
literal|5
condition|;
name|count
operator|++
control|)
block|{
name|xge_os_mdelay
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|xge_os_pci_read8
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
operator|(
name|vpd_addr
operator|+
literal|3
operator|)
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|XGE_HAL_VPD_READ_COMPLETE
condition|)
break|break;
block|}
if|if
condition|(
name|count
operator|>=
literal|5
condition|)
block|{
name|xge_os_printf
argument_list|(
literal|"ERR, Reading VPD data failed"
argument_list|)
expr_stmt|;
name|fail
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|xge_os_pci_read32
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
operator|(
name|vpd_addr
operator|+
literal|4
operator|)
argument_list|,
operator|(
name|u32
operator|*
operator|)
operator|&
name|vpd_data
index|[
name|index
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fail
condition|)
block|{
comment|/* read serial number of adapter */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|XGE_HAL_VPD_BUFFER_SIZE
condition|;
name|count
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|vpd_data
index|[
name|count
index|]
operator|==
literal|'S'
operator|)
operator|&&
operator|(
name|vpd_data
index|[
name|count
operator|+
literal|1
index|]
operator|==
literal|'N'
operator|)
operator|&&
operator|(
name|vpd_data
index|[
name|count
operator|+
literal|2
index|]
operator|<
name|XGE_HAL_VPD_LENGTH
operator|)
condition|)
block|{
name|memset
argument_list|(
name|hldev
operator|->
name|vpd_data
operator|.
name|serial_num
argument_list|,
literal|0
argument_list|,
name|XGE_HAL_VPD_LENGTH
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|hldev
operator|->
name|vpd_data
operator|.
name|serial_num
argument_list|,
operator|&
name|vpd_data
index|[
name|count
operator|+
literal|3
index|]
argument_list|,
name|vpd_data
index|[
name|count
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|vpd_data
index|[
literal|1
index|]
operator|<
name|XGE_HAL_VPD_LENGTH
condition|)
block|{
name|memset
argument_list|(
name|hldev
operator|->
name|vpd_data
operator|.
name|product_name
argument_list|,
literal|0
argument_list|,
name|vpd_data
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|hldev
operator|->
name|vpd_data
operator|.
name|product_name
argument_list|,
operator|&
name|vpd_data
index|[
literal|3
index|]
argument_list|,
name|vpd_data
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|xge_os_free
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|vpd_data
argument_list|,
name|XGE_HAL_VPD_BUFFER_SIZE
operator|+
literal|16
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_device_handle_tcode - Handle transfer code.  * @channelh: Channel handle.  * @dtrh: Descriptor handle.  * @t_code: One of the enumerated (and documented in the Xframe user guide)  *          "transfer codes".  *  * Handle descriptor's transfer code. The latter comes with each completed  * descriptor, see xge_hal_fifo_dtr_next_completed() and  * xge_hal_ring_dtr_next_completed().  * Transfer codes are enumerated in xgehal-fifo.h and xgehal-ring.h.  *  * Returns: one of the xge_hal_status_e{} enumerated types.  * XGE_HAL_OK           - for success.  * XGE_HAL_ERR_CRITICAL         - when encounters critical error.  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_device_handle_tcode
parameter_list|(
name|xge_hal_channel_h
name|channelh
parameter_list|,
name|xge_hal_dtr_h
name|dtrh
parameter_list|,
name|u8
name|t_code
parameter_list|)
block|{
name|xge_hal_channel_t
modifier|*
name|channel
init|=
operator|(
name|xge_hal_channel_t
operator|*
operator|)
name|channelh
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|channel
operator|->
name|devh
decl_stmt|;
if|if
condition|(
name|t_code
operator|>
literal|15
condition|)
block|{
name|xge_os_printf
argument_list|(
literal|"invalid t_code %d"
argument_list|,
name|t_code
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_OK
return|;
block|}
if|if
condition|(
name|channel
operator|->
name|type
operator|==
name|XGE_HAL_CHANNEL_TYPE_FIFO
condition|)
block|{
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_err_stats
operator|.
name|txd_t_code_err_cnt
index|[
name|t_code
index|]
operator|++
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|XGE_HAL_DEBUG_BAD_TCODE
argument_list|)
name|xge_hal_fifo_txd_t
modifier|*
name|txdp
init|=
operator|(
name|xge_hal_fifo_txd_t
operator|*
operator|)
name|dtrh
decl_stmt|;
name|xge_os_printf
argument_list|(
literal|""
name|XGE_OS_LLXFMT
literal|":"
name|XGE_OS_LLXFMT
literal|":"
name|XGE_OS_LLXFMT
literal|":"
name|XGE_OS_LLXFMT
argument_list|,
name|txdp
operator|->
name|control_1
argument_list|,
name|txdp
operator|->
name|control_2
argument_list|,
name|txdp
operator|->
name|buffer_pointer
argument_list|,
name|txdp
operator|->
name|host_control
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* handle link "down" immediately without going through 	     * xge_hal_device_poll() routine. */
if|if
condition|(
name|t_code
operator|==
name|XGE_HAL_TXD_T_CODE_LOSS_OF_LINK
condition|)
block|{
comment|/* link is down */
if|if
condition|(
name|hldev
operator|->
name|link_state
operator|!=
name|XGE_HAL_LINK_DOWN
condition|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
name|hldev
operator|->
name|link_state
operator|=
name|XGE_HAL_LINK_DOWN
expr_stmt|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_control
argument_list|)
expr_stmt|;
comment|/* turn off LED */
name|val64
operator|=
name|val64
operator|&
operator|(
operator|~
name|XGE_HAL_ADAPTER_LED_ON
operator|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_control
argument_list|)
expr_stmt|;
name|g_xge_hal_driver
operator|->
name|uld_callbacks
operator|.
name|link_down
argument_list|(
name|hldev
operator|->
name|upper_layer_info
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|t_code
operator|==
name|XGE_HAL_TXD_T_CODE_ABORT_BUFFER
operator|||
name|t_code
operator|==
name|XGE_HAL_TXD_T_CODE_ABORT_DTOR
condition|)
block|{
name|__hal_device_handle_targetabort
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_ERR_CRITICAL
return|;
block|}
return|return
name|XGE_HAL_ERR_PKT_DROP
return|;
block|}
elseif|else
if|if
condition|(
name|channel
operator|->
name|type
operator|==
name|XGE_HAL_CHANNEL_TYPE_RING
condition|)
block|{
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_err_stats
operator|.
name|rxd_t_code_err_cnt
index|[
name|t_code
index|]
operator|++
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|XGE_HAL_DEBUG_BAD_TCODE
argument_list|)
name|xge_hal_ring_rxd_1_t
modifier|*
name|rxdp
init|=
operator|(
name|xge_hal_ring_rxd_1_t
operator|*
operator|)
name|dtrh
decl_stmt|;
name|xge_os_printf
argument_list|(
literal|""
name|XGE_OS_LLXFMT
literal|":"
name|XGE_OS_LLXFMT
literal|":"
name|XGE_OS_LLXFMT
literal|":"
name|XGE_OS_LLXFMT
argument_list|,
name|rxdp
operator|->
name|control_1
argument_list|,
name|rxdp
operator|->
name|control_2
argument_list|,
name|rxdp
operator|->
name|buffer0_ptr
argument_list|,
name|rxdp
operator|->
name|host_control
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|t_code
operator|==
name|XGE_HAL_RXD_T_CODE_BAD_ECC
condition|)
block|{
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_err_stats
operator|.
name|ecc_err_cnt
operator|++
expr_stmt|;
name|__hal_device_handle_eccerr
argument_list|(
name|hldev
argument_list|,
literal|"rxd_t_code"
argument_list|,
operator|(
name|u64
operator|)
name|t_code
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_ERR_CRITICAL
return|;
block|}
elseif|else
if|if
condition|(
name|t_code
operator|==
name|XGE_HAL_RXD_T_CODE_PARITY
operator|||
name|t_code
operator|==
name|XGE_HAL_RXD_T_CODE_PARITY_ABORT
condition|)
block|{
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_err_stats
operator|.
name|parity_err_cnt
operator|++
expr_stmt|;
name|__hal_device_handle_parityerr
argument_list|(
name|hldev
argument_list|,
literal|"rxd_t_code"
argument_list|,
operator|(
name|u64
operator|)
name|t_code
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_ERR_CRITICAL
return|;
comment|/* do not drop if detected unknown IPv6 extension */
block|}
elseif|else
if|if
condition|(
name|t_code
operator|!=
name|XGE_HAL_RXD_T_CODE_UNKNOWN_PROTO
condition|)
block|{
return|return
name|XGE_HAL_ERR_PKT_DROP
return|;
block|}
block|}
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_device_link_state - Get link state.  * @devh: HAL device handle.  * @ls: Link state, see xge_hal_device_link_state_e{}.  *  * Get link state.  * Returns: XGE_HAL_OK.  * See also: xge_hal_device_link_state_e{}.  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_device_link_state
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|,
name|xge_hal_device_link_state_e
modifier|*
name|ls
parameter_list|)
block|{
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
name|xge_assert
argument_list|(
name|ls
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|ls
operator|=
name|hldev
operator|->
name|link_state
expr_stmt|;
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_device_sched_timer - Configure scheduled device interrupt.  * @devh: HAL device handle.  * @interval_us: Time interval, in miscoseconds.  *            Unlike transmit and receive interrupts,  *            the scheduled interrupt is generated independently of  *            traffic, but purely based on time.  * @one_shot: 1 - generate scheduled interrupt only once.  *            0 - generate scheduled interrupt periodically at the specified  *            @interval_us interval.  *  * (Re-)configure scheduled interrupt. Can be called at runtime to change  * the setting, generate one-shot interrupts based on the resource and/or  * traffic conditions, other purposes.  * See also: xge_hal_device_config_t{}.  */
end_comment

begin_function
name|void
name|xge_hal_device_sched_timer
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|,
name|int
name|interval_us
parameter_list|,
name|int
name|one_shot
parameter_list|)
block|{
name|u64
name|val64
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|unsigned
name|int
name|interval
init|=
name|hldev
operator|->
name|config
operator|.
name|pci_freq_mherz
operator|*
name|interval_us
decl_stmt|;
name|interval
operator|=
name|__hal_fix_time_ival_herc
argument_list|(
name|hldev
argument_list|,
name|interval
argument_list|)
expr_stmt|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|scheduled_int_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|interval
condition|)
block|{
name|val64
operator|&=
name|XGE_HAL_SCHED_INT_PERIOD_MASK
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_SCHED_INT_PERIOD
argument_list|(
name|interval
argument_list|)
expr_stmt|;
if|if
condition|(
name|one_shot
condition|)
block|{
name|val64
operator||=
name|XGE_HAL_SCHED_INT_CTRL_ONE_SHOT
expr_stmt|;
block|}
name|val64
operator||=
name|XGE_HAL_SCHED_INT_CTRL_TIMER_EN
expr_stmt|;
block|}
else|else
block|{
name|val64
operator|&=
operator|~
name|XGE_HAL_SCHED_INT_CTRL_TIMER_EN
expr_stmt|;
block|}
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|scheduled_int_ctrl
argument_list|)
expr_stmt|;
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"sched_timer 0x"
name|XGE_OS_LLXFMT
literal|": %s"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|val64
argument_list|,
name|interval
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_device_check_id - Verify device ID.  * @devh: HAL device handle.  *  * Verify device ID.  * Returns: one of the xge_hal_card_e{} enumerated types.  * See also: xge_hal_card_e{}.  */
end_comment

begin_function
name|xge_hal_card_e
name|xge_hal_device_check_id
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|)
block|{
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
switch|switch
condition|(
name|hldev
operator|->
name|device_id
condition|)
block|{
case|case
name|XGE_PCI_DEVICE_ID_XENA_1
case|:
case|case
name|XGE_PCI_DEVICE_ID_XENA_2
case|:
return|return
name|XGE_HAL_CARD_XENA
return|;
case|case
name|XGE_PCI_DEVICE_ID_HERC_1
case|:
case|case
name|XGE_PCI_DEVICE_ID_HERC_2
case|:
return|return
name|XGE_HAL_CARD_HERC
return|;
case|case
name|XGE_PCI_DEVICE_ID_TITAN_1
case|:
case|case
name|XGE_PCI_DEVICE_ID_TITAN_2
case|:
return|return
name|XGE_HAL_CARD_TITAN
return|;
default|default:
return|return
name|XGE_HAL_CARD_UNKNOWN
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * xge_hal_device_pci_info_get - Get PCI bus informations such as width,  *           frequency, and mode from previously stored values.  * @devh:       HAL device handle.  * @pci_mode:       pointer to a variable of enumerated type  *          xge_hal_pci_mode_e{}.  * @bus_frequency:  pointer to a variable of enumerated type  *          xge_hal_pci_bus_frequency_e{}.  * @bus_width:      pointer to a variable of enumerated type  *          xge_hal_pci_bus_width_e{}.  *  * Get pci mode, frequency, and PCI bus width.  * Returns: one of the xge_hal_status_e{} enumerated types.  * XGE_HAL_OK           - for success.  * XGE_HAL_ERR_INVALID_DEVICE   - for invalid device handle.  * See Also: xge_hal_pci_mode_e, xge_hal_pci_mode_e, xge_hal_pci_width_e.  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_device_pci_info_get
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|,
name|xge_hal_pci_mode_e
modifier|*
name|pci_mode
parameter_list|,
name|xge_hal_pci_bus_frequency_e
modifier|*
name|bus_frequency
parameter_list|,
name|xge_hal_pci_bus_width_e
modifier|*
name|bus_width
parameter_list|)
block|{
name|xge_hal_status_e
name|rc_status
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
if|if
condition|(
operator|!
name|hldev
operator|||
operator|!
name|hldev
operator|->
name|is_initialized
operator|||
name|hldev
operator|->
name|magic
operator|!=
name|XGE_HAL_MAGIC
condition|)
block|{
name|rc_status
operator|=
name|XGE_HAL_ERR_INVALID_DEVICE
expr_stmt|;
name|xge_debug_device
argument_list|(
name|XGE_ERR
argument_list|,
literal|"xge_hal_device_pci_info_get error, rc %d for device %p"
argument_list|,
name|rc_status
argument_list|,
name|hldev
argument_list|)
expr_stmt|;
return|return
name|rc_status
return|;
block|}
operator|*
name|pci_mode
operator|=
name|hldev
operator|->
name|pci_mode
expr_stmt|;
operator|*
name|bus_frequency
operator|=
name|hldev
operator|->
name|bus_frequency
expr_stmt|;
operator|*
name|bus_width
operator|=
name|hldev
operator|->
name|bus_width
expr_stmt|;
name|rc_status
operator|=
name|XGE_HAL_OK
expr_stmt|;
return|return
name|rc_status
return|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_reinitialize_hw  * @hldev: private member of the device structure.  *  * This function will soft reset the NIC and re-initalize all the  * I/O registers to the values they had after it's inital initialization  * through the probe function.  */
end_comment

begin_function
name|int
name|xge_hal_reinitialize_hw
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{
operator|(
name|void
operator|)
name|xge_hal_device_reset
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
if|if
condition|(
name|__hal_device_hw_initialize
argument_list|(
name|hldev
argument_list|)
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_hal_device_terminate
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|__hal_device_reset
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * __hal_read_spdm_entry_line  * @hldev: pointer to xge_hal_device_t structure  * @spdm_line: spdm line in the spdm entry to be read.  * @spdm_entry: spdm entry of the spdm_line in the SPDM table.  * @spdm_line_val: Contains the value stored in the spdm line.  *  * SPDM table contains upto a maximum of 256 spdm entries.  * Each spdm entry contains 8 lines and each line stores 8 bytes.  * This function reads the spdm line(addressed by @spdm_line)  * of the spdm entry(addressed by @spdm_entry) in  * the SPDM table.  */
end_comment

begin_function
name|xge_hal_status_e
name|__hal_read_spdm_entry_line
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|,
name|u8
name|spdm_line
parameter_list|,
name|u16
name|spdm_entry
parameter_list|,
name|u64
modifier|*
name|spdm_line_val
parameter_list|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
name|val64
operator|=
name|XGE_HAL_RTS_RTH_SPDM_MEM_CTRL_STROBE
operator||
name|XGE_HAL_RTS_RTH_SPDM_MEM_CTRL_LINE_SEL
argument_list|(
name|spdm_line
argument_list|)
operator||
name|XGE_HAL_RTS_RTH_SPDM_MEM_CTRL_OFFSET
argument_list|(
name|spdm_entry
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rts_rth_spdm_mem_ctrl
argument_list|)
expr_stmt|;
comment|/* poll until done */
if|if
condition|(
name|__hal_device_register_poll
argument_list|(
name|hldev
argument_list|,
operator|&
name|bar0
operator|->
name|rts_rth_spdm_mem_ctrl
argument_list|,
literal|0
argument_list|,
name|XGE_HAL_RTS_RTH_SPDM_MEM_CTRL_STROBE
argument_list|,
name|XGE_HAL_DEVICE_CMDMEM_WAIT_MAX_MILLIS
argument_list|)
operator|!=
name|XGE_HAL_OK
condition|)
block|{
return|return
name|XGE_HAL_INF_MEM_STROBE_CMD_EXECUTING
return|;
block|}
operator|*
name|spdm_line_val
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|rts_rth_spdm_mem_data
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/*  * __hal_get_free_spdm_entry  * @hldev: pointer to xge_hal_device_t structure  * @spdm_entry: Contains an index to the unused spdm entry in the SPDM table.  *  * This function returns an index of unused spdm entry in the SPDM  * table.  */
end_comment

begin_function
specifier|static
name|xge_hal_status_e
name|__hal_get_free_spdm_entry
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|,
name|u16
modifier|*
name|spdm_entry
parameter_list|)
block|{
name|xge_hal_status_e
name|status
decl_stmt|;
name|u64
name|spdm_line_val
init|=
literal|0
decl_stmt|;
comment|/* 	 * Search in the local SPDM table for a free slot. 	 */
operator|*
name|spdm_entry
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|*
name|spdm_entry
operator|<
name|hldev
operator|->
name|spdm_max_entries
condition|;
operator|(
operator|*
name|spdm_entry
operator|)
operator|++
control|)
block|{
if|if
condition|(
name|hldev
operator|->
name|spdm_table
index|[
operator|*
name|spdm_entry
index|]
operator|->
name|in_use
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|spdm_entry
operator|>=
name|hldev
operator|->
name|spdm_max_entries
condition|)
block|{
return|return
name|XGE_HAL_ERR_SPDM_TABLE_FULL
return|;
block|}
comment|/* 	 * Make sure that the corresponding spdm entry in the SPDM 	 * table is free. 	 * Seventh line of the spdm entry contains information about 	 * whether the entry is free or not. 	 */
if|if
condition|(
operator|(
name|status
operator|=
name|__hal_read_spdm_entry_line
argument_list|(
name|hldev
argument_list|,
literal|7
argument_list|,
operator|*
name|spdm_entry
argument_list|,
operator|&
name|spdm_line_val
argument_list|)
operator|)
operator|!=
name|XGE_HAL_OK
condition|)
block|{
return|return
name|status
return|;
block|}
comment|/* BIT(63) in spdm_line 7 corresponds to entry_enable bit */
if|if
condition|(
operator|(
name|spdm_line_val
operator|&
name|BIT
argument_list|(
literal|63
argument_list|)
operator|)
condition|)
block|{
comment|/* 	     * Log a warning 	     */
name|xge_debug_device
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Local SPDM table is not "
literal|"consistent with the actual one for the spdm "
literal|"entry %d"
argument_list|,
operator|*
name|spdm_entry
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_ERR_SPDM_TABLE_DATA_INCONSISTENT
return|;
block|}
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/*  * __hal_calc_jhash - Calculate Jenkins hash.  * @msg: Jenkins hash algorithm key.  * @length: Length of the key.  * @golden_ratio: Jenkins hash golden ratio.  * @init_value: Jenkins hash initial value.  *  * This function implements the Jenkins based algorithm used for the  * calculation of the RTH hash.  * Returns:  Jenkins hash value.  *  */
end_comment

begin_function
specifier|static
name|u32
name|__hal_calc_jhash
parameter_list|(
name|u8
modifier|*
name|msg
parameter_list|,
name|u32
name|length
parameter_list|,
name|u32
name|golden_ratio
parameter_list|,
name|u32
name|init_value
parameter_list|)
block|{
specifier|register
name|u32
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|len
decl_stmt|;
comment|/* 	 * Set up the internal state 	 */
name|len
operator|=
name|length
expr_stmt|;
name|a
operator|=
name|b
operator|=
name|golden_ratio
expr_stmt|;
comment|/* the golden ratio; an arbitrary value */
name|c
operator|=
name|init_value
expr_stmt|;
comment|/* the previous hash value */
comment|/*  handle most of the key */
while|while
condition|(
name|len
operator|>=
literal|12
condition|)
block|{
name|a
operator|+=
operator|(
name|msg
index|[
literal|0
index|]
operator|+
operator|(
operator|(
name|u32
operator|)
name|msg
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
operator|(
name|u32
operator|)
name|msg
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
operator|(
name|u32
operator|)
name|msg
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator|)
expr_stmt|;
name|b
operator|+=
operator|(
name|msg
index|[
literal|4
index|]
operator|+
operator|(
operator|(
name|u32
operator|)
name|msg
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
operator|(
name|u32
operator|)
name|msg
index|[
literal|6
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
operator|(
name|u32
operator|)
name|msg
index|[
literal|7
index|]
operator|<<
literal|24
operator|)
operator|)
expr_stmt|;
name|c
operator|+=
operator|(
name|msg
index|[
literal|8
index|]
operator|+
operator|(
operator|(
name|u32
operator|)
name|msg
index|[
literal|9
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
operator|(
name|u32
operator|)
name|msg
index|[
literal|10
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
operator|(
name|u32
operator|)
name|msg
index|[
literal|11
index|]
operator|<<
literal|24
operator|)
operator|)
expr_stmt|;
name|mix
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|msg
operator|+=
literal|12
expr_stmt|;
name|len
operator|-=
literal|12
expr_stmt|;
block|}
comment|/*  handle the last 11 bytes */
name|c
operator|+=
name|length
expr_stmt|;
switch|switch
condition|(
name|len
condition|)
comment|/* all the case statements fall through */
block|{
case|case
literal|11
case|:
name|c
operator|+=
operator|(
operator|(
name|u32
operator|)
name|msg
index|[
literal|10
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|c
operator|+=
operator|(
operator|(
name|u32
operator|)
name|msg
index|[
literal|9
index|]
operator|<<
literal|16
operator|)
expr_stmt|;
break|break;
case|case
literal|9
case|:
name|c
operator|+=
operator|(
operator|(
name|u32
operator|)
name|msg
index|[
literal|8
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
break|break;
comment|/* the first byte of c is reserved for the length */
case|case
literal|8
case|:
name|b
operator|+=
operator|(
operator|(
name|u32
operator|)
name|msg
index|[
literal|7
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|b
operator|+=
operator|(
operator|(
name|u32
operator|)
name|msg
index|[
literal|6
index|]
operator|<<
literal|16
operator|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|b
operator|+=
operator|(
operator|(
name|u32
operator|)
name|msg
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|b
operator|+=
name|msg
index|[
literal|4
index|]
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|a
operator|+=
operator|(
operator|(
name|u32
operator|)
name|msg
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|a
operator|+=
operator|(
operator|(
name|u32
operator|)
name|msg
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|a
operator|+=
operator|(
operator|(
name|u32
operator|)
name|msg
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|a
operator|+=
name|msg
index|[
literal|0
index|]
expr_stmt|;
break|break;
comment|/* case 0: nothing left to add */
block|}
name|mix
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* report the result */
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_spdm_entry_add - Add a new entry to the SPDM table.  * @devh: HAL device handle.  * @src_ip: Source ip address(IPv4/IPv6).  * @dst_ip: Destination ip address(IPv4/IPv6).  * @l4_sp: L4 source port.  * @l4_dp: L4 destination port.  * @is_tcp: Set to 1, if the protocol is TCP.  *         0, if the protocol is UDP.  * @is_ipv4: Set to 1, if the protocol is IPv4.  *         0, if the protocol is IPv6.  * @tgt_queue: Target queue to route the receive packet.  *  * This function add a new entry to the SPDM table.  *  * Returns:  XGE_HAL_OK - success.  * XGE_HAL_ERR_SPDM_NOT_ENABLED -  SPDM support is not enabled.  * XGE_HAL_INF_MEM_STROBE_CMD_EXECUTING - Failed to add a new entry with in  *                  the time(timeout).  * XGE_HAL_ERR_SPDM_TABLE_FULL - SPDM table is full.  * XGE_HAL_ERR_SPDM_INVALID_ENTRY - Invalid SPDM entry.  *  * See also: xge_hal_spdm_entry_remove{}.  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_spdm_entry_add
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|,
name|xge_hal_ipaddr_t
modifier|*
name|src_ip
parameter_list|,
name|xge_hal_ipaddr_t
modifier|*
name|dst_ip
parameter_list|,
name|u16
name|l4_sp
parameter_list|,
name|u16
name|l4_dp
parameter_list|,
name|u8
name|is_tcp
parameter_list|,
name|u8
name|is_ipv4
parameter_list|,
name|u8
name|tgt_queue
parameter_list|)
block|{
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u32
name|jhash_value
decl_stmt|;
name|u32
name|jhash_init_val
decl_stmt|;
name|u32
name|jhash_golden_ratio
decl_stmt|;
name|u64
name|val64
decl_stmt|;
name|int
name|off
decl_stmt|;
name|u16
name|spdm_entry
decl_stmt|;
name|u8
name|msg
index|[
name|XGE_HAL_JHASH_MSG_LEN
index|]
decl_stmt|;
name|int
name|ipaddr_len
decl_stmt|;
name|xge_hal_status_e
name|status
decl_stmt|;
if|if
condition|(
operator|!
name|hldev
operator|->
name|config
operator|.
name|rth_spdm_en
condition|)
block|{
return|return
name|XGE_HAL_ERR_SPDM_NOT_ENABLED
return|;
block|}
if|if
condition|(
operator|(
name|tgt_queue
operator|<
name|XGE_HAL_MIN_RING_NUM
operator|)
operator|||
operator|(
name|tgt_queue
operator|>
name|XGE_HAL_MAX_RING_NUM
operator|)
condition|)
block|{
return|return
name|XGE_HAL_ERR_SPDM_INVALID_ENTRY
return|;
block|}
comment|/* 	 * Calculate the jenkins hash. 	 */
comment|/* 	 * Create the Jenkins hash algorithm key. 	 * key = {L3SA, L3DA, L4SP, L4DP}, if SPDM is configured to 	 * use L4 information. Otherwize key = {L3SA, L3DA}. 	 */
if|if
condition|(
name|is_ipv4
condition|)
block|{
name|ipaddr_len
operator|=
literal|4
expr_stmt|;
comment|// In bytes
block|}
else|else
block|{
name|ipaddr_len
operator|=
literal|16
expr_stmt|;
block|}
comment|/* 	 * Jenkins hash algorithm expects the key in the big endian 	 * format. Since key is the byte array, memcpy won't work in the 	 * case of little endian. So, the current code extracts each 	 * byte starting from MSB and store it in the key. 	 */
if|if
condition|(
name|is_ipv4
condition|)
block|{
for|for
control|(
name|off
operator|=
literal|0
init|;
name|off
operator|<
name|ipaddr_len
condition|;
name|off
operator|++
control|)
block|{
name|u32
name|mask
init|=
name|vBIT32
argument_list|(
literal|0xff
argument_list|,
operator|(
name|off
operator|*
literal|8
operator|)
argument_list|,
literal|8
argument_list|)
decl_stmt|;
name|int
name|shift
init|=
literal|32
operator|-
operator|(
name|off
operator|+
literal|1
operator|)
operator|*
literal|8
decl_stmt|;
name|msg
index|[
name|off
index|]
operator|=
call|(
name|u8
call|)
argument_list|(
operator|(
name|src_ip
operator|->
name|ipv4
operator|.
name|addr
operator|&
name|mask
operator|)
operator|>>
name|shift
argument_list|)
expr_stmt|;
name|msg
index|[
name|off
operator|+
name|ipaddr_len
index|]
operator|=
call|(
name|u8
call|)
argument_list|(
operator|(
name|dst_ip
operator|->
name|ipv4
operator|.
name|addr
operator|&
name|mask
operator|)
operator|>>
name|shift
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|off
operator|=
literal|0
init|;
name|off
operator|<
name|ipaddr_len
condition|;
name|off
operator|++
control|)
block|{
name|int
name|loc
init|=
name|off
operator|%
literal|8
decl_stmt|;
name|u64
name|mask
init|=
name|vBIT
argument_list|(
literal|0xff
argument_list|,
operator|(
name|loc
operator|*
literal|8
operator|)
argument_list|,
literal|8
argument_list|)
decl_stmt|;
name|int
name|shift
init|=
literal|64
operator|-
operator|(
name|loc
operator|+
literal|1
operator|)
operator|*
literal|8
decl_stmt|;
name|msg
index|[
name|off
index|]
operator|=
call|(
name|u8
call|)
argument_list|(
operator|(
name|src_ip
operator|->
name|ipv6
operator|.
name|addr
index|[
name|off
operator|/
literal|8
index|]
operator|&
name|mask
operator|)
operator|>>
name|shift
argument_list|)
expr_stmt|;
name|msg
index|[
name|off
operator|+
name|ipaddr_len
index|]
operator|=
call|(
name|u8
call|)
argument_list|(
operator|(
name|dst_ip
operator|->
name|ipv6
operator|.
name|addr
index|[
name|off
operator|/
literal|8
index|]
operator|&
name|mask
operator|)
operator|>>
name|shift
argument_list|)
expr_stmt|;
block|}
block|}
name|off
operator|=
operator|(
literal|2
operator|*
name|ipaddr_len
operator|)
expr_stmt|;
if|if
condition|(
name|hldev
operator|->
name|config
operator|.
name|rth_spdm_use_l4
condition|)
block|{
name|msg
index|[
name|off
index|]
operator|=
call|(
name|u8
call|)
argument_list|(
operator|(
name|l4_sp
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|msg
index|[
name|off
operator|+
literal|1
index|]
operator|=
call|(
name|u8
call|)
argument_list|(
name|l4_sp
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|msg
index|[
name|off
operator|+
literal|2
index|]
operator|=
call|(
name|u8
call|)
argument_list|(
operator|(
name|l4_dp
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|msg
index|[
name|off
operator|+
literal|3
index|]
operator|=
call|(
name|u8
call|)
argument_list|(
name|l4_dp
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|off
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* 	 * Calculate jenkins hash for this configuration 	 */
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|rts_rth_jhash_cfg
argument_list|)
expr_stmt|;
name|jhash_golden_ratio
operator|=
call|(
name|u32
call|)
argument_list|(
name|val64
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|jhash_init_val
operator|=
call|(
name|u32
call|)
argument_list|(
name|val64
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|jhash_value
operator|=
name|__hal_calc_jhash
argument_list|(
name|msg
argument_list|,
name|off
argument_list|,
name|jhash_golden_ratio
argument_list|,
name|jhash_init_val
argument_list|)
expr_stmt|;
name|xge_os_spin_lock
argument_list|(
operator|&
name|hldev
operator|->
name|spdm_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Locate a free slot in the SPDM table. To avoid a seach in the 	 * actual SPDM table, which is very expensive in terms of time, 	 * we are maintaining a local copy of  the table and the search for 	 * the free entry is performed in the local table. 	 */
if|if
condition|(
operator|(
name|status
operator|=
name|__hal_get_free_spdm_entry
argument_list|(
name|hldev
argument_list|,
operator|&
name|spdm_entry
argument_list|)
operator|)
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_os_spin_unlock
argument_list|(
operator|&
name|hldev
operator|->
name|spdm_lock
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
comment|/* 	 * Add this entry to the SPDM table 	 */
name|status
operator|=
name|__hal_spdm_entry_add
argument_list|(
name|hldev
argument_list|,
name|src_ip
argument_list|,
name|dst_ip
argument_list|,
name|l4_sp
argument_list|,
name|l4_dp
argument_list|,
name|is_tcp
argument_list|,
name|is_ipv4
argument_list|,
name|tgt_queue
argument_list|,
name|jhash_value
argument_list|,
comment|/* calculated jhash */
name|spdm_entry
argument_list|)
expr_stmt|;
name|xge_os_spin_unlock
argument_list|(
operator|&
name|hldev
operator|->
name|spdm_lock
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_spdm_entry_remove - Remove an entry from the SPDM table.  * @devh: HAL device handle.  * @src_ip: Source ip address(IPv4/IPv6).  * @dst_ip: Destination ip address(IPv4/IPv6).  * @l4_sp: L4 source port.  * @l4_dp: L4 destination port.  * @is_tcp: Set to 1, if the protocol is TCP.  *         0, if the protocol os UDP.  * @is_ipv4: Set to 1, if the protocol is IPv4.  *         0, if the protocol is IPv6.  *  * This function remove an entry from the SPDM table.  *  * Returns:  XGE_HAL_OK - success.  * XGE_HAL_ERR_SPDM_NOT_ENABLED -  SPDM support is not enabled.  * XGE_HAL_INF_MEM_STROBE_CMD_EXECUTING - Failed to remove an entry with in  *                  the time(timeout).  * XGE_HAL_ERR_SPDM_ENTRY_NOT_FOUND - Unable to locate the entry in the SPDM  *                  table.  *  * See also: xge_hal_spdm_entry_add{}.  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_spdm_entry_remove
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|,
name|xge_hal_ipaddr_t
modifier|*
name|src_ip
parameter_list|,
name|xge_hal_ipaddr_t
modifier|*
name|dst_ip
parameter_list|,
name|u16
name|l4_sp
parameter_list|,
name|u16
name|l4_dp
parameter_list|,
name|u8
name|is_tcp
parameter_list|,
name|u8
name|is_ipv4
parameter_list|)
block|{
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
name|u16
name|spdm_entry
decl_stmt|;
name|xge_hal_status_e
name|status
decl_stmt|;
name|u64
name|spdm_line_arr
index|[
literal|8
index|]
decl_stmt|;
name|u8
name|line_no
decl_stmt|;
name|u8
name|spdm_is_tcp
decl_stmt|;
name|u8
name|spdm_is_ipv4
decl_stmt|;
name|u16
name|spdm_l4_sp
decl_stmt|;
name|u16
name|spdm_l4_dp
decl_stmt|;
if|if
condition|(
operator|!
name|hldev
operator|->
name|config
operator|.
name|rth_spdm_en
condition|)
block|{
return|return
name|XGE_HAL_ERR_SPDM_NOT_ENABLED
return|;
block|}
name|xge_os_spin_lock
argument_list|(
operator|&
name|hldev
operator|->
name|spdm_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Poll the rxpic_int_reg register until spdm ready bit is set or 	 * timeout happens. 	 */
if|if
condition|(
name|__hal_device_register_poll
argument_list|(
name|hldev
argument_list|,
operator|&
name|bar0
operator|->
name|rxpic_int_reg
argument_list|,
literal|1
argument_list|,
name|XGE_HAL_RX_PIC_INT_REG_SPDM_READY
argument_list|,
name|XGE_HAL_DEVICE_CMDMEM_WAIT_MAX_MILLIS
argument_list|)
operator|!=
name|XGE_HAL_OK
condition|)
block|{
comment|/* upper layer may require to repeat */
name|xge_os_spin_unlock
argument_list|(
operator|&
name|hldev
operator|->
name|spdm_lock
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_INF_MEM_STROBE_CMD_EXECUTING
return|;
block|}
comment|/* 	 * Clear the SPDM READY bit. 	 */
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|rxpic_int_reg
argument_list|)
expr_stmt|;
name|val64
operator|&=
operator|~
name|XGE_HAL_RX_PIC_INT_REG_SPDM_READY
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rxpic_int_reg
argument_list|)
expr_stmt|;
comment|/* 	 * Search in the local SPDM table to get the index of the 	 * corresponding entry in the SPDM table. 	 */
name|spdm_entry
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|spdm_entry
operator|<
name|hldev
operator|->
name|spdm_max_entries
condition|;
name|spdm_entry
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|!
name|hldev
operator|->
name|spdm_table
index|[
name|spdm_entry
index|]
operator|->
name|in_use
operator|)
operator|||
operator|(
name|hldev
operator|->
name|spdm_table
index|[
name|spdm_entry
index|]
operator|->
name|is_tcp
operator|!=
name|is_tcp
operator|)
operator|||
operator|(
name|hldev
operator|->
name|spdm_table
index|[
name|spdm_entry
index|]
operator|->
name|l4_sp
operator|!=
name|l4_sp
operator|)
operator|||
operator|(
name|hldev
operator|->
name|spdm_table
index|[
name|spdm_entry
index|]
operator|->
name|l4_dp
operator|!=
name|l4_dp
operator|)
operator|||
operator|(
name|hldev
operator|->
name|spdm_table
index|[
name|spdm_entry
index|]
operator|->
name|is_ipv4
operator|!=
name|is_ipv4
operator|)
condition|)
block|{
continue|continue;
block|}
comment|/* 	     * Compare the src/dst IP addresses of source and target 	     */
if|if
condition|(
name|is_ipv4
condition|)
block|{
if|if
condition|(
operator|(
name|hldev
operator|->
name|spdm_table
index|[
name|spdm_entry
index|]
operator|->
name|src_ip
operator|.
name|ipv4
operator|.
name|addr
operator|!=
name|src_ip
operator|->
name|ipv4
operator|.
name|addr
operator|)
operator|||
operator|(
name|hldev
operator|->
name|spdm_table
index|[
name|spdm_entry
index|]
operator|->
name|dst_ip
operator|.
name|ipv4
operator|.
name|addr
operator|!=
name|dst_ip
operator|->
name|ipv4
operator|.
name|addr
operator|)
condition|)
block|{
continue|continue;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|hldev
operator|->
name|spdm_table
index|[
name|spdm_entry
index|]
operator|->
name|src_ip
operator|.
name|ipv6
operator|.
name|addr
index|[
literal|0
index|]
operator|!=
name|src_ip
operator|->
name|ipv6
operator|.
name|addr
index|[
literal|0
index|]
operator|)
operator|||
operator|(
name|hldev
operator|->
name|spdm_table
index|[
name|spdm_entry
index|]
operator|->
name|src_ip
operator|.
name|ipv6
operator|.
name|addr
index|[
literal|1
index|]
operator|!=
name|src_ip
operator|->
name|ipv6
operator|.
name|addr
index|[
literal|1
index|]
operator|)
operator|||
operator|(
name|hldev
operator|->
name|spdm_table
index|[
name|spdm_entry
index|]
operator|->
name|dst_ip
operator|.
name|ipv6
operator|.
name|addr
index|[
literal|0
index|]
operator|!=
name|dst_ip
operator|->
name|ipv6
operator|.
name|addr
index|[
literal|0
index|]
operator|)
operator|||
operator|(
name|hldev
operator|->
name|spdm_table
index|[
name|spdm_entry
index|]
operator|->
name|dst_ip
operator|.
name|ipv6
operator|.
name|addr
index|[
literal|1
index|]
operator|!=
name|dst_ip
operator|->
name|ipv6
operator|.
name|addr
index|[
literal|1
index|]
operator|)
condition|)
block|{
continue|continue;
block|}
block|}
break|break;
block|}
if|if
condition|(
name|spdm_entry
operator|>=
name|hldev
operator|->
name|spdm_max_entries
condition|)
block|{
name|xge_os_spin_unlock
argument_list|(
operator|&
name|hldev
operator|->
name|spdm_lock
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_ERR_SPDM_ENTRY_NOT_FOUND
return|;
block|}
comment|/* 	 * Retrieve the corresponding entry from the SPDM table and 	 * make sure that the data is consistent. 	 */
for|for
control|(
name|line_no
operator|=
literal|0
init|;
name|line_no
operator|<
literal|8
condition|;
name|line_no
operator|++
control|)
block|{
comment|/* 	     *  SPDM line 2,3,4 are valid only for IPv6 entry. 	     *  SPDM line 5& 6 are reserved. We don't have to 	     *  read these entries in the above cases. 	     */
if|if
condition|(
operator|(
operator|(
name|is_ipv4
operator|)
operator|&&
operator|(
operator|(
name|line_no
operator|==
literal|2
operator|)
operator|||
operator|(
name|line_no
operator|==
literal|3
operator|)
operator|||
operator|(
name|line_no
operator|==
literal|4
operator|)
operator|)
operator|)
operator|||
operator|(
name|line_no
operator|==
literal|5
operator|)
operator|||
operator|(
name|line_no
operator|==
literal|6
operator|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
name|status
operator|=
name|__hal_read_spdm_entry_line
argument_list|(
name|hldev
argument_list|,
name|line_no
argument_list|,
name|spdm_entry
argument_list|,
operator|&
name|spdm_line_arr
index|[
name|line_no
index|]
argument_list|)
operator|)
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_os_spin_unlock
argument_list|(
operator|&
name|hldev
operator|->
name|spdm_lock
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
block|}
comment|/* 	 * Seventh line of the spdm entry contains the entry_enable 	 * bit. Make sure that the entry_enable bit of this spdm entry 	 * is set. 	 * To remove an entry from the SPDM table, reset this 	 * bit. 	 */
if|if
condition|(
operator|!
operator|(
name|spdm_line_arr
index|[
literal|7
index|]
operator|&
name|BIT
argument_list|(
literal|63
argument_list|)
operator|)
condition|)
block|{
comment|/* 	     * Log a warning 	     */
name|xge_debug_device
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Local SPDM table is not "
literal|"consistent with the actual one for the spdm "
literal|"entry %d "
argument_list|,
name|spdm_entry
argument_list|)
expr_stmt|;
goto|goto
name|err_exit
goto|;
block|}
comment|/* 	 *  Retreive the L4 SP/DP, src/dst ip addresses from the SPDM 	 *  table and do a comparision. 	 */
name|spdm_is_tcp
operator|=
call|(
name|u8
call|)
argument_list|(
operator|(
name|spdm_line_arr
index|[
literal|0
index|]
operator|&
name|BIT
argument_list|(
literal|59
argument_list|)
operator|)
operator|>>
literal|4
argument_list|)
expr_stmt|;
name|spdm_is_ipv4
operator|=
call|(
name|u8
call|)
argument_list|(
name|spdm_line_arr
index|[
literal|0
index|]
operator|&
name|BIT
argument_list|(
literal|63
argument_list|)
argument_list|)
expr_stmt|;
name|spdm_l4_sp
operator|=
call|(
name|u16
call|)
argument_list|(
name|spdm_line_arr
index|[
literal|0
index|]
operator|>>
literal|48
argument_list|)
expr_stmt|;
name|spdm_l4_dp
operator|=
call|(
name|u16
call|)
argument_list|(
operator|(
name|spdm_line_arr
index|[
literal|0
index|]
operator|>>
literal|32
operator|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|spdm_is_tcp
operator|!=
name|is_tcp
operator|)
operator|||
operator|(
name|spdm_is_ipv4
operator|!=
name|is_ipv4
operator|)
operator|||
operator|(
name|spdm_l4_sp
operator|!=
name|l4_sp
operator|)
operator|||
operator|(
name|spdm_l4_dp
operator|!=
name|l4_dp
operator|)
condition|)
block|{
comment|/* 	     * Log a warning 	     */
name|xge_debug_device
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Local SPDM table is not "
literal|"consistent with the actual one for the spdm "
literal|"entry %d "
argument_list|,
name|spdm_entry
argument_list|)
expr_stmt|;
goto|goto
name|err_exit
goto|;
block|}
if|if
condition|(
name|is_ipv4
condition|)
block|{
comment|/* Upper 32 bits of spdm_line(64 bit) contains the 	     * src IPv4 address. Lower 32 bits of spdm_line 	     * contains the destination IPv4 address. 	     */
name|u32
name|temp_src_ip
init|=
call|(
name|u32
call|)
argument_list|(
name|spdm_line_arr
index|[
literal|1
index|]
operator|>>
literal|32
argument_list|)
decl_stmt|;
name|u32
name|temp_dst_ip
init|=
call|(
name|u32
call|)
argument_list|(
name|spdm_line_arr
index|[
literal|1
index|]
operator|&
literal|0xffffffff
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|temp_src_ip
operator|!=
name|src_ip
operator|->
name|ipv4
operator|.
name|addr
operator|)
operator|||
operator|(
name|temp_dst_ip
operator|!=
name|dst_ip
operator|->
name|ipv4
operator|.
name|addr
operator|)
condition|)
block|{
name|xge_debug_device
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Local SPDM table is not "
literal|"consistent with the actual one for the spdm "
literal|"entry %d "
argument_list|,
name|spdm_entry
argument_list|)
expr_stmt|;
goto|goto
name|err_exit
goto|;
block|}
block|}
else|else
block|{
comment|/* 	     * SPDM line 1& 2 contains the src IPv6 address. 	     * SPDM line 3& 4 contains the dst IPv6 address. 	     */
if|if
condition|(
operator|(
name|spdm_line_arr
index|[
literal|1
index|]
operator|!=
name|src_ip
operator|->
name|ipv6
operator|.
name|addr
index|[
literal|0
index|]
operator|)
operator|||
operator|(
name|spdm_line_arr
index|[
literal|2
index|]
operator|!=
name|src_ip
operator|->
name|ipv6
operator|.
name|addr
index|[
literal|1
index|]
operator|)
operator|||
operator|(
name|spdm_line_arr
index|[
literal|3
index|]
operator|!=
name|dst_ip
operator|->
name|ipv6
operator|.
name|addr
index|[
literal|0
index|]
operator|)
operator|||
operator|(
name|spdm_line_arr
index|[
literal|4
index|]
operator|!=
name|dst_ip
operator|->
name|ipv6
operator|.
name|addr
index|[
literal|1
index|]
operator|)
condition|)
block|{
comment|/* 	         * Log a warning 	         */
name|xge_debug_device
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Local SPDM table is not "
literal|"consistent with the actual one for the spdm "
literal|"entry %d "
argument_list|,
name|spdm_entry
argument_list|)
expr_stmt|;
goto|goto
name|err_exit
goto|;
block|}
block|}
comment|/* 	 * Reset the entry_enable bit to zero 	 */
name|spdm_line_arr
index|[
literal|7
index|]
operator|&=
operator|~
name|BIT
argument_list|(
literal|63
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|spdm_line_arr
index|[
literal|7
index|]
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|hldev
operator|->
name|spdm_mem_base
operator|+
operator|(
name|spdm_entry
operator|*
literal|64
operator|)
operator|+
operator|(
literal|7
operator|*
literal|8
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for the operation to be completed. 	 */
if|if
condition|(
name|__hal_device_register_poll
argument_list|(
name|hldev
argument_list|,
operator|&
name|bar0
operator|->
name|rxpic_int_reg
argument_list|,
literal|1
argument_list|,
name|XGE_HAL_RX_PIC_INT_REG_SPDM_READY
argument_list|,
name|XGE_HAL_DEVICE_CMDMEM_WAIT_MAX_MILLIS
argument_list|)
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_os_spin_unlock
argument_list|(
operator|&
name|hldev
operator|->
name|spdm_lock
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_INF_MEM_STROBE_CMD_EXECUTING
return|;
block|}
comment|/* 	 * Make the corresponding spdm entry in the local SPDM table 	 * available for future use. 	 */
name|hldev
operator|->
name|spdm_table
index|[
name|spdm_entry
index|]
operator|->
name|in_use
operator|=
literal|0
expr_stmt|;
name|xge_os_spin_unlock
argument_list|(
operator|&
name|hldev
operator|->
name|spdm_lock
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_OK
return|;
name|err_exit
label|:
name|xge_os_spin_unlock
argument_list|(
operator|&
name|hldev
operator|->
name|spdm_lock
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_ERR_SPDM_TABLE_DATA_INCONSISTENT
return|;
block|}
end_function

begin_comment
comment|/*  * __hal_device_rti_set  * @ring: The post_qid of the ring.  * @channel: HAL channel of the ring.  *  * This function stores the RTI value associated for the MSI and  * also unmasks this particular RTI in the rti_mask register.  */
end_comment

begin_function
specifier|static
name|void
name|__hal_device_rti_set
parameter_list|(
name|int
name|ring_qid
parameter_list|,
name|xge_hal_channel_t
modifier|*
name|channel
parameter_list|)
block|{
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|channel
operator|->
name|devh
decl_stmt|;
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
if|if
condition|(
name|hldev
operator|->
name|config
operator|.
name|intr_mode
operator|==
name|XGE_HAL_INTR_MODE_MSI
operator|||
name|hldev
operator|->
name|config
operator|.
name|intr_mode
operator|==
name|XGE_HAL_INTR_MODE_MSIX
condition|)
name|channel
operator|->
name|rti
operator|=
operator|(
name|u8
operator|)
name|ring_qid
expr_stmt|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|rx_traffic_mask
argument_list|)
expr_stmt|;
name|val64
operator|&=
operator|~
name|BIT
argument_list|(
name|ring_qid
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_traffic_mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * __hal_device_tti_set  * @ring: The post_qid of the FIFO.  * @channel: HAL channel the FIFO.  *  * This function stores the TTI value associated for the MSI and  * also unmasks this particular TTI in the tti_mask register.  */
end_comment

begin_function
specifier|static
name|void
name|__hal_device_tti_set
parameter_list|(
name|int
name|fifo_qid
parameter_list|,
name|xge_hal_channel_t
modifier|*
name|channel
parameter_list|)
block|{
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|channel
operator|->
name|devh
decl_stmt|;
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
if|if
condition|(
name|hldev
operator|->
name|config
operator|.
name|intr_mode
operator|==
name|XGE_HAL_INTR_MODE_MSI
operator|||
name|hldev
operator|->
name|config
operator|.
name|intr_mode
operator|==
name|XGE_HAL_INTR_MODE_MSIX
condition|)
name|channel
operator|->
name|tti
operator|=
operator|(
name|u8
operator|)
name|fifo_qid
expr_stmt|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|tx_traffic_mask
argument_list|)
expr_stmt|;
name|val64
operator|&=
operator|~
name|BIT
argument_list|(
name|fifo_qid
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|tx_traffic_mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_channel_msi_set - Associate a RTI with a ring or TTI with a  * FIFO for a given MSI.  * @channelh: HAL channel handle.  * @msi: MSI Number associated with the channel.  * @msi_msg: The MSI message associated with the MSI number above.  *  * This API will associate a given channel (either Ring or FIFO) with the  * given MSI number. It will alo program the Tx_Mat/Rx_Mat tables in the  * hardware to indicate this association to the hardware.  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_channel_msi_set
parameter_list|(
name|xge_hal_channel_h
name|channelh
parameter_list|,
name|int
name|msi
parameter_list|,
name|u32
name|msi_msg
parameter_list|)
block|{
name|xge_hal_channel_t
modifier|*
name|channel
init|=
operator|(
name|xge_hal_channel_t
operator|*
operator|)
name|channelh
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|channel
operator|->
name|devh
decl_stmt|;
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
name|channel
operator|->
name|msi_msg
operator|=
name|msi_msg
expr_stmt|;
if|if
condition|(
name|channel
operator|->
name|type
operator|==
name|XGE_HAL_CHANNEL_TYPE_RING
condition|)
block|{
name|int
name|ring
init|=
name|channel
operator|->
name|post_qid
decl_stmt|;
name|xge_debug_osdep
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"MSI Data: 0x%4x, Ring: %d,"
literal|" MSI: %d"
argument_list|,
name|channel
operator|->
name|msi_msg
argument_list|,
name|ring
argument_list|,
name|msi
argument_list|)
expr_stmt|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|rx_mat
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_SET_RX_MAT
argument_list|(
name|ring
argument_list|,
name|msi
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_mat
argument_list|)
expr_stmt|;
name|__hal_device_rti_set
argument_list|(
name|ring
argument_list|,
name|channel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|fifo
init|=
name|channel
operator|->
name|post_qid
decl_stmt|;
name|xge_debug_osdep
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"MSI Data: 0x%4x, Fifo: %d,"
literal|" MSI: %d"
argument_list|,
name|channel
operator|->
name|msi_msg
argument_list|,
name|fifo
argument_list|,
name|msi
argument_list|)
expr_stmt|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|tx_mat
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_SET_TX_MAT
argument_list|(
name|fifo
argument_list|,
name|msi
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|tx_mat
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|__hal_device_tti_set
argument_list|(
name|fifo
argument_list|,
name|channel
argument_list|)
expr_stmt|;
block|}
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_mask_msix - Begin IRQ processing.  * @hldev: HAL device handle.  * @msi_id:  MSI ID  *  * The function masks the msix interrupt for the given msi_id  *  * Note:  *  * Returns: 0,  * Otherwise, XGE_HAL_ERR_WRONG_IRQ if the msix index is out of range  * status.  * See also:  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_mask_msix
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|,
name|int
name|msi_id
parameter_list|)
block|{
name|xge_hal_status_e
name|status
init|=
name|XGE_HAL_OK
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
name|u32
modifier|*
name|bar2
init|=
operator|(
name|u32
operator|*
operator|)
name|hldev
operator|->
name|bar2
decl_stmt|;
name|u32
name|val32
decl_stmt|;
name|xge_assert
argument_list|(
name|msi_id
operator|<
name|XGE_HAL_MAX_MSIX_MESSAGES
argument_list|)
expr_stmt|;
name|val32
operator|=
name|xge_os_pio_mem_read32
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh2
argument_list|,
operator|&
name|bar2
index|[
name|msi_id
operator|*
literal|4
operator|+
literal|3
index|]
argument_list|)
expr_stmt|;
name|val32
operator||=
literal|1
expr_stmt|;
name|xge_os_pio_mem_write32
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh2
argument_list|,
name|val32
argument_list|,
operator|&
name|bar2
index|[
name|msi_id
operator|*
literal|4
operator|+
literal|3
index|]
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_mask_msix - Begin IRQ processing.  * @hldev: HAL device handle.  * @msi_id:  MSI ID  *  * The function masks the msix interrupt for the given msi_id  *  * Note:  *  * Returns: 0,  * Otherwise, XGE_HAL_ERR_WRONG_IRQ if the msix index is out of range  * status.  * See also:  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_unmask_msix
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|,
name|int
name|msi_id
parameter_list|)
block|{
name|xge_hal_status_e
name|status
init|=
name|XGE_HAL_OK
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
name|u32
modifier|*
name|bar2
init|=
operator|(
name|u32
operator|*
operator|)
name|hldev
operator|->
name|bar2
decl_stmt|;
name|u32
name|val32
decl_stmt|;
name|xge_assert
argument_list|(
name|msi_id
operator|<
name|XGE_HAL_MAX_MSIX_MESSAGES
argument_list|)
expr_stmt|;
name|val32
operator|=
name|xge_os_pio_mem_read32
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh2
argument_list|,
operator|&
name|bar2
index|[
name|msi_id
operator|*
literal|4
operator|+
literal|3
index|]
argument_list|)
expr_stmt|;
name|val32
operator|&=
operator|~
literal|1
expr_stmt|;
name|xge_os_pio_mem_write32
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh2
argument_list|,
name|val32
argument_list|,
operator|&
name|bar2
index|[
name|msi_id
operator|*
literal|4
operator|+
literal|3
index|]
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/*  * __hal_set_msix_vals  * @devh: HAL device handle.  * @msix_value: 32bit MSI-X value transferred across PCI to @msix_address.  *              Filled in by this function.  * @msix_address: 32bit MSI-X DMA address.  *              Filled in by this function.  * @msix_idx: index that corresponds to the (@msix_value, @msix_address)  *            entry in the table of MSI-X (value, address) pairs.  *  * This function will program the hardware associating the given  * address/value cobination to the specified msi number.  */
end_comment

begin_function
specifier|static
name|void
name|__hal_set_msix_vals
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|,
name|u32
modifier|*
name|msix_value
parameter_list|,
name|u64
modifier|*
name|msix_addr
parameter_list|,
name|int
name|msix_idx
parameter_list|)
block|{
name|int
name|cnt
init|=
literal|0
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
name|val64
operator|=
name|XGE_HAL_XMSI_NO
argument_list|(
name|msix_idx
argument_list|)
operator||
name|XGE_HAL_XMSI_STROBE
expr_stmt|;
name|__hal_pio_mem_write32_upper
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
call|(
name|u32
call|)
argument_list|(
name|val64
operator|>>
literal|32
argument_list|)
argument_list|,
operator|&
name|bar0
operator|->
name|xmsi_access
argument_list|)
expr_stmt|;
name|__hal_pio_mem_write32_lower
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
call|(
name|u32
call|)
argument_list|(
name|val64
argument_list|)
argument_list|,
operator|&
name|bar0
operator|->
name|xmsi_access
argument_list|)
expr_stmt|;
do|do
block|{
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|xmsi_access
argument_list|)
expr_stmt|;
if|if
condition|(
name|val64
operator|&
name|XGE_HAL_XMSI_STROBE
condition|)
break|break;
name|cnt
operator|++
expr_stmt|;
name|xge_os_mdelay
argument_list|(
literal|20
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|cnt
operator|<
literal|5
condition|)
do|;
operator|*
name|msix_value
operator|=
call|(
name|u32
call|)
argument_list|(
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|xmsi_data
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|msix_addr
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|xmsi_address
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_channel_msix_set - Associate MSI-X with a channel.  * @channelh: HAL channel handle.  * @msix_idx: index that corresponds to a particular (@msix_value,  *            @msix_address) entry in the MSI-X table.  *  * This API associates a given channel (either Ring or FIFO) with the  * given MSI-X number. It programs the Xframe's Tx_Mat/Rx_Mat tables  * to indicate this association.  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_channel_msix_set
parameter_list|(
name|xge_hal_channel_h
name|channelh
parameter_list|,
name|int
name|msix_idx
parameter_list|)
block|{
name|xge_hal_channel_t
modifier|*
name|channel
init|=
operator|(
name|xge_hal_channel_t
operator|*
operator|)
name|channelh
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|channel
operator|->
name|devh
decl_stmt|;
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
if|if
condition|(
name|channel
operator|->
name|type
operator|==
name|XGE_HAL_CHANNEL_TYPE_RING
condition|)
block|{
comment|/* Currently Ring and RTI is one on one. */
name|int
name|ring
init|=
name|channel
operator|->
name|post_qid
decl_stmt|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|rx_mat
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_SET_RX_MAT
argument_list|(
name|ring
argument_list|,
name|msix_idx
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_mat
argument_list|)
expr_stmt|;
name|__hal_device_rti_set
argument_list|(
name|ring
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|hldev
operator|->
name|config
operator|.
name|fifo
operator|.
name|queue
index|[
name|channel
operator|->
name|post_qid
index|]
operator|.
name|intr_vector
operator|=
name|msix_idx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|channel
operator|->
name|type
operator|==
name|XGE_HAL_CHANNEL_TYPE_FIFO
condition|)
block|{
name|int
name|fifo
init|=
name|channel
operator|->
name|post_qid
decl_stmt|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|tx_mat
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_SET_TX_MAT
argument_list|(
name|fifo
argument_list|,
name|msix_idx
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|tx_mat
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|__hal_device_tti_set
argument_list|(
name|fifo
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|hldev
operator|->
name|config
operator|.
name|ring
operator|.
name|queue
index|[
name|channel
operator|->
name|post_qid
index|]
operator|.
name|intr_vector
operator|=
name|msix_idx
expr_stmt|;
block|}
name|channel
operator|->
name|msix_idx
operator|=
name|msix_idx
expr_stmt|;
name|__hal_set_msix_vals
argument_list|(
name|hldev
argument_list|,
operator|&
name|channel
operator|->
name|msix_data
argument_list|,
operator|&
name|channel
operator|->
name|msix_address
argument_list|,
name|channel
operator|->
name|msix_idx
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|XGE_HAL_CONFIG_LRO
argument_list|)
end_if

begin_comment
comment|/**  * xge_hal_lro_terminate - Terminate lro resources.  * @lro_scale: Amount of  lro memory.  * @hldev: Hal device structure.  *  */
end_comment

begin_function
name|void
name|xge_hal_lro_terminate
parameter_list|(
name|u32
name|lro_scale
parameter_list|,
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{ }
end_function

begin_comment
comment|/**  * xge_hal_lro_init - Initiate lro resources.  * @lro_scale: Amount of  lro memory.  * @hldev: Hal device structure.  * Note: For time being I am using only one LRO per device. Later on size  * will be increased.  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_lro_init
parameter_list|(
name|u32
name|lro_scale
parameter_list|,
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|hldev
operator|->
name|config
operator|.
name|lro_sg_size
operator|==
name|XGE_HAL_DEFAULT_USE_HARDCODE
condition|)
name|hldev
operator|->
name|config
operator|.
name|lro_sg_size
operator|=
name|XGE_HAL_LRO_DEFAULT_SG_SIZE
expr_stmt|;
if|if
condition|(
name|hldev
operator|->
name|config
operator|.
name|lro_frm_len
operator|==
name|XGE_HAL_DEFAULT_USE_HARDCODE
condition|)
name|hldev
operator|->
name|config
operator|.
name|lro_frm_len
operator|=
name|XGE_HAL_LRO_DEFAULT_FRM_LEN
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XGE_HAL_MAX_RING_NUM
condition|;
name|i
operator|++
control|)
block|{
name|xge_os_memzero
argument_list|(
name|hldev
operator|->
name|lro_desc
index|[
name|i
index|]
operator|.
name|lro_pool
argument_list|,
sizeof|sizeof
argument_list|(
name|lro_t
argument_list|)
operator|*
name|XGE_HAL_LRO_MAX_BUCKETS
argument_list|)
expr_stmt|;
name|hldev
operator|->
name|lro_desc
index|[
name|i
index|]
operator|.
name|lro_next_idx
operator|=
literal|0
expr_stmt|;
name|hldev
operator|->
name|lro_desc
index|[
name|i
index|]
operator|.
name|lro_recent
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * xge_hal_device_poll - HAL device "polling" entry point.  * @devh: HAL device.  *  * HAL "polling" entry point. Note that this is part of HAL public API.  * Upper-Layer driver _must_ periodically poll HAL via  * xge_hal_device_poll().  *  * HAL uses caller's execution context to serially process accumulated  * slow-path events, such as link state changes and hardware error  * indications.  *  * The rate of polling could be somewhere between 500us to 10ms,  * depending on requirements (e.g., the requirement to support fail-over  * could mean that 500us or even 100us polling interval need to be used).  *  * The need and motivation for external polling includes  *  *   - remove the error-checking "burden" from the HAL interrupt handler  *     (see xge_hal_device_handle_irq());  *  *   - remove the potential source of portability issues by _not_  *     implementing separate polling thread within HAL itself.  *  * See also: xge_hal_event_e{}, xge_hal_driver_config_t{}.  * Usage: See ex_slow_path{}.  */
end_comment

begin_function
name|void
name|xge_hal_device_poll
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|)
block|{
name|unsigned
name|char
name|item_buf
index|[
sizeof|sizeof
argument_list|(
name|xge_queue_item_t
argument_list|)
operator|+
name|XGE_DEFAULT_EVENT_MAX_DATA_SIZE
index|]
decl_stmt|;
name|xge_queue_item_t
modifier|*
name|item
init|=
operator|(
name|xge_queue_item_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|item_buf
decl_stmt|;
name|xge_queue_status_e
name|qstatus
decl_stmt|;
name|xge_hal_status_e
name|hstatus
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|queue_has_critical_event
init|=
literal|0
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
name|xge_os_memzero
argument_list|(
name|item_buf
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|xge_queue_item_t
argument_list|)
operator|+
name|XGE_DEFAULT_EVENT_MAX_DATA_SIZE
operator|)
argument_list|)
expr_stmt|;
name|_again
label|:
if|if
condition|(
operator|!
name|hldev
operator|->
name|is_initialized
operator|||
name|hldev
operator|->
name|terminating
operator|||
name|hldev
operator|->
name|magic
operator|!=
name|XGE_HAL_MAGIC
condition|)
return|return;
if|if
condition|(
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_err_stats
operator|.
name|xpak_counter
operator|.
name|tick_period
operator|<
literal|72000
condition|)
block|{
comment|/* 	     * Wait for an Hour 	     */
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_err_stats
operator|.
name|xpak_counter
operator|.
name|tick_period
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * Logging Error messages in the excess temperature, 	     * Bias current, laser ouput for three cycle 	     */
name|__hal_updt_stats_xpak
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_err_stats
operator|.
name|xpak_counter
operator|.
name|tick_period
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|queue_has_critical_event
condition|)
name|queue_has_critical_event
operator|=
name|__queue_get_reset_critical
argument_list|(
name|hldev
operator|->
name|queueh
argument_list|)
expr_stmt|;
name|hldev
operator|->
name|in_poll
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|++
operator|<
name|XGE_HAL_DRIVER_QUEUE_CONSUME_MAX
operator|||
name|queue_has_critical_event
condition|)
block|{
name|qstatus
operator|=
name|xge_queue_consume
argument_list|(
name|hldev
operator|->
name|queueh
argument_list|,
name|XGE_DEFAULT_EVENT_MAX_DATA_SIZE
argument_list|,
name|item
argument_list|)
expr_stmt|;
if|if
condition|(
name|qstatus
operator|==
name|XGE_QUEUE_IS_EMPTY
condition|)
break|break;
name|xge_debug_queue
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"queueh 0x"
name|XGE_OS_LLXFMT
literal|" consumed event: %d ctxt 0x"
name|XGE_OS_LLXFMT
argument_list|,
operator|(
name|u64
operator|)
operator|(
name|ulong_t
operator|)
name|hldev
operator|->
name|queueh
argument_list|,
name|item
operator|->
name|event_type
argument_list|,
operator|(
name|u64
operator|)
operator|(
name|ulong_t
operator|)
name|item
operator|->
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hldev
operator|->
name|is_initialized
operator|||
name|hldev
operator|->
name|magic
operator|!=
name|XGE_HAL_MAGIC
condition|)
block|{
name|hldev
operator|->
name|in_poll
operator|=
literal|0
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|item
operator|->
name|event_type
condition|)
block|{
case|case
name|XGE_HAL_EVENT_LINK_IS_UP
case|:
block|{
if|if
condition|(
operator|!
name|queue_has_critical_event
operator|&&
name|g_xge_hal_driver
operator|->
name|uld_callbacks
operator|.
name|link_up
condition|)
block|{
name|g_xge_hal_driver
operator|->
name|uld_callbacks
operator|.
name|link_up
argument_list|(
name|hldev
operator|->
name|upper_layer_info
argument_list|)
expr_stmt|;
name|hldev
operator|->
name|link_state
operator|=
name|XGE_HAL_LINK_UP
expr_stmt|;
block|}
block|}
break|break;
case|case
name|XGE_HAL_EVENT_LINK_IS_DOWN
case|:
block|{
if|if
condition|(
operator|!
name|queue_has_critical_event
operator|&&
name|g_xge_hal_driver
operator|->
name|uld_callbacks
operator|.
name|link_down
condition|)
block|{
name|g_xge_hal_driver
operator|->
name|uld_callbacks
operator|.
name|link_down
argument_list|(
name|hldev
operator|->
name|upper_layer_info
argument_list|)
expr_stmt|;
name|hldev
operator|->
name|link_state
operator|=
name|XGE_HAL_LINK_DOWN
expr_stmt|;
block|}
block|}
break|break;
case|case
name|XGE_HAL_EVENT_SERR
case|:
case|case
name|XGE_HAL_EVENT_ECCERR
case|:
case|case
name|XGE_HAL_EVENT_PARITYERR
case|:
case|case
name|XGE_HAL_EVENT_TARGETABORT
case|:
case|case
name|XGE_HAL_EVENT_SLOT_FREEZE
case|:
block|{
name|void
modifier|*
name|item_data
init|=
name|xge_queue_item_data
argument_list|(
name|item
argument_list|)
decl_stmt|;
name|xge_hal_event_e
name|event_type
init|=
name|item
operator|->
name|event_type
decl_stmt|;
name|u64
name|val64
init|=
operator|*
operator|(
operator|(
name|u64
operator|*
operator|)
name|item_data
operator|)
decl_stmt|;
if|if
condition|(
name|event_type
operator|!=
name|XGE_HAL_EVENT_SLOT_FREEZE
condition|)
if|if
condition|(
name|xge_hal_device_is_slot_freeze
argument_list|(
name|hldev
argument_list|)
condition|)
name|event_type
operator|=
name|XGE_HAL_EVENT_SLOT_FREEZE
expr_stmt|;
if|if
condition|(
name|g_xge_hal_driver
operator|->
name|uld_callbacks
operator|.
name|crit_err
condition|)
block|{
name|g_xge_hal_driver
operator|->
name|uld_callbacks
operator|.
name|crit_err
argument_list|(
name|hldev
operator|->
name|upper_layer_info
argument_list|,
name|event_type
argument_list|,
name|val64
argument_list|)
expr_stmt|;
comment|/* handle one critical event per poll cycle */
name|hldev
operator|->
name|in_poll
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
break|break;
default|default:
block|{
name|xge_debug_queue
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"got non-HAL event %d"
argument_list|,
name|item
operator|->
name|event_type
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* broadcast this event */
if|if
condition|(
name|g_xge_hal_driver
operator|->
name|uld_callbacks
operator|.
name|event
condition|)
name|g_xge_hal_driver
operator|->
name|uld_callbacks
operator|.
name|event
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|g_xge_hal_driver
operator|->
name|uld_callbacks
operator|.
name|before_device_poll
condition|)
block|{
if|if
condition|(
name|g_xge_hal_driver
operator|->
name|uld_callbacks
operator|.
name|before_device_poll
argument_list|(
name|hldev
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|hldev
operator|->
name|in_poll
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
name|hstatus
operator|=
name|__hal_device_poll
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_xge_hal_driver
operator|->
name|uld_callbacks
operator|.
name|after_device_poll
condition|)
name|g_xge_hal_driver
operator|->
name|uld_callbacks
operator|.
name|after_device_poll
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
comment|/* 	 * handle critical error right away: 	 * - walk the device queue again 	 * - drop non-critical events, if any 	 * - look for the 1st critical 	 */
if|if
condition|(
name|hstatus
operator|==
name|XGE_HAL_ERR_CRITICAL
condition|)
block|{
name|queue_has_critical_event
operator|=
literal|1
expr_stmt|;
goto|goto
name|_again
goto|;
block|}
name|hldev
operator|->
name|in_poll
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_rts_rth_init - Set enhanced mode for  RTS hashing.  * @hldev: HAL device handle.  *  * This function is used to set the adapter to enhanced mode.  *  * See also: xge_hal_rts_rth_clr(), xge_hal_rts_rth_set().  */
end_comment

begin_function
name|void
name|xge_hal_rts_rth_init
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
comment|/* 	 * Set the receive traffic steering mode from default(classic) 	 * to enhanced. 	 */
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|rts_ctrl
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_RTS_CTRL_ENHANCED_MODE
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rts_ctrl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_rts_rth_clr - Clear RTS hashing.  * @hldev: HAL device handle.  *  * This function is used to clear all RTS hashing related stuff.  * It brings the adapter out from enhanced mode to classic mode.  * It also clears RTS_RTH_CFG register i.e clears hash type, function etc.  *  * See also: xge_hal_rts_rth_set(), xge_hal_rts_rth_itable_set().  */
end_comment

begin_function
name|void
name|xge_hal_rts_rth_clr
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
comment|/* 	 * Set the receive traffic steering mode from default(classic) 	 * to enhanced. 	 */
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|rts_ctrl
argument_list|)
expr_stmt|;
name|val64
operator|&=
operator|~
name|XGE_HAL_RTS_CTRL_ENHANCED_MODE
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rts_ctrl
argument_list|)
expr_stmt|;
name|val64
operator|=
literal|0
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rts_rth_cfg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_rts_rth_set - Set/configure RTS hashing.  * @hldev: HAL device handle.  * @def_q: default queue  * @hash_type: hash type i.e TcpIpV4, TcpIpV6 etc.  * @bucket_size: no of least significant bits to be used for hashing.  *  * Used to set/configure all RTS hashing related stuff.  * - set the steering mode to enhanced.  * - set hash function i.e algo selection.  * - set the default queue.  *  * See also: xge_hal_rts_rth_clr(), xge_hal_rts_rth_itable_set().  */
end_comment

begin_function
name|void
name|xge_hal_rts_rth_set
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|,
name|u8
name|def_q
parameter_list|,
name|u64
name|hash_type
parameter_list|,
name|u16
name|bucket_size
parameter_list|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
name|val64
operator|=
name|XGE_HAL_RTS_DEFAULT_Q
argument_list|(
name|def_q
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rts_default_q
argument_list|)
expr_stmt|;
name|val64
operator|=
name|hash_type
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_RTS_RTH_EN
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_RTS_RTH_BUCKET_SIZE
argument_list|(
name|bucket_size
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_RTS_RTH_ALG_SEL_MS
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rts_rth_cfg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_rts_rth_start - Start RTS hashing.  * @hldev: HAL device handle.  *  * Used to Start RTS hashing .  *  * See also: xge_hal_rts_rth_clr(), xge_hal_rts_rth_itable_set(), xge_hal_rts_rth_start.  */
end_comment

begin_function
name|void
name|xge_hal_rts_rth_start
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|rts_rth_cfg
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_RTS_RTH_EN
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rts_rth_cfg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_rts_rth_stop - Stop the RTS hashing.  * @hldev: HAL device handle.  *  * Used to Staop RTS hashing .  *  * See also: xge_hal_rts_rth_clr(), xge_hal_rts_rth_itable_set(), xge_hal_rts_rth_start.  */
end_comment

begin_function
name|void
name|xge_hal_rts_rth_stop
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|rts_rth_cfg
argument_list|)
expr_stmt|;
name|val64
operator|&=
operator|~
name|XGE_HAL_RTS_RTH_EN
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rts_rth_cfg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_rts_rth_itable_set - Set/configure indirection table (IT).  * @hldev: HAL device handle.  * @itable: Pointer to the indirection table  * @itable_size: no of least significant bits to be used for hashing  *  * Used to set/configure indirection table.  * It enables the required no of entries in the IT.  * It adds entries to the IT.  *  * See also: xge_hal_rts_rth_clr(), xge_hal_rts_rth_set().  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_rts_rth_itable_set
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|,
name|u8
modifier|*
name|itable
parameter_list|,
name|u32
name|itable_size
parameter_list|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
name|u32
name|idx
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|itable_size
condition|;
name|idx
operator|++
control|)
block|{
name|val64
operator|=
name|XGE_HAL_RTS_RTH_MAP_MEM_DATA_ENTRY_EN
operator||
name|XGE_HAL_RTS_RTH_MAP_MEM_DATA
argument_list|(
name|itable
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rts_rth_map_mem_data
argument_list|)
expr_stmt|;
comment|/* execute */
name|val64
operator|=
operator|(
name|XGE_HAL_RTS_RTH_MAP_MEM_CTRL_WE
operator||
name|XGE_HAL_RTS_RTH_MAP_MEM_CTRL_STROBE
operator||
name|XGE_HAL_RTS_RTH_MAP_MEM_CTRL_OFFSET
argument_list|(
name|idx
argument_list|)
operator|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rts_rth_map_mem_ctrl
argument_list|)
expr_stmt|;
comment|/* poll until done */
if|if
condition|(
name|__hal_device_register_poll
argument_list|(
name|hldev
argument_list|,
operator|&
name|bar0
operator|->
name|rts_rth_map_mem_ctrl
argument_list|,
literal|0
argument_list|,
name|XGE_HAL_RTS_RTH_MAP_MEM_CTRL_STROBE
argument_list|,
name|XGE_HAL_DEVICE_CMDMEM_WAIT_MAX_MILLIS
argument_list|)
operator|!=
name|XGE_HAL_OK
condition|)
block|{
comment|/* upper layer may require to repeat */
return|return
name|XGE_HAL_INF_MEM_STROBE_CMD_EXECUTING
return|;
block|}
block|}
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_device_rts_rth_key_set - Configure 40byte secret for hash calc.  *  * @hldev: HAL device handle.  * @KeySize: Number of 64-bit words  * @Key: upto 40-byte array of 8-bit values  * This function configures the 40-byte secret which is used for hash  * calculation.  *  * See also: xge_hal_rts_rth_clr(), xge_hal_rts_rth_set().  */
end_comment

begin_function
name|void
name|xge_hal_device_rts_rth_key_set
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|,
name|u8
name|KeySize
parameter_list|,
name|u8
modifier|*
name|Key
parameter_list|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
name|u32
name|entry
decl_stmt|,
name|nreg
decl_stmt|,
name|i
decl_stmt|;
name|entry
operator|=
literal|0
expr_stmt|;
name|nreg
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|KeySize
condition|)
block|{
name|val64
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
comment|/* Prepare 64-bit word for 'nreg' containing 8 keys. */
if|if
condition|(
name|i
condition|)
name|val64
operator|<<=
literal|8
expr_stmt|;
name|val64
operator||=
name|Key
index|[
name|entry
operator|++
index|]
expr_stmt|;
block|}
name|KeySize
operator|--
expr_stmt|;
comment|/* temp64 = XGE_HAL_RTH_HASH_MASK_n(val64, (n<<3), (n<<3)+7);*/
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rts_rth_hash_mask
index|[
name|nreg
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|nreg
operator|<
literal|5
condition|)
block|{
comment|/* Clear the rest if key is less than 40 bytes */
name|val64
operator|=
literal|0
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rts_rth_hash_mask
index|[
name|nreg
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * xge_hal_device_is_closed - Device is closed  *  * @devh: HAL device handle.  */
end_comment

begin_function
name|int
name|xge_hal_device_is_closed
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|)
block|{
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
if|if
condition|(
name|xge_list_is_empty
argument_list|(
operator|&
name|hldev
operator|->
name|fifo_channels
argument_list|)
operator|&&
name|xge_list_is_empty
argument_list|(
operator|&
name|hldev
operator|->
name|ring_channels
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|xge_hal_status_e
name|xge_hal_device_rts_section_enable
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|u64
name|val64
decl_stmt|;
name|int
name|section
decl_stmt|;
name|int
name|max_addr
init|=
name|XGE_HAL_MAX_MAC_ADDRESSES
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
if|if
condition|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_HERC
condition|)
name|max_addr
operator|=
name|XGE_HAL_MAX_MAC_ADDRESSES_HERC
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|max_addr
condition|)
return|return
name|XGE_HAL_ERR_OUT_OF_MAC_ADDRESSES
return|;
comment|/* 	 * Calculate the section value 	 */
name|section
operator|=
name|index
operator|/
literal|32
expr_stmt|;
name|xge_debug_device
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"the Section value is %d "
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|rts_mac_cfg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|section
condition|)
block|{
case|case
literal|0
case|:
name|val64
operator||=
name|XGE_HAL_RTS_MAC_SECT0_EN
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|val64
operator||=
name|XGE_HAL_RTS_MAC_SECT1_EN
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|val64
operator||=
name|XGE_HAL_RTS_MAC_SECT2_EN
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|val64
operator||=
name|XGE_HAL_RTS_MAC_SECT3_EN
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|val64
operator||=
name|XGE_HAL_RTS_MAC_SECT4_EN
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|val64
operator||=
name|XGE_HAL_RTS_MAC_SECT5_EN
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|val64
operator||=
name|XGE_HAL_RTS_MAC_SECT6_EN
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|val64
operator||=
name|XGE_HAL_RTS_MAC_SECT7_EN
expr_stmt|;
break|break;
default|default:
name|xge_debug_device
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Invalid Section value %d "
argument_list|,
name|section
argument_list|)
expr_stmt|;
block|}
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rts_mac_cfg
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_fix_rldram_ecc_error  * @hldev: private member of the device structure.  *  * SXE-02-010. This function will turn OFF the ECC error reporting for the   * interface bet'n external Micron RLDRAM II device and memory controller.  * The error would have been reported in RLD_ECC_DB_ERR_L and RLD_ECC_DB_ERR_U  * fields of MC_ERR_REG register. Issue reported by HP-Unix folks during the  * qualification of Herc.   */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_fix_rldram_ecc_error
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
comment|// Enter Test Mode.
name|val64
operator|=
name|XGE_HAL_MC_RLDRAM_TEST_MODE
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|mc_rldram_test_ctrl
argument_list|)
expr_stmt|;
comment|// Enable fg/bg tests.
name|val64
operator|=
literal|0x0100000000000000ULL
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|mc_driver
argument_list|)
expr_stmt|;
comment|// Enable RLDRAM configuration.
name|val64
operator|=
literal|0x0000000000017B00ULL
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|mc_rldram_mrs
argument_list|)
expr_stmt|;
comment|// Enable RLDRAM queues.
name|val64
operator|=
literal|0x0000000001017B00ULL
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|mc_rldram_mrs
argument_list|)
expr_stmt|;
comment|// Setup test ranges
name|val64
operator|=
literal|0x00000000001E0100ULL
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|mc_rldram_test_add
argument_list|)
expr_stmt|;
name|val64
operator|=
literal|0x00000100001F0100ULL
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|mc_rldram_test_add_bkg
argument_list|)
expr_stmt|;
comment|// Start Reads.
name|val64
operator|=
literal|0x0001000000010000ULL
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|mc_rldram_test_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|__hal_device_register_poll
argument_list|(
name|hldev
argument_list|,
operator|&
name|bar0
operator|->
name|mc_rldram_test_ctrl
argument_list|,
literal|1
argument_list|,
name|XGE_HAL_MC_RLDRAM_TEST_DONE
argument_list|,
name|XGE_HAL_DEVICE_CMDMEM_WAIT_MAX_MILLIS
argument_list|)
operator|!=
name|XGE_HAL_OK
condition|)
block|{
return|return
name|XGE_HAL_INF_MEM_STROBE_CMD_EXECUTING
return|;
block|}
comment|// Exit test mode
name|val64
operator|=
literal|0x0000000000000000ULL
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|mc_rldram_test_ctrl
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

end_unit

