begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002-2007 Neterion, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<dev/nxge/include/xgehal-mgmt.h>
end_include

begin_include
include|#
directive|include
file|<dev/nxge/include/xgehal-driver.h>
end_include

begin_include
include|#
directive|include
file|<dev/nxge/include/xgehal-device.h>
end_include

begin_comment
comment|/**  * xge_hal_mgmt_about - Retrieve about info.  * @devh: HAL device handle.  * @about_info: Filled in by HAL. See xge_hal_mgmt_about_info_t{}.  * @size: Size of the @about_info buffer. HAL will return error if the  *        size is smaller than sizeof(xge_hal_mgmt_about_info_t).  *  * Retrieve information such as PCI device and vendor IDs, board  * revision number, HAL version number, etc.  *  * Returns: XGE_HAL_OK - success;  * XGE_HAL_ERR_INVALID_DEVICE - Device is not valid.  * XGE_HAL_ERR_VERSION_CONFLICT - Version it not maching.  * XGE_HAL_FAIL - Failed to retrieve the information.  *  * See also: xge_hal_mgmt_about_info_t{}.  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_mgmt_about
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|,
name|xge_hal_mgmt_about_info_t
modifier|*
name|about_info
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
if|if
condition|(
operator|(
name|hldev
operator|==
name|NULL
operator|)
operator|||
operator|(
name|hldev
operator|->
name|magic
operator|!=
name|XGE_HAL_MAGIC
operator|)
condition|)
block|{
return|return
name|XGE_HAL_ERR_INVALID_DEVICE
return|;
block|}
if|if
condition|(
name|size
operator|!=
sizeof|sizeof
argument_list|(
name|xge_hal_mgmt_about_info_t
argument_list|)
condition|)
block|{
return|return
name|XGE_HAL_ERR_VERSION_CONFLICT
return|;
block|}
name|xge_os_pci_read16
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_le_t
argument_list|,
name|vendor_id
argument_list|)
argument_list|,
operator|&
name|about_info
operator|->
name|vendor
argument_list|)
expr_stmt|;
name|xge_os_pci_read16
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_le_t
argument_list|,
name|device_id
argument_list|)
argument_list|,
operator|&
name|about_info
operator|->
name|device
argument_list|)
expr_stmt|;
name|xge_os_pci_read16
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_le_t
argument_list|,
name|subsystem_vendor_id
argument_list|)
argument_list|,
operator|&
name|about_info
operator|->
name|subsys_vendor
argument_list|)
expr_stmt|;
name|xge_os_pci_read16
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_le_t
argument_list|,
name|subsystem_id
argument_list|)
argument_list|,
operator|&
name|about_info
operator|->
name|subsys_device
argument_list|)
expr_stmt|;
name|xge_os_pci_read8
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_le_t
argument_list|,
name|revision
argument_list|)
argument_list|,
operator|&
name|about_info
operator|->
name|board_rev
argument_list|)
expr_stmt|;
name|xge_os_strcpy
argument_list|(
name|about_info
operator|->
name|vendor_name
argument_list|,
name|XGE_DRIVER_VENDOR
argument_list|)
expr_stmt|;
name|xge_os_strcpy
argument_list|(
name|about_info
operator|->
name|chip_name
argument_list|,
name|XGE_CHIP_FAMILY
argument_list|)
expr_stmt|;
name|xge_os_strcpy
argument_list|(
name|about_info
operator|->
name|media
argument_list|,
name|XGE_SUPPORTED_MEDIA_0
argument_list|)
expr_stmt|;
name|xge_os_strcpy
argument_list|(
name|about_info
operator|->
name|hal_major
argument_list|,
name|XGE_HAL_VERSION_MAJOR
argument_list|)
expr_stmt|;
name|xge_os_strcpy
argument_list|(
name|about_info
operator|->
name|hal_minor
argument_list|,
name|XGE_HAL_VERSION_MINOR
argument_list|)
expr_stmt|;
name|xge_os_strcpy
argument_list|(
name|about_info
operator|->
name|hal_fix
argument_list|,
name|XGE_HAL_VERSION_FIX
argument_list|)
expr_stmt|;
name|xge_os_strcpy
argument_list|(
name|about_info
operator|->
name|hal_build
argument_list|,
name|XGE_HAL_VERSION_BUILD
argument_list|)
expr_stmt|;
name|xge_os_strcpy
argument_list|(
name|about_info
operator|->
name|ll_major
argument_list|,
name|XGELL_VERSION_MAJOR
argument_list|)
expr_stmt|;
name|xge_os_strcpy
argument_list|(
name|about_info
operator|->
name|ll_minor
argument_list|,
name|XGELL_VERSION_MINOR
argument_list|)
expr_stmt|;
name|xge_os_strcpy
argument_list|(
name|about_info
operator|->
name|ll_fix
argument_list|,
name|XGELL_VERSION_FIX
argument_list|)
expr_stmt|;
name|xge_os_strcpy
argument_list|(
name|about_info
operator|->
name|ll_build
argument_list|,
name|XGELL_VERSION_BUILD
argument_list|)
expr_stmt|;
name|about_info
operator|->
name|transponder_temperature
operator|=
name|xge_hal_read_xfp_current_temp
argument_list|(
name|devh
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_mgmt_reg_read - Read Xframe register.  * @devh: HAL device handle.  * @bar_id: 0 - for BAR0, 1- for BAR1.  * @offset: Register offset in the Base Address Register (BAR) space.  * @value: Register value. Returned by HAL.  * Read Xframe register.  *  * Returns: XGE_HAL_OK - success.  * XGE_HAL_ERR_INVALID_DEVICE - Device is not valid.  * XGE_HAL_ERR_INVALID_OFFSET - Register offset in the BAR space is not  * valid.  * XGE_HAL_ERR_INVALID_BAR_ID - BAR id is not valid.  *  * See also: xge_hal_aux_bar0_read(), xge_hal_aux_bar1_read().  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_mgmt_reg_read
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|,
name|int
name|bar_id
parameter_list|,
name|unsigned
name|int
name|offset
parameter_list|,
name|u64
modifier|*
name|value
parameter_list|)
block|{
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
if|if
condition|(
operator|(
name|hldev
operator|==
name|NULL
operator|)
operator|||
operator|(
name|hldev
operator|->
name|magic
operator|!=
name|XGE_HAL_MAGIC
operator|)
condition|)
block|{
return|return
name|XGE_HAL_ERR_INVALID_DEVICE
return|;
block|}
if|if
condition|(
name|bar_id
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|offset
operator|>
sizeof|sizeof
argument_list|(
name|xge_hal_pci_bar0_t
argument_list|)
operator|-
literal|8
condition|)
block|{
return|return
name|XGE_HAL_ERR_INVALID_OFFSET
return|;
block|}
operator|*
name|value
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|hldev
operator|->
name|bar0
operator|+
name|offset
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bar_id
operator|==
literal|1
operator|&&
operator|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_XENA
operator|||
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_HERC
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XGE_HAL_MAX_FIFO_NUM_HERC
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|offset
operator|==
name|i
operator|*
literal|0x2000
operator|||
name|offset
operator|==
name|i
operator|*
literal|0x2000
operator|+
literal|0x18
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|XGE_HAL_MAX_FIFO_NUM_HERC
condition|)
block|{
return|return
name|XGE_HAL_ERR_INVALID_OFFSET
return|;
block|}
operator|*
name|value
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh1
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|hldev
operator|->
name|bar1
operator|+
name|offset
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bar_id
operator|==
literal|1
condition|)
block|{
comment|/* FIXME: check TITAN BAR1 offsets */
block|}
else|else
block|{
return|return
name|XGE_HAL_ERR_INVALID_BAR_ID
return|;
block|}
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_mgmt_reg_write - Write Xframe register.  * @devh: HAL device handle.  * @bar_id: 0 - for BAR0, 1- for BAR1.  * @offset: Register offset in the Base Address Register (BAR) space.  * @value: Register value.  *  * Write Xframe register.  *  * Returns: XGE_HAL_OK - success.  * XGE_HAL_ERR_INVALID_DEVICE - Device is not valid.  * XGE_HAL_ERR_INVALID_OFFSET - Register offset in the BAR space is not  * valid.  * XGE_HAL_ERR_INVALID_BAR_ID - BAR id is not valid.  *  * See also: xge_hal_aux_bar0_write().  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_mgmt_reg_write
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|,
name|int
name|bar_id
parameter_list|,
name|unsigned
name|int
name|offset
parameter_list|,
name|u64
name|value
parameter_list|)
block|{
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
if|if
condition|(
operator|(
name|hldev
operator|==
name|NULL
operator|)
operator|||
operator|(
name|hldev
operator|->
name|magic
operator|!=
name|XGE_HAL_MAGIC
operator|)
condition|)
block|{
return|return
name|XGE_HAL_ERR_INVALID_DEVICE
return|;
block|}
if|if
condition|(
name|bar_id
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|offset
operator|>
sizeof|sizeof
argument_list|(
name|xge_hal_pci_bar0_t
argument_list|)
operator|-
literal|8
condition|)
block|{
return|return
name|XGE_HAL_ERR_INVALID_OFFSET
return|;
block|}
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|value
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|hldev
operator|->
name|bar0
operator|+
name|offset
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bar_id
operator|==
literal|1
operator|&&
operator|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_XENA
operator|||
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_HERC
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XGE_HAL_MAX_FIFO_NUM_HERC
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|offset
operator|==
name|i
operator|*
literal|0x2000
operator|||
name|offset
operator|==
name|i
operator|*
literal|0x2000
operator|+
literal|0x18
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|XGE_HAL_MAX_FIFO_NUM_HERC
condition|)
block|{
return|return
name|XGE_HAL_ERR_INVALID_OFFSET
return|;
block|}
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh1
argument_list|,
name|value
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|hldev
operator|->
name|bar1
operator|+
name|offset
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bar_id
operator|==
literal|1
condition|)
block|{
comment|/* FIXME: check TITAN BAR1 offsets */
block|}
else|else
block|{
return|return
name|XGE_HAL_ERR_INVALID_BAR_ID
return|;
block|}
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_mgmt_hw_stats - Get Xframe hardware statistics.  * @devh: HAL device handle.  * @hw_stats: Hardware statistics. Returned by HAL.  *            See xge_hal_stats_hw_info_t{}.  * @size: Size of the @hw_stats buffer. HAL will return an error  * if the size is smaller than sizeof(xge_hal_stats_hw_info_t).  * Get Xframe hardware statistics.  *  * Returns: XGE_HAL_OK - success.  * XGE_HAL_ERR_INVALID_DEVICE - Device is not valid.  * XGE_HAL_ERR_VERSION_CONFLICT - Version it not maching.  *  * See also: xge_hal_mgmt_sw_stats().  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_mgmt_hw_stats
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|,
name|xge_hal_mgmt_hw_stats_t
modifier|*
name|hw_stats
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|xge_hal_status_e
name|status
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
name|xge_hal_stats_hw_info_t
modifier|*
name|hw_info
decl_stmt|;
name|xge_assert
argument_list|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|!=
name|XGE_HAL_CARD_TITAN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hldev
operator|==
name|NULL
operator|)
operator|||
operator|(
name|hldev
operator|->
name|magic
operator|!=
name|XGE_HAL_MAGIC
operator|)
condition|)
block|{
return|return
name|XGE_HAL_ERR_INVALID_DEVICE
return|;
block|}
if|if
condition|(
name|size
operator|!=
sizeof|sizeof
argument_list|(
name|xge_hal_stats_hw_info_t
argument_list|)
condition|)
block|{
return|return
name|XGE_HAL_ERR_VERSION_CONFLICT
return|;
block|}
if|if
condition|(
operator|(
name|status
operator|=
name|xge_hal_stats_hw
argument_list|(
name|devh
argument_list|,
operator|&
name|hw_info
argument_list|)
operator|)
operator|!=
name|XGE_HAL_OK
condition|)
block|{
return|return
name|status
return|;
block|}
name|xge_os_memcpy
argument_list|(
name|hw_stats
argument_list|,
name|hw_info
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_stats_hw_info_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_mgmt_hw_stats_off - TBD.  * @devh: HAL device handle.  * @off: TBD  * @size: TBD  * @out: TBD  *  * Returns: XGE_HAL_OK - success.  * XGE_HAL_ERR_INVALID_DEVICE - Device is not valid.  * XGE_HAL_ERR_VERSION_CONFLICT - Version it not maching.  *  * See also: xge_hal_mgmt_sw_stats().  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_mgmt_hw_stats_off
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|size
parameter_list|,
name|char
modifier|*
name|out
parameter_list|)
block|{
name|xge_hal_status_e
name|status
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
name|xge_hal_stats_hw_info_t
modifier|*
name|hw_info
decl_stmt|;
name|xge_assert
argument_list|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|!=
name|XGE_HAL_CARD_TITAN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hldev
operator|==
name|NULL
operator|)
operator|||
operator|(
name|hldev
operator|->
name|magic
operator|!=
name|XGE_HAL_MAGIC
operator|)
condition|)
block|{
return|return
name|XGE_HAL_ERR_INVALID_DEVICE
return|;
block|}
if|if
condition|(
name|off
operator|>
sizeof|sizeof
argument_list|(
name|xge_hal_stats_hw_info_t
argument_list|)
operator|-
literal|4
operator|||
name|size
operator|>
literal|8
condition|)
block|{
return|return
name|XGE_HAL_ERR_INVALID_OFFSET
return|;
block|}
if|if
condition|(
operator|(
name|status
operator|=
name|xge_hal_stats_hw
argument_list|(
name|devh
argument_list|,
operator|&
name|hw_info
argument_list|)
operator|)
operator|!=
name|XGE_HAL_OK
condition|)
block|{
return|return
name|status
return|;
block|}
name|xge_os_memcpy
argument_list|(
name|out
argument_list|,
operator|(
name|char
operator|*
operator|)
name|hw_info
operator|+
name|off
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_mgmt_pcim_stats - Get Titan hardware statistics.  * @devh: HAL device handle.  * @pcim_stats: PCIM statistics. Returned by HAL.  *            See xge_hal_stats_hw_info_t{}.  * @size: Size of the @hw_stats buffer. HAL will return an error  * if the size is smaller than sizeof(xge_hal_stats_hw_info_t).  * Get Xframe hardware statistics.  *  * Returns: XGE_HAL_OK - success.  * XGE_HAL_ERR_INVALID_DEVICE - Device is not valid.  * XGE_HAL_ERR_VERSION_CONFLICT - Version it not maching.  *  * See also: xge_hal_mgmt_sw_stats().  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_mgmt_pcim_stats
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|,
name|xge_hal_mgmt_pcim_stats_t
modifier|*
name|pcim_stats
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|xge_hal_status_e
name|status
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
name|xge_hal_stats_pcim_info_t
modifier|*
name|pcim_info
decl_stmt|;
name|xge_assert
argument_list|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_TITAN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hldev
operator|==
name|NULL
operator|)
operator|||
operator|(
name|hldev
operator|->
name|magic
operator|!=
name|XGE_HAL_MAGIC
operator|)
condition|)
block|{
return|return
name|XGE_HAL_ERR_INVALID_DEVICE
return|;
block|}
if|if
condition|(
name|size
operator|!=
sizeof|sizeof
argument_list|(
name|xge_hal_stats_pcim_info_t
argument_list|)
condition|)
block|{
return|return
name|XGE_HAL_ERR_VERSION_CONFLICT
return|;
block|}
if|if
condition|(
operator|(
name|status
operator|=
name|xge_hal_stats_pcim
argument_list|(
name|devh
argument_list|,
operator|&
name|pcim_info
argument_list|)
operator|)
operator|!=
name|XGE_HAL_OK
condition|)
block|{
return|return
name|status
return|;
block|}
name|xge_os_memcpy
argument_list|(
name|pcim_stats
argument_list|,
name|pcim_info
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_stats_pcim_info_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_mgmt_pcim_stats_off - TBD.  * @devh: HAL device handle.  * @off: TBD  * @size: TBD  * @out: TBD  *  * Returns: XGE_HAL_OK - success.  * XGE_HAL_ERR_INVALID_DEVICE - Device is not valid.  * XGE_HAL_ERR_VERSION_CONFLICT - Version it not maching.  *  * See also: xge_hal_mgmt_sw_stats().  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_mgmt_pcim_stats_off
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|size
parameter_list|,
name|char
modifier|*
name|out
parameter_list|)
block|{
name|xge_hal_status_e
name|status
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
name|xge_hal_stats_pcim_info_t
modifier|*
name|pcim_info
decl_stmt|;
name|xge_assert
argument_list|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_TITAN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hldev
operator|==
name|NULL
operator|)
operator|||
operator|(
name|hldev
operator|->
name|magic
operator|!=
name|XGE_HAL_MAGIC
operator|)
condition|)
block|{
return|return
name|XGE_HAL_ERR_INVALID_DEVICE
return|;
block|}
if|if
condition|(
name|off
operator|>
sizeof|sizeof
argument_list|(
name|xge_hal_stats_pcim_info_t
argument_list|)
operator|-
literal|8
operator|||
name|size
operator|>
literal|8
condition|)
block|{
return|return
name|XGE_HAL_ERR_INVALID_OFFSET
return|;
block|}
if|if
condition|(
operator|(
name|status
operator|=
name|xge_hal_stats_pcim
argument_list|(
name|devh
argument_list|,
operator|&
name|pcim_info
argument_list|)
operator|)
operator|!=
name|XGE_HAL_OK
condition|)
block|{
return|return
name|status
return|;
block|}
name|xge_os_memcpy
argument_list|(
name|out
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pcim_info
operator|+
name|off
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_mgmt_sw_stats - Get per-device software statistics.  * @devh: HAL device handle.  * @sw_stats: Hardware statistics. Returned by HAL.  *            See xge_hal_stats_sw_err_t{}.  * @size: Size of the @sw_stats buffer. HAL will return an error  * if the size is smaller than sizeof(xge_hal_stats_sw_err_t).  * Get device software statistics, including ECC and Parity error  * counters, etc.  *  * Returns: XGE_HAL_OK - success.  * XGE_HAL_ERR_INVALID_DEVICE - Device is not valid.  * XGE_HAL_ERR_VERSION_CONFLICT - Version it not maching.  *  * See also: xge_hal_stats_sw_err_t{}, xge_hal_mgmt_hw_stats().  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_mgmt_sw_stats
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|,
name|xge_hal_mgmt_sw_stats_t
modifier|*
name|sw_stats
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
if|if
condition|(
operator|(
name|hldev
operator|==
name|NULL
operator|)
operator|||
operator|(
name|hldev
operator|->
name|magic
operator|!=
name|XGE_HAL_MAGIC
operator|)
condition|)
block|{
return|return
name|XGE_HAL_ERR_INVALID_DEVICE
return|;
block|}
if|if
condition|(
name|size
operator|!=
sizeof|sizeof
argument_list|(
name|xge_hal_stats_sw_err_t
argument_list|)
condition|)
block|{
return|return
name|XGE_HAL_ERR_VERSION_CONFLICT
return|;
block|}
if|if
condition|(
operator|!
name|hldev
operator|->
name|stats
operator|.
name|is_initialized
operator|||
operator|!
name|hldev
operator|->
name|stats
operator|.
name|is_enabled
condition|)
block|{
return|return
name|XGE_HAL_INF_STATS_IS_NOT_READY
return|;
block|}
comment|/* Updating xpak stats value */
name|__hal_updt_stats_xpak
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
name|xge_os_memcpy
argument_list|(
name|sw_stats
argument_list|,
operator|&
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_err_stats
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_stats_sw_err_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_mgmt_device_stats - Get HAL device statistics.  * @devh: HAL device handle.  * @device_stats: HAL device "soft" statistics. Maintained by HAL itself.  *            (as opposed to xge_hal_mgmt_hw_stats() - those are  *            maintained by the Xframe hardware).  *            Returned by HAL.  *            See xge_hal_stats_device_info_t{}.  * @size: Size of the @device_stats buffer. HAL will return an error  * if the size is smaller than sizeof(xge_hal_stats_device_info_t).  *  * Get HAL (layer) statistic counters.  * Returns: XGE_HAL_OK - success.  * XGE_HAL_ERR_INVALID_DEVICE - Device is not valid.  * XGE_HAL_ERR_VERSION_CONFLICT - Version it not maching.  * XGE_HAL_INF_STATS_IS_NOT_READY - Statistics information is not  * currently available.  *  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_mgmt_device_stats
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|,
name|xge_hal_mgmt_device_stats_t
modifier|*
name|device_stats
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|xge_hal_status_e
name|status
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
name|xge_hal_stats_device_info_t
modifier|*
name|device_info
decl_stmt|;
if|if
condition|(
operator|(
name|hldev
operator|==
name|NULL
operator|)
operator|||
operator|(
name|hldev
operator|->
name|magic
operator|!=
name|XGE_HAL_MAGIC
operator|)
condition|)
block|{
return|return
name|XGE_HAL_ERR_INVALID_DEVICE
return|;
block|}
if|if
condition|(
name|size
operator|!=
sizeof|sizeof
argument_list|(
name|xge_hal_stats_device_info_t
argument_list|)
condition|)
block|{
return|return
name|XGE_HAL_ERR_VERSION_CONFLICT
return|;
block|}
if|if
condition|(
operator|(
name|status
operator|=
name|xge_hal_stats_device
argument_list|(
name|devh
argument_list|,
operator|&
name|device_info
argument_list|)
operator|)
operator|!=
name|XGE_HAL_OK
condition|)
block|{
return|return
name|status
return|;
block|}
name|xge_os_memcpy
argument_list|(
name|device_stats
argument_list|,
name|device_info
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_stats_device_info_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/*  * __hal_update_ring_bump - Update the ring bump counter for the  * particular channel.  * @hldev: HAL device handle.  * @queue: the queue who's data is to be collected.  * @chinfo: pointer to the statistics structure of the given channel.  * Usage: See xge_hal_aux_stats_hal_read{}  */
end_comment

begin_function
specifier|static
name|void
name|__hal_update_ring_bump
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|,
name|int
name|queue
parameter_list|,
name|xge_hal_stats_channel_info_t
modifier|*
name|chinfo
parameter_list|)
block|{
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|rbc
init|=
literal|0
decl_stmt|;
name|int
name|reg
init|=
operator|(
name|queue
operator|/
literal|4
operator|)
decl_stmt|;
name|void
modifier|*
name|addr
decl_stmt|;
name|addr
operator|=
operator|(
name|reg
operator|==
literal|1
operator|)
condition|?
operator|(
operator|&
name|bar0
operator|->
name|ring_bump_counter2
operator|)
else|:
operator|(
operator|&
name|bar0
operator|->
name|ring_bump_counter1
operator|)
expr_stmt|;
name|rbc
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|chinfo
operator|->
name|ring_bump_cnt
operator|=
name|XGE_HAL_RING_BUMP_CNT
argument_list|(
name|queue
argument_list|,
name|rbc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_mgmt_channel_stats - Get HAL channel statistics.  * @channelh: HAL channel handle.  * @channel_stats: HAL channel statistics. Maintained by HAL itself  *            (as opposed to xge_hal_mgmt_hw_stats() - those are  *            maintained by the Xframe hardware).  *            Returned by HAL.  *            See xge_hal_stats_channel_info_t{}.  * @size: Size of the @channel_stats buffer. HAL will return an error  * if the size is smaller than sizeof(xge_hal_mgmt_channel_stats_t).  *  * Get HAL per-channel statistic counters.  *  * Returns: XGE_HAL_OK - success.  * XGE_HAL_ERR_VERSION_CONFLICT - Version it not maching.  * XGE_HAL_INF_STATS_IS_NOT_READY - Statistics information is not  * currently available.  *  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_mgmt_channel_stats
parameter_list|(
name|xge_hal_channel_h
name|channelh
parameter_list|,
name|xge_hal_mgmt_channel_stats_t
modifier|*
name|channel_stats
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|xge_hal_status_e
name|status
decl_stmt|;
name|xge_hal_stats_channel_info_t
modifier|*
name|channel_info
decl_stmt|;
name|xge_hal_channel_t
modifier|*
name|channel
init|=
operator|(
name|xge_hal_channel_t
operator|*
operator|)
name|channelh
decl_stmt|;
if|if
condition|(
name|size
operator|!=
sizeof|sizeof
argument_list|(
name|xge_hal_stats_channel_info_t
argument_list|)
condition|)
block|{
return|return
name|XGE_HAL_ERR_VERSION_CONFLICT
return|;
block|}
if|if
condition|(
operator|(
name|status
operator|=
name|xge_hal_stats_channel
argument_list|(
name|channelh
argument_list|,
operator|&
name|channel_info
argument_list|)
operator|)
operator|!=
name|XGE_HAL_OK
condition|)
block|{
return|return
name|status
return|;
block|}
if|if
condition|(
name|xge_hal_device_check_id
argument_list|(
name|channel
operator|->
name|devh
argument_list|)
operator|==
name|XGE_HAL_CARD_HERC
condition|)
block|{
name|__hal_update_ring_bump
argument_list|(
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|channel
operator|->
name|devh
argument_list|,
name|channel
operator|->
name|post_qid
argument_list|,
name|channel_info
argument_list|)
expr_stmt|;
block|}
name|xge_os_memcpy
argument_list|(
name|channel_stats
argument_list|,
name|channel_info
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_stats_channel_info_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_mgmt_pcireg_read - Read PCI configuration at a specified  * offset.  * @devh: HAL device handle.  * @offset: Offset in the 256 byte PCI configuration space.  * @value_bits: 8, 16, or 32 (bits) to read.  * @value: Value returned by HAL.  *  * Read PCI configuration, given device and offset in the PCI space.  *  * Returns: XGE_HAL_OK - success.  * XGE_HAL_ERR_INVALID_DEVICE - Device is not valid.  * XGE_HAL_ERR_INVALID_OFFSET - Register offset in the BAR space is not  * valid.  * XGE_HAL_ERR_INVALID_VALUE_BIT_SIZE - Invalid bits size. Valid  * values(8/16/32).  *  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_mgmt_pcireg_read
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|,
name|unsigned
name|int
name|offset
parameter_list|,
name|int
name|value_bits
parameter_list|,
name|u32
modifier|*
name|value
parameter_list|)
block|{
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
if|if
condition|(
operator|(
name|hldev
operator|==
name|NULL
operator|)
operator|||
operator|(
name|hldev
operator|->
name|magic
operator|!=
name|XGE_HAL_MAGIC
operator|)
condition|)
block|{
return|return
name|XGE_HAL_ERR_INVALID_DEVICE
return|;
block|}
if|if
condition|(
name|offset
operator|>
sizeof|sizeof
argument_list|(
name|xge_hal_pci_config_t
argument_list|)
operator|-
name|value_bits
operator|/
literal|8
condition|)
block|{
return|return
name|XGE_HAL_ERR_INVALID_OFFSET
return|;
block|}
if|if
condition|(
name|value_bits
operator|==
literal|8
condition|)
block|{
name|xge_os_pci_read8
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
name|offset
argument_list|,
operator|(
name|u8
operator|*
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value_bits
operator|==
literal|16
condition|)
block|{
name|xge_os_pci_read16
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
name|offset
argument_list|,
operator|(
name|u16
operator|*
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value_bits
operator|==
literal|32
condition|)
block|{
name|xge_os_pci_read32
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
name|offset
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
name|XGE_HAL_ERR_INVALID_VALUE_BIT_SIZE
return|;
block|}
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_mgmt_device_config - Retrieve device configuration.  * @devh: HAL device handle.  * @dev_config: Device configuration, see xge_hal_device_config_t{}.  * @size: Size of the @dev_config buffer. HAL will return an error  * if the size is smaller than sizeof(xge_hal_mgmt_device_config_t).  *  * Get device configuration. Permits to retrieve at run-time configuration  * values that were used to initialize and configure the device.  *  * Returns: XGE_HAL_OK - success.  * XGE_HAL_ERR_INVALID_DEVICE - Device is not valid.  * XGE_HAL_ERR_VERSION_CONFLICT - Version it not maching.  *  * See also: xge_hal_device_config_t{}, xge_hal_mgmt_driver_config().  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_mgmt_device_config
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|,
name|xge_hal_mgmt_device_config_t
modifier|*
name|dev_config
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
if|if
condition|(
operator|(
name|hldev
operator|==
name|NULL
operator|)
operator|||
operator|(
name|hldev
operator|->
name|magic
operator|!=
name|XGE_HAL_MAGIC
operator|)
condition|)
block|{
return|return
name|XGE_HAL_ERR_INVALID_DEVICE
return|;
block|}
if|if
condition|(
name|size
operator|!=
sizeof|sizeof
argument_list|(
name|xge_hal_mgmt_device_config_t
argument_list|)
condition|)
block|{
return|return
name|XGE_HAL_ERR_VERSION_CONFLICT
return|;
block|}
name|xge_os_memcpy
argument_list|(
name|dev_config
argument_list|,
operator|&
name|hldev
operator|->
name|config
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_device_config_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_mgmt_driver_config - Retrieve driver configuration.  * @drv_config: Device configuration, see xge_hal_driver_config_t{}.  * @size: Size of the @dev_config buffer. HAL will return an error  * if the size is smaller than sizeof(xge_hal_mgmt_driver_config_t).  *  * Get driver configuration. Permits to retrieve at run-time configuration  * values that were used to configure the device at load-time.  *  * Returns: XGE_HAL_OK - success.  * XGE_HAL_ERR_DRIVER_NOT_INITIALIZED - HAL is not initialized.  * XGE_HAL_ERR_VERSION_CONFLICT - Version is not maching.  *  * See also: xge_hal_driver_config_t{}, xge_hal_mgmt_device_config().  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_mgmt_driver_config
parameter_list|(
name|xge_hal_mgmt_driver_config_t
modifier|*
name|drv_config
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|g_xge_hal_driver
operator|==
name|NULL
condition|)
block|{
return|return
name|XGE_HAL_ERR_DRIVER_NOT_INITIALIZED
return|;
block|}
if|if
condition|(
name|size
operator|!=
sizeof|sizeof
argument_list|(
name|xge_hal_mgmt_driver_config_t
argument_list|)
condition|)
block|{
return|return
name|XGE_HAL_ERR_VERSION_CONFLICT
return|;
block|}
name|xge_os_memcpy
argument_list|(
name|drv_config
argument_list|,
operator|&
name|g_xge_hal_driver
operator|->
name|config
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_mgmt_driver_config_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_mgmt_pci_config - Retrieve PCI configuration.  * @devh: HAL device handle.  * @pci_config: 256 byte long buffer for PCI configuration space.  * @size: Size of the @ buffer. HAL will return an error  * if the size is smaller than sizeof(xge_hal_mgmt_pci_config_t).  *  * Get PCI configuration. Permits to retrieve at run-time configuration  * values that were used to configure the device at load-time.  *  * Returns: XGE_HAL_OK - success.  * XGE_HAL_ERR_INVALID_DEVICE - Device is not valid.  * XGE_HAL_ERR_VERSION_CONFLICT - Version it not maching.  *  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_mgmt_pci_config
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|,
name|xge_hal_mgmt_pci_config_t
modifier|*
name|pci_config
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
if|if
condition|(
operator|(
name|hldev
operator|==
name|NULL
operator|)
operator|||
operator|(
name|hldev
operator|->
name|magic
operator|!=
name|XGE_HAL_MAGIC
operator|)
condition|)
block|{
return|return
name|XGE_HAL_ERR_INVALID_DEVICE
return|;
block|}
if|if
condition|(
name|size
operator|!=
sizeof|sizeof
argument_list|(
name|xge_hal_mgmt_pci_config_t
argument_list|)
condition|)
block|{
return|return
name|XGE_HAL_ERR_VERSION_CONFLICT
return|;
block|}
comment|/* refresh PCI config space */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x68
operator|/
literal|4
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|xge_os_pci_read32
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
name|i
operator|*
literal|4
argument_list|,
operator|(
name|u32
operator|*
operator|)
operator|&
name|hldev
operator|->
name|pci_config_space
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
name|xge_os_memcpy
argument_list|(
name|pci_config
argument_list|,
operator|&
name|hldev
operator|->
name|pci_config_space
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_mgmt_pci_config_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|XGE_TRACE_INTO_CIRCULAR_ARR
end_ifdef

begin_comment
comment|/**  * xge_hal_mgmt_trace_read - Read trace buffer contents.  * @buffer: Buffer to store the trace buffer contents.  * @buf_size: Size of the buffer.  * @offset: Offset in the internal trace buffer to read data.  * @read_length: Size of the valid data in the buffer.  *  * Read  HAL trace buffer contents starting from the offset  * upto the size of the buffer or till EOF is reached.  *  * Returns: XGE_HAL_OK - success.  * XGE_HAL_EOF_TRACE_BUF - No more data in the trace buffer.  *  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_mgmt_trace_read
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|unsigned
name|buf_size
parameter_list|,
name|unsigned
modifier|*
name|offset
parameter_list|,
name|unsigned
modifier|*
name|read_length
parameter_list|)
block|{
name|int
name|data_offset
decl_stmt|;
name|int
name|start_offset
decl_stmt|;
if|if
condition|(
operator|(
name|g_xge_os_tracebuf
operator|==
name|NULL
operator|)
operator|||
operator|(
name|g_xge_os_tracebuf
operator|->
name|offset
operator|==
name|g_xge_os_tracebuf
operator|->
name|size
operator|-
literal|2
operator|)
condition|)
block|{
return|return
name|XGE_HAL_EOF_TRACE_BUF
return|;
block|}
name|data_offset
operator|=
name|g_xge_os_tracebuf
operator|->
name|offset
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|offset
operator|>=
operator|(
name|unsigned
operator|)
name|xge_os_strlen
argument_list|(
name|g_xge_os_tracebuf
operator|->
name|data
operator|+
name|data_offset
argument_list|)
condition|)
block|{
return|return
name|XGE_HAL_EOF_TRACE_BUF
return|;
block|}
name|xge_os_memzero
argument_list|(
name|buffer
argument_list|,
name|buf_size
argument_list|)
expr_stmt|;
name|start_offset
operator|=
name|data_offset
operator|+
operator|*
name|offset
expr_stmt|;
operator|*
name|read_length
operator|=
name|xge_os_strlen
argument_list|(
name|g_xge_os_tracebuf
operator|->
name|data
operator|+
name|start_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|read_length
operator|>=
name|buf_size
condition|)
block|{
operator|*
name|read_length
operator|=
name|buf_size
operator|-
literal|1
expr_stmt|;
block|}
name|xge_os_memcpy
argument_list|(
name|buffer
argument_list|,
name|g_xge_os_tracebuf
operator|->
name|data
operator|+
name|start_offset
argument_list|,
operator|*
name|read_length
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|+=
operator|*
name|read_length
expr_stmt|;
operator|(
operator|*
name|read_length
operator|)
operator|++
expr_stmt|;
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * xge_hal_restore_link_led - Restore link LED to its original state.  * @devh: HAL device handle.  */
end_comment

begin_function
name|void
name|xge_hal_restore_link_led
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|)
block|{
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
comment|/* 	 * If the current link state is UP, switch on LED else make it 	 * off. 	 */
comment|/* 	 * For Xena 3 and lower revision cards, adapter control needs to be 	 * used for making LED ON/OFF. 	 */
if|if
condition|(
operator|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_XENA
operator|)
operator|&&
operator|(
name|xge_hal_device_rev
argument_list|(
name|hldev
argument_list|)
operator|<=
literal|3
operator|)
condition|)
block|{
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_control
argument_list|)
expr_stmt|;
if|if
condition|(
name|hldev
operator|->
name|link_state
operator|==
name|XGE_HAL_LINK_UP
condition|)
block|{
name|val64
operator||=
name|XGE_HAL_ADAPTER_LED_ON
expr_stmt|;
block|}
else|else
block|{
name|val64
operator|&=
operator|~
name|XGE_HAL_ADAPTER_LED_ON
expr_stmt|;
block|}
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_control
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Use beacon control register to control the LED. 	 * LED link output corresponds to bit 8 of the beacon control 	 * register. Note that, in the case of Xena, beacon control register 	 * represents the gpio control register. In the case of Herc, LED 	 * handling is done by beacon control register as opposed to gpio 	 * control register in Xena. Beacon control is used only to toggle 	 * and the value written into it does not depend on the link state. 	 * It is upto the ULD to toggle the LED even number of times which  	 * brings the LED to it's original state.  	 */
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|beacon_control
argument_list|)
expr_stmt|;
name|val64
operator||=
literal|0x0000800000000000ULL
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|beacon_control
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_flick_link_led - Flick (blink) link LED.  * @devh: HAL device handle.  *  * Depending on the card revision flicker the link LED by using the  * beacon control or the adapter_control register.  */
end_comment

begin_function
name|void
name|xge_hal_flick_link_led
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|)
block|{
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
init|=
literal|0
decl_stmt|;
comment|/* 	 * For Xena 3 and lower revision cards, adapter control needs to be 	 * used for making LED ON/OFF. 	 */
if|if
condition|(
operator|(
name|xge_hal_device_check_id
argument_list|(
name|hldev
argument_list|)
operator|==
name|XGE_HAL_CARD_XENA
operator|)
operator|&&
operator|(
name|xge_hal_device_rev
argument_list|(
name|hldev
argument_list|)
operator|<=
literal|3
operator|)
condition|)
block|{
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_control
argument_list|)
expr_stmt|;
name|val64
operator|^=
name|XGE_HAL_ADAPTER_LED_ON
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_control
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Use beacon control register to control the Link LED. 	 * Note that, in the case of Xena, beacon control register represents 	 * the gpio control register. In the case of Herc, LED handling is 	 * done by beacon control register as opposed to gpio control register 	 * in Xena. 	 */
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|beacon_control
argument_list|)
expr_stmt|;
name|val64
operator|^=
name|XGE_HAL_GPIO_CTRL_GPIO_0
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|beacon_control
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_read_eeprom - Read 4 bytes of data from user given offset.  * @devh: HAL device handle.  * @off: offset at which the data must be written  * @data: output parameter where the data is stored.  *  * Read 4 bytes of data from the user given offset and return the  * read data.  * Note: will allow to read only part of the EEPROM visible through the  * I2C bus.  * Returns: -1 on failure, 0 on success.  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_read_eeprom
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|,
name|int
name|off
parameter_list|,
name|u32
modifier|*
name|data
parameter_list|)
block|{
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
name|xge_hal_status_e
name|ret
init|=
name|XGE_HAL_FAIL
decl_stmt|;
name|u32
name|exit_cnt
init|=
literal|0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|val64
operator|=
name|XGE_HAL_I2C_CONTROL_DEV_ID
argument_list|(
name|XGE_DEV_ID
argument_list|)
operator||
name|XGE_HAL_I2C_CONTROL_ADDR
argument_list|(
name|off
argument_list|)
operator||
name|XGE_HAL_I2C_CONTROL_BYTE_CNT
argument_list|(
literal|0x3
argument_list|)
operator||
name|XGE_HAL_I2C_CONTROL_READ
operator||
name|XGE_HAL_I2C_CONTROL_CNTL_START
expr_stmt|;
name|__hal_serial_mem_write64
argument_list|(
name|hldev
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|i2c_control
argument_list|)
expr_stmt|;
while|while
condition|(
name|exit_cnt
operator|<
literal|5
condition|)
block|{
name|val64
operator|=
name|__hal_serial_mem_read64
argument_list|(
name|hldev
argument_list|,
operator|&
name|bar0
operator|->
name|i2c_control
argument_list|)
expr_stmt|;
if|if
condition|(
name|XGE_HAL_I2C_CONTROL_CNTL_END
argument_list|(
name|val64
argument_list|)
condition|)
block|{
operator|*
name|data
operator|=
name|XGE_HAL_I2C_CONTROL_GET_DATA
argument_list|(
name|val64
argument_list|)
expr_stmt|;
name|ret
operator|=
name|XGE_HAL_OK
expr_stmt|;
break|break;
block|}
name|exit_cnt
operator|++
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * xge_hal_write_eeprom - actually writes the relevant part of the data  value.  * @devh: HAL device handle.  * @off: offset at which the data must be written  * @data : The data that is to be written  * @cnt : Number of bytes of the data that are actually to be written into  * the Eeprom. (max of 3)  *  * Actually writes the relevant part of the data value into the Eeprom  * through the I2C bus.  * Return value:  * 0 on success, -1 on failure.  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_write_eeprom
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|,
name|int
name|off
parameter_list|,
name|u32
name|data
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
name|xge_hal_status_e
name|ret
init|=
name|XGE_HAL_FAIL
decl_stmt|;
name|u32
name|exit_cnt
init|=
literal|0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|val64
operator|=
name|XGE_HAL_I2C_CONTROL_DEV_ID
argument_list|(
name|XGE_DEV_ID
argument_list|)
operator||
name|XGE_HAL_I2C_CONTROL_ADDR
argument_list|(
name|off
argument_list|)
operator||
name|XGE_HAL_I2C_CONTROL_BYTE_CNT
argument_list|(
name|cnt
argument_list|)
operator||
name|XGE_HAL_I2C_CONTROL_SET_DATA
argument_list|(
name|data
argument_list|)
operator||
name|XGE_HAL_I2C_CONTROL_CNTL_START
expr_stmt|;
name|__hal_serial_mem_write64
argument_list|(
name|hldev
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|i2c_control
argument_list|)
expr_stmt|;
while|while
condition|(
name|exit_cnt
operator|<
literal|5
condition|)
block|{
name|val64
operator|=
name|__hal_serial_mem_read64
argument_list|(
name|hldev
argument_list|,
operator|&
name|bar0
operator|->
name|i2c_control
argument_list|)
expr_stmt|;
if|if
condition|(
name|XGE_HAL_I2C_CONTROL_CNTL_END
argument_list|(
name|val64
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|val64
operator|&
name|XGE_HAL_I2C_CONTROL_NACK
operator|)
condition|)
name|ret
operator|=
name|XGE_HAL_OK
expr_stmt|;
break|break;
block|}
name|exit_cnt
operator|++
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * xge_hal_register_test - reads and writes into all clock domains.  * @hldev : private member of the device structure.  * xge_nic structure.  * @data : variable that returns the result of each of the test conducted b  * by the driver.  *  * Read and write into all clock domains. The NIC has 3 clock domains,  * see that registers in all the three regions are accessible.  * Return value:  * 0 on success.  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_register_test
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|,
name|u64
modifier|*
name|data
parameter_list|)
block|{
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
init|=
literal|0
decl_stmt|;
name|int
name|fail
init|=
literal|0
decl_stmt|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|pif_rd_swapper_fb
argument_list|)
expr_stmt|;
if|if
condition|(
name|val64
operator|!=
literal|0x123456789abcdefULL
condition|)
block|{
name|fail
operator|=
literal|1
expr_stmt|;
name|xge_debug_osdep
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"Read Test level 1 fails"
argument_list|)
expr_stmt|;
block|}
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|rmac_pause_cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val64
operator|!=
literal|0xc000ffff00000000ULL
condition|)
block|{
name|fail
operator|=
literal|1
expr_stmt|;
name|xge_debug_osdep
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"Read Test level 2 fails"
argument_list|)
expr_stmt|;
block|}
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|rx_queue_cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val64
operator|!=
literal|0x0808080808080808ULL
condition|)
block|{
name|fail
operator|=
literal|1
expr_stmt|;
name|xge_debug_osdep
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"Read Test level 3 fails"
argument_list|)
expr_stmt|;
block|}
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|xgxs_efifo_cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val64
operator|!=
literal|0x000000001923141EULL
condition|)
block|{
name|fail
operator|=
literal|1
expr_stmt|;
name|xge_debug_osdep
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"Read Test level 4 fails"
argument_list|)
expr_stmt|;
block|}
name|val64
operator|=
literal|0x5A5A5A5A5A5A5A5AULL
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|xmsi_data
argument_list|)
expr_stmt|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|xmsi_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|val64
operator|!=
literal|0x5A5A5A5A5A5A5A5AULL
condition|)
block|{
name|fail
operator|=
literal|1
expr_stmt|;
name|xge_debug_osdep
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Write Test level 1 fails"
argument_list|)
expr_stmt|;
block|}
name|val64
operator|=
literal|0xA5A5A5A5A5A5A5A5ULL
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|xmsi_data
argument_list|)
expr_stmt|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|xmsi_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|val64
operator|!=
literal|0xA5A5A5A5A5A5A5A5ULL
condition|)
block|{
name|fail
operator|=
literal|1
expr_stmt|;
name|xge_debug_osdep
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Write Test level 2 fails"
argument_list|)
expr_stmt|;
block|}
operator|*
name|data
operator|=
name|fail
expr_stmt|;
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/*  * xge_hal_rldram_test - offline test for access to the RldRam chip on  the NIC  * @devh: HAL device handle.  * @data: variable that returns the result of each of the test  * conducted by the driver.  *  * This is one of the offline test that tests the read and write  * access to the RldRam chip on the NIC.  * Return value:  * 0 on success.  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_rldram_test
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|,
name|u64
modifier|*
name|data
parameter_list|)
block|{
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|iteration
init|=
literal|0
decl_stmt|,
name|test_pass
init|=
literal|0
decl_stmt|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_control
argument_list|)
expr_stmt|;
name|val64
operator|&=
operator|~
name|XGE_HAL_ADAPTER_ECC_EN
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_control
argument_list|)
expr_stmt|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|mc_rldram_test_ctrl
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_MC_RLDRAM_TEST_MODE
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|mc_rldram_test_ctrl
argument_list|)
expr_stmt|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|mc_rldram_mrs
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_MC_RLDRAM_QUEUE_SIZE_ENABLE
expr_stmt|;
name|__hal_serial_mem_write64
argument_list|(
name|hldev
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|i2c_control
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_MC_RLDRAM_MRS_ENABLE
expr_stmt|;
name|__hal_serial_mem_write64
argument_list|(
name|hldev
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|i2c_control
argument_list|)
expr_stmt|;
while|while
condition|(
name|iteration
operator|<
literal|2
condition|)
block|{
name|val64
operator|=
literal|0x55555555aaaa0000ULL
expr_stmt|;
if|if
condition|(
name|iteration
operator|==
literal|1
condition|)
block|{
name|val64
operator|^=
literal|0xFFFFFFFFFFFF0000ULL
expr_stmt|;
block|}
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|mc_rldram_test_d0
argument_list|)
expr_stmt|;
name|val64
operator|=
literal|0xaaaa5a5555550000ULL
expr_stmt|;
if|if
condition|(
name|iteration
operator|==
literal|1
condition|)
block|{
name|val64
operator|^=
literal|0xFFFFFFFFFFFF0000ULL
expr_stmt|;
block|}
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|mc_rldram_test_d1
argument_list|)
expr_stmt|;
name|val64
operator|=
literal|0x55aaaaaaaa5a0000ULL
expr_stmt|;
if|if
condition|(
name|iteration
operator|==
literal|1
condition|)
block|{
name|val64
operator|^=
literal|0xFFFFFFFFFFFF0000ULL
expr_stmt|;
block|}
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|mc_rldram_test_d2
argument_list|)
expr_stmt|;
name|val64
operator|=
call|(
name|u64
call|)
argument_list|(
literal|0x0000003fffff0000ULL
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|mc_rldram_test_add
argument_list|)
expr_stmt|;
name|val64
operator|=
name|XGE_HAL_MC_RLDRAM_TEST_MODE
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|mc_rldram_test_ctrl
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_MC_RLDRAM_TEST_MODE
operator||
name|XGE_HAL_MC_RLDRAM_TEST_WRITE
operator||
name|XGE_HAL_MC_RLDRAM_TEST_GO
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|mc_rldram_test_ctrl
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
literal|5
condition|;
name|cnt
operator|++
control|)
block|{
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|mc_rldram_test_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|val64
operator|&
name|XGE_HAL_MC_RLDRAM_TEST_DONE
condition|)
break|break;
name|xge_os_mdelay
argument_list|(
literal|200
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cnt
operator|==
literal|5
condition|)
break|break;
name|val64
operator|=
name|XGE_HAL_MC_RLDRAM_TEST_MODE
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|mc_rldram_test_ctrl
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_MC_RLDRAM_TEST_MODE
operator||
name|XGE_HAL_MC_RLDRAM_TEST_GO
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|mc_rldram_test_ctrl
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
literal|5
condition|;
name|cnt
operator|++
control|)
block|{
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|mc_rldram_test_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|val64
operator|&
name|XGE_HAL_MC_RLDRAM_TEST_DONE
condition|)
break|break;
name|xge_os_mdelay
argument_list|(
literal|500
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cnt
operator|==
literal|5
condition|)
break|break;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|mc_rldram_test_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|val64
operator|&
name|XGE_HAL_MC_RLDRAM_TEST_PASS
condition|)
name|test_pass
operator|=
literal|1
expr_stmt|;
name|iteration
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|test_pass
condition|)
operator|*
name|data
operator|=
literal|1
expr_stmt|;
else|else
operator|*
name|data
operator|=
literal|0
expr_stmt|;
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/*  * xge_hal_pma_loopback - Enable or disable PMA loopback  * @devh: HAL device handle.  * @enable:Boolean set to 1 to enable and 0 to disable.  *  * Enable or disable PMA loopback.  * Return value:  * 0 on success.  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_pma_loopback
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
name|u16
name|data
decl_stmt|;
comment|/* 	 * This code if for MAC loopbak 	 * Should be enabled through another parameter 	 */
if|#
directive|if
literal|0
block|val64 = xge_os_pio_mem_read64(hldev->pdev, hldev->regh0,&bar0->mac_cfg); 	if ( enable ) 	{ 	    val64 |= ( XGE_HAL_MAC_CFG_TMAC_LOOPBACK | XGE_HAL_MAC_CFG_RMAC_PROM_ENABLE ); 	} 	__hal_pio_mem_write32_upper(hldev->pdev, hldev->regh0, 	        (u32)(val64>> 32), (char*)&bar0->mac_cfg); 	xge_os_mdelay(1);
endif|#
directive|endif
name|val64
operator|=
name|XGE_HAL_MDIO_CONTROL_MMD_INDX_ADDR
argument_list|(
literal|0
argument_list|)
operator||
name|XGE_HAL_MDIO_CONTROL_MMD_DEV_ADDR
argument_list|(
literal|1
argument_list|)
operator||
name|XGE_HAL_MDIO_CONTROL_MMD_PRT_ADDR
argument_list|(
literal|0
argument_list|)
operator||
name|XGE_HAL_MDIO_CONTROL_MMD_CTRL
argument_list|(
literal|0
argument_list|)
operator||
name|XGE_HAL_MDIO_CONTROL_MMD_OP
argument_list|(
name|XGE_HAL_MDIO_OP_ADDRESS
argument_list|)
expr_stmt|;
name|__hal_serial_mem_write64
argument_list|(
name|hldev
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|mdio_control
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_MDIO_CONTROL_MMD_CTRL
argument_list|(
name|XGE_HAL_MDIO_CTRL_START
argument_list|)
expr_stmt|;
name|__hal_serial_mem_write64
argument_list|(
name|hldev
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|mdio_control
argument_list|)
expr_stmt|;
name|val64
operator|=
name|XGE_HAL_MDIO_CONTROL_MMD_INDX_ADDR
argument_list|(
literal|0
argument_list|)
operator||
name|XGE_HAL_MDIO_CONTROL_MMD_DEV_ADDR
argument_list|(
literal|1
argument_list|)
operator||
name|XGE_HAL_MDIO_CONTROL_MMD_PRT_ADDR
argument_list|(
literal|0
argument_list|)
operator||
name|XGE_HAL_MDIO_CONTROL_MMD_CTRL
argument_list|(
literal|0
argument_list|)
operator||
name|XGE_HAL_MDIO_CONTROL_MMD_OP
argument_list|(
name|XGE_HAL_MDIO_OP_READ
argument_list|)
expr_stmt|;
name|__hal_serial_mem_write64
argument_list|(
name|hldev
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|mdio_control
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_MDIO_CONTROL_MMD_CTRL
argument_list|(
name|XGE_HAL_MDIO_CTRL_START
argument_list|)
expr_stmt|;
name|__hal_serial_mem_write64
argument_list|(
name|hldev
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|mdio_control
argument_list|)
expr_stmt|;
name|val64
operator|=
name|__hal_serial_mem_read64
argument_list|(
name|hldev
argument_list|,
operator|&
name|bar0
operator|->
name|mdio_control
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|u16
operator|)
name|XGE_HAL_MDIO_CONTROL_MMD_DATA_GET
argument_list|(
name|val64
argument_list|)
expr_stmt|;
define|#
directive|define
name|_HAL_LOOPBK_PMA
value|1
if|if
condition|(
name|enable
condition|)
name|data
operator||=
literal|1
expr_stmt|;
else|else
name|data
operator|&=
literal|0xfe
expr_stmt|;
name|val64
operator|=
name|XGE_HAL_MDIO_CONTROL_MMD_INDX_ADDR
argument_list|(
literal|0
argument_list|)
operator||
name|XGE_HAL_MDIO_CONTROL_MMD_DEV_ADDR
argument_list|(
literal|1
argument_list|)
operator||
name|XGE_HAL_MDIO_CONTROL_MMD_PRT_ADDR
argument_list|(
literal|0
argument_list|)
operator||
name|XGE_HAL_MDIO_CONTROL_MMD_CTRL
argument_list|(
literal|0
argument_list|)
operator||
name|XGE_HAL_MDIO_CONTROL_MMD_OP
argument_list|(
name|XGE_HAL_MDIO_OP_ADDRESS
argument_list|)
expr_stmt|;
name|__hal_serial_mem_write64
argument_list|(
name|hldev
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|mdio_control
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_MDIO_CONTROL_MMD_CTRL
argument_list|(
name|XGE_HAL_MDIO_CTRL_START
argument_list|)
expr_stmt|;
name|__hal_serial_mem_write64
argument_list|(
name|hldev
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|mdio_control
argument_list|)
expr_stmt|;
name|val64
operator|=
name|XGE_HAL_MDIO_CONTROL_MMD_INDX_ADDR
argument_list|(
literal|0
argument_list|)
operator||
name|XGE_HAL_MDIO_CONTROL_MMD_DEV_ADDR
argument_list|(
literal|1
argument_list|)
operator||
name|XGE_HAL_MDIO_CONTROL_MMD_PRT_ADDR
argument_list|(
literal|0
argument_list|)
operator||
name|XGE_HAL_MDIO_CONTROL_MMD_DATA
argument_list|(
name|data
argument_list|)
operator||
name|XGE_HAL_MDIO_CONTROL_MMD_CTRL
argument_list|(
literal|0x0
argument_list|)
operator||
name|XGE_HAL_MDIO_CONTROL_MMD_OP
argument_list|(
name|XGE_HAL_MDIO_OP_WRITE
argument_list|)
expr_stmt|;
name|__hal_serial_mem_write64
argument_list|(
name|hldev
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|mdio_control
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_MDIO_CONTROL_MMD_CTRL
argument_list|(
name|XGE_HAL_MDIO_CTRL_START
argument_list|)
expr_stmt|;
name|__hal_serial_mem_write64
argument_list|(
name|hldev
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|mdio_control
argument_list|)
expr_stmt|;
name|val64
operator|=
name|XGE_HAL_MDIO_CONTROL_MMD_INDX_ADDR
argument_list|(
literal|0
argument_list|)
operator||
name|XGE_HAL_MDIO_CONTROL_MMD_DEV_ADDR
argument_list|(
literal|1
argument_list|)
operator||
name|XGE_HAL_MDIO_CONTROL_MMD_PRT_ADDR
argument_list|(
literal|0
argument_list|)
operator||
name|XGE_HAL_MDIO_CONTROL_MMD_CTRL
argument_list|(
literal|0x0
argument_list|)
operator||
name|XGE_HAL_MDIO_CONTROL_MMD_OP
argument_list|(
name|XGE_HAL_MDIO_OP_READ
argument_list|)
expr_stmt|;
name|__hal_serial_mem_write64
argument_list|(
name|hldev
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|mdio_control
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_MDIO_CONTROL_MMD_CTRL
argument_list|(
name|XGE_HAL_MDIO_CTRL_START
argument_list|)
expr_stmt|;
name|__hal_serial_mem_write64
argument_list|(
name|hldev
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|mdio_control
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_function
name|u16
name|xge_hal_mdio_read
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|,
name|u32
name|mmd_type
parameter_list|,
name|u64
name|addr
parameter_list|)
block|{
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
init|=
literal|0x0
decl_stmt|;
name|u16
name|rval16
init|=
literal|0x0
decl_stmt|;
name|u8
name|i
init|=
literal|0
decl_stmt|;
comment|/* address transaction */
name|val64
operator|=
name|XGE_HAL_MDIO_CONTROL_MMD_INDX_ADDR
argument_list|(
name|addr
argument_list|)
operator||
name|XGE_HAL_MDIO_CONTROL_MMD_DEV_ADDR
argument_list|(
name|mmd_type
argument_list|)
operator||
name|XGE_HAL_MDIO_CONTROL_MMD_PRT_ADDR
argument_list|(
literal|0
argument_list|)
operator||
name|XGE_HAL_MDIO_CONTROL_MMD_OP
argument_list|(
name|XGE_HAL_MDIO_OP_ADDRESS
argument_list|)
expr_stmt|;
name|__hal_serial_mem_write64
argument_list|(
name|hldev
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|mdio_control
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_MDIO_CONTROL_MMD_CTRL
argument_list|(
name|XGE_HAL_MDIO_CTRL_START
argument_list|)
expr_stmt|;
name|__hal_serial_mem_write64
argument_list|(
name|hldev
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|mdio_control
argument_list|)
expr_stmt|;
do|do
block|{
name|val64
operator|=
name|__hal_serial_mem_read64
argument_list|(
name|hldev
argument_list|,
operator|&
name|bar0
operator|->
name|mdio_control
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|++
operator|>
literal|10
condition|)
block|{
break|break;
block|}
block|}
do|while
condition|(
operator|(
name|val64
operator|&
name|XGE_HAL_MDIO_CONTROL_MMD_CTRL
argument_list|(
literal|0xF
argument_list|)
operator|)
operator|!=
name|XGE_HAL_MDIO_CONTROL_MMD_CTRL
argument_list|(
literal|1
argument_list|)
condition|)
do|;
comment|/* Data transaction */
name|val64
operator|=
name|XGE_HAL_MDIO_CONTROL_MMD_INDX_ADDR
argument_list|(
name|addr
argument_list|)
operator||
name|XGE_HAL_MDIO_CONTROL_MMD_DEV_ADDR
argument_list|(
name|mmd_type
argument_list|)
operator||
name|XGE_HAL_MDIO_CONTROL_MMD_PRT_ADDR
argument_list|(
literal|0
argument_list|)
operator||
name|XGE_HAL_MDIO_CONTROL_MMD_OP
argument_list|(
name|XGE_HAL_MDIO_OP_READ
argument_list|)
expr_stmt|;
name|__hal_serial_mem_write64
argument_list|(
name|hldev
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|mdio_control
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_MDIO_CONTROL_MMD_CTRL
argument_list|(
name|XGE_HAL_MDIO_CTRL_START
argument_list|)
expr_stmt|;
name|__hal_serial_mem_write64
argument_list|(
name|hldev
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|mdio_control
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|val64
operator|=
name|__hal_serial_mem_read64
argument_list|(
name|hldev
argument_list|,
operator|&
name|bar0
operator|->
name|mdio_control
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|++
operator|>
literal|10
condition|)
block|{
break|break;
block|}
block|}
do|while
condition|(
operator|(
name|val64
operator|&
name|XGE_HAL_MDIO_CONTROL_MMD_CTRL
argument_list|(
literal|0xF
argument_list|)
operator|)
operator|!=
name|XGE_HAL_MDIO_CONTROL_MMD_CTRL
argument_list|(
literal|1
argument_list|)
condition|)
do|;
name|rval16
operator|=
operator|(
name|u16
operator|)
name|XGE_HAL_MDIO_CONTROL_MMD_DATA_GET
argument_list|(
name|val64
argument_list|)
expr_stmt|;
return|return
name|rval16
return|;
block|}
end_function

begin_function
name|xge_hal_status_e
name|xge_hal_mdio_write
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|,
name|u32
name|mmd_type
parameter_list|,
name|u64
name|addr
parameter_list|,
name|u32
name|value
parameter_list|)
block|{
name|u64
name|val64
init|=
literal|0x0
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u8
name|i
init|=
literal|0
decl_stmt|;
comment|/* address transaction */
name|val64
operator|=
name|XGE_HAL_MDIO_CONTROL_MMD_INDX_ADDR
argument_list|(
name|addr
argument_list|)
operator||
name|XGE_HAL_MDIO_CONTROL_MMD_DEV_ADDR
argument_list|(
name|mmd_type
argument_list|)
operator||
name|XGE_HAL_MDIO_CONTROL_MMD_PRT_ADDR
argument_list|(
literal|0
argument_list|)
operator||
name|XGE_HAL_MDIO_CONTROL_MMD_OP
argument_list|(
name|XGE_HAL_MDIO_OP_ADDRESS
argument_list|)
expr_stmt|;
name|__hal_serial_mem_write64
argument_list|(
name|hldev
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|mdio_control
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_MDIO_CONTROL_MMD_CTRL
argument_list|(
name|XGE_HAL_MDIO_CTRL_START
argument_list|)
expr_stmt|;
name|__hal_serial_mem_write64
argument_list|(
name|hldev
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|mdio_control
argument_list|)
expr_stmt|;
do|do
block|{
name|val64
operator|=
name|__hal_serial_mem_read64
argument_list|(
name|hldev
argument_list|,
operator|&
name|bar0
operator|->
name|mdio_control
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|++
operator|>
literal|10
condition|)
block|{
break|break;
block|}
block|}
do|while
condition|(
operator|(
name|val64
operator|&
name|XGE_HAL_MDIO_CONTROL_MMD_CTRL
argument_list|(
literal|0xF
argument_list|)
operator|)
operator|!=
name|XGE_HAL_MDIO_CONTROL_MMD_CTRL
argument_list|(
literal|1
argument_list|)
condition|)
do|;
comment|/* Data transaction */
name|val64
operator|=
literal|0x0
expr_stmt|;
name|val64
operator|=
name|XGE_HAL_MDIO_CONTROL_MMD_INDX_ADDR
argument_list|(
name|addr
argument_list|)
operator||
name|XGE_HAL_MDIO_CONTROL_MMD_DEV_ADDR
argument_list|(
name|mmd_type
argument_list|)
operator||
name|XGE_HAL_MDIO_CONTROL_MMD_PRT_ADDR
argument_list|(
literal|0
argument_list|)
operator||
name|XGE_HAL_MDIO_CONTROL_MMD_DATA
argument_list|(
name|value
argument_list|)
operator||
name|XGE_HAL_MDIO_CONTROL_MMD_OP
argument_list|(
name|XGE_HAL_MDIO_OP_WRITE
argument_list|)
expr_stmt|;
name|__hal_serial_mem_write64
argument_list|(
name|hldev
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|mdio_control
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_MDIO_CONTROL_MMD_CTRL
argument_list|(
name|XGE_HAL_MDIO_CTRL_START
argument_list|)
expr_stmt|;
name|__hal_serial_mem_write64
argument_list|(
name|hldev
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|mdio_control
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|val64
operator|=
name|__hal_serial_mem_read64
argument_list|(
name|hldev
argument_list|,
operator|&
name|bar0
operator|->
name|mdio_control
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|++
operator|>
literal|10
condition|)
block|{
break|break;
block|}
block|}
do|while
condition|(
operator|(
name|val64
operator|&
name|XGE_HAL_MDIO_CONTROL_MMD_CTRL
argument_list|(
literal|0xF
argument_list|)
operator|)
operator|!=
name|XGE_HAL_MDIO_CONTROL_MMD_CTRL
argument_list|(
literal|1
argument_list|)
condition|)
do|;
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/*  * xge_hal_eeprom_test - to verify that EEprom in the xena can be  programmed.  * @devh: HAL device handle.  * @data:variable that returns the result of each of the test conducted by  * the driver.  *  * Verify that EEPROM in the xena can be programmed using I2C_CONTROL  * register.  * Return value:  * 0 on success.  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_eeprom_test
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|,
name|u64
modifier|*
name|data
parameter_list|)
block|{
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
name|int
name|fail
init|=
literal|0
decl_stmt|;
name|u32
name|ret_data
init|=
literal|0
decl_stmt|;
comment|/* Test Write Error at offset 0 */
if|if
condition|(
operator|!
name|xge_hal_write_eeprom
argument_list|(
name|hldev
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
condition|)
name|fail
operator|=
literal|1
expr_stmt|;
comment|/* Test Write at offset 4f0 */
if|if
condition|(
name|xge_hal_write_eeprom
argument_list|(
name|hldev
argument_list|,
literal|0x4F0
argument_list|,
literal|0x01234567
argument_list|,
literal|3
argument_list|)
condition|)
name|fail
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|xge_hal_read_eeprom
argument_list|(
name|hldev
argument_list|,
literal|0x4F0
argument_list|,
operator|&
name|ret_data
argument_list|)
condition|)
name|fail
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ret_data
operator|!=
literal|0x01234567
condition|)
name|fail
operator|=
literal|1
expr_stmt|;
comment|/* Reset the EEPROM data go FFFF */
operator|(
name|void
operator|)
name|xge_hal_write_eeprom
argument_list|(
name|hldev
argument_list|,
literal|0x4F0
argument_list|,
literal|0xFFFFFFFF
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* Test Write Request Error at offset 0x7c */
if|if
condition|(
operator|!
name|xge_hal_write_eeprom
argument_list|(
name|hldev
argument_list|,
literal|0x07C
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
condition|)
name|fail
operator|=
literal|1
expr_stmt|;
comment|/* Test Write Request at offset 0x7fc */
if|if
condition|(
name|xge_hal_write_eeprom
argument_list|(
name|hldev
argument_list|,
literal|0x7FC
argument_list|,
literal|0x01234567
argument_list|,
literal|3
argument_list|)
condition|)
name|fail
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|xge_hal_read_eeprom
argument_list|(
name|hldev
argument_list|,
literal|0x7FC
argument_list|,
operator|&
name|ret_data
argument_list|)
condition|)
name|fail
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ret_data
operator|!=
literal|0x01234567
condition|)
name|fail
operator|=
literal|1
expr_stmt|;
comment|/* Reset the EEPROM data go FFFF */
operator|(
name|void
operator|)
name|xge_hal_write_eeprom
argument_list|(
name|hldev
argument_list|,
literal|0x7FC
argument_list|,
literal|0xFFFFFFFF
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* Test Write Error at offset 0x80 */
if|if
condition|(
operator|!
name|xge_hal_write_eeprom
argument_list|(
name|hldev
argument_list|,
literal|0x080
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
condition|)
name|fail
operator|=
literal|1
expr_stmt|;
comment|/* Test Write Error at offset 0xfc */
if|if
condition|(
operator|!
name|xge_hal_write_eeprom
argument_list|(
name|hldev
argument_list|,
literal|0x0FC
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
condition|)
name|fail
operator|=
literal|1
expr_stmt|;
comment|/* Test Write Error at offset 0x100 */
if|if
condition|(
operator|!
name|xge_hal_write_eeprom
argument_list|(
name|hldev
argument_list|,
literal|0x100
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
condition|)
name|fail
operator|=
literal|1
expr_stmt|;
comment|/* Test Write Error at offset 4ec */
if|if
condition|(
operator|!
name|xge_hal_write_eeprom
argument_list|(
name|hldev
argument_list|,
literal|0x4EC
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
condition|)
name|fail
operator|=
literal|1
expr_stmt|;
operator|*
name|data
operator|=
name|fail
expr_stmt|;
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/*  * xge_hal_bist_test - invokes the MemBist test of the card .  * @devh: HAL device handle.  * xge_nic structure.  * @data:variable that returns the result of each of the test conducted by  * the driver.  *  * This invokes the MemBist test of the card. We give around  * 2 secs time for the Test to complete. If it's still not complete  * within this peiod, we consider that the test failed.  * Return value:  * 0 on success and -1 on failure.  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_bist_test
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|,
name|u64
modifier|*
name|data
parameter_list|)
block|{
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
name|u8
name|bist
init|=
literal|0
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|;
name|xge_hal_status_e
name|ret
init|=
name|XGE_HAL_FAIL
decl_stmt|;
name|xge_os_pci_read8
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
literal|0x0f
argument_list|,
operator|&
name|bist
argument_list|)
expr_stmt|;
name|bist
operator||=
literal|0x40
expr_stmt|;
name|xge_os_pci_write8
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
literal|0x0f
argument_list|,
name|bist
argument_list|)
expr_stmt|;
while|while
condition|(
name|cnt
operator|<
literal|20
condition|)
block|{
name|xge_os_pci_read8
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|cfgh
argument_list|,
literal|0x0f
argument_list|,
operator|&
name|bist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bist
operator|&
literal|0x40
operator|)
condition|)
block|{
operator|*
name|data
operator|=
operator|(
name|bist
operator|&
literal|0x0f
operator|)
expr_stmt|;
name|ret
operator|=
name|XGE_HAL_OK
expr_stmt|;
break|break;
block|}
name|xge_os_mdelay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * xge_hal_link_test - verifies the link state of the nic  * @devh: HAL device handle.  * @data: variable that returns the result of each of the test conducted by  * the driver.  *  * Verify the link state of the NIC and updates the input  * argument 'data' appropriately.  * Return value:  * 0 on success.  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_hal_link_test
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|,
name|u64
modifier|*
name|data
parameter_list|)
block|{
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|adapter_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|val64
operator|&
name|XGE_HAL_ADAPTER_STATUS_RMAC_LOCAL_FAULT
condition|)
operator|*
name|data
operator|=
literal|1
expr_stmt|;
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_getpause_data -Pause frame frame generation and reception.  * @devh: HAL device handle.  * @tx : A field to return the pause generation capability of the NIC.  * @rx : A field to return the pause reception capability of the NIC.  *  * Returns the Pause frame generation and reception capability of the NIC.  * Return value:  *  void  */
end_comment

begin_function
name|void
name|xge_hal_getpause_data
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|,
name|int
modifier|*
name|tx
parameter_list|,
name|int
modifier|*
name|rx
parameter_list|)
block|{
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|rmac_pause_cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val64
operator|&
name|XGE_HAL_RMAC_PAUSE_GEN_EN
condition|)
operator|*
name|tx
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|val64
operator|&
name|XGE_HAL_RMAC_PAUSE_RCV_EN
condition|)
operator|*
name|rx
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_setpause_data -  set/reset pause frame generation.  * @devh: HAL device handle.  * @tx: A field that indicates the pause generation capability to be  * set on the NIC.  * @rx: A field that indicates the pause reception capability to be  * set on the NIC.  *  * It can be used to set or reset Pause frame generation or reception  * support of the NIC.  * Return value:  * int, returns 0 on Success  */
end_comment

begin_function
name|int
name|xge_hal_setpause_data
parameter_list|(
name|xge_hal_device_h
name|devh
parameter_list|,
name|int
name|tx
parameter_list|,
name|int
name|rx
parameter_list|)
block|{
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|devh
decl_stmt|;
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|u64
name|val64
decl_stmt|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|rmac_pause_cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx
condition|)
name|val64
operator||=
name|XGE_HAL_RMAC_PAUSE_GEN_EN
expr_stmt|;
else|else
name|val64
operator|&=
operator|~
name|XGE_HAL_RMAC_PAUSE_GEN_EN
expr_stmt|;
if|if
condition|(
name|rx
condition|)
name|val64
operator||=
name|XGE_HAL_RMAC_PAUSE_RCV_EN
expr_stmt|;
else|else
name|val64
operator|&=
operator|~
name|XGE_HAL_RMAC_PAUSE_RCV_EN
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|hldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rmac_pause_cfg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * xge_hal_read_xfp_current_temp -  * @hldev: HAL device handle.  *  * This routine only gets the temperature for XFP modules. Also, updating of the  * NVRAM can sometimes fail and so the reading we might get may not be uptodate.  */
end_comment

begin_function
name|u32
name|xge_hal_read_xfp_current_temp
parameter_list|(
name|xge_hal_device_h
name|hldev
parameter_list|)
block|{
name|u16
name|val_1
decl_stmt|,
name|val_2
decl_stmt|,
name|i
init|=
literal|0
decl_stmt|;
name|u32
name|actual
decl_stmt|;
comment|/* First update the NVRAM table of XFP. */
operator|(
name|void
operator|)
name|xge_hal_mdio_write
argument_list|(
name|hldev
argument_list|,
name|XGE_HAL_MDIO_MMD_PMA_DEV_ADDR
argument_list|,
literal|0x8000
argument_list|,
literal|0x3
argument_list|)
expr_stmt|;
comment|/* Now wait for the transfer to complete */
do|do
block|{
name|xge_os_mdelay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|// wait 50 milliseonds
name|val_1
operator|=
name|xge_hal_mdio_read
argument_list|(
name|hldev
argument_list|,
name|XGE_HAL_MDIO_MMD_PMA_DEV_ADDR
argument_list|,
literal|0x8000
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|++
operator|>
literal|10
condition|)
block|{
comment|// waited 500 ms which should be plenty of time.
break|break;
block|}
block|}
do|while
condition|(
operator|(
name|val_1
operator|&
literal|0x000C
operator|)
operator|!=
literal|0x0004
condition|)
do|;
comment|/* Now NVRAM table of XFP should be updated, so read the temp */
name|val_1
operator|=
operator|(
name|u8
operator|)
name|xge_hal_mdio_read
argument_list|(
name|hldev
argument_list|,
name|XGE_HAL_MDIO_MMD_PMA_DEV_ADDR
argument_list|,
literal|0x8067
argument_list|)
expr_stmt|;
name|val_2
operator|=
operator|(
name|u8
operator|)
name|xge_hal_mdio_read
argument_list|(
name|hldev
argument_list|,
name|XGE_HAL_MDIO_MMD_PMA_DEV_ADDR
argument_list|,
literal|0x8068
argument_list|)
expr_stmt|;
name|actual
operator|=
operator|(
operator|(
name|val_1
operator|<<
literal|8
operator|)
operator||
name|val_2
operator|)
expr_stmt|;
if|if
condition|(
name|actual
operator|>=
literal|32768
condition|)
name|actual
operator|=
name|actual
operator|-
literal|65536
expr_stmt|;
name|actual
operator|=
name|actual
operator|/
literal|256
expr_stmt|;
return|return
name|actual
return|;
block|}
end_function

begin_comment
comment|/**  * __hal_chk_xpak_counter -  check the Xpak error count and log the msg.  * @hldev: pointer to xge_hal_device_t structure  * @type:  xpak stats error type  * @value: xpak stats value  *  * It is used to log the error message based on the xpak stats value  * Return value:  * None  */
end_comment

begin_function
name|void
name|__hal_chk_xpak_counter
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|,
name|int
name|type
parameter_list|,
name|u32
name|value
parameter_list|)
block|{
comment|/* 	 * If the value is high for three consecutive cylce, 	 * log a error message 	 */
if|if
condition|(
name|value
operator|==
literal|3
condition|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|1
case|:
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_err_stats
operator|.
name|xpak_counter
operator|.
name|excess_temp
operator|=
literal|0
expr_stmt|;
comment|/* 	         * Notify the ULD on Excess Xpak temperature alarm msg 	         */
if|if
condition|(
name|g_xge_hal_driver
operator|->
name|uld_callbacks
operator|.
name|xpak_alarm_log
condition|)
block|{
name|g_xge_hal_driver
operator|->
name|uld_callbacks
operator|.
name|xpak_alarm_log
argument_list|(
name|hldev
operator|->
name|upper_layer_info
argument_list|,
name|XGE_HAL_XPAK_ALARM_EXCESS_TEMP
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_err_stats
operator|.
name|xpak_counter
operator|.
name|excess_bias_current
operator|=
literal|0
expr_stmt|;
comment|/* 	         * Notify the ULD on Excess  xpak bias current alarm msg 	         */
if|if
condition|(
name|g_xge_hal_driver
operator|->
name|uld_callbacks
operator|.
name|xpak_alarm_log
condition|)
block|{
name|g_xge_hal_driver
operator|->
name|uld_callbacks
operator|.
name|xpak_alarm_log
argument_list|(
name|hldev
operator|->
name|upper_layer_info
argument_list|,
name|XGE_HAL_XPAK_ALARM_EXCESS_BIAS_CURRENT
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|3
case|:
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_err_stats
operator|.
name|xpak_counter
operator|.
name|excess_laser_output
operator|=
literal|0
expr_stmt|;
comment|/* 	         * Notify the ULD on Excess Xpak Laser o/p power 	         * alarm msg 	         */
if|if
condition|(
name|g_xge_hal_driver
operator|->
name|uld_callbacks
operator|.
name|xpak_alarm_log
condition|)
block|{
name|g_xge_hal_driver
operator|->
name|uld_callbacks
operator|.
name|xpak_alarm_log
argument_list|(
name|hldev
operator|->
name|upper_layer_info
argument_list|,
name|XGE_HAL_XPAK_ALARM_EXCESS_LASER_OUTPUT
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|xge_debug_osdep
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"Incorrect XPAK Alarm "
literal|"type "
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * __hal_updt_stats_xpak -  update the Xpak error count.  * @hldev: pointer to xge_hal_device_t structure  *  * It is used to update the xpak stats value  * Return value:  * None  */
end_comment

begin_function
name|void
name|__hal_updt_stats_xpak
parameter_list|(
name|xge_hal_device_t
modifier|*
name|hldev
parameter_list|)
block|{
name|u16
name|val_1
decl_stmt|;
name|u64
name|addr
decl_stmt|;
comment|/* Check the communication with the MDIO slave */
name|addr
operator|=
literal|0x0000
expr_stmt|;
name|val_1
operator|=
literal|0x0
expr_stmt|;
name|val_1
operator|=
name|xge_hal_mdio_read
argument_list|(
name|hldev
argument_list|,
name|XGE_HAL_MDIO_MMD_PMA_DEV_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val_1
operator|==
literal|0xFFFF
operator|)
operator|||
operator|(
name|val_1
operator|==
literal|0x0000
operator|)
condition|)
block|{
name|xge_debug_osdep
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"ERR: MDIO slave access failed - "
literal|"Returned %x"
argument_list|,
name|val_1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check for the expected value of 2040 at PMA address 0x0000 */
if|if
condition|(
name|val_1
operator|!=
literal|0x2040
condition|)
block|{
name|xge_debug_osdep
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"Incorrect value at PMA address 0x0000 - "
argument_list|)
expr_stmt|;
name|xge_debug_osdep
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"Returned: %llx- Expected: 0x2040"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
operator|(
name|unsigned
name|long
operator|)
name|val_1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Loading the DOM register to MDIO register */
name|addr
operator|=
literal|0xA100
expr_stmt|;
operator|(
name|void
operator|)
name|xge_hal_mdio_write
argument_list|(
name|hldev
argument_list|,
name|XGE_HAL_MDIO_MMD_PMA_DEV_ADDR
argument_list|,
name|addr
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|val_1
operator|=
name|xge_hal_mdio_read
argument_list|(
name|hldev
argument_list|,
name|XGE_HAL_MDIO_MMD_PMA_DEV_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* 	 * Reading the Alarm flags 	 */
name|addr
operator|=
literal|0xA070
expr_stmt|;
name|val_1
operator|=
literal|0x0
expr_stmt|;
name|val_1
operator|=
name|xge_hal_mdio_read
argument_list|(
name|hldev
argument_list|,
name|XGE_HAL_MDIO_MMD_PMA_DEV_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHECKBIT
argument_list|(
name|val_1
argument_list|,
literal|0x7
argument_list|)
condition|)
block|{
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_err_stats
operator|.
name|stats_xpak
operator|.
name|alarm_transceiver_temp_high
operator|++
expr_stmt|;
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_err_stats
operator|.
name|xpak_counter
operator|.
name|excess_temp
operator|++
expr_stmt|;
name|__hal_chk_xpak_counter
argument_list|(
name|hldev
argument_list|,
literal|0x1
argument_list|,
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_err_stats
operator|.
name|xpak_counter
operator|.
name|excess_temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_err_stats
operator|.
name|xpak_counter
operator|.
name|excess_temp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|CHECKBIT
argument_list|(
name|val_1
argument_list|,
literal|0x6
argument_list|)
condition|)
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_err_stats
operator|.
name|stats_xpak
operator|.
name|alarm_transceiver_temp_low
operator|++
expr_stmt|;
if|if
condition|(
name|CHECKBIT
argument_list|(
name|val_1
argument_list|,
literal|0x3
argument_list|)
condition|)
block|{
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_err_stats
operator|.
name|stats_xpak
operator|.
name|alarm_laser_bias_current_high
operator|++
expr_stmt|;
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_err_stats
operator|.
name|xpak_counter
operator|.
name|excess_bias_current
operator|++
expr_stmt|;
name|__hal_chk_xpak_counter
argument_list|(
name|hldev
argument_list|,
literal|0x2
argument_list|,
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_err_stats
operator|.
name|xpak_counter
operator|.
name|excess_bias_current
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_err_stats
operator|.
name|xpak_counter
operator|.
name|excess_bias_current
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|CHECKBIT
argument_list|(
name|val_1
argument_list|,
literal|0x2
argument_list|)
condition|)
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_err_stats
operator|.
name|stats_xpak
operator|.
name|alarm_laser_bias_current_low
operator|++
expr_stmt|;
if|if
condition|(
name|CHECKBIT
argument_list|(
name|val_1
argument_list|,
literal|0x1
argument_list|)
condition|)
block|{
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_err_stats
operator|.
name|stats_xpak
operator|.
name|alarm_laser_output_power_high
operator|++
expr_stmt|;
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_err_stats
operator|.
name|xpak_counter
operator|.
name|excess_laser_output
operator|++
expr_stmt|;
name|__hal_chk_xpak_counter
argument_list|(
name|hldev
argument_list|,
literal|0x3
argument_list|,
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_err_stats
operator|.
name|xpak_counter
operator|.
name|excess_laser_output
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_err_stats
operator|.
name|xpak_counter
operator|.
name|excess_laser_output
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|CHECKBIT
argument_list|(
name|val_1
argument_list|,
literal|0x0
argument_list|)
condition|)
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_err_stats
operator|.
name|stats_xpak
operator|.
name|alarm_laser_output_power_low
operator|++
expr_stmt|;
comment|/* 	 * Reading the warning flags 	 */
name|addr
operator|=
literal|0xA074
expr_stmt|;
name|val_1
operator|=
literal|0x0
expr_stmt|;
name|val_1
operator|=
name|xge_hal_mdio_read
argument_list|(
name|hldev
argument_list|,
name|XGE_HAL_MDIO_MMD_PMA_DEV_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHECKBIT
argument_list|(
name|val_1
argument_list|,
literal|0x7
argument_list|)
condition|)
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_err_stats
operator|.
name|stats_xpak
operator|.
name|warn_transceiver_temp_high
operator|++
expr_stmt|;
if|if
condition|(
name|CHECKBIT
argument_list|(
name|val_1
argument_list|,
literal|0x6
argument_list|)
condition|)
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_err_stats
operator|.
name|stats_xpak
operator|.
name|warn_transceiver_temp_low
operator|++
expr_stmt|;
if|if
condition|(
name|CHECKBIT
argument_list|(
name|val_1
argument_list|,
literal|0x3
argument_list|)
condition|)
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_err_stats
operator|.
name|stats_xpak
operator|.
name|warn_laser_bias_current_high
operator|++
expr_stmt|;
if|if
condition|(
name|CHECKBIT
argument_list|(
name|val_1
argument_list|,
literal|0x2
argument_list|)
condition|)
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_err_stats
operator|.
name|stats_xpak
operator|.
name|warn_laser_bias_current_low
operator|++
expr_stmt|;
if|if
condition|(
name|CHECKBIT
argument_list|(
name|val_1
argument_list|,
literal|0x1
argument_list|)
condition|)
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_err_stats
operator|.
name|stats_xpak
operator|.
name|warn_laser_output_power_high
operator|++
expr_stmt|;
if|if
condition|(
name|CHECKBIT
argument_list|(
name|val_1
argument_list|,
literal|0x0
argument_list|)
condition|)
name|hldev
operator|->
name|stats
operator|.
name|sw_dev_err_stats
operator|.
name|stats_xpak
operator|.
name|warn_laser_output_power_low
operator|++
expr_stmt|;
block|}
end_function

end_unit

