begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002-2007 Neterion, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  *  if_nxge.c  *  *  FreeBSD specific initialization& routines  */
end_comment

begin_include
include|#
directive|include
file|<dev/nxge/if_nxge.h>
end_include

begin_include
include|#
directive|include
file|<dev/nxge/xge-osdep.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_decl_stmt
name|int
name|copyright_print
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|hal_driver_init_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|size
init|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/******************************************  * xge_probe  * Parameters: Device structure  * Return: BUS_PROBE_DEFAULT/ENXIO/ENOMEM  * Description: Probes for Xframe device  ******************************************/
end_comment

begin_function
name|int
name|xge_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|devid
init|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|vendorid
init|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|retValue
init|=
name|ENXIO
decl_stmt|;
name|ENTER_FUNCTION
if|if
condition|(
name|vendorid
operator|==
name|XGE_PCI_VENDOR_ID
condition|)
block|{
if|if
condition|(
operator|(
name|devid
operator|==
name|XGE_PCI_DEVICE_ID_XENA_2
operator|)
operator|||
operator|(
name|devid
operator|==
name|XGE_PCI_DEVICE_ID_HERC_2
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|copyright_print
condition|)
block|{
name|PRINT_COPYRIGHT
expr_stmt|;
name|copyright_print
operator|=
literal|1
expr_stmt|;
block|}
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
literal|"Neterion Xframe 10 Gigabit Ethernet Adapter"
argument_list|)
expr_stmt|;
name|retValue
operator|=
name|BUS_PROBE_DEFAULT
expr_stmt|;
block|}
block|}
name|LEAVE_FUNCTION
return|return
name|retValue
return|;
block|}
end_function

begin_comment
comment|/******************************************  * xge_init_params  * Parameters: HAL device configuration  * structure, device pointer  * Return: None  * Description: Sets parameter values in  * xge_hal_device_config_t structure  ******************************************/
end_comment

begin_function
name|void
name|xge_init_params
parameter_list|(
name|xge_hal_device_config_t
modifier|*
name|dconfig
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|index
decl_stmt|,
name|revision
decl_stmt|;
name|device_t
name|checkdev
decl_stmt|;
name|ENTER_FUNCTION
define|#
directive|define
name|SAVE_PARAM
parameter_list|(
name|to
parameter_list|,
name|what
parameter_list|,
name|value
parameter_list|)
value|to.what = value;
define|#
directive|define
name|GET_PARAM
parameter_list|(
name|str_kenv
parameter_list|,
name|to
parameter_list|,
name|param
parameter_list|,
name|hardcode
parameter_list|)
value|{                            \ 	static int param##__LINE__;                                           \ 	if(testenv(str_kenv) == 1) {                                          \ 	    getenv_int(str_kenv,&param##__LINE__);                           \ 	}                                                                     \ 	else {                                                                \ 	    param##__LINE__ = hardcode;                                       \ 	}                                                                     \ 	SAVE_PARAM(to, param, param##__LINE__);                               \ }
define|#
directive|define
name|GET_PARAM_MAC
parameter_list|(
name|str_kenv
parameter_list|,
name|param
parameter_list|,
name|hardcode
parameter_list|)
define|\
value|GET_PARAM(str_kenv, ((*dconfig).mac), param, hardcode);
define|#
directive|define
name|GET_PARAM_FIFO
parameter_list|(
name|str_kenv
parameter_list|,
name|param
parameter_list|,
name|hardcode
parameter_list|)
define|\
value|GET_PARAM(str_kenv, ((*dconfig).fifo), param, hardcode);
define|#
directive|define
name|GET_PARAM_FIFO_QUEUE
parameter_list|(
name|str_kenv
parameter_list|,
name|param
parameter_list|,
name|qindex
parameter_list|,
name|hardcode
parameter_list|)
define|\
value|GET_PARAM(str_kenv, ((*dconfig).fifo.queue[qindex]), param, hardcode);
define|#
directive|define
name|GET_PARAM_FIFO_QUEUE_TTI
parameter_list|(
name|str_kenv
parameter_list|,
name|param
parameter_list|,
name|qindex
parameter_list|,
name|tindex
parameter_list|,
name|hardcode
parameter_list|)
define|\
value|GET_PARAM(str_kenv, ((*dconfig).fifo.queue[qindex].tti[tindex]),      \ 	    param, hardcode);
define|#
directive|define
name|GET_PARAM_RING
parameter_list|(
name|str_kenv
parameter_list|,
name|param
parameter_list|,
name|hardcode
parameter_list|)
define|\
value|GET_PARAM(str_kenv, ((*dconfig).ring), param, hardcode);
define|#
directive|define
name|GET_PARAM_RING_QUEUE
parameter_list|(
name|str_kenv
parameter_list|,
name|param
parameter_list|,
name|qindex
parameter_list|,
name|hardcode
parameter_list|)
define|\
value|GET_PARAM(str_kenv, ((*dconfig).ring.queue[qindex]), param, hardcode);
define|#
directive|define
name|GET_PARAM_RING_QUEUE_RTI
parameter_list|(
name|str_kenv
parameter_list|,
name|param
parameter_list|,
name|qindex
parameter_list|,
name|hardcode
parameter_list|)
define|\
value|GET_PARAM(str_kenv, ((*dconfig).ring.queue[qindex].rti), param,       \ 	    hardcode);
name|dconfig
operator|->
name|mtu
init|=
name|XGE_DEFAULT_INITIAL_MTU
decl_stmt|;
name|dconfig
operator|->
name|pci_freq_mherz
operator|=
name|XGE_DEFAULT_USER_HARDCODED
expr_stmt|;
name|dconfig
operator|->
name|device_poll_millis
operator|=
name|XGE_HAL_DEFAULT_DEVICE_POLL_MILLIS
expr_stmt|;
name|dconfig
operator|->
name|link_stability_period
operator|=
name|XGE_HAL_DEFAULT_LINK_STABILITY_PERIOD
expr_stmt|;
name|dconfig
operator|->
name|mac
operator|.
name|rmac_bcast_en
operator|=
name|XGE_DEFAULT_MAC_RMAC_BCAST_EN
expr_stmt|;
name|dconfig
operator|->
name|fifo
operator|.
name|alignment_size
operator|=
name|XGE_DEFAULT_FIFO_ALIGNMENT_SIZE
expr_stmt|;
name|GET_PARAM
argument_list|(
literal|"hw.xge.latency_timer"
argument_list|,
operator|(
operator|*
name|dconfig
operator|)
argument_list|,
name|latency_timer
argument_list|,
name|XGE_DEFAULT_LATENCY_TIMER
argument_list|)
expr_stmt|;
name|GET_PARAM
argument_list|(
literal|"hw.xge.max_splits_trans"
argument_list|,
operator|(
operator|*
name|dconfig
operator|)
argument_list|,
name|max_splits_trans
argument_list|,
name|XGE_DEFAULT_MAX_SPLITS_TRANS
argument_list|)
expr_stmt|;
name|GET_PARAM
argument_list|(
literal|"hw.xge.mmrb_count"
argument_list|,
operator|(
operator|*
name|dconfig
operator|)
argument_list|,
name|mmrb_count
argument_list|,
name|XGE_DEFAULT_MMRB_COUNT
argument_list|)
expr_stmt|;
name|GET_PARAM
argument_list|(
literal|"hw.xge.shared_splits"
argument_list|,
operator|(
operator|*
name|dconfig
operator|)
argument_list|,
name|shared_splits
argument_list|,
name|XGE_DEFAULT_SHARED_SPLITS
argument_list|)
expr_stmt|;
name|GET_PARAM
argument_list|(
literal|"hw.xge.isr_polling_cnt"
argument_list|,
operator|(
operator|*
name|dconfig
operator|)
argument_list|,
name|isr_polling_cnt
argument_list|,
name|XGE_DEFAULT_ISR_POLLING_CNT
argument_list|)
expr_stmt|;
name|GET_PARAM
argument_list|(
literal|"hw.xge.stats_refresh_time_sec"
argument_list|,
operator|(
operator|*
name|dconfig
operator|)
argument_list|,
name|stats_refresh_time_sec
argument_list|,
name|XGE_DEFAULT_STATS_REFRESH_TIME_SEC
argument_list|)
expr_stmt|;
name|GET_PARAM_MAC
argument_list|(
literal|"hw.xge.mac_tmac_util_period"
argument_list|,
name|tmac_util_period
argument_list|,
name|XGE_DEFAULT_MAC_TMAC_UTIL_PERIOD
argument_list|)
expr_stmt|;
name|GET_PARAM_MAC
argument_list|(
literal|"hw.xge.mac_rmac_util_period"
argument_list|,
name|rmac_util_period
argument_list|,
name|XGE_DEFAULT_MAC_RMAC_UTIL_PERIOD
argument_list|)
expr_stmt|;
name|GET_PARAM_MAC
argument_list|(
literal|"hw.xge.mac_rmac_pause_gen_en"
argument_list|,
name|rmac_pause_gen_en
argument_list|,
name|XGE_DEFAULT_MAC_RMAC_PAUSE_GEN_EN
argument_list|)
expr_stmt|;
name|GET_PARAM_MAC
argument_list|(
literal|"hw.xge.mac_rmac_pause_rcv_en"
argument_list|,
name|rmac_pause_rcv_en
argument_list|,
name|XGE_DEFAULT_MAC_RMAC_PAUSE_RCV_EN
argument_list|)
expr_stmt|;
name|GET_PARAM_MAC
argument_list|(
literal|"hw.xge.mac_rmac_pause_time"
argument_list|,
name|rmac_pause_time
argument_list|,
name|XGE_DEFAULT_MAC_RMAC_PAUSE_TIME
argument_list|)
expr_stmt|;
name|GET_PARAM_MAC
argument_list|(
literal|"hw.xge.mac_mc_pause_threshold_q0q3"
argument_list|,
name|mc_pause_threshold_q0q3
argument_list|,
name|XGE_DEFAULT_MAC_MC_PAUSE_THRESHOLD_Q0Q3
argument_list|)
expr_stmt|;
name|GET_PARAM_MAC
argument_list|(
literal|"hw.xge.mac_mc_pause_threshold_q4q7"
argument_list|,
name|mc_pause_threshold_q4q7
argument_list|,
name|XGE_DEFAULT_MAC_MC_PAUSE_THRESHOLD_Q4Q7
argument_list|)
expr_stmt|;
name|GET_PARAM_FIFO
argument_list|(
literal|"hw.xge.fifo_memblock_size"
argument_list|,
name|memblock_size
argument_list|,
name|XGE_DEFAULT_FIFO_MEMBLOCK_SIZE
argument_list|)
expr_stmt|;
name|GET_PARAM_FIFO
argument_list|(
literal|"hw.xge.fifo_reserve_threshold"
argument_list|,
name|reserve_threshold
argument_list|,
name|XGE_DEFAULT_FIFO_RESERVE_THRESHOLD
argument_list|)
expr_stmt|;
name|GET_PARAM_FIFO
argument_list|(
literal|"hw.xge.fifo_max_frags"
argument_list|,
name|max_frags
argument_list|,
name|XGE_DEFAULT_FIFO_MAX_FRAGS
argument_list|)
expr_stmt|;
name|GET_PARAM_FIFO_QUEUE
argument_list|(
literal|"hw.xge.fifo_queue_intr"
argument_list|,
name|intr
argument_list|,
literal|0
argument_list|,
name|XGE_DEFAULT_FIFO_QUEUE_INTR
argument_list|)
expr_stmt|;
name|GET_PARAM_FIFO_QUEUE
argument_list|(
literal|"hw.xge.fifo_queue_max"
argument_list|,
name|max
argument_list|,
literal|0
argument_list|,
name|XGE_DEFAULT_FIFO_QUEUE_MAX
argument_list|)
expr_stmt|;
name|GET_PARAM_FIFO_QUEUE
argument_list|(
literal|"hw.xge.fifo_queue_initial"
argument_list|,
name|initial
argument_list|,
literal|0
argument_list|,
name|XGE_DEFAULT_FIFO_QUEUE_INITIAL
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|XGE_HAL_MAX_FIFO_TTI_NUM
condition|;
name|index
operator|++
control|)
block|{
name|dconfig
operator|->
name|fifo
operator|.
name|queue
index|[
literal|0
index|]
operator|.
name|tti
index|[
name|index
index|]
operator|.
name|enabled
operator|=
literal|1
expr_stmt|;
name|dconfig
operator|->
name|fifo
operator|.
name|queue
index|[
literal|0
index|]
operator|.
name|configured
operator|=
literal|1
expr_stmt|;
name|GET_PARAM_FIFO_QUEUE_TTI
argument_list|(
literal|"hw.xge.fifo_queue_tti_urange_a"
argument_list|,
name|urange_a
argument_list|,
literal|0
argument_list|,
name|index
argument_list|,
name|XGE_DEFAULT_FIFO_QUEUE_TTI_URANGE_A
argument_list|)
expr_stmt|;
name|GET_PARAM_FIFO_QUEUE_TTI
argument_list|(
literal|"hw.xge.fifo_queue_tti_urange_b"
argument_list|,
name|urange_b
argument_list|,
literal|0
argument_list|,
name|index
argument_list|,
name|XGE_DEFAULT_FIFO_QUEUE_TTI_URANGE_B
argument_list|)
expr_stmt|;
name|GET_PARAM_FIFO_QUEUE_TTI
argument_list|(
literal|"hw.xge.fifo_queue_tti_urange_c"
argument_list|,
name|urange_c
argument_list|,
literal|0
argument_list|,
name|index
argument_list|,
name|XGE_DEFAULT_FIFO_QUEUE_TTI_URANGE_C
argument_list|)
expr_stmt|;
name|GET_PARAM_FIFO_QUEUE_TTI
argument_list|(
literal|"hw.xge.fifo_queue_tti_ufc_a"
argument_list|,
name|ufc_a
argument_list|,
literal|0
argument_list|,
name|index
argument_list|,
name|XGE_DEFAULT_FIFO_QUEUE_TTI_UFC_A
argument_list|)
expr_stmt|;
name|GET_PARAM_FIFO_QUEUE_TTI
argument_list|(
literal|"hw.xge.fifo_queue_tti_ufc_b"
argument_list|,
name|ufc_b
argument_list|,
literal|0
argument_list|,
name|index
argument_list|,
name|XGE_DEFAULT_FIFO_QUEUE_TTI_UFC_B
argument_list|)
expr_stmt|;
name|GET_PARAM_FIFO_QUEUE_TTI
argument_list|(
literal|"hw.xge.fifo_queue_tti_ufc_c"
argument_list|,
name|ufc_c
argument_list|,
literal|0
argument_list|,
name|index
argument_list|,
name|XGE_DEFAULT_FIFO_QUEUE_TTI_UFC_C
argument_list|)
expr_stmt|;
name|GET_PARAM_FIFO_QUEUE_TTI
argument_list|(
literal|"hw.xge.fifo_queue_tti_ufc_d"
argument_list|,
name|ufc_d
argument_list|,
literal|0
argument_list|,
name|index
argument_list|,
name|XGE_DEFAULT_FIFO_QUEUE_TTI_UFC_D
argument_list|)
expr_stmt|;
name|GET_PARAM_FIFO_QUEUE_TTI
argument_list|(
literal|"hw.xge.fifo_queue_tti_timer_ci_en"
argument_list|,
name|timer_ci_en
argument_list|,
literal|0
argument_list|,
name|index
argument_list|,
name|XGE_DEFAULT_FIFO_QUEUE_TTI_TIMER_CI_EN
argument_list|)
expr_stmt|;
name|GET_PARAM_FIFO_QUEUE_TTI
argument_list|(
literal|"hw.xge.fifo_queue_tti_timer_ac_en"
argument_list|,
name|timer_ac_en
argument_list|,
literal|0
argument_list|,
name|index
argument_list|,
name|XGE_DEFAULT_FIFO_QUEUE_TTI_TIMER_AC_EN
argument_list|)
expr_stmt|;
name|GET_PARAM_FIFO_QUEUE_TTI
argument_list|(
literal|"hw.xge.fifo_queue_tti_timer_val_us"
argument_list|,
name|timer_val_us
argument_list|,
literal|0
argument_list|,
name|index
argument_list|,
name|XGE_DEFAULT_FIFO_QUEUE_TTI_TIMER_VAL_US
argument_list|)
expr_stmt|;
block|}
name|GET_PARAM_RING
argument_list|(
literal|"hw.xge.ring_memblock_size"
argument_list|,
name|memblock_size
argument_list|,
name|XGE_DEFAULT_RING_MEMBLOCK_SIZE
argument_list|)
expr_stmt|;
name|GET_PARAM_RING
argument_list|(
literal|"hw.xge.ring_strip_vlan_tag"
argument_list|,
name|strip_vlan_tag
argument_list|,
name|XGE_DEFAULT_RING_STRIP_VLAN_TAG
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|XGE_HAL_MIN_RING_NUM
condition|;
name|index
operator|++
control|)
block|{
name|dconfig
operator|->
name|ring
operator|.
name|queue
index|[
name|index
index|]
operator|.
name|max_frm_len
operator|=
name|XGE_HAL_RING_USE_MTU
expr_stmt|;
name|dconfig
operator|->
name|ring
operator|.
name|queue
index|[
name|index
index|]
operator|.
name|priority
operator|=
literal|0
expr_stmt|;
name|dconfig
operator|->
name|ring
operator|.
name|queue
index|[
name|index
index|]
operator|.
name|configured
operator|=
literal|1
expr_stmt|;
name|dconfig
operator|->
name|ring
operator|.
name|queue
index|[
name|index
index|]
operator|.
name|buffer_mode
operator|=
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_1
expr_stmt|;
name|GET_PARAM_RING_QUEUE
argument_list|(
literal|"hw.xge.ring_queue_max"
argument_list|,
name|max
argument_list|,
name|index
argument_list|,
name|XGE_DEFAULT_RING_QUEUE_MAX
argument_list|)
expr_stmt|;
name|GET_PARAM_RING_QUEUE
argument_list|(
literal|"hw.xge.ring_queue_initial"
argument_list|,
name|initial
argument_list|,
name|index
argument_list|,
name|XGE_DEFAULT_RING_QUEUE_INITIAL
argument_list|)
expr_stmt|;
name|GET_PARAM_RING_QUEUE
argument_list|(
literal|"hw.xge.ring_queue_dram_size_mb"
argument_list|,
name|dram_size_mb
argument_list|,
name|index
argument_list|,
name|XGE_DEFAULT_RING_QUEUE_DRAM_SIZE_MB
argument_list|)
expr_stmt|;
name|GET_PARAM_RING_QUEUE
argument_list|(
literal|"hw.xge.ring_queue_indicate_max_pkts"
argument_list|,
name|indicate_max_pkts
argument_list|,
name|index
argument_list|,
name|XGE_DEFAULT_RING_QUEUE_INDICATE_MAX_PKTS
argument_list|)
expr_stmt|;
name|GET_PARAM_RING_QUEUE
argument_list|(
literal|"hw.xge.ring_queue_backoff_interval_us"
argument_list|,
name|backoff_interval_us
argument_list|,
name|index
argument_list|,
name|XGE_DEFAULT_RING_QUEUE_BACKOFF_INTERVAL_US
argument_list|)
expr_stmt|;
name|GET_PARAM_RING_QUEUE_RTI
argument_list|(
literal|"hw.xge.ring_queue_rti_ufc_a"
argument_list|,
name|ufc_a
argument_list|,
name|index
argument_list|,
name|XGE_DEFAULT_RING_QUEUE_RTI_UFC_A
argument_list|)
expr_stmt|;
name|GET_PARAM_RING_QUEUE_RTI
argument_list|(
literal|"hw.xge.ring_queue_rti_ufc_b"
argument_list|,
name|ufc_b
argument_list|,
name|index
argument_list|,
name|XGE_DEFAULT_RING_QUEUE_RTI_UFC_B
argument_list|)
expr_stmt|;
name|GET_PARAM_RING_QUEUE_RTI
argument_list|(
literal|"hw.xge.ring_queue_rti_ufc_c"
argument_list|,
name|ufc_c
argument_list|,
name|index
argument_list|,
name|XGE_DEFAULT_RING_QUEUE_RTI_UFC_C
argument_list|)
expr_stmt|;
name|GET_PARAM_RING_QUEUE_RTI
argument_list|(
literal|"hw.xge.ring_queue_rti_ufc_d"
argument_list|,
name|ufc_d
argument_list|,
name|index
argument_list|,
name|XGE_DEFAULT_RING_QUEUE_RTI_UFC_D
argument_list|)
expr_stmt|;
name|GET_PARAM_RING_QUEUE_RTI
argument_list|(
literal|"hw.xge.ring_queue_rti_timer_ac_en"
argument_list|,
name|timer_ac_en
argument_list|,
name|index
argument_list|,
name|XGE_DEFAULT_RING_QUEUE_RTI_TIMER_AC_EN
argument_list|)
expr_stmt|;
name|GET_PARAM_RING_QUEUE_RTI
argument_list|(
literal|"hw.xge.ring_queue_rti_timer_val_us"
argument_list|,
name|timer_val_us
argument_list|,
name|index
argument_list|,
name|XGE_DEFAULT_RING_QUEUE_RTI_TIMER_VAL_US
argument_list|)
expr_stmt|;
name|GET_PARAM_RING_QUEUE_RTI
argument_list|(
literal|"hw.xge.ring_queue_rti_urange_a"
argument_list|,
name|urange_a
argument_list|,
name|index
argument_list|,
name|XGE_DEFAULT_RING_QUEUE_RTI_URANGE_A
argument_list|)
expr_stmt|;
name|GET_PARAM_RING_QUEUE_RTI
argument_list|(
literal|"hw.xge.ring_queue_rti_urange_b"
argument_list|,
name|urange_b
argument_list|,
name|index
argument_list|,
name|XGE_DEFAULT_RING_QUEUE_RTI_URANGE_B
argument_list|)
expr_stmt|;
name|GET_PARAM_RING_QUEUE_RTI
argument_list|(
literal|"hw.xge.ring_queue_rti_urange_c"
argument_list|,
name|urange_c
argument_list|,
name|index
argument_list|,
name|XGE_DEFAULT_RING_QUEUE_RTI_URANGE_C
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dconfig
operator|->
name|fifo
operator|.
name|max_frags
operator|>
operator|(
name|PAGE_SIZE
operator|/
literal|32
operator|)
condition|)
block|{
name|xge_os_printf
argument_list|(
literal|"fifo_max_frags = %d"
argument_list|,
name|dconfig
operator|->
name|fifo
operator|.
name|max_frags
argument_list|)
expr_stmt|;
name|xge_os_printf
argument_list|(
literal|"fifo_max_frags should be<= (PAGE_SIZE / 32) = %d"
argument_list|,
operator|(
name|PAGE_SIZE
operator|/
literal|32
operator|)
argument_list|)
expr_stmt|;
name|xge_os_printf
argument_list|(
literal|"Using fifo_max_frags = %d"
argument_list|,
operator|(
name|PAGE_SIZE
operator|/
literal|32
operator|)
argument_list|)
expr_stmt|;
name|dconfig
operator|->
name|fifo
operator|.
name|max_frags
operator|=
operator|(
name|PAGE_SIZE
operator|/
literal|32
operator|)
expr_stmt|;
block|}
name|checkdev
operator|=
name|pci_find_device
argument_list|(
name|VENDOR_ID_AMD
argument_list|,
name|DEVICE_ID_8131_PCI_BRIDGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|checkdev
operator|!=
name|NULL
condition|)
block|{
comment|/* Check Revision for 0x12 */
name|revision
operator|=
name|pci_read_config
argument_list|(
name|checkdev
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_t
argument_list|,
name|revision
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|revision
operator|<=
literal|0x12
condition|)
block|{
comment|/* Set mmrb_count to 1k and max splits = 2 */
name|dconfig
operator|->
name|mmrb_count
operator|=
literal|1
expr_stmt|;
name|dconfig
operator|->
name|max_splits_trans
operator|=
name|XGE_HAL_THREE_SPLIT_TRANSACTION
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|XGE_FEATURE_LRO
comment|/* updating the LRO frame's sg size and frame len size. */
name|dconfig
operator|->
name|lro_sg_size
operator|=
literal|20
expr_stmt|;
name|dconfig
operator|->
name|lro_frm_len
operator|=
literal|65536
expr_stmt|;
endif|#
directive|endif
name|LEAVE_FUNCTION
block|}
end_function

begin_comment
comment|/******************************************  * xge_driver_initialize  * Parameters: None  * Return: 0/1  * Description: Defines HAL-ULD callbacks  * and initializes the HAL driver  ******************************************/
end_comment

begin_function
name|int
name|xge_driver_initialize
parameter_list|(
name|void
parameter_list|)
block|{
name|xge_hal_uld_cbs_t
name|uld_callbacks
decl_stmt|;
name|xge_hal_driver_config_t
name|driver_config
decl_stmt|;
name|xge_hal_status_e
name|status
init|=
name|XGE_HAL_OK
decl_stmt|;
name|ENTER_FUNCTION
comment|/* Initialize HAL driver */
if|if
condition|(
operator|!
name|hal_driver_init_count
condition|)
block|{
name|xge_os_memzero
argument_list|(
operator|&
name|uld_callbacks
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_uld_cbs_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	     * Initial and maximum size of the queue used to store the events 	     * like Link up/down (xge_hal_event_e) 	     */
name|driver_config
operator|.
name|queue_size_initial
operator|=
literal|1
expr_stmt|;
name|driver_config
operator|.
name|queue_size_max
operator|=
literal|4
expr_stmt|;
name|uld_callbacks
operator|.
name|link_up
operator|=
name|xgell_callback_link_up
expr_stmt|;
name|uld_callbacks
operator|.
name|link_down
operator|=
name|xgell_callback_link_down
expr_stmt|;
name|uld_callbacks
operator|.
name|crit_err
operator|=
name|xgell_callback_crit_err
expr_stmt|;
name|uld_callbacks
operator|.
name|event
operator|=
name|xgell_callback_event
expr_stmt|;
name|status
operator|=
name|xge_hal_driver_initialize
argument_list|(
operator|&
name|driver_config
argument_list|,
operator|&
name|uld_callbacks
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_os_printf
argument_list|(
literal|"xgeX: Initialization failed (Status: %d)"
argument_list|,
name|status
argument_list|)
expr_stmt|;
goto|goto
name|xdi_out
goto|;
block|}
block|}
name|hal_driver_init_count
operator|=
name|hal_driver_init_count
operator|+
literal|1
expr_stmt|;
name|xge_hal_driver_debug_module_mask_set
argument_list|(
literal|0xffffffff
argument_list|)
expr_stmt|;
name|xge_hal_driver_debug_level_set
argument_list|(
name|XGE_TRACE
argument_list|)
expr_stmt|;
name|xdi_out
label|:
name|LEAVE_FUNCTION
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/******************************************  * Function:    xge_media_init  * Parameters:  Device pointer  * Return:      None  * Description: Initializes, adds and sets  *              media  ******************************************/
end_comment

begin_function
name|void
name|xge_media_init
parameter_list|(
name|device_t
name|devc
parameter_list|)
block|{
name|xgelldev_t
modifier|*
name|lldev
init|=
operator|(
name|xgelldev_t
operator|*
operator|)
name|device_get_softc
argument_list|(
name|devc
argument_list|)
decl_stmt|;
name|ENTER_FUNCTION
comment|/* Initialize Media */
name|ifmedia_init
argument_list|(
operator|&
name|lldev
operator|->
name|xge_media
argument_list|,
name|IFM_IMASK
argument_list|,
name|xge_ifmedia_change
argument_list|,
name|xge_ifmedia_status
argument_list|)
decl_stmt|;
comment|/* Add supported media */
name|ifmedia_add
argument_list|(
operator|&
name|lldev
operator|->
name|xge_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_SX
operator||
name|IFM_FDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|lldev
operator|->
name|xge_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_SX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|lldev
operator|->
name|xge_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|lldev
operator|->
name|xge_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_SR
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|lldev
operator|->
name|xge_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_LR
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Set media */
name|ifmedia_set
argument_list|(
operator|&
name|lldev
operator|->
name|xge_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
name|LEAVE_FUNCTION
block|}
end_function

begin_comment
comment|/*  * xge_pci_space_save  * Save PCI configuration space  * @dev Device structure  */
end_comment

begin_function
name|void
name|xge_pci_space_save
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|ENTER_FUNCTION
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|NULL
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|xge_trace
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"Saving PCI configuration space"
argument_list|)
expr_stmt|;
name|pci_cfg_save
argument_list|(
name|dev
argument_list|,
name|dinfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LEAVE_FUNCTION
block|}
end_function

begin_comment
comment|/*  * xge_pci_space_restore  * Restore saved PCI configuration space  * @dev Device structure  */
end_comment

begin_function
name|void
name|xge_pci_space_restore
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|ENTER_FUNCTION
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|NULL
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|xge_trace
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"Restoring PCI configuration space"
argument_list|)
expr_stmt|;
name|pci_cfg_restore
argument_list|(
name|dev
argument_list|,
name|dinfo
argument_list|)
expr_stmt|;
name|LEAVE_FUNCTION
block|}
end_function

begin_comment
comment|/******************************************  * xge_attach  * Parameters: Per adapter xgelldev_t  * structure pointer  * Return: None  * Description: Connects the driver to the  * system if the probe routine returned success  ******************************************/
end_comment

begin_function
name|int
name|xge_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|xge_hal_device_config_t
modifier|*
name|device_config
decl_stmt|;
name|xge_hal_ring_config_t
modifier|*
name|pRingConfig
decl_stmt|;
name|xge_hal_device_attr_t
name|attr
decl_stmt|;
name|xgelldev_t
modifier|*
name|lldev
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
decl_stmt|;
name|pci_info_t
modifier|*
name|pci_info
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifnetp
decl_stmt|;
name|char
modifier|*
name|mesg
decl_stmt|;
name|char
modifier|*
name|desc
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|int
name|rid0
decl_stmt|;
name|int
name|rid1
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u64
name|val64
init|=
literal|0
decl_stmt|;
name|int
name|retValue
init|=
literal|0
decl_stmt|;
name|int
name|mode
init|=
literal|0
decl_stmt|;
name|int
name|buffer_index
decl_stmt|,
name|buffer_length
decl_stmt|,
name|index
decl_stmt|;
name|ENTER_FUNCTION
name|device_config
init|=
name|xge_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|xge_hal_device_config_t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|device_config
condition|)
block|{
name|xge_ctrace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Malloc of device config failed"
argument_list|)
expr_stmt|;
name|retValue
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|attach_out_config
goto|;
block|}
name|lldev
operator|=
operator|(
name|xgelldev_t
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lldev
condition|)
block|{
name|xge_ctrace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Adapter softc structure allocation failed"
argument_list|)
expr_stmt|;
name|retValue
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|attach_out
goto|;
block|}
name|lldev
operator|->
name|device
operator|=
name|dev
expr_stmt|;
comment|/* Initialize mutex */
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mtx_init
argument_list|(
operator|(
operator|&
name|lldev
operator|->
name|xge_lock
operator|)
argument_list|,
literal|"xge"
argument_list|,
name|MTX_NETWORK_LOCK
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|xge_driver_initialize
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_ctrace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Initializing driver failed"
argument_list|)
expr_stmt|;
name|freeResources
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|retValue
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|attach_out
goto|;
block|}
comment|/* HAL device */
name|hldev
operator|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|xge_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|xge_hal_device_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hldev
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Allocating memory for xge_hal_device_t failed"
argument_list|)
expr_stmt|;
name|freeResources
argument_list|(
name|dev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|retValue
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|attach_out
goto|;
block|}
name|lldev
operator|->
name|devh
operator|=
name|hldev
expr_stmt|;
comment|/* Our private structure */
name|pci_info
operator|=
operator|(
name|pci_info_t
operator|*
operator|)
name|xge_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|pci_info_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pci_info
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Allocating memory for pci_info_t failed"
argument_list|)
expr_stmt|;
name|freeResources
argument_list|(
name|dev
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|retValue
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|attach_out
goto|;
block|}
name|lldev
operator|->
name|pdev
operator|=
name|pci_info
expr_stmt|;
name|pci_info
operator|->
name|device
operator|=
name|dev
expr_stmt|;
comment|/* Set bus master */
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Get virtual address for BAR0 */
name|rid0
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|pci_info
operator|->
name|regmap0
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid0
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_info
operator|->
name|regmap0
operator|==
name|NULL
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"NULL handler for BAR0"
argument_list|)
expr_stmt|;
name|freeResources
argument_list|(
name|dev
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|retValue
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|attach_out
goto|;
block|}
name|attr
operator|.
name|bar0
operator|=
operator|(
name|char
operator|*
operator|)
name|pci_info
operator|->
name|regmap0
expr_stmt|;
name|pci_info
operator|->
name|bar0resource
operator|=
operator|(
name|busresource_t
operator|*
operator|)
name|xge_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|busresource_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_info
operator|->
name|bar0resource
operator|==
name|NULL
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Allocating memory for bar0resources failed"
argument_list|)
expr_stmt|;
name|freeResources
argument_list|(
name|dev
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|retValue
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|attach_out
goto|;
block|}
operator|(
operator|(
expr|struct
name|busresources
operator|*
operator|)
operator|(
name|pci_info
operator|->
name|bar0resource
operator|)
operator|)
operator|->
name|bus_tag
operator|=
name|rman_get_bustag
argument_list|(
name|pci_info
operator|->
name|regmap0
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|busresources
operator|*
operator|)
operator|(
name|pci_info
operator|->
name|bar0resource
operator|)
operator|)
operator|->
name|bus_handle
operator|=
name|rman_get_bushandle
argument_list|(
name|pci_info
operator|->
name|regmap0
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|busresources
operator|*
operator|)
operator|(
name|pci_info
operator|->
name|bar0resource
operator|)
operator|)
operator|->
name|bar_start_addr
operator|=
name|pci_info
operator|->
name|regmap0
expr_stmt|;
comment|/* Get virtual address for BAR1 */
name|rid1
operator|=
name|PCIR_BAR
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|pci_info
operator|->
name|regmap1
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_info
operator|->
name|regmap1
operator|==
name|NULL
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"NULL handler for BAR1"
argument_list|)
expr_stmt|;
name|freeResources
argument_list|(
name|dev
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|retValue
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|attach_out
goto|;
block|}
name|attr
operator|.
name|bar1
operator|=
operator|(
name|char
operator|*
operator|)
name|pci_info
operator|->
name|regmap1
expr_stmt|;
name|pci_info
operator|->
name|bar1resource
operator|=
operator|(
name|busresource_t
operator|*
operator|)
name|xge_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|busresource_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_info
operator|->
name|bar1resource
operator|==
name|NULL
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Allocating memory for bar0resources failed"
argument_list|)
expr_stmt|;
name|freeResources
argument_list|(
name|dev
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|retValue
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|attach_out
goto|;
block|}
operator|(
operator|(
expr|struct
name|busresources
operator|*
operator|)
operator|(
name|pci_info
operator|->
name|bar1resource
operator|)
operator|)
operator|->
name|bus_tag
operator|=
name|rman_get_bustag
argument_list|(
name|pci_info
operator|->
name|regmap1
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|busresources
operator|*
operator|)
operator|(
name|pci_info
operator|->
name|bar1resource
operator|)
operator|)
operator|->
name|bus_handle
operator|=
name|rman_get_bushandle
argument_list|(
name|pci_info
operator|->
name|regmap1
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|busresources
operator|*
operator|)
operator|(
name|pci_info
operator|->
name|bar1resource
operator|)
operator|)
operator|->
name|bar_start_addr
operator|=
name|pci_info
operator|->
name|regmap1
expr_stmt|;
comment|/* Save PCI config space */
name|xge_pci_space_save
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|attr
operator|.
name|regh0
operator|=
operator|(
name|busresource_t
operator|*
operator|)
name|pci_info
operator|->
name|bar0resource
expr_stmt|;
name|attr
operator|.
name|regh1
operator|=
operator|(
name|busresource_t
operator|*
operator|)
name|pci_info
operator|->
name|bar1resource
expr_stmt|;
name|attr
operator|.
name|irqh
operator|=
name|lldev
operator|->
name|irqhandle
expr_stmt|;
name|attr
operator|.
name|cfgh
operator|=
name|pci_info
expr_stmt|;
name|attr
operator|.
name|pdev
operator|=
name|pci_info
expr_stmt|;
comment|/* Initialize device configuration parameters */
name|xge_init_params
argument_list|(
name|device_config
argument_list|,
name|dev
argument_list|)
expr_stmt|;
comment|/* Initialize HAL device */
name|error
operator|=
name|xge_hal_device_initialize
argument_list|(
name|hldev
argument_list|,
operator|&
name|attr
argument_list|,
name|device_config
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|XGE_HAL_OK
condition|)
block|{
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|XGE_HAL_ERR_DRIVER_NOT_INITIALIZED
case|:
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"XGE_HAL_ERR_DRIVER_NOT_INITIALIZED"
argument_list|)
expr_stmt|;
break|break;
case|case
name|XGE_HAL_ERR_OUT_OF_MEMORY
case|:
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"XGE_HAL_ERR_OUT_OF_MEMORY"
argument_list|)
expr_stmt|;
break|break;
case|case
name|XGE_HAL_ERR_BAD_SUBSYSTEM_ID
case|:
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"XGE_HAL_ERR_BAD_SUBSYSTEM_ID"
argument_list|)
expr_stmt|;
break|break;
case|case
name|XGE_HAL_ERR_INVALID_MAC_ADDRESS
case|:
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"XGE_HAL_ERR_INVALID_MAC_ADDRESS"
argument_list|)
expr_stmt|;
break|break;
case|case
name|XGE_HAL_INF_MEM_STROBE_CMD_EXECUTING
case|:
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"XGE_HAL_INF_MEM_STROBE_CMD_EXECUTING"
argument_list|)
expr_stmt|;
break|break;
case|case
name|XGE_HAL_ERR_SWAPPER_CTRL
case|:
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"XGE_HAL_ERR_SWAPPER_CTRL"
argument_list|)
expr_stmt|;
break|break;
case|case
name|XGE_HAL_ERR_DEVICE_IS_NOT_QUIESCENT
case|:
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"XGE_HAL_ERR_DEVICE_IS_NOT_QUIESCENT"
argument_list|)
expr_stmt|;
break|break;
block|}
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Initializing HAL device failed (error: %d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|freeResources
argument_list|(
name|dev
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|retValue
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|attach_out
goto|;
block|}
name|desc
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|100
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|==
name|NULL
condition|)
block|{
name|retValue
operator|=
name|ENOMEM
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|desc
argument_list|,
literal|"%s (Rev %d) Driver v%s \n%s: Serial Number: %s "
argument_list|,
name|hldev
operator|->
name|vpd_data
operator|.
name|product_name
argument_list|,
name|hldev
operator|->
name|revision
argument_list|,
name|DRIVER_VERSION
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|hldev
operator|->
name|vpd_data
operator|.
name|serial_num
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Xframe%s %s\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
operator|(
operator|(
name|hldev
operator|->
name|device_id
operator|==
name|XGE_PCI_DEVICE_ID_XENA_2
operator|)
condition|?
literal|"I"
else|:
literal|"II"
operator|)
argument_list|,
name|desc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|desc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|XGE_PCI_DEVICE_ID_HERC_2
condition|)
block|{
name|error
operator|=
name|xge_hal_mgmt_reg_read
argument_list|(
name|hldev
argument_list|,
literal|0
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_bar0_t
argument_list|,
name|pci_info
argument_list|)
argument_list|,
operator|&
name|val64
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Error for getting bus speed"
argument_list|)
expr_stmt|;
block|}
name|mesg
operator|=
operator|(
name|char
operator|*
operator|)
name|xge_malloc
argument_list|(
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
name|mesg
operator|==
name|NULL
condition|)
block|{
name|freeResources
argument_list|(
name|dev
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|retValue
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|attach_out
goto|;
block|}
name|sprintf
argument_list|(
name|mesg
argument_list|,
literal|"%s: Device is on %s bit"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
operator|(
name|val64
operator|&
name|BIT
argument_list|(
literal|8
argument_list|)
operator|)
condition|?
literal|"32"
else|:
literal|"64"
argument_list|)
expr_stmt|;
name|mode
operator|=
call|(
name|u8
call|)
argument_list|(
operator|(
name|val64
operator|&
name|vBIT
argument_list|(
literal|0xF
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
operator|)
operator|>>
literal|60
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
literal|0x00
case|:
name|xge_os_printf
argument_list|(
literal|"%s PCI 33MHz bus"
argument_list|,
name|mesg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x01
case|:
name|xge_os_printf
argument_list|(
literal|"%s PCI 66MHz bus"
argument_list|,
name|mesg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x02
case|:
name|xge_os_printf
argument_list|(
literal|"%s PCIX(M1) 66MHz bus"
argument_list|,
name|mesg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x03
case|:
name|xge_os_printf
argument_list|(
literal|"%s PCIX(M1) 100MHz bus"
argument_list|,
name|mesg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x04
case|:
name|xge_os_printf
argument_list|(
literal|"%s PCIX(M1) 133MHz bus"
argument_list|,
name|mesg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x05
case|:
name|xge_os_printf
argument_list|(
literal|"%s PCIX(M2) 133MHz bus"
argument_list|,
name|mesg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x06
case|:
name|xge_os_printf
argument_list|(
literal|"%s PCIX(M2) 200MHz bus"
argument_list|,
name|mesg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x07
case|:
name|xge_os_printf
argument_list|(
literal|"%s PCIX(M2) 266MHz bus"
argument_list|,
name|mesg
argument_list|)
expr_stmt|;
break|break;
block|}
name|free
argument_list|(
name|mesg
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|xge_hal_device_private_set
argument_list|(
name|hldev
argument_list|,
name|lldev
argument_list|)
expr_stmt|;
name|error
operator|=
name|xge_interface_setup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|retValue
operator|=
name|error
expr_stmt|;
goto|goto
name|attach_out
goto|;
block|}
name|ifnetp
operator|=
name|lldev
operator|->
name|ifnetp
expr_stmt|;
name|ifnetp
operator|->
name|if_mtu
operator|=
name|device_config
operator|->
name|mtu
expr_stmt|;
name|xge_media_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Interrupt */
name|rid
operator|=
literal|0
expr_stmt|;
name|lldev
operator|->
name|irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|lldev
operator|->
name|irq
operator|==
name|NULL
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"NULL handler for IRQ"
argument_list|)
expr_stmt|;
name|freeResources
argument_list|(
name|dev
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|retValue
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|attach_out
goto|;
block|}
comment|/* Associate interrupt handler with the device */
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|lldev
operator|->
name|irq
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|700030
name|xge_intr_filter
argument_list|,
endif|#
directive|endif
operator|(
name|void
operator|*
operator|)
name|xge_intr
argument_list|,
name|lldev
argument_list|,
operator|&
name|lldev
operator|->
name|irqhandle
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Associating interrupt handler with device failed"
argument_list|)
expr_stmt|;
name|freeResources
argument_list|(
name|dev
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|retValue
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|attach_out
goto|;
block|}
comment|/* Create DMA tags */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
comment|/* Parent                    */
name|PAGE_SIZE
argument_list|,
comment|/* Alignment                 */
literal|0
argument_list|,
comment|/* Bounds                    */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* Low Address               */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* High Address              */
name|NULL
argument_list|,
comment|/* Filter Function           */
name|NULL
argument_list|,
comment|/* Filter Function Arguments */
name|MCLBYTES
operator|*
name|MAX_SEGS
argument_list|,
comment|/* Maximum Size              */
name|MAX_SEGS
argument_list|,
comment|/* Number of Segments        */
name|MCLBYTES
argument_list|,
comment|/* Maximum Segment Size      */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* Flags                     */
name|NULL
argument_list|,
comment|/* Lock Function             */
name|NULL
argument_list|,
comment|/* Lock Function Arguments   */
operator|(
operator|&
name|lldev
operator|->
name|dma_tag_tx
operator|)
argument_list|)
expr_stmt|;
comment|/* DMA Tag                   */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Tx DMA tag creation failed"
argument_list|)
expr_stmt|;
name|freeResources
argument_list|(
name|dev
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|retValue
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|attach_out
goto|;
block|}
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
comment|/* Parent                    */
name|PAGE_SIZE
argument_list|,
comment|/* Alignment                 */
literal|0
argument_list|,
comment|/* Bounds                    */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* Low Address               */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* High Address              */
name|NULL
argument_list|,
comment|/* Filter Function           */
name|NULL
argument_list|,
comment|/* Filter Function Arguments */
name|MJUMPAGESIZE
argument_list|,
comment|/* Maximum Size              */
literal|1
argument_list|,
comment|/* Number of Segments        */
name|MJUMPAGESIZE
argument_list|,
comment|/* Maximum Segment Size      */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* Flags                     */
name|NULL
argument_list|,
comment|/* Lock Function             */
name|NULL
argument_list|,
comment|/* Lock Function Arguments   */
operator|(
operator|&
name|lldev
operator|->
name|dma_tag_rx
operator|)
argument_list|)
expr_stmt|;
comment|/* DMA Tag                   */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Rx DMA tag creation failed"
argument_list|)
expr_stmt|;
name|freeResources
argument_list|(
name|dev
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|retValue
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|attach_out
goto|;
block|}
comment|/*Updating lldev->buffer_mode parameter*/
name|pRingConfig
operator|=
operator|&
operator|(
name|hldev
operator|->
name|config
operator|.
name|ring
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|device_config
operator|->
name|mtu
operator|+
name|XGE_HAL_MAC_HEADER_MAX_SIZE
operator|)
operator|<=
name|PAGE_SIZE
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|XGE_FEATURE_BUFFER_MODE_3
argument_list|)
name|xge_os_printf
argument_list|(
literal|"%s: 3 Buffer Mode Enabled"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|XGE_RING_COUNT
condition|;
name|index
operator|++
control|)
block|{
name|pRingConfig
operator|->
name|queue
index|[
name|index
index|]
operator|.
name|buffer_mode
operator|=
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_3
expr_stmt|;
block|}
name|pRingConfig
operator|->
name|scatter_mode
operator|=
name|XGE_HAL_RING_QUEUE_SCATTER_MODE_A
expr_stmt|;
name|lldev
operator|->
name|buffer_mode
operator|=
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_3
expr_stmt|;
name|lldev
operator|->
name|rxd_mbuf_len
index|[
literal|0
index|]
operator|=
name|XGE_HAL_MAC_HEADER_MAX_SIZE
expr_stmt|;
name|lldev
operator|->
name|rxd_mbuf_len
index|[
literal|1
index|]
operator|=
name|XGE_HAL_TCPIP_HEADER_MAX_SIZE
expr_stmt|;
name|lldev
operator|->
name|rxd_mbuf_len
index|[
literal|2
index|]
operator|=
name|device_config
operator|->
name|mtu
expr_stmt|;
name|lldev
operator|->
name|rxd_mbuf_cnt
operator|=
literal|3
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|XGE_FEATURE_BUFFER_MODE_2
argument_list|)
name|xge_os_printf
argument_list|(
literal|"%s: 2 Buffer Mode Enabled"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|XGE_RING_COUNT
condition|;
name|index
operator|++
control|)
block|{
name|pRingConfig
operator|->
name|queue
index|[
name|index
index|]
operator|.
name|buffer_mode
operator|=
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_3
expr_stmt|;
block|}
name|pRingConfig
operator|->
name|scatter_mode
operator|=
name|XGE_HAL_RING_QUEUE_SCATTER_MODE_B
expr_stmt|;
name|lldev
operator|->
name|buffer_mode
operator|=
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_2
expr_stmt|;
name|lldev
operator|->
name|rxd_mbuf_len
index|[
literal|0
index|]
operator|=
name|XGE_HAL_MAC_HEADER_MAX_SIZE
expr_stmt|;
name|lldev
operator|->
name|rxd_mbuf_len
index|[
literal|1
index|]
operator|=
name|device_config
operator|->
name|mtu
expr_stmt|;
name|lldev
operator|->
name|rxd_mbuf_cnt
operator|=
literal|2
expr_stmt|;
else|#
directive|else
name|lldev
operator|->
name|buffer_mode
operator|=
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_1
expr_stmt|;
name|lldev
operator|->
name|rxd_mbuf_len
index|[
literal|0
index|]
operator|=
name|device_config
operator|->
name|mtu
expr_stmt|;
name|lldev
operator|->
name|rxd_mbuf_cnt
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
else|else
block|{
name|xge_os_printf
argument_list|(
literal|"%s: 5 Buffer Mode Enabled"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|xge_os_memzero
argument_list|(
name|lldev
operator|->
name|rxd_mbuf_len
argument_list|,
sizeof|sizeof
argument_list|(
name|lldev
operator|->
name|rxd_mbuf_len
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|XGE_RING_COUNT
condition|;
name|index
operator|++
control|)
block|{
name|pRingConfig
operator|->
name|queue
index|[
name|index
index|]
operator|.
name|buffer_mode
operator|=
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_5
expr_stmt|;
block|}
name|lldev
operator|->
name|buffer_mode
operator|=
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_5
expr_stmt|;
name|buffer_length
operator|=
name|device_config
operator|->
name|mtu
expr_stmt|;
name|buffer_index
operator|=
literal|2
expr_stmt|;
name|lldev
operator|->
name|rxd_mbuf_len
index|[
literal|0
index|]
operator|=
name|XGE_HAL_MAC_HEADER_MAX_SIZE
expr_stmt|;
name|lldev
operator|->
name|rxd_mbuf_len
index|[
literal|1
index|]
operator|=
name|XGE_HAL_TCPIP_HEADER_MAX_SIZE
expr_stmt|;
while|while
condition|(
name|buffer_length
operator|>
name|PAGE_SIZE
condition|)
block|{
name|buffer_length
operator|-=
name|PAGE_SIZE
expr_stmt|;
name|lldev
operator|->
name|rxd_mbuf_len
index|[
name|buffer_index
index|]
operator|=
name|PAGE_SIZE
expr_stmt|;
name|buffer_index
operator|++
expr_stmt|;
block|}
name|BUFALIGN
argument_list|(
name|buffer_length
argument_list|)
expr_stmt|;
name|lldev
operator|->
name|rxd_mbuf_len
index|[
name|buffer_index
index|]
operator|=
name|buffer_length
expr_stmt|;
name|lldev
operator|->
name|rxd_mbuf_cnt
operator|=
name|buffer_index
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|XGE_FEATURE_LRO
name|xge_os_printf
argument_list|(
literal|"%s: LRO (Large Receive Offload) Enabled"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XGE_FEATURE_TSO
name|xge_os_printf
argument_list|(
literal|"%s: TSO (TCP Segmentation Offload) enabled"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|attach_out
label|:
name|free
argument_list|(
name|device_config
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|attach_out_config
label|:
name|LEAVE_FUNCTION
return|return
name|retValue
return|;
block|}
end_function

begin_comment
comment|/******************************************  * freeResources  * Parameters: Device structure, error (used  * to branch freeing)  * Return: None  * Description: Frees allocated resources  ******************************************/
end_comment

begin_function
name|void
name|freeResources
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|xgelldev_t
modifier|*
name|lldev
decl_stmt|;
name|pci_info_t
modifier|*
name|pci_info
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|status
decl_stmt|;
name|ENTER_FUNCTION
comment|/* LL Device */
name|lldev
init|=
operator|(
name|xgelldev_t
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|pci_info
operator|=
name|lldev
operator|->
name|pdev
expr_stmt|;
comment|/* HAL Device */
name|hldev
operator|=
name|lldev
operator|->
name|devh
expr_stmt|;
switch|switch
condition|(
name|error
condition|)
block|{
case|case
literal|0
case|:
name|status
operator|=
name|bus_dma_tag_destroy
argument_list|(
name|lldev
operator|->
name|dma_tag_rx
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Rx DMA tag destroy failed"
argument_list|)
expr_stmt|;
block|}
case|case
literal|13
case|:
name|status
operator|=
name|bus_dma_tag_destroy
argument_list|(
name|lldev
operator|->
name|dma_tag_tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Tx DMA tag destroy failed"
argument_list|)
expr_stmt|;
block|}
case|case
literal|12
case|:
comment|/* Teardown interrupt handler - device association */
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|lldev
operator|->
name|irq
argument_list|,
name|lldev
operator|->
name|irqhandle
argument_list|)
expr_stmt|;
case|case
literal|11
case|:
comment|/* Release IRQ */
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|lldev
operator|->
name|irq
argument_list|)
expr_stmt|;
case|case
literal|10
case|:
comment|/* Media */
name|ifmedia_removeall
argument_list|(
operator|&
name|lldev
operator|->
name|xge_media
argument_list|)
expr_stmt|;
comment|/* Detach Ether */
name|ether_ifdetach
argument_list|(
name|lldev
operator|->
name|ifnetp
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|lldev
operator|->
name|ifnetp
argument_list|)
expr_stmt|;
name|xge_hal_device_private_set
argument_list|(
name|hldev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xge_hal_device_disable
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
case|case
literal|9
case|:
comment|/* HAL Device */
name|xge_hal_device_terminate
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
case|case
literal|8
case|:
comment|/* Restore PCI configuration space */
name|xge_pci_space_restore
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Free bar1resource */
name|free
argument_list|(
name|pci_info
operator|->
name|bar1resource
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
case|case
literal|7
case|:
comment|/* Release BAR1 */
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rid
argument_list|,
name|pci_info
operator|->
name|regmap1
argument_list|)
expr_stmt|;
case|case
literal|6
case|:
comment|/* Free bar0resource */
name|free
argument_list|(
name|pci_info
operator|->
name|bar0resource
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
case|case
literal|5
case|:
comment|/* Release BAR0 */
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rid
argument_list|,
name|pci_info
operator|->
name|regmap0
argument_list|)
expr_stmt|;
case|case
literal|4
case|:
comment|/* Disable Bus Master */
name|pci_disable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Free pci_info_t */
name|lldev
operator|->
name|pdev
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|pci_info
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
case|case
literal|3
case|:
comment|/* Free device configuration struct and HAL device */
name|free
argument_list|(
name|hldev
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
case|case
literal|2
case|:
comment|/* Terminate HAL driver */
name|hal_driver_init_count
operator|=
name|hal_driver_init_count
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|hal_driver_init_count
condition|)
block|{
name|xge_hal_driver_terminate
argument_list|()
expr_stmt|;
block|}
case|case
literal|1
case|:
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mtx_destroy
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
block|}
block|}
name|LEAVE_FUNCTION
block|}
end_function

begin_comment
comment|/******************************************  * xge_detach  * Parameters: Device structure  * Return: 0  * Description: Detaches the driver from the  * kernel subsystem.  ******************************************/
end_comment

begin_function
name|int
name|xge_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|xgelldev_t
modifier|*
name|lldev
init|=
operator|(
name|xgelldev_t
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|ENTER_FUNCTION
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
decl_stmt|;
name|lldev
operator|->
name|in_detach
operator|=
literal|1
expr_stmt|;
name|xge_stop
argument_list|(
name|lldev
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
name|freeResources
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LEAVE_FUNCTION
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/******************************************  * xge_shutdown  * Parameters: Per adapter xgelldev_t  * structure pointer  * Return: None  * Description: Gets called when the system  * is about to be shutdown.  ******************************************/
end_comment

begin_function
name|int
name|xge_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|xgelldev_t
modifier|*
name|lldev
init|=
operator|(
name|xgelldev_t
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|ENTER_FUNCTION
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
decl_stmt|;
name|xge_stop
argument_list|(
name|lldev
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
name|LEAVE_FUNCTION
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/******************************************  * Function:    xge_interface_setup  * Parameters:  Device pointer  * Return:      0/ENXIO/ENOMEM  * Description: Sets up the interface  *              through ifnet pointer  ******************************************/
end_comment

begin_function
name|int
name|xge_interface_setup
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|u8
name|mcaddr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|xge_hal_status_e
name|status_code
decl_stmt|;
name|xgelldev_t
modifier|*
name|lldev
init|=
operator|(
name|xgelldev_t
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifnetp
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
init|=
name|lldev
operator|->
name|devh
decl_stmt|;
name|int
name|retValue
init|=
literal|0
decl_stmt|;
name|ENTER_FUNCTION
comment|/* Get the MAC address of the device */
name|status_code
init|=
name|xge_hal_device_macaddr_get
argument_list|(
name|hldev
argument_list|,
literal|0
argument_list|,
operator|&
name|mcaddr
argument_list|)
decl_stmt|;
if|if
condition|(
name|status_code
operator|!=
name|XGE_HAL_OK
condition|)
block|{
switch|switch
condition|(
name|status_code
condition|)
block|{
case|case
name|XGE_HAL_INF_MEM_STROBE_CMD_EXECUTING
case|:
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Failed to retrieve MAC address (timeout)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|XGE_HAL_ERR_OUT_OF_MAC_ADDRESSES
case|:
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Invalid MAC address index"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|xge_trace
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"Default Case"
argument_list|)
expr_stmt|;
break|break;
block|}
name|freeResources
argument_list|(
name|dev
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|retValue
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|ifsetup_out
goto|;
block|}
comment|/* Get interface ifnet structure for this Ether device */
name|ifnetp
operator|=
name|lldev
operator|->
name|ifnetp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifnetp
operator|==
name|NULL
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Allocating/getting ifnet structure failed"
argument_list|)
expr_stmt|;
name|freeResources
argument_list|(
name|dev
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|retValue
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|ifsetup_out
goto|;
block|}
comment|/* Initialize interface ifnet structure */
name|if_initname
argument_list|(
name|ifnetp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifnetp
operator|->
name|if_mtu
operator|=
name|XGE_HAL_DEFAULT_MTU
expr_stmt|;
comment|/* 	 * TODO: Can't set more than 2Gbps. -- Higher value results in overflow. 	 * But there is no effect in performance even if you set this to 10 Mbps 	 */
name|ifnetp
operator|->
name|if_baudrate
operator|=
name|IF_Gbps
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|ifnetp
operator|->
name|if_init
operator|=
name|xge_init
expr_stmt|;
name|ifnetp
operator|->
name|if_softc
operator|=
name|lldev
expr_stmt|;
name|ifnetp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifnetp
operator|->
name|if_ioctl
operator|=
name|xge_ioctl
expr_stmt|;
name|ifnetp
operator|->
name|if_start
operator|=
name|xge_send
expr_stmt|;
comment|/* TODO: Check and assign optimal value */
name|ifnetp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|ifnetp
operator|->
name|if_capabilities
operator|=
name|IFCAP_VLAN_HWTAGGING
operator||
name|IFCAP_VLAN_MTU
operator||
name|IFCAP_HWCSUM
expr_stmt|;
name|ifnetp
operator|->
name|if_capenable
operator|=
name|ifnetp
operator|->
name|if_capabilities
expr_stmt|;
ifdef|#
directive|ifdef
name|XGE_FEATURE_TSO
name|ifnetp
operator|->
name|if_capabilities
operator||=
name|IFCAP_TSO4
expr_stmt|;
name|ifnetp
operator|->
name|if_capenable
operator||=
name|IFCAP_TSO4
expr_stmt|;
endif|#
directive|endif
comment|/* Attach the interface */
name|ether_ifattach
argument_list|(
name|ifnetp
argument_list|,
name|mcaddr
argument_list|)
expr_stmt|;
name|ifsetup_out
label|:
name|LEAVE_FUNCTION
return|return
name|retValue
return|;
block|}
end_function

begin_comment
comment|/******************************************  * xgell_callback_link_up  * Parameters: Per adapter xgelldev_t  * structure pointer as void *  * Return: None  * Description: Called by HAL to notify  * hardware link up state change  ******************************************/
end_comment

begin_function
name|void
name|xgell_callback_link_up
parameter_list|(
name|void
modifier|*
name|userdata
parameter_list|)
block|{
name|xgelldev_t
modifier|*
name|lldev
init|=
operator|(
name|xgelldev_t
operator|*
operator|)
name|userdata
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifnetp
init|=
name|lldev
operator|->
name|ifnetp
decl_stmt|;
name|ENTER_FUNCTION
name|ifnetp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifnetp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
name|LEAVE_FUNCTION
block|}
end_function

begin_comment
comment|/******************************************  * xgell_callback_link_down  * Parameters: Per adapter xgelldev_t  * structure pointer as void *  * Return: None  * Description: Called by HAL to notify  * hardware link up state change  ******************************************/
end_comment

begin_function
name|void
name|xgell_callback_link_down
parameter_list|(
name|void
modifier|*
name|userdata
parameter_list|)
block|{
name|xgelldev_t
modifier|*
name|lldev
init|=
operator|(
name|xgelldev_t
operator|*
operator|)
name|userdata
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifnetp
init|=
name|lldev
operator|->
name|ifnetp
decl_stmt|;
name|ENTER_FUNCTION
name|ifnetp
operator|->
name|if_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifnetp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
name|LEAVE_FUNCTION
block|}
end_function

begin_comment
comment|/******************************************  * xgell_callback_crit_err  * Parameters: Per adapter xgelldev_t  * structure pointer as void *, event,  * serr_data ->  * Return: None  * Description: Called by HAL on serious  * error event  ******************************************/
end_comment

begin_function
name|void
name|xgell_callback_crit_err
parameter_list|(
name|void
modifier|*
name|userdata
parameter_list|,
name|xge_hal_event_e
name|type
parameter_list|,
name|u64
name|serr_data
parameter_list|)
block|{
name|ENTER_FUNCTION
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Critical Error"
argument_list|)
decl_stmt|;
name|xgell_reset
argument_list|(
name|userdata
argument_list|)
expr_stmt|;
name|LEAVE_FUNCTION
block|}
end_function

begin_comment
comment|/******************************************  * xgell_callback_event  * Parameters: Queue item  * Return: None  * Description: Called by HAL in case of  * some unknown to HAL events.  ******************************************/
end_comment

begin_function
name|void
name|xgell_callback_event
parameter_list|(
name|xge_queue_item_t
modifier|*
name|item
parameter_list|)
block|{
name|xgelldev_t
modifier|*
name|lldev
init|=
name|NULL
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
init|=
name|NULL
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifnetp
init|=
name|NULL
decl_stmt|;
name|ENTER_FUNCTION
name|hldev
init|=
name|item
operator|->
name|context
decl_stmt|;
name|lldev
operator|=
name|xge_hal_device_private
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
name|ifnetp
operator|=
name|lldev
operator|->
name|ifnetp
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|event_type
operator|==
name|XGE_LL_EVENT_TRY_XMIT_AGAIN
condition|)
block|{
if|if
condition|(
name|lldev
operator|->
name|initialized
condition|)
block|{
if|if
condition|(
name|xge_hal_channel_dtr_count
argument_list|(
name|lldev
operator|->
name|fifo_channel_0
argument_list|)
operator|>
literal|0
condition|)
block|{
name|ifnetp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
block|}
else|else
block|{
comment|/* try next time */
name|xge_queue_produce_context
argument_list|(
name|xge_hal_device_queue
argument_list|(
name|lldev
operator|->
name|devh
argument_list|)
argument_list|,
name|XGE_LL_EVENT_TRY_XMIT_AGAIN
argument_list|,
name|lldev
operator|->
name|devh
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|item
operator|->
name|event_type
operator|==
name|XGE_LL_EVENT_DEVICE_RESETTING
condition|)
block|{
name|xgell_reset
argument_list|(
name|item
operator|->
name|context
argument_list|)
expr_stmt|;
block|}
name|LEAVE_FUNCTION
block|}
end_function

begin_comment
comment|/******************************************  * Function:    xge_ifmedia_change  * Parameters:  Pointer to ifnet structure  * Return:      0 for success, EINVAL if media  *              type is not IFM_ETHER.  * Description: Media change driver callback  ******************************************/
end_comment

begin_function
name|int
name|xge_ifmedia_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifnetp
parameter_list|)
block|{
name|xgelldev_t
modifier|*
name|lldev
init|=
name|ifnetp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifmedia
modifier|*
name|ifmediap
init|=
operator|&
name|lldev
operator|->
name|xge_media
decl_stmt|;
name|ENTER_FUNCTION
name|LEAVE_FUNCTION
return|return
operator|(
name|IFM_TYPE
argument_list|(
name|ifmediap
operator|->
name|ifm_media
argument_list|)
operator|!=
name|IFM_ETHER
operator|)
condition|?
name|EINVAL
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/******************************************  * Function:    xge_ifmedia_status  * Parameters:  Pointer to ifnet structure  *              ifmediareq structure pointer  *              through which status of media  *              will be returned.  * Return:      None  * Description: Media status driver callback  ******************************************/
end_comment

begin_function
name|void
name|xge_ifmedia_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifnetp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|xge_hal_status_e
name|status
decl_stmt|;
name|u64
name|regvalue
decl_stmt|;
name|xgelldev_t
modifier|*
name|lldev
init|=
name|ifnetp
operator|->
name|if_softc
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
init|=
name|lldev
operator|->
name|devh
decl_stmt|;
name|ENTER_FUNCTION
name|ifmr
operator|->
name|ifm_status
init|=
name|IFM_AVALID
decl_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
expr_stmt|;
name|status
operator|=
name|xge_hal_mgmt_reg_read
argument_list|(
name|hldev
argument_list|,
literal|0
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_bar0_t
argument_list|,
name|adapter_status
argument_list|)
argument_list|,
operator|&
name|regvalue
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Getting adapter status failed"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|regvalue
operator|&
operator|(
name|XGE_HAL_ADAPTER_STATUS_RMAC_REMOTE_FAULT
operator||
name|XGE_HAL_ADAPTER_STATUS_RMAC_LOCAL_FAULT
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_SR
operator||
name|IFM_FDX
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifnetp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|if_link_state_change
argument_list|(
name|ifnetp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
block|}
name|LEAVE_FUNCTION
block|}
end_function

begin_comment
comment|/******************************************  * Function:    xge_ioctl  * Parameters:  Pointer to ifnet structure,  *              command -> indicates requests,  *              data -> passed values (if any)  * Return:  * Description: IOCTL entry point. Called  *              when the user wants to  *              configure the interface  ******************************************/
end_comment

begin_function
name|int
name|xge_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifnetp
parameter_list|,
name|unsigned
name|long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|ifmedia
modifier|*
name|ifmediap
decl_stmt|;
name|xge_hal_stats_hw_info_t
modifier|*
name|hw_stats
decl_stmt|;
name|xge_hal_pci_config_t
modifier|*
name|pci_conf
decl_stmt|;
name|xge_hal_device_config_t
modifier|*
name|device_conf
decl_stmt|;
name|xge_hal_stats_sw_err_t
modifier|*
name|tcode
decl_stmt|;
name|xge_hal_stats_device_info_t
modifier|*
name|intr
decl_stmt|;
name|bar0reg_t
modifier|*
name|reg
decl_stmt|;
name|xge_hal_status_e
name|status_code
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
decl_stmt|;
name|void
modifier|*
name|regInfo
decl_stmt|;
name|u64
name|value
decl_stmt|;
name|u64
name|offset
decl_stmt|;
name|char
modifier|*
name|pAccess
decl_stmt|;
name|char
modifier|*
name|version
decl_stmt|;
name|int
name|retValue
init|=
literal|0
decl_stmt|,
name|index
init|=
literal|0
decl_stmt|,
name|buffer_mode
init|=
literal|0
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifreqp
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|xgelldev_t
modifier|*
name|lldev
init|=
name|ifnetp
operator|->
name|if_softc
decl_stmt|;
name|ifmediap
operator|=
operator|&
name|lldev
operator|->
name|xge_media
expr_stmt|;
name|hldev
operator|=
name|lldev
operator|->
name|devh
expr_stmt|;
if|if
condition|(
name|lldev
operator|->
name|in_detach
condition|)
block|{
return|return
name|retValue
return|;
block|}
switch|switch
condition|(
name|command
condition|)
block|{
comment|/* Set/Get ifnet address */
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
name|ether_ioctl
argument_list|(
name|ifnetp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
comment|/* Set ifnet MTU */
case|case
name|SIOCSIFMTU
case|:
name|retValue
operator|=
name|changeMtu
argument_list|(
name|lldev
argument_list|,
name|ifreqp
operator|->
name|ifr_mtu
argument_list|)
expr_stmt|;
break|break;
comment|/* Set ifnet flags */
case|case
name|SIOCSIFFLAGS
case|:
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifnetp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
comment|/* Link status is UP */
if|if
condition|(
operator|!
operator|(
name|ifnetp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|xge_init_locked
argument_list|(
name|lldev
argument_list|)
expr_stmt|;
block|}
name|xge_disable_promisc
argument_list|(
name|lldev
argument_list|)
expr_stmt|;
name|xge_enable_promisc
argument_list|(
name|lldev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Link status is DOWN */
comment|/* If device is in running, make it down */
if|if
condition|(
name|ifnetp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|xge_stop
argument_list|(
name|lldev
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
break|break;
comment|/* Add/delete multicast address */
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
if|if
condition|(
name|ifnetp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|xge_setmulti
argument_list|(
name|lldev
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Set/Get net media */
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|retValue
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifnetp
argument_list|,
name|ifreqp
argument_list|,
name|ifmediap
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
comment|/* Set capabilities */
case|case
name|SIOCSIFCAP
case|:
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
name|int
name|mask
init|=
literal|0
decl_stmt|;
name|mask
operator|=
name|ifreqp
operator|->
name|ifr_reqcap
operator|^
name|ifnetp
operator|->
name|if_capenable
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD_version
argument_list|)
operator|&&
operator|(
name|__FreeBSD_version
operator|>=
literal|700026
operator|)
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO4
condition|)
block|{
if|if
condition|(
name|ifnetp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO4
condition|)
block|{
name|ifnetp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_TSO4
expr_stmt|;
name|ifnetp
operator|->
name|if_hwassist
operator|&=
operator|~
name|CSUM_TSO
expr_stmt|;
block|}
comment|/*enable tso only if txcsum is enabled*/
if|if
condition|(
name|ifnetp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
name|ifnetp
operator|->
name|if_capenable
operator||=
name|IFCAP_TSO4
expr_stmt|;
name|ifnetp
operator|->
name|if_hwassist
operator||=
name|CSUM_TSO
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
break|break;
comment|/* Custom IOCTL 0 : 	     * Used to get Statistics& PCI configuration through application */
case|case
name|SIOCGPRIVATE_0
case|:
name|pAccess
operator|=
operator|(
name|char
operator|*
operator|)
name|ifreqp
operator|->
name|ifr_data
expr_stmt|;
if|if
condition|(
operator|*
name|pAccess
operator|==
name|XGE_QUERY_STATS
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
name|status_code
operator|=
name|xge_hal_stats_hw
argument_list|(
name|hldev
argument_list|,
operator|&
name|hw_stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|status_code
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Getting statistics failed (Status: %d)"
argument_list|,
name|status_code
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
name|retValue
operator|=
name|EINVAL
expr_stmt|;
block|}
name|copyout
argument_list|(
name|hw_stats
argument_list|,
name|ifreqp
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_stats_hw_info_t
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|pAccess
operator|==
name|XGE_QUERY_PCICONF
condition|)
block|{
name|pci_conf
operator|=
name|xge_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|xge_hal_pci_config_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_conf
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
name|status_code
operator|=
name|xge_hal_mgmt_pci_config
argument_list|(
name|hldev
argument_list|,
name|pci_conf
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_pci_config_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status_code
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Getting PCIconfiguration failed (Status: %d)"
argument_list|,
name|status_code
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
name|retValue
operator|=
name|EINVAL
expr_stmt|;
block|}
name|copyout
argument_list|(
name|pci_conf
argument_list|,
name|ifreqp
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_pci_config_t
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pci_conf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|pAccess
operator|==
name|XGE_QUERY_INTRSTATS
condition|)
block|{
name|intr
operator|=
name|xge_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|xge_hal_stats_device_info_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|intr
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
name|status_code
operator|=
name|xge_hal_mgmt_device_stats
argument_list|(
name|hldev
argument_list|,
name|intr
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_stats_device_info_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status_code
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Getting intr statistics failed (Status: %d)"
argument_list|,
name|status_code
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
name|retValue
operator|=
name|EINVAL
expr_stmt|;
block|}
name|copyout
argument_list|(
name|intr
argument_list|,
name|ifreqp
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_stats_device_info_t
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|intr
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|pAccess
operator|==
name|XGE_QUERY_TCODE
condition|)
block|{
name|tcode
operator|=
name|xge_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|xge_hal_stats_sw_err_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcode
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
name|status_code
operator|=
name|xge_hal_mgmt_sw_stats
argument_list|(
name|hldev
argument_list|,
name|tcode
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_stats_sw_err_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status_code
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Getting tcode statistics failed (Status: %d)"
argument_list|,
name|status_code
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
name|retValue
operator|=
name|EINVAL
expr_stmt|;
block|}
name|copyout
argument_list|(
name|tcode
argument_list|,
name|ifreqp
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_stats_sw_err_t
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tcode
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|pAccess
operator|==
name|XGE_READ_VERSION
condition|)
block|{
name|version
operator|=
name|xge_malloc
argument_list|(
name|BUFFER_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|version
argument_list|,
name|DRIVER_VERSION
argument_list|)
expr_stmt|;
name|copyout
argument_list|(
name|version
argument_list|,
name|ifreqp
operator|->
name|ifr_data
argument_list|,
name|BUFFER_SIZE
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|version
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|pAccess
operator|==
name|XGE_QUERY_DEVCONF
condition|)
block|{
name|device_conf
operator|=
name|xge_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|xge_hal_device_config_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_conf
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
name|status_code
operator|=
name|xge_hal_mgmt_device_config
argument_list|(
name|hldev
argument_list|,
name|device_conf
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_device_config_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status_code
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Getting devconfig failed (Status: %d)"
argument_list|,
name|status_code
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
name|retValue
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
name|copyout
argument_list|(
name|device_conf
argument_list|,
name|ifreqp
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_device_config_t
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Device configuration copyout erro"
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|device_conf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|pAccess
operator|==
name|XGE_QUERY_BUFFER_MODE
condition|)
block|{
name|buffer_mode
operator|=
name|lldev
operator|->
name|buffer_mode
expr_stmt|;
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|buffer_mode
argument_list|,
name|ifreqp
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Error with copyout of buffermode"
argument_list|)
expr_stmt|;
name|retValue
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|pAccess
operator|==
name|XGE_SET_BUFFER_MODE_1
operator|)
operator|||
operator|(
operator|*
name|pAccess
operator|==
name|XGE_SET_BUFFER_MODE_2
operator|)
operator|||
operator|(
operator|*
name|pAccess
operator|==
name|XGE_SET_BUFFER_MODE_3
operator|)
operator|||
operator|(
operator|*
name|pAccess
operator|==
name|XGE_SET_BUFFER_MODE_5
operator|)
condition|)
block|{
switch|switch
condition|(
operator|*
name|pAccess
condition|)
block|{
case|case
name|XGE_SET_BUFFER_MODE_1
case|:
operator|*
name|pAccess
operator|=
literal|'Y'
expr_stmt|;
break|break;
case|case
name|XGE_SET_BUFFER_MODE_2
case|:
case|case
name|XGE_SET_BUFFER_MODE_3
case|:
case|case
name|XGE_SET_BUFFER_MODE_5
case|:
operator|*
name|pAccess
operator|=
literal|'N'
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|copyout
argument_list|(
name|pAccess
argument_list|,
name|ifreqp
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|pAccess
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Copyout of chgbufmode result failed"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|xge_trace
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"Nothing is matching"
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	     * Custom IOCTL 1 : 	     * Used to get BAR0 register values through application program 	     */
case|case
name|SIOCGPRIVATE_1
case|:
name|reg
operator|=
operator|(
name|bar0reg_t
operator|*
operator|)
name|ifreqp
operator|->
name|ifr_data
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|reg
operator|->
name|option
argument_list|,
literal|"-r"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|offset
operator|=
name|reg
operator|->
name|offset
expr_stmt|;
name|value
operator|=
literal|0x0000
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
name|status_code
operator|=
name|xge_hal_mgmt_reg_read
argument_list|(
name|hldev
argument_list|,
literal|0
argument_list|,
name|offset
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|status_code
operator|==
name|XGE_HAL_OK
condition|)
block|{
name|reg
operator|->
name|value
operator|=
name|value
expr_stmt|;
block|}
else|else
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Getting register value failed"
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
name|retValue
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|copyout
argument_list|(
name|reg
argument_list|,
name|ifreqp
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|bar0reg_t
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|reg
operator|->
name|option
argument_list|,
literal|"-w"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|offset
operator|=
name|reg
operator|->
name|offset
expr_stmt|;
name|value
operator|=
name|reg
operator|->
name|value
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
name|status_code
operator|=
name|xge_hal_mgmt_reg_write
argument_list|(
name|hldev
argument_list|,
literal|0
argument_list|,
name|offset
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|status_code
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Getting register value failed"
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
name|retValue
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|value
operator|=
literal|0x0000
expr_stmt|;
name|status_code
operator|=
name|xge_hal_mgmt_reg_read
argument_list|(
name|hldev
argument_list|,
literal|0
argument_list|,
name|offset
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|status_code
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Getting register value failed"
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
name|retValue
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|reg
operator|->
name|value
operator|!=
name|value
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
name|retValue
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|=
literal|0x0000
expr_stmt|;
name|value
operator|=
literal|0x0000
expr_stmt|;
name|regInfo
operator|=
operator|(
name|void
operator|*
operator|)
name|ifreqp
operator|->
name|ifr_data
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
operator|,
name|offset
operator|=
literal|0
init|;
name|offset
operator|<=
name|XGE_OFFSET_OF_LAST_REG
condition|;
name|index
operator|++
operator|,
name|offset
operator|+=
literal|0x0008
control|)
block|{
name|status_code
operator|=
name|xge_hal_mgmt_reg_read
argument_list|(
name|hldev
argument_list|,
literal|0
argument_list|,
name|offset
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|status_code
operator|==
name|XGE_HAL_OK
condition|)
block|{
operator|*
operator|(
operator|(
name|u64
operator|*
operator|)
operator|(
operator|(
name|u64
operator|*
operator|)
name|regInfo
operator|+
name|index
operator|)
operator|)
operator|=
name|value
expr_stmt|;
block|}
else|else
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Getting register value failed"
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
name|retValue
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
name|copyout
argument_list|(
name|regInfo
argument_list|,
name|ifreqp
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_pci_bar0_t
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|retValue
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|retValue
return|;
block|}
end_function

begin_comment
comment|/******************************************  * Function:    xge_init  * Parameters:  Pointer to per-device  *              xgelldev_t structure as void*.  * Return:      None  * Description: Init entry point.  ******************************************/
end_comment

begin_function
name|void
name|xge_init
parameter_list|(
name|void
modifier|*
name|plldev
parameter_list|)
block|{
name|ENTER_FUNCTION
name|xgelldev_t
modifier|*
name|lldev
init|=
operator|(
name|xgelldev_t
operator|*
operator|)
name|plldev
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
name|xge_init_locked
argument_list|(
name|lldev
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
name|LEAVE_FUNCTION
block|}
end_function

begin_function
name|void
name|xge_init_locked
parameter_list|(
name|void
modifier|*
name|pdevin
parameter_list|)
block|{
name|ENTER_FUNCTION
name|xgelldev_t
modifier|*
name|lldev
init|=
operator|(
name|xgelldev_t
operator|*
operator|)
name|pdevin
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifnetp
init|=
name|lldev
operator|->
name|ifnetp
decl_stmt|;
name|device_t
name|dev
init|=
name|lldev
operator|->
name|device
decl_stmt|;
name|mtx_assert
argument_list|(
operator|(
operator|&
name|lldev
operator|->
name|xge_lock
operator|)
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* If device is in running state, initializing is not required */
if|if
condition|(
name|ifnetp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
return|return;
block|}
comment|/* Initializing timer */
name|callout_init
argument_list|(
operator|&
name|lldev
operator|->
name|timer
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|xge_initialize
argument_list|(
name|dev
argument_list|,
name|XGE_HAL_CHANNEL_OC_NORMAL
argument_list|)
expr_stmt|;
name|LEAVE_FUNCTION
block|}
end_function

begin_comment
comment|/******************************************  * Function:    xge_timer  * Parameters:  Pointer to per-device  *              xgelldev_t structure as void*.  * Return:      None  * Description: Polls the changes.  ******************************************/
end_comment

begin_function
name|void
name|xge_timer
parameter_list|(
name|void
modifier|*
name|devp
parameter_list|)
block|{
name|xgelldev_t
modifier|*
name|lldev
init|=
operator|(
name|xgelldev_t
operator|*
operator|)
name|devp
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
init|=
name|lldev
operator|->
name|devh
decl_stmt|;
comment|/* Poll for changes */
name|xge_hal_device_poll
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
comment|/* Reset timer */
name|callout_reset
argument_list|(
operator|&
name|lldev
operator|->
name|timer
argument_list|,
name|hz
argument_list|,
name|xge_timer
argument_list|,
name|lldev
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/******************************************  * Function:    xge_stop  * Parameters:  Per adapter xgelldev_t  *              structure pointer  * Return:      None  * Description: Deactivates the interface  *              (Called on "ifconfig down"  ******************************************/
end_comment

begin_function
name|void
name|xge_stop
parameter_list|(
name|xgelldev_t
modifier|*
name|lldev
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifnetp
init|=
name|lldev
operator|->
name|ifnetp
decl_stmt|;
name|device_t
name|dev
init|=
name|lldev
operator|->
name|device
decl_stmt|;
name|ENTER_FUNCTION
name|mtx_assert
argument_list|(
operator|(
operator|&
name|lldev
operator|->
name|xge_lock
operator|)
argument_list|,
name|MA_OWNED
argument_list|)
decl_stmt|;
comment|/* If device is not in "Running" state, return */
if|if
condition|(
operator|!
operator|(
name|ifnetp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
goto|goto
name|xfstop_out
goto|;
block|}
name|xge_terminate
argument_list|(
name|dev
argument_list|,
name|XGE_HAL_CHANNEL_OC_NORMAL
argument_list|)
expr_stmt|;
name|xfstop_out
label|:
name|LEAVE_FUNCTION
return|return;
block|}
end_function

begin_comment
comment|/*  * xge_intr_filter  *   * ISR filter function  * @handle softc/lldev per device structure  */
end_comment

begin_function
name|int
name|xge_intr_filter
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|)
block|{
name|xgelldev_t
modifier|*
name|lldev
init|=
name|NULL
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
init|=
name|NULL
decl_stmt|;
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
name|NULL
decl_stmt|;
name|device_t
name|dev
init|=
name|NULL
decl_stmt|;
name|u16
name|retValue
init|=
name|FILTER_STRAY
decl_stmt|;
name|u64
name|val64
init|=
literal|0
decl_stmt|;
name|lldev
operator|=
operator|(
name|xgelldev_t
operator|*
operator|)
name|handle
expr_stmt|;
name|hldev
operator|=
name|lldev
operator|->
name|devh
expr_stmt|;
name|dev
operator|=
name|lldev
operator|->
name|device
expr_stmt|;
name|bar0
operator|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
name|hldev
operator|->
name|bar0
expr_stmt|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|lldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|general_int_status
argument_list|)
expr_stmt|;
name|retValue
operator|=
operator|(
operator|!
name|val64
operator|)
condition|?
name|FILTER_STRAY
else|:
name|FILTER_SCHEDULE_THREAD
expr_stmt|;
return|return
name|retValue
return|;
block|}
end_function

begin_comment
comment|/******************************************  * xge_intr  * Parameters: Per adapter xgelldev_t  * structure pointer  * Return: None  * Description: Interrupt service routine  ******************************************/
end_comment

begin_function
name|void
name|xge_intr
parameter_list|(
name|void
modifier|*
name|plldev
parameter_list|)
block|{
name|xge_hal_status_e
name|status
decl_stmt|;
name|xgelldev_t
modifier|*
name|lldev
init|=
operator|(
name|xgelldev_t
operator|*
operator|)
name|plldev
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|lldev
operator|->
name|devh
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifnetp
init|=
name|lldev
operator|->
name|ifnetp
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifnetp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|status
operator|=
name|xge_hal_device_handle_irq
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifnetp
operator|->
name|if_snd
argument_list|)
operator|)
condition|)
block|{
name|xge_send_locked
argument_list|(
name|ifnetp
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/********************************************  * Function  :    xgell_rx_open  * Parameters:  Queue index, channel  *              open/close/reopen flag  * Return:      0 or ENODEV  * Description: Initialize and open all Rx  *              channels.  ******************************************/
end_comment

begin_function
name|int
name|xgell_rx_open
parameter_list|(
name|int
name|qid
parameter_list|,
name|xgelldev_t
modifier|*
name|lldev
parameter_list|,
name|xge_hal_channel_reopen_e
name|rflag
parameter_list|)
block|{
name|u64
name|adapter_status
init|=
literal|0x0
decl_stmt|;
name|int
name|retValue
init|=
literal|0
decl_stmt|;
name|xge_hal_status_e
name|status_code
decl_stmt|;
name|ENTER_FUNCTION
name|xge_hal_channel_attr_t
name|attr
init|=
block|{
operator|.
name|post_qid
operator|=
name|qid
block|,
operator|.
name|compl_qid
operator|=
literal|0
block|,
operator|.
name|callback
operator|=
name|xgell_rx_compl
block|,
operator|.
name|per_dtr_space
operator|=
sizeof|sizeof
argument_list|(
name|xgell_rx_priv_t
argument_list|)
block|,
operator|.
name|flags
operator|=
literal|0
block|,
operator|.
name|type
operator|=
name|XGE_HAL_CHANNEL_TYPE_RING
block|,
operator|.
name|userdata
operator|=
name|lldev
block|,
operator|.
name|dtr_init
operator|=
name|xgell_rx_initial_replenish
block|,
operator|.
name|dtr_term
operator|=
name|xgell_rx_term
block|}
decl_stmt|;
comment|/* If device is not ready, return */
if|if
condition|(
name|xge_hal_device_status
argument_list|(
name|lldev
operator|->
name|devh
argument_list|,
operator|&
name|adapter_status
argument_list|)
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Device is not ready. Adapter status: 0x%llx"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|adapter_status
argument_list|)
expr_stmt|;
name|retValue
operator|=
operator|-
name|ENODEV
expr_stmt|;
goto|goto
name|rxopen_out
goto|;
block|}
comment|/* Open ring channel */
name|status_code
operator|=
name|xge_hal_channel_open
argument_list|(
name|lldev
operator|->
name|devh
argument_list|,
operator|&
name|attr
argument_list|,
operator|&
name|lldev
operator|->
name|ring_channel
index|[
name|qid
index|]
argument_list|,
name|rflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|status_code
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Can not open Rx RING channel, Status: %d\n"
argument_list|,
name|status_code
argument_list|)
expr_stmt|;
name|retValue
operator|=
operator|-
name|ENODEV
expr_stmt|;
goto|goto
name|rxopen_out
goto|;
block|}
name|rxopen_out
label|:
name|LEAVE_FUNCTION
return|return
name|retValue
return|;
block|}
end_function

begin_comment
comment|/******************************************  * Function:    xgell_tx_open  * Parameters:  Channel  *              open/close/reopen flag  * Return:      0 or ENODEV  * Description: Initialize and open all Tx  *              channels.  ******************************************/
end_comment

begin_function
name|int
name|xgell_tx_open
parameter_list|(
name|xgelldev_t
modifier|*
name|lldev
parameter_list|,
name|xge_hal_channel_reopen_e
name|tflag
parameter_list|)
block|{
name|xge_hal_status_e
name|status_code
decl_stmt|;
name|u64
name|adapter_status
init|=
literal|0x0
decl_stmt|;
name|int
name|retValue
init|=
literal|0
decl_stmt|;
name|ENTER_FUNCTION
name|xge_hal_channel_attr_t
name|attr
init|=
block|{
operator|.
name|post_qid
operator|=
literal|0
block|,
operator|.
name|compl_qid
operator|=
literal|0
block|,
operator|.
name|callback
operator|=
name|xgell_tx_compl
block|,
operator|.
name|per_dtr_space
operator|=
sizeof|sizeof
argument_list|(
name|xgell_tx_priv_t
argument_list|)
block|,
operator|.
name|flags
operator|=
literal|0
block|,
operator|.
name|type
operator|=
name|XGE_HAL_CHANNEL_TYPE_FIFO
block|,
operator|.
name|userdata
operator|=
name|lldev
block|,
operator|.
name|dtr_init
operator|=
name|xgell_tx_initial_replenish
block|,
operator|.
name|dtr_term
operator|=
name|xgell_tx_term
block|}
decl_stmt|;
comment|/* If device is not ready, return */
if|if
condition|(
name|xge_hal_device_status
argument_list|(
name|lldev
operator|->
name|devh
argument_list|,
operator|&
name|adapter_status
argument_list|)
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Device is not ready. Adapter status: 0x%llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|adapter_status
argument_list|)
expr_stmt|;
name|retValue
operator|=
operator|-
name|ENODEV
expr_stmt|;
goto|goto
name|txopen_out
goto|;
block|}
comment|/* Open FIFO channel */
name|status_code
operator|=
name|xge_hal_channel_open
argument_list|(
name|lldev
operator|->
name|devh
argument_list|,
operator|&
name|attr
argument_list|,
operator|&
name|lldev
operator|->
name|fifo_channel_0
argument_list|,
name|tflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|status_code
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Can not open Tx FIFO channel, Status: %d\n"
argument_list|,
name|status_code
argument_list|)
expr_stmt|;
name|retValue
operator|=
operator|-
name|ENODEV
expr_stmt|;
goto|goto
name|txopen_out
goto|;
block|}
name|txopen_out
label|:
name|LEAVE_FUNCTION
return|return
name|retValue
return|;
block|}
end_function

begin_comment
comment|/******************************************  * Function:    xgell_channel_open  * Parameters:  Per adapter xgelldev_t  *              structure pointer  * Return:      None  * Description: Opens both Rx and Tx channels.  ******************************************/
end_comment

begin_function
name|int
name|xgell_channel_open
parameter_list|(
name|xgelldev_t
modifier|*
name|lldev
parameter_list|,
name|xge_hal_channel_reopen_e
name|option
parameter_list|)
block|{
name|int
name|status
init|=
name|XGE_HAL_OK
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
name|int
name|index2
init|=
literal|0
decl_stmt|;
name|ENTER_FUNCTION
comment|/* Open ring (Rx) channel */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|XGE_RING_COUNT
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|xgell_rx_open
argument_list|(
name|index
argument_list|,
name|lldev
argument_list|,
name|option
argument_list|)
operator|)
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Opening Rx channel failed (Status: %d)\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
for|for
control|(
name|index2
operator|=
literal|0
init|;
name|index2
operator|<
name|index
condition|;
name|index2
operator|++
control|)
block|{
name|xge_hal_channel_close
argument_list|(
name|lldev
operator|->
name|ring_channel
index|[
name|index2
index|]
argument_list|,
name|option
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|XGE_FEATURE_LRO
name|status
operator|=
name|xge_hal_lro_init
argument_list|(
literal|1
argument_list|,
name|lldev
operator|->
name|devh
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"cannot init Rx LRO got status code %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENODEV
return|;
block|}
endif|#
directive|endif
comment|/* Open FIFO (Tx) channel */
if|if
condition|(
operator|(
name|status
operator|=
name|xgell_tx_open
argument_list|(
name|lldev
argument_list|,
name|option
argument_list|)
operator|)
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Opening Tx channel failed (Status: %d)\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|XGE_RING_COUNT
condition|;
name|index
operator|++
control|)
block|{
name|xge_hal_channel_close
argument_list|(
name|lldev
operator|->
name|ring_channel
index|[
name|index
index|]
argument_list|,
name|option
argument_list|)
expr_stmt|;
block|}
block|}
name|LEAVE_FUNCTION
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/******************************************  * Function:    xgell_channel_close  * Parameters:  Per adapter xgelldev_t  *              structure pointer  * Return:      0 for success, non-zero for  *              failure  * Description: Closes both Tx and Rx channels  ******************************************/
end_comment

begin_function
name|int
name|xgell_channel_close
parameter_list|(
name|xgelldev_t
modifier|*
name|lldev
parameter_list|,
name|xge_hal_channel_reopen_e
name|option
parameter_list|)
block|{
name|int
name|index
decl_stmt|;
name|ENTER_FUNCTION
name|DELAY
argument_list|(
literal|1000
operator|*
literal|1000
argument_list|)
decl_stmt|;
comment|/* Close FIFO (Tx) channel */
name|xge_hal_channel_close
argument_list|(
name|lldev
operator|->
name|fifo_channel_0
argument_list|,
name|option
argument_list|)
expr_stmt|;
comment|/* Close Ring (Rx) channel */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|XGE_RING_COUNT
condition|;
name|index
operator|++
control|)
block|{
name|xge_hal_channel_close
argument_list|(
name|lldev
operator|->
name|ring_channel
index|[
name|index
index|]
argument_list|,
name|option
argument_list|)
expr_stmt|;
block|}
name|LEAVE_FUNCTION
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/******************************************  * Function:    dmamap_cb  * Parameters:  Parameter passed from dmamap  *              function, Segment, Number of  *              segments, error (if any)  * Return:      None  * Description: Callback function used for  *              DMA mapping  ******************************************/
end_comment

begin_function
name|void
name|dmamap_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
if|if
condition|(
operator|!
name|error
condition|)
block|{
operator|*
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/******************************************  * Function:    xgell_reset  * Parameters:  Per adapter xgelldev_t  *              structure pointer  * Return:      HAL status code/EPERM  * Description: Resets the device  ******************************************/
end_comment

begin_function
name|void
name|xgell_reset
parameter_list|(
name|xgelldev_t
modifier|*
name|lldev
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|lldev
operator|->
name|device
decl_stmt|;
name|ENTER_FUNCTION
name|xge_trace
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"Reseting the chip"
argument_list|)
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
comment|/* If the device is not initialized, return */
if|if
condition|(
operator|!
name|lldev
operator|->
name|initialized
condition|)
block|{
goto|goto
name|xreset_out
goto|;
block|}
name|xge_terminate
argument_list|(
name|dev
argument_list|,
name|XGE_HAL_CHANNEL_OC_NORMAL
argument_list|)
expr_stmt|;
name|xge_initialize
argument_list|(
name|dev
argument_list|,
name|XGE_HAL_CHANNEL_OC_NORMAL
argument_list|)
expr_stmt|;
name|xreset_out
label|:
name|LEAVE_FUNCTION
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
decl_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/******************************************  * Function:    xge_setmulti  * Parameters:  Per adapter xgelldev_t  *              structure pointer  * Return:      None  * Description: Set an address as a multicast  *              address  ******************************************/
end_comment

begin_function
name|void
name|xge_setmulti
parameter_list|(
name|xgelldev_t
modifier|*
name|lldev
parameter_list|)
block|{
name|ENTER_FUNCTION
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|u8
modifier|*
name|lladdr
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|lldev
operator|->
name|devh
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifnetp
init|=
name|lldev
operator|->
name|ifnetp
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
name|int
name|offset
init|=
literal|1
decl_stmt|;
name|int
name|table_size
init|=
literal|47
decl_stmt|;
name|xge_hal_status_e
name|status
init|=
name|XGE_HAL_OK
decl_stmt|;
name|u8
name|initial_addr
index|[]
init|=
block|{
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|}
decl_stmt|;
if|if
condition|(
operator|(
name|ifnetp
operator|->
name|if_flags
operator|&
name|IFF_MULTICAST
operator|)
operator|&&
operator|(
operator|!
name|lldev
operator|->
name|all_multicast
operator|)
condition|)
block|{
name|status
operator|=
name|xge_hal_device_mcast_enable
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
name|lldev
operator|->
name|all_multicast
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifnetp
operator|->
name|if_flags
operator|&
name|IFF_MULTICAST
operator|)
operator|&&
operator|(
name|lldev
operator|->
name|all_multicast
operator|)
condition|)
block|{
name|status
operator|=
name|xge_hal_device_mcast_disable
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
name|lldev
operator|->
name|all_multicast
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|printf
argument_list|(
literal|"Failed to %s multicast (status: %d)\n"
argument_list|,
operator|(
name|ifnetp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|?
literal|"enable"
else|:
literal|"disable"
operator|)
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
comment|/* Updating address list */
name|IF_ADDR_LOCK
argument_list|(
name|ifnetp
argument_list|)
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifnetp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
block|{
continue|continue;
block|}
name|lladdr
operator|=
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
expr_stmt|;
name|index
operator|+=
literal|1
expr_stmt|;
block|}
name|IF_ADDR_UNLOCK
argument_list|(
name|ifnetp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|lldev
operator|->
name|all_multicast
operator|)
operator|&&
operator|(
name|index
operator|)
condition|)
block|{
name|lldev
operator|->
name|macaddr_count
operator|=
operator|(
name|index
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|lldev
operator|->
name|macaddr_count
operator|>
name|table_size
condition|)
block|{
return|return;
block|}
comment|/* Clear old addresses */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
literal|48
condition|;
name|index
operator|++
control|)
block|{
name|xge_hal_device_macaddr_set
argument_list|(
name|hldev
argument_list|,
operator|(
name|offset
operator|+
name|index
operator|)
argument_list|,
name|initial_addr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Add new addresses */
name|IF_ADDR_LOCK
argument_list|(
name|ifnetp
argument_list|)
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifnetp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
block|{
continue|continue;
block|}
name|lladdr
operator|=
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
expr_stmt|;
name|xge_hal_device_macaddr_set
argument_list|(
name|hldev
argument_list|,
operator|(
name|offset
operator|+
name|index
operator|)
argument_list|,
name|lladdr
argument_list|)
expr_stmt|;
name|index
operator|+=
literal|1
expr_stmt|;
block|}
name|IF_ADDR_UNLOCK
argument_list|(
name|ifnetp
argument_list|)
expr_stmt|;
name|LEAVE_FUNCTION
block|}
end_function

begin_comment
comment|/******************************************  * Function:    xge_enable_promisc  * Parameters:  Adapter structure  * Return:      None  * Description: Enables promiscuous mode  ******************************************/
end_comment

begin_function
name|void
name|xge_enable_promisc
parameter_list|(
name|xgelldev_t
modifier|*
name|lldev
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifnetp
init|=
name|lldev
operator|->
name|ifnetp
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
init|=
name|lldev
operator|->
name|devh
decl_stmt|;
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
name|NULL
decl_stmt|;
name|u64
name|val64
init|=
literal|0
decl_stmt|;
name|ENTER_FUNCTION
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
if|if
condition|(
name|ifnetp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|xge_hal_device_promisc_enable
argument_list|(
name|lldev
operator|->
name|devh
argument_list|)
expr_stmt|;
comment|/* 	     * When operating in promiscuous mode, don't strip the VLAN tag 	     */
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|lldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|rx_pa_cfg
argument_list|)
expr_stmt|;
name|val64
operator|&=
operator|~
name|XGE_HAL_RX_PA_CFG_STRIP_VLAN_TAG_MODE
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_RX_PA_CFG_STRIP_VLAN_TAG_MODE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|lldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_pa_cfg
argument_list|)
expr_stmt|;
name|xge_trace
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"Promiscuous mode ON"
argument_list|)
expr_stmt|;
block|}
name|LEAVE_FUNCTION
block|}
end_function

begin_comment
comment|/******************************************  * Function:    xge_disable_promisc  * Parameters:  Adapter structure  * Return:      None  * Description: Disables promiscuous mode  ******************************************/
end_comment

begin_function
name|void
name|xge_disable_promisc
parameter_list|(
name|xgelldev_t
modifier|*
name|lldev
parameter_list|)
block|{
name|xge_hal_device_t
modifier|*
name|hldev
init|=
name|lldev
operator|->
name|devh
decl_stmt|;
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
name|NULL
decl_stmt|;
name|u64
name|val64
init|=
literal|0
decl_stmt|;
name|ENTER_FUNCTION
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
name|hldev
operator|->
name|bar0
decl_stmt|;
name|xge_hal_device_promisc_disable
argument_list|(
name|lldev
operator|->
name|devh
argument_list|)
expr_stmt|;
comment|/* 	 * Strip VLAN tag when operating in non-promiscuous mode 	 */
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|lldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|rx_pa_cfg
argument_list|)
expr_stmt|;
name|val64
operator|&=
operator|~
name|XGE_HAL_RX_PA_CFG_STRIP_VLAN_TAG_MODE
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_RX_PA_CFG_STRIP_VLAN_TAG_MODE
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|lldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_pa_cfg
argument_list|)
expr_stmt|;
name|xge_trace
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"Promiscuous mode OFF"
argument_list|)
expr_stmt|;
name|LEAVE_FUNCTION
block|}
end_function

begin_comment
comment|/******************************************  * Function:    changeMtu  * Parameters:  Pointer to per-device  *              xgelldev_t structure, New  *              MTU size.  * Return:      None  * Description: Changes MTU size to requested  ******************************************/
end_comment

begin_function
name|int
name|changeMtu
parameter_list|(
name|xgelldev_t
modifier|*
name|lldev
parameter_list|,
name|int
name|NewMtu
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifnetp
init|=
name|lldev
operator|->
name|ifnetp
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
init|=
name|lldev
operator|->
name|devh
decl_stmt|;
name|int
name|retValue
init|=
literal|0
decl_stmt|;
name|ENTER_FUNCTION
do|do
block|{
comment|/* Check requested MTU size for boundary */
if|if
condition|(
name|xge_hal_device_mtu_check
argument_list|(
name|hldev
argument_list|,
name|NewMtu
argument_list|)
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Invalid MTU"
argument_list|)
expr_stmt|;
name|retValue
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|lldev
operator|->
name|initialized
operator|!=
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
name|if_down
argument_list|(
name|ifnetp
argument_list|)
expr_stmt|;
name|xge_stop
argument_list|(
name|lldev
argument_list|)
expr_stmt|;
name|ifnetp
operator|->
name|if_mtu
operator|=
name|NewMtu
expr_stmt|;
name|changeBufmode
argument_list|(
name|lldev
argument_list|,
name|NewMtu
argument_list|)
expr_stmt|;
name|xge_init_locked
argument_list|(
operator|(
name|void
operator|*
operator|)
name|lldev
argument_list|)
expr_stmt|;
name|if_up
argument_list|(
name|ifnetp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ifnetp
operator|->
name|if_mtu
operator|=
name|NewMtu
expr_stmt|;
name|changeBufmode
argument_list|(
name|lldev
argument_list|,
name|NewMtu
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|FALSE
condition|)
do|;
name|LEAVE_FUNCTION
return|return
name|retValue
return|;
block|}
end_function

begin_comment
comment|/******************************************  * Function:    changeBufmode  * Parameters:  Pointer to per-device  *              xgelldev_t structure, New  *              MTU size.  * Return:      None  * Description: Updates RingConfiguration structure  *              depending the NewMtu size.  ******************************************/
end_comment

begin_function
name|int
name|changeBufmode
parameter_list|(
name|xgelldev_t
modifier|*
name|lldev
parameter_list|,
name|int
name|NewMtu
parameter_list|)
block|{
name|xge_hal_ring_config_t
modifier|*
name|pRingConfig
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
init|=
name|lldev
operator|->
name|devh
decl_stmt|;
name|device_t
name|dev
init|=
name|lldev
operator|->
name|device
decl_stmt|;
name|int
name|buffer_length
init|=
literal|0
decl_stmt|,
name|buffer_index
init|=
literal|0
decl_stmt|,
name|index
decl_stmt|;
name|pRingConfig
operator|=
operator|&
operator|(
name|hldev
operator|->
name|config
operator|.
name|ring
operator|)
expr_stmt|;
name|xge_os_memzero
argument_list|(
name|lldev
operator|->
name|rxd_mbuf_len
argument_list|,
sizeof|sizeof
argument_list|(
name|lldev
operator|->
name|rxd_mbuf_len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|NewMtu
operator|+
name|XGE_HAL_MAC_HEADER_MAX_SIZE
operator|)
operator|<=
name|MJUMPAGESIZE
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|XGE_FEATURE_BUFFER_MODE_3
argument_list|)
name|xge_os_printf
argument_list|(
literal|"%s: 3 Buffer Mode Enabled"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|XGE_RING_COUNT
condition|;
name|index
operator|++
control|)
block|{
name|pRingConfig
operator|->
name|queue
index|[
name|index
index|]
operator|.
name|buffer_mode
operator|=
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_3
expr_stmt|;
block|}
name|pRingConfig
operator|->
name|scatter_mode
operator|=
name|XGE_HAL_RING_QUEUE_SCATTER_MODE_A
expr_stmt|;
name|lldev
operator|->
name|buffer_mode
operator|=
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_3
expr_stmt|;
name|lldev
operator|->
name|rxd_mbuf_len
index|[
literal|0
index|]
operator|=
name|XGE_HAL_MAC_HEADER_MAX_SIZE
expr_stmt|;
name|lldev
operator|->
name|rxd_mbuf_len
index|[
literal|1
index|]
operator|=
name|XGE_HAL_TCPIP_HEADER_MAX_SIZE
expr_stmt|;
name|lldev
operator|->
name|rxd_mbuf_len
index|[
literal|2
index|]
operator|=
name|NewMtu
expr_stmt|;
name|lldev
operator|->
name|rxd_mbuf_cnt
operator|=
literal|3
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|XGE_FEATURE_BUFFER_MODE_2
argument_list|)
name|xge_os_printf
argument_list|(
literal|"%s: 2 Buffer Mode Enabled"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|XGE_RING_COUNT
condition|;
name|index
operator|++
control|)
block|{
name|pRingConfig
operator|->
name|queue
index|[
name|index
index|]
operator|.
name|buffer_mode
operator|=
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_3
expr_stmt|;
block|}
name|pRingConfig
operator|->
name|scatter_mode
operator|=
name|XGE_HAL_RING_QUEUE_SCATTER_MODE_B
expr_stmt|;
name|lldev
operator|->
name|buffer_mode
operator|=
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_2
expr_stmt|;
name|lldev
operator|->
name|rxd_mbuf_len
index|[
literal|0
index|]
operator|=
name|XGE_HAL_MAC_HEADER_MAX_SIZE
expr_stmt|;
name|lldev
operator|->
name|rxd_mbuf_len
index|[
literal|1
index|]
operator|=
name|NewMtu
expr_stmt|;
name|lldev
operator|->
name|rxd_mbuf_cnt
operator|=
literal|2
expr_stmt|;
else|#
directive|else
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|XGE_RING_COUNT
condition|;
name|index
operator|++
control|)
block|{
name|pRingConfig
operator|->
name|queue
index|[
name|index
index|]
operator|.
name|buffer_mode
operator|=
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_1
expr_stmt|;
block|}
name|pRingConfig
operator|->
name|scatter_mode
operator|=
name|XGE_HAL_RING_QUEUE_SCATTER_MODE_A
expr_stmt|;
name|lldev
operator|->
name|buffer_mode
operator|=
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_1
expr_stmt|;
name|lldev
operator|->
name|rxd_mbuf_len
index|[
literal|0
index|]
operator|=
name|NewMtu
expr_stmt|;
name|lldev
operator|->
name|rxd_mbuf_cnt
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|XGE_FEATURE_BUFFER_MODE_3
argument_list|)
operator|||
name|defined
argument_list|(
name|XGE_FEATURE_BUFFER_MODE_2
argument_list|)
name|xge_os_printf
argument_list|(
literal|"2 or 3 Buffer mode is not supported for given MTU"
argument_list|)
expr_stmt|;
name|xge_os_printf
argument_list|(
literal|"So changing buffer mode to 5 buffer mode\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|xge_os_printf
argument_list|(
literal|"%s: 5 Buffer Mode Enabled"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|XGE_RING_COUNT
condition|;
name|index
operator|++
control|)
block|{
name|pRingConfig
operator|->
name|queue
index|[
name|index
index|]
operator|.
name|buffer_mode
operator|=
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_5
expr_stmt|;
block|}
name|lldev
operator|->
name|buffer_mode
operator|=
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_5
expr_stmt|;
name|buffer_length
operator|=
name|NewMtu
expr_stmt|;
name|buffer_index
operator|=
literal|2
expr_stmt|;
name|lldev
operator|->
name|rxd_mbuf_len
index|[
literal|0
index|]
operator|=
name|XGE_HAL_MAC_HEADER_MAX_SIZE
expr_stmt|;
name|lldev
operator|->
name|rxd_mbuf_len
index|[
literal|1
index|]
operator|=
name|XGE_HAL_TCPIP_HEADER_MAX_SIZE
expr_stmt|;
while|while
condition|(
name|buffer_length
operator|>
name|MJUMPAGESIZE
condition|)
block|{
name|buffer_length
operator|-=
name|MJUMPAGESIZE
expr_stmt|;
name|lldev
operator|->
name|rxd_mbuf_len
index|[
name|buffer_index
index|]
operator|=
name|MJUMPAGESIZE
expr_stmt|;
name|buffer_index
operator|++
expr_stmt|;
block|}
name|BUFALIGN
argument_list|(
name|buffer_length
argument_list|)
expr_stmt|;
name|lldev
operator|->
name|rxd_mbuf_len
index|[
name|buffer_index
index|]
operator|=
name|buffer_length
expr_stmt|;
name|lldev
operator|->
name|rxd_mbuf_cnt
operator|=
name|buffer_index
operator|+
literal|1
expr_stmt|;
block|}
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/*************************************************************  * xge_initialize  *  * @dev: Device structure  * @option: Normal/Reset option for channels  *  * Called by both init and reset functions to enable device, interrupts, and to  * open channels.  *  **************************************************************/
end_comment

begin_function
name|void
name|xge_initialize
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|xge_hal_channel_reopen_e
name|option
parameter_list|)
block|{
name|ENTER_FUNCTION
name|struct
name|ifaddr
modifier|*
name|ifaddrp
decl_stmt|;
name|struct
name|sockaddr_dl
modifier|*
name|sockaddrp
decl_stmt|;
name|unsigned
name|char
modifier|*
name|macaddr
decl_stmt|;
name|xgelldev_t
modifier|*
name|lldev
init|=
operator|(
name|xgelldev_t
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
init|=
name|lldev
operator|->
name|devh
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifnetp
init|=
name|lldev
operator|->
name|ifnetp
decl_stmt|;
name|int
name|status
init|=
name|XGE_HAL_OK
decl_stmt|;
name|xge_trace
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"Set MTU size"
argument_list|)
expr_stmt|;
name|status
operator|=
name|xge_hal_device_mtu_set
argument_list|(
name|hldev
argument_list|,
name|ifnetp
operator|->
name|if_mtu
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Setting HAL device MTU failed (Status: %d)"
argument_list|,
name|status
argument_list|)
expr_stmt|;
goto|goto
name|init_sub_out
goto|;
block|}
comment|/* Enable HAL device */
name|xge_hal_device_enable
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
comment|/* Get MAC address and update in HAL */
name|ifaddrp
operator|=
name|ifaddr_byindex
argument_list|(
name|ifnetp
operator|->
name|if_index
argument_list|)
expr_stmt|;
name|sockaddrp
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifaddrp
operator|->
name|ifa_addr
expr_stmt|;
name|sockaddrp
operator|->
name|sdl_type
operator|=
name|IFT_ETHER
expr_stmt|;
name|sockaddrp
operator|->
name|sdl_alen
operator|=
name|ifnetp
operator|->
name|if_addrlen
expr_stmt|;
name|macaddr
operator|=
name|LLADDR
argument_list|(
name|sockaddrp
argument_list|)
expr_stmt|;
name|xge_trace
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"Setting MAC address: %02x:%02x:%02x:%02x:%02x:%02x\n"
argument_list|,
operator|*
name|macaddr
argument_list|,
operator|*
operator|(
name|macaddr
operator|+
literal|1
operator|)
argument_list|,
operator|*
operator|(
name|macaddr
operator|+
literal|2
operator|)
argument_list|,
operator|*
operator|(
name|macaddr
operator|+
literal|3
operator|)
argument_list|,
operator|*
operator|(
name|macaddr
operator|+
literal|4
operator|)
argument_list|,
operator|*
operator|(
name|macaddr
operator|+
literal|5
operator|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|xge_hal_device_macaddr_set
argument_list|(
name|hldev
argument_list|,
literal|0
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Setting MAC address failed (Status: %d)\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
comment|/* Opening channels */
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
name|status
operator|=
name|xgell_channel_open
argument_list|(
name|lldev
argument_list|,
name|option
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
goto|goto
name|init_sub_out
goto|;
block|}
comment|/* Set appropriate flags */
name|ifnetp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifnetp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
comment|/* Checksum capability */
name|ifnetp
operator|->
name|if_hwassist
operator|=
operator|(
name|ifnetp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
operator|)
condition|?
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator|)
else|:
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|XGE_FEATURE_TSO
if|if
condition|(
name|ifnetp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO4
condition|)
name|ifnetp
operator|->
name|if_hwassist
operator||=
name|CSUM_TSO
expr_stmt|;
endif|#
directive|endif
comment|/* Enable interrupts */
name|xge_hal_device_intr_enable
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|lldev
operator|->
name|timer
argument_list|,
literal|10
operator|*
name|hz
argument_list|,
name|xge_timer
argument_list|,
name|lldev
argument_list|)
expr_stmt|;
comment|/* Disable promiscuous mode */
name|xge_trace
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"If opted, enable promiscuous mode"
argument_list|)
expr_stmt|;
name|xge_enable_promisc
argument_list|(
name|lldev
argument_list|)
expr_stmt|;
comment|/* Device is initialized */
name|lldev
operator|->
name|initialized
operator|=
literal|1
expr_stmt|;
name|xge_os_mdelay
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|init_sub_out
label|:
name|LEAVE_FUNCTION
return|return;
block|}
end_function

begin_comment
comment|/*******************************************************  * xge_terminate  *  * @dev: Device structure  * @option: Normal/Reset option for channels  *  * Called by both stop and reset functions to disable device, interrupts, and to  * close channels.  ******************************************************/
end_comment

begin_function
name|void
name|xge_terminate
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|xge_hal_channel_reopen_e
name|option
parameter_list|)
block|{
name|ENTER_FUNCTION
name|xgelldev_t
modifier|*
name|lldev
init|=
operator|(
name|xgelldev_t
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
init|=
name|lldev
operator|->
name|devh
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifnetp
init|=
name|lldev
operator|->
name|ifnetp
decl_stmt|;
comment|/* Set appropriate flags */
name|ifnetp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
comment|/* Stop timer */
name|callout_stop
argument_list|(
operator|&
name|lldev
operator|->
name|timer
argument_list|)
expr_stmt|;
comment|/* Disable interrupts */
name|xge_hal_device_intr_disable
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
name|xge_queue_flush
argument_list|(
name|xge_hal_device_queue
argument_list|(
name|lldev
operator|->
name|devh
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
comment|/* Disable HAL device */
if|if
condition|(
name|xge_hal_device_disable
argument_list|(
name|hldev
argument_list|)
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Disabling HAL device failed"
argument_list|)
expr_stmt|;
block|}
comment|/* Close Tx and Rx channels */
name|xgell_channel_close
argument_list|(
name|lldev
argument_list|,
name|option
argument_list|)
expr_stmt|;
comment|/* Reset HAL device */
name|xge_hal_device_reset
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
name|xge_os_mdelay
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|lldev
operator|->
name|initialized
operator|=
literal|0
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifnetp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
name|LEAVE_FUNCTION
block|}
end_function

begin_comment
comment|/******************************************  * Function:    xgell_set_mbuf_cflags  * Parameters:  mbuf structure pointer  * Return:      None  * Description: This fuction will set the csum_flag of the mbuf  ******************************************/
end_comment

begin_function
name|void
name|xgell_set_mbuf_cflags
parameter_list|(
name|mbuf_t
name|pkt
parameter_list|)
block|{
name|pkt
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
name|CSUM_IP_CHECKED
expr_stmt|;
name|pkt
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_IP_VALID
expr_stmt|;
name|pkt
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
operator|(
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
expr_stmt|;
name|pkt
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
name|htons
argument_list|(
literal|0xffff
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|XGE_FEATURE_LRO
end_ifdef

begin_comment
comment|/******************************************  * Function:    xgell_lro_flush_sessions  * Parameters:  Per adapter xgelldev_t  * Return:      None  * Description: This function will flush the LRO session and send the  *              accumulated LRO packet to Upper layer.  ******************************************/
end_comment

begin_function
name|void
name|xgell_lro_flush_sessions
parameter_list|(
name|xgelldev_t
modifier|*
name|lldev
parameter_list|)
block|{
name|lro_t
modifier|*
name|lro
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifnetp
init|=
name|lldev
operator|->
name|ifnetp
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|lldev
operator|->
name|devh
decl_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|lro
operator|=
name|xge_hal_lro_get_next_session
argument_list|(
name|hldev
argument_list|)
operator|)
condition|)
block|{
name|xgell_set_mbuf_cflags
argument_list|(
name|lro
operator|->
name|os_buf
argument_list|)
expr_stmt|;
comment|/* Send it up */
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifnetp
operator|->
name|if_input
call|)
argument_list|(
name|ifnetp
argument_list|,
name|lro
operator|->
name|os_buf
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
name|xge_hal_lro_close_session
argument_list|(
name|lro
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/******************************************  * Function:    xgell_accumulate_large_rx  * Parameters:  Descriptor info structure, current mbuf structure,  *              packet length, Per adapter structure, Rx Desc private structure  * Return:      None  * Description: This function will accumulate packets to form the LRO  *              packets based on various condition.  ******************************************/
end_comment

begin_function
name|void
name|xgell_accumulate_large_rx
parameter_list|(
name|xge_hal_dtr_info_t
modifier|*
name|ext_info
parameter_list|,
name|mbuf_t
name|pkt
parameter_list|,
name|int
name|pkt_length
parameter_list|,
name|xgelldev_t
modifier|*
name|lldev
parameter_list|,
name|xgell_rx_priv_t
modifier|*
name|rxd_priv
parameter_list|)
block|{
name|tcplro_t
modifier|*
name|tcp
decl_stmt|;
name|lro_t
modifier|*
name|lro
decl_stmt|,
modifier|*
name|lro_end3
decl_stmt|;
name|xge_hal_status_e
name|status
decl_stmt|;
name|unsigned
name|char
modifier|*
name|temp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifnetp
init|=
name|lldev
operator|->
name|ifnetp
decl_stmt|;
name|status
operator|=
name|xge_hal_accumulate_large_rx
argument_list|(
name|pkt
operator|->
name|m_data
argument_list|,
operator|&
name|tcp
argument_list|,
operator|&
name|pkt_length
argument_list|,
operator|&
name|lro
argument_list|,
name|ext_info
argument_list|,
name|lldev
operator|->
name|devh
argument_list|,
operator|&
name|lro_end3
argument_list|)
expr_stmt|;
name|pkt
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|temp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tcp
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|XGE_HAL_INF_LRO_BEGIN
condition|)
block|{
name|pkt
operator|->
name|m_flags
operator||=
name|M_PKTHDR
expr_stmt|;
name|pkt
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifnetp
expr_stmt|;
name|lro
operator|->
name|os_buf
operator|=
name|lro
operator|->
name|os_buf_end
operator|=
name|pkt
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|XGE_HAL_INF_LRO_CONT
condition|)
block|{
comment|/* 	     * Current mbuf will be combine to form LRO frame, 	     * So mask the pkthdr of the flag variable for current mbuf 	     */
name|pkt
operator|->
name|m_flags
operator|=
name|pkt
operator|->
name|m_flags
operator|&
literal|0xFFFD
expr_stmt|;
comment|//Mask pkthdr
name|pkt
operator|->
name|m_data
operator|=
operator|(
name|u8
operator|*
operator|)
name|tcp
expr_stmt|;
name|pkt
operator|->
name|m_len
operator|=
name|pkt_length
expr_stmt|;
comment|/* 	     * Combine the current mbuf to the LRO frame and update 	     * the LRO's pkthdr len accordingly 	     */
name|lro
operator|->
name|os_buf_end
operator|->
name|m_next
operator|=
name|pkt
expr_stmt|;
name|lro
operator|->
name|os_buf_end
operator|=
name|pkt
expr_stmt|;
name|lro
operator|->
name|os_buf
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|pkt_length
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|XGE_HAL_INF_LRO_END_2
condition|)
block|{
name|lro
operator|->
name|os_buf
operator|->
name|m_flags
operator||=
name|M_EOR
expr_stmt|;
comment|/* Update the Checksum flags of the LRO frames */
name|xgell_set_mbuf_cflags
argument_list|(
name|lro
operator|->
name|os_buf
argument_list|)
expr_stmt|;
comment|/* Post-Read sync */
name|bus_dmamap_sync
argument_list|(
name|lldev
operator|->
name|dma_tag_rx
argument_list|,
name|rxd_priv
operator|->
name|dmainfo
index|[
literal|0
index|]
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
comment|/* 	     * Current packet can not be combined with LRO frame. 	     * Flush the previous LRO frames and send the current packet 	     * seperately 	     */
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifnetp
operator|->
name|if_input
call|)
argument_list|(
name|ifnetp
argument_list|,
name|lro
operator|->
name|os_buf
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifnetp
operator|->
name|if_input
call|)
argument_list|(
name|ifnetp
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
name|xge_hal_lro_close_session
argument_list|(
name|lro
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|XGE_HAL_INF_LRO_END_1
condition|)
block|{
name|pkt
operator|->
name|m_flags
operator|=
name|pkt
operator|->
name|m_flags
operator|&
literal|0xFFFD
expr_stmt|;
name|pkt
operator|->
name|m_data
operator|=
operator|(
name|u8
operator|*
operator|)
name|tcp
expr_stmt|;
name|pkt
operator|->
name|m_len
operator|=
name|pkt_length
expr_stmt|;
name|lro
operator|->
name|os_buf_end
operator|->
name|m_next
operator|=
name|pkt
expr_stmt|;
name|lro
operator|->
name|os_buf
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|pkt_length
expr_stmt|;
name|xgell_set_mbuf_cflags
argument_list|(
name|lro
operator|->
name|os_buf
argument_list|)
expr_stmt|;
name|lro
operator|->
name|os_buf
operator|->
name|m_flags
operator||=
name|M_EOR
expr_stmt|;
comment|/* Post-Read sync */
name|bus_dmamap_sync
argument_list|(
name|lldev
operator|->
name|dma_tag_rx
argument_list|,
name|rxd_priv
operator|->
name|dmainfo
index|[
literal|0
index|]
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
comment|/* Send it up */
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifnetp
operator|->
name|if_input
call|)
argument_list|(
name|ifnetp
argument_list|,
name|lro
operator|->
name|os_buf
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
name|xge_hal_lro_close_session
argument_list|(
name|lro
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|XGE_HAL_INF_LRO_END_3
condition|)
block|{
name|pkt
operator|->
name|m_flags
operator||=
name|M_PKTHDR
expr_stmt|;
name|pkt
operator|->
name|m_len
operator|=
name|pkt_length
expr_stmt|;
name|pkt
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|pkt_length
expr_stmt|;
name|lro_end3
operator|->
name|os_buf
operator|=
name|lro_end3
operator|->
name|os_buf_end
operator|=
name|pkt
expr_stmt|;
name|lro
operator|->
name|os_buf
operator|->
name|m_flags
operator||=
name|M_EOR
expr_stmt|;
name|xgell_set_mbuf_cflags
argument_list|(
name|lro
operator|->
name|os_buf
argument_list|)
expr_stmt|;
comment|/* Post-Read sync */
name|bus_dmamap_sync
argument_list|(
name|lldev
operator|->
name|dma_tag_rx
argument_list|,
name|rxd_priv
operator|->
name|dmainfo
index|[
literal|0
index|]
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
comment|/* Send it up */
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifnetp
operator|->
name|if_input
call|)
argument_list|(
name|ifnetp
argument_list|,
name|lro
operator|->
name|os_buf
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
name|xge_hal_lro_close_session
argument_list|(
name|lro
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|status
operator|==
name|XGE_HAL_INF_LRO_UNCAPABLE
operator|)
operator|||
operator|(
name|status
operator|==
name|XGE_HAL_INF_LRO_SESSIONS_XCDED
operator|)
condition|)
block|{
name|pkt
operator|->
name|m_flags
operator||=
name|M_PKTHDR
expr_stmt|;
name|pkt
operator|->
name|m_len
operator|=
name|pkt_length
expr_stmt|;
name|pkt
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|pkt_length
expr_stmt|;
comment|/* Post-Read sync */
name|bus_dmamap_sync
argument_list|(
name|lldev
operator|->
name|dma_tag_rx
argument_list|,
name|rxd_priv
operator|->
name|dmainfo
index|[
literal|0
index|]
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
comment|/* Send it up */
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifnetp
operator|->
name|if_input
call|)
argument_list|(
name|ifnetp
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/******************************************  * Function:    xgell_rx_compl  * Parameters:  Channel handle, descriptor,  *              transfer code, userdata  *              (not used)  * Return:      HAL status code  * Description: If the interrupt is because  *              of a received frame or if  *              the receive ring contains  *              fresh as yet un-processed  *              frames, this function is  *              called.  ******************************************/
end_comment

begin_function
name|xge_hal_status_e
name|xgell_rx_compl
parameter_list|(
name|xge_hal_channel_h
name|channelh
parameter_list|,
name|xge_hal_dtr_h
name|dtr
parameter_list|,
name|u8
name|t_code
parameter_list|,
name|void
modifier|*
name|userdata
parameter_list|)
block|{
name|xge_hal_dtr_info_t
name|ext_info
decl_stmt|;
name|xge_hal_status_e
name|status_code
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifnetp
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|int
name|index
decl_stmt|;
name|mbuf_t
name|mbuf_up
init|=
name|NULL
decl_stmt|;
name|xgell_rx_priv_t
modifier|*
name|rxd_priv
init|=
name|NULL
decl_stmt|,
name|old_rxd_priv
decl_stmt|;
name|u16
name|vlan_tag
decl_stmt|;
comment|//    ENTER_FUNCTION
comment|/*get the user data portion*/
name|xgelldev_t
modifier|*
name|lldev
init|=
name|xge_hal_channel_userdata
argument_list|(
name|channelh
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|lldev
condition|)
block|{
name|xge_ctrace
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"xgeX: %s: Failed to get user data"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_FAIL
return|;
block|}
name|dev
operator|=
name|lldev
operator|->
name|device
expr_stmt|;
name|mtx_assert
argument_list|(
operator|(
operator|&
name|lldev
operator|->
name|xge_lock
operator|)
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* get the interface pointer */
name|ifnetp
operator|=
name|lldev
operator|->
name|ifnetp
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
operator|(
name|ifnetp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
return|return
name|XGE_HAL_FAIL
return|;
block|}
if|if
condition|(
name|t_code
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"Packet dropped because of %d"
argument_list|,
name|t_code
argument_list|)
expr_stmt|;
name|xge_hal_device_handle_tcode
argument_list|(
name|channelh
argument_list|,
name|dtr
argument_list|,
name|t_code
argument_list|)
expr_stmt|;
name|xge_hal_ring_dtr_post
argument_list|(
name|channelh
argument_list|,
name|dtr
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Get the private data for this descriptor*/
name|rxd_priv
operator|=
operator|(
name|xgell_rx_priv_t
operator|*
operator|)
name|xge_hal_ring_dtr_private
argument_list|(
name|channelh
argument_list|,
name|dtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rxd_priv
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Failed to get descriptor private data"
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_FAIL
return|;
block|}
comment|/* Taking backup of rxd_priv structure details of current packet */
name|xge_os_memcpy
argument_list|(
operator|&
name|old_rxd_priv
argument_list|,
name|rxd_priv
argument_list|,
sizeof|sizeof
argument_list|(
name|xgell_rx_priv_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Prepare one buffer to send it to upper layer -- since the upper 	     * layer frees the buffer do not use rxd_priv->buffer 	     * Meanwhile prepare a new buffer, do mapping, use it in the 	     * current descriptor and post descriptor back to ring channel */
name|mbuf_up
operator|=
name|rxd_priv
operator|->
name|bufferArray
index|[
literal|0
index|]
expr_stmt|;
comment|/* Gets details of mbuf i.e., packet length */
name|xge_ring_dtr_get
argument_list|(
name|mbuf_up
argument_list|,
name|channelh
argument_list|,
name|dtr
argument_list|,
name|lldev
argument_list|,
name|rxd_priv
argument_list|)
expr_stmt|;
name|status_code
operator|=
operator|(
name|lldev
operator|->
name|buffer_mode
operator|==
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_1
operator|)
condition|?
name|xgell_get_buf
argument_list|(
name|dtr
argument_list|,
name|rxd_priv
argument_list|,
name|lldev
argument_list|,
literal|0
argument_list|)
else|:
name|xgell_get_buf_3b_5b
argument_list|(
name|dtr
argument_list|,
name|rxd_priv
argument_list|,
name|lldev
argument_list|)
expr_stmt|;
if|if
condition|(
name|status_code
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"No memory"
argument_list|)
expr_stmt|;
comment|/* 	         * Do not deliver the received buffer to the stack. Instead, 	         * Re-post the descriptor with the same buffer 	         */
comment|/* Get back previous rxd_priv structure before posting */
name|xge_os_memcpy
argument_list|(
name|rxd_priv
argument_list|,
operator|&
name|old_rxd_priv
argument_list|,
sizeof|sizeof
argument_list|(
name|xgell_rx_priv_t
argument_list|)
argument_list|)
expr_stmt|;
name|xge_hal_ring_dtr_post
argument_list|(
name|channelh
argument_list|,
name|dtr
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Get the extended information */
name|xge_hal_ring_dtr_info_get
argument_list|(
name|channelh
argument_list|,
name|dtr
argument_list|,
operator|&
name|ext_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|lldev
operator|->
name|buffer_mode
operator|==
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_1
condition|)
block|{
comment|/* 	         * As we have allocated a new mbuf for this descriptor, post 	         * this descriptor with new mbuf back to ring channel 	         */
name|vlan_tag
operator|=
name|ext_info
operator|.
name|vlan
expr_stmt|;
name|xge_hal_ring_dtr_post
argument_list|(
name|channelh
argument_list|,
name|dtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
operator|(
name|ext_info
operator|.
name|proto
operator|&
name|XGE_HAL_FRAME_PROTO_IP_FRAGMENTED
operator|)
operator|&&
operator|(
name|ext_info
operator|.
name|proto
operator|&
name|XGE_HAL_FRAME_PROTO_TCP_OR_UDP
operator|)
operator|&&
operator|(
name|ext_info
operator|.
name|l3_cksum
operator|==
name|XGE_HAL_L3_CKSUM_OK
operator|)
operator|&&
operator|(
name|ext_info
operator|.
name|l4_cksum
operator|==
name|XGE_HAL_L4_CKSUM_OK
operator|)
operator|)
condition|)
block|{
comment|/* set Checksum Flag */
name|xgell_set_mbuf_cflags
argument_list|(
name|mbuf_up
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XGE_FEATURE_LRO
if|if
condition|(
name|lldev
operator|->
name|buffer_mode
operator|==
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_1
condition|)
block|{
name|xgell_accumulate_large_rx
argument_list|(
operator|&
name|ext_info
argument_list|,
name|mbuf_up
argument_list|,
name|mbuf_up
operator|->
name|m_len
argument_list|,
name|lldev
argument_list|,
name|rxd_priv
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* Post-Read sync for buffers*/
name|bus_dmamap_sync
argument_list|(
name|lldev
operator|->
name|dma_tag_rx
argument_list|,
name|rxd_priv
operator|->
name|dmainfo
index|[
literal|0
index|]
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
comment|/* Send it up */
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifnetp
operator|->
name|if_input
call|)
argument_list|(
name|ifnetp
argument_list|,
name|mbuf_up
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* 	             * Packet with erroneous checksum , let the upper layer 	             * deal with it 	             */
comment|/* Post-Read sync for buffers*/
name|bus_dmamap_sync
argument_list|(
name|lldev
operator|->
name|dma_tag_rx
argument_list|,
name|rxd_priv
operator|->
name|dmainfo
index|[
literal|0
index|]
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XGE_FEATURE_LRO
name|xgell_lro_flush_sessions
argument_list|(
name|lldev
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|vlan_tag
condition|)
block|{
name|mbuf_up
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|=
name|vlan_tag
expr_stmt|;
name|mbuf_up
operator|->
name|m_flags
operator||=
name|M_VLANTAG
expr_stmt|;
block|}
comment|/* Send it up */
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifnetp
operator|->
name|if_input
call|)
argument_list|(
name|ifnetp
argument_list|,
name|mbuf_up
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	         * As we have allocated a new mbuf for this descriptor, post 	         * this descriptor with new mbuf back to ring channel 	         */
name|xge_hal_ring_dtr_post
argument_list|(
name|channelh
argument_list|,
name|dtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
operator|(
name|ext_info
operator|.
name|proto
operator|&
name|XGE_HAL_FRAME_PROTO_IP_FRAGMENTED
operator|)
operator|&&
operator|(
name|ext_info
operator|.
name|proto
operator|&
name|XGE_HAL_FRAME_PROTO_TCP_OR_UDP
operator|)
operator|&&
operator|(
name|ext_info
operator|.
name|l3_cksum
operator|==
name|XGE_HAL_L3_CKSUM_OK
operator|)
operator|&&
operator|(
name|ext_info
operator|.
name|l4_cksum
operator|==
name|XGE_HAL_L4_CKSUM_OK
operator|)
operator|)
condition|)
block|{
comment|/* set Checksum Flag */
name|xgell_set_mbuf_cflags
argument_list|(
name|mbuf_up
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XGE_FEATURE_LRO
if|if
condition|(
name|lldev
operator|->
name|buffer_mode
operator|==
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_1
condition|)
block|{
name|xgell_accumulate_large_rx
argument_list|(
operator|&
name|ext_info
argument_list|,
name|mbuf_up
argument_list|,
name|mbuf_up
operator|->
name|m_len
argument_list|,
name|lldev
argument_list|,
name|rxd_priv
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* Post-Read sync for buffers*/
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|lldev
operator|->
name|rxd_mbuf_cnt
condition|;
name|index
operator|++
control|)
block|{
comment|/* Post-Read sync */
name|bus_dmamap_sync
argument_list|(
name|lldev
operator|->
name|dma_tag_rx
argument_list|,
name|rxd_priv
operator|->
name|dmainfo
index|[
name|index
index|]
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
block|}
comment|/* Send it up */
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifnetp
operator|->
name|if_input
call|)
argument_list|(
name|ifnetp
argument_list|,
name|mbuf_up
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* 	             * Packet with erroneous checksum , let the upper layer 	             * deal with it 	             */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|lldev
operator|->
name|rxd_mbuf_cnt
condition|;
name|index
operator|++
control|)
block|{
comment|/* Post-Read sync */
name|bus_dmamap_sync
argument_list|(
name|lldev
operator|->
name|dma_tag_rx
argument_list|,
name|rxd_priv
operator|->
name|dmainfo
index|[
name|index
index|]
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|XGE_FEATURE_LRO
name|xgell_lro_flush_sessions
argument_list|(
name|lldev
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Send it up */
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifnetp
operator|->
name|if_input
call|)
argument_list|(
name|ifnetp
argument_list|,
name|mbuf_up
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|xge_hal_ring_dtr_next_completed
argument_list|(
name|channelh
argument_list|,
operator|&
name|dtr
argument_list|,
operator|&
name|t_code
argument_list|)
operator|==
name|XGE_HAL_OK
condition|)
do|;
ifdef|#
directive|ifdef
name|XGE_FEATURE_LRO
name|xgell_lro_flush_sessions
argument_list|(
name|lldev
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|//    LEAVE_FUNCTION
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/******************************************  * Function:    xge_ring_dtr_get  * Parameters:  mbuf pointer, channel handler  *              descriptot, Per adapter xgelldev_t  *              structure pointer,  *              Rx private structure  * Return:      HAL status code  * Description: Updates the mbuf lengths  *              depending on packet lengths.  ******************************************/
end_comment

begin_function
name|int
name|xge_ring_dtr_get
parameter_list|(
name|mbuf_t
name|mbuf_up
parameter_list|,
name|xge_hal_channel_h
name|channelh
parameter_list|,
name|xge_hal_dtr_h
name|dtr
parameter_list|,
name|xgelldev_t
modifier|*
name|lldev
parameter_list|,
name|xgell_rx_priv_t
modifier|*
name|rxd_priv
parameter_list|)
block|{
name|mbuf_t
name|m
decl_stmt|;
name|int
name|pkt_length
index|[
literal|5
index|]
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|,
name|pkt_len
init|=
literal|0
decl_stmt|;
name|dma_addr_t
name|dma_data
index|[
literal|5
index|]
decl_stmt|;
name|int
name|index
decl_stmt|;
name|m
operator|=
name|mbuf_up
expr_stmt|;
name|pkt_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lldev
operator|->
name|buffer_mode
operator|!=
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_1
condition|)
block|{
name|xge_os_memzero
argument_list|(
name|pkt_length
argument_list|,
sizeof|sizeof
argument_list|(
name|pkt_length
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	     * Retrieve data of interest from the completed descriptor -- This 	     * returns the packet length 	     */
if|if
condition|(
name|lldev
operator|->
name|buffer_mode
operator|==
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_5
condition|)
block|{
name|xge_hal_ring_dtr_5b_get
argument_list|(
name|channelh
argument_list|,
name|dtr
argument_list|,
name|dma_data
argument_list|,
name|pkt_length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xge_hal_ring_dtr_3b_get
argument_list|(
name|channelh
argument_list|,
name|dtr
argument_list|,
name|dma_data
argument_list|,
name|pkt_length
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|lldev
operator|->
name|rxd_mbuf_cnt
condition|;
name|index
operator|++
control|)
block|{
name|m
operator|->
name|m_len
operator|=
name|pkt_length
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|index
operator|<
operator|(
name|lldev
operator|->
name|rxd_mbuf_cnt
operator|-
literal|1
operator|)
condition|)
block|{
name|m
operator|->
name|m_next
operator|=
name|rxd_priv
operator|->
name|bufferArray
index|[
name|index
operator|+
literal|1
index|]
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
else|else
block|{
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
block|}
name|pkt_len
operator|+=
name|pkt_length
index|[
name|index
index|]
expr_stmt|;
block|}
comment|/* 	     * Since 2 buffer mode is an exceptional case where data is in 3rd 	     * buffer but not in 2nd buffer 	     */
if|if
condition|(
name|lldev
operator|->
name|buffer_mode
operator|==
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_2
condition|)
block|{
name|m
operator|->
name|m_len
operator|=
name|pkt_length
index|[
literal|2
index|]
expr_stmt|;
name|pkt_len
operator|+=
name|pkt_length
index|[
literal|2
index|]
expr_stmt|;
block|}
comment|/* 	     * Update length of newly created buffer to be sent up with packet 	     * length 	     */
name|mbuf_up
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|pkt_len
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * Retrieve data of interest from the completed descriptor -- This 	     * returns the packet length 	     */
name|xge_hal_ring_dtr_1b_get
argument_list|(
name|channelh
argument_list|,
name|dtr
argument_list|,
operator|&
name|dma_data
index|[
literal|0
index|]
argument_list|,
operator|&
name|pkt_length
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* 	     * Update length of newly created buffer to be sent up with packet 	     * length 	     */
name|mbuf_up
operator|->
name|m_len
operator|=
name|mbuf_up
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|pkt_length
index|[
literal|0
index|]
expr_stmt|;
block|}
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/******************************************  * Function:    xge_send  * Parameters:  Pointer to ifnet structure  * Return:      None  * Description: Transmit entry point  ******************************************/
end_comment

begin_function
name|void
name|xge_send
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifnetp
parameter_list|)
block|{
name|xgelldev_t
modifier|*
name|lldev
init|=
name|ifnetp
operator|->
name|if_softc
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
name|xge_send_locked
argument_list|(
name|ifnetp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|xge_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xge_send_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifnetp
parameter_list|)
block|{
name|xge_hal_dtr_h
name|dtr
decl_stmt|;
specifier|static
name|bus_dma_segment_t
name|segs
index|[
name|MAX_SEGS
index|]
decl_stmt|;
name|xge_hal_status_e
name|status_code
decl_stmt|;
name|unsigned
name|int
name|max_fragments
decl_stmt|;
name|xgelldev_t
modifier|*
name|lldev
init|=
name|ifnetp
operator|->
name|if_softc
decl_stmt|;
name|xge_hal_channel_h
name|channelh
init|=
name|lldev
operator|->
name|fifo_channel_0
decl_stmt|;
name|mbuf_t
name|m_head
init|=
name|NULL
decl_stmt|;
name|mbuf_t
name|m_buf
init|=
name|NULL
decl_stmt|;
name|xgell_tx_priv_t
modifier|*
name|ll_tx_priv
init|=
name|NULL
decl_stmt|;
specifier|register
name|unsigned
name|int
name|count
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|nsegs
init|=
literal|0
decl_stmt|;
name|u16
name|vlan_tag
decl_stmt|;
name|max_fragments
operator|=
operator|(
operator|(
name|xge_hal_fifo_t
operator|*
operator|)
name|channelh
operator|)
operator|->
name|config
operator|->
name|max_frags
expr_stmt|;
name|mtx_assert
argument_list|(
operator|(
operator|&
name|lldev
operator|->
name|xge_lock
operator|)
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* If device is not initialized, return */
if|if
condition|(
operator|(
operator|!
name|lldev
operator|->
name|initialized
operator|)
operator|||
operator|(
operator|!
operator|(
name|ifnetp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|)
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Device is not initialized"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Get the number of free descriptors in the FIFO channel and return if 	 * the count is less than the XGELL_TX_LEVEL_LOW -- the low threshold 	 */
name|count
operator|=
name|xge_hal_channel_dtr_count
argument_list|(
name|channelh
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<=
name|XGELL_TX_LEVEL_LOW
condition|)
block|{
name|ifnetp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
name|xge_trace
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"Free descriptor count %d/%d at low threshold"
argument_list|,
name|count
argument_list|,
name|XGELL_TX_LEVEL_LOW
argument_list|)
expr_stmt|;
comment|/* Serialized -- through queue */
name|xge_queue_produce_context
argument_list|(
name|xge_hal_device_queue
argument_list|(
name|lldev
operator|->
name|devh
argument_list|)
argument_list|,
name|XGE_LL_EVENT_TRY_XMIT_AGAIN
argument_list|,
name|lldev
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* This loop will be executed for each packet in the kernel maintained 	 * queue -- each packet can be with fragments as an mbuf chain */
while|while
condition|(
operator|(
name|ifnetp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|)
operator|&&
operator|(
name|xge_hal_channel_dtr_count
argument_list|(
name|channelh
argument_list|)
operator|>
name|XGELL_TX_LEVEL_LOW
operator|)
condition|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifnetp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
operator|,
name|m_buf
operator|=
name|m_head
init|;
name|m_buf
operator|!=
name|NULL
condition|;
name|m_buf
operator|=
name|m_buf
operator|->
name|m_next
control|)
block|{
if|if
condition|(
name|m_buf
operator|->
name|m_len
condition|)
block|{
name|count
operator|+=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|count
operator|>=
name|max_fragments
condition|)
block|{
name|m_buf
operator|=
name|m_defrag
argument_list|(
name|m_head
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_buf
operator|!=
name|NULL
condition|)
block|{
name|m_head
operator|=
name|m_buf
expr_stmt|;
block|}
block|}
comment|/* Reserve descriptors */
name|status_code
operator|=
name|xge_hal_fifo_dtr_reserve
argument_list|(
name|channelh
argument_list|,
operator|&
name|dtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|status_code
condition|)
block|{
switch|switch
condition|(
name|status_code
condition|)
block|{
case|case
name|XGE_HAL_INF_CHANNEL_IS_NOT_READY
case|:
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Channel is not ready"
argument_list|)
expr_stmt|;
break|break;
case|case
name|XGE_HAL_INF_OUT_OF_DESCRIPTORS
case|:
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Out of descriptors"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Reserving (Tx) descriptors failed. Status %d"
argument_list|,
name|status_code
argument_list|)
expr_stmt|;
block|}
goto|goto
name|out2
goto|;
break|break;
block|}
name|vlan_tag
operator|=
operator|(
name|m_head
operator|->
name|m_flags
operator|&
name|M_VLANTAG
operator|)
condition|?
name|m_head
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
else|:
literal|0
expr_stmt|;
name|xge_hal_fifo_dtr_vlan_set
argument_list|(
name|dtr
argument_list|,
name|vlan_tag
argument_list|)
expr_stmt|;
comment|/* Update Tx private structure for this descriptor */
name|ll_tx_priv
operator|=
name|xge_hal_fifo_dtr_private
argument_list|(
name|dtr
argument_list|)
expr_stmt|;
name|ll_tx_priv
operator|->
name|buffer
operator|=
name|m_head
expr_stmt|;
comment|/* 	     * Do mapping -- Required DMA tag has been created in xge_init 	     * function and DMA maps have already been created in the 	     * xgell_tx_replenish function. 	     * Returns number of segments through nsegs 	     */
if|if
condition|(
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|lldev
operator|->
name|dma_tag_tx
argument_list|,
name|ll_tx_priv
operator|->
name|dma_map
argument_list|,
name|m_head
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"DMA map load with segments failed"
argument_list|)
expr_stmt|;
goto|goto
name|out2
goto|;
block|}
comment|/* Set descriptor buffer for header and each fragment/segment */
name|count
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|xge_hal_fifo_dtr_buffer_set
argument_list|(
name|channelh
argument_list|,
name|dtr
argument_list|,
name|count
argument_list|,
operator|(
name|dma_addr_t
operator|)
name|htole64
argument_list|(
name|segs
index|[
name|count
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|,
name|segs
index|[
name|count
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
name|count
operator|=
name|count
operator|+
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|count
operator|<
name|nsegs
condition|)
do|;
comment|/* Pre-write Sync of mapping */
name|bus_dmamap_sync
argument_list|(
name|lldev
operator|->
name|dma_tag_tx
argument_list|,
name|ll_tx_priv
operator|->
name|dma_map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XGE_FEATURE_TSO
if|if
condition|(
operator|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
operator|)
operator|!=
literal|0
condition|)
block|{
name|xge_hal_fifo_dtr_mss_set
argument_list|(
name|dtr
argument_list|,
name|m_head
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Checksum */
if|if
condition|(
name|ifnetp
operator|->
name|if_hwassist
operator|>
literal|0
condition|)
block|{
name|xge_hal_fifo_dtr_cksum_set_bits
argument_list|(
name|dtr
argument_list|,
name|XGE_HAL_TXD_TX_CKO_IPV4_EN
operator||
name|XGE_HAL_TXD_TX_CKO_TCP_EN
operator||
name|XGE_HAL_TXD_TX_CKO_UDP_EN
argument_list|)
expr_stmt|;
block|}
comment|/* Post descriptor to FIFO channel */
name|xge_hal_fifo_dtr_post
argument_list|(
name|channelh
argument_list|,
name|dtr
argument_list|)
expr_stmt|;
comment|/* Send the same copy of mbuf packet to BPF (Berkely Packet Filter) 	     * listener so that we can use tools like tcpdump */
name|ETHER_BPF_MTAP
argument_list|(
name|ifnetp
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
block|}
goto|goto
name|out1
goto|;
name|out2
label|:
comment|/* Prepend the packet back to queue */
name|IF_PREPEND
argument_list|(
operator|&
name|ifnetp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
name|out1
label|:
name|ifnetp
operator|->
name|if_timer
operator|=
literal|15
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************  * Function:    xgell_get_buf  * Parameters:  Per adapter xgelldev_t  *              structure pointer, descriptor,  *              Rx private structure, rxd_priv buffer  *              buffer index for mapping  * Return:      HAL status code  * Description: Gets buffer from system mbuf  *              buffer pool.  ******************************************/
end_comment

begin_function
name|int
name|xgell_get_buf
parameter_list|(
name|xge_hal_dtr_h
name|dtrh
parameter_list|,
name|xgell_rx_priv_t
modifier|*
name|rxd_priv
parameter_list|,
name|xgelldev_t
modifier|*
name|lldev
parameter_list|,
name|int
name|index
parameter_list|)
block|{
specifier|register
name|mbuf_t
name|mp
init|=
name|NULL
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifnetp
init|=
name|lldev
operator|->
name|ifnetp
decl_stmt|;
name|int
name|retValue
init|=
name|XGE_HAL_OK
decl_stmt|;
name|bus_addr_t
name|paddr
decl_stmt|;
name|int
name|BUFLEN
init|=
literal|0
decl_stmt|,
name|CLUSTLEN
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|lldev
operator|->
name|buffer_mode
operator|==
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_1
condition|)
block|{
name|CLUSTLEN
operator|=
name|MJUMPAGESIZE
expr_stmt|;
name|BUFLEN
operator|=
name|MJUMPAGESIZE
expr_stmt|;
block|}
else|else
block|{
name|BUFLEN
operator|=
name|lldev
operator|->
name|rxd_mbuf_len
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|BUFLEN
operator|<
name|MCLBYTES
condition|)
block|{
name|CLUSTLEN
operator|=
name|MCLBYTES
expr_stmt|;
block|}
else|else
block|{
name|CLUSTLEN
operator|=
name|MJUMPAGESIZE
expr_stmt|;
block|}
block|}
comment|/* Get mbuf with attached cluster */
name|mp
operator|=
name|m_getjcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|CLUSTLEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mp
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Out of memory to allocate mbuf"
argument_list|)
expr_stmt|;
name|retValue
operator|=
name|XGE_HAL_FAIL
expr_stmt|;
goto|goto
name|getbuf_out
goto|;
block|}
comment|/* Update mbuf's length, packet length and receive interface */
name|mp
operator|->
name|m_len
operator|=
name|mp
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|BUFLEN
expr_stmt|;
name|mp
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifnetp
expr_stmt|;
comment|/* Unload DMA map of mbuf in current descriptor */
name|bus_dmamap_unload
argument_list|(
name|lldev
operator|->
name|dma_tag_rx
argument_list|,
name|rxd_priv
operator|->
name|dmainfo
index|[
name|index
index|]
operator|.
name|dma_map
argument_list|)
expr_stmt|;
comment|/* Load DMA map */
if|if
condition|(
name|bus_dmamap_load
argument_list|(
name|lldev
operator|->
name|dma_tag_rx
argument_list|,
name|rxd_priv
operator|->
name|dmainfo
index|[
name|index
index|]
operator|.
name|dma_map
argument_list|,
name|mtod
argument_list|(
name|mp
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|mp
operator|->
name|m_len
argument_list|,
name|dmamap_cb
argument_list|,
operator|&
name|paddr
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Loading DMA map failed"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|retValue
operator|=
name|XGE_HAL_FAIL
expr_stmt|;
goto|goto
name|getbuf_out
goto|;
block|}
comment|/* Update descriptor private data */
name|rxd_priv
operator|->
name|bufferArray
index|[
name|index
index|]
operator|=
name|mp
expr_stmt|;
name|rxd_priv
operator|->
name|dmainfo
index|[
name|index
index|]
operator|.
name|dma_phyaddr
operator|=
name|htole64
argument_list|(
name|paddr
argument_list|)
expr_stmt|;
comment|/* Pre-Read/Write sync */
name|bus_dmamap_sync
argument_list|(
name|lldev
operator|->
name|dma_tag_rx
argument_list|,
name|rxd_priv
operator|->
name|dmainfo
index|[
name|index
index|]
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Set descriptor buffer */
if|if
condition|(
name|lldev
operator|->
name|buffer_mode
operator|==
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_1
condition|)
block|{
name|xge_hal_ring_dtr_1b_set
argument_list|(
name|dtrh
argument_list|,
name|rxd_priv
operator|->
name|dmainfo
index|[
literal|0
index|]
operator|.
name|dma_phyaddr
argument_list|,
name|MJUMPAGESIZE
argument_list|)
expr_stmt|;
block|}
name|getbuf_out
label|:
return|return
name|retValue
return|;
block|}
end_function

begin_comment
comment|/******************************************  * Function:    xgell_get_buf_3b_5b  * Parameters:  Per adapter xgelldev_t  *              structure pointer, descriptor,  *              Rx private structure  * Return:      HAL status code  * Description: Gets buffers from system mbuf  *              buffer pool.  ******************************************/
end_comment

begin_function
name|int
name|xgell_get_buf_3b_5b
parameter_list|(
name|xge_hal_dtr_h
name|dtrh
parameter_list|,
name|xgell_rx_priv_t
modifier|*
name|rxd_priv
parameter_list|,
name|xgelldev_t
modifier|*
name|lldev
parameter_list|)
block|{
name|bus_addr_t
name|dma_pointers
index|[
literal|5
index|]
decl_stmt|;
name|int
name|dma_sizes
index|[
literal|5
index|]
decl_stmt|;
name|int
name|retValue
init|=
name|XGE_HAL_OK
decl_stmt|,
name|index
decl_stmt|;
name|int
name|newindex
init|=
literal|0
decl_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|lldev
operator|->
name|rxd_mbuf_cnt
condition|;
name|index
operator|++
control|)
block|{
name|retValue
operator|=
name|xgell_get_buf
argument_list|(
name|dtrh
argument_list|,
name|rxd_priv
argument_list|,
name|lldev
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|retValue
operator|!=
name|XGE_HAL_OK
condition|)
block|{
for|for
control|(
name|newindex
operator|=
literal|0
init|;
name|newindex
operator|<
name|index
condition|;
name|newindex
operator|++
control|)
block|{
name|m_freem
argument_list|(
name|rxd_priv
operator|->
name|bufferArray
index|[
name|newindex
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|retValue
return|;
block|}
block|}
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|lldev
operator|->
name|buffer_mode
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
name|lldev
operator|->
name|rxd_mbuf_len
index|[
name|index
index|]
operator|!=
literal|0
condition|)
block|{
name|dma_pointers
index|[
name|index
index|]
operator|=
name|rxd_priv
operator|->
name|dmainfo
index|[
name|index
index|]
operator|.
name|dma_phyaddr
expr_stmt|;
name|dma_sizes
index|[
name|index
index|]
operator|=
name|lldev
operator|->
name|rxd_mbuf_len
index|[
name|index
index|]
expr_stmt|;
block|}
else|else
block|{
name|dma_pointers
index|[
name|index
index|]
operator|=
name|rxd_priv
operator|->
name|dmainfo
index|[
name|index
operator|-
literal|1
index|]
operator|.
name|dma_phyaddr
expr_stmt|;
name|dma_sizes
index|[
name|index
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Assigning second buffer to third pointer in 2 buffer mode */
if|if
condition|(
name|lldev
operator|->
name|buffer_mode
operator|==
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_2
condition|)
block|{
name|dma_pointers
index|[
literal|2
index|]
operator|=
name|dma_pointers
index|[
literal|1
index|]
expr_stmt|;
name|dma_sizes
index|[
literal|2
index|]
operator|=
name|dma_sizes
index|[
literal|1
index|]
expr_stmt|;
name|dma_sizes
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|lldev
operator|->
name|buffer_mode
operator|==
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_5
condition|)
block|{
name|xge_hal_ring_dtr_5b_set
argument_list|(
name|dtrh
argument_list|,
name|dma_pointers
argument_list|,
name|dma_sizes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xge_hal_ring_dtr_3b_set
argument_list|(
name|dtrh
argument_list|,
name|dma_pointers
argument_list|,
name|dma_sizes
argument_list|)
expr_stmt|;
block|}
return|return
name|retValue
return|;
block|}
end_function

begin_comment
comment|/******************************************  * Function:    xgell_tx_compl  * Parameters:  Channel handle, descriptor,  *              transfer code,  *              userdata -> per adapter  *              xgelldev_t structure as void *  * Return:      HAL status code  * Description: If an interrupt was raised  *              to indicate DMA complete of  *              the Tx packet, this function  *              is called. It identifies the  *              last TxD whose buffer was  *              freed and frees all skbs  *              whose data have already DMA'ed  *              into the NICs internal memory.  ******************************************/
end_comment

begin_function
name|xge_hal_status_e
name|xgell_tx_compl
parameter_list|(
name|xge_hal_channel_h
name|channelh
parameter_list|,
name|xge_hal_dtr_h
name|dtr
parameter_list|,
name|u8
name|t_code
parameter_list|,
name|void
modifier|*
name|userdata
parameter_list|)
block|{
name|xgell_tx_priv_t
modifier|*
name|ll_tx_priv
decl_stmt|;
name|mbuf_t
name|m_buffer
decl_stmt|;
name|xgelldev_t
modifier|*
name|lldev
init|=
operator|(
name|xgelldev_t
operator|*
operator|)
name|userdata
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifnetp
init|=
name|lldev
operator|->
name|ifnetp
decl_stmt|;
name|ifnetp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
comment|/* For each completed descriptor: Get private structure, free buffer, 	 * do unmapping, and free descriptor */
do|do
block|{
if|if
condition|(
name|t_code
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"t_code %d"
argument_list|,
name|t_code
argument_list|)
expr_stmt|;
name|xge_hal_device_handle_tcode
argument_list|(
name|channelh
argument_list|,
name|dtr
argument_list|,
name|t_code
argument_list|)
expr_stmt|;
block|}
name|ll_tx_priv
operator|=
name|xge_hal_fifo_dtr_private
argument_list|(
name|dtr
argument_list|)
expr_stmt|;
name|m_buffer
operator|=
name|ll_tx_priv
operator|->
name|buffer
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|lldev
operator|->
name|dma_tag_tx
argument_list|,
name|ll_tx_priv
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m_buffer
argument_list|)
expr_stmt|;
name|ll_tx_priv
operator|->
name|buffer
operator|=
name|NULL
expr_stmt|;
name|xge_hal_fifo_dtr_free
argument_list|(
name|channelh
argument_list|,
name|dtr
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|xge_hal_fifo_dtr_next_completed
argument_list|(
name|channelh
argument_list|,
operator|&
name|dtr
argument_list|,
operator|&
name|t_code
argument_list|)
operator|==
name|XGE_HAL_OK
condition|)
do|;
name|ifnetp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/******************************************  * Function:    xgell_tx_initial_replenish  * Parameters:  Channel handle, descriptor,  *              index (not used), userdata  *              (not used), channel  *              open/close/reopen option.  * Return:      HAL status code  * Description: Creates DMA maps to be used  *              for Tx  ******************************************/
end_comment

begin_function
name|xge_hal_status_e
name|xgell_tx_initial_replenish
parameter_list|(
name|xge_hal_channel_h
name|channelh
parameter_list|,
name|xge_hal_dtr_h
name|dtrh
parameter_list|,
name|int
name|index
parameter_list|,
name|void
modifier|*
name|userdata
parameter_list|,
name|xge_hal_channel_reopen_e
name|reopen
parameter_list|)
block|{
name|xgell_tx_priv_t
modifier|*
name|txd_priv
init|=
name|NULL
decl_stmt|;
name|int
name|retValue
init|=
name|XGE_HAL_OK
decl_stmt|;
name|device_t
name|dev
init|=
name|NULL
decl_stmt|;
comment|/* Get the user data portion from channel handle */
name|xgelldev_t
modifier|*
name|lldev
init|=
name|xge_hal_channel_userdata
argument_list|(
name|channelh
argument_list|)
decl_stmt|;
if|if
condition|(
name|lldev
operator|==
name|NULL
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Failed to get user data"
argument_list|)
expr_stmt|;
name|retValue
operator|=
name|XGE_HAL_FAIL
expr_stmt|;
goto|goto
name|txinit_out
goto|;
block|}
name|dev
operator|=
name|lldev
operator|->
name|device
expr_stmt|;
comment|/* Get the private data */
name|txd_priv
operator|=
operator|(
name|xgell_tx_priv_t
operator|*
operator|)
name|xge_hal_fifo_dtr_private
argument_list|(
name|dtrh
argument_list|)
expr_stmt|;
if|if
condition|(
name|txd_priv
operator|==
name|NULL
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Failed to get descriptor private data"
argument_list|)
expr_stmt|;
name|retValue
operator|=
name|XGE_HAL_FAIL
expr_stmt|;
goto|goto
name|txinit_out
goto|;
block|}
comment|/* Create DMA map for this descriptor */
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|lldev
operator|->
name|dma_tag_tx
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|txd_priv
operator|->
name|dma_map
argument_list|)
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"DMA map creation for Tx descriptor failed"
argument_list|)
expr_stmt|;
name|retValue
operator|=
name|XGE_HAL_FAIL
expr_stmt|;
goto|goto
name|txinit_out
goto|;
block|}
name|txinit_out
label|:
return|return
name|retValue
return|;
block|}
end_function

begin_comment
comment|/******************************************  * Function:    xgell_rx_initial_replenish  * Parameters:  Channel handle, descriptor,  *              ring index, userdata  *              (not used), channel  *              open/close/reopen option.  * Return:      HAL status code  * Description: Replenish descriptor with  *              rx_buffer in Rx buffer pool.  ******************************************/
end_comment

begin_function
name|xge_hal_status_e
name|xgell_rx_initial_replenish
parameter_list|(
name|xge_hal_channel_h
name|channelh
parameter_list|,
name|xge_hal_dtr_h
name|dtrh
parameter_list|,
name|int
name|index
parameter_list|,
name|void
modifier|*
name|userdata
parameter_list|,
name|xge_hal_channel_reopen_e
name|reopen
parameter_list|)
block|{
name|xgell_rx_priv_t
modifier|*
name|rxd_priv
init|=
name|NULL
decl_stmt|;
name|int
name|retValue
init|=
name|XGE_HAL_OK
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifnetp
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|int
name|index1
decl_stmt|,
name|index2
decl_stmt|;
comment|/* Get the user data portion from channel handle */
name|xgelldev_t
modifier|*
name|lldev
init|=
name|xge_hal_channel_userdata
argument_list|(
name|channelh
argument_list|)
decl_stmt|;
if|if
condition|(
name|lldev
operator|==
name|NULL
condition|)
block|{
name|xge_ctrace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"xgeX: %s: Failed to get user data"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|retValue
operator|=
name|XGE_HAL_FAIL
expr_stmt|;
goto|goto
name|rxinit_out
goto|;
block|}
name|dev
operator|=
name|lldev
operator|->
name|device
expr_stmt|;
comment|/* Get the private data */
name|rxd_priv
operator|=
operator|(
name|xgell_rx_priv_t
operator|*
operator|)
name|xge_hal_ring_dtr_private
argument_list|(
name|channelh
argument_list|,
name|dtrh
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxd_priv
operator|==
name|NULL
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Failed to get descriptor private data"
argument_list|)
expr_stmt|;
name|retValue
operator|=
name|XGE_HAL_FAIL
expr_stmt|;
goto|goto
name|rxinit_out
goto|;
block|}
name|rxd_priv
operator|->
name|bufferArray
operator|=
name|malloc
argument_list|(
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|rxd_priv
operator|->
name|bufferArray
argument_list|)
operator|)
operator|*
operator|(
name|lldev
operator|->
name|rxd_mbuf_cnt
operator|)
operator|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxd_priv
operator|->
name|bufferArray
operator|==
name|NULL
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Failed to allocate buffers for Rxd private structure"
argument_list|)
expr_stmt|;
name|retValue
operator|=
name|XGE_HAL_FAIL
expr_stmt|;
goto|goto
name|rxinit_out
goto|;
block|}
name|ifnetp
operator|=
name|lldev
operator|->
name|ifnetp
expr_stmt|;
if|if
condition|(
name|lldev
operator|->
name|buffer_mode
operator|==
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_1
condition|)
block|{
comment|/* Create DMA map for these descriptors*/
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|lldev
operator|->
name|dma_tag_rx
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|rxd_priv
operator|->
name|dmainfo
index|[
literal|0
index|]
operator|.
name|dma_map
argument_list|)
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"DMA map creation for Rx descriptor failed"
argument_list|)
expr_stmt|;
name|retValue
operator|=
name|XGE_HAL_FAIL
expr_stmt|;
goto|goto
name|rxinit_err_out
goto|;
block|}
comment|/* Get a buffer, attach it to this descriptor */
name|retValue
operator|=
name|xgell_get_buf
argument_list|(
name|dtrh
argument_list|,
name|rxd_priv
argument_list|,
name|lldev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|index1
operator|=
literal|0
init|;
name|index1
operator|<
name|lldev
operator|->
name|rxd_mbuf_cnt
condition|;
name|index1
operator|++
control|)
block|{
comment|/* Create DMA map for this descriptor */
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|lldev
operator|->
name|dma_tag_rx
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|rxd_priv
operator|->
name|dmainfo
index|[
name|index1
index|]
operator|.
name|dma_map
argument_list|)
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Jumbo DMA map creation for Rx descriptor failed"
argument_list|)
expr_stmt|;
for|for
control|(
name|index2
operator|=
name|index1
operator|-
literal|1
init|;
name|index2
operator|>=
literal|0
condition|;
name|index2
operator|--
control|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|lldev
operator|->
name|dma_tag_rx
argument_list|,
name|rxd_priv
operator|->
name|dmainfo
index|[
name|index2
index|]
operator|.
name|dma_map
argument_list|)
expr_stmt|;
block|}
name|retValue
operator|=
name|XGE_HAL_FAIL
expr_stmt|;
goto|goto
name|rxinit_err_out
goto|;
block|}
block|}
name|retValue
operator|=
name|xgell_get_buf_3b_5b
argument_list|(
name|dtrh
argument_list|,
name|rxd_priv
argument_list|,
name|lldev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|retValue
operator|!=
name|XGE_HAL_OK
condition|)
block|{
for|for
control|(
name|index1
operator|=
literal|0
init|;
name|index1
operator|<
name|lldev
operator|->
name|rxd_mbuf_cnt
condition|;
name|index1
operator|++
control|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|lldev
operator|->
name|dma_tag_rx
argument_list|,
name|rxd_priv
operator|->
name|dmainfo
index|[
name|index1
index|]
operator|.
name|dma_map
argument_list|)
expr_stmt|;
block|}
goto|goto
name|rxinit_err_out
goto|;
block|}
else|else
block|{
goto|goto
name|rxinit_out
goto|;
block|}
name|rxinit_err_out
label|:
name|free
argument_list|(
name|rxd_priv
operator|->
name|bufferArray
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|rxinit_out
label|:
return|return
name|retValue
return|;
block|}
end_function

begin_comment
comment|/******************************************  * Function:    xgell_rx_term  * Parameters:  Channel handle, descriptor,  *              descriptor state, userdata  *              (not used), channel  *              open/close/reopen option.  * Return:      None  * Description: Called by HAL to terminate  *              all DTRs for ring channels.  ******************************************/
end_comment

begin_function
name|void
name|xgell_rx_term
parameter_list|(
name|xge_hal_channel_h
name|channelh
parameter_list|,
name|xge_hal_dtr_h
name|dtrh
parameter_list|,
name|xge_hal_dtr_state_e
name|state
parameter_list|,
name|void
modifier|*
name|userdata
parameter_list|,
name|xge_hal_channel_reopen_e
name|reopen
parameter_list|)
block|{
name|xgell_rx_priv_t
modifier|*
name|rxd_priv
decl_stmt|;
name|xgelldev_t
modifier|*
name|lldev
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifnetp
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|int
name|index
decl_stmt|;
comment|//    ENTER_FUNCTION
comment|/* Descriptor state is not "Posted" */
if|if
condition|(
name|state
operator|!=
name|XGE_HAL_DTR_STATE_POSTED
condition|)
block|{
name|xge_ctrace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"xgeX: %s: Descriptor not posted\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
goto|goto
name|rxterm_out
goto|;
block|}
comment|/* Get the user data portion */
name|lldev
operator|=
name|xge_hal_channel_userdata
argument_list|(
name|channelh
argument_list|)
expr_stmt|;
name|dev
operator|=
name|lldev
operator|->
name|device
expr_stmt|;
name|ifnetp
operator|=
name|lldev
operator|->
name|ifnetp
expr_stmt|;
comment|/* Get the private data */
name|rxd_priv
operator|=
operator|(
name|xgell_rx_priv_t
operator|*
operator|)
name|xge_hal_ring_dtr_private
argument_list|(
name|channelh
argument_list|,
name|dtrh
argument_list|)
expr_stmt|;
if|if
condition|(
name|lldev
operator|->
name|buffer_mode
operator|==
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_1
condition|)
block|{
comment|/* Post-Read sync */
name|bus_dmamap_sync
argument_list|(
name|lldev
operator|->
name|dma_tag_rx
argument_list|,
name|rxd_priv
operator|->
name|dmainfo
index|[
literal|0
index|]
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
comment|/* Do unmapping and destory DMA map */
name|bus_dmamap_unload
argument_list|(
name|lldev
operator|->
name|dma_tag_rx
argument_list|,
name|rxd_priv
operator|->
name|dmainfo
index|[
literal|0
index|]
operator|.
name|dma_map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|rxd_priv
operator|->
name|bufferArray
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|lldev
operator|->
name|dma_tag_rx
argument_list|,
name|rxd_priv
operator|->
name|dmainfo
index|[
literal|0
index|]
operator|.
name|dma_map
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|lldev
operator|->
name|rxd_mbuf_cnt
condition|;
name|index
operator|++
control|)
block|{
comment|/* Post-Read sync */
name|bus_dmamap_sync
argument_list|(
name|lldev
operator|->
name|dma_tag_rx
argument_list|,
name|rxd_priv
operator|->
name|dmainfo
index|[
name|index
index|]
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
comment|/* Do unmapping and destory DMA map */
name|bus_dmamap_unload
argument_list|(
name|lldev
operator|->
name|dma_tag_rx
argument_list|,
name|rxd_priv
operator|->
name|dmainfo
index|[
name|index
index|]
operator|.
name|dma_map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|lldev
operator|->
name|dma_tag_rx
argument_list|,
name|rxd_priv
operator|->
name|dmainfo
index|[
name|index
index|]
operator|.
name|dma_map
argument_list|)
expr_stmt|;
comment|/* Free the buffer */
name|m_free
argument_list|(
name|rxd_priv
operator|->
name|bufferArray
index|[
name|index
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|rxd_priv
operator|->
name|bufferArray
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
comment|/* Free the descriptor */
name|xge_hal_ring_dtr_free
argument_list|(
name|channelh
argument_list|,
name|dtrh
argument_list|)
expr_stmt|;
name|rxterm_out
label|:
comment|//    LEAVE_FUNCTION
return|return;
block|}
end_function

begin_comment
comment|/******************************************  * Function:    xgell_tx_term  * Parameters:  Channel handle, descriptor,  *              descriptor state, userdata  *              (not used), channel  *              open/close/reopen option.  * Return:      None  * Description: Called by HAL to terminate  *              all DTRs for fifo channels.  ******************************************/
end_comment

begin_function
name|void
name|xgell_tx_term
parameter_list|(
name|xge_hal_channel_h
name|channelh
parameter_list|,
name|xge_hal_dtr_h
name|dtr
parameter_list|,
name|xge_hal_dtr_state_e
name|state
parameter_list|,
name|void
modifier|*
name|userdata
parameter_list|,
name|xge_hal_channel_reopen_e
name|reopen
parameter_list|)
block|{
name|xgell_tx_priv_t
modifier|*
name|ll_tx_priv
init|=
name|xge_hal_fifo_dtr_private
argument_list|(
name|dtr
argument_list|)
decl_stmt|;
name|xgelldev_t
modifier|*
name|lldev
init|=
operator|(
name|xgelldev_t
operator|*
operator|)
name|userdata
decl_stmt|;
comment|//    ENTER_FUNCTION
comment|/* Destroy DMA map */
name|bus_dmamap_destroy
argument_list|(
name|lldev
operator|->
name|dma_tag_tx
argument_list|,
name|ll_tx_priv
operator|->
name|dma_map
argument_list|)
expr_stmt|;
comment|//    LEAVE_FUNCTION
block|}
end_function

begin_comment
comment|/******************************************  * xge_methods  *  * FreeBSD device interface entry points  ******************************************/
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|xge_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|xge_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|xge_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|xge_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|xge_shutdown
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|xge_driver
init|=
block|{
literal|"nxge"
block|,
name|xge_methods
block|,
sizeof|sizeof
argument_list|(
name|xgelldev_t
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|xge_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|nxge
argument_list|,
name|pci
argument_list|,
name|xge_driver
argument_list|,
name|xge_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

