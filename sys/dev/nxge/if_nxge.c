begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002-2007 Neterion, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<dev/nxge/if_nxge.h>
end_include

begin_include
include|#
directive|include
file|<dev/nxge/xge-osdep.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_decl_stmt
name|int
name|copyright_print
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|hal_driver_init_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|size
init|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
specifier|inline
name|xge_flush_txds
parameter_list|(
name|xge_hal_channel_h
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * xge_probe  * Probes for Xframe devices  *  * @dev Device handle  *  * Returns  * BUS_PROBE_DEFAULT if device is supported  * ENXIO if device is not supported  */
end_comment

begin_function
name|int
name|xge_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|devid
init|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|vendorid
init|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|retValue
init|=
name|ENXIO
decl_stmt|;
if|if
condition|(
name|vendorid
operator|==
name|XGE_PCI_VENDOR_ID
condition|)
block|{
if|if
condition|(
operator|(
name|devid
operator|==
name|XGE_PCI_DEVICE_ID_XENA_2
operator|)
operator|||
operator|(
name|devid
operator|==
name|XGE_PCI_DEVICE_ID_HERC_2
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|copyright_print
condition|)
block|{
name|xge_os_printf
argument_list|(
name|XGE_COPYRIGHT
argument_list|)
expr_stmt|;
name|copyright_print
operator|=
literal|1
expr_stmt|;
block|}
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
literal|"Neterion Xframe 10 Gigabit Ethernet Adapter"
argument_list|)
expr_stmt|;
name|retValue
operator|=
name|BUS_PROBE_DEFAULT
expr_stmt|;
block|}
block|}
return|return
name|retValue
return|;
block|}
end_function

begin_comment
comment|/**  * xge_init_params  * Sets HAL parameter values (from kenv).  *  * @dconfig Device Configuration  * @dev Device Handle  */
end_comment

begin_function
name|void
name|xge_init_params
parameter_list|(
name|xge_hal_device_config_t
modifier|*
name|dconfig
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|qindex
decl_stmt|,
name|tindex
decl_stmt|,
name|revision
decl_stmt|;
name|device_t
name|checkdev
decl_stmt|;
name|xge_lldev_t
modifier|*
name|lldev
init|=
operator|(
name|xge_lldev_t
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|dconfig
operator|->
name|mtu
operator|=
name|XGE_DEFAULT_INITIAL_MTU
expr_stmt|;
name|dconfig
operator|->
name|pci_freq_mherz
operator|=
name|XGE_DEFAULT_USER_HARDCODED
expr_stmt|;
name|dconfig
operator|->
name|device_poll_millis
operator|=
name|XGE_HAL_DEFAULT_DEVICE_POLL_MILLIS
expr_stmt|;
name|dconfig
operator|->
name|link_stability_period
operator|=
name|XGE_HAL_DEFAULT_LINK_STABILITY_PERIOD
expr_stmt|;
name|dconfig
operator|->
name|mac
operator|.
name|rmac_bcast_en
operator|=
name|XGE_DEFAULT_MAC_RMAC_BCAST_EN
expr_stmt|;
name|dconfig
operator|->
name|fifo
operator|.
name|alignment_size
operator|=
name|XGE_DEFAULT_FIFO_ALIGNMENT_SIZE
expr_stmt|;
name|XGE_GET_PARAM
argument_list|(
literal|"hw.xge.enable_tso"
argument_list|,
operator|(
operator|*
name|lldev
operator|)
argument_list|,
name|enabled_tso
argument_list|,
name|XGE_DEFAULT_ENABLED_TSO
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM
argument_list|(
literal|"hw.xge.enable_lro"
argument_list|,
operator|(
operator|*
name|lldev
operator|)
argument_list|,
name|enabled_lro
argument_list|,
name|XGE_DEFAULT_ENABLED_LRO
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM
argument_list|(
literal|"hw.xge.enable_msi"
argument_list|,
operator|(
operator|*
name|lldev
operator|)
argument_list|,
name|enabled_msi
argument_list|,
name|XGE_DEFAULT_ENABLED_MSI
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM
argument_list|(
literal|"hw.xge.latency_timer"
argument_list|,
operator|(
operator|*
name|dconfig
operator|)
argument_list|,
name|latency_timer
argument_list|,
name|XGE_DEFAULT_LATENCY_TIMER
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM
argument_list|(
literal|"hw.xge.max_splits_trans"
argument_list|,
operator|(
operator|*
name|dconfig
operator|)
argument_list|,
name|max_splits_trans
argument_list|,
name|XGE_DEFAULT_MAX_SPLITS_TRANS
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM
argument_list|(
literal|"hw.xge.mmrb_count"
argument_list|,
operator|(
operator|*
name|dconfig
operator|)
argument_list|,
name|mmrb_count
argument_list|,
name|XGE_DEFAULT_MMRB_COUNT
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM
argument_list|(
literal|"hw.xge.shared_splits"
argument_list|,
operator|(
operator|*
name|dconfig
operator|)
argument_list|,
name|shared_splits
argument_list|,
name|XGE_DEFAULT_SHARED_SPLITS
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM
argument_list|(
literal|"hw.xge.isr_polling_cnt"
argument_list|,
operator|(
operator|*
name|dconfig
operator|)
argument_list|,
name|isr_polling_cnt
argument_list|,
name|XGE_DEFAULT_ISR_POLLING_CNT
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM
argument_list|(
literal|"hw.xge.stats_refresh_time_sec"
argument_list|,
operator|(
operator|*
name|dconfig
operator|)
argument_list|,
name|stats_refresh_time_sec
argument_list|,
name|XGE_DEFAULT_STATS_REFRESH_TIME_SEC
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM_MAC
argument_list|(
literal|"hw.xge.mac_tmac_util_period"
argument_list|,
name|tmac_util_period
argument_list|,
name|XGE_DEFAULT_MAC_TMAC_UTIL_PERIOD
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM_MAC
argument_list|(
literal|"hw.xge.mac_rmac_util_period"
argument_list|,
name|rmac_util_period
argument_list|,
name|XGE_DEFAULT_MAC_RMAC_UTIL_PERIOD
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM_MAC
argument_list|(
literal|"hw.xge.mac_rmac_pause_gen_en"
argument_list|,
name|rmac_pause_gen_en
argument_list|,
name|XGE_DEFAULT_MAC_RMAC_PAUSE_GEN_EN
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM_MAC
argument_list|(
literal|"hw.xge.mac_rmac_pause_rcv_en"
argument_list|,
name|rmac_pause_rcv_en
argument_list|,
name|XGE_DEFAULT_MAC_RMAC_PAUSE_RCV_EN
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM_MAC
argument_list|(
literal|"hw.xge.mac_rmac_pause_time"
argument_list|,
name|rmac_pause_time
argument_list|,
name|XGE_DEFAULT_MAC_RMAC_PAUSE_TIME
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM_MAC
argument_list|(
literal|"hw.xge.mac_mc_pause_threshold_q0q3"
argument_list|,
name|mc_pause_threshold_q0q3
argument_list|,
name|XGE_DEFAULT_MAC_MC_PAUSE_THRESHOLD_Q0Q3
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM_MAC
argument_list|(
literal|"hw.xge.mac_mc_pause_threshold_q4q7"
argument_list|,
name|mc_pause_threshold_q4q7
argument_list|,
name|XGE_DEFAULT_MAC_MC_PAUSE_THRESHOLD_Q4Q7
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM_FIFO
argument_list|(
literal|"hw.xge.fifo_memblock_size"
argument_list|,
name|memblock_size
argument_list|,
name|XGE_DEFAULT_FIFO_MEMBLOCK_SIZE
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM_FIFO
argument_list|(
literal|"hw.xge.fifo_reserve_threshold"
argument_list|,
name|reserve_threshold
argument_list|,
name|XGE_DEFAULT_FIFO_RESERVE_THRESHOLD
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM_FIFO
argument_list|(
literal|"hw.xge.fifo_max_frags"
argument_list|,
name|max_frags
argument_list|,
name|XGE_DEFAULT_FIFO_MAX_FRAGS
argument_list|)
expr_stmt|;
for|for
control|(
name|qindex
operator|=
literal|0
init|;
name|qindex
operator|<
name|XGE_FIFO_COUNT
condition|;
name|qindex
operator|++
control|)
block|{
name|XGE_GET_PARAM_FIFO_QUEUE
argument_list|(
literal|"hw.xge.fifo_queue_intr"
argument_list|,
name|intr
argument_list|,
name|qindex
argument_list|,
name|XGE_DEFAULT_FIFO_QUEUE_INTR
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM_FIFO_QUEUE
argument_list|(
literal|"hw.xge.fifo_queue_max"
argument_list|,
name|max
argument_list|,
name|qindex
argument_list|,
name|XGE_DEFAULT_FIFO_QUEUE_MAX
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM_FIFO_QUEUE
argument_list|(
literal|"hw.xge.fifo_queue_initial"
argument_list|,
name|initial
argument_list|,
name|qindex
argument_list|,
name|XGE_DEFAULT_FIFO_QUEUE_INITIAL
argument_list|)
expr_stmt|;
for|for
control|(
name|tindex
operator|=
literal|0
init|;
name|tindex
operator|<
name|XGE_HAL_MAX_FIFO_TTI_NUM
condition|;
name|tindex
operator|++
control|)
block|{
name|dconfig
operator|->
name|fifo
operator|.
name|queue
index|[
name|qindex
index|]
operator|.
name|tti
index|[
name|tindex
index|]
operator|.
name|enabled
operator|=
literal|1
expr_stmt|;
name|dconfig
operator|->
name|fifo
operator|.
name|queue
index|[
name|qindex
index|]
operator|.
name|configured
operator|=
literal|1
expr_stmt|;
name|XGE_GET_PARAM_FIFO_QUEUE_TTI
argument_list|(
literal|"hw.xge.fifo_queue_tti_urange_a"
argument_list|,
name|urange_a
argument_list|,
name|qindex
argument_list|,
name|tindex
argument_list|,
name|XGE_DEFAULT_FIFO_QUEUE_TTI_URANGE_A
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM_FIFO_QUEUE_TTI
argument_list|(
literal|"hw.xge.fifo_queue_tti_urange_b"
argument_list|,
name|urange_b
argument_list|,
name|qindex
argument_list|,
name|tindex
argument_list|,
name|XGE_DEFAULT_FIFO_QUEUE_TTI_URANGE_B
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM_FIFO_QUEUE_TTI
argument_list|(
literal|"hw.xge.fifo_queue_tti_urange_c"
argument_list|,
name|urange_c
argument_list|,
name|qindex
argument_list|,
name|tindex
argument_list|,
name|XGE_DEFAULT_FIFO_QUEUE_TTI_URANGE_C
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM_FIFO_QUEUE_TTI
argument_list|(
literal|"hw.xge.fifo_queue_tti_ufc_a"
argument_list|,
name|ufc_a
argument_list|,
name|qindex
argument_list|,
name|tindex
argument_list|,
name|XGE_DEFAULT_FIFO_QUEUE_TTI_UFC_A
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM_FIFO_QUEUE_TTI
argument_list|(
literal|"hw.xge.fifo_queue_tti_ufc_b"
argument_list|,
name|ufc_b
argument_list|,
name|qindex
argument_list|,
name|tindex
argument_list|,
name|XGE_DEFAULT_FIFO_QUEUE_TTI_UFC_B
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM_FIFO_QUEUE_TTI
argument_list|(
literal|"hw.xge.fifo_queue_tti_ufc_c"
argument_list|,
name|ufc_c
argument_list|,
name|qindex
argument_list|,
name|tindex
argument_list|,
name|XGE_DEFAULT_FIFO_QUEUE_TTI_UFC_C
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM_FIFO_QUEUE_TTI
argument_list|(
literal|"hw.xge.fifo_queue_tti_ufc_d"
argument_list|,
name|ufc_d
argument_list|,
name|qindex
argument_list|,
name|tindex
argument_list|,
name|XGE_DEFAULT_FIFO_QUEUE_TTI_UFC_D
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM_FIFO_QUEUE_TTI
argument_list|(
literal|"hw.xge.fifo_queue_tti_timer_ci_en"
argument_list|,
name|timer_ci_en
argument_list|,
name|qindex
argument_list|,
name|tindex
argument_list|,
name|XGE_DEFAULT_FIFO_QUEUE_TTI_TIMER_CI_EN
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM_FIFO_QUEUE_TTI
argument_list|(
literal|"hw.xge.fifo_queue_tti_timer_ac_en"
argument_list|,
name|timer_ac_en
argument_list|,
name|qindex
argument_list|,
name|tindex
argument_list|,
name|XGE_DEFAULT_FIFO_QUEUE_TTI_TIMER_AC_EN
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM_FIFO_QUEUE_TTI
argument_list|(
literal|"hw.xge.fifo_queue_tti_timer_val_us"
argument_list|,
name|timer_val_us
argument_list|,
name|qindex
argument_list|,
name|tindex
argument_list|,
name|XGE_DEFAULT_FIFO_QUEUE_TTI_TIMER_VAL_US
argument_list|)
expr_stmt|;
block|}
block|}
name|XGE_GET_PARAM_RING
argument_list|(
literal|"hw.xge.ring_memblock_size"
argument_list|,
name|memblock_size
argument_list|,
name|XGE_DEFAULT_RING_MEMBLOCK_SIZE
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM_RING
argument_list|(
literal|"hw.xge.ring_strip_vlan_tag"
argument_list|,
name|strip_vlan_tag
argument_list|,
name|XGE_DEFAULT_RING_STRIP_VLAN_TAG
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM
argument_list|(
literal|"hw.xge.buffer_mode"
argument_list|,
operator|(
operator|*
name|lldev
operator|)
argument_list|,
name|buffer_mode
argument_list|,
name|XGE_DEFAULT_BUFFER_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lldev
operator|->
name|buffer_mode
operator|<
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_1
operator|)
operator|||
operator|(
name|lldev
operator|->
name|buffer_mode
operator|>
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_2
operator|)
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Supported buffer modes are 1 and 2"
argument_list|)
expr_stmt|;
name|lldev
operator|->
name|buffer_mode
operator|=
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_1
expr_stmt|;
block|}
for|for
control|(
name|qindex
operator|=
literal|0
init|;
name|qindex
operator|<
name|XGE_RING_COUNT
condition|;
name|qindex
operator|++
control|)
block|{
name|dconfig
operator|->
name|ring
operator|.
name|queue
index|[
name|qindex
index|]
operator|.
name|max_frm_len
operator|=
name|XGE_HAL_RING_USE_MTU
expr_stmt|;
name|dconfig
operator|->
name|ring
operator|.
name|queue
index|[
name|qindex
index|]
operator|.
name|priority
operator|=
literal|0
expr_stmt|;
name|dconfig
operator|->
name|ring
operator|.
name|queue
index|[
name|qindex
index|]
operator|.
name|configured
operator|=
literal|1
expr_stmt|;
name|dconfig
operator|->
name|ring
operator|.
name|queue
index|[
name|qindex
index|]
operator|.
name|buffer_mode
operator|=
operator|(
name|lldev
operator|->
name|buffer_mode
operator|==
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_2
operator|)
condition|?
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_3
else|:
name|lldev
operator|->
name|buffer_mode
expr_stmt|;
name|XGE_GET_PARAM_RING_QUEUE
argument_list|(
literal|"hw.xge.ring_queue_max"
argument_list|,
name|max
argument_list|,
name|qindex
argument_list|,
name|XGE_DEFAULT_RING_QUEUE_MAX
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM_RING_QUEUE
argument_list|(
literal|"hw.xge.ring_queue_initial"
argument_list|,
name|initial
argument_list|,
name|qindex
argument_list|,
name|XGE_DEFAULT_RING_QUEUE_INITIAL
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM_RING_QUEUE
argument_list|(
literal|"hw.xge.ring_queue_dram_size_mb"
argument_list|,
name|dram_size_mb
argument_list|,
name|qindex
argument_list|,
name|XGE_DEFAULT_RING_QUEUE_DRAM_SIZE_MB
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM_RING_QUEUE
argument_list|(
literal|"hw.xge.ring_queue_indicate_max_pkts"
argument_list|,
name|indicate_max_pkts
argument_list|,
name|qindex
argument_list|,
name|XGE_DEFAULT_RING_QUEUE_INDICATE_MAX_PKTS
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM_RING_QUEUE
argument_list|(
literal|"hw.xge.ring_queue_backoff_interval_us"
argument_list|,
name|backoff_interval_us
argument_list|,
name|qindex
argument_list|,
name|XGE_DEFAULT_RING_QUEUE_BACKOFF_INTERVAL_US
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM_RING_QUEUE_RTI
argument_list|(
literal|"hw.xge.ring_queue_rti_ufc_a"
argument_list|,
name|ufc_a
argument_list|,
name|qindex
argument_list|,
name|XGE_DEFAULT_RING_QUEUE_RTI_UFC_A
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM_RING_QUEUE_RTI
argument_list|(
literal|"hw.xge.ring_queue_rti_ufc_b"
argument_list|,
name|ufc_b
argument_list|,
name|qindex
argument_list|,
name|XGE_DEFAULT_RING_QUEUE_RTI_UFC_B
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM_RING_QUEUE_RTI
argument_list|(
literal|"hw.xge.ring_queue_rti_ufc_c"
argument_list|,
name|ufc_c
argument_list|,
name|qindex
argument_list|,
name|XGE_DEFAULT_RING_QUEUE_RTI_UFC_C
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM_RING_QUEUE_RTI
argument_list|(
literal|"hw.xge.ring_queue_rti_ufc_d"
argument_list|,
name|ufc_d
argument_list|,
name|qindex
argument_list|,
name|XGE_DEFAULT_RING_QUEUE_RTI_UFC_D
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM_RING_QUEUE_RTI
argument_list|(
literal|"hw.xge.ring_queue_rti_timer_ac_en"
argument_list|,
name|timer_ac_en
argument_list|,
name|qindex
argument_list|,
name|XGE_DEFAULT_RING_QUEUE_RTI_TIMER_AC_EN
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM_RING_QUEUE_RTI
argument_list|(
literal|"hw.xge.ring_queue_rti_timer_val_us"
argument_list|,
name|timer_val_us
argument_list|,
name|qindex
argument_list|,
name|XGE_DEFAULT_RING_QUEUE_RTI_TIMER_VAL_US
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM_RING_QUEUE_RTI
argument_list|(
literal|"hw.xge.ring_queue_rti_urange_a"
argument_list|,
name|urange_a
argument_list|,
name|qindex
argument_list|,
name|XGE_DEFAULT_RING_QUEUE_RTI_URANGE_A
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM_RING_QUEUE_RTI
argument_list|(
literal|"hw.xge.ring_queue_rti_urange_b"
argument_list|,
name|urange_b
argument_list|,
name|qindex
argument_list|,
name|XGE_DEFAULT_RING_QUEUE_RTI_URANGE_B
argument_list|)
expr_stmt|;
name|XGE_GET_PARAM_RING_QUEUE_RTI
argument_list|(
literal|"hw.xge.ring_queue_rti_urange_c"
argument_list|,
name|urange_c
argument_list|,
name|qindex
argument_list|,
name|XGE_DEFAULT_RING_QUEUE_RTI_URANGE_C
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dconfig
operator|->
name|fifo
operator|.
name|max_frags
operator|>
operator|(
name|PAGE_SIZE
operator|/
literal|32
operator|)
condition|)
block|{
name|xge_os_printf
argument_list|(
literal|"fifo_max_frags = %d"
argument_list|,
argument|dconfig->fifo.max_frags
argument_list|)
name|xge_os_printf
argument_list|(
literal|"fifo_max_frags should be<= (PAGE_SIZE / 32) = %d"
argument_list|,
argument|(int)(PAGE_SIZE /
literal|32
argument|)
argument_list|)
name|xge_os_printf
argument_list|(
literal|"Using fifo_max_frags = %d"
argument_list|,
argument|(int)(PAGE_SIZE /
literal|32
argument|)
argument_list|)
name|dconfig
operator|->
name|fifo
operator|.
name|max_frags
operator|=
operator|(
name|PAGE_SIZE
operator|/
literal|32
operator|)
expr_stmt|;
block|}
name|checkdev
operator|=
name|pci_find_device
argument_list|(
name|VENDOR_ID_AMD
argument_list|,
name|DEVICE_ID_8131_PCI_BRIDGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|checkdev
operator|!=
name|NULL
condition|)
block|{
comment|/* Check Revision for 0x12 */
name|revision
operator|=
name|pci_read_config
argument_list|(
name|checkdev
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_t
argument_list|,
name|revision
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|revision
operator|<=
literal|0x12
condition|)
block|{
comment|/* Set mmrb_count to 1k and max splits = 2 */
name|dconfig
operator|->
name|mmrb_count
operator|=
literal|1
expr_stmt|;
name|dconfig
operator|->
name|max_splits_trans
operator|=
name|XGE_HAL_THREE_SPLIT_TRANSACTION
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * xge_buffer_sizes_set  * Set buffer sizes based on Rx buffer mode  *  * @lldev Per-adapter Data  * @buffer_mode Rx Buffer Mode  */
end_comment

begin_function
name|void
name|xge_rx_buffer_sizes_set
parameter_list|(
name|xge_lldev_t
modifier|*
name|lldev
parameter_list|,
name|int
name|buffer_mode
parameter_list|,
name|int
name|mtu
parameter_list|)
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
name|int
name|frame_header
init|=
name|XGE_HAL_MAC_HEADER_MAX_SIZE
decl_stmt|;
name|int
name|buffer_size
init|=
name|mtu
operator|+
name|frame_header
decl_stmt|;
name|xge_os_memzero
argument_list|(
name|lldev
operator|->
name|rxd_mbuf_len
argument_list|,
sizeof|sizeof
argument_list|(
name|lldev
operator|->
name|rxd_mbuf_len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer_mode
operator|!=
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_5
condition|)
name|lldev
operator|->
name|rxd_mbuf_len
index|[
name|buffer_mode
operator|-
literal|1
index|]
operator|=
name|mtu
expr_stmt|;
name|lldev
operator|->
name|rxd_mbuf_len
index|[
literal|0
index|]
operator|=
operator|(
name|buffer_mode
operator|==
literal|1
operator|)
condition|?
name|buffer_size
else|:
name|frame_header
expr_stmt|;
if|if
condition|(
name|buffer_mode
operator|==
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_5
condition|)
name|lldev
operator|->
name|rxd_mbuf_len
index|[
literal|1
index|]
operator|=
name|XGE_HAL_TCPIP_HEADER_MAX_SIZE
expr_stmt|;
if|if
condition|(
name|buffer_mode
operator|==
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_5
condition|)
block|{
name|index
operator|=
literal|2
expr_stmt|;
name|buffer_size
operator|-=
name|XGE_HAL_TCPIP_HEADER_MAX_SIZE
expr_stmt|;
while|while
condition|(
name|buffer_size
operator|>
name|MJUMPAGESIZE
condition|)
block|{
name|lldev
operator|->
name|rxd_mbuf_len
index|[
name|index
operator|++
index|]
operator|=
name|MJUMPAGESIZE
expr_stmt|;
name|buffer_size
operator|-=
name|MJUMPAGESIZE
expr_stmt|;
block|}
name|XGE_ALIGN_TO
argument_list|(
name|buffer_size
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|lldev
operator|->
name|rxd_mbuf_len
index|[
name|index
index|]
operator|=
name|buffer_size
expr_stmt|;
name|lldev
operator|->
name|rxd_mbuf_cnt
operator|=
name|index
operator|+
literal|1
expr_stmt|;
block|}
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|buffer_mode
condition|;
name|index
operator|++
control|)
name|xge_trace
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"Buffer[%d] %d\n"
argument_list|,
name|index
argument_list|,
name|lldev
operator|->
name|rxd_mbuf_len
index|[
name|index
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * xge_buffer_mode_init  * Init Rx buffer mode  *  * @lldev Per-adapter Data  * @mtu Interface MTU  */
end_comment

begin_function
name|void
name|xge_buffer_mode_init
parameter_list|(
name|xge_lldev_t
modifier|*
name|lldev
parameter_list|,
name|int
name|mtu
parameter_list|)
block|{
name|int
name|index
init|=
literal|0
decl_stmt|,
name|buffer_size
init|=
literal|0
decl_stmt|;
name|xge_hal_ring_config_t
modifier|*
name|ring_config
init|=
operator|&
operator|(
operator|(
name|lldev
operator|->
name|devh
operator|)
operator|->
name|config
operator|.
name|ring
operator|)
decl_stmt|;
name|buffer_size
operator|=
name|mtu
operator|+
name|XGE_HAL_MAC_HEADER_MAX_SIZE
expr_stmt|;
if|if
condition|(
name|lldev
operator|->
name|enabled_lro
condition|)
operator|(
name|lldev
operator|->
name|ifnetp
operator|)
operator|->
name|if_capenable
operator||=
name|IFCAP_LRO
expr_stmt|;
else|else
operator|(
name|lldev
operator|->
name|ifnetp
operator|)
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_LRO
expr_stmt|;
name|lldev
operator|->
name|rxd_mbuf_cnt
operator|=
name|lldev
operator|->
name|buffer_mode
expr_stmt|;
if|if
condition|(
name|lldev
operator|->
name|buffer_mode
operator|==
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_2
condition|)
block|{
name|XGE_SET_BUFFER_MODE_IN_RINGS
argument_list|(
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_3
argument_list|)
expr_stmt|;
name|ring_config
operator|->
name|scatter_mode
operator|=
name|XGE_HAL_RING_QUEUE_SCATTER_MODE_B
expr_stmt|;
block|}
else|else
block|{
name|XGE_SET_BUFFER_MODE_IN_RINGS
argument_list|(
name|lldev
operator|->
name|buffer_mode
argument_list|)
expr_stmt|;
name|ring_config
operator|->
name|scatter_mode
operator|=
name|XGE_HAL_RING_QUEUE_SCATTER_MODE_A
expr_stmt|;
block|}
name|xge_rx_buffer_sizes_set
argument_list|(
name|lldev
argument_list|,
name|lldev
operator|->
name|buffer_mode
argument_list|,
name|mtu
argument_list|)
expr_stmt|;
name|xge_os_printf
argument_list|(
literal|"%s: TSO %s"
argument_list|,
name|device_get_nameunit
argument_list|(
name|lldev
operator|->
name|device
argument_list|)
argument_list|,
operator|(
operator|(
name|lldev
operator|->
name|enabled_tso
operator|)
condition|?
literal|"Enabled"
else|:
literal|"Disabled"
operator|)
argument_list|)
expr_stmt|;
name|xge_os_printf
argument_list|(
literal|"%s: LRO %s"
argument_list|,
name|device_get_nameunit
argument_list|(
name|lldev
operator|->
name|device
argument_list|)
argument_list|,
operator|(
operator|(
name|lldev
operator|->
name|ifnetp
operator|)
operator|->
name|if_capenable
operator|&
name|IFCAP_LRO
operator|)
condition|?
literal|"Enabled"
else|:
literal|"Disabled"
argument_list|)
expr_stmt|;
name|xge_os_printf
argument_list|(
literal|"%s: Rx %d Buffer Mode Enabled"
argument_list|,
name|device_get_nameunit
argument_list|(
name|lldev
operator|->
name|device
argument_list|)
argument_list|,
name|lldev
operator|->
name|buffer_mode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * xge_driver_initialize  * Initializes HAL driver (common for all devices)  *  * Returns  * XGE_HAL_OK if success  * XGE_HAL_ERR_BAD_DRIVER_CONFIG if driver configuration parameters are invalid  */
end_comment

begin_function
name|int
name|xge_driver_initialize
parameter_list|(
name|void
parameter_list|)
block|{
name|xge_hal_uld_cbs_t
name|uld_callbacks
decl_stmt|;
name|xge_hal_driver_config_t
name|driver_config
decl_stmt|;
name|xge_hal_status_e
name|status
init|=
name|XGE_HAL_OK
decl_stmt|;
comment|/* Initialize HAL driver */
if|if
condition|(
operator|!
name|hal_driver_init_count
condition|)
block|{
name|xge_os_memzero
argument_list|(
operator|&
name|uld_callbacks
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_uld_cbs_t
argument_list|)
argument_list|)
expr_stmt|;
name|xge_os_memzero
argument_list|(
operator|&
name|driver_config
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_driver_config_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	     * Initial and maximum size of the queue used to store the events 	     * like Link up/down (xge_hal_event_e) 	     */
name|driver_config
operator|.
name|queue_size_initial
operator|=
name|XGE_HAL_MIN_QUEUE_SIZE_INITIAL
expr_stmt|;
name|driver_config
operator|.
name|queue_size_max
operator|=
name|XGE_HAL_MAX_QUEUE_SIZE_MAX
expr_stmt|;
name|uld_callbacks
operator|.
name|link_up
operator|=
name|xge_callback_link_up
expr_stmt|;
name|uld_callbacks
operator|.
name|link_down
operator|=
name|xge_callback_link_down
expr_stmt|;
name|uld_callbacks
operator|.
name|crit_err
operator|=
name|xge_callback_crit_err
expr_stmt|;
name|uld_callbacks
operator|.
name|event
operator|=
name|xge_callback_event
expr_stmt|;
name|status
operator|=
name|xge_hal_driver_initialize
argument_list|(
operator|&
name|driver_config
argument_list|,
operator|&
name|uld_callbacks
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|XGE_EXIT_ON_ERR
argument_list|(
literal|"xgeX: Initialization of HAL driver failed"
argument_list|,
name|xdi_out
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
name|hal_driver_init_count
operator|=
name|hal_driver_init_count
operator|+
literal|1
expr_stmt|;
name|xge_hal_driver_debug_module_mask_set
argument_list|(
literal|0xffffffff
argument_list|)
expr_stmt|;
name|xge_hal_driver_debug_level_set
argument_list|(
name|XGE_TRACE
argument_list|)
expr_stmt|;
name|xdi_out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * xge_media_init  * Initializes, adds and sets media  *  * @devc Device Handle  */
end_comment

begin_function
name|void
name|xge_media_init
parameter_list|(
name|device_t
name|devc
parameter_list|)
block|{
name|xge_lldev_t
modifier|*
name|lldev
init|=
operator|(
name|xge_lldev_t
operator|*
operator|)
name|device_get_softc
argument_list|(
name|devc
argument_list|)
decl_stmt|;
comment|/* Initialize Media */
name|ifmedia_init
argument_list|(
operator|&
name|lldev
operator|->
name|media
argument_list|,
name|IFM_IMASK
argument_list|,
name|xge_ifmedia_change
argument_list|,
name|xge_ifmedia_status
argument_list|)
expr_stmt|;
comment|/* Add supported media */
name|ifmedia_add
argument_list|(
operator|&
name|lldev
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_SX
operator||
name|IFM_FDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|lldev
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_SX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|lldev
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|lldev
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_SR
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|lldev
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_LR
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Set media */
name|ifmedia_set
argument_list|(
operator|&
name|lldev
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * xge_pci_space_save  * Save PCI configuration space  *  * @dev Device Handle  */
end_comment

begin_function
name|void
name|xge_pci_space_save
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|NULL
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|xge_trace
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"Saving PCI configuration space"
argument_list|)
expr_stmt|;
name|pci_cfg_save
argument_list|(
name|dev
argument_list|,
name|dinfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * xge_pci_space_restore  * Restore saved PCI configuration space  *  * @dev Device Handle  */
end_comment

begin_function
name|void
name|xge_pci_space_restore
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
init|=
name|NULL
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|xge_trace
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"Restoring PCI configuration space"
argument_list|)
expr_stmt|;
name|pci_cfg_restore
argument_list|(
name|dev
argument_list|,
name|dinfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * xge_msi_info_save  * Save MSI info  *  * @lldev Per-adapter Data  */
end_comment

begin_function
name|void
name|xge_msi_info_save
parameter_list|(
name|xge_lldev_t
modifier|*
name|lldev
parameter_list|)
block|{
name|xge_os_pci_read16
argument_list|(
name|lldev
operator|->
name|pdev
argument_list|,
name|NULL
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_le_t
argument_list|,
name|msi_control
argument_list|)
argument_list|,
operator|&
name|lldev
operator|->
name|msi_info
operator|.
name|msi_control
argument_list|)
expr_stmt|;
name|xge_os_pci_read32
argument_list|(
name|lldev
operator|->
name|pdev
argument_list|,
name|NULL
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_le_t
argument_list|,
name|msi_lower_address
argument_list|)
argument_list|,
operator|&
name|lldev
operator|->
name|msi_info
operator|.
name|msi_lower_address
argument_list|)
expr_stmt|;
name|xge_os_pci_read32
argument_list|(
name|lldev
operator|->
name|pdev
argument_list|,
name|NULL
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_le_t
argument_list|,
name|msi_higher_address
argument_list|)
argument_list|,
operator|&
name|lldev
operator|->
name|msi_info
operator|.
name|msi_higher_address
argument_list|)
expr_stmt|;
name|xge_os_pci_read16
argument_list|(
name|lldev
operator|->
name|pdev
argument_list|,
name|NULL
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_le_t
argument_list|,
name|msi_data
argument_list|)
argument_list|,
operator|&
name|lldev
operator|->
name|msi_info
operator|.
name|msi_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * xge_msi_info_restore  * Restore saved MSI info  *  * @dev Device Handle  */
end_comment

begin_function
name|void
name|xge_msi_info_restore
parameter_list|(
name|xge_lldev_t
modifier|*
name|lldev
parameter_list|)
block|{
comment|/* 	 * If interface is made down and up, traffic fails. It was observed that 	 * MSI information were getting reset on down. Restoring them. 	 */
name|xge_os_pci_write16
argument_list|(
name|lldev
operator|->
name|pdev
argument_list|,
name|NULL
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_le_t
argument_list|,
name|msi_control
argument_list|)
argument_list|,
name|lldev
operator|->
name|msi_info
operator|.
name|msi_control
argument_list|)
expr_stmt|;
name|xge_os_pci_write32
argument_list|(
name|lldev
operator|->
name|pdev
argument_list|,
name|NULL
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_le_t
argument_list|,
name|msi_lower_address
argument_list|)
argument_list|,
name|lldev
operator|->
name|msi_info
operator|.
name|msi_lower_address
argument_list|)
expr_stmt|;
name|xge_os_pci_write32
argument_list|(
name|lldev
operator|->
name|pdev
argument_list|,
name|NULL
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_le_t
argument_list|,
name|msi_higher_address
argument_list|)
argument_list|,
name|lldev
operator|->
name|msi_info
operator|.
name|msi_higher_address
argument_list|)
expr_stmt|;
name|xge_os_pci_write16
argument_list|(
name|lldev
operator|->
name|pdev
argument_list|,
name|NULL
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_le_t
argument_list|,
name|msi_data
argument_list|)
argument_list|,
name|lldev
operator|->
name|msi_info
operator|.
name|msi_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * xge_init_mutex  * Initializes mutexes used in driver  *  * @lldev  Per-adapter Data  */
end_comment

begin_function
name|void
name|xge_mutex_init
parameter_list|(
name|xge_lldev_t
modifier|*
name|lldev
parameter_list|)
block|{
name|int
name|qindex
decl_stmt|;
name|sprintf
argument_list|(
name|lldev
operator|->
name|mtx_name_drv
argument_list|,
literal|"%s_drv"
argument_list|,
name|device_get_nameunit
argument_list|(
name|lldev
operator|->
name|device
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|lldev
operator|->
name|mtx_drv
argument_list|,
name|lldev
operator|->
name|mtx_name_drv
argument_list|,
name|MTX_NETWORK_LOCK
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
for|for
control|(
name|qindex
operator|=
literal|0
init|;
name|qindex
operator|<
name|XGE_FIFO_COUNT
condition|;
name|qindex
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|lldev
operator|->
name|mtx_name_tx
index|[
name|qindex
index|]
argument_list|,
literal|"%s_tx_%d"
argument_list|,
name|device_get_nameunit
argument_list|(
name|lldev
operator|->
name|device
argument_list|)
argument_list|,
name|qindex
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|lldev
operator|->
name|mtx_tx
index|[
name|qindex
index|]
argument_list|,
name|lldev
operator|->
name|mtx_name_tx
index|[
name|qindex
index|]
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * xge_mutex_destroy  * Destroys mutexes used in driver  *  * @lldev Per-adapter Data  */
end_comment

begin_function
name|void
name|xge_mutex_destroy
parameter_list|(
name|xge_lldev_t
modifier|*
name|lldev
parameter_list|)
block|{
name|int
name|qindex
decl_stmt|;
for|for
control|(
name|qindex
operator|=
literal|0
init|;
name|qindex
operator|<
name|XGE_FIFO_COUNT
condition|;
name|qindex
operator|++
control|)
name|mtx_destroy
argument_list|(
operator|&
name|lldev
operator|->
name|mtx_tx
index|[
name|qindex
index|]
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|lldev
operator|->
name|mtx_drv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * xge_print_info  * Print device and driver information  *  * @lldev Per-adapter Data  */
end_comment

begin_function
name|void
name|xge_print_info
parameter_list|(
name|xge_lldev_t
modifier|*
name|lldev
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|lldev
operator|->
name|device
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
init|=
name|lldev
operator|->
name|devh
decl_stmt|;
name|xge_hal_status_e
name|status
init|=
name|XGE_HAL_OK
decl_stmt|;
name|u64
name|val64
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|xge_pci_bus_speeds
index|[
literal|17
index|]
init|=
block|{
literal|"PCI 33MHz Bus"
block|,
literal|"PCI 66MHz Bus"
block|,
literal|"PCIX(M1) 66MHz Bus"
block|,
literal|"PCIX(M1) 100MHz Bus"
block|,
literal|"PCIX(M1) 133MHz Bus"
block|,
literal|"PCIX(M2) 133MHz Bus"
block|,
literal|"PCIX(M2) 200MHz Bus"
block|,
literal|"PCIX(M2) 266MHz Bus"
block|,
literal|"PCIX(M1) Reserved"
block|,
literal|"PCIX(M1) 66MHz Bus (Not Supported)"
block|,
literal|"PCIX(M1) 100MHz Bus (Not Supported)"
block|,
literal|"PCIX(M1) 133MHz Bus (Not Supported)"
block|,
literal|"PCIX(M2) Reserved"
block|,
literal|"PCIX 533 Reserved"
block|,
literal|"PCI Basic Mode"
block|,
literal|"PCIX Basic Mode"
block|,
literal|"PCI Invalid Mode"
block|}
decl_stmt|;
name|xge_os_printf
argument_list|(
literal|"%s: Xframe%s %s Revision %d Driver v%s"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
operator|(
operator|(
name|hldev
operator|->
name|device_id
operator|==
name|XGE_PCI_DEVICE_ID_XENA_2
operator|)
condition|?
literal|"I"
else|:
literal|"II"
operator|)
argument_list|,
name|hldev
operator|->
name|vpd_data
operator|.
name|product_name
argument_list|,
name|hldev
operator|->
name|revision
argument_list|,
name|XGE_DRIVER_VERSION
argument_list|)
expr_stmt|;
name|xge_os_printf
argument_list|(
literal|"%s: Serial Number %s"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|hldev
operator|->
name|vpd_data
operator|.
name|serial_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|XGE_PCI_DEVICE_ID_HERC_2
condition|)
block|{
name|status
operator|=
name|xge_hal_mgmt_reg_read
argument_list|(
name|hldev
argument_list|,
literal|0
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_bar0_t
argument_list|,
name|pci_info
argument_list|)
argument_list|,
operator|&
name|val64
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Error for getting bus speed"
argument_list|)
expr_stmt|;
name|xge_os_printf
argument_list|(
literal|"%s: Adapter is on %s bit %s"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
operator|(
operator|(
name|val64
operator|&
name|BIT
argument_list|(
literal|8
argument_list|)
operator|)
condition|?
literal|"32"
else|:
literal|"64"
operator|)
argument_list|,
operator|(
name|xge_pci_bus_speeds
index|[
operator|(
operator|(
name|val64
operator|&
name|XGE_HAL_PCI_INFO
operator|)
operator|>>
literal|60
operator|)
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
name|xge_os_printf
argument_list|(
literal|"%s: Using %s Interrupts"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
operator|(
name|lldev
operator|->
name|enabled_msi
operator|==
name|XGE_HAL_INTR_MODE_MSI
operator|)
condition|?
literal|"MSI"
else|:
literal|"Line"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * xge_create_dma_tags  * Creates DMA tags for both Tx and Rx  *  * @dev Device Handle  *  * Returns XGE_HAL_OK or XGE_HAL_FAIL (if errors)  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_create_dma_tags
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|xge_lldev_t
modifier|*
name|lldev
init|=
operator|(
name|xge_lldev_t
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|xge_hal_status_e
name|status
init|=
name|XGE_HAL_FAIL
decl_stmt|;
name|int
name|mtu
init|=
operator|(
name|lldev
operator|->
name|ifnetp
operator|)
operator|->
name|if_mtu
decl_stmt|,
name|maxsize
decl_stmt|;
comment|/* DMA tag for Tx */
name|status
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
comment|/* Parent                    */
name|PAGE_SIZE
argument_list|,
comment|/* Alignment                 */
literal|0
argument_list|,
comment|/* Bounds                    */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* Low Address               */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* High Address              */
name|NULL
argument_list|,
comment|/* Filter Function           */
name|NULL
argument_list|,
comment|/* Filter Function Arguments */
name|MCLBYTES
operator|*
name|XGE_MAX_SEGS
argument_list|,
comment|/* Maximum Size              */
name|XGE_MAX_SEGS
argument_list|,
comment|/* Number of Segments        */
name|MCLBYTES
argument_list|,
comment|/* Maximum Segment Size      */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* Flags                     */
name|NULL
argument_list|,
comment|/* Lock Function             */
name|NULL
argument_list|,
comment|/* Lock Function Arguments   */
operator|(
operator|&
name|lldev
operator|->
name|dma_tag_tx
operator|)
argument_list|)
expr_stmt|;
comment|/* DMA Tag                   */
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
goto|goto
name|_exit
goto|;
name|maxsize
operator|=
name|mtu
operator|+
name|XGE_HAL_MAC_HEADER_MAX_SIZE
expr_stmt|;
if|if
condition|(
name|maxsize
operator|<=
name|MCLBYTES
condition|)
block|{
name|maxsize
operator|=
name|MCLBYTES
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|lldev
operator|->
name|buffer_mode
operator|==
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_5
condition|)
name|maxsize
operator|=
name|MJUMPAGESIZE
expr_stmt|;
else|else
name|maxsize
operator|=
operator|(
name|maxsize
operator|<=
name|MJUMPAGESIZE
operator|)
condition|?
name|MJUMPAGESIZE
else|:
name|MJUM9BYTES
expr_stmt|;
block|}
comment|/* DMA tag for Rx */
name|status
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
comment|/* Parent                    */
name|PAGE_SIZE
argument_list|,
comment|/* Alignment                 */
literal|0
argument_list|,
comment|/* Bounds                    */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* Low Address               */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* High Address              */
name|NULL
argument_list|,
comment|/* Filter Function           */
name|NULL
argument_list|,
comment|/* Filter Function Arguments */
name|maxsize
argument_list|,
comment|/* Maximum Size              */
literal|1
argument_list|,
comment|/* Number of Segments        */
name|maxsize
argument_list|,
comment|/* Maximum Segment Size      */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* Flags                     */
name|NULL
argument_list|,
comment|/* Lock Function             */
name|NULL
argument_list|,
comment|/* Lock Function Arguments   */
operator|(
operator|&
name|lldev
operator|->
name|dma_tag_rx
operator|)
argument_list|)
expr_stmt|;
comment|/* DMA Tag                   */
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
goto|goto
name|_exit1
goto|;
name|status
operator|=
name|bus_dmamap_create
argument_list|(
name|lldev
operator|->
name|dma_tag_rx
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|lldev
operator|->
name|extra_dma_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
goto|goto
name|_exit2
goto|;
name|status
operator|=
name|XGE_HAL_OK
expr_stmt|;
goto|goto
name|_exit
goto|;
name|_exit2
label|:
name|status
operator|=
name|bus_dma_tag_destroy
argument_list|(
name|lldev
operator|->
name|dma_tag_rx
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Rx DMA tag destroy failed"
argument_list|)
expr_stmt|;
name|_exit1
label|:
name|status
operator|=
name|bus_dma_tag_destroy
argument_list|(
name|lldev
operator|->
name|dma_tag_tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Tx DMA tag destroy failed"
argument_list|)
expr_stmt|;
name|status
operator|=
name|XGE_HAL_FAIL
expr_stmt|;
name|_exit
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * xge_confirm_changes  * Disables and Enables interface to apply requested change  *  * @lldev Per-adapter Data  * @mtu_set Is it called for changing MTU? (Yes: 1, No: 0)  *  * Returns 0 or Error Number  */
end_comment

begin_function
name|void
name|xge_confirm_changes
parameter_list|(
name|xge_lldev_t
modifier|*
name|lldev
parameter_list|,
name|xge_option_e
name|option
parameter_list|)
block|{
if|if
condition|(
name|lldev
operator|->
name|initialized
operator|==
literal|0
condition|)
goto|goto
name|_exit1
goto|;
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|mtx_drv
argument_list|)
expr_stmt|;
name|if_down
argument_list|(
name|lldev
operator|->
name|ifnetp
argument_list|)
expr_stmt|;
name|xge_device_stop
argument_list|(
name|lldev
argument_list|,
name|XGE_HAL_CHANNEL_OC_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|==
name|XGE_SET_MTU
condition|)
operator|(
name|lldev
operator|->
name|ifnetp
operator|)
operator|->
name|if_mtu
operator|=
name|lldev
operator|->
name|mtu
expr_stmt|;
else|else
name|xge_buffer_mode_init
argument_list|(
name|lldev
argument_list|,
name|lldev
operator|->
name|mtu
argument_list|)
expr_stmt|;
name|xge_device_init
argument_list|(
name|lldev
argument_list|,
name|XGE_HAL_CHANNEL_OC_NORMAL
argument_list|)
expr_stmt|;
name|if_up
argument_list|(
name|lldev
operator|->
name|ifnetp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|mtx_drv
argument_list|)
expr_stmt|;
goto|goto
name|_exit
goto|;
name|_exit1
label|:
comment|/* Request was to change MTU and device not initialized */
if|if
condition|(
name|option
operator|==
name|XGE_SET_MTU
condition|)
block|{
operator|(
name|lldev
operator|->
name|ifnetp
operator|)
operator|->
name|if_mtu
operator|=
name|lldev
operator|->
name|mtu
expr_stmt|;
name|xge_buffer_mode_init
argument_list|(
name|lldev
argument_list|,
name|lldev
operator|->
name|mtu
argument_list|)
expr_stmt|;
block|}
name|_exit
label|:
return|return;
block|}
end_function

begin_comment
comment|/**  * xge_change_lro_status  * Enable/Disable LRO feature  *  * @SYSCTL_HANDLER_ARGS sysctl_oid structure with arguments  *  * Returns 0 or error number.  */
end_comment

begin_function
specifier|static
name|int
name|xge_change_lro_status
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|xge_lldev_t
modifier|*
name|lldev
init|=
operator|(
name|xge_lldev_t
operator|*
operator|)
name|arg1
decl_stmt|;
name|int
name|request
init|=
name|lldev
operator|->
name|enabled_lro
decl_stmt|,
name|status
init|=
name|XGE_HAL_OK
decl_stmt|;
name|status
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|request
argument_list|,
name|arg2
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|!=
name|XGE_HAL_OK
operator|)
operator|||
operator|(
operator|!
name|req
operator|->
name|newptr
operator|)
condition|)
goto|goto
name|_exit
goto|;
if|if
condition|(
operator|(
name|request
operator|<
literal|0
operator|)
operator|||
operator|(
name|request
operator|>
literal|1
operator|)
condition|)
block|{
name|status
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|_exit
goto|;
block|}
comment|/* Return if current and requested states are same */
if|if
condition|(
name|request
operator|==
name|lldev
operator|->
name|enabled_lro
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"LRO is already %s"
argument_list|,
operator|(
operator|(
name|request
operator|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|_exit
goto|;
block|}
name|lldev
operator|->
name|enabled_lro
operator|=
name|request
expr_stmt|;
name|xge_confirm_changes
argument_list|(
name|lldev
argument_list|,
name|XGE_CHANGE_LRO
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|lldev
operator|->
name|enabled_lro
expr_stmt|;
name|_exit
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * xge_add_sysctl_handlers  * Registers sysctl parameter value update handlers  *  * @lldev Per-adapter data  */
end_comment

begin_function
name|void
name|xge_add_sysctl_handlers
parameter_list|(
name|xge_lldev_t
modifier|*
name|lldev
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|context_list
init|=
name|device_get_sysctl_ctx
argument_list|(
name|lldev
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|oid
init|=
name|device_get_sysctl_tree
argument_list|(
name|lldev
operator|->
name|device
argument_list|)
decl_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|context_list
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"enable_lro"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|lldev
argument_list|,
literal|0
argument_list|,
name|xge_change_lro_status
argument_list|,
literal|"I"
argument_list|,
literal|"Enable or disable LRO feature"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * xge_attach  * Connects driver to the system if probe was success  *  * @dev Device Handle  */
end_comment

begin_function
name|int
name|xge_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|xge_hal_device_config_t
modifier|*
name|device_config
decl_stmt|;
name|xge_hal_device_attr_t
name|attr
decl_stmt|;
name|xge_lldev_t
modifier|*
name|lldev
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
decl_stmt|;
name|xge_pci_info_t
modifier|*
name|pci_info
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifnetp
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|rid0
decl_stmt|,
name|rid1
decl_stmt|,
name|error
decl_stmt|;
name|int
name|msi_count
init|=
literal|0
decl_stmt|,
name|status
init|=
name|XGE_HAL_OK
decl_stmt|;
name|int
name|enable_msi
init|=
name|XGE_HAL_INTR_MODE_IRQLINE
decl_stmt|;
name|device_config
operator|=
name|xge_os_malloc
argument_list|(
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_device_config_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|device_config
condition|)
block|{
name|XGE_EXIT_ON_ERR
argument_list|(
literal|"Memory allocation for device configuration failed"
argument_list|,
name|attach_out_config
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
block|}
name|lldev
operator|=
operator|(
name|xge_lldev_t
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lldev
condition|)
block|{
name|XGE_EXIT_ON_ERR
argument_list|(
literal|"Adapter softc is NULL"
argument_list|,
name|attach_out
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
block|}
name|lldev
operator|->
name|device
operator|=
name|dev
expr_stmt|;
name|xge_mutex_init
argument_list|(
name|lldev
argument_list|)
expr_stmt|;
name|error
operator|=
name|xge_driver_initialize
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_resources_free
argument_list|(
name|dev
argument_list|,
name|xge_free_mutex
argument_list|)
expr_stmt|;
name|XGE_EXIT_ON_ERR
argument_list|(
literal|"Initializing driver failed"
argument_list|,
name|attach_out
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
block|}
comment|/* HAL device */
name|hldev
operator|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|xge_os_malloc
argument_list|(
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_device_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hldev
condition|)
block|{
name|xge_resources_free
argument_list|(
name|dev
argument_list|,
name|xge_free_terminate_hal_driver
argument_list|)
expr_stmt|;
name|XGE_EXIT_ON_ERR
argument_list|(
literal|"Memory allocation for HAL device failed"
argument_list|,
name|attach_out
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
block|}
name|lldev
operator|->
name|devh
operator|=
name|hldev
expr_stmt|;
comment|/* Our private structure */
name|pci_info
operator|=
operator|(
name|xge_pci_info_t
operator|*
operator|)
name|xge_os_malloc
argument_list|(
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_pci_info_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pci_info
condition|)
block|{
name|xge_resources_free
argument_list|(
name|dev
argument_list|,
name|xge_free_hal_device
argument_list|)
expr_stmt|;
name|XGE_EXIT_ON_ERR
argument_list|(
literal|"Memory allocation for PCI info. failed"
argument_list|,
name|attach_out
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
block|}
name|lldev
operator|->
name|pdev
operator|=
name|pci_info
expr_stmt|;
name|pci_info
operator|->
name|device
operator|=
name|dev
expr_stmt|;
comment|/* Set bus master */
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Get virtual address for BAR0 */
name|rid0
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|pci_info
operator|->
name|regmap0
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid0
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_info
operator|->
name|regmap0
operator|==
name|NULL
condition|)
block|{
name|xge_resources_free
argument_list|(
name|dev
argument_list|,
name|xge_free_pci_info
argument_list|)
expr_stmt|;
name|XGE_EXIT_ON_ERR
argument_list|(
literal|"Bus resource allocation for BAR0 failed"
argument_list|,
name|attach_out
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
block|}
name|attr
operator|.
name|bar0
operator|=
operator|(
name|char
operator|*
operator|)
name|pci_info
operator|->
name|regmap0
expr_stmt|;
name|pci_info
operator|->
name|bar0resource
operator|=
operator|(
name|xge_bus_resource_t
operator|*
operator|)
name|xge_os_malloc
argument_list|(
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_bus_resource_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_info
operator|->
name|bar0resource
operator|==
name|NULL
condition|)
block|{
name|xge_resources_free
argument_list|(
name|dev
argument_list|,
name|xge_free_bar0
argument_list|)
expr_stmt|;
name|XGE_EXIT_ON_ERR
argument_list|(
literal|"Memory allocation for BAR0 Resources failed"
argument_list|,
name|attach_out
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
block|}
operator|(
operator|(
name|xge_bus_resource_t
operator|*
operator|)
operator|(
name|pci_info
operator|->
name|bar0resource
operator|)
operator|)
operator|->
name|bus_tag
operator|=
name|rman_get_bustag
argument_list|(
name|pci_info
operator|->
name|regmap0
argument_list|)
expr_stmt|;
operator|(
operator|(
name|xge_bus_resource_t
operator|*
operator|)
operator|(
name|pci_info
operator|->
name|bar0resource
operator|)
operator|)
operator|->
name|bus_handle
operator|=
name|rman_get_bushandle
argument_list|(
name|pci_info
operator|->
name|regmap0
argument_list|)
expr_stmt|;
operator|(
operator|(
name|xge_bus_resource_t
operator|*
operator|)
operator|(
name|pci_info
operator|->
name|bar0resource
operator|)
operator|)
operator|->
name|bar_start_addr
operator|=
name|pci_info
operator|->
name|regmap0
expr_stmt|;
comment|/* Get virtual address for BAR1 */
name|rid1
operator|=
name|PCIR_BAR
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|pci_info
operator|->
name|regmap1
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_info
operator|->
name|regmap1
operator|==
name|NULL
condition|)
block|{
name|xge_resources_free
argument_list|(
name|dev
argument_list|,
name|xge_free_bar0_resource
argument_list|)
expr_stmt|;
name|XGE_EXIT_ON_ERR
argument_list|(
literal|"Bus resource allocation for BAR1 failed"
argument_list|,
name|attach_out
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
block|}
name|attr
operator|.
name|bar1
operator|=
operator|(
name|char
operator|*
operator|)
name|pci_info
operator|->
name|regmap1
expr_stmt|;
name|pci_info
operator|->
name|bar1resource
operator|=
operator|(
name|xge_bus_resource_t
operator|*
operator|)
name|xge_os_malloc
argument_list|(
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_bus_resource_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_info
operator|->
name|bar1resource
operator|==
name|NULL
condition|)
block|{
name|xge_resources_free
argument_list|(
name|dev
argument_list|,
name|xge_free_bar1
argument_list|)
expr_stmt|;
name|XGE_EXIT_ON_ERR
argument_list|(
literal|"Memory allocation for BAR1 Resources failed"
argument_list|,
name|attach_out
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
block|}
operator|(
operator|(
name|xge_bus_resource_t
operator|*
operator|)
operator|(
name|pci_info
operator|->
name|bar1resource
operator|)
operator|)
operator|->
name|bus_tag
operator|=
name|rman_get_bustag
argument_list|(
name|pci_info
operator|->
name|regmap1
argument_list|)
expr_stmt|;
operator|(
operator|(
name|xge_bus_resource_t
operator|*
operator|)
operator|(
name|pci_info
operator|->
name|bar1resource
operator|)
operator|)
operator|->
name|bus_handle
operator|=
name|rman_get_bushandle
argument_list|(
name|pci_info
operator|->
name|regmap1
argument_list|)
expr_stmt|;
operator|(
operator|(
name|xge_bus_resource_t
operator|*
operator|)
operator|(
name|pci_info
operator|->
name|bar1resource
operator|)
operator|)
operator|->
name|bar_start_addr
operator|=
name|pci_info
operator|->
name|regmap1
expr_stmt|;
comment|/* Save PCI config space */
name|xge_pci_space_save
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|attr
operator|.
name|regh0
operator|=
operator|(
name|xge_bus_resource_t
operator|*
operator|)
name|pci_info
operator|->
name|bar0resource
expr_stmt|;
name|attr
operator|.
name|regh1
operator|=
operator|(
name|xge_bus_resource_t
operator|*
operator|)
name|pci_info
operator|->
name|bar1resource
expr_stmt|;
name|attr
operator|.
name|irqh
operator|=
name|lldev
operator|->
name|irqhandle
expr_stmt|;
name|attr
operator|.
name|cfgh
operator|=
name|pci_info
expr_stmt|;
name|attr
operator|.
name|pdev
operator|=
name|pci_info
expr_stmt|;
comment|/* Initialize device configuration parameters */
name|xge_init_params
argument_list|(
name|device_config
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|rid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lldev
operator|->
name|enabled_msi
condition|)
block|{
comment|/* Number of MSI messages supported by device */
name|msi_count
operator|=
name|pci_msi_count
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|msi_count
operator|>
literal|1
condition|)
block|{
comment|/* Device supports MSI */
if|if
condition|(
name|bootverbose
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"MSI count: %d"
argument_list|,
name|msi_count
argument_list|)
expr_stmt|;
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Now, driver supporting 1 message"
argument_list|)
expr_stmt|;
block|}
name|msi_count
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|pci_alloc_msi
argument_list|(
name|dev
argument_list|,
operator|&
name|msi_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Allocated messages: %d"
argument_list|,
name|msi_count
argument_list|)
expr_stmt|;
name|enable_msi
operator|=
name|XGE_HAL_INTR_MODE_MSI
expr_stmt|;
name|rid
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bootverbose
condition|)
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"pci_alloc_msi failed, %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|lldev
operator|->
name|enabled_msi
operator|=
name|enable_msi
expr_stmt|;
comment|/* Allocate resource for irq */
name|lldev
operator|->
name|irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
operator|(
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lldev
operator|->
name|irq
operator|==
name|NULL
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Allocating irq resource for %s failed"
argument_list|,
operator|(
operator|(
name|rid
operator|==
literal|0
operator|)
condition|?
literal|"line interrupt"
else|:
literal|"MSI"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rid
operator|==
literal|1
condition|)
block|{
name|error
operator|=
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Releasing MSI resources failed %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Requires reboot to use MSI again"
argument_list|)
expr_stmt|;
block|}
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Trying line interrupts"
argument_list|)
expr_stmt|;
name|rid
operator|=
literal|0
expr_stmt|;
name|lldev
operator|->
name|enabled_msi
operator|=
name|XGE_HAL_INTR_MODE_IRQLINE
expr_stmt|;
name|lldev
operator|->
name|irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
operator|(
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lldev
operator|->
name|irq
operator|==
name|NULL
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Allocating irq resource failed"
argument_list|)
expr_stmt|;
name|xge_resources_free
argument_list|(
name|dev
argument_list|,
name|xge_free_bar1_resource
argument_list|)
expr_stmt|;
name|status
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|attach_out
goto|;
block|}
block|}
name|device_config
operator|->
name|intr_mode
operator|=
name|lldev
operator|->
name|enabled_msi
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"rid: %d, Mode: %d, MSI count: %d"
argument_list|,
name|rid
argument_list|,
name|lldev
operator|->
name|enabled_msi
argument_list|,
name|msi_count
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize HAL device */
name|error
operator|=
name|xge_hal_device_initialize
argument_list|(
name|hldev
argument_list|,
operator|&
name|attr
argument_list|,
name|device_config
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_resources_free
argument_list|(
name|dev
argument_list|,
name|xge_free_irq_resource
argument_list|)
expr_stmt|;
name|XGE_EXIT_ON_ERR
argument_list|(
literal|"Initializing HAL device failed"
argument_list|,
name|attach_out
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
block|}
name|xge_hal_device_private_set
argument_list|(
name|hldev
argument_list|,
name|lldev
argument_list|)
expr_stmt|;
name|error
operator|=
name|xge_interface_setup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|status
operator|=
name|error
expr_stmt|;
goto|goto
name|attach_out
goto|;
block|}
name|ifnetp
operator|=
name|lldev
operator|->
name|ifnetp
expr_stmt|;
name|ifnetp
operator|->
name|if_mtu
operator|=
name|device_config
operator|->
name|mtu
expr_stmt|;
name|xge_media_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Associate interrupt handler with the device */
if|if
condition|(
name|lldev
operator|->
name|enabled_msi
operator|==
name|XGE_HAL_INTR_MODE_MSI
condition|)
block|{
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|lldev
operator|->
name|irq
argument_list|,
operator|(
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
operator|)
argument_list|,
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|700030
name|NULL
argument_list|,
endif|#
directive|endif
name|xge_isr_msi
argument_list|,
name|lldev
argument_list|,
operator|&
name|lldev
operator|->
name|irqhandle
argument_list|)
expr_stmt|;
name|xge_msi_info_save
argument_list|(
name|lldev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|lldev
operator|->
name|irq
argument_list|,
operator|(
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
operator|)
argument_list|,
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|700030
name|xge_isr_filter
argument_list|,
endif|#
directive|endif
name|xge_isr_line
argument_list|,
name|lldev
argument_list|,
operator|&
name|lldev
operator|->
name|irqhandle
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|xge_resources_free
argument_list|(
name|dev
argument_list|,
name|xge_free_media_interface
argument_list|)
expr_stmt|;
name|XGE_EXIT_ON_ERR
argument_list|(
literal|"Associating interrupt handler with device failed"
argument_list|,
name|attach_out
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
block|}
name|xge_print_info
argument_list|(
name|lldev
argument_list|)
expr_stmt|;
name|xge_add_sysctl_handlers
argument_list|(
name|lldev
argument_list|)
expr_stmt|;
name|xge_buffer_mode_init
argument_list|(
name|lldev
argument_list|,
name|device_config
operator|->
name|mtu
argument_list|)
expr_stmt|;
name|attach_out
label|:
name|xge_os_free
argument_list|(
name|NULL
argument_list|,
name|device_config
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_device_config_t
argument_list|)
argument_list|)
expr_stmt|;
name|attach_out_config
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * xge_resources_free  * Undo what-all we did during load/attach  *  * @dev Device Handle  * @error Identifies what-all to undo  */
end_comment

begin_function
name|void
name|xge_resources_free
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|xge_lables_e
name|error
parameter_list|)
block|{
name|xge_lldev_t
modifier|*
name|lldev
decl_stmt|;
name|xge_pci_info_t
modifier|*
name|pci_info
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|status
decl_stmt|;
comment|/* LL Device */
name|lldev
operator|=
operator|(
name|xge_lldev_t
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_info
operator|=
name|lldev
operator|->
name|pdev
expr_stmt|;
comment|/* HAL Device */
name|hldev
operator|=
name|lldev
operator|->
name|devh
expr_stmt|;
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|xge_free_all
case|:
comment|/* Teardown interrupt handler - device association */
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|lldev
operator|->
name|irq
argument_list|,
name|lldev
operator|->
name|irqhandle
argument_list|)
expr_stmt|;
case|case
name|xge_free_media_interface
case|:
comment|/* Media */
name|ifmedia_removeall
argument_list|(
operator|&
name|lldev
operator|->
name|media
argument_list|)
expr_stmt|;
comment|/* Detach Ether */
name|ether_ifdetach
argument_list|(
name|lldev
operator|->
name|ifnetp
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|lldev
operator|->
name|ifnetp
argument_list|)
expr_stmt|;
name|xge_hal_device_private_set
argument_list|(
name|hldev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xge_hal_device_disable
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
case|case
name|xge_free_terminate_hal_device
case|:
comment|/* HAL Device */
name|xge_hal_device_terminate
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
case|case
name|xge_free_irq_resource
case|:
comment|/* Release IRQ resource */
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|(
operator|(
name|lldev
operator|->
name|enabled_msi
operator|==
name|XGE_HAL_INTR_MODE_IRQLINE
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
argument_list|,
name|lldev
operator|->
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|lldev
operator|->
name|enabled_msi
operator|==
name|XGE_HAL_INTR_MODE_MSI
condition|)
block|{
name|status
operator|=
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"pci_release_msi returned %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
block|}
case|case
name|xge_free_bar1_resource
case|:
comment|/* Restore PCI configuration space */
name|xge_pci_space_restore
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Free bar1resource */
name|xge_os_free
argument_list|(
name|NULL
argument_list|,
name|pci_info
operator|->
name|bar1resource
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_bus_resource_t
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|xge_free_bar1
case|:
comment|/* Release BAR1 */
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rid
argument_list|,
name|pci_info
operator|->
name|regmap1
argument_list|)
expr_stmt|;
case|case
name|xge_free_bar0_resource
case|:
comment|/* Free bar0resource */
name|xge_os_free
argument_list|(
name|NULL
argument_list|,
name|pci_info
operator|->
name|bar0resource
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_bus_resource_t
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|xge_free_bar0
case|:
comment|/* Release BAR0 */
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rid
argument_list|,
name|pci_info
operator|->
name|regmap0
argument_list|)
expr_stmt|;
case|case
name|xge_free_pci_info
case|:
comment|/* Disable Bus Master */
name|pci_disable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Free pci_info_t */
name|lldev
operator|->
name|pdev
operator|=
name|NULL
expr_stmt|;
name|xge_os_free
argument_list|(
name|NULL
argument_list|,
name|pci_info
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_pci_info_t
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|xge_free_hal_device
case|:
comment|/* Free device configuration struct and HAL device */
name|xge_os_free
argument_list|(
name|NULL
argument_list|,
name|hldev
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_device_t
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|xge_free_terminate_hal_driver
case|:
comment|/* Terminate HAL driver */
name|hal_driver_init_count
operator|=
name|hal_driver_init_count
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|hal_driver_init_count
condition|)
block|{
name|xge_hal_driver_terminate
argument_list|()
expr_stmt|;
block|}
case|case
name|xge_free_mutex
case|:
name|xge_mutex_destroy
argument_list|(
name|lldev
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * xge_detach  * Detaches driver from the Kernel subsystem  *  * @dev Device Handle  */
end_comment

begin_function
name|int
name|xge_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|xge_lldev_t
modifier|*
name|lldev
init|=
operator|(
name|xge_lldev_t
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|lldev
operator|->
name|in_detach
operator|==
literal|0
condition|)
block|{
name|lldev
operator|->
name|in_detach
operator|=
literal|1
expr_stmt|;
name|xge_stop
argument_list|(
name|lldev
argument_list|)
expr_stmt|;
name|xge_resources_free
argument_list|(
name|dev
argument_list|,
name|xge_free_all
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * xge_shutdown  * To shutdown device before system shutdown  *  * @dev Device Handle  */
end_comment

begin_function
name|int
name|xge_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|xge_lldev_t
modifier|*
name|lldev
init|=
operator|(
name|xge_lldev_t
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|xge_stop
argument_list|(
name|lldev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * xge_interface_setup  * Setup interface  *  * @dev Device Handle  *  * Returns 0 on success, ENXIO/ENOMEM on failure  */
end_comment

begin_function
name|int
name|xge_interface_setup
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|u8
name|mcaddr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|xge_hal_status_e
name|status
decl_stmt|;
name|xge_lldev_t
modifier|*
name|lldev
init|=
operator|(
name|xge_lldev_t
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifnetp
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
init|=
name|lldev
operator|->
name|devh
decl_stmt|;
comment|/* Get the MAC address of the device */
name|status
operator|=
name|xge_hal_device_macaddr_get
argument_list|(
name|hldev
argument_list|,
literal|0
argument_list|,
operator|&
name|mcaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_resources_free
argument_list|(
name|dev
argument_list|,
name|xge_free_terminate_hal_device
argument_list|)
expr_stmt|;
name|XGE_EXIT_ON_ERR
argument_list|(
literal|"Getting MAC address failed"
argument_list|,
name|ifsetup_out
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
block|}
comment|/* Get interface ifnet structure for this Ether device */
name|ifnetp
operator|=
name|lldev
operator|->
name|ifnetp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifnetp
operator|==
name|NULL
condition|)
block|{
name|xge_resources_free
argument_list|(
name|dev
argument_list|,
name|xge_free_terminate_hal_device
argument_list|)
expr_stmt|;
name|XGE_EXIT_ON_ERR
argument_list|(
literal|"Allocation ifnet failed"
argument_list|,
name|ifsetup_out
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize interface ifnet structure */
name|if_initname
argument_list|(
name|ifnetp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifnetp
operator|->
name|if_mtu
operator|=
name|XGE_HAL_DEFAULT_MTU
expr_stmt|;
name|ifnetp
operator|->
name|if_baudrate
operator|=
name|XGE_BAUDRATE
expr_stmt|;
name|ifnetp
operator|->
name|if_init
operator|=
name|xge_init
expr_stmt|;
name|ifnetp
operator|->
name|if_softc
operator|=
name|lldev
expr_stmt|;
name|ifnetp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifnetp
operator|->
name|if_ioctl
operator|=
name|xge_ioctl
expr_stmt|;
name|ifnetp
operator|->
name|if_start
operator|=
name|xge_send
expr_stmt|;
comment|/* TODO: Check and assign optimal value */
name|ifnetp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|ifnetp
operator|->
name|if_capabilities
operator|=
name|IFCAP_VLAN_HWTAGGING
operator||
name|IFCAP_VLAN_MTU
operator||
name|IFCAP_HWCSUM
expr_stmt|;
if|if
condition|(
name|lldev
operator|->
name|enabled_tso
condition|)
name|ifnetp
operator|->
name|if_capabilities
operator||=
name|IFCAP_TSO4
expr_stmt|;
if|if
condition|(
name|lldev
operator|->
name|enabled_lro
condition|)
name|ifnetp
operator|->
name|if_capabilities
operator||=
name|IFCAP_LRO
expr_stmt|;
name|ifnetp
operator|->
name|if_capenable
operator|=
name|ifnetp
operator|->
name|if_capabilities
expr_stmt|;
comment|/* Attach the interface */
name|ether_ifattach
argument_list|(
name|ifnetp
argument_list|,
name|mcaddr
argument_list|)
expr_stmt|;
name|ifsetup_out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * xge_callback_link_up  * Callback for Link-up indication from HAL  *  * @userdata Per-adapter data  */
end_comment

begin_function
name|void
name|xge_callback_link_up
parameter_list|(
name|void
modifier|*
name|userdata
parameter_list|)
block|{
name|xge_lldev_t
modifier|*
name|lldev
init|=
operator|(
name|xge_lldev_t
operator|*
operator|)
name|userdata
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifnetp
init|=
name|lldev
operator|->
name|ifnetp
decl_stmt|;
name|ifnetp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifnetp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * xge_callback_link_down  * Callback for Link-down indication from HAL  *  * @userdata Per-adapter data  */
end_comment

begin_function
name|void
name|xge_callback_link_down
parameter_list|(
name|void
modifier|*
name|userdata
parameter_list|)
block|{
name|xge_lldev_t
modifier|*
name|lldev
init|=
operator|(
name|xge_lldev_t
operator|*
operator|)
name|userdata
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifnetp
init|=
name|lldev
operator|->
name|ifnetp
decl_stmt|;
name|ifnetp
operator|->
name|if_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifnetp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * xge_callback_crit_err  * Callback for Critical error indication from HAL  *  * @userdata Per-adapter data  * @type Event type (Enumerated hardware error)  * @serr_data Hardware status  */
end_comment

begin_function
name|void
name|xge_callback_crit_err
parameter_list|(
name|void
modifier|*
name|userdata
parameter_list|,
name|xge_hal_event_e
name|type
parameter_list|,
name|u64
name|serr_data
parameter_list|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Critical Error"
argument_list|)
expr_stmt|;
name|xge_reset
argument_list|(
name|userdata
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * xge_callback_event  * Callback from HAL indicating that some event has been queued  *  * @item Queued event item  */
end_comment

begin_function
name|void
name|xge_callback_event
parameter_list|(
name|xge_queue_item_t
modifier|*
name|item
parameter_list|)
block|{
name|xge_lldev_t
modifier|*
name|lldev
init|=
name|NULL
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
init|=
name|NULL
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifnetp
init|=
name|NULL
decl_stmt|;
name|hldev
operator|=
name|item
operator|->
name|context
expr_stmt|;
name|lldev
operator|=
name|xge_hal_device_private
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
name|ifnetp
operator|=
name|lldev
operator|->
name|ifnetp
expr_stmt|;
switch|switch
condition|(
name|item
operator|->
name|event_type
condition|)
block|{
case|case
name|XGE_LL_EVENT_TRY_XMIT_AGAIN
case|:
if|if
condition|(
name|lldev
operator|->
name|initialized
condition|)
block|{
if|if
condition|(
name|xge_hal_channel_dtr_count
argument_list|(
name|lldev
operator|->
name|fifo_channel
index|[
literal|0
index|]
argument_list|)
operator|>
literal|0
condition|)
block|{
name|ifnetp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
block|}
else|else
block|{
name|xge_queue_produce_context
argument_list|(
name|xge_hal_device_queue
argument_list|(
name|lldev
operator|->
name|devh
argument_list|)
argument_list|,
name|XGE_LL_EVENT_TRY_XMIT_AGAIN
argument_list|,
name|lldev
operator|->
name|devh
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|XGE_LL_EVENT_DEVICE_RESETTING
case|:
name|xge_reset
argument_list|(
name|item
operator|->
name|context
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/**  * xge_ifmedia_change  * Media change driver callback  *  * @ifnetp Interface Handle  *  * Returns 0 if media is Ether else EINVAL  */
end_comment

begin_function
name|int
name|xge_ifmedia_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifnetp
parameter_list|)
block|{
name|xge_lldev_t
modifier|*
name|lldev
init|=
name|ifnetp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifmedia
modifier|*
name|ifmediap
init|=
operator|&
name|lldev
operator|->
name|media
decl_stmt|;
return|return
operator|(
name|IFM_TYPE
argument_list|(
name|ifmediap
operator|->
name|ifm_media
argument_list|)
operator|!=
name|IFM_ETHER
operator|)
condition|?
name|EINVAL
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * xge_ifmedia_status  * Media status driver callback  *  * @ifnetp Interface Handle  * @ifmr Interface Media Settings  */
end_comment

begin_function
name|void
name|xge_ifmedia_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifnetp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|xge_hal_status_e
name|status
decl_stmt|;
name|u64
name|regvalue
decl_stmt|;
name|xge_lldev_t
modifier|*
name|lldev
init|=
name|ifnetp
operator|->
name|if_softc
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
init|=
name|lldev
operator|->
name|devh
decl_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
expr_stmt|;
name|status
operator|=
name|xge_hal_mgmt_reg_read
argument_list|(
name|hldev
argument_list|,
literal|0
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_bar0_t
argument_list|,
name|adapter_status
argument_list|)
argument_list|,
operator|&
name|regvalue
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"Getting adapter status failed"
argument_list|)
expr_stmt|;
goto|goto
name|_exit
goto|;
block|}
if|if
condition|(
operator|(
name|regvalue
operator|&
operator|(
name|XGE_HAL_ADAPTER_STATUS_RMAC_REMOTE_FAULT
operator||
name|XGE_HAL_ADAPTER_STATUS_RMAC_LOCAL_FAULT
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_SR
operator||
name|IFM_FDX
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifnetp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|if_link_state_change
argument_list|(
name|ifnetp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
block|}
name|_exit
label|:
return|return;
block|}
end_function

begin_comment
comment|/**  * xge_ioctl_stats  * IOCTL to get statistics  *  * @lldev Per-adapter data  * @ifreqp Interface request  */
end_comment

begin_function
name|int
name|xge_ioctl_stats
parameter_list|(
name|xge_lldev_t
modifier|*
name|lldev
parameter_list|,
name|struct
name|ifreq
modifier|*
name|ifreqp
parameter_list|)
block|{
name|xge_hal_status_e
name|status
init|=
name|XGE_HAL_OK
decl_stmt|;
name|char
modifier|*
name|data
init|=
operator|(
name|char
operator|*
operator|)
name|ifreqp
operator|->
name|ifr_data
decl_stmt|;
name|void
modifier|*
name|info
init|=
name|NULL
decl_stmt|;
name|int
name|retValue
init|=
name|EINVAL
decl_stmt|;
switch|switch
condition|(
operator|*
name|data
condition|)
block|{
case|case
name|XGE_QUERY_STATS
case|:
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|mtx_drv
argument_list|)
expr_stmt|;
name|status
operator|=
name|xge_hal_stats_hw
argument_list|(
name|lldev
operator|->
name|devh
argument_list|,
operator|(
name|xge_hal_stats_hw_info_t
operator|*
operator|*
operator|)
operator|&
name|info
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|mtx_drv
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|XGE_HAL_OK
condition|)
block|{
if|if
condition|(
name|copyout
argument_list|(
name|info
argument_list|,
name|ifreqp
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_stats_hw_info_t
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|retValue
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Getting statistics failed (Status: %d)"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|XGE_QUERY_PCICONF
case|:
name|info
operator|=
name|xge_os_malloc
argument_list|(
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_pci_config_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|!=
name|NULL
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|mtx_drv
argument_list|)
expr_stmt|;
name|status
operator|=
name|xge_hal_mgmt_pci_config
argument_list|(
name|lldev
operator|->
name|devh
argument_list|,
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_pci_config_t
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|mtx_drv
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|XGE_HAL_OK
condition|)
block|{
if|if
condition|(
name|copyout
argument_list|(
name|info
argument_list|,
name|ifreqp
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_pci_config_t
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|retValue
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Getting PCI configuration failed (%d)"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
name|xge_os_free
argument_list|(
name|NULL
argument_list|,
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_pci_config_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|XGE_QUERY_DEVSTATS
case|:
name|info
operator|=
name|xge_os_malloc
argument_list|(
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_stats_device_info_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|!=
name|NULL
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|mtx_drv
argument_list|)
expr_stmt|;
name|status
operator|=
name|xge_hal_mgmt_device_stats
argument_list|(
name|lldev
operator|->
name|devh
argument_list|,
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_stats_device_info_t
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|mtx_drv
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|XGE_HAL_OK
condition|)
block|{
if|if
condition|(
name|copyout
argument_list|(
name|info
argument_list|,
name|ifreqp
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_stats_device_info_t
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|retValue
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Getting device info failed (%d)"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
name|xge_os_free
argument_list|(
name|NULL
argument_list|,
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_stats_device_info_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|XGE_QUERY_SWSTATS
case|:
name|info
operator|=
name|xge_os_malloc
argument_list|(
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_stats_sw_err_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|!=
name|NULL
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|mtx_drv
argument_list|)
expr_stmt|;
name|status
operator|=
name|xge_hal_mgmt_sw_stats
argument_list|(
name|lldev
operator|->
name|devh
argument_list|,
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_stats_sw_err_t
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|mtx_drv
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|XGE_HAL_OK
condition|)
block|{
if|if
condition|(
name|copyout
argument_list|(
name|info
argument_list|,
name|ifreqp
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_stats_sw_err_t
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|retValue
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Getting tcode statistics failed (%d)"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
name|xge_os_free
argument_list|(
name|NULL
argument_list|,
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_stats_sw_err_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|XGE_QUERY_DRIVERSTATS
case|:
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|lldev
operator|->
name|driver_stats
argument_list|,
name|ifreqp
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_driver_stats_t
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|retValue
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Copyout of driver statistics failed (%d)"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|XGE_READ_VERSION
case|:
name|info
operator|=
name|xge_os_malloc
argument_list|(
name|NULL
argument_list|,
name|XGE_BUFFER_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|!=
name|NULL
condition|)
block|{
name|strcpy
argument_list|(
name|info
argument_list|,
name|XGE_DRIVER_VERSION
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyout
argument_list|(
name|info
argument_list|,
name|ifreqp
operator|->
name|ifr_data
argument_list|,
name|XGE_BUFFER_SIZE
argument_list|)
operator|==
literal|0
condition|)
name|retValue
operator|=
literal|0
expr_stmt|;
name|xge_os_free
argument_list|(
name|NULL
argument_list|,
name|info
argument_list|,
name|XGE_BUFFER_SIZE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|XGE_QUERY_DEVCONF
case|:
name|info
operator|=
name|xge_os_malloc
argument_list|(
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_device_config_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|!=
name|NULL
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|mtx_drv
argument_list|)
expr_stmt|;
name|status
operator|=
name|xge_hal_mgmt_device_config
argument_list|(
name|lldev
operator|->
name|devh
argument_list|,
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_device_config_t
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|mtx_drv
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|XGE_HAL_OK
condition|)
block|{
if|if
condition|(
name|copyout
argument_list|(
name|info
argument_list|,
name|ifreqp
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_device_config_t
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|retValue
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Getting devconfig failed (%d)"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
name|xge_os_free
argument_list|(
name|NULL
argument_list|,
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_device_config_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|XGE_QUERY_BUFFER_MODE
case|:
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|lldev
operator|->
name|buffer_mode
argument_list|,
name|ifreqp
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|retValue
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|XGE_SET_BUFFER_MODE_1
case|:
case|case
name|XGE_SET_BUFFER_MODE_2
case|:
case|case
name|XGE_SET_BUFFER_MODE_5
case|:
operator|*
name|data
operator|=
operator|(
operator|*
name|data
operator|==
name|XGE_SET_BUFFER_MODE_1
operator|)
condition|?
literal|'Y'
else|:
literal|'N'
expr_stmt|;
if|if
condition|(
name|copyout
argument_list|(
name|data
argument_list|,
name|ifreqp
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|retValue
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|xge_trace
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"Nothing is matching"
argument_list|)
expr_stmt|;
name|retValue
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
return|return
name|retValue
return|;
block|}
end_function

begin_comment
comment|/**  * xge_ioctl_registers  * IOCTL to get registers  *  * @lldev Per-adapter data  * @ifreqp Interface request  */
end_comment

begin_function
name|int
name|xge_ioctl_registers
parameter_list|(
name|xge_lldev_t
modifier|*
name|lldev
parameter_list|,
name|struct
name|ifreq
modifier|*
name|ifreqp
parameter_list|)
block|{
name|xge_register_t
modifier|*
name|data
init|=
operator|(
name|xge_register_t
operator|*
operator|)
name|ifreqp
operator|->
name|ifr_data
decl_stmt|;
name|xge_hal_status_e
name|status
init|=
name|XGE_HAL_OK
decl_stmt|;
name|int
name|retValue
init|=
name|EINVAL
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|,
name|index
init|=
literal|0
decl_stmt|;
name|u64
name|val64
init|=
literal|0
decl_stmt|;
comment|/* Reading a register */
if|if
condition|(
name|strcmp
argument_list|(
name|data
operator|->
name|option
argument_list|,
literal|"-r"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|data
operator|->
name|value
operator|=
literal|0x0000
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|mtx_drv
argument_list|)
expr_stmt|;
name|status
operator|=
name|xge_hal_mgmt_reg_read
argument_list|(
name|lldev
operator|->
name|devh
argument_list|,
literal|0
argument_list|,
name|data
operator|->
name|offset
argument_list|,
operator|&
name|data
operator|->
name|value
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|mtx_drv
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|XGE_HAL_OK
condition|)
block|{
if|if
condition|(
name|copyout
argument_list|(
name|data
argument_list|,
name|ifreqp
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_register_t
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|retValue
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Writing to a register */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|data
operator|->
name|option
argument_list|,
literal|"-w"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|mtx_drv
argument_list|)
expr_stmt|;
name|status
operator|=
name|xge_hal_mgmt_reg_write
argument_list|(
name|lldev
operator|->
name|devh
argument_list|,
literal|0
argument_list|,
name|data
operator|->
name|offset
argument_list|,
name|data
operator|->
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|XGE_HAL_OK
condition|)
block|{
name|val64
operator|=
literal|0x0000
expr_stmt|;
name|status
operator|=
name|xge_hal_mgmt_reg_read
argument_list|(
name|lldev
operator|->
name|devh
argument_list|,
literal|0
argument_list|,
name|data
operator|->
name|offset
argument_list|,
operator|&
name|val64
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Reading back updated register failed"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|val64
operator|!=
name|data
operator|->
name|value
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Read and written register values mismatched"
argument_list|)
expr_stmt|;
block|}
else|else
name|retValue
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Getting register value failed"
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|mtx_drv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|mtx_drv
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
operator|,
name|offset
operator|=
literal|0
init|;
name|offset
operator|<=
name|XGE_OFFSET_OF_LAST_REG
condition|;
name|index
operator|++
operator|,
name|offset
operator|+=
literal|0x0008
control|)
block|{
name|val64
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|xge_hal_mgmt_reg_read
argument_list|(
name|lldev
operator|->
name|devh
argument_list|,
literal|0
argument_list|,
name|offset
argument_list|,
operator|&
name|val64
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Getting register value failed"
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
operator|(
operator|(
name|u64
operator|*
operator|)
operator|(
operator|(
name|u64
operator|*
operator|)
name|data
operator|+
name|index
operator|)
operator|)
operator|=
name|val64
expr_stmt|;
name|retValue
operator|=
literal|0
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|mtx_drv
argument_list|)
expr_stmt|;
if|if
condition|(
name|retValue
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|copyout
argument_list|(
name|data
argument_list|,
name|ifreqp
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_hal_pci_bar0_t
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Copyout of register values failed"
argument_list|)
expr_stmt|;
name|retValue
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
else|else
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Getting register values failed"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|retValue
return|;
block|}
end_function

begin_comment
comment|/**  * xge_ioctl  * Callback to control the device - Interface configuration  *  * @ifnetp Interface Handle  * @command Device control command  * @data Parameters associated with command (if any)  */
end_comment

begin_function
name|int
name|xge_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifnetp
parameter_list|,
name|unsigned
name|long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|ifreq
modifier|*
name|ifreqp
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|xge_lldev_t
modifier|*
name|lldev
init|=
name|ifnetp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifmedia
modifier|*
name|ifmediap
init|=
operator|&
name|lldev
operator|->
name|media
decl_stmt|;
name|int
name|retValue
init|=
literal|0
decl_stmt|,
name|mask
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|lldev
operator|->
name|in_detach
condition|)
block|{
return|return
name|retValue
return|;
block|}
switch|switch
condition|(
name|command
condition|)
block|{
comment|/* Set/Get ifnet address */
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
name|ether_ioctl
argument_list|(
name|ifnetp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
comment|/* Set ifnet MTU */
case|case
name|SIOCSIFMTU
case|:
name|retValue
operator|=
name|xge_change_mtu
argument_list|(
name|lldev
argument_list|,
name|ifreqp
operator|->
name|ifr_mtu
argument_list|)
expr_stmt|;
break|break;
comment|/* Set ifnet flags */
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
name|ifnetp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
comment|/* Link status is UP */
if|if
condition|(
operator|!
operator|(
name|ifnetp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|xge_init
argument_list|(
name|lldev
argument_list|)
expr_stmt|;
block|}
name|xge_disable_promisc
argument_list|(
name|lldev
argument_list|)
expr_stmt|;
name|xge_enable_promisc
argument_list|(
name|lldev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Link status is DOWN */
comment|/* If device is in running, make it down */
if|if
condition|(
name|ifnetp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|xge_stop
argument_list|(
name|lldev
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
comment|/* Add/delete multicast address */
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
if|if
condition|(
name|ifnetp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|xge_setmulti
argument_list|(
name|lldev
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Set/Get net media */
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|retValue
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifnetp
argument_list|,
name|ifreqp
argument_list|,
name|ifmediap
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
comment|/* Set capabilities */
case|case
name|SIOCSIFCAP
case|:
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|mtx_drv
argument_list|)
expr_stmt|;
name|mask
operator|=
name|ifreqp
operator|->
name|ifr_reqcap
operator|^
name|ifnetp
operator|->
name|if_capenable
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
if|if
condition|(
name|ifnetp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
name|ifnetp
operator|->
name|if_capenable
operator|&=
operator|~
operator|(
name|IFCAP_TSO4
operator||
name|IFCAP_TXCSUM
operator|)
expr_stmt|;
name|ifnetp
operator|->
name|if_hwassist
operator|&=
operator|~
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator||
name|CSUM_TSO
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ifnetp
operator|->
name|if_capenable
operator||=
name|IFCAP_TXCSUM
expr_stmt|;
name|ifnetp
operator|->
name|if_hwassist
operator||=
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO4
condition|)
block|{
if|if
condition|(
name|ifnetp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO4
condition|)
block|{
name|ifnetp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_TSO4
expr_stmt|;
name|ifnetp
operator|->
name|if_hwassist
operator|&=
operator|~
name|CSUM_TSO
expr_stmt|;
name|xge_os_printf
argument_list|(
literal|"%s: TSO Disabled"
argument_list|,
name|device_get_nameunit
argument_list|(
name|lldev
operator|->
name|device
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifnetp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
name|ifnetp
operator|->
name|if_capenable
operator||=
name|IFCAP_TSO4
expr_stmt|;
name|ifnetp
operator|->
name|if_hwassist
operator||=
name|CSUM_TSO
expr_stmt|;
name|xge_os_printf
argument_list|(
literal|"%s: TSO Enabled"
argument_list|,
name|device_get_nameunit
argument_list|(
name|lldev
operator|->
name|device
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|mtx_drv
argument_list|)
expr_stmt|;
break|break;
comment|/* Custom IOCTL 0 */
case|case
name|SIOCGPRIVATE_0
case|:
name|retValue
operator|=
name|xge_ioctl_stats
argument_list|(
name|lldev
argument_list|,
name|ifreqp
argument_list|)
expr_stmt|;
break|break;
comment|/* Custom IOCTL 1 */
case|case
name|SIOCGPRIVATE_1
case|:
name|retValue
operator|=
name|xge_ioctl_registers
argument_list|(
name|lldev
argument_list|,
name|ifreqp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|retValue
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|retValue
return|;
block|}
end_function

begin_comment
comment|/**  * xge_init  * Initialize the interface  *  * @plldev Per-adapter Data  */
end_comment

begin_function
name|void
name|xge_init
parameter_list|(
name|void
modifier|*
name|plldev
parameter_list|)
block|{
name|xge_lldev_t
modifier|*
name|lldev
init|=
operator|(
name|xge_lldev_t
operator|*
operator|)
name|plldev
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|mtx_drv
argument_list|)
expr_stmt|;
name|xge_os_memzero
argument_list|(
operator|&
name|lldev
operator|->
name|driver_stats
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_driver_stats_t
argument_list|)
argument_list|)
expr_stmt|;
name|xge_device_init
argument_list|(
name|lldev
argument_list|,
name|XGE_HAL_CHANNEL_OC_NORMAL
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|mtx_drv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * xge_device_init  * Initialize the interface (called by holding lock)  *  * @pdevin Per-adapter Data  */
end_comment

begin_function
name|void
name|xge_device_init
parameter_list|(
name|xge_lldev_t
modifier|*
name|lldev
parameter_list|,
name|xge_hal_channel_reopen_e
name|option
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifnetp
init|=
name|lldev
operator|->
name|ifnetp
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
init|=
name|lldev
operator|->
name|devh
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifaddrp
decl_stmt|;
name|unsigned
name|char
modifier|*
name|macaddr
decl_stmt|;
name|struct
name|sockaddr_dl
modifier|*
name|sockaddrp
decl_stmt|;
name|int
name|status
init|=
name|XGE_HAL_OK
decl_stmt|;
name|mtx_assert
argument_list|(
operator|(
operator|&
name|lldev
operator|->
name|mtx_drv
operator|)
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* If device is in running state, initializing is not required */
if|if
condition|(
name|ifnetp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
return|return;
comment|/* Initializing timer */
name|callout_init
argument_list|(
operator|&
name|lldev
operator|->
name|timer
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|xge_trace
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"Set MTU size"
argument_list|)
expr_stmt|;
name|status
operator|=
name|xge_hal_device_mtu_set
argument_list|(
name|hldev
argument_list|,
name|ifnetp
operator|->
name|if_mtu
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Setting MTU in HAL device failed"
argument_list|)
expr_stmt|;
goto|goto
name|_exit
goto|;
block|}
comment|/* Enable HAL device */
name|xge_hal_device_enable
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
comment|/* Get MAC address and update in HAL */
name|ifaddrp
operator|=
name|ifnetp
operator|->
name|if_addr
expr_stmt|;
name|sockaddrp
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifaddrp
operator|->
name|ifa_addr
expr_stmt|;
name|sockaddrp
operator|->
name|sdl_type
operator|=
name|IFT_ETHER
expr_stmt|;
name|sockaddrp
operator|->
name|sdl_alen
operator|=
name|ifnetp
operator|->
name|if_addrlen
expr_stmt|;
name|macaddr
operator|=
name|LLADDR
argument_list|(
name|sockaddrp
argument_list|)
expr_stmt|;
name|xge_trace
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"Setting MAC address: %02x:%02x:%02x:%02x:%02x:%02x\n"
argument_list|,
operator|*
name|macaddr
argument_list|,
operator|*
operator|(
name|macaddr
operator|+
literal|1
operator|)
argument_list|,
operator|*
operator|(
name|macaddr
operator|+
literal|2
operator|)
argument_list|,
operator|*
operator|(
name|macaddr
operator|+
literal|3
operator|)
argument_list|,
operator|*
operator|(
name|macaddr
operator|+
literal|4
operator|)
argument_list|,
operator|*
operator|(
name|macaddr
operator|+
literal|5
operator|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|xge_hal_device_macaddr_set
argument_list|(
name|hldev
argument_list|,
literal|0
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Setting MAC address failed (%d)"
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* Opening channels */
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|mtx_drv
argument_list|)
expr_stmt|;
name|status
operator|=
name|xge_channel_open
argument_list|(
name|lldev
argument_list|,
name|option
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|mtx_drv
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
goto|goto
name|_exit
goto|;
comment|/* Set appropriate flags */
name|ifnetp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifnetp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
comment|/* Checksum capability */
name|ifnetp
operator|->
name|if_hwassist
operator|=
operator|(
name|ifnetp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
operator|)
condition|?
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|lldev
operator|->
name|enabled_tso
operator|)
operator|&&
operator|(
name|ifnetp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO4
operator|)
condition|)
name|ifnetp
operator|->
name|if_hwassist
operator||=
name|CSUM_TSO
expr_stmt|;
comment|/* Enable interrupts */
name|xge_hal_device_intr_enable
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|lldev
operator|->
name|timer
argument_list|,
literal|10
operator|*
name|hz
argument_list|,
name|xge_timer
argument_list|,
name|lldev
argument_list|)
expr_stmt|;
comment|/* Disable promiscuous mode */
name|xge_trace
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"If opted, enable promiscuous mode"
argument_list|)
expr_stmt|;
name|xge_enable_promisc
argument_list|(
name|lldev
argument_list|)
expr_stmt|;
comment|/* Device is initialized */
name|lldev
operator|->
name|initialized
operator|=
literal|1
expr_stmt|;
name|xge_os_mdelay
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|_exit
label|:
return|return;
block|}
end_function

begin_comment
comment|/**  * xge_timer  * Timer timeout function to handle link status  *  * @devp Per-adapter Data  */
end_comment

begin_function
name|void
name|xge_timer
parameter_list|(
name|void
modifier|*
name|devp
parameter_list|)
block|{
name|xge_lldev_t
modifier|*
name|lldev
init|=
operator|(
name|xge_lldev_t
operator|*
operator|)
name|devp
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
init|=
name|lldev
operator|->
name|devh
decl_stmt|;
comment|/* Poll for changes */
name|xge_hal_device_poll
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
comment|/* Reset timer */
name|callout_reset
argument_list|(
operator|&
name|lldev
operator|->
name|timer
argument_list|,
name|hz
argument_list|,
name|xge_timer
argument_list|,
name|lldev
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**  * xge_stop  * De-activate the interface  *  * @lldev Per-adater Data  */
end_comment

begin_function
name|void
name|xge_stop
parameter_list|(
name|xge_lldev_t
modifier|*
name|lldev
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|mtx_drv
argument_list|)
expr_stmt|;
name|xge_device_stop
argument_list|(
name|lldev
argument_list|,
name|XGE_HAL_CHANNEL_OC_NORMAL
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|mtx_drv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * xge_isr_filter  * ISR filter function - to filter interrupts from other devices (shared)  *  * @handle Per-adapter Data  *  * Returns  * FILTER_STRAY if interrupt is from other device  * FILTER_SCHEDULE_THREAD if interrupt is from Xframe device  */
end_comment

begin_function
name|int
name|xge_isr_filter
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|)
block|{
name|xge_lldev_t
modifier|*
name|lldev
init|=
operator|(
name|xge_lldev_t
operator|*
operator|)
name|handle
decl_stmt|;
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
operator|(
operator|(
name|lldev
operator|->
name|devh
operator|)
operator|->
name|bar0
operator|)
decl_stmt|;
name|u16
name|retValue
init|=
name|FILTER_STRAY
decl_stmt|;
name|u64
name|val64
init|=
literal|0
decl_stmt|;
name|XGE_DRV_STATS
argument_list|(
name|isr_filter
argument_list|)
expr_stmt|;
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|lldev
operator|->
name|pdev
argument_list|,
operator|(
name|lldev
operator|->
name|devh
operator|)
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|general_int_status
argument_list|)
expr_stmt|;
name|retValue
operator|=
operator|(
operator|!
name|val64
operator|)
condition|?
name|FILTER_STRAY
else|:
name|FILTER_SCHEDULE_THREAD
expr_stmt|;
return|return
name|retValue
return|;
block|}
end_function

begin_comment
comment|/**  * xge_isr_line  * Interrupt service routine for Line interrupts  *  * @plldev Per-adapter Data  */
end_comment

begin_function
name|void
name|xge_isr_line
parameter_list|(
name|void
modifier|*
name|plldev
parameter_list|)
block|{
name|xge_hal_status_e
name|status
decl_stmt|;
name|xge_lldev_t
modifier|*
name|lldev
init|=
operator|(
name|xge_lldev_t
operator|*
operator|)
name|plldev
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|lldev
operator|->
name|devh
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifnetp
init|=
name|lldev
operator|->
name|ifnetp
decl_stmt|;
name|XGE_DRV_STATS
argument_list|(
name|isr_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifnetp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|status
operator|=
name|xge_hal_device_handle_irq
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifnetp
operator|->
name|if_snd
argument_list|)
operator|)
condition|)
name|xge_send
argument_list|(
name|ifnetp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * xge_isr_msi  * ISR for Message signaled interrupts  */
end_comment

begin_function
name|void
name|xge_isr_msi
parameter_list|(
name|void
modifier|*
name|plldev
parameter_list|)
block|{
name|xge_lldev_t
modifier|*
name|lldev
init|=
operator|(
name|xge_lldev_t
operator|*
operator|)
name|plldev
decl_stmt|;
name|XGE_DRV_STATS
argument_list|(
name|isr_msi
argument_list|)
expr_stmt|;
name|xge_hal_device_continue_irq
argument_list|(
name|lldev
operator|->
name|devh
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * xge_rx_open  * Initiate and open all Rx channels  *  * @qid Ring Index  * @lldev Per-adapter Data  * @rflag Channel open/close/reopen flag  *  * Returns 0 or Error Number  */
end_comment

begin_function
name|int
name|xge_rx_open
parameter_list|(
name|int
name|qid
parameter_list|,
name|xge_lldev_t
modifier|*
name|lldev
parameter_list|,
name|xge_hal_channel_reopen_e
name|rflag
parameter_list|)
block|{
name|u64
name|adapter_status
init|=
literal|0x0
decl_stmt|;
name|xge_hal_status_e
name|status
init|=
name|XGE_HAL_FAIL
decl_stmt|;
name|xge_hal_channel_attr_t
name|attr
init|=
block|{
operator|.
name|post_qid
operator|=
name|qid
block|,
operator|.
name|compl_qid
operator|=
literal|0
block|,
operator|.
name|callback
operator|=
name|xge_rx_compl
block|,
operator|.
name|per_dtr_space
operator|=
sizeof|sizeof
argument_list|(
name|xge_rx_priv_t
argument_list|)
block|,
operator|.
name|flags
operator|=
literal|0
block|,
operator|.
name|type
operator|=
name|XGE_HAL_CHANNEL_TYPE_RING
block|,
operator|.
name|userdata
operator|=
name|lldev
block|,
operator|.
name|dtr_init
operator|=
name|xge_rx_initial_replenish
block|,
operator|.
name|dtr_term
operator|=
name|xge_rx_term
block|}
decl_stmt|;
comment|/* If device is not ready, return */
name|status
operator|=
name|xge_hal_device_status
argument_list|(
name|lldev
operator|->
name|devh
argument_list|,
operator|&
name|adapter_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_os_printf
argument_list|(
literal|"Adapter Status: 0x%llx"
argument_list|,
operator|(
name|long
name|long
operator|)
name|adapter_status
argument_list|)
expr_stmt|;
name|XGE_EXIT_ON_ERR
argument_list|(
literal|"Device is not ready"
argument_list|,
name|_exit
argument_list|,
name|XGE_HAL_FAIL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|xge_hal_channel_open
argument_list|(
name|lldev
operator|->
name|devh
argument_list|,
operator|&
name|attr
argument_list|,
operator|&
name|lldev
operator|->
name|ring_channel
index|[
name|qid
index|]
argument_list|,
name|rflag
argument_list|)
expr_stmt|;
block|}
name|_exit
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * xge_tx_open  * Initialize and open all Tx channels  *  * @lldev Per-adapter Data  * @tflag Channel open/close/reopen flag  *  * Returns 0 or Error Number  */
end_comment

begin_function
name|int
name|xge_tx_open
parameter_list|(
name|xge_lldev_t
modifier|*
name|lldev
parameter_list|,
name|xge_hal_channel_reopen_e
name|tflag
parameter_list|)
block|{
name|xge_hal_status_e
name|status
init|=
name|XGE_HAL_FAIL
decl_stmt|;
name|u64
name|adapter_status
init|=
literal|0x0
decl_stmt|;
name|int
name|qindex
decl_stmt|,
name|index
decl_stmt|;
name|xge_hal_channel_attr_t
name|attr
init|=
block|{
operator|.
name|compl_qid
operator|=
literal|0
block|,
operator|.
name|callback
operator|=
name|xge_tx_compl
block|,
operator|.
name|per_dtr_space
operator|=
sizeof|sizeof
argument_list|(
name|xge_tx_priv_t
argument_list|)
block|,
operator|.
name|flags
operator|=
literal|0
block|,
operator|.
name|type
operator|=
name|XGE_HAL_CHANNEL_TYPE_FIFO
block|,
operator|.
name|userdata
operator|=
name|lldev
block|,
operator|.
name|dtr_init
operator|=
name|xge_tx_initial_replenish
block|,
operator|.
name|dtr_term
operator|=
name|xge_tx_term
block|}
decl_stmt|;
comment|/* If device is not ready, return */
name|status
operator|=
name|xge_hal_device_status
argument_list|(
name|lldev
operator|->
name|devh
argument_list|,
operator|&
name|adapter_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_os_printf
argument_list|(
literal|"Adapter Status: 0x%llx"
argument_list|,
operator|(
name|long
name|long
operator|)
name|adapter_status
argument_list|)
expr_stmt|;
name|XGE_EXIT_ON_ERR
argument_list|(
literal|"Device is not ready"
argument_list|,
name|_exit
argument_list|,
name|XGE_HAL_FAIL
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|qindex
operator|=
literal|0
init|;
name|qindex
operator|<
name|XGE_FIFO_COUNT
condition|;
name|qindex
operator|++
control|)
block|{
name|attr
operator|.
name|post_qid
operator|=
name|qindex
operator|,
name|status
operator|=
name|xge_hal_channel_open
argument_list|(
name|lldev
operator|->
name|devh
argument_list|,
operator|&
name|attr
argument_list|,
operator|&
name|lldev
operator|->
name|fifo_channel
index|[
name|qindex
index|]
argument_list|,
name|tflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
block|{
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|qindex
condition|;
name|index
operator|++
control|)
name|xge_hal_channel_close
argument_list|(
name|lldev
operator|->
name|fifo_channel
index|[
name|index
index|]
argument_list|,
name|tflag
argument_list|)
expr_stmt|;
block|}
block|}
name|_exit
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * xge_enable_msi  * Enables MSI  *  * @lldev Per-adapter Data  */
end_comment

begin_function
name|void
name|xge_enable_msi
parameter_list|(
name|xge_lldev_t
modifier|*
name|lldev
parameter_list|)
block|{
name|xge_list_t
modifier|*
name|item
init|=
name|NULL
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
init|=
name|lldev
operator|->
name|devh
decl_stmt|;
name|xge_hal_channel_t
modifier|*
name|channel
init|=
name|NULL
decl_stmt|;
name|u16
name|offset
init|=
literal|0
decl_stmt|,
name|val16
init|=
literal|0
decl_stmt|;
name|xge_os_pci_read16
argument_list|(
name|lldev
operator|->
name|pdev
argument_list|,
name|NULL
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_le_t
argument_list|,
name|msi_control
argument_list|)
argument_list|,
operator|&
name|val16
argument_list|)
expr_stmt|;
comment|/* Update msi_data */
name|offset
operator|=
operator|(
name|val16
operator|&
literal|0x80
operator|)
condition|?
literal|0x4c
else|:
literal|0x48
expr_stmt|;
name|xge_os_pci_read16
argument_list|(
name|lldev
operator|->
name|pdev
argument_list|,
name|NULL
argument_list|,
name|offset
argument_list|,
operator|&
name|val16
argument_list|)
expr_stmt|;
if|if
condition|(
name|val16
operator|&
literal|0x1
condition|)
name|val16
operator|&=
literal|0xfffe
expr_stmt|;
else|else
name|val16
operator||=
literal|0x1
expr_stmt|;
name|xge_os_pci_write16
argument_list|(
name|lldev
operator|->
name|pdev
argument_list|,
name|NULL
argument_list|,
name|offset
argument_list|,
name|val16
argument_list|)
expr_stmt|;
comment|/* Update msi_control */
name|xge_os_pci_read16
argument_list|(
name|lldev
operator|->
name|pdev
argument_list|,
name|NULL
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_le_t
argument_list|,
name|msi_control
argument_list|)
argument_list|,
operator|&
name|val16
argument_list|)
expr_stmt|;
name|val16
operator||=
literal|0x10
expr_stmt|;
name|xge_os_pci_write16
argument_list|(
name|lldev
operator|->
name|pdev
argument_list|,
name|NULL
argument_list|,
name|xge_offsetof
argument_list|(
name|xge_hal_pci_config_le_t
argument_list|,
name|msi_control
argument_list|)
argument_list|,
name|val16
argument_list|)
expr_stmt|;
comment|/* Set TxMAT and RxMAT registers with MSI */
name|xge_list_for_each
argument_list|(
argument|item
argument_list|,
argument|&hldev->free_channels
argument_list|)
block|{
name|channel
operator|=
name|xge_container_of
argument_list|(
name|item
argument_list|,
name|xge_hal_channel_t
argument_list|,
name|item
argument_list|)
expr_stmt|;
name|xge_hal_channel_msi_set
argument_list|(
name|channel
argument_list|,
literal|1
argument_list|,
operator|(
name|u32
operator|)
name|val16
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * xge_channel_open  * Open both Tx and Rx channels  *  * @lldev Per-adapter Data  * @option Channel reopen option  */
end_comment

begin_function
name|int
name|xge_channel_open
parameter_list|(
name|xge_lldev_t
modifier|*
name|lldev
parameter_list|,
name|xge_hal_channel_reopen_e
name|option
parameter_list|)
block|{
name|xge_lro_entry_t
modifier|*
name|lro_session
init|=
name|NULL
decl_stmt|;
name|xge_hal_status_e
name|status
init|=
name|XGE_HAL_OK
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|,
name|index2
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|lldev
operator|->
name|enabled_msi
operator|==
name|XGE_HAL_INTR_MODE_MSI
condition|)
block|{
name|xge_msi_info_restore
argument_list|(
name|lldev
argument_list|)
expr_stmt|;
name|xge_enable_msi
argument_list|(
name|lldev
argument_list|)
expr_stmt|;
block|}
name|_exit2
label|:
name|status
operator|=
name|xge_create_dma_tags
argument_list|(
name|lldev
operator|->
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
name|XGE_EXIT_ON_ERR
argument_list|(
literal|"DMA tag creation failed"
argument_list|,
name|_exit
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* Open ring (Rx) channel */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|XGE_RING_COUNT
condition|;
name|index
operator|++
control|)
block|{
name|status
operator|=
name|xge_rx_open
argument_list|(
name|index
argument_list|,
name|lldev
argument_list|,
name|option
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
block|{
comment|/* 	         * DMA mapping fails in the unpatched Kernel which can't 	         * allocate contiguous memory for Jumbo frames. 	         * Try using 5 buffer mode. 	         */
if|if
condition|(
operator|(
name|lldev
operator|->
name|buffer_mode
operator|==
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_1
operator|)
operator|&&
operator|(
operator|(
operator|(
name|lldev
operator|->
name|ifnetp
operator|)
operator|->
name|if_mtu
operator|+
name|XGE_HAL_MAC_HEADER_MAX_SIZE
operator|)
operator|>
name|MJUMPAGESIZE
operator|)
condition|)
block|{
comment|/* Close so far opened channels */
for|for
control|(
name|index2
operator|=
literal|0
init|;
name|index2
operator|<
name|index
condition|;
name|index2
operator|++
control|)
block|{
name|xge_hal_channel_close
argument_list|(
name|lldev
operator|->
name|ring_channel
index|[
name|index2
index|]
argument_list|,
name|option
argument_list|)
expr_stmt|;
block|}
comment|/* Destroy DMA tags intended to use for 1 buffer mode */
if|if
condition|(
name|bus_dmamap_destroy
argument_list|(
name|lldev
operator|->
name|dma_tag_rx
argument_list|,
name|lldev
operator|->
name|extra_dma_map
argument_list|)
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Rx extra DMA map destroy failed"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bus_dma_tag_destroy
argument_list|(
name|lldev
operator|->
name|dma_tag_rx
argument_list|)
condition|)
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Rx DMA tag destroy failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_destroy
argument_list|(
name|lldev
operator|->
name|dma_tag_tx
argument_list|)
condition|)
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Tx DMA tag destroy failed"
argument_list|)
expr_stmt|;
comment|/* Switch to 5 buffer mode */
name|lldev
operator|->
name|buffer_mode
operator|=
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_5
expr_stmt|;
name|xge_buffer_mode_init
argument_list|(
name|lldev
argument_list|,
operator|(
name|lldev
operator|->
name|ifnetp
operator|)
operator|->
name|if_mtu
argument_list|)
expr_stmt|;
comment|/* Restart init */
goto|goto
name|_exit2
goto|;
block|}
else|else
block|{
name|XGE_EXIT_ON_ERR
argument_list|(
literal|"Opening Rx channel failed"
argument_list|,
name|_exit1
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|lldev
operator|->
name|enabled_lro
condition|)
block|{
name|SLIST_INIT
argument_list|(
operator|&
name|lldev
operator|->
name|lro_free
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|lldev
operator|->
name|lro_active
argument_list|)
expr_stmt|;
name|lldev
operator|->
name|lro_num
operator|=
name|XGE_LRO_DEFAULT_ENTRIES
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|lldev
operator|->
name|lro_num
condition|;
name|index
operator|++
control|)
block|{
name|lro_session
operator|=
operator|(
name|xge_lro_entry_t
operator|*
operator|)
name|xge_os_malloc
argument_list|(
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
name|xge_lro_entry_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lro_session
operator|==
name|NULL
condition|)
block|{
name|lldev
operator|->
name|lro_num
operator|=
name|index
expr_stmt|;
break|break;
block|}
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|lldev
operator|->
name|lro_free
argument_list|,
name|lro_session
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Open FIFO (Tx) channel */
name|status
operator|=
name|xge_tx_open
argument_list|(
name|lldev
argument_list|,
name|option
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
name|XGE_EXIT_ON_ERR
argument_list|(
literal|"Opening Tx channel failed"
argument_list|,
name|_exit1
argument_list|,
name|status
argument_list|)
expr_stmt|;
goto|goto
name|_exit
goto|;
name|_exit1
label|:
comment|/* 	 * Opening Rx channel(s) failed (index is<last ring index - 1>) or 	 * Initialization of LRO failed (index is XGE_RING_COUNT) 	 * Opening Tx channel failed    (index is XGE_RING_COUNT) 	 */
for|for
control|(
name|index2
operator|=
literal|0
init|;
name|index2
operator|<
name|index
condition|;
name|index2
operator|++
control|)
name|xge_hal_channel_close
argument_list|(
name|lldev
operator|->
name|ring_channel
index|[
name|index2
index|]
argument_list|,
name|option
argument_list|)
expr_stmt|;
name|_exit
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * xge_channel_close  * Close both Tx and Rx channels  *  * @lldev Per-adapter Data  * @option Channel reopen option  *  */
end_comment

begin_function
name|void
name|xge_channel_close
parameter_list|(
name|xge_lldev_t
modifier|*
name|lldev
parameter_list|,
name|xge_hal_channel_reopen_e
name|option
parameter_list|)
block|{
name|int
name|qindex
init|=
literal|0
decl_stmt|;
name|DELAY
argument_list|(
literal|1000
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|/* Close FIFO (Tx) channel */
for|for
control|(
name|qindex
operator|=
literal|0
init|;
name|qindex
operator|<
name|XGE_FIFO_COUNT
condition|;
name|qindex
operator|++
control|)
name|xge_hal_channel_close
argument_list|(
name|lldev
operator|->
name|fifo_channel
index|[
name|qindex
index|]
argument_list|,
name|option
argument_list|)
expr_stmt|;
comment|/* Close Ring (Rx) channels */
for|for
control|(
name|qindex
operator|=
literal|0
init|;
name|qindex
operator|<
name|XGE_RING_COUNT
condition|;
name|qindex
operator|++
control|)
name|xge_hal_channel_close
argument_list|(
name|lldev
operator|->
name|ring_channel
index|[
name|qindex
index|]
argument_list|,
name|option
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dmamap_destroy
argument_list|(
name|lldev
operator|->
name|dma_tag_rx
argument_list|,
name|lldev
operator|->
name|extra_dma_map
argument_list|)
condition|)
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Rx extra map destroy failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_destroy
argument_list|(
name|lldev
operator|->
name|dma_tag_rx
argument_list|)
condition|)
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Rx DMA tag destroy failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_destroy
argument_list|(
name|lldev
operator|->
name|dma_tag_tx
argument_list|)
condition|)
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Tx DMA tag destroy failed"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * dmamap_cb  * DMA map callback  *  * @arg Parameter passed from dmamap  * @segs Segments  * @nseg Number of segments  * @error Error  */
end_comment

begin_function
name|void
name|dmamap_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
if|if
condition|(
operator|!
name|error
condition|)
block|{
operator|*
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * xge_reset  * Device Reset  *  * @lldev Per-adapter Data  */
end_comment

begin_function
name|void
name|xge_reset
parameter_list|(
name|xge_lldev_t
modifier|*
name|lldev
parameter_list|)
block|{
name|xge_trace
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"Reseting the chip"
argument_list|)
expr_stmt|;
comment|/* If the device is not initialized, return */
if|if
condition|(
name|lldev
operator|->
name|initialized
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|mtx_drv
argument_list|)
expr_stmt|;
name|xge_device_stop
argument_list|(
name|lldev
argument_list|,
name|XGE_HAL_CHANNEL_OC_NORMAL
argument_list|)
expr_stmt|;
name|xge_device_init
argument_list|(
name|lldev
argument_list|,
name|XGE_HAL_CHANNEL_OC_NORMAL
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|mtx_drv
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**  * xge_setmulti  * Set an address as a multicast address  *  * @lldev Per-adapter Data  */
end_comment

begin_function
name|void
name|xge_setmulti
parameter_list|(
name|xge_lldev_t
modifier|*
name|lldev
parameter_list|)
block|{
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|u8
modifier|*
name|lladdr
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
init|=
operator|(
name|xge_hal_device_t
operator|*
operator|)
name|lldev
operator|->
name|devh
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifnetp
init|=
name|lldev
operator|->
name|ifnetp
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
name|int
name|offset
init|=
literal|1
decl_stmt|;
name|int
name|table_size
init|=
literal|47
decl_stmt|;
name|xge_hal_status_e
name|status
init|=
name|XGE_HAL_OK
decl_stmt|;
name|u8
name|initial_addr
index|[]
init|=
block|{
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|}
decl_stmt|;
if|if
condition|(
operator|(
name|ifnetp
operator|->
name|if_flags
operator|&
name|IFF_MULTICAST
operator|)
operator|&&
operator|(
operator|!
name|lldev
operator|->
name|all_multicast
operator|)
condition|)
block|{
name|status
operator|=
name|xge_hal_device_mcast_enable
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
name|lldev
operator|->
name|all_multicast
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifnetp
operator|->
name|if_flags
operator|&
name|IFF_MULTICAST
operator|)
operator|&&
operator|(
name|lldev
operator|->
name|all_multicast
operator|)
condition|)
block|{
name|status
operator|=
name|xge_hal_device_mcast_disable
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
name|lldev
operator|->
name|all_multicast
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Enabling/disabling multicast failed"
argument_list|)
expr_stmt|;
goto|goto
name|_exit
goto|;
block|}
comment|/* Updating address list */
name|if_maddr_rlock
argument_list|(
name|ifnetp
argument_list|)
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifnetp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
block|{
continue|continue;
block|}
name|lladdr
operator|=
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
expr_stmt|;
name|index
operator|+=
literal|1
expr_stmt|;
block|}
name|if_maddr_runlock
argument_list|(
name|ifnetp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|lldev
operator|->
name|all_multicast
operator|)
operator|&&
operator|(
name|index
operator|)
condition|)
block|{
name|lldev
operator|->
name|macaddr_count
operator|=
operator|(
name|index
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|lldev
operator|->
name|macaddr_count
operator|>
name|table_size
condition|)
block|{
goto|goto
name|_exit
goto|;
block|}
comment|/* Clear old addresses */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
literal|48
condition|;
name|index
operator|++
control|)
block|{
name|xge_hal_device_macaddr_set
argument_list|(
name|hldev
argument_list|,
operator|(
name|offset
operator|+
name|index
operator|)
argument_list|,
name|initial_addr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Add new addresses */
name|if_maddr_rlock
argument_list|(
name|ifnetp
argument_list|)
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifnetp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
block|{
continue|continue;
block|}
name|lladdr
operator|=
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
expr_stmt|;
name|xge_hal_device_macaddr_set
argument_list|(
name|hldev
argument_list|,
operator|(
name|offset
operator|+
name|index
operator|)
argument_list|,
name|lladdr
argument_list|)
expr_stmt|;
name|index
operator|+=
literal|1
expr_stmt|;
block|}
name|if_maddr_runlock
argument_list|(
name|ifnetp
argument_list|)
expr_stmt|;
name|_exit
label|:
return|return;
block|}
end_function

begin_comment
comment|/**  * xge_enable_promisc  * Enable Promiscuous Mode  *  * @lldev Per-adapter Data  */
end_comment

begin_function
name|void
name|xge_enable_promisc
parameter_list|(
name|xge_lldev_t
modifier|*
name|lldev
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifnetp
init|=
name|lldev
operator|->
name|ifnetp
decl_stmt|;
name|xge_hal_device_t
modifier|*
name|hldev
init|=
name|lldev
operator|->
name|devh
decl_stmt|;
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
name|NULL
decl_stmt|;
name|u64
name|val64
init|=
literal|0
decl_stmt|;
name|bar0
operator|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
name|hldev
operator|->
name|bar0
expr_stmt|;
if|if
condition|(
name|ifnetp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|xge_hal_device_promisc_enable
argument_list|(
name|lldev
operator|->
name|devh
argument_list|)
expr_stmt|;
comment|/* 	     * When operating in promiscuous mode, don't strip the VLAN tag 	     */
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|lldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|rx_pa_cfg
argument_list|)
expr_stmt|;
name|val64
operator|&=
operator|~
name|XGE_HAL_RX_PA_CFG_STRIP_VLAN_TAG_MODE
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_RX_PA_CFG_STRIP_VLAN_TAG_MODE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|lldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_pa_cfg
argument_list|)
expr_stmt|;
name|xge_trace
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"Promiscuous mode ON"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * xge_disable_promisc  * Disable Promiscuous Mode  *  * @lldev Per-adapter Data  */
end_comment

begin_function
name|void
name|xge_disable_promisc
parameter_list|(
name|xge_lldev_t
modifier|*
name|lldev
parameter_list|)
block|{
name|xge_hal_device_t
modifier|*
name|hldev
init|=
name|lldev
operator|->
name|devh
decl_stmt|;
name|xge_hal_pci_bar0_t
modifier|*
name|bar0
init|=
name|NULL
decl_stmt|;
name|u64
name|val64
init|=
literal|0
decl_stmt|;
name|bar0
operator|=
operator|(
name|xge_hal_pci_bar0_t
operator|*
operator|)
name|hldev
operator|->
name|bar0
expr_stmt|;
name|xge_hal_device_promisc_disable
argument_list|(
name|lldev
operator|->
name|devh
argument_list|)
expr_stmt|;
comment|/* 	 * Strip VLAN tag when operating in non-promiscuous mode 	 */
name|val64
operator|=
name|xge_os_pio_mem_read64
argument_list|(
name|lldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
operator|&
name|bar0
operator|->
name|rx_pa_cfg
argument_list|)
expr_stmt|;
name|val64
operator|&=
operator|~
name|XGE_HAL_RX_PA_CFG_STRIP_VLAN_TAG_MODE
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|val64
operator||=
name|XGE_HAL_RX_PA_CFG_STRIP_VLAN_TAG_MODE
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|xge_os_pio_mem_write64
argument_list|(
name|lldev
operator|->
name|pdev
argument_list|,
name|hldev
operator|->
name|regh0
argument_list|,
name|val64
argument_list|,
operator|&
name|bar0
operator|->
name|rx_pa_cfg
argument_list|)
expr_stmt|;
name|xge_trace
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"Promiscuous mode OFF"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * xge_change_mtu  * Change interface MTU to a requested valid size  *  * @lldev Per-adapter Data  * @NewMtu Requested MTU  *  * Returns 0 or Error Number  */
end_comment

begin_function
name|int
name|xge_change_mtu
parameter_list|(
name|xge_lldev_t
modifier|*
name|lldev
parameter_list|,
name|int
name|new_mtu
parameter_list|)
block|{
name|int
name|status
init|=
name|XGE_HAL_OK
decl_stmt|;
comment|/* Check requested MTU size for boundary */
if|if
condition|(
name|xge_hal_device_mtu_check
argument_list|(
name|lldev
operator|->
name|devh
argument_list|,
name|new_mtu
argument_list|)
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|XGE_EXIT_ON_ERR
argument_list|(
literal|"Invalid MTU"
argument_list|,
name|_exit
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
block|}
name|lldev
operator|->
name|mtu
operator|=
name|new_mtu
expr_stmt|;
name|xge_confirm_changes
argument_list|(
name|lldev
argument_list|,
name|XGE_SET_MTU
argument_list|)
expr_stmt|;
name|_exit
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * xge_device_stop  *  * Common code for both stop and part of reset. Disables device, interrupts and  * closes channels  *  * @dev Device Handle  * @option Channel normal/reset option  */
end_comment

begin_function
name|void
name|xge_device_stop
parameter_list|(
name|xge_lldev_t
modifier|*
name|lldev
parameter_list|,
name|xge_hal_channel_reopen_e
name|option
parameter_list|)
block|{
name|xge_hal_device_t
modifier|*
name|hldev
init|=
name|lldev
operator|->
name|devh
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifnetp
init|=
name|lldev
operator|->
name|ifnetp
decl_stmt|;
name|u64
name|val64
init|=
literal|0
decl_stmt|;
name|mtx_assert
argument_list|(
operator|(
operator|&
name|lldev
operator|->
name|mtx_drv
operator|)
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* If device is not in "Running" state, return */
if|if
condition|(
operator|!
operator|(
name|ifnetp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
goto|goto
name|_exit
goto|;
comment|/* Set appropriate flags */
name|ifnetp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
comment|/* Stop timer */
name|callout_stop
argument_list|(
operator|&
name|lldev
operator|->
name|timer
argument_list|)
expr_stmt|;
comment|/* Disable interrupts */
name|xge_hal_device_intr_disable
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|mtx_drv
argument_list|)
expr_stmt|;
name|xge_queue_flush
argument_list|(
name|xge_hal_device_queue
argument_list|(
name|lldev
operator|->
name|devh
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|mtx_drv
argument_list|)
expr_stmt|;
comment|/* Disable HAL device */
if|if
condition|(
name|xge_hal_device_disable
argument_list|(
name|hldev
argument_list|)
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Disabling HAL device failed"
argument_list|)
expr_stmt|;
name|xge_hal_device_status
argument_list|(
name|hldev
argument_list|,
operator|&
name|val64
argument_list|)
expr_stmt|;
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Adapter Status: 0x%llx"
argument_list|,
operator|(
name|long
name|long
operator|)
name|val64
argument_list|)
expr_stmt|;
block|}
comment|/* Close Tx and Rx channels */
name|xge_channel_close
argument_list|(
name|lldev
argument_list|,
name|option
argument_list|)
expr_stmt|;
comment|/* Reset HAL device */
name|xge_hal_device_reset
argument_list|(
name|hldev
argument_list|)
expr_stmt|;
name|xge_os_mdelay
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|lldev
operator|->
name|initialized
operator|=
literal|0
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifnetp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
name|_exit
label|:
return|return;
block|}
end_function

begin_comment
comment|/**  * xge_set_mbuf_cflags  * set checksum flag for the mbuf  *  * @pkt Packet  */
end_comment

begin_function
name|void
name|xge_set_mbuf_cflags
parameter_list|(
name|mbuf_t
name|pkt
parameter_list|)
block|{
name|pkt
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
name|CSUM_IP_CHECKED
expr_stmt|;
name|pkt
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_IP_VALID
expr_stmt|;
name|pkt
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
operator|(
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
expr_stmt|;
name|pkt
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
name|htons
argument_list|(
literal|0xffff
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * xge_lro_flush_sessions  * Flush LRO session and send accumulated LRO packet to upper layer  *  * @lldev Per-adapter Data  */
end_comment

begin_function
name|void
name|xge_lro_flush_sessions
parameter_list|(
name|xge_lldev_t
modifier|*
name|lldev
parameter_list|)
block|{
name|xge_lro_entry_t
modifier|*
name|lro_session
init|=
name|NULL
decl_stmt|;
while|while
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|lldev
operator|->
name|lro_active
argument_list|)
condition|)
block|{
name|lro_session
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|lldev
operator|->
name|lro_active
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|lldev
operator|->
name|lro_active
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|xge_lro_flush
argument_list|(
name|lldev
argument_list|,
name|lro_session
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * xge_lro_flush  * Flush LRO session. Send accumulated LRO packet to upper layer  *  * @lldev Per-adapter Data  * @lro LRO session to be flushed  */
end_comment

begin_function
specifier|static
name|void
name|xge_lro_flush
parameter_list|(
name|xge_lldev_t
modifier|*
name|lldev
parameter_list|,
name|xge_lro_entry_t
modifier|*
name|lro_session
parameter_list|)
block|{
name|struct
name|ip
modifier|*
name|header_ip
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|header_tcp
decl_stmt|;
name|u32
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|lro_session
operator|->
name|append_cnt
condition|)
block|{
name|header_ip
operator|=
name|lro_session
operator|->
name|lro_header_ip
expr_stmt|;
name|header_ip
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|lro_session
operator|->
name|len
operator|-
name|ETHER_HDR_LEN
argument_list|)
expr_stmt|;
name|lro_session
operator|->
name|m_head
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|lro_session
operator|->
name|len
expr_stmt|;
name|header_tcp
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
name|header_ip
operator|+
literal|1
operator|)
expr_stmt|;
name|header_tcp
operator|->
name|th_ack
operator|=
name|lro_session
operator|->
name|ack_seq
expr_stmt|;
name|header_tcp
operator|->
name|th_win
operator|=
name|lro_session
operator|->
name|window
expr_stmt|;
if|if
condition|(
name|lro_session
operator|->
name|timestamp
condition|)
block|{
name|ptr
operator|=
operator|(
name|u32
operator|*
operator|)
operator|(
name|header_tcp
operator|+
literal|1
operator|)
expr_stmt|;
name|ptr
index|[
literal|1
index|]
operator|=
name|htonl
argument_list|(
name|lro_session
operator|->
name|tsval
argument_list|)
expr_stmt|;
name|ptr
index|[
literal|2
index|]
operator|=
name|lro_session
operator|->
name|tsecr
expr_stmt|;
block|}
block|}
call|(
modifier|*
name|lldev
operator|->
name|ifnetp
operator|->
name|if_input
call|)
argument_list|(
name|lldev
operator|->
name|ifnetp
argument_list|,
name|lro_session
operator|->
name|m_head
argument_list|)
expr_stmt|;
name|lro_session
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
name|lro_session
operator|->
name|timestamp
operator|=
literal|0
expr_stmt|;
name|lro_session
operator|->
name|append_cnt
operator|=
literal|0
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|lldev
operator|->
name|lro_free
argument_list|,
name|lro_session
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * xge_lro_accumulate  * Accumulate packets to form a large LRO packet based on various conditions  *  * @lldev Per-adapter Data  * @m_head Current Packet  *  * Returns XGE_HAL_OK or XGE_HAL_FAIL (failure)  */
end_comment

begin_function
specifier|static
name|int
name|xge_lro_accumulate
parameter_list|(
name|xge_lldev_t
modifier|*
name|lldev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m_head
parameter_list|)
block|{
name|struct
name|ether_header
modifier|*
name|header_ethernet
decl_stmt|;
name|struct
name|ip
modifier|*
name|header_ip
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|header_tcp
decl_stmt|;
name|u32
name|seq
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|buffer_next
decl_stmt|,
modifier|*
name|buffer_tail
decl_stmt|;
name|xge_lro_entry_t
modifier|*
name|lro_session
decl_stmt|;
name|xge_hal_status_e
name|status
init|=
name|XGE_HAL_FAIL
decl_stmt|;
name|int
name|hlen
decl_stmt|,
name|ip_len
decl_stmt|,
name|tcp_hdr_len
decl_stmt|,
name|tcp_data_len
decl_stmt|,
name|tot_len
decl_stmt|,
name|tcp_options
decl_stmt|;
name|int
name|trim
decl_stmt|;
comment|/* Get Ethernet header */
name|header_ethernet
operator|=
name|mtod
argument_list|(
name|m_head
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
comment|/* Return if it is not IP packet */
if|if
condition|(
name|header_ethernet
operator|->
name|ether_type
operator|!=
name|htons
argument_list|(
name|ETHERTYPE_IP
argument_list|)
condition|)
goto|goto
name|_exit
goto|;
comment|/* Get IP header */
name|header_ip
operator|=
name|lldev
operator|->
name|buffer_mode
operator|==
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_1
condition|?
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|header_ethernet
operator|+
literal|1
operator|)
else|:
name|mtod
argument_list|(
name|m_head
operator|->
name|m_next
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
comment|/* Return if it is not TCP packet */
if|if
condition|(
name|header_ip
operator|->
name|ip_p
operator|!=
name|IPPROTO_TCP
condition|)
goto|goto
name|_exit
goto|;
comment|/* Return if packet has options */
if|if
condition|(
operator|(
name|header_ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|header_ip
argument_list|)
condition|)
goto|goto
name|_exit
goto|;
comment|/* Return if packet is fragmented */
if|if
condition|(
name|header_ip
operator|->
name|ip_off
operator|&
name|htons
argument_list|(
name|IP_MF
operator||
name|IP_OFFMASK
argument_list|)
condition|)
goto|goto
name|_exit
goto|;
comment|/* Get TCP header */
name|header_tcp
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
name|header_ip
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* Return if not ACK or PUSH */
if|if
condition|(
operator|(
name|header_tcp
operator|->
name|th_flags
operator|&
operator|~
operator|(
name|TH_ACK
operator||
name|TH_PUSH
operator|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|_exit
goto|;
comment|/* Only timestamp option is handled */
name|tcp_options
operator|=
operator|(
name|header_tcp
operator|->
name|th_off
operator|<<
literal|2
operator|)
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|header_tcp
argument_list|)
expr_stmt|;
name|tcp_hdr_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|header_tcp
argument_list|)
operator|+
name|tcp_options
expr_stmt|;
name|ptr
operator|=
operator|(
name|u32
operator|*
operator|)
operator|(
name|header_tcp
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|tcp_options
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|__predict_false
argument_list|(
name|tcp_options
operator|!=
name|TCPOLEN_TSTAMP_APPA
argument_list|)
operator|||
operator|(
operator|*
name|ptr
operator|!=
name|ntohl
argument_list|(
name|TCPOPT_NOP
operator|<<
literal|24
operator||
name|TCPOPT_NOP
operator|<<
literal|16
operator||
name|TCPOPT_TIMESTAMP
operator|<<
literal|8
operator||
name|TCPOLEN_TIMESTAMP
argument_list|)
operator|)
condition|)
block|{
goto|goto
name|_exit
goto|;
block|}
block|}
comment|/* Total length of packet (IP) */
name|ip_len
operator|=
name|ntohs
argument_list|(
name|header_ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
comment|/* TCP data size */
name|tcp_data_len
operator|=
name|ip_len
operator|-
operator|(
name|header_tcp
operator|->
name|th_off
operator|<<
literal|2
operator|)
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|header_ip
argument_list|)
expr_stmt|;
comment|/* If the frame is padded, trim it */
name|tot_len
operator|=
name|m_head
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|trim
operator|=
name|tot_len
operator|-
operator|(
name|ip_len
operator|+
name|ETHER_HDR_LEN
operator|)
expr_stmt|;
if|if
condition|(
name|trim
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|trim
operator|<
literal|0
condition|)
goto|goto
name|_exit
goto|;
name|m_adj
argument_list|(
name|m_head
argument_list|,
operator|-
name|trim
argument_list|)
expr_stmt|;
name|tot_len
operator|=
name|m_head
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
block|}
name|buffer_next
operator|=
name|m_head
expr_stmt|;
name|buffer_tail
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|buffer_next
operator|!=
name|NULL
condition|)
block|{
name|buffer_tail
operator|=
name|buffer_next
expr_stmt|;
name|buffer_next
operator|=
name|buffer_tail
operator|->
name|m_next
expr_stmt|;
block|}
comment|/* Total size of only headers */
name|hlen
operator|=
name|ip_len
operator|+
name|ETHER_HDR_LEN
operator|-
name|tcp_data_len
expr_stmt|;
comment|/* Get sequence number */
name|seq
operator|=
name|ntohl
argument_list|(
name|header_tcp
operator|->
name|th_seq
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|lro_session
argument_list|,
argument|&lldev->lro_active
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|lro_session
operator|->
name|source_port
operator|==
name|header_tcp
operator|->
name|th_sport
operator|&&
name|lro_session
operator|->
name|dest_port
operator|==
name|header_tcp
operator|->
name|th_dport
operator|&&
name|lro_session
operator|->
name|source_ip
operator|==
name|header_ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|&&
name|lro_session
operator|->
name|dest_ip
operator|==
name|header_ip
operator|->
name|ip_dst
operator|.
name|s_addr
condition|)
block|{
comment|/* Unmatched sequence number, flush LRO session */
if|if
condition|(
name|__predict_false
argument_list|(
name|seq
operator|!=
name|lro_session
operator|->
name|next_seq
argument_list|)
condition|)
block|{
name|SLIST_REMOVE
argument_list|(
operator|&
name|lldev
operator|->
name|lro_active
argument_list|,
name|lro_session
argument_list|,
name|xge_lro_entry_t
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|xge_lro_flush
argument_list|(
name|lldev
argument_list|,
name|lro_session
argument_list|)
expr_stmt|;
goto|goto
name|_exit
goto|;
block|}
comment|/* Handle timestamp option */
if|if
condition|(
name|tcp_options
condition|)
block|{
name|u32
name|tsval
init|=
name|ntohl
argument_list|(
operator|*
operator|(
name|ptr
operator|+
literal|1
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|lro_session
operator|->
name|tsval
operator|>
name|tsval
operator|||
operator|*
operator|(
name|ptr
operator|+
literal|2
operator|)
operator|==
literal|0
argument_list|)
condition|)
block|{
goto|goto
name|_exit
goto|;
block|}
name|lro_session
operator|->
name|tsval
operator|=
name|tsval
expr_stmt|;
name|lro_session
operator|->
name|tsecr
operator|=
operator|*
operator|(
name|ptr
operator|+
literal|2
operator|)
expr_stmt|;
block|}
name|lro_session
operator|->
name|next_seq
operator|+=
name|tcp_data_len
expr_stmt|;
name|lro_session
operator|->
name|ack_seq
operator|=
name|header_tcp
operator|->
name|th_ack
expr_stmt|;
name|lro_session
operator|->
name|window
operator|=
name|header_tcp
operator|->
name|th_win
expr_stmt|;
comment|/* If TCP data/payload is of 0 size, free mbuf */
if|if
condition|(
name|tcp_data_len
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m_head
argument_list|)
expr_stmt|;
name|status
operator|=
name|XGE_HAL_OK
expr_stmt|;
goto|goto
name|_exit
goto|;
block|}
name|lro_session
operator|->
name|append_cnt
operator|++
expr_stmt|;
name|lro_session
operator|->
name|len
operator|+=
name|tcp_data_len
expr_stmt|;
comment|/* Adjust mbuf so that m_data points to payload than headers */
name|m_adj
argument_list|(
name|m_head
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
comment|/* Append this packet to LRO accumulated packet */
name|lro_session
operator|->
name|m_tail
operator|->
name|m_next
operator|=
name|m_head
expr_stmt|;
name|lro_session
operator|->
name|m_tail
operator|=
name|buffer_tail
expr_stmt|;
comment|/* Flush if LRO packet is exceeding maximum size */
if|if
condition|(
name|lro_session
operator|->
name|len
operator|>
operator|(
name|XGE_HAL_LRO_DEFAULT_FRM_LEN
operator|-
name|lldev
operator|->
name|ifnetp
operator|->
name|if_mtu
operator|)
condition|)
block|{
name|SLIST_REMOVE
argument_list|(
operator|&
name|lldev
operator|->
name|lro_active
argument_list|,
name|lro_session
argument_list|,
name|xge_lro_entry_t
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|xge_lro_flush
argument_list|(
name|lldev
argument_list|,
name|lro_session
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
name|XGE_HAL_OK
expr_stmt|;
goto|goto
name|_exit
goto|;
block|}
block|}
if|if
condition|(
name|SLIST_EMPTY
argument_list|(
operator|&
name|lldev
operator|->
name|lro_free
argument_list|)
condition|)
goto|goto
name|_exit
goto|;
comment|/* Start a new LRO session */
name|lro_session
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|lldev
operator|->
name|lro_free
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|lldev
operator|->
name|lro_free
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|lldev
operator|->
name|lro_active
argument_list|,
name|lro_session
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|lro_session
operator|->
name|source_port
operator|=
name|header_tcp
operator|->
name|th_sport
expr_stmt|;
name|lro_session
operator|->
name|dest_port
operator|=
name|header_tcp
operator|->
name|th_dport
expr_stmt|;
name|lro_session
operator|->
name|source_ip
operator|=
name|header_ip
operator|->
name|ip_src
operator|.
name|s_addr
expr_stmt|;
name|lro_session
operator|->
name|dest_ip
operator|=
name|header_ip
operator|->
name|ip_dst
operator|.
name|s_addr
expr_stmt|;
name|lro_session
operator|->
name|next_seq
operator|=
name|seq
operator|+
name|tcp_data_len
expr_stmt|;
name|lro_session
operator|->
name|mss
operator|=
name|tcp_data_len
expr_stmt|;
name|lro_session
operator|->
name|ack_seq
operator|=
name|header_tcp
operator|->
name|th_ack
expr_stmt|;
name|lro_session
operator|->
name|window
operator|=
name|header_tcp
operator|->
name|th_win
expr_stmt|;
name|lro_session
operator|->
name|lro_header_ip
operator|=
name|header_ip
expr_stmt|;
comment|/* Handle timestamp option */
if|if
condition|(
name|tcp_options
condition|)
block|{
name|lro_session
operator|->
name|timestamp
operator|=
literal|1
expr_stmt|;
name|lro_session
operator|->
name|tsval
operator|=
name|ntohl
argument_list|(
operator|*
operator|(
name|ptr
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|lro_session
operator|->
name|tsecr
operator|=
operator|*
operator|(
name|ptr
operator|+
literal|2
operator|)
expr_stmt|;
block|}
name|lro_session
operator|->
name|len
operator|=
name|tot_len
expr_stmt|;
name|lro_session
operator|->
name|m_head
operator|=
name|m_head
expr_stmt|;
name|lro_session
operator|->
name|m_tail
operator|=
name|buffer_tail
expr_stmt|;
name|status
operator|=
name|XGE_HAL_OK
expr_stmt|;
name|_exit
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * xge_accumulate_large_rx  * Accumulate packets to form a large LRO packet based on various conditions  *  * @lldev Per-adapter Data  * @pkt Current packet  * @pkt_length Packet Length  * @rxd_priv Rx Descriptor Private Data  */
end_comment

begin_function
name|void
name|xge_accumulate_large_rx
parameter_list|(
name|xge_lldev_t
modifier|*
name|lldev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|pkt
parameter_list|,
name|int
name|pkt_length
parameter_list|,
name|xge_rx_priv_t
modifier|*
name|rxd_priv
parameter_list|)
block|{
if|if
condition|(
name|xge_lro_accumulate
argument_list|(
name|lldev
argument_list|,
name|pkt
argument_list|)
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|lldev
operator|->
name|dma_tag_rx
argument_list|,
name|rxd_priv
operator|->
name|dmainfo
index|[
literal|0
index|]
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lldev
operator|->
name|ifnetp
operator|->
name|if_input
call|)
argument_list|(
name|lldev
operator|->
name|ifnetp
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * xge_rx_compl  * If the interrupt is due to received frame (Rx completion), send it up  *  * @channelh Ring Channel Handle  * @dtr Current Descriptor  * @t_code Transfer Code indicating success or error  * @userdata Per-adapter Data  *  * Returns XGE_HAL_OK or HAL error enums  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_rx_compl
parameter_list|(
name|xge_hal_channel_h
name|channelh
parameter_list|,
name|xge_hal_dtr_h
name|dtr
parameter_list|,
name|u8
name|t_code
parameter_list|,
name|void
modifier|*
name|userdata
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifnetp
decl_stmt|;
name|xge_rx_priv_t
modifier|*
name|rxd_priv
init|=
name|NULL
decl_stmt|;
name|mbuf_t
name|mbuf_up
init|=
name|NULL
decl_stmt|;
name|xge_hal_status_e
name|status
init|=
name|XGE_HAL_OK
decl_stmt|;
name|xge_hal_dtr_info_t
name|ext_info
decl_stmt|;
name|int
name|index
decl_stmt|;
name|u16
name|vlan_tag
decl_stmt|;
comment|/*get the user data portion*/
name|xge_lldev_t
modifier|*
name|lldev
init|=
name|xge_hal_channel_userdata
argument_list|(
name|channelh
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|lldev
condition|)
block|{
name|XGE_EXIT_ON_ERR
argument_list|(
literal|"Failed to get user data"
argument_list|,
name|_exit
argument_list|,
name|XGE_HAL_FAIL
argument_list|)
expr_stmt|;
block|}
name|XGE_DRV_STATS
argument_list|(
name|rx_completions
argument_list|)
expr_stmt|;
comment|/* get the interface pointer */
name|ifnetp
operator|=
name|lldev
operator|->
name|ifnetp
expr_stmt|;
do|do
block|{
name|XGE_DRV_STATS
argument_list|(
name|rx_desc_compl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifnetp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|status
operator|=
name|XGE_HAL_FAIL
expr_stmt|;
goto|goto
name|_exit
goto|;
block|}
if|if
condition|(
name|t_code
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"Packet dropped because of %d"
argument_list|,
name|t_code
argument_list|)
expr_stmt|;
name|XGE_DRV_STATS
argument_list|(
name|rx_tcode
argument_list|)
expr_stmt|;
name|xge_hal_device_handle_tcode
argument_list|(
name|channelh
argument_list|,
name|dtr
argument_list|,
name|t_code
argument_list|)
expr_stmt|;
name|xge_hal_ring_dtr_post
argument_list|(
name|channelh
argument_list|,
name|dtr
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Get the private data for this descriptor*/
name|rxd_priv
operator|=
operator|(
name|xge_rx_priv_t
operator|*
operator|)
name|xge_hal_ring_dtr_private
argument_list|(
name|channelh
argument_list|,
name|dtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rxd_priv
condition|)
block|{
name|XGE_EXIT_ON_ERR
argument_list|(
literal|"Failed to get descriptor private data"
argument_list|,
name|_exit
argument_list|,
name|XGE_HAL_FAIL
argument_list|)
expr_stmt|;
block|}
comment|/* 	     * Prepare one buffer to send it to upper layer -- since the upper 	     * layer frees the buffer do not use rxd_priv->buffer. Meanwhile 	     * prepare a new buffer, do mapping, use it in the current 	     * descriptor and post descriptor back to ring channel 	     */
name|mbuf_up
operator|=
name|rxd_priv
operator|->
name|bufferArray
index|[
literal|0
index|]
expr_stmt|;
comment|/* Gets details of mbuf i.e., packet length */
name|xge_ring_dtr_get
argument_list|(
name|mbuf_up
argument_list|,
name|channelh
argument_list|,
name|dtr
argument_list|,
name|lldev
argument_list|,
name|rxd_priv
argument_list|)
expr_stmt|;
name|status
operator|=
operator|(
name|lldev
operator|->
name|buffer_mode
operator|==
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_1
operator|)
condition|?
name|xge_get_buf
argument_list|(
name|dtr
argument_list|,
name|rxd_priv
argument_list|,
name|lldev
argument_list|,
literal|0
argument_list|)
else|:
name|xge_get_buf_3b_5b
argument_list|(
name|dtr
argument_list|,
name|rxd_priv
argument_list|,
name|lldev
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"No memory"
argument_list|)
expr_stmt|;
name|XGE_DRV_STATS
argument_list|(
name|rx_no_buf
argument_list|)
expr_stmt|;
comment|/* 	         * Unable to allocate buffer. Instead of discarding, post 	         * descriptor back to channel for future processing of same 	         * packet. 	         */
name|xge_hal_ring_dtr_post
argument_list|(
name|channelh
argument_list|,
name|dtr
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Get the extended information */
name|xge_hal_ring_dtr_info_get
argument_list|(
name|channelh
argument_list|,
name|dtr
argument_list|,
operator|&
name|ext_info
argument_list|)
expr_stmt|;
comment|/* 	     * As we have allocated a new mbuf for this descriptor, post this 	     * descriptor with new mbuf back to ring channel 	     */
name|vlan_tag
operator|=
name|ext_info
operator|.
name|vlan
expr_stmt|;
name|xge_hal_ring_dtr_post
argument_list|(
name|channelh
argument_list|,
name|dtr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
operator|(
name|ext_info
operator|.
name|proto
operator|&
name|XGE_HAL_FRAME_PROTO_IP_FRAGMENTED
operator|)
operator|&&
operator|(
name|ext_info
operator|.
name|proto
operator|&
name|XGE_HAL_FRAME_PROTO_TCP_OR_UDP
operator|)
operator|&&
operator|(
name|ext_info
operator|.
name|l3_cksum
operator|==
name|XGE_HAL_L3_CKSUM_OK
operator|)
operator|&&
operator|(
name|ext_info
operator|.
name|l4_cksum
operator|==
name|XGE_HAL_L4_CKSUM_OK
operator|)
operator|)
condition|)
block|{
comment|/* set Checksum Flag */
name|xge_set_mbuf_cflags
argument_list|(
name|mbuf_up
argument_list|)
expr_stmt|;
if|if
condition|(
name|lldev
operator|->
name|enabled_lro
condition|)
block|{
name|xge_accumulate_large_rx
argument_list|(
name|lldev
argument_list|,
name|mbuf_up
argument_list|,
name|mbuf_up
operator|->
name|m_len
argument_list|,
name|rxd_priv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Post-Read sync for buffers*/
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|lldev
operator|->
name|rxd_mbuf_cnt
condition|;
name|index
operator|++
control|)
block|{
name|bus_dmamap_sync
argument_list|(
name|lldev
operator|->
name|dma_tag_rx
argument_list|,
name|rxd_priv
operator|->
name|dmainfo
index|[
literal|0
index|]
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|ifnetp
operator|->
name|if_input
call|)
argument_list|(
name|ifnetp
argument_list|,
name|mbuf_up
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	         * Packet with erroneous checksum , let the upper layer deal 	         * with it 	         */
comment|/* Post-Read sync for buffers*/
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|lldev
operator|->
name|rxd_mbuf_cnt
condition|;
name|index
operator|++
control|)
block|{
name|bus_dmamap_sync
argument_list|(
name|lldev
operator|->
name|dma_tag_rx
argument_list|,
name|rxd_priv
operator|->
name|dmainfo
index|[
literal|0
index|]
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vlan_tag
condition|)
block|{
name|mbuf_up
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|=
name|vlan_tag
expr_stmt|;
name|mbuf_up
operator|->
name|m_flags
operator||=
name|M_VLANTAG
expr_stmt|;
block|}
if|if
condition|(
name|lldev
operator|->
name|enabled_lro
condition|)
name|xge_lro_flush_sessions
argument_list|(
name|lldev
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifnetp
operator|->
name|if_input
call|)
argument_list|(
name|ifnetp
argument_list|,
name|mbuf_up
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|xge_hal_ring_dtr_next_completed
argument_list|(
name|channelh
argument_list|,
operator|&
name|dtr
argument_list|,
operator|&
name|t_code
argument_list|)
operator|==
name|XGE_HAL_OK
condition|)
do|;
if|if
condition|(
name|lldev
operator|->
name|enabled_lro
condition|)
name|xge_lro_flush_sessions
argument_list|(
name|lldev
argument_list|)
expr_stmt|;
name|_exit
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * xge_ring_dtr_get  * Get descriptors  *  * @mbuf_up Packet to send up  * @channelh Ring Channel Handle  * @dtr Descriptor  * @lldev Per-adapter Data  * @rxd_priv Rx Descriptor Private Data  *  * Returns XGE_HAL_OK or HAL error enums  */
end_comment

begin_function
name|int
name|xge_ring_dtr_get
parameter_list|(
name|mbuf_t
name|mbuf_up
parameter_list|,
name|xge_hal_channel_h
name|channelh
parameter_list|,
name|xge_hal_dtr_h
name|dtr
parameter_list|,
name|xge_lldev_t
modifier|*
name|lldev
parameter_list|,
name|xge_rx_priv_t
modifier|*
name|rxd_priv
parameter_list|)
block|{
name|mbuf_t
name|m
decl_stmt|;
name|int
name|pkt_length
index|[
literal|5
index|]
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|,
name|pkt_len
init|=
literal|0
decl_stmt|;
name|dma_addr_t
name|dma_data
index|[
literal|5
index|]
decl_stmt|;
name|int
name|index
decl_stmt|;
name|m
operator|=
name|mbuf_up
expr_stmt|;
name|pkt_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lldev
operator|->
name|buffer_mode
operator|!=
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_1
condition|)
block|{
name|xge_os_memzero
argument_list|(
name|pkt_length
argument_list|,
sizeof|sizeof
argument_list|(
name|pkt_length
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	     * Retrieve data of interest from the completed descriptor -- This 	     * returns the packet length 	     */
if|if
condition|(
name|lldev
operator|->
name|buffer_mode
operator|==
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_5
condition|)
block|{
name|xge_hal_ring_dtr_5b_get
argument_list|(
name|channelh
argument_list|,
name|dtr
argument_list|,
name|dma_data
argument_list|,
name|pkt_length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xge_hal_ring_dtr_3b_get
argument_list|(
name|channelh
argument_list|,
name|dtr
argument_list|,
name|dma_data
argument_list|,
name|pkt_length
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|lldev
operator|->
name|rxd_mbuf_cnt
condition|;
name|index
operator|++
control|)
block|{
name|m
operator|->
name|m_len
operator|=
name|pkt_length
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|index
operator|<
operator|(
name|lldev
operator|->
name|rxd_mbuf_cnt
operator|-
literal|1
operator|)
condition|)
block|{
name|m
operator|->
name|m_next
operator|=
name|rxd_priv
operator|->
name|bufferArray
index|[
name|index
operator|+
literal|1
index|]
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
else|else
block|{
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
block|}
name|pkt_len
operator|+=
name|pkt_length
index|[
name|index
index|]
expr_stmt|;
block|}
comment|/* 	     * Since 2 buffer mode is an exceptional case where data is in 3rd 	     * buffer but not in 2nd buffer 	     */
if|if
condition|(
name|lldev
operator|->
name|buffer_mode
operator|==
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_2
condition|)
block|{
name|m
operator|->
name|m_len
operator|=
name|pkt_length
index|[
literal|2
index|]
expr_stmt|;
name|pkt_len
operator|+=
name|pkt_length
index|[
literal|2
index|]
expr_stmt|;
block|}
comment|/* 	     * Update length of newly created buffer to be sent up with packet 	     * length 	     */
name|mbuf_up
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|pkt_len
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * Retrieve data of interest from the completed descriptor -- This 	     * returns the packet length 	     */
name|xge_hal_ring_dtr_1b_get
argument_list|(
name|channelh
argument_list|,
name|dtr
argument_list|,
operator|&
name|dma_data
index|[
literal|0
index|]
argument_list|,
operator|&
name|pkt_length
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* 	     * Update length of newly created buffer to be sent up with packet 	     * length 	     */
name|mbuf_up
operator|->
name|m_len
operator|=
name|mbuf_up
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|pkt_length
index|[
literal|0
index|]
expr_stmt|;
block|}
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/**  * xge_flush_txds  * Flush Tx descriptors  *  * @channelh Channel handle  */
end_comment

begin_function
specifier|static
name|void
specifier|inline
name|xge_flush_txds
parameter_list|(
name|xge_hal_channel_h
name|channelh
parameter_list|)
block|{
name|xge_lldev_t
modifier|*
name|lldev
init|=
name|xge_hal_channel_userdata
argument_list|(
name|channelh
argument_list|)
decl_stmt|;
name|xge_hal_dtr_h
name|tx_dtr
decl_stmt|;
name|xge_tx_priv_t
modifier|*
name|tx_priv
decl_stmt|;
name|u8
name|t_code
decl_stmt|;
while|while
condition|(
name|xge_hal_fifo_dtr_next_completed
argument_list|(
name|channelh
argument_list|,
operator|&
name|tx_dtr
argument_list|,
operator|&
name|t_code
argument_list|)
operator|==
name|XGE_HAL_OK
condition|)
block|{
name|XGE_DRV_STATS
argument_list|(
name|tx_desc_compl
argument_list|)
expr_stmt|;
if|if
condition|(
name|t_code
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"Tx descriptor with t_code %d"
argument_list|,
name|t_code
argument_list|)
expr_stmt|;
name|XGE_DRV_STATS
argument_list|(
name|tx_tcode
argument_list|)
expr_stmt|;
name|xge_hal_device_handle_tcode
argument_list|(
name|channelh
argument_list|,
name|tx_dtr
argument_list|,
name|t_code
argument_list|)
expr_stmt|;
block|}
name|tx_priv
operator|=
name|xge_hal_fifo_dtr_private
argument_list|(
name|tx_dtr
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|lldev
operator|->
name|dma_tag_tx
argument_list|,
name|tx_priv
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|tx_priv
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|tx_priv
operator|->
name|buffer
operator|=
name|NULL
expr_stmt|;
name|xge_hal_fifo_dtr_free
argument_list|(
name|channelh
argument_list|,
name|tx_dtr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * xge_send  * Transmit function  *  * @ifnetp Interface Handle  */
end_comment

begin_function
name|void
name|xge_send
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifnetp
parameter_list|)
block|{
name|int
name|qindex
init|=
literal|0
decl_stmt|;
name|xge_lldev_t
modifier|*
name|lldev
init|=
name|ifnetp
operator|->
name|if_softc
decl_stmt|;
for|for
control|(
name|qindex
operator|=
literal|0
init|;
name|qindex
operator|<
name|XGE_FIFO_COUNT
condition|;
name|qindex
operator|++
control|)
block|{
if|if
condition|(
name|mtx_trylock
argument_list|(
operator|&
name|lldev
operator|->
name|mtx_tx
index|[
name|qindex
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|XGE_DRV_STATS
argument_list|(
name|tx_lock_fail
argument_list|)
expr_stmt|;
break|break;
block|}
name|xge_send_locked
argument_list|(
name|ifnetp
argument_list|,
name|qindex
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|mtx_tx
index|[
name|qindex
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
specifier|inline
name|xge_send_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifnetp
parameter_list|,
name|int
name|qindex
parameter_list|)
block|{
name|xge_hal_dtr_h
name|dtr
decl_stmt|;
specifier|static
name|bus_dma_segment_t
name|segs
index|[
name|XGE_MAX_SEGS
index|]
decl_stmt|;
name|xge_hal_status_e
name|status
decl_stmt|;
name|unsigned
name|int
name|max_fragments
decl_stmt|;
name|xge_lldev_t
modifier|*
name|lldev
init|=
name|ifnetp
operator|->
name|if_softc
decl_stmt|;
name|xge_hal_channel_h
name|channelh
init|=
name|lldev
operator|->
name|fifo_channel
index|[
name|qindex
index|]
decl_stmt|;
name|mbuf_t
name|m_head
init|=
name|NULL
decl_stmt|;
name|mbuf_t
name|m_buf
init|=
name|NULL
decl_stmt|;
name|xge_tx_priv_t
modifier|*
name|ll_tx_priv
init|=
name|NULL
decl_stmt|;
specifier|register
name|unsigned
name|int
name|count
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|nsegs
init|=
literal|0
decl_stmt|;
name|u16
name|vlan_tag
decl_stmt|;
name|max_fragments
operator|=
operator|(
operator|(
name|xge_hal_fifo_t
operator|*
operator|)
name|channelh
operator|)
operator|->
name|config
operator|->
name|max_frags
expr_stmt|;
comment|/* If device is not initialized, return */
if|if
condition|(
operator|(
operator|!
name|lldev
operator|->
name|initialized
operator|)
operator|||
operator|(
operator|!
operator|(
name|ifnetp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|)
condition|)
return|return;
name|XGE_DRV_STATS
argument_list|(
name|tx_calls
argument_list|)
expr_stmt|;
comment|/* 	 * This loop will be executed for each packet in the kernel maintained 	 * queue -- each packet can be with fragments as an mbuf chain 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifnetp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_head
operator|==
name|NULL
condition|)
block|{
name|ifnetp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|m_buf
operator|=
name|m_head
init|;
name|m_buf
operator|!=
name|NULL
condition|;
name|m_buf
operator|=
name|m_buf
operator|->
name|m_next
control|)
block|{
if|if
condition|(
name|m_buf
operator|->
name|m_len
condition|)
name|count
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|>=
name|max_fragments
condition|)
block|{
name|m_buf
operator|=
name|m_defrag
argument_list|(
name|m_head
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_buf
operator|!=
name|NULL
condition|)
name|m_head
operator|=
name|m_buf
expr_stmt|;
name|XGE_DRV_STATS
argument_list|(
name|tx_defrag
argument_list|)
expr_stmt|;
block|}
comment|/* Reserve descriptors */
name|status
operator|=
name|xge_hal_fifo_dtr_reserve
argument_list|(
name|channelh
argument_list|,
operator|&
name|dtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
block|{
name|XGE_DRV_STATS
argument_list|(
name|tx_no_txd
argument_list|)
expr_stmt|;
name|xge_flush_txds
argument_list|(
name|channelh
argument_list|)
expr_stmt|;
break|break;
block|}
name|vlan_tag
operator|=
operator|(
name|m_head
operator|->
name|m_flags
operator|&
name|M_VLANTAG
operator|)
condition|?
name|m_head
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
else|:
literal|0
expr_stmt|;
name|xge_hal_fifo_dtr_vlan_set
argument_list|(
name|dtr
argument_list|,
name|vlan_tag
argument_list|)
expr_stmt|;
comment|/* Update Tx private structure for this descriptor */
name|ll_tx_priv
operator|=
name|xge_hal_fifo_dtr_private
argument_list|(
name|dtr
argument_list|)
expr_stmt|;
name|ll_tx_priv
operator|->
name|buffer
operator|=
name|m_head
expr_stmt|;
comment|/* 	     * Do mapping -- Required DMA tag has been created in xge_init 	     * function and DMA maps have already been created in the 	     * xgell_tx_replenish function. 	     * Returns number of segments through nsegs 	     */
if|if
condition|(
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|lldev
operator|->
name|dma_tag_tx
argument_list|,
name|ll_tx_priv
operator|->
name|dma_map
argument_list|,
name|m_head
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"DMA map load failed"
argument_list|)
expr_stmt|;
name|XGE_DRV_STATS
argument_list|(
name|tx_map_fail
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|lldev
operator|->
name|driver_stats
operator|.
name|tx_max_frags
operator|<
name|nsegs
condition|)
name|lldev
operator|->
name|driver_stats
operator|.
name|tx_max_frags
operator|=
name|nsegs
expr_stmt|;
comment|/* Set descriptor buffer for header and each fragment/segment */
name|count
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|xge_hal_fifo_dtr_buffer_set
argument_list|(
name|channelh
argument_list|,
name|dtr
argument_list|,
name|count
argument_list|,
operator|(
name|dma_addr_t
operator|)
name|htole64
argument_list|(
name|segs
index|[
name|count
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|,
name|segs
index|[
name|count
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|count
operator|<
name|nsegs
condition|)
do|;
comment|/* Pre-write Sync of mapping */
name|bus_dmamap_sync
argument_list|(
name|lldev
operator|->
name|dma_tag_tx
argument_list|,
name|ll_tx_priv
operator|->
name|dma_map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lldev
operator|->
name|enabled_tso
operator|)
operator|&&
operator|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
operator|)
condition|)
block|{
name|XGE_DRV_STATS
argument_list|(
name|tx_tso
argument_list|)
expr_stmt|;
name|xge_hal_fifo_dtr_mss_set
argument_list|(
name|dtr
argument_list|,
name|m_head
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
argument_list|)
expr_stmt|;
block|}
comment|/* Checksum */
if|if
condition|(
name|ifnetp
operator|->
name|if_hwassist
operator|>
literal|0
condition|)
block|{
name|xge_hal_fifo_dtr_cksum_set_bits
argument_list|(
name|dtr
argument_list|,
name|XGE_HAL_TXD_TX_CKO_IPV4_EN
operator||
name|XGE_HAL_TXD_TX_CKO_TCP_EN
operator||
name|XGE_HAL_TXD_TX_CKO_UDP_EN
argument_list|)
expr_stmt|;
block|}
comment|/* Post descriptor to FIFO channel */
name|xge_hal_fifo_dtr_post
argument_list|(
name|channelh
argument_list|,
name|dtr
argument_list|)
expr_stmt|;
name|XGE_DRV_STATS
argument_list|(
name|tx_posted
argument_list|)
expr_stmt|;
comment|/* Send the same copy of mbuf packet to BPF (Berkely Packet Filter) 	     * listener so that we can use tools like tcpdump */
name|ETHER_BPF_MTAP
argument_list|(
name|ifnetp
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
block|}
comment|/* Prepend the packet back to queue */
name|IF_PREPEND
argument_list|(
operator|&
name|ifnetp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
name|ifnetp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
name|xge_queue_produce_context
argument_list|(
name|xge_hal_device_queue
argument_list|(
name|lldev
operator|->
name|devh
argument_list|)
argument_list|,
name|XGE_LL_EVENT_TRY_XMIT_AGAIN
argument_list|,
name|lldev
operator|->
name|devh
argument_list|)
expr_stmt|;
name|XGE_DRV_STATS
argument_list|(
name|tx_again
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * xge_get_buf  * Allocates new mbufs to be placed into descriptors  *  * @dtrh Descriptor Handle  * @rxd_priv Rx Descriptor Private Data  * @lldev Per-adapter Data  * @index Buffer Index (if multi-buffer mode)  *  * Returns XGE_HAL_OK or HAL error enums  */
end_comment

begin_function
name|int
name|xge_get_buf
parameter_list|(
name|xge_hal_dtr_h
name|dtrh
parameter_list|,
name|xge_rx_priv_t
modifier|*
name|rxd_priv
parameter_list|,
name|xge_lldev_t
modifier|*
name|lldev
parameter_list|,
name|int
name|index
parameter_list|)
block|{
specifier|register
name|mbuf_t
name|mp
init|=
name|NULL
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifnetp
init|=
name|lldev
operator|->
name|ifnetp
decl_stmt|;
name|int
name|status
init|=
name|XGE_HAL_OK
decl_stmt|;
name|int
name|buffer_size
init|=
literal|0
decl_stmt|,
name|cluster_size
init|=
literal|0
decl_stmt|,
name|count
decl_stmt|;
name|bus_dmamap_t
name|map
init|=
name|rxd_priv
operator|->
name|dmainfo
index|[
name|index
index|]
operator|.
name|dma_map
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
literal|3
index|]
decl_stmt|;
name|buffer_size
operator|=
operator|(
name|lldev
operator|->
name|buffer_mode
operator|==
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_1
operator|)
condition|?
name|ifnetp
operator|->
name|if_mtu
operator|+
name|XGE_HAL_MAC_HEADER_MAX_SIZE
else|:
name|lldev
operator|->
name|rxd_mbuf_len
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|buffer_size
operator|<=
name|MCLBYTES
condition|)
block|{
name|cluster_size
operator|=
name|MCLBYTES
expr_stmt|;
name|mp
operator|=
name|m_getcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cluster_size
operator|=
name|MJUMPAGESIZE
expr_stmt|;
if|if
condition|(
operator|(
name|lldev
operator|->
name|buffer_mode
operator|!=
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_5
operator|)
operator|&&
operator|(
name|buffer_size
operator|>
name|MJUMPAGESIZE
operator|)
condition|)
block|{
name|cluster_size
operator|=
name|MJUM9BYTES
expr_stmt|;
block|}
name|mp
operator|=
name|m_getjcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|cluster_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mp
condition|)
block|{
name|xge_trace
argument_list|(
name|XGE_ERR
argument_list|,
literal|"Out of memory to allocate mbuf"
argument_list|)
expr_stmt|;
name|status
operator|=
name|XGE_HAL_FAIL
expr_stmt|;
goto|goto
name|getbuf_out
goto|;
block|}
comment|/* Update mbuf's length, packet length and receive interface */
name|mp
operator|->
name|m_len
operator|=
name|mp
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|buffer_size
expr_stmt|;
name|mp
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifnetp
expr_stmt|;
comment|/* Load DMA map */
if|if
condition|(
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|lldev
operator|->
name|dma_tag_rx
argument_list|,
name|lldev
operator|->
name|extra_dma_map
argument_list|,
name|mp
argument_list|,
name|segs
argument_list|,
operator|&
name|count
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
condition|)
block|{
name|XGE_DRV_STATS
argument_list|(
name|rx_map_fail
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|XGE_EXIT_ON_ERR
argument_list|(
literal|"DMA map load failed"
argument_list|,
name|getbuf_out
argument_list|,
name|XGE_HAL_FAIL
argument_list|)
expr_stmt|;
block|}
comment|/* Update descriptor private data */
name|rxd_priv
operator|->
name|bufferArray
index|[
name|index
index|]
operator|=
name|mp
expr_stmt|;
name|rxd_priv
operator|->
name|dmainfo
index|[
name|index
index|]
operator|.
name|dma_phyaddr
operator|=
name|htole64
argument_list|(
name|segs
operator|->
name|ds_addr
argument_list|)
expr_stmt|;
name|rxd_priv
operator|->
name|dmainfo
index|[
name|index
index|]
operator|.
name|dma_map
operator|=
name|lldev
operator|->
name|extra_dma_map
expr_stmt|;
name|lldev
operator|->
name|extra_dma_map
operator|=
name|map
expr_stmt|;
comment|/* Pre-Read/Write sync */
name|bus_dmamap_sync
argument_list|(
name|lldev
operator|->
name|dma_tag_rx
argument_list|,
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
comment|/* Unload DMA map of mbuf in current descriptor */
name|bus_dmamap_unload
argument_list|(
name|lldev
operator|->
name|dma_tag_rx
argument_list|,
name|map
argument_list|)
expr_stmt|;
comment|/* Set descriptor buffer */
if|if
condition|(
name|lldev
operator|->
name|buffer_mode
operator|==
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_1
condition|)
block|{
name|xge_hal_ring_dtr_1b_set
argument_list|(
name|dtrh
argument_list|,
name|rxd_priv
operator|->
name|dmainfo
index|[
literal|0
index|]
operator|.
name|dma_phyaddr
argument_list|,
name|cluster_size
argument_list|)
expr_stmt|;
block|}
name|getbuf_out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * xge_get_buf_3b_5b  * Allocates new mbufs to be placed into descriptors (in multi-buffer modes)  *  * @dtrh Descriptor Handle  * @rxd_priv Rx Descriptor Private Data  * @lldev Per-adapter Data  *  * Returns XGE_HAL_OK or HAL error enums  */
end_comment

begin_function
name|int
name|xge_get_buf_3b_5b
parameter_list|(
name|xge_hal_dtr_h
name|dtrh
parameter_list|,
name|xge_rx_priv_t
modifier|*
name|rxd_priv
parameter_list|,
name|xge_lldev_t
modifier|*
name|lldev
parameter_list|)
block|{
name|bus_addr_t
name|dma_pointers
index|[
literal|5
index|]
decl_stmt|;
name|int
name|dma_sizes
index|[
literal|5
index|]
decl_stmt|;
name|int
name|status
init|=
name|XGE_HAL_OK
decl_stmt|,
name|index
decl_stmt|;
name|int
name|newindex
init|=
literal|0
decl_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|lldev
operator|->
name|rxd_mbuf_cnt
condition|;
name|index
operator|++
control|)
block|{
name|status
operator|=
name|xge_get_buf
argument_list|(
name|dtrh
argument_list|,
name|rxd_priv
argument_list|,
name|lldev
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
block|{
for|for
control|(
name|newindex
operator|=
literal|0
init|;
name|newindex
operator|<
name|index
condition|;
name|newindex
operator|++
control|)
block|{
name|m_freem
argument_list|(
name|rxd_priv
operator|->
name|bufferArray
index|[
name|newindex
index|]
argument_list|)
expr_stmt|;
block|}
name|XGE_EXIT_ON_ERR
argument_list|(
literal|"mbuf allocation failed"
argument_list|,
name|_exit
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|lldev
operator|->
name|buffer_mode
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
name|lldev
operator|->
name|rxd_mbuf_len
index|[
name|index
index|]
operator|!=
literal|0
condition|)
block|{
name|dma_pointers
index|[
name|index
index|]
operator|=
name|rxd_priv
operator|->
name|dmainfo
index|[
name|index
index|]
operator|.
name|dma_phyaddr
expr_stmt|;
name|dma_sizes
index|[
name|index
index|]
operator|=
name|lldev
operator|->
name|rxd_mbuf_len
index|[
name|index
index|]
expr_stmt|;
block|}
else|else
block|{
name|dma_pointers
index|[
name|index
index|]
operator|=
name|rxd_priv
operator|->
name|dmainfo
index|[
name|index
operator|-
literal|1
index|]
operator|.
name|dma_phyaddr
expr_stmt|;
name|dma_sizes
index|[
name|index
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Assigning second buffer to third pointer in 2 buffer mode */
if|if
condition|(
name|lldev
operator|->
name|buffer_mode
operator|==
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_2
condition|)
block|{
name|dma_pointers
index|[
literal|2
index|]
operator|=
name|dma_pointers
index|[
literal|1
index|]
expr_stmt|;
name|dma_sizes
index|[
literal|2
index|]
operator|=
name|dma_sizes
index|[
literal|1
index|]
expr_stmt|;
name|dma_sizes
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|lldev
operator|->
name|buffer_mode
operator|==
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_5
condition|)
block|{
name|xge_hal_ring_dtr_5b_set
argument_list|(
name|dtrh
argument_list|,
name|dma_pointers
argument_list|,
name|dma_sizes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xge_hal_ring_dtr_3b_set
argument_list|(
name|dtrh
argument_list|,
name|dma_pointers
argument_list|,
name|dma_sizes
argument_list|)
expr_stmt|;
block|}
name|_exit
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * xge_tx_compl  * If the interrupt is due to Tx completion, free the sent buffer  *  * @channelh Channel Handle  * @dtr Descriptor  * @t_code Transfer Code indicating success or error  * @userdata Per-adapter Data  *  * Returns XGE_HAL_OK or HAL error enum  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_tx_compl
parameter_list|(
name|xge_hal_channel_h
name|channelh
parameter_list|,
name|xge_hal_dtr_h
name|dtr
parameter_list|,
name|u8
name|t_code
parameter_list|,
name|void
modifier|*
name|userdata
parameter_list|)
block|{
name|xge_tx_priv_t
modifier|*
name|ll_tx_priv
init|=
name|NULL
decl_stmt|;
name|xge_lldev_t
modifier|*
name|lldev
init|=
operator|(
name|xge_lldev_t
operator|*
operator|)
name|userdata
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifnetp
init|=
name|lldev
operator|->
name|ifnetp
decl_stmt|;
name|mbuf_t
name|m_buffer
init|=
name|NULL
decl_stmt|;
name|int
name|qindex
init|=
name|xge_hal_channel_id
argument_list|(
name|channelh
argument_list|)
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lldev
operator|->
name|mtx_tx
index|[
name|qindex
index|]
argument_list|)
expr_stmt|;
name|XGE_DRV_STATS
argument_list|(
name|tx_completions
argument_list|)
expr_stmt|;
comment|/* 	 * For each completed descriptor: Get private structure, free buffer, 	 * do unmapping, and free descriptor 	 */
do|do
block|{
name|XGE_DRV_STATS
argument_list|(
name|tx_desc_compl
argument_list|)
expr_stmt|;
if|if
condition|(
name|t_code
condition|)
block|{
name|XGE_DRV_STATS
argument_list|(
name|tx_tcode
argument_list|)
expr_stmt|;
name|xge_trace
argument_list|(
name|XGE_TRACE
argument_list|,
literal|"t_code %d"
argument_list|,
name|t_code
argument_list|)
expr_stmt|;
name|xge_hal_device_handle_tcode
argument_list|(
name|channelh
argument_list|,
name|dtr
argument_list|,
name|t_code
argument_list|)
expr_stmt|;
block|}
name|ll_tx_priv
operator|=
name|xge_hal_fifo_dtr_private
argument_list|(
name|dtr
argument_list|)
expr_stmt|;
name|m_buffer
operator|=
name|ll_tx_priv
operator|->
name|buffer
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|lldev
operator|->
name|dma_tag_tx
argument_list|,
name|ll_tx_priv
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m_buffer
argument_list|)
expr_stmt|;
name|ll_tx_priv
operator|->
name|buffer
operator|=
name|NULL
expr_stmt|;
name|xge_hal_fifo_dtr_free
argument_list|(
name|channelh
argument_list|,
name|dtr
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|xge_hal_fifo_dtr_next_completed
argument_list|(
name|channelh
argument_list|,
operator|&
name|dtr
argument_list|,
operator|&
name|t_code
argument_list|)
operator|==
name|XGE_HAL_OK
condition|)
do|;
name|xge_send_locked
argument_list|(
name|ifnetp
argument_list|,
name|qindex
argument_list|)
expr_stmt|;
name|ifnetp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lldev
operator|->
name|mtx_tx
index|[
name|qindex
index|]
argument_list|)
expr_stmt|;
return|return
name|XGE_HAL_OK
return|;
block|}
end_function

begin_comment
comment|/**  * xge_tx_initial_replenish  * Initially allocate buffers and set them into descriptors for later use  *  * @channelh Tx Channel Handle  * @dtrh Descriptor Handle  * @index  * @userdata Per-adapter Data  * @reopen Channel open/reopen option  *  * Returns XGE_HAL_OK or HAL error enums  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_tx_initial_replenish
parameter_list|(
name|xge_hal_channel_h
name|channelh
parameter_list|,
name|xge_hal_dtr_h
name|dtrh
parameter_list|,
name|int
name|index
parameter_list|,
name|void
modifier|*
name|userdata
parameter_list|,
name|xge_hal_channel_reopen_e
name|reopen
parameter_list|)
block|{
name|xge_tx_priv_t
modifier|*
name|txd_priv
init|=
name|NULL
decl_stmt|;
name|int
name|status
init|=
name|XGE_HAL_OK
decl_stmt|;
comment|/* Get the user data portion from channel handle */
name|xge_lldev_t
modifier|*
name|lldev
init|=
name|xge_hal_channel_userdata
argument_list|(
name|channelh
argument_list|)
decl_stmt|;
if|if
condition|(
name|lldev
operator|==
name|NULL
condition|)
block|{
name|XGE_EXIT_ON_ERR
argument_list|(
literal|"Failed to get user data from channel"
argument_list|,
name|txinit_out
argument_list|,
name|XGE_HAL_FAIL
argument_list|)
expr_stmt|;
block|}
comment|/* Get the private data */
name|txd_priv
operator|=
operator|(
name|xge_tx_priv_t
operator|*
operator|)
name|xge_hal_fifo_dtr_private
argument_list|(
name|dtrh
argument_list|)
expr_stmt|;
if|if
condition|(
name|txd_priv
operator|==
name|NULL
condition|)
block|{
name|XGE_EXIT_ON_ERR
argument_list|(
literal|"Failed to get descriptor private data"
argument_list|,
name|txinit_out
argument_list|,
name|XGE_HAL_FAIL
argument_list|)
expr_stmt|;
block|}
comment|/* Create DMA map for this descriptor */
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|lldev
operator|->
name|dma_tag_tx
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|txd_priv
operator|->
name|dma_map
argument_list|)
condition|)
block|{
name|XGE_EXIT_ON_ERR
argument_list|(
literal|"DMA map creation for Tx descriptor failed"
argument_list|,
name|txinit_out
argument_list|,
name|XGE_HAL_FAIL
argument_list|)
expr_stmt|;
block|}
name|txinit_out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * xge_rx_initial_replenish  * Initially allocate buffers and set them into descriptors for later use  *  * @channelh Tx Channel Handle  * @dtrh Descriptor Handle  * @index Ring Index  * @userdata Per-adapter Data  * @reopen Channel open/reopen option  *  * Returns XGE_HAL_OK or HAL error enums  */
end_comment

begin_function
name|xge_hal_status_e
name|xge_rx_initial_replenish
parameter_list|(
name|xge_hal_channel_h
name|channelh
parameter_list|,
name|xge_hal_dtr_h
name|dtrh
parameter_list|,
name|int
name|index
parameter_list|,
name|void
modifier|*
name|userdata
parameter_list|,
name|xge_hal_channel_reopen_e
name|reopen
parameter_list|)
block|{
name|xge_rx_priv_t
modifier|*
name|rxd_priv
init|=
name|NULL
decl_stmt|;
name|int
name|status
init|=
name|XGE_HAL_OK
decl_stmt|;
name|int
name|index1
init|=
literal|0
decl_stmt|,
name|index2
init|=
literal|0
decl_stmt|;
comment|/* Get the user data portion from channel handle */
name|xge_lldev_t
modifier|*
name|lldev
init|=
name|xge_hal_channel_userdata
argument_list|(
name|channelh
argument_list|)
decl_stmt|;
if|if
condition|(
name|lldev
operator|==
name|NULL
condition|)
block|{
name|XGE_EXIT_ON_ERR
argument_list|(
literal|"Failed to get user data from channel"
argument_list|,
name|rxinit_out
argument_list|,
name|XGE_HAL_FAIL
argument_list|)
expr_stmt|;
block|}
comment|/* Get the private data */
name|rxd_priv
operator|=
operator|(
name|xge_rx_priv_t
operator|*
operator|)
name|xge_hal_ring_dtr_private
argument_list|(
name|channelh
argument_list|,
name|dtrh
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxd_priv
operator|==
name|NULL
condition|)
block|{
name|XGE_EXIT_ON_ERR
argument_list|(
literal|"Failed to get descriptor private data"
argument_list|,
name|rxinit_out
argument_list|,
name|XGE_HAL_FAIL
argument_list|)
expr_stmt|;
block|}
name|rxd_priv
operator|->
name|bufferArray
operator|=
name|xge_os_malloc
argument_list|(
name|NULL
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|rxd_priv
operator|->
name|bufferArray
argument_list|)
operator|*
name|lldev
operator|->
name|rxd_mbuf_cnt
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxd_priv
operator|->
name|bufferArray
operator|==
name|NULL
condition|)
block|{
name|XGE_EXIT_ON_ERR
argument_list|(
literal|"Failed to allocate Rxd private"
argument_list|,
name|rxinit_out
argument_list|,
name|XGE_HAL_FAIL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lldev
operator|->
name|buffer_mode
operator|==
name|XGE_HAL_RING_QUEUE_BUFFER_MODE_1
condition|)
block|{
comment|/* Create DMA map for these descriptors*/
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|lldev
operator|->
name|dma_tag_rx
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|rxd_priv
operator|->
name|dmainfo
index|[
literal|0
index|]
operator|.
name|dma_map
argument_list|)
condition|)
block|{
name|XGE_EXIT_ON_ERR
argument_list|(
literal|"DMA map creation for Rx descriptor failed"
argument_list|,
name|rxinit_err_out
argument_list|,
name|XGE_HAL_FAIL
argument_list|)
expr_stmt|;
block|}
comment|/* Get a buffer, attach it to this descriptor */
name|status
operator|=
name|xge_get_buf
argument_list|(
name|dtrh
argument_list|,
name|rxd_priv
argument_list|,
name|lldev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|index1
operator|=
literal|0
init|;
name|index1
operator|<
name|lldev
operator|->
name|rxd_mbuf_cnt
condition|;
name|index1
operator|++
control|)
block|{
comment|/* Create DMA map for this descriptor */
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|lldev
operator|->
name|dma_tag_rx
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|rxd_priv
operator|->
name|dmainfo
index|[
name|index1
index|]
operator|.
name|dma_map
argument_list|)
condition|)
block|{
for|for
control|(
name|index2
operator|=
name|index1
operator|-
literal|1
init|;
name|index2
operator|>=
literal|0
condition|;
name|index2
operator|--
control|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|lldev
operator|->
name|dma_tag_rx
argument_list|,
name|rxd_priv
operator|->
name|dmainfo
index|[
name|index2
index|]
operator|.
name|dma_map
argument_list|)
expr_stmt|;
block|}
name|XGE_EXIT_ON_ERR
argument_list|(
literal|"Jumbo DMA map creation for Rx descriptor failed"
argument_list|,
name|rxinit_err_out
argument_list|,
name|XGE_HAL_FAIL
argument_list|)
expr_stmt|;
block|}
block|}
name|status
operator|=
name|xge_get_buf_3b_5b
argument_list|(
name|dtrh
argument_list|,
name|rxd_priv
argument_list|,
name|lldev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|!=
name|XGE_HAL_OK
condition|)
block|{
for|for
control|(
name|index1
operator|=
literal|0
init|;
name|index1
operator|<
name|lldev
operator|->
name|rxd_mbuf_cnt
condition|;
name|index1
operator|++
control|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|lldev
operator|->
name|dma_tag_rx
argument_list|,
name|rxd_priv
operator|->
name|dmainfo
index|[
name|index1
index|]
operator|.
name|dma_map
argument_list|)
expr_stmt|;
block|}
goto|goto
name|rxinit_err_out
goto|;
block|}
else|else
block|{
goto|goto
name|rxinit_out
goto|;
block|}
name|rxinit_err_out
label|:
name|xge_os_free
argument_list|(
name|NULL
argument_list|,
name|rxd_priv
operator|->
name|bufferArray
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|rxd_priv
operator|->
name|bufferArray
argument_list|)
operator|*
name|lldev
operator|->
name|rxd_mbuf_cnt
operator|)
argument_list|)
expr_stmt|;
name|rxinit_out
label|:
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**  * xge_rx_term  * During unload terminate and free all descriptors  *  * @channelh Rx Channel Handle  * @dtrh Rx Descriptor Handle  * @state Descriptor State  * @userdata Per-adapter Data  * @reopen Channel open/reopen option  */
end_comment

begin_function
name|void
name|xge_rx_term
parameter_list|(
name|xge_hal_channel_h
name|channelh
parameter_list|,
name|xge_hal_dtr_h
name|dtrh
parameter_list|,
name|xge_hal_dtr_state_e
name|state
parameter_list|,
name|void
modifier|*
name|userdata
parameter_list|,
name|xge_hal_channel_reopen_e
name|reopen
parameter_list|)
block|{
name|xge_rx_priv_t
modifier|*
name|rxd_priv
init|=
name|NULL
decl_stmt|;
name|xge_lldev_t
modifier|*
name|lldev
init|=
name|NULL
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
comment|/* Descriptor state is not "Posted" */
if|if
condition|(
name|state
operator|!=
name|XGE_HAL_DTR_STATE_POSTED
condition|)
goto|goto
name|rxterm_out
goto|;
comment|/* Get the user data portion */
name|lldev
operator|=
name|xge_hal_channel_userdata
argument_list|(
name|channelh
argument_list|)
expr_stmt|;
comment|/* Get the private data */
name|rxd_priv
operator|=
operator|(
name|xge_rx_priv_t
operator|*
operator|)
name|xge_hal_ring_dtr_private
argument_list|(
name|channelh
argument_list|,
name|dtrh
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|lldev
operator|->
name|rxd_mbuf_cnt
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
name|rxd_priv
operator|->
name|dmainfo
index|[
name|index
index|]
operator|.
name|dma_map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|lldev
operator|->
name|dma_tag_rx
argument_list|,
name|rxd_priv
operator|->
name|dmainfo
index|[
name|index
index|]
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|lldev
operator|->
name|dma_tag_rx
argument_list|,
name|rxd_priv
operator|->
name|dmainfo
index|[
name|index
index|]
operator|.
name|dma_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxd_priv
operator|->
name|bufferArray
index|[
name|index
index|]
operator|!=
name|NULL
condition|)
name|m_free
argument_list|(
name|rxd_priv
operator|->
name|bufferArray
index|[
name|index
index|]
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|lldev
operator|->
name|dma_tag_rx
argument_list|,
name|rxd_priv
operator|->
name|dmainfo
index|[
name|index
index|]
operator|.
name|dma_map
argument_list|)
expr_stmt|;
block|}
block|}
name|xge_os_free
argument_list|(
name|NULL
argument_list|,
name|rxd_priv
operator|->
name|bufferArray
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|rxd_priv
operator|->
name|bufferArray
argument_list|)
operator|*
name|lldev
operator|->
name|rxd_mbuf_cnt
operator|)
argument_list|)
expr_stmt|;
comment|/* Free the descriptor */
name|xge_hal_ring_dtr_free
argument_list|(
name|channelh
argument_list|,
name|dtrh
argument_list|)
expr_stmt|;
name|rxterm_out
label|:
return|return;
block|}
end_function

begin_comment
comment|/**  * xge_tx_term  * During unload terminate and free all descriptors  *  * @channelh Rx Channel Handle  * @dtrh Rx Descriptor Handle  * @state Descriptor State  * @userdata Per-adapter Data  * @reopen Channel open/reopen option  */
end_comment

begin_function
name|void
name|xge_tx_term
parameter_list|(
name|xge_hal_channel_h
name|channelh
parameter_list|,
name|xge_hal_dtr_h
name|dtr
parameter_list|,
name|xge_hal_dtr_state_e
name|state
parameter_list|,
name|void
modifier|*
name|userdata
parameter_list|,
name|xge_hal_channel_reopen_e
name|reopen
parameter_list|)
block|{
name|xge_tx_priv_t
modifier|*
name|ll_tx_priv
init|=
name|xge_hal_fifo_dtr_private
argument_list|(
name|dtr
argument_list|)
decl_stmt|;
name|xge_lldev_t
modifier|*
name|lldev
init|=
operator|(
name|xge_lldev_t
operator|*
operator|)
name|userdata
decl_stmt|;
comment|/* Destroy DMA map */
name|bus_dmamap_destroy
argument_list|(
name|lldev
operator|->
name|dma_tag_tx
argument_list|,
name|ll_tx_priv
operator|->
name|dma_map
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * xge_methods  *  * FreeBSD device interface entry points  */
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|xge_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|xge_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|xge_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|xge_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|xge_shutdown
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|xge_driver
init|=
block|{
literal|"nxge"
block|,
name|xge_methods
block|,
sizeof|sizeof
argument_list|(
name|xge_lldev_t
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|xge_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|nxge
argument_list|,
name|pci
argument_list|,
name|xge_driver
argument_list|,
name|xge_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

