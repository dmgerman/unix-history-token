begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * CAM SCSI device driver for the Adaptec 174X SCSI Host adapter  *  * Copyright (c) 1998 Justin T. Gibbs  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice immediately at the beginning of the file, without modification,  *    this list of conditions, and the following disclaimer.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<dev/eisa/eisaconf.h>
end_include

begin_include
include|#
directive|include
file|<dev/ahb/ahbreg.h>
end_include

begin_define
define|#
directive|define
name|ccb_ecb_ptr
value|spriv_ptr0
end_define

begin_define
define|#
directive|define
name|ccb_ahb_ptr
value|spriv_ptr1
end_define

begin_define
define|#
directive|define
name|ahb_inb
parameter_list|(
name|ahb
parameter_list|,
name|port
parameter_list|)
define|\
value|bus_space_read_1((ahb)->tag, (ahb)->bsh, port)
end_define

begin_define
define|#
directive|define
name|ahb_inl
parameter_list|(
name|ahb
parameter_list|,
name|port
parameter_list|)
define|\
value|bus_space_read_4((ahb)->tag, (ahb)->bsh, port)
end_define

begin_define
define|#
directive|define
name|ahb_outb
parameter_list|(
name|ahb
parameter_list|,
name|port
parameter_list|,
name|value
parameter_list|)
define|\
value|bus_space_write_1((ahb)->tag, (ahb)->bsh, port, value)
end_define

begin_define
define|#
directive|define
name|ahb_outl
parameter_list|(
name|ahb
parameter_list|,
name|port
parameter_list|,
name|value
parameter_list|)
define|\
value|bus_space_write_4((ahb)->tag, (ahb)->bsh, port, value)
end_define

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|ahbmatch
parameter_list|(
name|eisa_id_t
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ahb_softc
modifier|*
name|ahballoc
parameter_list|(
name|u_long
name|unit
parameter_list|,
name|struct
name|resource
modifier|*
name|res
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahbfree
parameter_list|(
name|struct
name|ahb_softc
modifier|*
name|ahb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahbreset
parameter_list|(
name|struct
name|ahb_softc
modifier|*
name|ahb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahbmapecbs
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahbxptattach
parameter_list|(
name|struct
name|ahb_softc
modifier|*
name|ahb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahbhandleimmed
parameter_list|(
name|struct
name|ahb_softc
modifier|*
name|ahb
parameter_list|,
name|u_int32_t
name|mbox
parameter_list|,
name|u_int
name|intstat
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahbcalcresid
parameter_list|(
name|struct
name|ahb_softc
modifier|*
name|ahb
parameter_list|,
name|struct
name|ecb
modifier|*
name|ecb
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahbdone
parameter_list|(
name|struct
name|ahb_softc
modifier|*
name|ahb
parameter_list|,
name|u_int32_t
name|mbox
parameter_list|,
name|u_int
name|intstat
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahbintr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|bus_dmamap_callback_t
name|ahbexecuteecb
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|ahbaction
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahbpoll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Our timeout handler */
end_comment

begin_decl_stmt
specifier|static
name|timeout_t
name|ahbtimeout
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|ecb
operator|*
name|ahbecbget
argument_list|(
expr|struct
name|ahb_softc
operator|*
name|ahb
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|__inline
name|void
name|ahbecbfree
parameter_list|(
name|struct
name|ahb_softc
modifier|*
name|ahb
parameter_list|,
name|struct
name|ecb
modifier|*
name|ecb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|u_int32_t
name|ahbecbvtop
parameter_list|(
name|struct
name|ahb_softc
modifier|*
name|ahb
parameter_list|,
name|struct
name|ecb
modifier|*
name|ecb
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|ecb
operator|*
name|ahbecbptov
argument_list|(
argument|struct ahb_softc *ahb
argument_list|,
argument|u_int32_t ecb_addr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|__inline
name|u_int32_t
name|ahbstatuspaddr
parameter_list|(
name|u_int32_t
name|ecb_paddr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|u_int32_t
name|ahbsensepaddr
parameter_list|(
name|u_int32_t
name|ecb_paddr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|u_int32_t
name|ahbsgpaddr
parameter_list|(
name|u_int32_t
name|ecb_paddr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ahbqueuembox
parameter_list|(
name|struct
name|ahb_softc
modifier|*
name|ahb
parameter_list|,
name|u_int32_t
name|mboxval
parameter_list|,
name|u_int
name|attn_code
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|ecb
operator|*
name|ahbecbget
argument_list|(
argument|struct ahb_softc *ahb
argument_list|)
block|{ 	struct
name|ecb
operator|*
name|ecb
block|;
name|int
name|s
block|;
name|s
operator|=
name|splcam
argument_list|()
block|;
if|if
condition|(
operator|(
name|ecb
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|ahb
operator|->
name|free_ecbs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|ahb
operator|->
name|free_ecbs
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|ecb
operator|)
return|;
end_return

begin_function
unit|}  static
name|__inline
name|void
name|ahbecbfree
parameter_list|(
name|struct
name|ahb_softc
modifier|*
name|ahb
parameter_list|,
name|struct
name|ecb
modifier|*
name|ecb
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|ecb
operator|->
name|state
operator|=
name|ECB_FREE
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|ahb
operator|->
name|free_ecbs
argument_list|,
name|ecb
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u_int32_t
name|ahbecbvtop
parameter_list|(
name|struct
name|ahb_softc
modifier|*
name|ahb
parameter_list|,
name|struct
name|ecb
modifier|*
name|ecb
parameter_list|)
block|{
return|return
operator|(
name|ahb
operator|->
name|ecb_physbase
operator|+
call|(
name|u_int32_t
call|)
argument_list|(
operator|(
name|caddr_t
operator|)
name|ecb
operator|-
operator|(
name|caddr_t
operator|)
name|ahb
operator|->
name|ecb_array
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|ecb
operator|*
name|ahbecbptov
argument_list|(
argument|struct ahb_softc *ahb
argument_list|,
argument|u_int32_t ecb_addr
argument_list|)
block|{
return|return
operator|(
name|ahb
operator|->
name|ecb_array
operator|+
operator|(
operator|(
expr|struct
name|ecb
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|ecb_addr
operator|-
operator|(
expr|struct
name|ecb
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|ahb
operator|->
name|ecb_physbase
operator|)
operator|)
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|__inline
name|u_int32_t
name|ahbstatuspaddr
parameter_list|(
name|u_int32_t
name|ecb_paddr
parameter_list|)
block|{
return|return
operator|(
name|ecb_paddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|ecb
argument_list|,
name|status
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u_int32_t
name|ahbsensepaddr
parameter_list|(
name|u_int32_t
name|ecb_paddr
parameter_list|)
block|{
return|return
operator|(
name|ecb_paddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|ecb
argument_list|,
name|sense
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u_int32_t
name|ahbsgpaddr
parameter_list|(
name|u_int32_t
name|ecb_paddr
parameter_list|)
block|{
return|return
operator|(
name|ecb_paddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|ecb
argument_list|,
name|sg_list
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ahbqueuembox
parameter_list|(
name|struct
name|ahb_softc
modifier|*
name|ahb
parameter_list|,
name|u_int32_t
name|mboxval
parameter_list|,
name|u_int
name|attn_code
parameter_list|)
block|{
name|u_int
name|loopmax
init|=
literal|300
decl_stmt|;
while|while
condition|(
operator|--
name|loopmax
condition|)
block|{
name|u_int
name|status
decl_stmt|;
name|status
operator|=
name|ahb_inb
argument_list|(
name|ahb
argument_list|,
name|HOSTSTAT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|HOSTSTAT_MBOX_EMPTY
operator||
name|HOSTSTAT_BUSY
operator|)
operator|)
operator|==
name|HOSTSTAT_MBOX_EMPTY
condition|)
break|break;
name|DELAY
argument_list|(
literal|20
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|loopmax
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"ahb%ld: adapter not taking commands\n"
argument_list|,
name|ahb
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ahb_outl
argument_list|(
name|ahb
argument_list|,
name|MBOXOUT0
argument_list|,
name|mboxval
argument_list|)
expr_stmt|;
name|ahb_outb
argument_list|(
name|ahb
argument_list|,
name|ATTN
argument_list|,
name|attn_code
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ahbmatch
parameter_list|(
name|eisa_id_t
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
operator|&
literal|0xfffffe00
condition|)
block|{
case|case
name|EISA_DEVICE_ID_ADAPTEC_1740
case|:
return|return
operator|(
literal|"Adaptec 174x SCSI host adapter"
operator|)
return|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahbprobe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|desc
decl_stmt|;
name|u_int32_t
name|iobase
decl_stmt|;
name|u_int32_t
name|irq
decl_stmt|;
name|u_int8_t
name|intdef
decl_stmt|;
name|int
name|shared
decl_stmt|;
name|desc
operator|=
name|ahbmatch
argument_list|(
name|eisa_get_id
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|desc
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|desc
argument_list|)
expr_stmt|;
name|iobase
operator|=
operator|(
name|eisa_get_slot
argument_list|(
name|dev
argument_list|)
operator|*
name|EISA_SLOT_SIZE
operator|)
operator|+
name|AHB_EISA_SLOT_OFFSET
expr_stmt|;
name|eisa_add_iospace
argument_list|(
name|dev
argument_list|,
name|iobase
argument_list|,
name|AHB_EISA_IOSIZE
argument_list|,
name|RESVADDR_NONE
argument_list|)
expr_stmt|;
name|intdef
operator|=
name|inb
argument_list|(
name|INTDEF
operator|+
name|iobase
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|intdef
operator|&
literal|0x7
condition|)
block|{
case|case
name|INT9
case|:
name|irq
operator|=
literal|9
expr_stmt|;
break|break;
case|case
name|INT10
case|:
name|irq
operator|=
literal|10
expr_stmt|;
break|break;
case|case
name|INT11
case|:
name|irq
operator|=
literal|11
expr_stmt|;
break|break;
case|case
name|INT12
case|:
name|irq
operator|=
literal|12
expr_stmt|;
break|break;
case|case
name|INT14
case|:
name|irq
operator|=
literal|14
expr_stmt|;
break|break;
case|case
name|INT15
case|:
name|irq
operator|=
literal|15
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Adaptec 174X at slot %d: illegal "
literal|"irq setting %d\n"
argument_list|,
name|eisa_get_slot
argument_list|(
name|dev
argument_list|)
argument_list|,
operator|(
name|intdef
operator|&
literal|0x7
operator|)
argument_list|)
expr_stmt|;
name|irq
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|irq
operator|==
literal|0
condition|)
return|return
name|ENXIO
return|;
name|shared
operator|=
operator|(
name|inb
argument_list|(
name|INTDEF
operator|+
name|iobase
argument_list|)
operator|&
name|INTLEVEL
operator|)
condition|?
name|EISA_TRIGGER_LEVEL
else|:
name|EISA_TRIGGER_EDGE
expr_stmt|;
name|eisa_add_intr
argument_list|(
name|dev
argument_list|,
name|irq
argument_list|,
name|shared
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahbattach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
comment|/* 	 * find unit and check we have that many defined 	 */
name|struct
name|ahb_softc
modifier|*
name|ahb
decl_stmt|;
name|struct
name|ecb
modifier|*
name|next_ecb
decl_stmt|;
name|struct
name|resource
modifier|*
name|io
init|=
literal|0
decl_stmt|;
name|struct
name|resource
modifier|*
name|irq
init|=
literal|0
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|void
modifier|*
name|ih
decl_stmt|;
name|rid
operator|=
literal|0
expr_stmt|;
name|io
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|io
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"No I/O space?!\n"
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
if|if
condition|(
operator|(
name|ahb
operator|=
name|ahballoc
argument_list|(
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|io
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
goto|goto
name|error_exit2
goto|;
block|}
if|if
condition|(
name|ahbreset
argument_list|(
name|ahb
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error_exit
goto|;
name|rid
operator|=
literal|0
expr_stmt|;
name|irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|irq
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Can't allocate interrupt\n"
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
comment|/* 	 * Create our DMA tags.  These tags define the kinds of device 	 * accessible memory allocations and memory mappings we will  	 * need to perform during normal operation. 	 */
comment|/* DMA tag for mapping buffers into device visible space. */
comment|/* XXX Should be a child of the EISA bus dma tag */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/* parent	*/
name|NULL
argument_list|,
comment|/* alignment	*/
literal|1
argument_list|,
comment|/* boundary	*/
literal|0
argument_list|,
comment|/* lowaddr	*/
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* highaddr	*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* filter	*/
name|NULL
argument_list|,
comment|/* filterarg	*/
name|NULL
argument_list|,
comment|/* maxsize	*/
name|MAXBSIZE
argument_list|,
comment|/* nsegments	*/
name|AHB_NSEG
argument_list|,
comment|/* maxsegsz	*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* flags	*/
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* lockfunc	*/
name|busdma_lock_mutex
argument_list|,
comment|/* lockarg	*/
operator|&
name|Giant
argument_list|,
operator|&
name|ahb
operator|->
name|buffer_dmat
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error_exit
goto|;
name|ahb
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* DMA tag for our ccb structures and ha inquiry data */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/* parent	*/
name|NULL
argument_list|,
comment|/* alignment	*/
literal|1
argument_list|,
comment|/* boundary	*/
literal|0
argument_list|,
comment|/* lowaddr	*/
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* highaddr	*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* filter	*/
name|NULL
argument_list|,
comment|/* filterarg	*/
name|NULL
argument_list|,
comment|/* maxsize	*/
operator|(
name|AHB_NECB
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ecb
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ahb
operator|->
name|ha_inq_data
argument_list|)
argument_list|,
comment|/* nsegments	*/
literal|1
argument_list|,
comment|/* maxsegsz	*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* flags	*/
literal|0
argument_list|,
comment|/* lockfunc	*/
name|busdma_lock_mutex
argument_list|,
comment|/* lockarg	*/
operator|&
name|Giant
argument_list|,
operator|&
name|ahb
operator|->
name|ecb_dmat
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error_exit
goto|;
name|ahb
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* Allocation for our ccbs */
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|ahb
operator|->
name|ecb_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ahb
operator|->
name|ecb_array
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|ahb
operator|->
name|ecb_dmamap
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error_exit
goto|;
name|ahb
operator|->
name|ha_inq_data
operator|=
operator|(
expr|struct
name|ha_inquiry_data
operator|*
operator|)
operator|&
name|ahb
operator|->
name|ecb_array
index|[
name|AHB_NECB
index|]
expr_stmt|;
name|ahb
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* And permanently map them */
name|bus_dmamap_load
argument_list|(
name|ahb
operator|->
name|ecb_dmat
argument_list|,
name|ahb
operator|->
name|ecb_dmamap
argument_list|,
name|ahb
operator|->
name|ecb_array
argument_list|,
name|AHB_NSEG
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ecb
argument_list|)
argument_list|,
name|ahbmapecbs
argument_list|,
name|ahb
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
name|ahb
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* Allocate the buffer dmamaps for each of our ECBs */
name|bzero
argument_list|(
name|ahb
operator|->
name|ecb_array
argument_list|,
operator|(
name|AHB_NECB
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ecb
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ahb
operator|->
name|ha_inq_data
argument_list|)
argument_list|)
expr_stmt|;
name|next_ecb
operator|=
name|ahb
operator|->
name|ecb_array
expr_stmt|;
while|while
condition|(
name|ahb
operator|->
name|num_ecbs
operator|<
name|AHB_NECB
condition|)
block|{
name|u_int32_t
name|ecb_paddr
decl_stmt|;
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|ahb
operator|->
name|buffer_dmat
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
operator|&
name|next_ecb
operator|->
name|dmamap
argument_list|)
condition|)
break|break;
name|ecb_paddr
operator|=
name|ahbecbvtop
argument_list|(
name|ahb
argument_list|,
name|next_ecb
argument_list|)
expr_stmt|;
name|next_ecb
operator|->
name|hecb
operator|.
name|status_ptr
operator|=
name|ahbstatuspaddr
argument_list|(
name|ecb_paddr
argument_list|)
expr_stmt|;
name|next_ecb
operator|->
name|hecb
operator|.
name|sense_ptr
operator|=
name|ahbsensepaddr
argument_list|(
name|ecb_paddr
argument_list|)
expr_stmt|;
name|ahb
operator|->
name|num_ecbs
operator|++
expr_stmt|;
name|ahbecbfree
argument_list|(
name|ahb
argument_list|,
name|next_ecb
argument_list|)
expr_stmt|;
name|next_ecb
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ahb
operator|->
name|num_ecbs
operator|==
literal|0
condition|)
goto|goto
name|error_exit
goto|;
name|ahb
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* 	 * Now that we know we own the resources we need, register 	 * our bus with the XPT. 	 */
if|if
condition|(
name|ahbxptattach
argument_list|(
name|ahb
argument_list|)
condition|)
goto|goto
name|error_exit
goto|;
comment|/* Enable our interrupt */
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|irq
argument_list|,
name|INTR_TYPE_CAM
operator||
name|INTR_ENTROPY
argument_list|,
name|NULL
argument_list|,
name|ahbintr
argument_list|,
name|ahb
argument_list|,
operator|&
name|ih
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|error_exit
label|:
comment|/* 	 * The board's IRQ line will not be left enabled 	 * if we can't intialize correctly, so its safe 	 * to release the irq. 	 */
name|ahbfree
argument_list|(
name|ahb
argument_list|)
expr_stmt|;
name|error_exit2
label|:
if|if
condition|(
name|io
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|,
name|io
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|irq
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ahb_softc
modifier|*
name|ahballoc
parameter_list|(
name|u_long
name|unit
parameter_list|,
name|struct
name|resource
modifier|*
name|res
parameter_list|)
block|{
name|struct
name|ahb_softc
modifier|*
name|ahb
decl_stmt|;
comment|/* 	 * Allocate a storage area for us 	 */
name|ahb
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ahb_softc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ahb
condition|)
block|{
name|printf
argument_list|(
literal|"ahb%ld: cannot malloc!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|SLIST_INIT
argument_list|(
operator|&
name|ahb
operator|->
name|free_ecbs
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|ahb
operator|->
name|pending_ccbs
argument_list|)
expr_stmt|;
name|ahb
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|ahb
operator|->
name|tag
operator|=
name|rman_get_bustag
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|ahb
operator|->
name|bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|ahb
operator|->
name|disc_permitted
operator|=
operator|~
literal|0
expr_stmt|;
name|ahb
operator|->
name|tags_permitted
operator|=
operator|~
literal|0
expr_stmt|;
return|return
operator|(
name|ahb
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahbfree
parameter_list|(
name|struct
name|ahb_softc
modifier|*
name|ahb
parameter_list|)
block|{
switch|switch
condition|(
name|ahb
operator|->
name|init_level
condition|)
block|{
default|default:
case|case
literal|4
case|:
name|bus_dmamap_unload
argument_list|(
name|ahb
operator|->
name|ecb_dmat
argument_list|,
name|ahb
operator|->
name|ecb_dmamap
argument_list|)
expr_stmt|;
case|case
literal|3
case|:
name|bus_dmamem_free
argument_list|(
name|ahb
operator|->
name|ecb_dmat
argument_list|,
name|ahb
operator|->
name|ecb_array
argument_list|,
name|ahb
operator|->
name|ecb_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|ahb
operator|->
name|ecb_dmat
argument_list|,
name|ahb
operator|->
name|ecb_dmamap
argument_list|)
expr_stmt|;
case|case
literal|2
case|:
name|bus_dma_tag_destroy
argument_list|(
name|ahb
operator|->
name|ecb_dmat
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
name|bus_dma_tag_destroy
argument_list|(
name|ahb
operator|->
name|buffer_dmat
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
break|break;
block|}
name|free
argument_list|(
name|ahb
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * reset board, If it doesn't respond, return failure  */
end_comment

begin_function
specifier|static
name|int
name|ahbreset
parameter_list|(
name|struct
name|ahb_softc
modifier|*
name|ahb
parameter_list|)
block|{
name|int
name|wait
init|=
literal|1000
decl_stmt|;
comment|/* 1 sec enough? */
name|int
name|test
decl_stmt|;
if|if
condition|(
operator|(
name|ahb_inb
argument_list|(
name|ahb
argument_list|,
name|PORTADDR
argument_list|)
operator|&
name|PORTADDR_ENHANCED
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ahb_reset: Controller not in enhanced mode\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ahb_outb
argument_list|(
name|ahb
argument_list|,
name|CONTROL
argument_list|,
name|CNTRL_HARD_RST
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|ahb_outb
argument_list|(
name|ahb
argument_list|,
name|CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|wait
condition|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahb_inb
argument_list|(
name|ahb
argument_list|,
name|HOSTSTAT
argument_list|)
operator|&
name|HOSTSTAT_BUSY
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|wait
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ahbreset: No answer from aha1742 board\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|test
operator|=
name|ahb_inb
argument_list|(
name|ahb
argument_list|,
name|MBOXIN0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ahb_reset: self test failed, val = 0x%x\n"
argument_list|,
name|test
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
while|while
condition|(
name|ahb_inb
argument_list|(
name|ahb
argument_list|,
name|HOSTSTAT
argument_list|)
operator|&
name|HOSTSTAT_INTPEND
condition|)
block|{
name|ahb_outb
argument_list|(
name|ahb
argument_list|,
name|CONTROL
argument_list|,
name|CNTRL_CLRINT
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahbmapecbs
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|ahb_softc
modifier|*
name|ahb
decl_stmt|;
name|ahb
operator|=
operator|(
expr|struct
name|ahb_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|ahb
operator|->
name|ecb_physbase
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
comment|/* 	 * Space for adapter inquiry information is on the 	 * tail of the ecb array. 	 */
name|ahb
operator|->
name|ha_inq_physbase
operator|=
name|ahbecbvtop
argument_list|(
name|ahb
argument_list|,
operator|&
name|ahb
operator|->
name|ecb_array
index|[
name|AHB_NECB
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahbxptattach
parameter_list|(
name|struct
name|ahb_softc
modifier|*
name|ahb
parameter_list|)
block|{
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|struct
name|ecb
modifier|*
name|ecb
decl_stmt|;
name|u_int
name|i
decl_stmt|;
comment|/* Remeber who are we on the scsi bus */
name|ahb
operator|->
name|scsi_id
operator|=
name|ahb_inb
argument_list|(
name|ahb
argument_list|,
name|SCSIDEF
argument_list|)
operator|&
name|HSCSIID
expr_stmt|;
comment|/* Use extended translation?? */
name|ahb
operator|->
name|extended_trans
operator|=
name|ahb_inb
argument_list|(
name|ahb
argument_list|,
name|RESV1
argument_list|)
operator|&
name|EXTENDED_TRANS
expr_stmt|;
comment|/* Fetch adapter inquiry data */
name|ecb
operator|=
name|ahbecbget
argument_list|(
name|ahb
argument_list|)
expr_stmt|;
comment|/* Always succeeds - no outstanding commands */
name|ecb
operator|->
name|hecb
operator|.
name|opcode
operator|=
name|ECBOP_READ_HA_INQDATA
expr_stmt|;
name|ecb
operator|->
name|hecb
operator|.
name|flag_word1
operator|=
name|FW1_SUPPRESS_URUN_ERR
operator||
name|FW1_ERR_STATUS_BLK_ONLY
expr_stmt|;
name|ecb
operator|->
name|hecb
operator|.
name|data_ptr
operator|=
name|ahb
operator|->
name|ha_inq_physbase
expr_stmt|;
name|ecb
operator|->
name|hecb
operator|.
name|data_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ha_inquiry_data
argument_list|)
expr_stmt|;
name|ecb
operator|->
name|hecb
operator|.
name|sense_ptr
operator|=
literal|0
expr_stmt|;
name|ecb
operator|->
name|state
operator|=
name|ECB_ACTIVE
expr_stmt|;
comment|/* Tell the adapter about this command */
name|ahbqueuembox
argument_list|(
name|ahb
argument_list|,
name|ahbecbvtop
argument_list|(
name|ahb
argument_list|,
name|ecb
argument_list|)
argument_list|,
name|ATTN_STARTECB
operator||
name|ahb
operator|->
name|scsi_id
argument_list|)
expr_stmt|;
comment|/* Poll for interrupt completion */
for|for
control|(
name|i
operator|=
literal|1000
init|;
name|ecb
operator|->
name|state
operator|!=
name|ECB_FREE
operator|&&
name|i
operator|!=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|ahbintr
argument_list|(
name|ahb
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
name|ahb
operator|->
name|num_ecbs
operator|=
name|MIN
argument_list|(
name|ahb
operator|->
name|num_ecbs
argument_list|,
name|ahb
operator|->
name|ha_inq_data
operator|->
name|scsi_data
operator|.
name|spc2_flags
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ahb%ld: %.8s %s SCSI Adapter, FW Rev. %.4s, ID=%d, %d ECBs\n"
argument_list|,
name|ahb
operator|->
name|unit
argument_list|,
name|ahb
operator|->
name|ha_inq_data
operator|->
name|scsi_data
operator|.
name|product
argument_list|,
operator|(
name|ahb
operator|->
name|ha_inq_data
operator|->
name|scsi_data
operator|.
name|flags
operator|&
literal|0x4
operator|)
condition|?
literal|"Differential"
else|:
literal|"Single Ended"
argument_list|,
name|ahb
operator|->
name|ha_inq_data
operator|->
name|scsi_data
operator|.
name|revision
argument_list|,
name|ahb
operator|->
name|scsi_id
argument_list|,
name|ahb
operator|->
name|num_ecbs
argument_list|)
expr_stmt|;
comment|/* Restore sense paddr for future CCB clients */
name|ecb
operator|->
name|hecb
operator|.
name|sense_ptr
operator|=
name|ahbsensepaddr
argument_list|(
name|ahbecbvtop
argument_list|(
name|ahb
argument_list|,
name|ecb
argument_list|)
argument_list|)
expr_stmt|;
name|ahbecbfree
argument_list|(
name|ahb
argument_list|,
name|ecb
argument_list|)
expr_stmt|;
comment|/* 	 * Create the device queue for our SIM. 	 */
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
name|ahb
operator|->
name|num_ecbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|devq
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* 	 * Construct our SIM entry 	 */
name|ahb
operator|->
name|sim
operator|=
name|cam_sim_alloc
argument_list|(
name|ahbaction
argument_list|,
name|ahbpoll
argument_list|,
literal|"ahb"
argument_list|,
name|ahb
argument_list|,
name|ahb
operator|->
name|unit
argument_list|,
literal|2
argument_list|,
name|ahb
operator|->
name|num_ecbs
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahb
operator|->
name|sim
operator|==
name|NULL
condition|)
block|{
name|cam_simq_free
argument_list|(
name|devq
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|ahb
operator|->
name|sim
argument_list|,
literal|0
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|cam_sim_free
argument_list|(
name|ahb
operator|->
name|sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|ahb
operator|->
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|ahb
operator|->
name|sim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|ahb
operator|->
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|ahb
operator|->
name|sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * Allow the board to generate interrupts. 	 */
name|ahb_outb
argument_list|(
name|ahb
argument_list|,
name|INTDEF
argument_list|,
name|ahb_inb
argument_list|(
name|ahb
argument_list|,
name|INTDEF
argument_list|)
operator||
name|INTEN
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahbhandleimmed
parameter_list|(
name|struct
name|ahb_softc
modifier|*
name|ahb
parameter_list|,
name|u_int32_t
name|mbox
parameter_list|,
name|u_int
name|intstat
parameter_list|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|u_int
name|target_id
decl_stmt|;
if|if
condition|(
name|ahb
operator|->
name|immed_cmd
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ahb%ld: Immediate Command complete with no "
literal|" pending command\n"
argument_list|,
name|ahb
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|target_id
operator|=
name|intstat
operator|&
name|INTSTAT_TARGET_MASK
expr_stmt|;
name|ccb_h
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|ahb
operator|->
name|pending_ccbs
argument_list|)
expr_stmt|;
while|while
condition|(
name|ccb_h
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ecb
modifier|*
name|pending_ecb
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|pending_ecb
operator|=
operator|(
expr|struct
name|ecb
operator|*
operator|)
name|ccb_h
operator|->
name|ccb_ecb_ptr
expr_stmt|;
name|ccb
operator|=
name|pending_ecb
operator|->
name|ccb
expr_stmt|;
name|ccb_h
operator|=
name|LIST_NEXT
argument_list|(
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|le
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|==
name|target_id
operator|||
name|target_id
operator|==
name|ahb
operator|->
name|scsi_id
condition|)
block|{
name|untimeout
argument_list|(
name|ahbtimeout
argument_list|,
name|pending_ecb
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|le
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
name|bus_dmamap_unload
argument_list|(
name|ahb
operator|->
name|buffer_dmat
argument_list|,
name|pending_ecb
operator|->
name|dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_ecb
operator|==
name|ahb
operator|->
name|immed_ecb
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_CMD_TIMEOUT
operator||
name|CAM_RELEASE_SIMQ
expr_stmt|;
elseif|else
if|if
condition|(
name|target_id
operator|==
name|ahb
operator|->
name|scsi_id
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SCSI_BUS_RESET
expr_stmt|;
else|else
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_BDR_SENT
expr_stmt|;
name|ahbecbfree
argument_list|(
name|ahb
argument_list|,
name|pending_ecb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ahb
operator|->
name|immed_ecb
operator|!=
name|NULL
condition|)
block|{
comment|/* Re-instate timeout */
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|ahbtimeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|pending_ecb
argument_list|,
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ahb
operator|->
name|immed_ecb
operator|!=
name|NULL
condition|)
block|{
name|ahb
operator|->
name|immed_ecb
operator|=
name|NULL
expr_stmt|;
name|printf
argument_list|(
literal|"ahb%ld: No longer in timeout\n"
argument_list|,
name|ahb
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|target_id
operator|==
name|ahb
operator|->
name|scsi_id
condition|)
name|printf
argument_list|(
literal|"ahb%ld: SCSI Bus Reset Delivered\n"
argument_list|,
name|ahb
operator|->
name|unit
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"ahb%ld:  Bus Device Reset Delibered to target %d\n"
argument_list|,
name|ahb
operator|->
name|unit
argument_list|,
name|target_id
argument_list|)
expr_stmt|;
name|ahb
operator|->
name|immed_cmd
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahbcalcresid
parameter_list|(
name|struct
name|ahb_softc
modifier|*
name|ahb
parameter_list|,
name|struct
name|ecb
modifier|*
name|ecb
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
if|if
condition|(
name|ecb
operator|->
name|status
operator|.
name|data_overrun
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Overrun Condition.  The hardware doesn't 		 * provide a meaningful byte count in this case 		 * (the residual is always 0).  Tell the XPT 		 * layer about the error. 		 */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_DATA_RUN_ERR
expr_stmt|;
block|}
else|else
block|{
name|ccb
operator|->
name|csio
operator|.
name|resid
operator|=
name|ecb
operator|->
name|status
operator|.
name|resid_count
expr_stmt|;
if|if
condition|(
operator|(
name|ecb
operator|->
name|hecb
operator|.
name|flag_word1
operator|&
name|FW1_SG_ECB
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * For S/G transfers, the adapter provides a pointer 			 * to the address in the last S/G element used and a 			 * residual for that element.  So, we need to sum up 			 * the elements that follow it in order to get a real 			 * residual number.  If we have an overrun, the residual 			 * reported will be 0 and we already know that all S/G 			 * segments have been exhausted, so we can skip this 			 * step. 			 */
name|ahb_sg_t
modifier|*
name|sg
decl_stmt|;
name|int
name|num_sg
decl_stmt|;
name|num_sg
operator|=
name|ecb
operator|->
name|hecb
operator|.
name|data_len
operator|/
sizeof|sizeof
argument_list|(
name|ahb_sg_t
argument_list|)
expr_stmt|;
comment|/* Find the S/G the adapter was working on */
for|for
control|(
name|sg
operator|=
name|ecb
operator|->
name|sg_list
init|;
name|num_sg
operator|!=
literal|0
operator|&&
name|sg
operator|->
name|addr
operator|!=
name|ecb
operator|->
name|status
operator|.
name|resid_addr
condition|;
name|num_sg
operator|--
operator|,
name|sg
operator|++
control|)
empty_stmt|;
comment|/* Skip it */
name|num_sg
operator|--
expr_stmt|;
name|sg
operator|++
expr_stmt|;
comment|/* Sum the rest */
for|for
control|(
init|;
name|num_sg
operator|!=
literal|0
condition|;
name|num_sg
operator|--
operator|,
name|sg
operator|++
control|)
name|ccb
operator|->
name|csio
operator|.
name|resid
operator|+=
name|sg
operator|->
name|len
expr_stmt|;
block|}
comment|/* Underruns are not errors */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahbprocesserror
parameter_list|(
name|struct
name|ahb_softc
modifier|*
name|ahb
parameter_list|,
name|struct
name|ecb
modifier|*
name|ecb
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|hardware_ecb
modifier|*
name|hecb
decl_stmt|;
name|struct
name|ecb_status
modifier|*
name|status
decl_stmt|;
name|hecb
operator|=
operator|&
name|ecb
operator|->
name|hecb
expr_stmt|;
name|status
operator|=
operator|&
name|ecb
operator|->
name|status
expr_stmt|;
switch|switch
condition|(
name|status
operator|->
name|ha_status
condition|)
block|{
case|case
name|HS_OK
case|:
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|status
operator|->
name|scsi_status
expr_stmt|;
if|if
condition|(
name|status
operator|->
name|scsi_status
operator|!=
literal|0
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SCSI_STATUS_ERROR
expr_stmt|;
if|if
condition|(
name|status
operator|->
name|sense_stored
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_AUTOSNS_VALID
expr_stmt|;
name|ccb
operator|->
name|csio
operator|.
name|sense_resid
operator|=
name|ccb
operator|->
name|csio
operator|.
name|sense_len
operator|-
name|status
operator|->
name|sense_len
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|ecb
operator|->
name|sense
argument_list|,
operator|&
name|ccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|,
name|status
operator|->
name|sense_len
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|HS_TARGET_NOT_ASSIGNED
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_PATH_INVALID
expr_stmt|;
break|break;
case|case
name|HS_SEL_TIMEOUT
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SEL_TIMEOUT
expr_stmt|;
break|break;
case|case
name|HS_DATA_RUN_ERR
case|:
name|ahbcalcresid
argument_list|(
name|ahb
argument_list|,
name|ecb
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|HS_UNEXPECTED_BUSFREE
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_UNEXP_BUSFREE
expr_stmt|;
break|break;
case|case
name|HS_INVALID_PHASE
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SEQUENCE_FAIL
expr_stmt|;
break|break;
case|case
name|HS_REQUEST_SENSE_FAILED
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_AUTOSENSE_FAIL
expr_stmt|;
break|break;
case|case
name|HS_TAG_MSG_REJECTED
case|:
block|{
name|struct
name|ccb_trans_settings
name|neg
decl_stmt|;
name|struct
name|ccb_trans_settings_scsi
modifier|*
name|scsi
init|=
operator|&
name|neg
operator|.
name|proto_specific
operator|.
name|scsi
decl_stmt|;
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"refuses tagged commands.  Performing "
literal|"non-tagged I/O\n"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|neg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|neg
argument_list|)
argument_list|)
expr_stmt|;
name|neg
operator|.
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|neg
operator|.
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|neg
operator|.
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|neg
operator|.
name|transport_version
operator|=
literal|2
expr_stmt|;
name|scsi
operator|->
name|flags
operator|=
name|CTS_SCSI_VALID_TQ
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|neg
operator|.
name|ccb_h
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_TRANSFER_NEG
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
operator|&
name|neg
argument_list|)
expr_stmt|;
name|ahb
operator|->
name|tags_permitted
operator|&=
operator|~
operator|(
literal|0x01
operator|<<
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_MSG_REJECT_REC
expr_stmt|;
break|break;
block|}
case|case
name|HS_FIRMWARE_LOAD_REQ
case|:
case|case
name|HS_HARDWARE_ERR
case|:
comment|/* 		 * Tell the system that the Adapter 		 * is no longer functional. 		 */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_NO_HBA
expr_stmt|;
break|break;
case|case
name|HS_CMD_ABORTED_HOST
case|:
case|case
name|HS_CMD_ABORTED_ADAPTER
case|:
case|case
name|HS_ATN_TARGET_FAILED
case|:
case|case
name|HS_SCSI_RESET_ADAPTER
case|:
case|case
name|HS_SCSI_RESET_INCOMING
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SCSI_BUS_RESET
expr_stmt|;
break|break;
case|case
name|HS_INVALID_ECB_PARAM
case|:
name|printf
argument_list|(
literal|"ahb%ld: opcode 0x%02x, flag_word1 0x%02x, flag_word2 0x%02x\n"
argument_list|,
name|ahb
operator|->
name|unit
argument_list|,
name|hecb
operator|->
name|opcode
argument_list|,
name|hecb
operator|->
name|flag_word1
argument_list|,
name|hecb
operator|->
name|flag_word2
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SCSI_BUS_RESET
expr_stmt|;
break|break;
case|case
name|HS_DUP_TCB_RECEIVED
case|:
case|case
name|HS_INVALID_OPCODE
case|:
case|case
name|HS_INVALID_CMD_LINK
case|:
case|case
name|HS_PROGRAM_CKSUM_ERROR
case|:
name|panic
argument_list|(
literal|"ahb%ld: Can't happen host status %x occurred"
argument_list|,
name|ahb
operator|->
name|unit
argument_list|,
name|status
operator|->
name|ha_status
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_freeze_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_QFRZN
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahbdone
parameter_list|(
name|struct
name|ahb_softc
modifier|*
name|ahb
parameter_list|,
name|u_int32_t
name|mbox
parameter_list|,
name|u_int
name|intstat
parameter_list|)
block|{
name|struct
name|ecb
modifier|*
name|ecb
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|ecb
operator|=
name|ahbecbptov
argument_list|(
name|ahb
argument_list|,
name|mbox
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ecb
operator|->
name|state
operator|&
name|ECB_ACTIVE
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"ecb not active"
argument_list|)
expr_stmt|;
name|ccb
operator|=
name|ecb
operator|->
name|ccb
expr_stmt|;
if|if
condition|(
name|ccb
operator|!=
name|NULL
condition|)
block|{
name|untimeout
argument_list|(
name|ahbtimeout
argument_list|,
name|ecb
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|le
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
name|bus_dmasync_op_t
name|op
decl_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
name|op
operator|=
name|BUS_DMASYNC_POSTREAD
expr_stmt|;
else|else
name|op
operator|=
name|BUS_DMASYNC_POSTWRITE
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ahb
operator|->
name|buffer_dmat
argument_list|,
name|ecb
operator|->
name|dmamap
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|ahb
operator|->
name|buffer_dmat
argument_list|,
name|ecb
operator|->
name|dmamap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|intstat
operator|&
name|INTSTAT_MASK
operator|)
operator|==
name|INTSTAT_ECB_OK
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|ccb
operator|->
name|csio
operator|.
name|resid
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ahbprocesserror
argument_list|(
name|ahb
argument_list|,
name|ecb
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
block|}
name|ahbecbfree
argument_list|(
name|ahb
argument_list|,
name|ecb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Non CCB Command */
if|if
condition|(
operator|(
name|intstat
operator|&
name|INTSTAT_MASK
operator|)
operator|!=
name|INTSTAT_ECB_OK
condition|)
block|{
name|printf
argument_list|(
literal|"ahb%ld: Command 0%x Failed %x:%x:%x\n"
argument_list|,
name|ahb
operator|->
name|unit
argument_list|,
name|ecb
operator|->
name|hecb
operator|.
name|opcode
argument_list|,
operator|*
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
operator|&
name|ecb
operator|->
name|status
operator|)
argument_list|,
name|ecb
operator|->
name|status
operator|.
name|ha_status
argument_list|,
name|ecb
operator|->
name|status
operator|.
name|resid_count
argument_list|)
expr_stmt|;
block|}
comment|/* Client owns this ECB and will release it. */
block|}
block|}
end_function

begin_comment
comment|/*  * Catch an interrupt from the adaptor  */
end_comment

begin_function
specifier|static
name|void
name|ahbintr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ahb_softc
modifier|*
name|ahb
decl_stmt|;
name|u_int
name|intstat
decl_stmt|;
name|u_int32_t
name|mbox
decl_stmt|;
name|ahb
operator|=
operator|(
expr|struct
name|ahb_softc
operator|*
operator|)
name|arg
expr_stmt|;
while|while
condition|(
name|ahb_inb
argument_list|(
name|ahb
argument_list|,
name|HOSTSTAT
argument_list|)
operator|&
name|HOSTSTAT_INTPEND
condition|)
block|{
comment|/* 		 * Fetch information about this interrupt. 		 */
name|intstat
operator|=
name|ahb_inb
argument_list|(
name|ahb
argument_list|,
name|INTSTAT
argument_list|)
expr_stmt|;
name|mbox
operator|=
name|ahb_inl
argument_list|(
name|ahb
argument_list|,
name|MBOXIN0
argument_list|)
expr_stmt|;
comment|/* 		 * Reset interrupt latch. 		 */
name|ahb_outb
argument_list|(
name|ahb
argument_list|,
name|CONTROL
argument_list|,
name|CNTRL_CLRINT
argument_list|)
expr_stmt|;
comment|/* 		 * Process the completed operation 		 */
switch|switch
condition|(
name|intstat
operator|&
name|INTSTAT_MASK
condition|)
block|{
case|case
name|INTSTAT_ECB_OK
case|:
case|case
name|INTSTAT_ECB_CMPWRETRY
case|:
case|case
name|INTSTAT_ECB_CMPWERR
case|:
name|ahbdone
argument_list|(
name|ahb
argument_list|,
name|mbox
argument_list|,
name|intstat
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTSTAT_AEN_OCCURED
case|:
if|if
condition|(
operator|(
name|intstat
operator|&
name|INTSTAT_TARGET_MASK
operator|)
operator|==
name|ahb
operator|->
name|scsi_id
condition|)
block|{
comment|/* Bus Reset */
name|xpt_print_path
argument_list|(
name|ahb
operator|->
name|path
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mbox
condition|)
block|{
case|case
name|HS_SCSI_RESET_ADAPTER
case|:
name|printf
argument_list|(
literal|"Host Adapter Initiated "
literal|"Bus Reset occurred\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|HS_SCSI_RESET_INCOMING
case|:
name|printf
argument_list|(
literal|"Bus Reset Initiated "
literal|"by another device occurred\n"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Notify the XPT */
name|xpt_async
argument_list|(
name|AC_BUS_RESET
argument_list|,
name|ahb
operator|->
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"Unsupported initiator selection AEN occured\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTSTAT_IMMED_OK
case|:
case|case
name|INTSTAT_IMMED_ERR
case|:
name|ahbhandleimmed
argument_list|(
name|ahb
argument_list|,
name|mbox
argument_list|,
name|intstat
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTSTAT_HW_ERR
case|:
name|panic
argument_list|(
literal|"Unrecoverable hardware Error Occurred\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahbexecuteecb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|ecb
modifier|*
name|ecb
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|ahb_softc
modifier|*
name|ahb
decl_stmt|;
name|u_int32_t
name|ecb_paddr
decl_stmt|;
name|int
name|s
decl_stmt|;
name|ecb
operator|=
operator|(
expr|struct
name|ecb
operator|*
operator|)
name|arg
expr_stmt|;
name|ccb
operator|=
name|ecb
operator|->
name|ccb
expr_stmt|;
name|ahb
operator|=
operator|(
expr|struct
name|ahb_softc
operator|*
operator|)
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_ahb_ptr
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|!=
name|EFBIG
condition|)
name|printf
argument_list|(
literal|"ahb%ld: Unexepected error 0x%x returned from "
literal|"bus_dmamap_load\n"
argument_list|,
name|ahb
operator|->
name|unit
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|==
name|CAM_REQ_INPROG
condition|)
block|{
name|xpt_freeze_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_TOO_BIG
operator||
name|CAM_DEV_QFRZN
expr_stmt|;
block|}
name|ahbecbfree
argument_list|(
name|ahb
argument_list|,
name|ecb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|ecb_paddr
operator|=
name|ahbecbvtop
argument_list|(
name|ahb
argument_list|,
name|ecb
argument_list|)
expr_stmt|;
if|if
condition|(
name|nseg
operator|!=
literal|0
condition|)
block|{
name|ahb_sg_t
modifier|*
name|sg
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|end_seg
decl_stmt|;
name|bus_dmasync_op_t
name|op
decl_stmt|;
name|end_seg
operator|=
name|dm_segs
operator|+
name|nseg
expr_stmt|;
comment|/* Copy the segments into our SG list */
name|sg
operator|=
name|ecb
operator|->
name|sg_list
expr_stmt|;
while|while
condition|(
name|dm_segs
operator|<
name|end_seg
condition|)
block|{
name|sg
operator|->
name|addr
operator|=
name|dm_segs
operator|->
name|ds_addr
expr_stmt|;
name|sg
operator|->
name|len
operator|=
name|dm_segs
operator|->
name|ds_len
expr_stmt|;
name|sg
operator|++
expr_stmt|;
name|dm_segs
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|nseg
operator|>
literal|1
condition|)
block|{
name|ecb
operator|->
name|hecb
operator|.
name|flag_word1
operator||=
name|FW1_SG_ECB
expr_stmt|;
name|ecb
operator|->
name|hecb
operator|.
name|data_ptr
operator|=
name|ahbsgpaddr
argument_list|(
name|ecb_paddr
argument_list|)
expr_stmt|;
name|ecb
operator|->
name|hecb
operator|.
name|data_len
operator|=
sizeof|sizeof
argument_list|(
name|ahb_sg_t
argument_list|)
operator|*
name|nseg
expr_stmt|;
block|}
else|else
block|{
name|ecb
operator|->
name|hecb
operator|.
name|data_ptr
operator|=
name|ecb
operator|->
name|sg_list
operator|->
name|addr
expr_stmt|;
name|ecb
operator|->
name|hecb
operator|.
name|data_len
operator|=
name|ecb
operator|->
name|sg_list
operator|->
name|len
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
block|{
comment|/*			ecb->hecb.flag_word2 |= FW2_DATA_DIR_IN; */
name|op
operator|=
name|BUS_DMASYNC_PREREAD
expr_stmt|;
block|}
else|else
block|{
name|op
operator|=
name|BUS_DMASYNC_PREWRITE
expr_stmt|;
block|}
comment|/* ecb->hecb.flag_word2 |= FW2_CHECK_DATA_DIR; */
name|bus_dmamap_sync
argument_list|(
name|ahb
operator|->
name|buffer_dmat
argument_list|,
name|ecb
operator|->
name|dmamap
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ecb
operator|->
name|hecb
operator|.
name|data_ptr
operator|=
literal|0
expr_stmt|;
name|ecb
operator|->
name|hecb
operator|.
name|data_len
operator|=
literal|0
expr_stmt|;
block|}
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
comment|/* 	 * Last time we need to check if this CCB needs to 	 * be aborted. 	 */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|!=
name|CAM_REQ_INPROG
condition|)
block|{
if|if
condition|(
name|nseg
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|ahb
operator|->
name|buffer_dmat
argument_list|,
name|ecb
operator|->
name|dmamap
argument_list|)
expr_stmt|;
name|ahbecbfree
argument_list|(
name|ahb
argument_list|,
name|ecb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|ecb
operator|->
name|state
operator|=
name|ECB_ACTIVE
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SIM_QUEUED
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ahb
operator|->
name|pending_ccbs
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|le
argument_list|)
expr_stmt|;
comment|/* Tell the adapter about this command */
name|ahbqueuembox
argument_list|(
name|ahb
argument_list|,
name|ecb_paddr
argument_list|,
name|ATTN_STARTECB
operator||
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|ahbtimeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ecb
argument_list|,
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahbaction
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|ahb_softc
modifier|*
name|ahb
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"ahbaction\n"
operator|)
argument_list|)
expr_stmt|;
name|ahb
operator|=
operator|(
expr|struct
name|ahb_softc
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
comment|/* Common cases first */
case|case
name|XPT_SCSI_IO
case|:
comment|/* Execute the requested I/O operation */
block|{
name|struct
name|ecb
modifier|*
name|ecb
decl_stmt|;
name|struct
name|hardware_ecb
modifier|*
name|hecb
decl_stmt|;
comment|/* 		 * get an ecb to use. 		 */
if|if
condition|(
operator|(
name|ecb
operator|=
name|ahbecbget
argument_list|(
name|ahb
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* Should never occur */
name|panic
argument_list|(
literal|"Failed to get an ecb"
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * So we can find the ECB when an abort is requested 		 */
name|ecb
operator|->
name|ccb
operator|=
name|ccb
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_ecb_ptr
operator|=
name|ecb
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_ahb_ptr
operator|=
name|ahb
expr_stmt|;
comment|/* 		 * Put all the arguments for the xfer in the ecb 		 */
name|hecb
operator|=
operator|&
name|ecb
operator|->
name|hecb
expr_stmt|;
name|hecb
operator|->
name|opcode
operator|=
name|ECBOP_INITIATOR_SCSI_CMD
expr_stmt|;
name|hecb
operator|->
name|flag_word1
operator|=
name|FW1_AUTO_REQUEST_SENSE
operator||
name|FW1_ERR_STATUS_BLK_ONLY
expr_stmt|;
name|hecb
operator|->
name|flag_word2
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator||
name|FW2_NO_RETRY_ON_BUSY
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_TAG_ACTION_VALID
operator|)
operator|!=
literal|0
condition|)
block|{
name|hecb
operator|->
name|flag_word2
operator||=
name|FW2_TAG_ENB
operator||
operator|(
operator|(
name|ccb
operator|->
name|csio
operator|.
name|tag_action
operator|&
literal|0x3
operator|)
operator|<<
name|FW2_TAG_TYPE_SHIFT
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIS_DISCONNECT
operator|)
operator|!=
literal|0
condition|)
name|hecb
operator|->
name|flag_word2
operator||=
name|FW2_DISABLE_DISC
expr_stmt|;
name|hecb
operator|->
name|sense_len
operator|=
name|ccb
operator|->
name|csio
operator|.
name|sense_len
expr_stmt|;
name|hecb
operator|->
name|cdb_len
operator|=
name|ccb
operator|->
name|csio
operator|.
name|cdb_len
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_PHYS
operator|)
operator|==
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_ptr
argument_list|,
name|hecb
operator|->
name|cdb
argument_list|,
name|hecb
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* I guess I could map it in... */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|ahbecbfree
argument_list|(
name|ahb
argument_list|,
name|ecb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|bcopy
argument_list|(
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|hecb
operator|->
name|cdb
argument_list|,
name|hecb
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If we have any data to send with this command, 		 * map it into bus space. 		 */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SCATTER_VALID
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * We've been given a pointer 				 * to a single buffer. 				 */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|s
decl_stmt|;
name|int
name|error
decl_stmt|;
name|s
operator|=
name|splsoftvm
argument_list|()
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|ahb
operator|->
name|buffer_dmat
argument_list|,
name|ecb
operator|->
name|dmamap
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
argument_list|,
name|ahbexecuteecb
argument_list|,
name|ecb
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
block|{
comment|/* 						 * So as to maintain ordering, 						 * freeze the controller queue 						 * until our mapping is 						 * returned. 						 */
name|xpt_freeze_simq
argument_list|(
name|ahb
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|bus_dma_segment
name|seg
decl_stmt|;
comment|/* Pointer to physical buffer */
name|seg
operator|.
name|ds_addr
operator|=
operator|(
name|bus_addr_t
operator|)
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
expr_stmt|;
name|seg
operator|.
name|ds_len
operator|=
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
expr_stmt|;
name|ahbexecuteecb
argument_list|(
name|ecb
argument_list|,
operator|&
name|seg
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|struct
name|bus_dma_segment
modifier|*
name|segs
decl_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"ahbaction - Physical segment "
literal|"pointers unsupported"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SG_LIST_PHYS
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"btaction - Virtual segment "
literal|"addresses unsupported"
argument_list|)
expr_stmt|;
comment|/* Just use the segments provided */
name|segs
operator|=
operator|(
expr|struct
name|bus_dma_segment
operator|*
operator|)
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
expr_stmt|;
name|ahbexecuteecb
argument_list|(
name|ecb
argument_list|,
name|segs
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|sglist_cnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ahbexecuteecb
argument_list|(
name|ecb
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|XPT_EN_LUN
case|:
comment|/* Enable LUN as a target */
case|case
name|XPT_TARGET_IO
case|:
comment|/* Execute target I/O request */
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
comment|/* Accept Host Target Mode CDB */
case|case
name|XPT_CONT_TARGET_IO
case|:
comment|/* Continue Host Target I/O Connection*/
case|case
name|XPT_ABORT
case|:
comment|/* Abort the specified CCB */
comment|/* XXX Implement */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_FUNC_NOTAVAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
comment|/* Get default/user set transfer settings for the target */
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|cts
init|=
operator|&
name|ccb
operator|->
name|cts
decl_stmt|;
name|u_int
name|target_mask
init|=
literal|0x01
operator|<<
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
decl_stmt|;
name|struct
name|ccb_trans_settings_scsi
modifier|*
name|scsi
init|=
operator|&
name|cts
operator|->
name|proto_specific
operator|.
name|scsi
decl_stmt|;
name|struct
name|ccb_trans_settings_spi
modifier|*
name|spi
init|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|spi
decl_stmt|;
if|if
condition|(
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_USER_SETTINGS
condition|)
block|{
name|cts
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cts
operator|->
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|cts
operator|->
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|cts
operator|->
name|transport_version
operator|=
literal|2
expr_stmt|;
name|scsi
operator|->
name|flags
operator|&=
operator|~
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
name|spi
operator|->
name|flags
operator|&=
operator|~
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
if|if
condition|(
operator|(
name|ahb
operator|->
name|disc_permitted
operator|&
name|target_mask
operator|)
operator|!=
literal|0
condition|)
name|spi
operator|->
name|flags
operator||=
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
if|if
condition|(
operator|(
name|ahb
operator|->
name|tags_permitted
operator|&
name|target_mask
operator|)
operator|!=
literal|0
condition|)
name|scsi
operator|->
name|flags
operator||=
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
name|spi
operator|->
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_8_BIT
expr_stmt|;
name|spi
operator|->
name|sync_period
operator|=
literal|25
expr_stmt|;
comment|/* 10MHz */
if|if
condition|(
name|spi
operator|->
name|sync_period
operator|!=
literal|0
condition|)
name|spi
operator|->
name|sync_offset
operator|=
literal|15
expr_stmt|;
name|spi
operator|->
name|valid
operator|=
name|CTS_SPI_VALID_SYNC_RATE
operator||
name|CTS_SPI_VALID_SYNC_OFFSET
operator||
name|CTS_SPI_VALID_BUS_WIDTH
operator||
name|CTS_SPI_VALID_DISC
expr_stmt|;
name|scsi
operator|->
name|valid
operator|=
name|CTS_SCSI_VALID_TQ
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
block|}
else|else
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_FUNC_NOTAVAIL
expr_stmt|;
block|}
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_RESET_DEV
case|:
comment|/* Bus Device Reset the specified SCSI device */
block|{
name|int
name|i
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|ahb
operator|->
name|immed_cmd
operator|=
name|IMMED_RESET
expr_stmt|;
name|ahbqueuembox
argument_list|(
name|ahb
argument_list|,
name|IMMED_RESET
argument_list|,
name|ATTN_IMMED
operator||
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|)
expr_stmt|;
comment|/* Poll for interrupt completion */
for|for
control|(
name|i
operator|=
literal|1000
init|;
name|ahb
operator|->
name|immed_cmd
operator|!=
literal|0
operator|&&
name|i
operator|!=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|ahbintr
argument_list|(
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_CALC_GEOMETRY
case|:
block|{
name|cam_calc_geometry
argument_list|(
operator|&
name|ccb
operator|->
name|ccg
argument_list|,
name|ahb
operator|->
name|extended_trans
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_RESET_BUS
case|:
comment|/* Reset the specified SCSI bus */
block|{
name|int
name|i
decl_stmt|;
name|ahb
operator|->
name|immed_cmd
operator|=
name|IMMED_RESET
expr_stmt|;
name|ahbqueuembox
argument_list|(
name|ahb
argument_list|,
name|IMMED_RESET
argument_list|,
name|ATTN_IMMED
operator||
name|ahb
operator|->
name|scsi_id
argument_list|)
expr_stmt|;
comment|/* Poll for interrupt completion */
for|for
control|(
name|i
operator|=
literal|1000
init|;
name|ahb
operator|->
name|immed_cmd
operator|!=
literal|0
operator|&&
name|i
operator|!=
literal|0
condition|;
name|i
operator|--
control|)
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_TERM_IO
case|:
comment|/* Terminate the I/O process */
comment|/* XXX Implement */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_PATH_INQ
case|:
comment|/* Path routing inquiry */
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
init|=
operator|&
name|ccb
operator|->
name|cpi
decl_stmt|;
name|cpi
operator|->
name|version_num
operator|=
literal|1
expr_stmt|;
comment|/* XXX??? */
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_SDTR_ABLE
operator||
name|PI_TAG_ABLE
expr_stmt|;
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_misc
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_target
operator|=
literal|7
expr_stmt|;
name|cpi
operator|->
name|max_lun
operator|=
literal|7
expr_stmt|;
name|cpi
operator|->
name|initiator_id
operator|=
name|ahb
operator|->
name|scsi_id
expr_stmt|;
name|cpi
operator|->
name|bus_id
operator|=
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|3300
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|"Adaptec"
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|sim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|cam_sim_unit
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|cpi
operator|->
name|transport_version
operator|=
literal|2
expr_stmt|;
name|cpi
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cpi
operator|->
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|cpi
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
if|#
directive|if
literal|0
comment|/* Need these??? */
block|case XPT_IMMED_NOTIFY:
comment|/* Notify Host Target driver of event */
block|case XPT_NOTIFY_ACK:
comment|/* Acknowledgement of event */
endif|#
directive|endif
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahbpoll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
name|ahbintr
argument_list|(
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahbtimeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ecb
modifier|*
name|ecb
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|ahb_softc
modifier|*
name|ahb
decl_stmt|;
name|int
name|s
decl_stmt|;
name|ecb
operator|=
operator|(
expr|struct
name|ecb
operator|*
operator|)
name|arg
expr_stmt|;
name|ccb
operator|=
name|ecb
operator|->
name|ccb
expr_stmt|;
name|ahb
operator|=
operator|(
expr|struct
name|ahb_softc
operator|*
operator|)
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_ahb_ptr
expr_stmt|;
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ECB %p - timed out\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ecb
argument_list|)
expr_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|ecb
operator|->
name|state
operator|&
name|ECB_ACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ECB %p - timed out ECB already completed\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ecb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * In order to simplify the recovery process, we ask the XPT 	 * layer to halt the queue of new transactions and we traverse 	 * the list of pending CCBs and remove their timeouts. This 	 * means that the driver attempts to clear only one error 	 * condition at a time.  In general, timeouts that occur 	 * close together are related anyway, so there is no benefit 	 * in attempting to handle errors in parrallel.  Timeouts will 	 * be reinstated when the recovery process ends. 	 */
if|if
condition|(
operator|(
name|ecb
operator|->
name|state
operator|&
name|ECB_DEVICE_RESET
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
if|if
condition|(
operator|(
name|ecb
operator|->
name|state
operator|&
name|ECB_RELEASE_SIMQ
operator|)
operator|==
literal|0
condition|)
block|{
name|xpt_freeze_simq
argument_list|(
name|ahb
operator|->
name|sim
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|ecb
operator|->
name|state
operator||=
name|ECB_RELEASE_SIMQ
expr_stmt|;
block|}
name|ccb_h
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|ahb
operator|->
name|pending_ccbs
argument_list|)
expr_stmt|;
while|while
condition|(
name|ccb_h
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ecb
modifier|*
name|pending_ecb
decl_stmt|;
name|pending_ecb
operator|=
operator|(
expr|struct
name|ecb
operator|*
operator|)
name|ccb_h
operator|->
name|ccb_ecb_ptr
expr_stmt|;
name|untimeout
argument_list|(
name|ahbtimeout
argument_list|,
name|pending_ecb
argument_list|,
name|ccb_h
operator|->
name|timeout_ch
argument_list|)
expr_stmt|;
name|ccb_h
operator|=
name|LIST_NEXT
argument_list|(
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|le
argument_list|)
expr_stmt|;
block|}
comment|/* Store for our interrupt handler */
name|ahb
operator|->
name|immed_ecb
operator|=
name|ecb
expr_stmt|;
comment|/*     		 * Send a Bus Device Reset message: 		 * The target that is holding up the bus may not 		 * be the same as the one that triggered this timeout 		 * (different commands have different timeout lengths), 		 * but we have no way of determining this from our 		 * timeout handler.  Our strategy here is to queue a 		 * BDR message to the target of the timed out command. 		 * If this fails, we'll get another timeout 2 seconds 		 * later which will attempt a bus reset. 		 */
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Queuing BDR\n"
argument_list|)
expr_stmt|;
name|ecb
operator|->
name|state
operator||=
name|ECB_DEVICE_RESET
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|ahbtimeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ecb
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
name|ahb
operator|->
name|immed_cmd
operator|=
name|IMMED_RESET
expr_stmt|;
name|ahbqueuembox
argument_list|(
name|ahb
argument_list|,
name|IMMED_RESET
argument_list|,
name|ATTN_IMMED
operator||
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ecb
operator|->
name|state
operator|&
name|ECB_SCSIBUS_RESET
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Try a SCSI bus reset.  We do this only if we 		 * have already attempted to clear the condition with a BDR. 		 */
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Attempting SCSI Bus reset\n"
argument_list|)
expr_stmt|;
name|ecb
operator|->
name|state
operator||=
name|ECB_SCSIBUS_RESET
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|ahbtimeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ecb
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
name|ahb
operator|->
name|immed_cmd
operator|=
name|IMMED_RESET
expr_stmt|;
name|ahbqueuembox
argument_list|(
name|ahb
argument_list|,
name|IMMED_RESET
argument_list|,
name|ATTN_IMMED
operator||
name|ahb
operator|->
name|scsi_id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Bring out the hammer... */
name|ahbreset
argument_list|(
name|ahb
argument_list|)
expr_stmt|;
comment|/* Simulate the reset complete interrupt */
name|ahbhandleimmed
argument_list|(
name|ahb
argument_list|,
literal|0
argument_list|,
name|ahb
operator|->
name|scsi_id
operator||
name|INTSTAT_IMMED_OK
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|ahb_eisa_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ahbprobe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ahbattach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ahb_eisa_driver
init|=
block|{
literal|"ahb"
block|,
name|ahb_eisa_methods
block|,
literal|1
block|,
comment|/* unused */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|ahb_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ahb
argument_list|,
name|eisa
argument_list|,
name|ahb_eisa_driver
argument_list|,
name|ahb_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ahb
argument_list|,
name|eisa
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ahb
argument_list|,
name|cam
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

