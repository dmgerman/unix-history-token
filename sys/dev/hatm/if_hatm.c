begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001-2003  *	Fraunhofer Institute for Open Communication Systems (FhG Fokus).  * 	All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * Author: Hartmut Brandt<harti@freebsd.org>  *  * ForeHE driver.  *  * This file contains the module and driver infrastructure stuff as well  * as a couple of utility functions and the entire initialisation.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_natm.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_atm.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_BPF
end_ifdef

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_atm.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/utopia/utopia.h>
end_include

begin_include
include|#
directive|include
file|<dev/hatm/if_hatmconf.h>
end_include

begin_include
include|#
directive|include
file|<dev/hatm/if_hatmreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/hatm/if_hatmvar.h>
end_include

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|uint16_t
name|vid
decl_stmt|;
name|uint16_t
name|did
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|hatm_devs
index|[]
init|=
block|{
block|{
literal|0x1127
block|,
literal|0x400
block|,
literal|"FORE HE"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_hw_atm
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|hatm
argument_list|,
name|utopia
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|hatm
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|hatm
argument_list|,
name|atm
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|EEPROM_DELAY
value|400
end_define

begin_comment
comment|/* microseconds */
end_comment

begin_comment
comment|/* Read from EEPROM 0000 0011b */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|uint32_t
name|readtab
index|[]
init|=
block|{
name|HE_REGM_HOST_PROM_SEL
operator||
name|HE_REGM_HOST_PROM_CLOCK
block|,
literal|0
block|,
name|HE_REGM_HOST_PROM_CLOCK
block|,
literal|0
block|,
comment|/* 0 */
name|HE_REGM_HOST_PROM_CLOCK
block|,
literal|0
block|,
comment|/* 0 */
name|HE_REGM_HOST_PROM_CLOCK
block|,
literal|0
block|,
comment|/* 0 */
name|HE_REGM_HOST_PROM_CLOCK
block|,
literal|0
block|,
comment|/* 0 */
name|HE_REGM_HOST_PROM_CLOCK
block|,
literal|0
block|,
comment|/* 0 */
name|HE_REGM_HOST_PROM_CLOCK
block|,
name|HE_REGM_HOST_PROM_DATA_IN
block|,
comment|/* 0 */
name|HE_REGM_HOST_PROM_CLOCK
operator||
name|HE_REGM_HOST_PROM_DATA_IN
block|,
name|HE_REGM_HOST_PROM_DATA_IN
block|,
comment|/* 1 */
name|HE_REGM_HOST_PROM_CLOCK
operator||
name|HE_REGM_HOST_PROM_DATA_IN
block|,
name|HE_REGM_HOST_PROM_DATA_IN
block|,
comment|/* 1 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint32_t
name|clocktab
index|[]
init|=
block|{
literal|0
block|,
name|HE_REGM_HOST_PROM_CLOCK
block|,
literal|0
block|,
name|HE_REGM_HOST_PROM_CLOCK
block|,
literal|0
block|,
name|HE_REGM_HOST_PROM_CLOCK
block|,
literal|0
block|,
name|HE_REGM_HOST_PROM_CLOCK
block|,
literal|0
block|,
name|HE_REGM_HOST_PROM_CLOCK
block|,
literal|0
block|,
name|HE_REGM_HOST_PROM_CLOCK
block|,
literal|0
block|,
name|HE_REGM_HOST_PROM_CLOCK
block|,
literal|0
block|,
name|HE_REGM_HOST_PROM_CLOCK
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Convert cell rate to ATM Forum format  */
end_comment

begin_function
name|u_int
name|hatm_cps2atmf
parameter_list|(
name|uint32_t
name|pcr
parameter_list|)
block|{
name|u_int
name|e
decl_stmt|;
if|if
condition|(
name|pcr
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|pcr
operator|<<=
literal|9
expr_stmt|;
name|e
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|pcr
operator|>
operator|(
literal|1024
operator|-
literal|1
operator|)
condition|)
block|{
name|e
operator|++
expr_stmt|;
name|pcr
operator|>>=
literal|1
expr_stmt|;
block|}
return|return
operator|(
operator|(
literal|1
operator|<<
literal|14
operator|)
operator||
operator|(
name|e
operator|<<
literal|9
operator|)
operator||
operator|(
name|pcr
operator|&
literal|0x1ff
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|u_int
name|hatm_atmf2cps
parameter_list|(
name|uint32_t
name|fcr
parameter_list|)
block|{
name|fcr
operator|&=
literal|0x7fff
expr_stmt|;
return|return
operator|(
operator|(
literal|1
operator|<<
operator|(
operator|(
name|fcr
operator|>>
literal|9
operator|)
operator|&
literal|0x1f
operator|)
operator|)
operator|*
operator|(
literal|512
operator|+
operator|(
name|fcr
operator|&
literal|0x1ff
operator|)
operator|)
operator|/
literal|512
operator|*
operator|(
name|fcr
operator|>>
literal|14
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************  *  * Initialisation  */
end_comment

begin_comment
comment|/*  * Probe for a HE controller  */
end_comment

begin_function
specifier|static
name|int
name|hatm_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|hatm_devs
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|hatm_devs
index|[
name|i
index|]
operator|.
name|vid
operator|&&
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|hatm_devs
index|[
name|i
index|]
operator|.
name|did
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|hatm_devs
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate and map DMA-able memory. We support only contiguous mappings.  */
end_comment

begin_function
specifier|static
name|void
name|dmaload_helper
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
if|if
condition|(
name|error
condition|)
return|return;
name|KASSERT
argument_list|(
name|nsegs
operator|==
literal|1
argument_list|,
operator|(
literal|"too many segments for DMA: %d"
operator|,
name|nsegs
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
operator|<=
literal|0xffffffffUL
argument_list|,
operator|(
literal|"phys addr too large %lx"
operator|,
operator|(
name|u_long
operator|)
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|hatm_alloc_dmamem
parameter_list|(
name|struct
name|hatm_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|what
parameter_list|,
name|struct
name|dmamem
modifier|*
name|mem
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|mem
operator|->
name|base
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Alignement does not work in the bus_dmamem_alloc function below 	 * on FreeBSD. malloc seems to align objects at least to the object 	 * size so increase the size to the alignment if the size is lesser 	 * than the alignemnt. 	 * XXX on sparc64 this is (probably) not needed. 	 */
if|if
condition|(
name|mem
operator|->
name|size
operator|<
name|mem
operator|->
name|align
condition|)
name|mem
operator|->
name|size
operator|=
name|mem
operator|->
name|align
expr_stmt|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_tag
argument_list|,
name|mem
operator|->
name|align
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|mem
operator|->
name|size
argument_list|,
literal|1
argument_list|,
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
name|BUS_DMA_ALLOCNOW
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|mem
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"DMA tag create (%s)\n"
argument_list|,
name|what
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|mem
operator|->
name|tag
argument_list|,
operator|&
name|mem
operator|->
name|base
argument_list|,
literal|0
argument_list|,
operator|&
name|mem
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"DMA mem alloc (%s): %d\n"
argument_list|,
name|what
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|mem
operator|->
name|tag
argument_list|)
expr_stmt|;
name|mem
operator|->
name|base
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|mem
operator|->
name|tag
argument_list|,
name|mem
operator|->
name|map
argument_list|,
name|mem
operator|->
name|base
argument_list|,
name|mem
operator|->
name|size
argument_list|,
name|dmaload_helper
argument_list|,
operator|&
name|mem
operator|->
name|paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"DMA map load (%s): %d\n"
argument_list|,
name|what
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|mem
operator|->
name|tag
argument_list|,
name|mem
operator|->
name|base
argument_list|,
name|mem
operator|->
name|map
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|mem
operator|->
name|tag
argument_list|)
expr_stmt|;
name|mem
operator|->
name|base
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|DBG
argument_list|(
name|sc
argument_list|,
name|DMA
argument_list|,
operator|(
literal|"%s S/A/V/P 0x%x 0x%x %p 0x%lx"
operator|,
name|what
operator|,
name|mem
operator|->
name|size
operator|,
name|mem
operator|->
name|align
operator|,
name|mem
operator|->
name|base
operator|,
operator|(
name|u_long
operator|)
name|mem
operator|->
name|paddr
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroy all the resources of an DMA-able memory region.  */
end_comment

begin_function
specifier|static
name|void
name|hatm_destroy_dmamem
parameter_list|(
name|struct
name|dmamem
modifier|*
name|mem
parameter_list|)
block|{
if|if
condition|(
name|mem
operator|->
name|base
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|mem
operator|->
name|tag
argument_list|,
name|mem
operator|->
name|map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|mem
operator|->
name|tag
argument_list|,
name|mem
operator|->
name|base
argument_list|,
name|mem
operator|->
name|map
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bus_dma_tag_destroy
argument_list|(
name|mem
operator|->
name|tag
argument_list|)
expr_stmt|;
name|mem
operator|->
name|base
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Initialize/destroy DMA maps for the large pool 0  */
end_comment

begin_function
specifier|static
name|void
name|hatm_destroy_rmaps
parameter_list|(
name|struct
name|hatm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int
name|b
decl_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|ATTACH
argument_list|,
operator|(
literal|"destroying rmaps and lbuf pointers..."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rmaps
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|sc
operator|->
name|lbufs_size
condition|;
name|b
operator|++
control|)
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|mbuf_tag
argument_list|,
name|sc
operator|->
name|rmaps
index|[
name|b
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|rmaps
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|lbufs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sc
operator|->
name|lbufs
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hatm_init_rmaps
parameter_list|(
name|struct
name|hatm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int
name|b
decl_stmt|;
name|int
name|err
decl_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|ATTACH
argument_list|,
operator|(
literal|"allocating rmaps and lbuf pointers..."
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lbufs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|lbufs
index|[
literal|0
index|]
argument_list|)
operator|*
name|sc
operator|->
name|lbufs_size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* allocate and create the DMA maps for the large pool */
name|sc
operator|->
name|rmaps
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|rmaps
index|[
literal|0
index|]
argument_list|)
operator|*
name|sc
operator|->
name|lbufs_size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|sc
operator|->
name|lbufs_size
condition|;
name|b
operator|++
control|)
block|{
name|err
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|mbuf_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|rmaps
index|[
name|b
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"bus_dmamap_create: %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Initialize and destroy small mbuf page pointers and pages  */
end_comment

begin_function
specifier|static
name|void
name|hatm_destroy_smbufs
parameter_list|(
name|struct
name|hatm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|,
name|b
decl_stmt|;
name|struct
name|mbuf_page
modifier|*
name|pg
decl_stmt|;
name|struct
name|mbuf_chunk_hdr
modifier|*
name|h
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|mbuf_pages
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|mbuf_npages
condition|;
name|i
operator|++
control|)
block|{
name|pg
operator|=
name|sc
operator|->
name|mbuf_pages
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|pg
operator|->
name|hdr
operator|.
name|nchunks
condition|;
name|b
operator|++
control|)
block|{
name|h
operator|=
operator|(
expr|struct
name|mbuf_chunk_hdr
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|pg
operator|+
name|b
operator|*
name|pg
operator|->
name|hdr
operator|.
name|chunksize
operator|+
name|pg
operator|->
name|hdr
operator|.
name|hdroff
operator|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|flags
operator|&
name|MBUF_CARD
condition|)
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"%s -- mbuf page=%u card buf %u\n"
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|flags
operator|&
name|MBUF_USED
condition|)
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"%s -- mbuf page=%u used buf %u\n"
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|mbuf_tag
argument_list|,
name|pg
operator|->
name|hdr
operator|.
name|map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|mbuf_tag
argument_list|,
name|pg
operator|->
name|hdr
operator|.
name|map
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pg
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|sc
operator|->
name|mbuf_pages
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hatm_init_smbufs
parameter_list|(
name|struct
name|hatm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|mbuf_pages
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|mbuf_pages
index|[
literal|0
index|]
argument_list|)
operator|*
name|sc
operator|->
name|mbuf_max_pages
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mbuf_npages
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize/destroy TPDs. This is called from attach/detach.  */
end_comment

begin_function
specifier|static
name|void
name|hatm_destroy_tpds
parameter_list|(
name|struct
name|hatm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|tpd
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|tpds
operator|.
name|base
operator|==
name|NULL
condition|)
return|return;
name|DBG
argument_list|(
name|sc
argument_list|,
name|ATTACH
argument_list|,
operator|(
literal|"releasing TPDs ..."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tpd_nfree
operator|!=
name|sc
operator|->
name|tpd_total
condition|)
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"%u tpds still in use from %u\n"
argument_list|,
name|sc
operator|->
name|tpd_total
operator|-
name|sc
operator|->
name|tpd_nfree
argument_list|,
name|sc
operator|->
name|tpd_total
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|t
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|tpd_free
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|tpd_free
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|tx_tag
argument_list|,
name|t
operator|->
name|map
argument_list|)
expr_stmt|;
block|}
name|hatm_destroy_dmamem
argument_list|(
operator|&
name|sc
operator|->
name|tpds
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|tpd_used
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|ATTACH
argument_list|,
operator|(
literal|"... done"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|hatm_init_tpds
parameter_list|(
name|struct
name|hatm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|struct
name|tpd
modifier|*
name|t
decl_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|ATTACH
argument_list|,
operator|(
literal|"allocating %u TPDs and maps ..."
operator|,
name|sc
operator|->
name|tpd_total
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|hatm_alloc_dmamem
argument_list|(
name|sc
argument_list|,
literal|"TPD memory"
argument_list|,
operator|&
name|sc
operator|->
name|tpds
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DBG
argument_list|(
name|sc
argument_list|,
name|ATTACH
argument_list|,
operator|(
literal|"... dmamem error=%d"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* put all the TPDs on the free list and allocate DMA maps */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|tpd_total
condition|;
name|i
operator|++
control|)
block|{
name|t
operator|=
name|TPD_ADDR
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|t
operator|->
name|no
operator|=
name|i
expr_stmt|;
name|t
operator|->
name|mbuf
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|tx_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|t
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DBG
argument_list|(
name|sc
argument_list|,
name|ATTACH
argument_list|,
operator|(
literal|"... dmamap error=%d"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|t
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|tpd_free
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|tpd_free
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|tx_tag
argument_list|,
name|t
operator|->
name|map
argument_list|)
expr_stmt|;
block|}
name|hatm_destroy_dmamem
argument_list|(
operator|&
name|sc
operator|->
name|tpds
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|tpd_free
argument_list|,
name|t
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
comment|/* allocate and zero bitmap */
name|sc
operator|->
name|tpd_used
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
operator|*
operator|(
name|sc
operator|->
name|tpd_total
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tpd_nfree
operator|=
name|sc
operator|->
name|tpd_total
expr_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|ATTACH
argument_list|,
operator|(
literal|"... done"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free all the TPDs that where given to the card.   * An mbuf chain may be attached to a TPD - free it also and  * unload its associated DMA map.  */
end_comment

begin_function
specifier|static
name|void
name|hatm_stop_tpds
parameter_list|(
name|struct
name|hatm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|struct
name|tpd
modifier|*
name|t
decl_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|ATTACH
argument_list|,
operator|(
literal|"free TPDs ..."
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|tpd_total
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|TPD_TST_USED
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|t
operator|=
name|TPD_ADDR
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|mbuf
condition|)
block|{
name|m_freem
argument_list|(
name|t
operator|->
name|mbuf
argument_list|)
expr_stmt|;
name|t
operator|->
name|mbuf
operator|=
name|NULL
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|tx_tag
argument_list|,
name|t
operator|->
name|map
argument_list|)
expr_stmt|;
block|}
name|TPD_CLR_USED
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|tpd_free
argument_list|,
name|t
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tpd_nfree
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * This frees ALL resources of this interface and leaves the structure  * in an indeterminate state. This is called just before detaching or  * on a failed attach. No lock should be held.  */
end_comment

begin_function
specifier|static
name|void
name|hatm_destroy
parameter_list|(
name|struct
name|hatm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int
name|cid
decl_stmt|;
name|bus_teardown_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|irqres
argument_list|,
name|sc
operator|->
name|ih
argument_list|)
expr_stmt|;
name|hatm_destroy_rmaps
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hatm_destroy_smbufs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hatm_destroy_tpds
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vcc_zone
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|cid
operator|=
literal|0
init|;
name|cid
operator|<
name|HE_MAX_VCCS
condition|;
name|cid
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|vccs
index|[
name|cid
index|]
operator|!=
name|NULL
condition|)
name|uma_zfree
argument_list|(
name|sc
operator|->
name|vcc_zone
argument_list|,
name|sc
operator|->
name|vccs
index|[
name|cid
index|]
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|sc
operator|->
name|vcc_zone
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Release all memory allocated to the various queues and 	 * Status pages. These have there own flag which shows whether 	 * they are really allocated. 	 */
name|hatm_destroy_dmamem
argument_list|(
operator|&
name|sc
operator|->
name|irq_0
operator|.
name|mem
argument_list|)
expr_stmt|;
name|hatm_destroy_dmamem
argument_list|(
operator|&
name|sc
operator|->
name|rbp_s0
operator|.
name|mem
argument_list|)
expr_stmt|;
name|hatm_destroy_dmamem
argument_list|(
operator|&
name|sc
operator|->
name|rbp_l0
operator|.
name|mem
argument_list|)
expr_stmt|;
name|hatm_destroy_dmamem
argument_list|(
operator|&
name|sc
operator|->
name|rbp_s1
operator|.
name|mem
argument_list|)
expr_stmt|;
name|hatm_destroy_dmamem
argument_list|(
operator|&
name|sc
operator|->
name|rbrq_0
operator|.
name|mem
argument_list|)
expr_stmt|;
name|hatm_destroy_dmamem
argument_list|(
operator|&
name|sc
operator|->
name|rbrq_1
operator|.
name|mem
argument_list|)
expr_stmt|;
name|hatm_destroy_dmamem
argument_list|(
operator|&
name|sc
operator|->
name|tbrq
operator|.
name|mem
argument_list|)
expr_stmt|;
name|hatm_destroy_dmamem
argument_list|(
operator|&
name|sc
operator|->
name|tpdrq
operator|.
name|mem
argument_list|)
expr_stmt|;
name|hatm_destroy_dmamem
argument_list|(
operator|&
name|sc
operator|->
name|hsp_mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irqres
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irqid
argument_list|,
name|sc
operator|->
name|irqres
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tx_tag
operator|!=
name|NULL
condition|)
if|if
condition|(
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|tx_tag
argument_list|)
condition|)
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"mbuf DMA tag busy\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mbuf_tag
operator|!=
name|NULL
condition|)
if|if
condition|(
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|mbuf_tag
argument_list|)
condition|)
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"mbuf DMA tag busy\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|parent_tag
operator|!=
name|NULL
condition|)
if|if
condition|(
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|parent_tag
argument_list|)
condition|)
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"parent DMA tag busy\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|memres
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|memid
argument_list|,
name|sc
operator|->
name|memres
argument_list|)
expr_stmt|;
name|sysctl_ctx_free
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|sc
operator|->
name|cv_rcclose
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|sc
operator|->
name|vcc_cv
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ifp
operator|!=
name|NULL
condition|)
name|if_free
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * 4.4 Card reset  */
end_comment

begin_function
specifier|static
name|int
name|hatm_reset
parameter_list|(
name|struct
name|hatm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int
name|v
decl_stmt|,
name|count
decl_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RESET_CNTL
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RESET_CNTL
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|BARRIER_RW
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|v
operator|=
name|READ4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RESET_CNTL
argument_list|)
operator|)
operator|&
name|HE_REGM_RESET_STATE
operator|)
operator|==
literal|0
condition|)
block|{
name|BARRIER_R
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|count
operator|==
literal|100
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"reset failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 4.5 Set Bus Width  */
end_comment

begin_function
specifier|static
name|void
name|hatm_init_bus_width
parameter_list|(
name|struct
name|hatm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|v
decl_stmt|,
name|v1
decl_stmt|;
name|v
operator|=
name|READ4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_HOST_CNTL
argument_list|)
expr_stmt|;
name|BARRIER_R
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|HE_REGM_HOST_BUS64
condition|)
block|{
name|sc
operator|->
name|pci64
operator|=
literal|1
expr_stmt|;
name|v1
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|HE_PCIR_GEN_CNTL_0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|v1
operator||=
name|HE_PCIM_CTL0_64BIT
expr_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|HE_PCIR_GEN_CNTL_0
argument_list|,
name|v1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|v
operator||=
name|HE_REGM_HOST_DESC_RD64
operator||
name|HE_REGM_HOST_DATA_RD64
operator||
name|HE_REGM_HOST_DATA_WR64
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_HOST_CNTL
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|pci64
operator|=
literal|0
expr_stmt|;
name|v
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|HE_PCIR_GEN_CNTL_0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|v
operator|&=
operator|~
name|HE_PCIM_CTL0_64BIT
expr_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|HE_PCIR_GEN_CNTL_0
argument_list|,
name|v
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * 4.6 Set Host Endianess  */
end_comment

begin_function
specifier|static
name|void
name|hatm_init_endianess
parameter_list|(
name|struct
name|hatm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|v
decl_stmt|;
name|v
operator|=
name|READ4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_LB_SWAP
argument_list|)
expr_stmt|;
name|BARRIER_R
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
name|v
operator||=
name|HE_REGM_LBSWAP_INTR_SWAP
operator||
name|HE_REGM_LBSWAP_DESC_WR_SWAP
operator||
name|HE_REGM_LBSWAP_BIG_ENDIAN
expr_stmt|;
name|v
operator|&=
operator|~
operator|(
name|HE_REGM_LBSWAP_DATA_WR_SWAP
operator||
name|HE_REGM_LBSWAP_DESC_RD_SWAP
operator||
name|HE_REGM_LBSWAP_DATA_RD_SWAP
operator|)
expr_stmt|;
else|#
directive|else
name|v
operator|&=
operator|~
operator|(
name|HE_REGM_LBSWAP_DATA_WR_SWAP
operator||
name|HE_REGM_LBSWAP_DESC_RD_SWAP
operator||
name|HE_REGM_LBSWAP_DATA_RD_SWAP
operator||
name|HE_REGM_LBSWAP_INTR_SWAP
operator||
name|HE_REGM_LBSWAP_DESC_WR_SWAP
operator||
name|HE_REGM_LBSWAP_BIG_ENDIAN
operator|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|he622
condition|)
name|v
operator||=
name|HE_REGM_LBSWAP_XFER_SIZE
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_LB_SWAP
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * 4.7 Read EEPROM  */
end_comment

begin_function
specifier|static
name|uint8_t
name|hatm_read_prom_byte
parameter_list|(
name|struct
name|hatm_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|addr
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|,
name|tmp_read
decl_stmt|,
name|byte_read
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|n
decl_stmt|;
name|val
operator|=
name|READ4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_HOST_CNTL
argument_list|)
expr_stmt|;
name|val
operator|&=
name|HE_REGM_HOST_PROM_BITS
expr_stmt|;
name|BARRIER_R
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|val
operator||=
name|HE_REGM_HOST_PROM_WREN
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_HOST_CNTL
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* send READ */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|readtab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|readtab
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_HOST_CNTL
argument_list|,
name|val
operator||
name|readtab
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|EEPROM_DELAY
argument_list|)
expr_stmt|;
block|}
comment|/* send ADDRESS */
for|for
control|(
name|n
operator|=
literal|7
operator|,
name|j
operator|=
literal|0
init|;
name|n
operator|>=
literal|0
condition|;
name|n
operator|--
control|)
block|{
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_HOST_CNTL
argument_list|,
name|val
operator||
name|clocktab
index|[
name|j
operator|++
index|]
operator||
operator|(
operator|(
operator|(
name|addr
operator|>>
name|n
operator|)
operator|&
literal|1
operator|)
operator|<<
name|HE_REGS_HOST_PROM_DATA_IN
operator|)
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|EEPROM_DELAY
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_HOST_CNTL
argument_list|,
name|val
operator||
name|clocktab
index|[
name|j
operator|++
index|]
operator||
operator|(
operator|(
operator|(
name|addr
operator|>>
name|n
operator|)
operator|&
literal|1
operator|)
operator|<<
name|HE_REGS_HOST_PROM_DATA_IN
operator|)
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|EEPROM_DELAY
argument_list|)
expr_stmt|;
block|}
name|val
operator|&=
operator|~
name|HE_REGM_HOST_PROM_WREN
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_HOST_CNTL
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* read DATA */
name|byte_read
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|7
operator|,
name|j
operator|=
literal|0
init|;
name|n
operator|>=
literal|0
condition|;
name|n
operator|--
control|)
block|{
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_HOST_CNTL
argument_list|,
name|val
operator||
name|clocktab
index|[
name|j
operator|++
index|]
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|EEPROM_DELAY
argument_list|)
expr_stmt|;
name|tmp_read
operator|=
name|READ4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_HOST_CNTL
argument_list|)
expr_stmt|;
name|byte_read
operator||=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
operator|(
name|tmp_read
operator|&
name|HE_REGM_HOST_PROM_DATA_OUT
operator|)
operator|>>
name|HE_REGS_HOST_PROM_DATA_OUT
operator|)
operator|<<
name|n
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_HOST_CNTL
argument_list|,
name|val
operator||
name|clocktab
index|[
name|j
operator|++
index|]
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|EEPROM_DELAY
argument_list|)
expr_stmt|;
block|}
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_HOST_CNTL
argument_list|,
name|val
operator||
name|clocktab
index|[
name|j
operator|++
index|]
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|EEPROM_DELAY
argument_list|)
expr_stmt|;
return|return
operator|(
name|byte_read
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hatm_init_read_eeprom
parameter_list|(
name|struct
name|hatm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int
name|n
decl_stmt|,
name|count
decl_stmt|;
name|u_char
name|byte
decl_stmt|;
name|uint32_t
name|v
decl_stmt|;
for|for
control|(
name|n
operator|=
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|HE_EEPROM_PROD_ID_LEN
condition|;
name|count
operator|++
control|)
block|{
name|byte
operator|=
name|hatm_read_prom_byte
argument_list|(
name|sc
argument_list|,
name|HE_EEPROM_PROD_ID
operator|+
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
operator|||
name|byte
operator|!=
literal|' '
condition|)
name|sc
operator|->
name|prod_id
index|[
name|n
operator|++
index|]
operator|=
name|byte
expr_stmt|;
block|}
while|while
condition|(
name|n
operator|>
literal|0
operator|&&
name|sc
operator|->
name|prod_id
index|[
name|n
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|n
operator|--
expr_stmt|;
name|sc
operator|->
name|prod_id
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|n
operator|=
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|HE_EEPROM_REV_LEN
condition|;
name|count
operator|++
control|)
block|{
name|byte
operator|=
name|hatm_read_prom_byte
argument_list|(
name|sc
argument_list|,
name|HE_EEPROM_REV
operator|+
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
operator|||
name|byte
operator|!=
literal|' '
condition|)
name|sc
operator|->
name|rev
index|[
name|n
operator|++
index|]
operator|=
name|byte
expr_stmt|;
block|}
while|while
condition|(
name|n
operator|>
literal|0
operator|&&
name|sc
operator|->
name|rev
index|[
name|n
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|n
operator|--
expr_stmt|;
name|sc
operator|->
name|rev
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|hw_version
operator|=
name|sc
operator|->
name|rev
index|[
literal|0
index|]
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|serial
operator|=
name|hatm_read_prom_byte
argument_list|(
name|sc
argument_list|,
name|HE_EEPROM_M_SN
operator|+
literal|0
argument_list|)
operator|<<
literal|0
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|serial
operator||=
name|hatm_read_prom_byte
argument_list|(
name|sc
argument_list|,
name|HE_EEPROM_M_SN
operator|+
literal|1
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|serial
operator||=
name|hatm_read_prom_byte
argument_list|(
name|sc
argument_list|,
name|HE_EEPROM_M_SN
operator|+
literal|2
argument_list|)
operator|<<
literal|16
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|serial
operator||=
name|hatm_read_prom_byte
argument_list|(
name|sc
argument_list|,
name|HE_EEPROM_M_SN
operator|+
literal|3
argument_list|)
operator|<<
literal|24
expr_stmt|;
name|v
operator|=
name|hatm_read_prom_byte
argument_list|(
name|sc
argument_list|,
name|HE_EEPROM_MEDIA
operator|+
literal|0
argument_list|)
operator|<<
literal|0
expr_stmt|;
name|v
operator||=
name|hatm_read_prom_byte
argument_list|(
name|sc
argument_list|,
name|HE_EEPROM_MEDIA
operator|+
literal|1
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|v
operator||=
name|hatm_read_prom_byte
argument_list|(
name|sc
argument_list|,
name|HE_EEPROM_MEDIA
operator|+
literal|2
argument_list|)
operator|<<
literal|16
expr_stmt|;
name|v
operator||=
name|hatm_read_prom_byte
argument_list|(
name|sc
argument_list|,
name|HE_EEPROM_MEDIA
operator|+
literal|3
argument_list|)
operator|<<
literal|24
expr_stmt|;
switch|switch
condition|(
name|v
condition|)
block|{
case|case
name|HE_MEDIA_UTP155
case|:
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|media
operator|=
name|IFM_ATM_UTP_155
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|pcr
operator|=
name|ATM_RATE_155M
expr_stmt|;
break|break;
case|case
name|HE_MEDIA_MMF155
case|:
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|media
operator|=
name|IFM_ATM_MM_155
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|pcr
operator|=
name|ATM_RATE_155M
expr_stmt|;
break|break;
case|case
name|HE_MEDIA_MMF622
case|:
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|media
operator|=
name|IFM_ATM_MM_622
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|device
operator|=
name|ATM_DEVICE_HE622
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|pcr
operator|=
name|ATM_RATE_622M
expr_stmt|;
name|sc
operator|->
name|he622
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|HE_MEDIA_SMF155
case|:
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|media
operator|=
name|IFM_ATM_SM_155
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|pcr
operator|=
name|ATM_RATE_155M
expr_stmt|;
break|break;
case|case
name|HE_MEDIA_SMF622
case|:
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|media
operator|=
name|IFM_ATM_SM_622
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|device
operator|=
name|ATM_DEVICE_HE622
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|pcr
operator|=
name|ATM_RATE_622M
expr_stmt|;
name|sc
operator|->
name|he622
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|esi
index|[
literal|0
index|]
operator|=
name|hatm_read_prom_byte
argument_list|(
name|sc
argument_list|,
name|HE_EEPROM_MAC
operator|+
literal|0
argument_list|)
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|esi
index|[
literal|1
index|]
operator|=
name|hatm_read_prom_byte
argument_list|(
name|sc
argument_list|,
name|HE_EEPROM_MAC
operator|+
literal|1
argument_list|)
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|esi
index|[
literal|2
index|]
operator|=
name|hatm_read_prom_byte
argument_list|(
name|sc
argument_list|,
name|HE_EEPROM_MAC
operator|+
literal|2
argument_list|)
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|esi
index|[
literal|3
index|]
operator|=
name|hatm_read_prom_byte
argument_list|(
name|sc
argument_list|,
name|HE_EEPROM_MAC
operator|+
literal|3
argument_list|)
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|esi
index|[
literal|4
index|]
operator|=
name|hatm_read_prom_byte
argument_list|(
name|sc
argument_list|,
name|HE_EEPROM_MAC
operator|+
literal|4
argument_list|)
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|esi
index|[
literal|5
index|]
operator|=
name|hatm_read_prom_byte
argument_list|(
name|sc
argument_list|,
name|HE_EEPROM_MAC
operator|+
literal|5
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Clear unused interrupt queue  */
end_comment

begin_function
specifier|static
name|void
name|hatm_clear_irq
parameter_list|(
name|struct
name|hatm_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|group
parameter_list|)
block|{
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_IRQ_BASE
argument_list|(
name|group
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_IRQ_HEAD
argument_list|(
name|group
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_IRQ_CNTL
argument_list|(
name|group
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_IRQ_DATA
argument_list|(
name|group
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * 4.10 Initialize interrupt queues  */
end_comment

begin_function
specifier|static
name|void
name|hatm_init_irq
parameter_list|(
name|struct
name|hatm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|heirq
modifier|*
name|q
parameter_list|,
name|u_int
name|group
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
if|if
condition|(
name|q
operator|->
name|size
operator|==
literal|0
condition|)
block|{
name|hatm_clear_irq
argument_list|(
name|sc
argument_list|,
name|group
argument_list|)
expr_stmt|;
return|return;
block|}
name|q
operator|->
name|group
operator|=
name|group
expr_stmt|;
name|q
operator|->
name|sc
operator|=
name|sc
expr_stmt|;
name|q
operator|->
name|irq
operator|=
name|q
operator|->
name|mem
operator|.
name|base
expr_stmt|;
name|q
operator|->
name|head
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|tailp
operator|=
name|q
operator|->
name|irq
operator|+
operator|(
name|q
operator|->
name|size
operator|-
literal|1
operator|)
expr_stmt|;
operator|*
name|q
operator|->
name|tailp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|q
operator|->
name|size
condition|;
name|i
operator|++
control|)
name|q
operator|->
name|irq
index|[
name|i
index|]
operator|=
name|HE_REGM_ITYPE_INVALID
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_IRQ_BASE
argument_list|(
name|group
argument_list|)
argument_list|,
name|q
operator|->
name|mem
operator|.
name|paddr
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_IRQ_HEAD
argument_list|(
name|group
argument_list|)
argument_list|,
operator|(
operator|(
name|q
operator|->
name|size
operator|-
literal|1
operator|)
operator|<<
name|HE_REGS_IRQ_HEAD_SIZE
operator|)
operator||
operator|(
name|q
operator|->
name|thresh
operator|<<
name|HE_REGS_IRQ_HEAD_THRESH
operator|)
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_IRQ_CNTL
argument_list|(
name|group
argument_list|)
argument_list|,
name|q
operator|->
name|line
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_IRQ_DATA
argument_list|(
name|group
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * 5.1.3 Initialize connection memory  */
end_comment

begin_function
specifier|static
name|void
name|hatm_init_cm
parameter_list|(
name|struct
name|hatm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int
name|rsra
decl_stmt|,
name|mlbm
decl_stmt|,
name|rabr
decl_stmt|,
name|numbuffs
decl_stmt|;
name|u_int
name|tsra
decl_stmt|,
name|tabr
decl_stmt|,
name|mtpd
decl_stmt|;
name|u_int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|HE_CONFIG_TXMEM
condition|;
name|n
operator|++
control|)
name|WRITE_TCM4
argument_list|(
name|sc
argument_list|,
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|HE_CONFIG_RXMEM
condition|;
name|n
operator|++
control|)
name|WRITE_RCM4
argument_list|(
name|sc
argument_list|,
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|numbuffs
operator|=
name|sc
operator|->
name|r0_numbuffs
operator|+
name|sc
operator|->
name|r1_numbuffs
operator|+
name|sc
operator|->
name|tx_numbuffs
expr_stmt|;
name|rsra
operator|=
literal|0
expr_stmt|;
name|mlbm
operator|=
operator|(
operator|(
name|rsra
operator|+
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|max_vccs
operator|*
literal|8
operator|)
operator|+
literal|0x7ff
operator|)
operator|&
operator|~
literal|0x7ff
expr_stmt|;
name|rabr
operator|=
operator|(
operator|(
name|mlbm
operator|+
name|numbuffs
operator|*
literal|2
operator|)
operator|+
literal|0x7ff
operator|)
operator|&
operator|~
literal|0x7ff
expr_stmt|;
name|sc
operator|->
name|rsrb
operator|=
operator|(
operator|(
name|rabr
operator|+
literal|2048
operator|)
operator|+
operator|(
literal|2
operator|*
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|max_vccs
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
operator|(
literal|2
operator|*
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|max_vccs
operator|-
literal|1
operator|)
expr_stmt|;
name|tsra
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|tsrb
operator|=
name|tsra
operator|+
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|max_vccs
operator|*
literal|8
expr_stmt|;
name|sc
operator|->
name|tsrc
operator|=
name|sc
operator|->
name|tsrb
operator|+
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|max_vccs
operator|*
literal|4
expr_stmt|;
name|sc
operator|->
name|tsrd
operator|=
name|sc
operator|->
name|tsrc
operator|+
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|max_vccs
operator|*
literal|2
expr_stmt|;
name|tabr
operator|=
name|sc
operator|->
name|tsrd
operator|+
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|max_vccs
operator|*
literal|1
expr_stmt|;
name|mtpd
operator|=
operator|(
operator|(
name|tabr
operator|+
literal|1024
operator|)
operator|+
operator|(
literal|16
operator|*
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|max_vccs
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
operator|(
literal|16
operator|*
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|max_vccs
operator|-
literal|1
operator|)
expr_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|ATTACH
argument_list|,
operator|(
literal|"rsra=%x mlbm=%x rabr=%x rsrb=%x"
operator|,
name|rsra
operator|,
name|mlbm
operator|,
name|rabr
operator|,
name|sc
operator|->
name|rsrb
operator|)
argument_list|)
expr_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|ATTACH
argument_list|,
operator|(
literal|"tsra=%x tsrb=%x tsrc=%x tsrd=%x tabr=%x mtpd=%x"
operator|,
name|tsra
operator|,
name|sc
operator|->
name|tsrb
operator|,
name|sc
operator|->
name|tsrc
operator|,
name|sc
operator|->
name|tsrd
operator|,
name|tabr
operator|,
name|mtpd
operator|)
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_TSRB_BA
argument_list|,
name|sc
operator|->
name|tsrb
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_TSRC_BA
argument_list|,
name|sc
operator|->
name|tsrc
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_TSRD_BA
argument_list|,
name|sc
operator|->
name|tsrd
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_TMABR_BA
argument_list|,
name|tabr
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_TPD_BA
argument_list|,
name|mtpd
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RCMRSRB_BA
argument_list|,
name|sc
operator|->
name|rsrb
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RCMLBM_BA
argument_list|,
name|mlbm
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RCMABR_BA
argument_list|,
name|rabr
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * 5.1.4 Initialize Local buffer Pools  */
end_comment

begin_function
specifier|static
name|void
name|hatm_init_rx_buffer_pool
parameter_list|(
name|struct
name|hatm_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|num
parameter_list|,
comment|/* bank */
name|u_int
name|start
parameter_list|,
comment|/* start row */
name|u_int
name|numbuffs
comment|/* number of entries */
parameter_list|)
block|{
name|u_int
name|row_size
decl_stmt|;
comment|/* bytes per row */
name|uint32_t
name|row_addr
decl_stmt|;
comment|/* start address of this row */
name|u_int
name|lbuf_size
decl_stmt|;
comment|/* bytes per lbuf */
name|u_int
name|lbufs_per_row
decl_stmt|;
comment|/* number of lbufs per memory row */
name|uint32_t
name|lbufd_index
decl_stmt|;
comment|/* index of lbuf descriptor */
name|uint32_t
name|lbufd_addr
decl_stmt|;
comment|/* address of lbuf descriptor */
name|u_int
name|lbuf_row_cnt
decl_stmt|;
comment|/* current lbuf in current row */
name|uint32_t
name|lbuf_addr
decl_stmt|;
comment|/* address of current buffer */
name|u_int
name|i
decl_stmt|;
name|row_size
operator|=
name|sc
operator|->
name|bytes_per_row
expr_stmt|;
name|row_addr
operator|=
name|start
operator|*
name|row_size
expr_stmt|;
name|lbuf_size
operator|=
name|sc
operator|->
name|cells_per_lbuf
operator|*
literal|48
expr_stmt|;
name|lbufs_per_row
operator|=
name|sc
operator|->
name|cells_per_row
operator|/
name|sc
operator|->
name|cells_per_lbuf
expr_stmt|;
comment|/* descriptor index */
name|lbufd_index
operator|=
name|num
expr_stmt|;
comment|/* 2 words per entry */
name|lbufd_addr
operator|=
name|READ4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RCMLBM_BA
argument_list|)
operator|+
name|lbufd_index
operator|*
literal|2
expr_stmt|;
comment|/* write head of queue */
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RLBF_H
argument_list|(
name|num
argument_list|)
argument_list|,
name|lbufd_index
argument_list|)
expr_stmt|;
name|lbuf_row_cnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numbuffs
condition|;
name|i
operator|++
control|)
block|{
name|lbuf_addr
operator|=
operator|(
name|row_addr
operator|+
name|lbuf_row_cnt
operator|*
name|lbuf_size
operator|)
operator|/
literal|32
expr_stmt|;
name|WRITE_RCM4
argument_list|(
name|sc
argument_list|,
name|lbufd_addr
argument_list|,
name|lbuf_addr
argument_list|)
expr_stmt|;
name|lbufd_index
operator|+=
literal|2
expr_stmt|;
name|WRITE_RCM4
argument_list|(
name|sc
argument_list|,
name|lbufd_addr
operator|+
literal|1
argument_list|,
name|lbufd_index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|lbuf_row_cnt
operator|==
name|lbufs_per_row
condition|)
block|{
name|lbuf_row_cnt
operator|=
literal|0
expr_stmt|;
name|row_addr
operator|+=
name|row_size
expr_stmt|;
block|}
name|lbufd_addr
operator|+=
literal|2
operator|*
literal|2
expr_stmt|;
block|}
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RLBF_T
argument_list|(
name|num
argument_list|)
argument_list|,
name|lbufd_index
operator|-
literal|2
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RLBF_C
argument_list|(
name|num
argument_list|)
argument_list|,
name|numbuffs
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hatm_init_tx_buffer_pool
parameter_list|(
name|struct
name|hatm_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|start
parameter_list|,
comment|/* start row */
name|u_int
name|numbuffs
comment|/* number of entries */
parameter_list|)
block|{
name|u_int
name|row_size
decl_stmt|;
comment|/* bytes per row */
name|uint32_t
name|row_addr
decl_stmt|;
comment|/* start address of this row */
name|u_int
name|lbuf_size
decl_stmt|;
comment|/* bytes per lbuf */
name|u_int
name|lbufs_per_row
decl_stmt|;
comment|/* number of lbufs per memory row */
name|uint32_t
name|lbufd_index
decl_stmt|;
comment|/* index of lbuf descriptor */
name|uint32_t
name|lbufd_addr
decl_stmt|;
comment|/* address of lbuf descriptor */
name|u_int
name|lbuf_row_cnt
decl_stmt|;
comment|/* current lbuf in current row */
name|uint32_t
name|lbuf_addr
decl_stmt|;
comment|/* address of current buffer */
name|u_int
name|i
decl_stmt|;
name|row_size
operator|=
name|sc
operator|->
name|bytes_per_row
expr_stmt|;
name|row_addr
operator|=
name|start
operator|*
name|row_size
expr_stmt|;
name|lbuf_size
operator|=
name|sc
operator|->
name|cells_per_lbuf
operator|*
literal|48
expr_stmt|;
name|lbufs_per_row
operator|=
name|sc
operator|->
name|cells_per_row
operator|/
name|sc
operator|->
name|cells_per_lbuf
expr_stmt|;
comment|/* descriptor index */
name|lbufd_index
operator|=
name|sc
operator|->
name|r0_numbuffs
operator|+
name|sc
operator|->
name|r1_numbuffs
expr_stmt|;
comment|/* 2 words per entry */
name|lbufd_addr
operator|=
name|READ4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RCMLBM_BA
argument_list|)
operator|+
name|lbufd_index
operator|*
literal|2
expr_stmt|;
comment|/* write head of queue */
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_TLBF_H
argument_list|,
name|lbufd_index
argument_list|)
expr_stmt|;
name|lbuf_row_cnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numbuffs
condition|;
name|i
operator|++
control|)
block|{
name|lbuf_addr
operator|=
operator|(
name|row_addr
operator|+
name|lbuf_row_cnt
operator|*
name|lbuf_size
operator|)
operator|/
literal|32
expr_stmt|;
name|WRITE_RCM4
argument_list|(
name|sc
argument_list|,
name|lbufd_addr
argument_list|,
name|lbuf_addr
argument_list|)
expr_stmt|;
name|lbufd_index
operator|++
expr_stmt|;
name|WRITE_RCM4
argument_list|(
name|sc
argument_list|,
name|lbufd_addr
operator|+
literal|1
argument_list|,
name|lbufd_index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|lbuf_row_cnt
operator|==
name|lbufs_per_row
condition|)
block|{
name|lbuf_row_cnt
operator|=
literal|0
expr_stmt|;
name|row_addr
operator|+=
name|row_size
expr_stmt|;
block|}
name|lbufd_addr
operator|+=
literal|2
expr_stmt|;
block|}
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_TLBF_T
argument_list|,
name|lbufd_index
operator|-
literal|1
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * 5.1.5 Initialize Intermediate Receive Queues  */
end_comment

begin_function
specifier|static
name|void
name|hatm_init_imed_queues
parameter_list|(
name|struct
name|hatm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int
name|n
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|he622
condition|)
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|8
condition|;
name|n
operator|++
control|)
block|{
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_INMQ_S
argument_list|(
name|n
argument_list|)
argument_list|,
literal|0x10
operator|*
name|n
operator|+
literal|0x000f
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_INMQ_L
argument_list|(
name|n
argument_list|)
argument_list|,
literal|0x10
operator|*
name|n
operator|+
literal|0x200f
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|8
condition|;
name|n
operator|++
control|)
block|{
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_INMQ_S
argument_list|(
name|n
argument_list|)
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_INMQ_L
argument_list|(
name|n
argument_list|)
argument_list|,
name|n
operator|+
literal|0x8
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * 5.1.7 Init CS block  */
end_comment

begin_function
specifier|static
name|void
name|hatm_init_cs_block
parameter_list|(
name|struct
name|hatm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int
name|n
decl_stmt|,
name|i
decl_stmt|;
name|u_int
name|clkfreg
decl_stmt|,
name|cellrate
decl_stmt|,
name|decr
decl_stmt|,
name|tmp
decl_stmt|;
specifier|static
specifier|const
name|uint32_t
name|erthr
index|[
literal|2
index|]
index|[
literal|5
index|]
index|[
literal|3
index|]
init|=
name|HE_REGT_CS_ERTHR
decl_stmt|;
specifier|static
specifier|const
name|uint32_t
name|erctl
index|[
literal|2
index|]
index|[
literal|3
index|]
init|=
name|HE_REGT_CS_ERCTL
decl_stmt|;
specifier|static
specifier|const
name|uint32_t
name|erstat
index|[
literal|2
index|]
index|[
literal|2
index|]
init|=
name|HE_REGT_CS_ERSTAT
decl_stmt|;
specifier|static
specifier|const
name|uint32_t
name|rtfwr
index|[
literal|2
index|]
init|=
name|HE_REGT_CS_RTFWR
decl_stmt|;
specifier|static
specifier|const
name|uint32_t
name|rtatr
index|[
literal|2
index|]
init|=
name|HE_REGT_CS_RTATR
decl_stmt|;
specifier|static
specifier|const
name|uint32_t
name|bwalloc
index|[
literal|2
index|]
index|[
literal|6
index|]
init|=
name|HE_REGT_CS_BWALLOC
decl_stmt|;
specifier|static
specifier|const
name|uint32_t
name|orcf
index|[
literal|2
index|]
index|[
literal|2
index|]
init|=
name|HE_REGT_CS_ORCF
decl_stmt|;
comment|/* Clear Rate Controller Start Times and Occupied Flags */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|32
condition|;
name|n
operator|++
control|)
name|WRITE_MBOX4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_CS_STTIM
argument_list|(
name|n
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clkfreg
operator|=
name|sc
operator|->
name|he622
condition|?
name|HE_622_CLOCK
else|:
name|HE_155_CLOCK
expr_stmt|;
name|cellrate
operator|=
name|sc
operator|->
name|he622
condition|?
name|ATM_RATE_622M
else|:
name|ATM_RATE_155M
expr_stmt|;
name|decr
operator|=
name|cellrate
operator|/
literal|32
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|16
condition|;
name|n
operator|++
control|)
block|{
name|tmp
operator|=
name|clkfreg
operator|/
name|cellrate
expr_stmt|;
name|WRITE_MBOX4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_CS_TGRLD
argument_list|(
name|n
argument_list|)
argument_list|,
name|tmp
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cellrate
operator|-=
name|decr
expr_stmt|;
block|}
name|i
operator|=
operator|(
name|sc
operator|->
name|cells_per_lbuf
operator|==
literal|2
operator|)
condition|?
literal|0
else|:
operator|(
name|sc
operator|->
name|cells_per_lbuf
operator|==
literal|4
operator|)
condition|?
literal|1
else|:
literal|2
expr_stmt|;
comment|/* table 5.2 */
name|WRITE_MBOX4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_CS_ERTHR0
argument_list|,
name|erthr
index|[
name|sc
operator|->
name|he622
index|]
index|[
literal|0
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|WRITE_MBOX4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_CS_ERTHR1
argument_list|,
name|erthr
index|[
name|sc
operator|->
name|he622
index|]
index|[
literal|1
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|WRITE_MBOX4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_CS_ERTHR2
argument_list|,
name|erthr
index|[
name|sc
operator|->
name|he622
index|]
index|[
literal|2
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|WRITE_MBOX4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_CS_ERTHR3
argument_list|,
name|erthr
index|[
name|sc
operator|->
name|he622
index|]
index|[
literal|3
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|WRITE_MBOX4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_CS_ERTHR4
argument_list|,
name|erthr
index|[
name|sc
operator|->
name|he622
index|]
index|[
literal|4
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|WRITE_MBOX4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_CS_ERCTL0
argument_list|,
name|erctl
index|[
name|sc
operator|->
name|he622
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|WRITE_MBOX4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_CS_ERCTL1
argument_list|,
name|erctl
index|[
name|sc
operator|->
name|he622
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|WRITE_MBOX4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_CS_ERCTL2
argument_list|,
name|erctl
index|[
name|sc
operator|->
name|he622
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|WRITE_MBOX4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_CS_ERSTAT0
argument_list|,
name|erstat
index|[
name|sc
operator|->
name|he622
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|WRITE_MBOX4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_CS_ERSTAT1
argument_list|,
name|erstat
index|[
name|sc
operator|->
name|he622
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|WRITE_MBOX4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_CS_RTFWR
argument_list|,
name|rtfwr
index|[
name|sc
operator|->
name|he622
index|]
argument_list|)
expr_stmt|;
name|WRITE_MBOX4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_CS_RTATR
argument_list|,
name|rtatr
index|[
name|sc
operator|->
name|he622
index|]
argument_list|)
expr_stmt|;
name|WRITE_MBOX4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_CS_TFBSET
argument_list|,
name|bwalloc
index|[
name|sc
operator|->
name|he622
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|WRITE_MBOX4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_CS_WCRMAX
argument_list|,
name|bwalloc
index|[
name|sc
operator|->
name|he622
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|WRITE_MBOX4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_CS_WCRMIN
argument_list|,
name|bwalloc
index|[
name|sc
operator|->
name|he622
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|WRITE_MBOX4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_CS_WCRINC
argument_list|,
name|bwalloc
index|[
name|sc
operator|->
name|he622
index|]
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|WRITE_MBOX4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_CS_WCRDEC
argument_list|,
name|bwalloc
index|[
name|sc
operator|->
name|he622
index|]
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|WRITE_MBOX4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_CS_WCRCEIL
argument_list|,
name|bwalloc
index|[
name|sc
operator|->
name|he622
index|]
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|WRITE_MBOX4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_CS_OTPPER
argument_list|,
name|orcf
index|[
name|sc
operator|->
name|he622
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|WRITE_MBOX4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_CS_OTWPER
argument_list|,
name|orcf
index|[
name|sc
operator|->
name|he622
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|WRITE_MBOX4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_CS_OTTLIM
argument_list|,
literal|8
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|8
condition|;
name|n
operator|++
control|)
name|WRITE_MBOX4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_CS_HGRRT
argument_list|(
name|n
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * 5.1.8 CS Block Connection Memory Initialisation  */
end_comment

begin_function
specifier|static
name|void
name|hatm_init_cs_block_cm
parameter_list|(
name|struct
name|hatm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int
name|n
decl_stmt|,
name|i
decl_stmt|;
name|u_int
name|expt
decl_stmt|,
name|mant
decl_stmt|,
name|etrm
decl_stmt|,
name|wcr
decl_stmt|,
name|ttnrm
decl_stmt|,
name|tnrm
decl_stmt|;
name|uint32_t
name|rate
decl_stmt|;
name|uint32_t
name|clkfreq
decl_stmt|,
name|cellrate
decl_stmt|,
name|decr
decl_stmt|;
name|uint32_t
modifier|*
name|rg
decl_stmt|,
name|rtg
decl_stmt|,
name|val
init|=
literal|0
decl_stmt|;
name|uint64_t
name|drate
decl_stmt|;
name|u_int
name|buf
decl_stmt|,
name|buf_limit
decl_stmt|;
name|uint32_t
name|base
init|=
name|READ4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RCMABR_BA
argument_list|)
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|HE_REGL_CM_GQTBL
condition|;
name|n
operator|++
control|)
name|WRITE_RCM4
argument_list|(
name|sc
argument_list|,
name|base
operator|+
name|HE_REGO_CM_GQTBL
operator|+
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|HE_REGL_CM_RGTBL
condition|;
name|n
operator|++
control|)
name|WRITE_RCM4
argument_list|(
name|sc
argument_list|,
name|base
operator|+
name|HE_REGO_CM_RGTBL
operator|+
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tnrm
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|HE_REGL_CM_TNRMTBL
operator|*
literal|4
condition|;
name|n
operator|++
control|)
block|{
name|expt
operator|=
operator|(
name|n
operator|>>
literal|5
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|mant
operator|=
operator|(
operator|(
name|n
operator|&
literal|0x18
operator|)
operator|<<
literal|4
operator|)
operator||
literal|0x7f
expr_stmt|;
name|wcr
operator|=
operator|(
literal|1
operator|<<
name|expt
operator|)
operator|*
operator|(
name|mant
operator|+
literal|512
operator|)
operator|/
literal|512
expr_stmt|;
name|etrm
operator|=
name|n
operator|&
literal|0x7
expr_stmt|;
name|ttnrm
operator|=
name|wcr
operator|/
literal|10
operator|/
operator|(
literal|1
operator|<<
name|etrm
operator|)
expr_stmt|;
if|if
condition|(
name|ttnrm
operator|>
literal|255
condition|)
name|ttnrm
operator|=
literal|255
expr_stmt|;
elseif|else
if|if
condition|(
name|ttnrm
operator|<
literal|2
condition|)
name|ttnrm
operator|=
literal|2
expr_stmt|;
name|tnrm
operator|=
operator|(
name|tnrm
operator|<<
literal|8
operator|)
operator||
operator|(
name|ttnrm
operator|&
literal|0xff
operator|)
expr_stmt|;
if|if
condition|(
name|n
operator|%
literal|4
operator|==
literal|0
condition|)
name|WRITE_RCM4
argument_list|(
name|sc
argument_list|,
name|base
operator|+
name|HE_REGO_CM_TNRMTBL
operator|+
operator|(
name|n
operator|/
literal|4
operator|)
argument_list|,
name|tnrm
argument_list|)
expr_stmt|;
block|}
name|clkfreq
operator|=
name|sc
operator|->
name|he622
condition|?
name|HE_622_CLOCK
else|:
name|HE_155_CLOCK
expr_stmt|;
name|buf_limit
operator|=
literal|4
expr_stmt|;
name|cellrate
operator|=
name|sc
operator|->
name|he622
condition|?
name|ATM_RATE_622M
else|:
name|ATM_RATE_155M
expr_stmt|;
name|decr
operator|=
name|cellrate
operator|/
literal|32
expr_stmt|;
comment|/* compute GRID top row in 1000 * cps */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|16
condition|;
name|n
operator|++
control|)
block|{
name|u_int
name|interval
init|=
name|clkfreq
operator|/
name|cellrate
decl_stmt|;
name|sc
operator|->
name|rate_grid
index|[
literal|0
index|]
index|[
name|n
index|]
operator|=
operator|(
name|u_int64_t
operator|)
name|clkfreq
operator|*
literal|1000
operator|/
name|interval
expr_stmt|;
name|cellrate
operator|-=
name|decr
expr_stmt|;
block|}
comment|/* compute the other rows according to 2.4 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|16
condition|;
name|n
operator|++
control|)
name|sc
operator|->
name|rate_grid
index|[
name|i
index|]
index|[
name|n
index|]
operator|=
name|sc
operator|->
name|rate_grid
index|[
name|i
operator|-
literal|1
index|]
index|[
name|n
index|]
operator|/
operator|(
operator|(
name|i
operator|<
literal|14
operator|)
condition|?
literal|2
else|:
literal|4
operator|)
expr_stmt|;
comment|/* first entry is line rate */
name|n
operator|=
name|hatm_cps2atmf
argument_list|(
name|sc
operator|->
name|he622
condition|?
name|ATM_RATE_622M
else|:
name|ATM_RATE_155M
argument_list|)
expr_stmt|;
name|expt
operator|=
operator|(
name|n
operator|>>
literal|9
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|mant
operator|=
name|n
operator|&
literal|0x1f0
expr_stmt|;
name|sc
operator|->
name|rate_grid
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
call|(
name|u_int64_t
call|)
argument_list|(
literal|1
operator|<<
name|expt
argument_list|)
operator|*
literal|1000
operator|*
operator|(
name|mant
operator|+
literal|512
operator|)
operator|/
literal|512
expr_stmt|;
comment|/* now build the conversion table - each 32 bit word contains 	 * two entries - this gives a total of 0x400 16 bit entries. 	 * This table maps the truncated ATMF rate version into a grid index */
name|cellrate
operator|=
name|sc
operator|->
name|he622
condition|?
name|ATM_RATE_622M
else|:
name|ATM_RATE_155M
expr_stmt|;
name|rg
operator|=
operator|&
name|sc
operator|->
name|rate_grid
index|[
literal|15
index|]
index|[
literal|15
index|]
expr_stmt|;
for|for
control|(
name|rate
operator|=
literal|0
init|;
name|rate
operator|<
literal|2
operator|*
name|HE_REGL_CM_RTGTBL
condition|;
name|rate
operator|++
control|)
block|{
comment|/* unpack the ATMF rate */
name|expt
operator|=
name|rate
operator|>>
literal|5
expr_stmt|;
name|mant
operator|=
operator|(
name|rate
operator|&
literal|0x1f
operator|)
operator|<<
literal|4
expr_stmt|;
comment|/* get the cell rate - minimum is 10 per second */
name|drate
operator|=
call|(
name|uint64_t
call|)
argument_list|(
literal|1
operator|<<
name|expt
argument_list|)
operator|*
literal|1000
operator|*
operator|(
name|mant
operator|+
literal|512
operator|)
operator|/
literal|512
expr_stmt|;
if|if
condition|(
name|drate
operator|<
literal|10
operator|*
literal|1000
condition|)
name|drate
operator|=
literal|10
operator|*
literal|1000
expr_stmt|;
comment|/* now look up the grid index */
while|while
condition|(
name|drate
operator|>=
operator|*
name|rg
operator|&&
name|rg
operator|--
operator|>
operator|&
name|sc
operator|->
name|rate_grid
index|[
literal|0
index|]
index|[
literal|0
index|]
condition|)
empty_stmt|;
name|rg
operator|++
expr_stmt|;
name|rtg
operator|=
name|rg
operator|-
operator|&
name|sc
operator|->
name|rate_grid
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
comment|/* now compute the buffer limit */
name|buf
operator|=
name|drate
operator|*
name|sc
operator|->
name|tx_numbuffs
operator|/
operator|(
name|cellrate
operator|*
literal|2
operator|)
operator|/
literal|1000
expr_stmt|;
if|if
condition|(
name|buf
operator|==
literal|0
condition|)
name|buf
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|buf
operator|>
name|buf_limit
condition|)
name|buf
operator|=
name|buf_limit
expr_stmt|;
comment|/* make value */
name|val
operator|=
operator|(
name|val
operator|<<
literal|16
operator|)
operator||
operator|(
name|rtg
operator|<<
literal|8
operator|)
operator||
name|buf
expr_stmt|;
comment|/* write */
if|if
condition|(
name|rate
operator|%
literal|2
operator|==
literal|1
condition|)
name|WRITE_RCM4
argument_list|(
name|sc
argument_list|,
name|base
operator|+
name|HE_REGO_CM_RTGTBL
operator|+
name|rate
operator|/
literal|2
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Clear an unused receive group buffer pool  */
end_comment

begin_function
specifier|static
name|void
name|hatm_clear_rpool
parameter_list|(
name|struct
name|hatm_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|group
parameter_list|,
name|u_int
name|large
parameter_list|)
block|{
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RBP_S
argument_list|(
name|large
argument_list|,
name|group
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RBP_T
argument_list|(
name|large
argument_list|,
name|group
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RBP_QI
argument_list|(
name|large
argument_list|,
name|group
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RBP_BL
argument_list|(
name|large
argument_list|,
name|group
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize a receive group buffer pool  */
end_comment

begin_function
specifier|static
name|void
name|hatm_init_rpool
parameter_list|(
name|struct
name|hatm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|herbp
modifier|*
name|q
parameter_list|,
name|u_int
name|group
parameter_list|,
name|u_int
name|large
parameter_list|)
block|{
if|if
condition|(
name|q
operator|->
name|size
operator|==
literal|0
condition|)
block|{
name|hatm_clear_rpool
argument_list|(
name|sc
argument_list|,
name|group
argument_list|,
name|large
argument_list|)
expr_stmt|;
return|return;
block|}
name|bzero
argument_list|(
name|q
operator|->
name|mem
operator|.
name|base
argument_list|,
name|q
operator|->
name|mem
operator|.
name|size
argument_list|)
expr_stmt|;
name|q
operator|->
name|rbp
operator|=
name|q
operator|->
name|mem
operator|.
name|base
expr_stmt|;
name|q
operator|->
name|head
operator|=
name|q
operator|->
name|tail
operator|=
literal|0
expr_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|ATTACH
argument_list|,
operator|(
literal|"RBP%u%c=0x%lx"
operator|,
name|group
operator|,
literal|"SL"
index|[
name|large
index|]
operator|,
operator|(
name|u_long
operator|)
name|q
operator|->
name|mem
operator|.
name|paddr
operator|)
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RBP_S
argument_list|(
name|large
argument_list|,
name|group
argument_list|)
argument_list|,
name|q
operator|->
name|mem
operator|.
name|paddr
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RBP_T
argument_list|(
name|large
argument_list|,
name|group
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RBP_QI
argument_list|(
name|large
argument_list|,
name|group
argument_list|)
argument_list|,
operator|(
operator|(
name|q
operator|->
name|size
operator|-
literal|1
operator|)
operator|<<
name|HE_REGS_RBP_SIZE
operator|)
operator||
name|HE_REGM_RBP_INTR_ENB
operator||
operator|(
name|q
operator|->
name|thresh
operator|<<
name|HE_REGS_RBP_THRESH
operator|)
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RBP_BL
argument_list|(
name|large
argument_list|,
name|group
argument_list|)
argument_list|,
operator|(
name|q
operator|->
name|bsize
operator|>>
literal|2
operator|)
operator|&
operator|~
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Clear an unused receive buffer return queue  */
end_comment

begin_function
specifier|static
name|void
name|hatm_clear_rbrq
parameter_list|(
name|struct
name|hatm_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|group
parameter_list|)
block|{
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RBRQ_ST
argument_list|(
name|group
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RBRQ_H
argument_list|(
name|group
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RBRQ_Q
argument_list|(
name|group
argument_list|)
argument_list|,
operator|(
literal|1
operator|<<
name|HE_REGS_RBRQ_THRESH
operator|)
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RBRQ_I
argument_list|(
name|group
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize receive buffer return queue  */
end_comment

begin_function
specifier|static
name|void
name|hatm_init_rbrq
parameter_list|(
name|struct
name|hatm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|herbrq
modifier|*
name|rq
parameter_list|,
name|u_int
name|group
parameter_list|)
block|{
if|if
condition|(
name|rq
operator|->
name|size
operator|==
literal|0
condition|)
block|{
name|hatm_clear_rbrq
argument_list|(
name|sc
argument_list|,
name|group
argument_list|)
expr_stmt|;
return|return;
block|}
name|rq
operator|->
name|rbrq
operator|=
name|rq
operator|->
name|mem
operator|.
name|base
expr_stmt|;
name|rq
operator|->
name|head
operator|=
literal|0
expr_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|ATTACH
argument_list|,
operator|(
literal|"RBRQ%u=0x%lx"
operator|,
name|group
operator|,
operator|(
name|u_long
operator|)
name|rq
operator|->
name|mem
operator|.
name|paddr
operator|)
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RBRQ_ST
argument_list|(
name|group
argument_list|)
argument_list|,
name|rq
operator|->
name|mem
operator|.
name|paddr
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RBRQ_H
argument_list|(
name|group
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RBRQ_Q
argument_list|(
name|group
argument_list|)
argument_list|,
operator|(
name|rq
operator|->
name|thresh
operator|<<
name|HE_REGS_RBRQ_THRESH
operator|)
operator||
operator|(
operator|(
name|rq
operator|->
name|size
operator|-
literal|1
operator|)
operator|<<
name|HE_REGS_RBRQ_SIZE
operator|)
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RBRQ_I
argument_list|(
name|group
argument_list|)
argument_list|,
operator|(
name|rq
operator|->
name|tout
operator|<<
name|HE_REGS_RBRQ_TIME
operator|)
operator||
operator|(
name|rq
operator|->
name|pcnt
operator|<<
name|HE_REGS_RBRQ_COUNT
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Clear an unused transmit buffer return queue N  */
end_comment

begin_function
specifier|static
name|void
name|hatm_clear_tbrq
parameter_list|(
name|struct
name|hatm_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|group
parameter_list|)
block|{
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_TBRQ_B_T
argument_list|(
name|group
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_TBRQ_H
argument_list|(
name|group
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_TBRQ_S
argument_list|(
name|group
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_TBRQ_THRESH
argument_list|(
name|group
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize transmit buffer return queue N  */
end_comment

begin_function
specifier|static
name|void
name|hatm_init_tbrq
parameter_list|(
name|struct
name|hatm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|hetbrq
modifier|*
name|tq
parameter_list|,
name|u_int
name|group
parameter_list|)
block|{
if|if
condition|(
name|tq
operator|->
name|size
operator|==
literal|0
condition|)
block|{
name|hatm_clear_tbrq
argument_list|(
name|sc
argument_list|,
name|group
argument_list|)
expr_stmt|;
return|return;
block|}
name|tq
operator|->
name|tbrq
operator|=
name|tq
operator|->
name|mem
operator|.
name|base
expr_stmt|;
name|tq
operator|->
name|head
operator|=
literal|0
expr_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|ATTACH
argument_list|,
operator|(
literal|"TBRQ%u=0x%lx"
operator|,
name|group
operator|,
operator|(
name|u_long
operator|)
name|tq
operator|->
name|mem
operator|.
name|paddr
operator|)
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_TBRQ_B_T
argument_list|(
name|group
argument_list|)
argument_list|,
name|tq
operator|->
name|mem
operator|.
name|paddr
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_TBRQ_H
argument_list|(
name|group
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_TBRQ_S
argument_list|(
name|group
argument_list|)
argument_list|,
name|tq
operator|->
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_TBRQ_THRESH
argument_list|(
name|group
argument_list|)
argument_list|,
name|tq
operator|->
name|thresh
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize TPDRQ  */
end_comment

begin_function
specifier|static
name|void
name|hatm_init_tpdrq
parameter_list|(
name|struct
name|hatm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|hetpdrq
modifier|*
name|tq
decl_stmt|;
name|tq
operator|=
operator|&
name|sc
operator|->
name|tpdrq
expr_stmt|;
name|tq
operator|->
name|tpdrq
operator|=
name|tq
operator|->
name|mem
operator|.
name|base
expr_stmt|;
name|tq
operator|->
name|tail
operator|=
name|tq
operator|->
name|head
operator|=
literal|0
expr_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|ATTACH
argument_list|,
operator|(
literal|"TPDRQ=0x%lx"
operator|,
operator|(
name|u_long
operator|)
name|tq
operator|->
name|mem
operator|.
name|paddr
operator|)
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_TPDRQ_H
argument_list|,
name|tq
operator|->
name|mem
operator|.
name|paddr
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_TPDRQ_T
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_TPDRQ_S
argument_list|,
name|tq
operator|->
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function can be called by the infrastructure to start the card.  */
end_comment

begin_function
specifier|static
name|void
name|hatm_init
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|hatm_softc
modifier|*
name|sc
init|=
name|p
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|hatm_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hatm_initialize
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_enum
enum|enum
block|{
name|CTL_ISTATS
block|, }
enum|;
end_enum

begin_comment
comment|/*  * Sysctl handler  */
end_comment

begin_function
specifier|static
name|int
name|hatm_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hatm_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|uint32_t
modifier|*
name|ret
decl_stmt|;
name|int
name|error
decl_stmt|;
name|size_t
name|len
decl_stmt|;
switch|switch
condition|(
name|arg2
condition|)
block|{
case|case
name|CTL_ISTATS
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|istats
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"bad control code"
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|malloc
argument_list|(
name|len
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|arg2
condition|)
block|{
case|case
name|CTL_ISTATS
case|:
name|sc
operator|->
name|istats
operator|.
name|mcc
operator|+=
name|READ4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_MCC
argument_list|)
expr_stmt|;
name|sc
operator|->
name|istats
operator|.
name|oec
operator|+=
name|READ4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_OEC
argument_list|)
expr_stmt|;
name|sc
operator|->
name|istats
operator|.
name|dcc
operator|+=
name|READ4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_DCC
argument_list|)
expr_stmt|;
name|sc
operator|->
name|istats
operator|.
name|cec
operator|+=
name|READ4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_CEC
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|sc
operator|->
name|istats
argument_list|,
name|ret
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|istats
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|ret
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ret
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kenv_getuint
parameter_list|(
name|struct
name|hatm_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|var
parameter_list|,
name|u_int
modifier|*
name|ptr
parameter_list|,
name|u_int
name|def
parameter_list|,
name|int
name|rw
parameter_list|)
block|{
name|char
name|full
index|[
name|IFNAMSIZ
operator|+
literal|3
operator|+
literal|20
index|]
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|u_int
name|u
decl_stmt|;
operator|*
name|ptr
operator|=
name|def
expr_stmt|;
if|if
condition|(
name|SYSCTL_ADD_UINT
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|var
argument_list|,
name|rw
condition|?
name|CTLFLAG_RW
else|:
name|CTLFLAG_RD
argument_list|,
name|ptr
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|snprintf
argument_list|(
name|full
argument_list|,
sizeof|sizeof
argument_list|(
name|full
argument_list|)
argument_list|,
literal|"hw.%s.%s"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|=
name|kern_getenv
argument_list|(
name|full
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|u
operator|=
name|strtoul
argument_list|(
name|val
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|==
name|val
operator|||
operator|*
name|end
operator|!=
literal|'\0'
condition|)
block|{
name|freeenv
argument_list|(
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|freeenv
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"%s=%u\n"
argument_list|,
name|full
argument_list|,
name|u
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|=
name|u
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set configurable parameters. Many of these are configurable via  * kenv.  */
end_comment

begin_function
specifier|static
name|int
name|hatm_configure
parameter_list|(
name|struct
name|hatm_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Receive buffer pool 0 small */
name|kenv_getuint
argument_list|(
name|sc
argument_list|,
literal|"rbps0_size"
argument_list|,
operator|&
name|sc
operator|->
name|rbp_s0
operator|.
name|size
argument_list|,
name|HE_CONFIG_RBPS0_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kenv_getuint
argument_list|(
name|sc
argument_list|,
literal|"rbps0_thresh"
argument_list|,
operator|&
name|sc
operator|->
name|rbp_s0
operator|.
name|thresh
argument_list|,
name|HE_CONFIG_RBPS0_THRESH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rbp_s0
operator|.
name|bsize
operator|=
name|MBUF0_SIZE
expr_stmt|;
comment|/* Receive buffer pool 0 large */
name|kenv_getuint
argument_list|(
name|sc
argument_list|,
literal|"rbpl0_size"
argument_list|,
operator|&
name|sc
operator|->
name|rbp_l0
operator|.
name|size
argument_list|,
name|HE_CONFIG_RBPL0_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kenv_getuint
argument_list|(
name|sc
argument_list|,
literal|"rbpl0_thresh"
argument_list|,
operator|&
name|sc
operator|->
name|rbp_l0
operator|.
name|thresh
argument_list|,
name|HE_CONFIG_RBPL0_THRESH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rbp_l0
operator|.
name|bsize
operator|=
name|MCLBYTES
operator|-
name|MBUFL_OFFSET
expr_stmt|;
comment|/* Receive buffer return queue 0 */
name|kenv_getuint
argument_list|(
name|sc
argument_list|,
literal|"rbrq0_size"
argument_list|,
operator|&
name|sc
operator|->
name|rbrq_0
operator|.
name|size
argument_list|,
name|HE_CONFIG_RBRQ0_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kenv_getuint
argument_list|(
name|sc
argument_list|,
literal|"rbrq0_thresh"
argument_list|,
operator|&
name|sc
operator|->
name|rbrq_0
operator|.
name|thresh
argument_list|,
name|HE_CONFIG_RBRQ0_THRESH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kenv_getuint
argument_list|(
name|sc
argument_list|,
literal|"rbrq0_tout"
argument_list|,
operator|&
name|sc
operator|->
name|rbrq_0
operator|.
name|tout
argument_list|,
name|HE_CONFIG_RBRQ0_TOUT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kenv_getuint
argument_list|(
name|sc
argument_list|,
literal|"rbrq0_pcnt"
argument_list|,
operator|&
name|sc
operator|->
name|rbrq_0
operator|.
name|pcnt
argument_list|,
name|HE_CONFIG_RBRQ0_PCNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Receive buffer pool 1 small */
name|kenv_getuint
argument_list|(
name|sc
argument_list|,
literal|"rbps1_size"
argument_list|,
operator|&
name|sc
operator|->
name|rbp_s1
operator|.
name|size
argument_list|,
name|HE_CONFIG_RBPS1_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kenv_getuint
argument_list|(
name|sc
argument_list|,
literal|"rbps1_thresh"
argument_list|,
operator|&
name|sc
operator|->
name|rbp_s1
operator|.
name|thresh
argument_list|,
name|HE_CONFIG_RBPS1_THRESH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rbp_s1
operator|.
name|bsize
operator|=
name|MBUF1_SIZE
expr_stmt|;
comment|/* Receive buffer return queue 1 */
name|kenv_getuint
argument_list|(
name|sc
argument_list|,
literal|"rbrq1_size"
argument_list|,
operator|&
name|sc
operator|->
name|rbrq_1
operator|.
name|size
argument_list|,
name|HE_CONFIG_RBRQ1_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kenv_getuint
argument_list|(
name|sc
argument_list|,
literal|"rbrq1_thresh"
argument_list|,
operator|&
name|sc
operator|->
name|rbrq_1
operator|.
name|thresh
argument_list|,
name|HE_CONFIG_RBRQ1_THRESH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kenv_getuint
argument_list|(
name|sc
argument_list|,
literal|"rbrq1_tout"
argument_list|,
operator|&
name|sc
operator|->
name|rbrq_1
operator|.
name|tout
argument_list|,
name|HE_CONFIG_RBRQ1_TOUT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kenv_getuint
argument_list|(
name|sc
argument_list|,
literal|"rbrq1_pcnt"
argument_list|,
operator|&
name|sc
operator|->
name|rbrq_1
operator|.
name|pcnt
argument_list|,
name|HE_CONFIG_RBRQ1_PCNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Interrupt queue 0 */
name|kenv_getuint
argument_list|(
name|sc
argument_list|,
literal|"irq0_size"
argument_list|,
operator|&
name|sc
operator|->
name|irq_0
operator|.
name|size
argument_list|,
name|HE_CONFIG_IRQ0_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kenv_getuint
argument_list|(
name|sc
argument_list|,
literal|"irq0_thresh"
argument_list|,
operator|&
name|sc
operator|->
name|irq_0
operator|.
name|thresh
argument_list|,
name|HE_CONFIG_IRQ0_THRESH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq_0
operator|.
name|line
operator|=
name|HE_CONFIG_IRQ0_LINE
expr_stmt|;
comment|/* Transmit buffer return queue 0 */
name|kenv_getuint
argument_list|(
name|sc
argument_list|,
literal|"tbrq0_size"
argument_list|,
operator|&
name|sc
operator|->
name|tbrq
operator|.
name|size
argument_list|,
name|HE_CONFIG_TBRQ_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kenv_getuint
argument_list|(
name|sc
argument_list|,
literal|"tbrq0_thresh"
argument_list|,
operator|&
name|sc
operator|->
name|tbrq
operator|.
name|thresh
argument_list|,
name|HE_CONFIG_TBRQ_THRESH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Transmit buffer ready queue */
name|kenv_getuint
argument_list|(
name|sc
argument_list|,
literal|"tpdrq_size"
argument_list|,
operator|&
name|sc
operator|->
name|tpdrq
operator|.
name|size
argument_list|,
name|HE_CONFIG_TPDRQ_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Max TPDs per VCC */
name|kenv_getuint
argument_list|(
name|sc
argument_list|,
literal|"tpdmax"
argument_list|,
operator|&
name|sc
operator|->
name|max_tpd
argument_list|,
name|HE_CONFIG_TPD_MAXCC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* external mbuf pages */
name|kenv_getuint
argument_list|(
name|sc
argument_list|,
literal|"max_mbuf_pages"
argument_list|,
operator|&
name|sc
operator|->
name|mbuf_max_pages
argument_list|,
name|HE_CONFIG_MAX_MBUF_PAGES
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* mpsafe */
name|kenv_getuint
argument_list|(
name|sc
argument_list|,
literal|"mpsafe"
argument_list|,
operator|&
name|sc
operator|->
name|mpsafe
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mpsafe
operator|!=
literal|0
condition|)
name|sc
operator|->
name|mpsafe
operator|=
name|INTR_MPSAFE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HATM_DEBUG
end_ifdef

begin_comment
comment|/*  * Get TSRs from connection memory  */
end_comment

begin_function
specifier|static
name|int
name|hatm_sysctl_tsr
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hatm_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|uint32_t
modifier|*
name|val
decl_stmt|;
name|val
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
name|HE_MAX_VCCS
operator|*
literal|15
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HE_MAX_VCCS
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
literal|14
condition|;
name|j
operator|++
control|)
name|val
index|[
literal|15
operator|*
name|i
operator|+
name|j
index|]
operator|=
name|READ_TSR
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
name|HE_MAX_VCCS
operator|*
literal|15
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|val
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get TPDs from connection memory  */
end_comment

begin_function
specifier|static
name|int
name|hatm_sysctl_tpd
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hatm_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|uint32_t
modifier|*
name|val
decl_stmt|;
name|val
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
name|HE_MAX_VCCS
operator|*
literal|16
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HE_MAX_VCCS
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
name|val
index|[
literal|16
operator|*
name|i
operator|+
name|j
index|]
operator|=
name|READ_TCM4
argument_list|(
name|sc
argument_list|,
literal|16
operator|*
name|i
operator|+
name|j
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
name|HE_MAX_VCCS
operator|*
literal|16
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|val
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get mbox registers  */
end_comment

begin_function
specifier|static
name|int
name|hatm_sysctl_mbox
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hatm_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|uint32_t
modifier|*
name|val
decl_stmt|;
name|val
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
name|HE_REGO_CS_END
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HE_REGO_CS_END
condition|;
name|i
operator|++
control|)
name|val
index|[
name|i
index|]
operator|=
name|READ_MBOX4
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
name|HE_REGO_CS_END
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|val
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get connection memory  */
end_comment

begin_function
specifier|static
name|int
name|hatm_sysctl_cm
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hatm_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|uint32_t
modifier|*
name|val
decl_stmt|;
name|val
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
operator|(
name|HE_CONFIG_RXMEM
operator|+
literal|1
operator|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|val
index|[
literal|0
index|]
operator|=
name|READ4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RCMABR_BA
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HE_CONFIG_RXMEM
condition|;
name|i
operator|++
control|)
name|val
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|READ_RCM4
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
operator|(
name|HE_CONFIG_RXMEM
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|val
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get local buffer memory  */
end_comment

begin_function
specifier|static
name|int
name|hatm_sysctl_lbmem
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hatm_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|uint32_t
modifier|*
name|val
decl_stmt|;
name|u_int
name|bytes
init|=
operator|(
literal|1
operator|<<
literal|21
operator|)
decl_stmt|;
name|val
operator|=
name|malloc
argument_list|(
name|bytes
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bytes
operator|/
literal|4
condition|;
name|i
operator|++
control|)
name|val
index|[
name|i
index|]
operator|=
name|READ_LB4
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|val
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|val
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get all card registers  */
end_comment

begin_function
specifier|static
name|int
name|hatm_sysctl_heregs
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|hatm_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|uint32_t
modifier|*
name|val
decl_stmt|;
name|val
operator|=
name|malloc
argument_list|(
name|HE_REGO_END
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HE_REGO_END
condition|;
name|i
operator|+=
literal|4
control|)
name|val
index|[
name|i
operator|/
literal|4
index|]
operator|=
name|READ4
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|val
argument_list|,
name|HE_REGO_END
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|val
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Suni register access  */
end_comment

begin_comment
comment|/*  * read at most n SUNI registers starting at reg into val  */
end_comment

begin_function
specifier|static
name|int
name|hatm_utopia_readregs
parameter_list|(
name|struct
name|ifatm
modifier|*
name|ifatm
parameter_list|,
name|u_int
name|reg
parameter_list|,
name|uint8_t
modifier|*
name|val
parameter_list|,
name|u_int
modifier|*
name|n
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|struct
name|hatm_softc
modifier|*
name|sc
init|=
name|ifatm
operator|->
name|ifp
operator|->
name|if_softc
decl_stmt|;
if|if
condition|(
name|reg
operator|>=
operator|(
name|HE_REGO_SUNI_END
operator|-
name|HE_REGO_SUNI
operator|)
operator|/
literal|4
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|reg
operator|+
operator|*
name|n
operator|>
operator|(
name|HE_REGO_SUNI_END
operator|-
name|HE_REGO_SUNI
operator|)
operator|/
literal|4
condition|)
operator|*
name|n
operator|=
name|reg
operator|-
operator|(
name|HE_REGO_SUNI_END
operator|-
name|HE_REGO_SUNI
operator|)
operator|/
literal|4
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|n
condition|;
name|i
operator|++
control|)
name|val
index|[
name|i
index|]
operator|=
name|READ4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_SUNI
operator|+
literal|4
operator|*
operator|(
name|reg
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * change the bits given by mask to them in val in register reg  */
end_comment

begin_function
specifier|static
name|int
name|hatm_utopia_writereg
parameter_list|(
name|struct
name|ifatm
modifier|*
name|ifatm
parameter_list|,
name|u_int
name|reg
parameter_list|,
name|u_int
name|mask
parameter_list|,
name|u_int
name|val
parameter_list|)
block|{
name|uint32_t
name|regval
decl_stmt|;
name|struct
name|hatm_softc
modifier|*
name|sc
init|=
name|ifatm
operator|->
name|ifp
operator|->
name|if_softc
decl_stmt|;
if|if
condition|(
name|reg
operator|>=
operator|(
name|HE_REGO_SUNI_END
operator|-
name|HE_REGO_SUNI
operator|)
operator|/
literal|4
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|regval
operator|=
name|READ4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_SUNI
operator|+
literal|4
operator|*
name|reg
argument_list|)
expr_stmt|;
name|regval
operator|=
operator|(
name|regval
operator|&
operator|~
name|mask
operator|)
operator||
operator|(
name|val
operator|&
name|mask
operator|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_SUNI
operator|+
literal|4
operator|*
name|reg
argument_list|,
name|regval
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|utopia_methods
name|hatm_utopia_methods
init|=
block|{
name|hatm_utopia_readregs
block|,
name|hatm_utopia_writereg
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Detach - if it is running, stop. Destroy.  */
end_comment

begin_function
specifier|static
name|int
name|hatm_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hatm_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|hatm_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|utopia
operator|.
name|state
operator|&
name|UTP_ST_ATTACHED
condition|)
block|{
name|utopia_stop
argument_list|(
operator|&
name|sc
operator|->
name|utopia
argument_list|)
expr_stmt|;
name|utopia_detach
argument_list|(
operator|&
name|sc
operator|->
name|utopia
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|atm_ifdetach
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|hatm_destroy
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach to the device. Assume that no locking is needed here.  * All resource we allocate here are freed by calling hatm_destroy.  */
end_comment

begin_function
specifier|static
name|int
name|hatm_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hatm_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint32_t
name|v
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ATM
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not if_alloc()\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|device
operator|=
name|ATM_DEVICE_HE155
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|serial
operator|=
literal|0
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|hw_version
operator|=
literal|0
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|sw_version
operator|=
literal|0
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|vpi_bits
operator|=
name|HE_CONFIG_VPI_BITS
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|vci_bits
operator|=
name|HE_CONFIG_VCI_BITS
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|max_vpcs
operator|=
literal|0
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|max_vccs
operator|=
name|HE_MAX_VCCS
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|media
operator|=
name|IFM_ATM_UNKNOWN
expr_stmt|;
name|sc
operator|->
name|he622
operator|=
literal|0
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|phy
operator|=
operator|&
name|sc
operator|->
name|utopia
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|sc
operator|->
name|tpd_free
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|MTX_NETWORK_LOCK
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|sc
operator|->
name|vcc_cv
argument_list|,
literal|"HEVCCcv"
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|sc
operator|->
name|cv_rcclose
argument_list|,
literal|"RCClose"
argument_list|)
expr_stmt|;
name|sysctl_ctx_init
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|)
expr_stmt|;
comment|/* 	 * 4.2 BIOS Configuration 	 */
name|v
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|v
operator||=
name|PCIM_CMD_BUSMASTEREN
operator||
name|PCIM_CMD_MWRICEN
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|v
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 * 4.3 PCI Bus Controller-Specific Initialisation 	 */
name|v
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|HE_PCIR_GEN_CNTL_0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|v
operator||=
name|HE_PCIM_CTL0_MRL
operator||
name|HE_PCIM_CTL0_MRM
operator||
name|HE_PCIM_CTL0_IGNORE_TIMEOUT
expr_stmt|;
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
operator|&&
literal|0
name|v
operator||=
name|HE_PCIM_CTL0_BIGENDIAN
expr_stmt|;
endif|#
directive|endif
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|HE_PCIR_GEN_CNTL_0
argument_list|,
name|v
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* 	 * Map memory 	 */
name|sc
operator|->
name|memid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|memres
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|memid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|memres
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not map memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|sc
operator|->
name|memh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|memres
argument_list|)
expr_stmt|;
name|sc
operator|->
name|memt
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|memres
argument_list|)
expr_stmt|;
comment|/* 	 * ALlocate a DMA tag for subsequent allocations 	 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
literal|1
argument_list|,
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|parent_tag
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate DMA tag\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_tag
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MBUF_ALLOC_SIZE
argument_list|,
literal|1
argument_list|,
name|MBUF_ALLOC_SIZE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|mbuf_tag
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate mbuf DMA tag\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
comment|/* 	 * Allocate a DMA tag for packets to send. Here we have a problem with 	 * the specification of the maximum number of segments. Theoretically 	 * this would be the size of the transmit ring - 1 multiplied by 3, 	 * but this would not work. So make the maximum number of TPDs 	 * occupied by one packet a configuration parameter. 	 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|HE_MAX_PDU
argument_list|,
literal|3
operator|*
name|HE_CONFIG_MAX_TPD_PER_PACKET
argument_list|,
name|HE_MAX_PDU
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|tx_tag
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate TX tag\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
comment|/* 	 * Setup the interrupt 	 */
name|sc
operator|->
name|irqid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|irqres
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|irqid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irqres
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate irq\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Make the sysctl tree 	 */
name|error
operator|=
name|ENOMEM
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sysctl_tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_STATIC_CHILDREN
argument_list|(
name|_hw_atm
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
if|if
condition|(
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"istats"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|sc
argument_list|,
name|CTL_ISTATS
argument_list|,
name|hatm_sysctl
argument_list|,
literal|"LU"
argument_list|,
literal|"internal statistics"
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
ifdef|#
directive|ifdef
name|HATM_DEBUG
if|if
condition|(
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tsr"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|hatm_sysctl_tsr
argument_list|,
literal|"S"
argument_list|,
literal|"transmission status registers"
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
if|if
condition|(
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tpd"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|hatm_sysctl_tpd
argument_list|,
literal|"S"
argument_list|,
literal|"transmission packet descriptors"
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
if|if
condition|(
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mbox"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|hatm_sysctl_mbox
argument_list|,
literal|"S"
argument_list|,
literal|"mbox registers"
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
if|if
condition|(
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cm"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|hatm_sysctl_cm
argument_list|,
literal|"S"
argument_list|,
literal|"connection memory"
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
if|if
condition|(
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"heregs"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|hatm_sysctl_heregs
argument_list|,
literal|"S"
argument_list|,
literal|"card registers"
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
if|if
condition|(
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lbmem"
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|hatm_sysctl_lbmem
argument_list|,
literal|"S"
argument_list|,
literal|"local memory"
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
name|kenv_getuint
argument_list|(
name|sc
argument_list|,
literal|"debug"
argument_list|,
operator|&
name|sc
operator|->
name|debug
argument_list|,
name|HATM_DEBUG
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Configure 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|hatm_configure
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|failed
goto|;
comment|/* 	 * Compute memory parameters 	 */
if|if
condition|(
name|sc
operator|->
name|rbp_s0
operator|.
name|size
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|rbp_s0
operator|.
name|mask
operator|=
operator|(
name|sc
operator|->
name|rbp_s0
operator|.
name|size
operator|-
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
name|sc
operator|->
name|rbp_s0
operator|.
name|mem
operator|.
name|size
operator|=
name|sc
operator|->
name|rbp_s0
operator|.
name|size
operator|*
literal|8
expr_stmt|;
name|sc
operator|->
name|rbp_s0
operator|.
name|mem
operator|.
name|align
operator|=
name|sc
operator|->
name|rbp_s0
operator|.
name|mem
operator|.
name|size
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|rbp_l0
operator|.
name|size
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|rbp_l0
operator|.
name|mask
operator|=
operator|(
name|sc
operator|->
name|rbp_l0
operator|.
name|size
operator|-
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
name|sc
operator|->
name|rbp_l0
operator|.
name|mem
operator|.
name|size
operator|=
name|sc
operator|->
name|rbp_l0
operator|.
name|size
operator|*
literal|8
expr_stmt|;
name|sc
operator|->
name|rbp_l0
operator|.
name|mem
operator|.
name|align
operator|=
name|sc
operator|->
name|rbp_l0
operator|.
name|mem
operator|.
name|size
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|rbp_s1
operator|.
name|size
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|rbp_s1
operator|.
name|mask
operator|=
operator|(
name|sc
operator|->
name|rbp_s1
operator|.
name|size
operator|-
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
name|sc
operator|->
name|rbp_s1
operator|.
name|mem
operator|.
name|size
operator|=
name|sc
operator|->
name|rbp_s1
operator|.
name|size
operator|*
literal|8
expr_stmt|;
name|sc
operator|->
name|rbp_s1
operator|.
name|mem
operator|.
name|align
operator|=
name|sc
operator|->
name|rbp_s1
operator|.
name|mem
operator|.
name|size
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|rbrq_0
operator|.
name|size
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|rbrq_0
operator|.
name|mem
operator|.
name|size
operator|=
name|sc
operator|->
name|rbrq_0
operator|.
name|size
operator|*
literal|8
expr_stmt|;
name|sc
operator|->
name|rbrq_0
operator|.
name|mem
operator|.
name|align
operator|=
name|sc
operator|->
name|rbrq_0
operator|.
name|mem
operator|.
name|size
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|rbrq_1
operator|.
name|size
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|rbrq_1
operator|.
name|mem
operator|.
name|size
operator|=
name|sc
operator|->
name|rbrq_1
operator|.
name|size
operator|*
literal|8
expr_stmt|;
name|sc
operator|->
name|rbrq_1
operator|.
name|mem
operator|.
name|align
operator|=
name|sc
operator|->
name|rbrq_1
operator|.
name|mem
operator|.
name|size
expr_stmt|;
block|}
name|sc
operator|->
name|irq_0
operator|.
name|mem
operator|.
name|size
operator|=
name|sc
operator|->
name|irq_0
operator|.
name|size
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq_0
operator|.
name|mem
operator|.
name|align
operator|=
literal|4
operator|*
literal|1024
expr_stmt|;
name|sc
operator|->
name|tbrq
operator|.
name|mem
operator|.
name|size
operator|=
name|sc
operator|->
name|tbrq
operator|.
name|size
operator|*
literal|4
expr_stmt|;
name|sc
operator|->
name|tbrq
operator|.
name|mem
operator|.
name|align
operator|=
literal|2
operator|*
name|sc
operator|->
name|tbrq
operator|.
name|mem
operator|.
name|size
expr_stmt|;
comment|/* ZZZ */
name|sc
operator|->
name|tpdrq
operator|.
name|mem
operator|.
name|size
operator|=
name|sc
operator|->
name|tpdrq
operator|.
name|size
operator|*
literal|8
expr_stmt|;
name|sc
operator|->
name|tpdrq
operator|.
name|mem
operator|.
name|align
operator|=
name|sc
operator|->
name|tpdrq
operator|.
name|mem
operator|.
name|size
expr_stmt|;
name|sc
operator|->
name|hsp_mem
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|he_hsp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hsp_mem
operator|.
name|align
operator|=
literal|1024
expr_stmt|;
name|sc
operator|->
name|lbufs_size
operator|=
name|sc
operator|->
name|rbp_l0
operator|.
name|size
operator|+
name|sc
operator|->
name|rbrq_0
operator|.
name|size
expr_stmt|;
name|sc
operator|->
name|tpd_total
operator|=
name|sc
operator|->
name|tbrq
operator|.
name|size
operator|+
name|sc
operator|->
name|tpdrq
operator|.
name|size
expr_stmt|;
name|sc
operator|->
name|tpds
operator|.
name|align
operator|=
literal|64
expr_stmt|;
name|sc
operator|->
name|tpds
operator|.
name|size
operator|=
name|sc
operator|->
name|tpd_total
operator|*
name|HE_TPD_SIZE
expr_stmt|;
name|hatm_init_rmaps
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hatm_init_smbufs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|hatm_init_tpds
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|failed
goto|;
comment|/* 	 * Allocate memory 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|hatm_alloc_dmamem
argument_list|(
name|sc
argument_list|,
literal|"IRQ"
argument_list|,
operator|&
name|sc
operator|->
name|irq_0
operator|.
name|mem
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|error
operator|=
name|hatm_alloc_dmamem
argument_list|(
name|sc
argument_list|,
literal|"TBRQ0"
argument_list|,
operator|&
name|sc
operator|->
name|tbrq
operator|.
name|mem
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|error
operator|=
name|hatm_alloc_dmamem
argument_list|(
name|sc
argument_list|,
literal|"TPDRQ"
argument_list|,
operator|&
name|sc
operator|->
name|tpdrq
operator|.
name|mem
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|error
operator|=
name|hatm_alloc_dmamem
argument_list|(
name|sc
argument_list|,
literal|"HSP"
argument_list|,
operator|&
name|sc
operator|->
name|hsp_mem
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|failed
goto|;
if|if
condition|(
name|sc
operator|->
name|rbp_s0
operator|.
name|mem
operator|.
name|size
operator|!=
literal|0
operator|&&
operator|(
name|error
operator|=
name|hatm_alloc_dmamem
argument_list|(
name|sc
argument_list|,
literal|"RBPS0"
argument_list|,
operator|&
name|sc
operator|->
name|rbp_s0
operator|.
name|mem
argument_list|)
operator|)
condition|)
goto|goto
name|failed
goto|;
if|if
condition|(
name|sc
operator|->
name|rbp_l0
operator|.
name|mem
operator|.
name|size
operator|!=
literal|0
operator|&&
operator|(
name|error
operator|=
name|hatm_alloc_dmamem
argument_list|(
name|sc
argument_list|,
literal|"RBPL0"
argument_list|,
operator|&
name|sc
operator|->
name|rbp_l0
operator|.
name|mem
argument_list|)
operator|)
condition|)
goto|goto
name|failed
goto|;
if|if
condition|(
name|sc
operator|->
name|rbp_s1
operator|.
name|mem
operator|.
name|size
operator|!=
literal|0
operator|&&
operator|(
name|error
operator|=
name|hatm_alloc_dmamem
argument_list|(
name|sc
argument_list|,
literal|"RBPS1"
argument_list|,
operator|&
name|sc
operator|->
name|rbp_s1
operator|.
name|mem
argument_list|)
operator|)
condition|)
goto|goto
name|failed
goto|;
if|if
condition|(
name|sc
operator|->
name|rbrq_0
operator|.
name|mem
operator|.
name|size
operator|!=
literal|0
operator|&&
operator|(
name|error
operator|=
name|hatm_alloc_dmamem
argument_list|(
name|sc
argument_list|,
literal|"RBRQ0"
argument_list|,
operator|&
name|sc
operator|->
name|rbrq_0
operator|.
name|mem
argument_list|)
operator|)
condition|)
goto|goto
name|failed
goto|;
if|if
condition|(
name|sc
operator|->
name|rbrq_1
operator|.
name|mem
operator|.
name|size
operator|!=
literal|0
operator|&&
operator|(
name|error
operator|=
name|hatm_alloc_dmamem
argument_list|(
name|sc
argument_list|,
literal|"RBRQ1"
argument_list|,
operator|&
name|sc
operator|->
name|rbrq_1
operator|.
name|mem
argument_list|)
operator|)
condition|)
goto|goto
name|failed
goto|;
if|if
condition|(
operator|(
name|sc
operator|->
name|vcc_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"HE vccs"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hevcc
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate zone for vccs\n"
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
comment|/* 	 * 4.4 Reset the card. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|hatm_reset
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|failed
goto|;
comment|/* 	 * Read the prom. 	 */
name|hatm_init_bus_width
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hatm_init_read_eeprom
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hatm_init_endianess
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize interface 	 */
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_SIMPLEX
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|hatm_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|hatm_start
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|hatm_init
expr_stmt|;
name|utopia_attach
argument_list|(
operator|&
name|sc
operator|->
name|utopia
argument_list|,
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
argument_list|,
operator|&
name|sc
operator|->
name|media
argument_list|,
operator|&
name|sc
operator|->
name|mtx
argument_list|,
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
operator|&
name|hatm_utopia_methods
argument_list|)
expr_stmt|;
name|utopia_init_media
argument_list|(
operator|&
name|sc
operator|->
name|utopia
argument_list|)
expr_stmt|;
comment|/* these two SUNI routines need the lock */
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
comment|/* poll while we are not running */
name|sc
operator|->
name|utopia
operator|.
name|flags
operator||=
name|UTP_FL_POLL_CARRIER
expr_stmt|;
name|utopia_start
argument_list|(
operator|&
name|sc
operator|->
name|utopia
argument_list|)
expr_stmt|;
name|utopia_reset
argument_list|(
operator|&
name|sc
operator|->
name|utopia
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|atm_ifattach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_BPF
name|bpfattach
argument_list|(
name|ifp
argument_list|,
name|DLT_ATM_RFC1483
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|atmllc
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irqres
argument_list|,
name|sc
operator|->
name|mpsafe
operator||
name|INTR_TYPE_NET
argument_list|,
name|NULL
argument_list|,
name|hatm_intr
argument_list|,
operator|&
name|sc
operator|->
name|irq_0
argument_list|,
operator|&
name|sc
operator|->
name|ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not setup interrupt\n"
argument_list|)
expr_stmt|;
name|hatm_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|failed
label|:
name|hatm_destroy
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Start the interface. Assume a state as from attach().  */
end_comment

begin_function
name|void
name|hatm_initialize
parameter_list|(
name|struct
name|hatm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|v
decl_stmt|;
name|u_int
name|cid
decl_stmt|;
specifier|static
specifier|const
name|u_int
name|layout
index|[
literal|2
index|]
index|[
literal|7
index|]
init|=
name|HE_CONFIG_MEM_LAYOUT
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
return|return;
name|hatm_init_bus_width
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hatm_init_endianess
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"%s, Rev. %s, S/N %u, "
literal|"MAC=%02x:%02x:%02x:%02x:%02x:%02x (%ubit PCI)\n"
argument_list|,
name|sc
operator|->
name|prod_id
argument_list|,
name|sc
operator|->
name|rev
argument_list|,
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|serial
argument_list|,
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|esi
index|[
literal|0
index|]
argument_list|,
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|esi
index|[
literal|1
index|]
argument_list|,
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|esi
index|[
literal|2
index|]
argument_list|,
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|esi
index|[
literal|3
index|]
argument_list|,
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|esi
index|[
literal|4
index|]
argument_list|,
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|esi
index|[
literal|5
index|]
argument_list|,
name|sc
operator|->
name|pci64
condition|?
literal|64
else|:
literal|32
argument_list|)
expr_stmt|;
comment|/* 	 * 4.8 SDRAM Controller Initialisation 	 * 4.9 Initialize RNUM value 	 */
if|if
condition|(
name|sc
operator|->
name|he622
condition|)
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_SDRAM_CNTL
argument_list|,
name|HE_REGM_SDRAM_64BIT
argument_list|)
expr_stmt|;
else|else
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_SDRAM_CNTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|v
operator|=
name|READ4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_LB_SWAP
argument_list|)
expr_stmt|;
name|BARRIER_R
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|v
operator||=
literal|0xf
operator|<<
name|HE_REGS_LBSWAP_RNUM
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_LB_SWAP
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hatm_init_irq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|irq_0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hatm_clear_irq
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hatm_clear_irq
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|hatm_clear_irq
argument_list|(
name|sc
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_GRP_1_0_MAP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_GRP_3_2_MAP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_GRP_5_4_MAP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_GRP_7_6_MAP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * 4.11 Enable PCI Bus Controller State Machine 	 */
name|v
operator|=
name|READ4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_HOST_CNTL
argument_list|)
expr_stmt|;
name|BARRIER_R
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|v
operator||=
name|HE_REGM_HOST_OUTFF_ENB
operator||
name|HE_REGM_HOST_CMDFF_ENB
operator||
name|HE_REGM_HOST_QUICK_RD
operator||
name|HE_REGM_HOST_QUICK_WR
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_HOST_CNTL
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * 5.1.1 Generic configuration state 	 */
name|sc
operator|->
name|cells_per_row
operator|=
name|layout
index|[
name|sc
operator|->
name|he622
index|]
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|bytes_per_row
operator|=
name|layout
index|[
name|sc
operator|->
name|he622
index|]
index|[
literal|1
index|]
expr_stmt|;
name|sc
operator|->
name|r0_numrows
operator|=
name|layout
index|[
name|sc
operator|->
name|he622
index|]
index|[
literal|2
index|]
expr_stmt|;
name|sc
operator|->
name|tx_numrows
operator|=
name|layout
index|[
name|sc
operator|->
name|he622
index|]
index|[
literal|3
index|]
expr_stmt|;
name|sc
operator|->
name|r1_numrows
operator|=
name|layout
index|[
name|sc
operator|->
name|he622
index|]
index|[
literal|4
index|]
expr_stmt|;
name|sc
operator|->
name|r0_startrow
operator|=
name|layout
index|[
name|sc
operator|->
name|he622
index|]
index|[
literal|5
index|]
expr_stmt|;
name|sc
operator|->
name|tx_startrow
operator|=
name|sc
operator|->
name|r0_startrow
operator|+
name|sc
operator|->
name|r0_numrows
expr_stmt|;
name|sc
operator|->
name|r1_startrow
operator|=
name|sc
operator|->
name|tx_startrow
operator|+
name|sc
operator|->
name|tx_numrows
expr_stmt|;
name|sc
operator|->
name|cells_per_lbuf
operator|=
name|layout
index|[
name|sc
operator|->
name|he622
index|]
index|[
literal|6
index|]
expr_stmt|;
name|sc
operator|->
name|r0_numbuffs
operator|=
name|sc
operator|->
name|r0_numrows
operator|*
operator|(
name|sc
operator|->
name|cells_per_row
operator|/
name|sc
operator|->
name|cells_per_lbuf
operator|)
expr_stmt|;
name|sc
operator|->
name|r1_numbuffs
operator|=
name|sc
operator|->
name|r1_numrows
operator|*
operator|(
name|sc
operator|->
name|cells_per_row
operator|/
name|sc
operator|->
name|cells_per_lbuf
operator|)
expr_stmt|;
name|sc
operator|->
name|tx_numbuffs
operator|=
name|sc
operator|->
name|tx_numrows
operator|*
operator|(
name|sc
operator|->
name|cells_per_row
operator|/
name|sc
operator|->
name|cells_per_lbuf
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|r0_numbuffs
operator|>
literal|2560
condition|)
name|sc
operator|->
name|r0_numbuffs
operator|=
literal|2560
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|r1_numbuffs
operator|>
literal|2560
condition|)
name|sc
operator|->
name|r1_numbuffs
operator|=
literal|2560
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tx_numbuffs
operator|>
literal|5120
condition|)
name|sc
operator|->
name|tx_numbuffs
operator|=
literal|5120
expr_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|ATTACH
argument_list|,
operator|(
literal|"cells_per_row=%u bytes_per_row=%u r0_numrows=%u "
literal|"tx_numrows=%u r1_numrows=%u r0_startrow=%u tx_startrow=%u "
literal|"r1_startrow=%u cells_per_lbuf=%u\nr0_numbuffs=%u r1_numbuffs=%u "
literal|"tx_numbuffs=%u\n"
operator|,
name|sc
operator|->
name|cells_per_row
operator|,
name|sc
operator|->
name|bytes_per_row
operator|,
name|sc
operator|->
name|r0_numrows
operator|,
name|sc
operator|->
name|tx_numrows
operator|,
name|sc
operator|->
name|r1_numrows
operator|,
name|sc
operator|->
name|r0_startrow
operator|,
name|sc
operator|->
name|tx_startrow
operator|,
name|sc
operator|->
name|r1_startrow
operator|,
name|sc
operator|->
name|cells_per_lbuf
operator|,
name|sc
operator|->
name|r0_numbuffs
operator|,
name|sc
operator|->
name|r1_numbuffs
operator|,
name|sc
operator|->
name|tx_numbuffs
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * 5.1.2 Configure Hardware dependend registers 	 */
if|if
condition|(
name|sc
operator|->
name|he622
condition|)
block|{
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_LBARB
argument_list|,
operator|(
literal|0x2
operator|<<
name|HE_REGS_LBARB_SLICE
operator|)
operator||
operator|(
literal|0xf
operator|<<
name|HE_REGS_LBARB_RNUM
operator|)
operator||
operator|(
literal|0x3
operator|<<
name|HE_REGS_LBARB_THPRI
operator|)
operator||
operator|(
literal|0x3
operator|<<
name|HE_REGS_LBARB_RHPRI
operator|)
operator||
operator|(
literal|0x2
operator|<<
name|HE_REGS_LBARB_TLPRI
operator|)
operator||
operator|(
literal|0x1
operator|<<
name|HE_REGS_LBARB_RLPRI
operator|)
operator||
operator|(
literal|0x28
operator|<<
name|HE_REGS_LBARB_BUS_MULT
operator|)
operator||
operator|(
literal|0x50
operator|<<
name|HE_REGS_LBARB_NET_PREF
operator|)
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_SDRAMCON
argument_list|,
comment|/* HW bug: don't use banking */
comment|/* HE_REGM_SDRAMCON_BANK | */
name|HE_REGM_SDRAMCON_WIDE
operator||
operator|(
literal|0x384
operator|<<
name|HE_REGS_SDRAMCON_REF
operator|)
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RCMCONFIG
argument_list|,
operator|(
literal|0x1
operator|<<
name|HE_REGS_RCMCONFIG_BANK_WAIT
operator|)
operator||
operator|(
literal|0x1
operator|<<
name|HE_REGS_RCMCONFIG_RW_WAIT
operator|)
operator||
operator|(
literal|0x0
operator|<<
name|HE_REGS_RCMCONFIG_TYPE
operator|)
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_TCMCONFIG
argument_list|,
operator|(
literal|0x2
operator|<<
name|HE_REGS_TCMCONFIG_BANK_WAIT
operator|)
operator||
operator|(
literal|0x1
operator|<<
name|HE_REGS_TCMCONFIG_RW_WAIT
operator|)
operator||
operator|(
literal|0x0
operator|<<
name|HE_REGS_TCMCONFIG_TYPE
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_LBARB
argument_list|,
operator|(
literal|0x2
operator|<<
name|HE_REGS_LBARB_SLICE
operator|)
operator||
operator|(
literal|0xf
operator|<<
name|HE_REGS_LBARB_RNUM
operator|)
operator||
operator|(
literal|0x3
operator|<<
name|HE_REGS_LBARB_THPRI
operator|)
operator||
operator|(
literal|0x3
operator|<<
name|HE_REGS_LBARB_RHPRI
operator|)
operator||
operator|(
literal|0x2
operator|<<
name|HE_REGS_LBARB_TLPRI
operator|)
operator||
operator|(
literal|0x1
operator|<<
name|HE_REGS_LBARB_RLPRI
operator|)
operator||
operator|(
literal|0x46
operator|<<
name|HE_REGS_LBARB_BUS_MULT
operator|)
operator||
operator|(
literal|0x8C
operator|<<
name|HE_REGS_LBARB_NET_PREF
operator|)
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_SDRAMCON
argument_list|,
comment|/* HW bug: don't use banking */
comment|/* HE_REGM_SDRAMCON_BANK | */
operator|(
literal|0x150
operator|<<
name|HE_REGS_SDRAMCON_REF
operator|)
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RCMCONFIG
argument_list|,
operator|(
literal|0x0
operator|<<
name|HE_REGS_RCMCONFIG_BANK_WAIT
operator|)
operator||
operator|(
literal|0x1
operator|<<
name|HE_REGS_RCMCONFIG_RW_WAIT
operator|)
operator||
operator|(
literal|0x0
operator|<<
name|HE_REGS_RCMCONFIG_TYPE
operator|)
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_TCMCONFIG
argument_list|,
operator|(
literal|0x1
operator|<<
name|HE_REGS_TCMCONFIG_BANK_WAIT
operator|)
operator||
operator|(
literal|0x1
operator|<<
name|HE_REGS_TCMCONFIG_RW_WAIT
operator|)
operator||
operator|(
literal|0x0
operator|<<
name|HE_REGS_TCMCONFIG_TYPE
operator|)
argument_list|)
expr_stmt|;
block|}
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_LBCONFIG
argument_list|,
operator|(
name|sc
operator|->
name|cells_per_lbuf
operator|*
literal|48
operator|)
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RLBC_H
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RLBC_T
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RLBC_H2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RXTHRSH
argument_list|,
literal|512
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_LITHRSH
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RLBF0_C
argument_list|,
name|sc
operator|->
name|r0_numbuffs
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RLBF1_C
argument_list|,
name|sc
operator|->
name|r1_numbuffs
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|he622
condition|)
block|{
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RCCONFIG
argument_list|,
operator|(
literal|8
operator|<<
name|HE_REGS_RCCONFIG_UTDELAY
operator|)
operator||
operator|(
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|vpi_bits
operator|<<
name|HE_REGS_RCCONFIG_VP
operator|)
operator||
operator|(
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|vci_bits
operator|<<
name|HE_REGS_RCCONFIG_VC
operator|)
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_TXCONFIG
argument_list|,
operator|(
literal|32
operator|<<
name|HE_REGS_TXCONFIG_THRESH
operator|)
operator||
operator|(
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|vci_bits
operator|<<
name|HE_REGS_TXCONFIG_VCI_MASK
operator|)
operator||
operator|(
name|sc
operator|->
name|tx_numbuffs
operator|<<
name|HE_REGS_TXCONFIG_LBFREE
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RCCONFIG
argument_list|,
operator|(
literal|0
operator|<<
name|HE_REGS_RCCONFIG_UTDELAY
operator|)
operator||
name|HE_REGM_RCCONFIG_UT_MODE
operator||
operator|(
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|vpi_bits
operator|<<
name|HE_REGS_RCCONFIG_VP
operator|)
operator||
operator|(
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|vci_bits
operator|<<
name|HE_REGS_RCCONFIG_VC
operator|)
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_TXCONFIG
argument_list|,
operator|(
literal|32
operator|<<
name|HE_REGS_TXCONFIG_THRESH
operator|)
operator||
name|HE_REGM_TXCONFIG_UTMODE
operator||
operator|(
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|vci_bits
operator|<<
name|HE_REGS_TXCONFIG_VCI_MASK
operator|)
operator||
operator|(
name|sc
operator|->
name|tx_numbuffs
operator|<<
name|HE_REGS_TXCONFIG_LBFREE
operator|)
argument_list|)
expr_stmt|;
block|}
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_TXAAL5_PROTO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rbp_s1
operator|.
name|size
operator|!=
literal|0
condition|)
block|{
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RHCONFIG
argument_list|,
name|HE_REGM_RHCONFIG_PHYENB
operator||
operator|(
operator|(
name|sc
operator|->
name|he622
condition|?
literal|0x41
else|:
literal|0x31
operator|)
operator|<<
name|HE_REGS_RHCONFIG_PTMR_PRE
operator|)
operator||
operator|(
literal|1
operator|<<
name|HE_REGS_RHCONFIG_OAM_GID
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RHCONFIG
argument_list|,
name|HE_REGM_RHCONFIG_PHYENB
operator||
operator|(
operator|(
name|sc
operator|->
name|he622
condition|?
literal|0x41
else|:
literal|0x31
operator|)
operator|<<
name|HE_REGS_RHCONFIG_PTMR_PRE
operator|)
operator||
operator|(
literal|0
operator|<<
name|HE_REGS_RHCONFIG_OAM_GID
operator|)
argument_list|)
expr_stmt|;
block|}
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hatm_init_cm
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hatm_init_rx_buffer_pool
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|r0_startrow
argument_list|,
name|sc
operator|->
name|r0_numbuffs
argument_list|)
expr_stmt|;
name|hatm_init_rx_buffer_pool
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|,
name|sc
operator|->
name|r1_startrow
argument_list|,
name|sc
operator|->
name|r1_numbuffs
argument_list|)
expr_stmt|;
name|hatm_init_tx_buffer_pool
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tx_startrow
argument_list|,
name|sc
operator|->
name|tx_numbuffs
argument_list|)
expr_stmt|;
name|hatm_init_imed_queues
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * 5.1.6 Application tunable Parameters 	 */
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_MCC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_OEC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_DCC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_CEC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hatm_init_cs_block
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hatm_init_cs_block_cm
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hatm_init_rpool
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rbp_s0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hatm_init_rpool
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rbp_l0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hatm_init_rpool
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rbp_s1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hatm_clear_rpool
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hatm_clear_rpool
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hatm_clear_rpool
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hatm_clear_rpool
argument_list|(
name|sc
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hatm_clear_rpool
argument_list|(
name|sc
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hatm_clear_rpool
argument_list|(
name|sc
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hatm_clear_rpool
argument_list|(
name|sc
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hatm_clear_rpool
argument_list|(
name|sc
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hatm_clear_rpool
argument_list|(
name|sc
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hatm_clear_rpool
argument_list|(
name|sc
argument_list|,
literal|6
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hatm_clear_rpool
argument_list|(
name|sc
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hatm_clear_rpool
argument_list|(
name|sc
argument_list|,
literal|7
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hatm_clear_rpool
argument_list|(
name|sc
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hatm_init_rbrq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rbrq_0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hatm_init_rbrq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rbrq_1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hatm_clear_rbrq
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|hatm_clear_rbrq
argument_list|(
name|sc
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|hatm_clear_rbrq
argument_list|(
name|sc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|hatm_clear_rbrq
argument_list|(
name|sc
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|hatm_clear_rbrq
argument_list|(
name|sc
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|hatm_clear_rbrq
argument_list|(
name|sc
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lbufs_next
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|lbufs
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|lbufs
index|[
literal|0
index|]
argument_list|)
operator|*
name|sc
operator|->
name|lbufs_size
argument_list|)
expr_stmt|;
name|hatm_init_tbrq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|tbrq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hatm_clear_tbrq
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hatm_clear_tbrq
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|hatm_clear_tbrq
argument_list|(
name|sc
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|hatm_clear_tbrq
argument_list|(
name|sc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|hatm_clear_tbrq
argument_list|(
name|sc
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|hatm_clear_tbrq
argument_list|(
name|sc
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|hatm_clear_tbrq
argument_list|(
name|sc
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|hatm_init_tpdrq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_UBUFF_BA
argument_list|,
operator|(
name|sc
operator|->
name|he622
condition|?
literal|0x104780
else|:
literal|0x800
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize HSP 	 */
name|bzero
argument_list|(
name|sc
operator|->
name|hsp_mem
operator|.
name|base
argument_list|,
name|sc
operator|->
name|hsp_mem
operator|.
name|size
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hsp
operator|=
name|sc
operator|->
name|hsp_mem
operator|.
name|base
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_HSP_BA
argument_list|,
name|sc
operator|->
name|hsp_mem
operator|.
name|paddr
argument_list|)
expr_stmt|;
comment|/* 	 * 5.1.12 Enable transmit and receive 	 * Enable bus master and interrupts 	 */
name|v
operator|=
name|READ_MBOX4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_CS_ERCTL0
argument_list|)
expr_stmt|;
name|v
operator||=
literal|0x18000000
expr_stmt|;
name|WRITE_MBOX4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_CS_ERCTL0
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|READ4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RCCONFIG
argument_list|)
expr_stmt|;
name|v
operator||=
name|HE_REGM_RCCONFIG_RXENB
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RCCONFIG
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|HE_PCIR_GEN_CNTL_0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|v
operator||=
name|HE_PCIM_CTL0_INIT_ENB
operator||
name|HE_PCIM_CTL0_INT_PROC_ENB
expr_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|HE_PCIR_GEN_CNTL_0
argument_list|,
name|v
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_baudrate
operator|=
literal|53
operator|*
literal|8
operator|*
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|pcr
expr_stmt|;
name|sc
operator|->
name|utopia
operator|.
name|flags
operator|&=
operator|~
name|UTP_FL_POLL_CARRIER
expr_stmt|;
comment|/* reopen vccs */
for|for
control|(
name|cid
operator|=
literal|0
init|;
name|cid
operator|<
name|HE_MAX_VCCS
condition|;
name|cid
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|vccs
index|[
name|cid
index|]
operator|!=
name|NULL
condition|)
name|hatm_load_vc
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ATMEV_SEND_IFSTATE_CHANGED
argument_list|(
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
argument_list|,
name|sc
operator|->
name|utopia
operator|.
name|carrier
operator|==
name|UTP_CARR_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This functions stops the card and frees all resources allocated after  * the attach. Must have the global lock.  */
end_comment

begin_function
name|void
name|hatm_stop
parameter_list|(
name|struct
name|hatm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|v
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|p
decl_stmt|,
name|cid
decl_stmt|;
name|struct
name|mbuf_chunk_hdr
modifier|*
name|ch
decl_stmt|;
name|struct
name|mbuf_page
modifier|*
name|pg
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
return|return;
name|sc
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|ATMEV_SEND_IFSTATE_CHANGED
argument_list|(
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
argument_list|,
name|sc
operator|->
name|utopia
operator|.
name|carrier
operator|==
name|UTP_CARR_OK
argument_list|)
expr_stmt|;
name|sc
operator|->
name|utopia
operator|.
name|flags
operator||=
name|UTP_FL_POLL_CARRIER
expr_stmt|;
comment|/* 	 * Stop and reset the hardware so that everything remains 	 * stable. 	 */
name|v
operator|=
name|READ_MBOX4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_CS_ERCTL0
argument_list|)
expr_stmt|;
name|v
operator|&=
operator|~
literal|0x18000000
expr_stmt|;
name|WRITE_MBOX4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_CS_ERCTL0
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|v
operator|=
name|READ4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RCCONFIG
argument_list|)
expr_stmt|;
name|v
operator|&=
operator|~
name|HE_REGM_RCCONFIG_RXENB
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RCCONFIG
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_RHCONFIG
argument_list|,
operator|(
literal|0x2
operator|<<
name|HE_REGS_RHCONFIG_PTMR_PRE
operator|)
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|v
operator|=
name|READ4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_HOST_CNTL
argument_list|)
expr_stmt|;
name|BARRIER_R
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|v
operator|&=
operator|~
operator|(
name|HE_REGM_HOST_OUTFF_ENB
operator||
name|HE_REGM_HOST_CMDFF_ENB
operator|)
expr_stmt|;
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_HOST_CNTL
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|BARRIER_W
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Disable bust master and interrupts 	 */
name|v
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|HE_PCIR_GEN_CNTL_0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|v
operator|&=
operator|~
operator|(
name|HE_PCIM_CTL0_INIT_ENB
operator||
name|HE_PCIM_CTL0_INT_PROC_ENB
operator|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|HE_PCIR_GEN_CNTL_0
argument_list|,
name|v
argument_list|,
literal|4
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|hatm_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Card resets the SUNI when resetted, so re-initialize it 	 */
name|utopia_reset
argument_list|(
operator|&
name|sc
operator|->
name|utopia
argument_list|)
expr_stmt|;
comment|/* 	 * Give any waiters on closing a VCC a chance. They will stop 	 * to wait if they see that IFF_DRV_RUNNING disappeared. 	 */
name|cv_broadcast
argument_list|(
operator|&
name|sc
operator|->
name|vcc_cv
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|sc
operator|->
name|cv_rcclose
argument_list|)
expr_stmt|;
comment|/* 	 * Now free all resources. 	 */
comment|/* 	 * Free the large mbufs that are given to the card. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|lbufs_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|lbufs
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|mbuf_tag
argument_list|,
name|sc
operator|->
name|rmaps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|sc
operator|->
name|lbufs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lbufs
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* 	 * Free small buffers 	 */
for|for
control|(
name|p
operator|=
literal|0
init|;
name|p
operator|<
name|sc
operator|->
name|mbuf_npages
condition|;
name|p
operator|++
control|)
block|{
name|pg
operator|=
name|sc
operator|->
name|mbuf_pages
index|[
name|p
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pg
operator|->
name|hdr
operator|.
name|nchunks
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|=
operator|(
expr|struct
name|mbuf_chunk_hdr
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|pg
operator|+
name|i
operator|*
name|pg
operator|->
name|hdr
operator|.
name|chunksize
operator|+
name|pg
operator|->
name|hdr
operator|.
name|hdroff
operator|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|flags
operator|&
name|MBUF_CARD
condition|)
block|{
name|ch
operator|->
name|flags
operator|&=
operator|~
name|MBUF_CARD
expr_stmt|;
name|ch
operator|->
name|flags
operator||=
name|MBUF_USED
expr_stmt|;
name|hatm_ext_free
argument_list|(
operator|&
name|sc
operator|->
name|mbuf_list
index|[
name|pg
operator|->
name|hdr
operator|.
name|pool
index|]
argument_list|,
operator|(
expr|struct
name|mbufx_free
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
name|ch
operator|-
name|pg
operator|->
name|hdr
operator|.
name|hdroff
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|hatm_stop_tpds
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Free all partial reassembled PDUs on any VCC. 	 */
for|for
control|(
name|cid
operator|=
literal|0
init|;
name|cid
operator|<
name|HE_MAX_VCCS
condition|;
name|cid
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|vccs
index|[
name|cid
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|vccs
index|[
name|cid
index|]
operator|->
name|chain
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|sc
operator|->
name|vccs
index|[
name|cid
index|]
operator|->
name|chain
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vccs
index|[
name|cid
index|]
operator|->
name|chain
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|vccs
index|[
name|cid
index|]
operator|->
name|last
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|vccs
index|[
name|cid
index|]
operator|->
name|vflags
operator|&
operator|(
name|HE_VCC_RX_OPEN
operator||
name|HE_VCC_TX_OPEN
operator|)
operator|)
condition|)
block|{
name|hatm_tx_vcc_closed
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|sc
operator|->
name|vcc_zone
argument_list|,
name|sc
operator|->
name|vccs
index|[
name|cid
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vccs
index|[
name|cid
index|]
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|open_vccs
operator|--
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|vccs
index|[
name|cid
index|]
operator|->
name|vflags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|vccs
index|[
name|cid
index|]
operator|->
name|ntpds
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|rbp_s0
operator|.
name|size
operator|!=
literal|0
condition|)
name|bzero
argument_list|(
name|sc
operator|->
name|rbp_s0
operator|.
name|mem
operator|.
name|base
argument_list|,
name|sc
operator|->
name|rbp_s0
operator|.
name|mem
operator|.
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rbp_l0
operator|.
name|size
operator|!=
literal|0
condition|)
name|bzero
argument_list|(
name|sc
operator|->
name|rbp_l0
operator|.
name|mem
operator|.
name|base
argument_list|,
name|sc
operator|->
name|rbp_l0
operator|.
name|mem
operator|.
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rbp_s1
operator|.
name|size
operator|!=
literal|0
condition|)
name|bzero
argument_list|(
name|sc
operator|->
name|rbp_s1
operator|.
name|mem
operator|.
name|base
argument_list|,
name|sc
operator|->
name|rbp_s1
operator|.
name|mem
operator|.
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rbrq_0
operator|.
name|size
operator|!=
literal|0
condition|)
name|bzero
argument_list|(
name|sc
operator|->
name|rbrq_0
operator|.
name|mem
operator|.
name|base
argument_list|,
name|sc
operator|->
name|rbrq_0
operator|.
name|mem
operator|.
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rbrq_1
operator|.
name|size
operator|!=
literal|0
condition|)
name|bzero
argument_list|(
name|sc
operator|->
name|rbrq_1
operator|.
name|mem
operator|.
name|base
argument_list|,
name|sc
operator|->
name|rbrq_1
operator|.
name|mem
operator|.
name|size
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|tbrq
operator|.
name|mem
operator|.
name|base
argument_list|,
name|sc
operator|->
name|tbrq
operator|.
name|mem
operator|.
name|size
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|tpdrq
operator|.
name|mem
operator|.
name|base
argument_list|,
name|sc
operator|->
name|tpdrq
operator|.
name|mem
operator|.
name|size
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|hsp_mem
operator|.
name|base
argument_list|,
name|sc
operator|->
name|hsp_mem
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************  *  * Driver infrastructure  */
end_comment

begin_decl_stmt
name|devclass_t
name|hatm_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|hatm_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|hatm_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|hatm_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|hatm_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|hatm_driver
init|=
block|{
literal|"hatm"
block|,
name|hatm_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|hatm_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|hatm
argument_list|,
name|pci
argument_list|,
name|hatm_driver
argument_list|,
name|hatm_devclass
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

