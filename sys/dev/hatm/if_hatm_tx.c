begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001-2003  *	Fraunhofer Institute for Open Communication Systems (FhG Fokus).  * 	All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * Author: Hartmut Brandt<harti@freebsd.org>  *  * ForeHE driver.  *  * Transmission.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_natm.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_atm.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_BPF
end_ifdef

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_atm.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/utopia/utopia.h>
end_include

begin_include
include|#
directive|include
file|<dev/hatm/if_hatmconf.h>
end_include

begin_include
include|#
directive|include
file|<dev/hatm/if_hatmreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/hatm/if_hatmvar.h>
end_include

begin_comment
comment|/*  * These macros are used to trace the flow of transmit mbufs and to  * detect transmit mbuf leaks in the driver.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HATM_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|hatm_free_txmbuf
parameter_list|(
name|SC
parameter_list|)
define|\
value|do {								\ 		if (--sc->txmbuf< 0)					\ 			DBG(sc, TX, ("txmbuf below 0!"));		\ 		else if (sc->txmbuf == 0)				\ 			DBG(sc, TX, ("txmbuf now 0"));			\ 	} while (0)
end_define

begin_define
define|#
directive|define
name|hatm_get_txmbuf
parameter_list|(
name|SC
parameter_list|)
define|\
value|do {								\ 		if (++sc->txmbuf> 20000)				\ 			DBG(sc,	TX, ("txmbuf %u", sc->txmbuf));		\ 		else if (sc->txmbuf == 1)				\ 			DBG(sc, TX, ("txmbuf leaves 0"));		\ 	} while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|hatm_free_txmbuf
parameter_list|(
name|SC
parameter_list|)
value|do { } while (0)
end_define

begin_define
define|#
directive|define
name|hatm_get_txmbuf
parameter_list|(
name|SC
parameter_list|)
value|do { } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Allocate a new TPD, zero the TPD part. Cannot return NULL if  * flag is 0. The TPD is removed from the free list and its used  * bit is set.  */
end_comment

begin_function
specifier|static
name|struct
name|tpd
modifier|*
name|hatm_alloc_tpd
parameter_list|(
name|struct
name|hatm_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|tpd
modifier|*
name|t
decl_stmt|;
comment|/* if we allocate a transmit TPD check for the reserve */
if|if
condition|(
name|flags
operator|&
name|M_NOWAIT
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|tpd_nfree
operator|<=
name|HE_CONFIG_TPD_RESERVE
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|tpd_nfree
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* make it beeing used */
name|t
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|tpd_free
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|t
operator|!=
name|NULL
argument_list|,
operator|(
literal|"tpd botch"
operator|)
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|tpd_free
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|TPD_SET_USED
argument_list|(
name|sc
argument_list|,
name|t
operator|->
name|no
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tpd_nfree
operator|--
expr_stmt|;
comment|/* initialize */
name|t
operator|->
name|mbuf
operator|=
name|NULL
expr_stmt|;
name|t
operator|->
name|cid
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|t
operator|->
name|tpd
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|tpd
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|tpd
operator|.
name|addr
operator|=
name|t
operator|->
name|no
operator|<<
name|HE_REGS_TPD_ADDR
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free a TPD. If the mbuf pointer in that TPD is not zero, it is assumed, that  * the DMA map of this TPD was used to load this mbuf. The map is unloaded  * and the mbuf is freed. The TPD is put back onto the free list and  * its used bit is cleared.  */
end_comment

begin_function
specifier|static
name|void
name|hatm_free_tpd
parameter_list|(
name|struct
name|hatm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|tpd
modifier|*
name|tpd
parameter_list|)
block|{
if|if
condition|(
name|tpd
operator|->
name|mbuf
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|tx_tag
argument_list|,
name|tpd
operator|->
name|map
argument_list|)
expr_stmt|;
name|hatm_free_txmbuf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|tpd
operator|->
name|mbuf
argument_list|)
expr_stmt|;
name|tpd
operator|->
name|mbuf
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* insert TPD into free list */
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|tpd_free
argument_list|,
name|tpd
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|TPD_CLR_USED
argument_list|(
name|sc
argument_list|,
name|tpd
operator|->
name|no
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tpd_nfree
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Queue a number of TPD. If there is not enough space none of the TPDs  * is queued and an error code is returned.  */
end_comment

begin_function
specifier|static
name|int
name|hatm_queue_tpds
parameter_list|(
name|struct
name|hatm_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|count
parameter_list|,
name|struct
name|tpd
modifier|*
modifier|*
name|list
parameter_list|,
name|u_int
name|cid
parameter_list|)
block|{
name|u_int
name|space
decl_stmt|;
name|u_int
name|i
decl_stmt|;
if|if
condition|(
name|count
operator|>=
name|sc
operator|->
name|tpdrq
operator|.
name|size
condition|)
block|{
name|sc
operator|->
name|istats
operator|.
name|tdprq_full
operator|++
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|tpdrq
operator|.
name|tail
operator|<
name|sc
operator|->
name|tpdrq
operator|.
name|head
condition|)
name|space
operator|=
name|sc
operator|->
name|tpdrq
operator|.
name|head
operator|-
name|sc
operator|->
name|tpdrq
operator|.
name|tail
expr_stmt|;
else|else
name|space
operator|=
name|sc
operator|->
name|tpdrq
operator|.
name|head
operator|-
name|sc
operator|->
name|tpdrq
operator|.
name|tail
operator|+
name|sc
operator|->
name|tpdrq
operator|.
name|size
expr_stmt|;
if|if
condition|(
name|space
operator|<=
name|count
condition|)
block|{
name|sc
operator|->
name|tpdrq
operator|.
name|head
operator|=
operator|(
name|READ4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_TPDRQ_H
argument_list|)
operator|>>
name|HE_REGS_TPDRQ_H_H
operator|)
operator|&
operator|(
name|sc
operator|->
name|tpdrq
operator|.
name|size
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tpdrq
operator|.
name|tail
operator|<
name|sc
operator|->
name|tpdrq
operator|.
name|head
condition|)
name|space
operator|=
name|sc
operator|->
name|tpdrq
operator|.
name|head
operator|-
name|sc
operator|->
name|tpdrq
operator|.
name|tail
expr_stmt|;
else|else
name|space
operator|=
name|sc
operator|->
name|tpdrq
operator|.
name|head
operator|-
name|sc
operator|->
name|tpdrq
operator|.
name|tail
operator|+
name|sc
operator|->
name|tpdrq
operator|.
name|size
expr_stmt|;
if|if
condition|(
name|space
operator|<=
name|count
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"TPDRQ full\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|istats
operator|.
name|tdprq_full
operator|++
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
block|}
comment|/* we are going to write to the TPD queue space */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|tpdrq
operator|.
name|mem
operator|.
name|tag
argument_list|,
name|sc
operator|->
name|tpdrq
operator|.
name|mem
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* put the entries into the TPD space */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
comment|/* we are going to 'write' the TPD to the device */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|tpds
operator|.
name|tag
argument_list|,
name|sc
operator|->
name|tpds
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tpdrq
operator|.
name|tpdrq
index|[
name|sc
operator|->
name|tpdrq
operator|.
name|tail
index|]
operator|.
name|tpd
operator|=
name|sc
operator|->
name|tpds
operator|.
name|paddr
operator|+
name|HE_TPD_SIZE
operator|*
name|list
index|[
name|i
index|]
operator|->
name|no
expr_stmt|;
name|sc
operator|->
name|tpdrq
operator|.
name|tpdrq
index|[
name|sc
operator|->
name|tpdrq
operator|.
name|tail
index|]
operator|.
name|cid
operator|=
name|cid
expr_stmt|;
if|if
condition|(
operator|++
name|sc
operator|->
name|tpdrq
operator|.
name|tail
operator|==
name|sc
operator|->
name|tpdrq
operator|.
name|size
condition|)
name|sc
operator|->
name|tpdrq
operator|.
name|tail
operator|=
literal|0
expr_stmt|;
block|}
comment|/* update tail pointer */
name|WRITE4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_TPDRQ_T
argument_list|,
operator|(
name|sc
operator|->
name|tpdrq
operator|.
name|tail
operator|<<
name|HE_REGS_TPDRQ_T_T
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Helper struct for communication with the DMA load helper.  */
end_comment

begin_struct
struct|struct
name|load_txbuf_arg
block|{
name|struct
name|hatm_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|tpd
modifier|*
name|first
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mbuf
decl_stmt|;
name|struct
name|hevcc
modifier|*
name|vcc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_int
name|pti
decl_stmt|;
name|u_int
name|vpi
decl_stmt|,
name|vci
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Loader callback for the mbuf. This function allocates the TPDs and  * fills them. It puts the dmamap and and the mbuf pointer into the last  * TPD and then tries to queue all the TPDs. If anything fails, all TPDs  * allocated by this function are freed and the error flag is set in the  * argument structure. The first TPD must then be freed by the caller.  */
end_comment

begin_function
specifier|static
name|void
name|hatm_load_txbuf
parameter_list|(
name|void
modifier|*
name|uarg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|bus_size_t
name|mapsize
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|load_txbuf_arg
modifier|*
name|arg
init|=
name|uarg
decl_stmt|;
name|u_int
name|tpds_needed
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|,
name|tpd_cnt
decl_stmt|;
name|int
name|need_intr
decl_stmt|;
name|struct
name|tpd
modifier|*
name|tpd
decl_stmt|;
name|struct
name|tpd
modifier|*
name|tpd_list
index|[
name|HE_CONFIG_MAX_TPD_PER_PACKET
index|]
decl_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DBG
argument_list|(
name|arg
operator|->
name|sc
argument_list|,
name|DMA
argument_list|,
operator|(
literal|"%s -- error=%d plen=%d\n"
operator|,
name|__func__
operator|,
name|error
operator|,
name|arg
operator|->
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|len
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* ensure, we have enough TPDs (remember, we already have one) */
name|tpds_needed
operator|=
operator|(
name|nseg
operator|+
literal|2
operator|)
operator|/
literal|3
expr_stmt|;
if|if
condition|(
name|HE_CONFIG_TPD_RESERVE
operator|+
name|tpds_needed
operator|-
literal|1
operator|>
name|arg
operator|->
name|sc
operator|->
name|tpd_nfree
condition|)
block|{
name|if_printf
argument_list|(
name|arg
operator|->
name|sc
operator|->
name|ifp
argument_list|,
literal|"%s -- out of TPDs (need %d, "
literal|"have %u)\n"
argument_list|,
name|__func__
argument_list|,
name|tpds_needed
operator|-
literal|1
argument_list|,
name|arg
operator|->
name|sc
operator|->
name|tpd_nfree
operator|+
literal|1
argument_list|)
expr_stmt|;
name|arg
operator|->
name|error
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* 	 * Check for the maximum number of TPDs on the connection. 	 */
name|need_intr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|sc
operator|->
name|max_tpd
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|arg
operator|->
name|vcc
operator|->
name|ntpds
operator|+
name|tpds_needed
operator|>
name|arg
operator|->
name|sc
operator|->
name|max_tpd
condition|)
block|{
name|arg
operator|->
name|sc
operator|->
name|istats
operator|.
name|flow_closed
operator|++
expr_stmt|;
name|arg
operator|->
name|vcc
operator|->
name|vflags
operator||=
name|HE_VCC_FLOW_CTRL
expr_stmt|;
name|ATMEV_SEND_FLOW_CONTROL
argument_list|(
name|IFP2IFATM
argument_list|(
name|arg
operator|->
name|sc
operator|->
name|ifp
argument_list|)
argument_list|,
name|arg
operator|->
name|vpi
argument_list|,
name|arg
operator|->
name|vci
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|arg
operator|->
name|error
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|arg
operator|->
name|vcc
operator|->
name|ntpds
operator|+
name|tpds_needed
operator|>
operator|(
literal|9
operator|*
name|arg
operator|->
name|sc
operator|->
name|max_tpd
operator|)
operator|/
literal|10
condition|)
name|need_intr
operator|=
literal|1
expr_stmt|;
block|}
name|tpd
operator|=
name|arg
operator|->
name|first
expr_stmt|;
name|tpd_cnt
operator|=
literal|0
expr_stmt|;
name|tpd_list
index|[
name|tpd_cnt
operator|++
index|]
operator|=
name|tpd
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n
operator|=
literal|0
init|;
name|i
operator|<
name|nseg
condition|;
name|i
operator|++
operator|,
name|n
operator|++
control|)
block|{
if|if
condition|(
name|n
operator|==
literal|3
condition|)
block|{
if|if
condition|(
operator|(
name|tpd
operator|=
name|hatm_alloc_tpd
argument_list|(
name|arg
operator|->
name|sc
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
comment|/* may not fail (see check above) */
name|panic
argument_list|(
literal|"%s: out of TPDs"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|tpd
operator|->
name|cid
operator|=
name|arg
operator|->
name|first
operator|->
name|cid
expr_stmt|;
name|tpd
operator|->
name|tpd
operator|.
name|addr
operator||=
name|arg
operator|->
name|pti
expr_stmt|;
name|tpd_list
index|[
name|tpd_cnt
operator|++
index|]
operator|=
name|tpd
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
operator|<=
literal|0xffffffffLU
argument_list|,
operator|(
literal|"phys addr too large %lx"
operator|,
operator|(
name|u_long
operator|)
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
operator|)
argument_list|)
expr_stmt|;
name|DBG
argument_list|(
name|arg
operator|->
name|sc
argument_list|,
name|DMA
argument_list|,
operator|(
literal|"DMA loaded: %lx/%lu"
operator|,
operator|(
name|u_long
operator|)
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
operator|,
operator|(
name|u_long
operator|)
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
operator|)
argument_list|)
expr_stmt|;
name|tpd
operator|->
name|tpd
operator|.
name|bufs
index|[
name|n
index|]
operator|.
name|addr
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
expr_stmt|;
name|tpd
operator|->
name|tpd
operator|.
name|bufs
index|[
name|n
index|]
operator|.
name|len
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
expr_stmt|;
name|DBG
argument_list|(
name|arg
operator|->
name|sc
argument_list|,
name|TX
argument_list|,
operator|(
literal|"seg[%u]=tpd[%u,%u]=%x/%u"
operator|,
name|i
operator|,
name|tpd_cnt
operator|,
name|n
operator|,
name|tpd
operator|->
name|tpd
operator|.
name|bufs
index|[
name|n
index|]
operator|.
name|addr
operator|,
name|tpd
operator|->
name|tpd
operator|.
name|bufs
index|[
name|n
index|]
operator|.
name|len
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|nseg
operator|-
literal|1
condition|)
name|tpd
operator|->
name|tpd
operator|.
name|bufs
index|[
name|n
index|]
operator|.
name|len
operator||=
name|HE_REGM_TPD_LST
expr_stmt|;
block|}
comment|/* 	 * Swap the MAP in the first and the last TPD and set the mbuf 	 * pointer into the last TPD. We use the map in the last TPD, because 	 * the map must stay valid until the last TPD is processed by the card. 	 */
if|if
condition|(
name|tpd_cnt
operator|>
literal|1
condition|)
block|{
name|bus_dmamap_t
name|tmp
decl_stmt|;
name|tmp
operator|=
name|arg
operator|->
name|first
operator|->
name|map
expr_stmt|;
name|arg
operator|->
name|first
operator|->
name|map
operator|=
name|tpd_list
index|[
name|tpd_cnt
operator|-
literal|1
index|]
operator|->
name|map
expr_stmt|;
name|tpd_list
index|[
name|tpd_cnt
operator|-
literal|1
index|]
operator|->
name|map
operator|=
name|tmp
expr_stmt|;
block|}
name|tpd_list
index|[
name|tpd_cnt
operator|-
literal|1
index|]
operator|->
name|mbuf
operator|=
name|arg
operator|->
name|mbuf
expr_stmt|;
if|if
condition|(
name|need_intr
condition|)
name|tpd_list
index|[
name|tpd_cnt
operator|-
literal|1
index|]
operator|->
name|tpd
operator|.
name|addr
operator||=
name|HE_REGM_TPD_INTR
expr_stmt|;
comment|/* queue the TPDs */
if|if
condition|(
name|hatm_queue_tpds
argument_list|(
name|arg
operator|->
name|sc
argument_list|,
name|tpd_cnt
argument_list|,
name|tpd_list
argument_list|,
name|arg
operator|->
name|first
operator|->
name|cid
argument_list|)
condition|)
block|{
comment|/* free all, except the first TPD */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|tpd_cnt
condition|;
name|i
operator|++
control|)
name|hatm_free_tpd
argument_list|(
name|arg
operator|->
name|sc
argument_list|,
name|tpd_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|arg
operator|->
name|error
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|arg
operator|->
name|vcc
operator|->
name|ntpds
operator|+=
name|tpd_cnt
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start output on the interface  */
end_comment

begin_function
name|void
name|hatm_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|hatm_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|hatm_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|atm_pseudohdr
modifier|*
name|aph
decl_stmt|;
name|u_int
name|cid
decl_stmt|;
name|struct
name|tpd
modifier|*
name|tpd
decl_stmt|;
name|struct
name|load_txbuf_arg
name|arg
decl_stmt|;
name|u_int
name|len
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
return|return;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|arg
operator|.
name|sc
operator|=
name|sc
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|hatm_get_txmbuf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|aph
argument_list|)
condition|)
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|aph
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|hatm_free_txmbuf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|aph
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|atm_pseudohdr
operator|*
argument_list|)
expr_stmt|;
name|arg
operator|.
name|vci
operator|=
name|ATM_PH_VCI
argument_list|(
name|aph
argument_list|)
expr_stmt|;
name|arg
operator|.
name|vpi
operator|=
name|ATM_PH_VPI
argument_list|(
name|aph
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|aph
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|)
operator|==
literal|0
condition|)
block|{
name|hatm_free_txmbuf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|arg
operator|.
name|vpi
operator|&
operator|~
name|HE_VPI_MASK
operator|)
operator|||
operator|(
name|arg
operator|.
name|vci
operator|&
operator|~
name|HE_VCI_MASK
operator|)
operator|||
operator|(
name|arg
operator|.
name|vci
operator|==
literal|0
operator|)
condition|)
block|{
name|hatm_free_txmbuf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|cid
operator|=
name|HE_CID
argument_list|(
name|arg
operator|.
name|vpi
argument_list|,
name|arg
operator|.
name|vci
argument_list|)
expr_stmt|;
name|arg
operator|.
name|vcc
operator|=
name|sc
operator|->
name|vccs
index|[
name|cid
index|]
expr_stmt|;
if|if
condition|(
name|arg
operator|.
name|vcc
operator|==
name|NULL
operator|||
operator|!
operator|(
name|arg
operator|.
name|vcc
operator|->
name|vflags
operator|&
name|HE_VCC_OPEN
operator|)
condition|)
block|{
name|hatm_free_txmbuf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|arg
operator|.
name|vcc
operator|->
name|vflags
operator|&
name|HE_VCC_FLOW_CTRL
condition|)
block|{
name|hatm_free_txmbuf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|istats
operator|.
name|flow_drop
operator|++
expr_stmt|;
continue|continue;
block|}
name|arg
operator|.
name|pti
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|arg
operator|.
name|vcc
operator|->
name|param
operator|.
name|aal
operator|==
name|ATMIO_AAL_RAW
condition|)
block|{
if|if
condition|(
name|len
operator|<
literal|52
condition|)
block|{
comment|/* too short */
name|hatm_free_txmbuf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * Get the header and ignore except 			 * payload type and CLP. 			 */
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
literal|4
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
literal|4
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|hatm_free_txmbuf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|arg
operator|.
name|pti
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
index|[
literal|3
index|]
operator|&
literal|0xf
expr_stmt|;
name|arg
operator|.
name|pti
operator|=
operator|(
operator|(
name|arg
operator|.
name|pti
operator|&
literal|0xe
operator|)
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|arg
operator|.
name|pti
operator|&
literal|1
operator|)
operator|<<
literal|1
operator|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|len
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
name|len
operator|%
literal|48
operator|!=
literal|0
condition|)
block|{
name|m_adj
argument_list|(
name|m
argument_list|,
operator|-
operator|(
call|(
name|int
call|)
argument_list|(
name|len
operator|%
literal|48
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|len
operator|-=
name|len
operator|%
literal|48
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|ENABLE_BPF
if|if
condition|(
operator|!
operator|(
name|arg
operator|.
name|vcc
operator|->
name|param
operator|.
name|flags
operator|&
name|ATMIO_FLAG_NG
operator|)
operator|&&
operator|(
name|arg
operator|.
name|vcc
operator|->
name|param
operator|.
name|aal
operator|==
name|ATMIO_AAL_5
operator|)
operator|&&
operator|(
name|arg
operator|.
name|vcc
operator|->
name|param
operator|.
name|flags
operator|&
name|ATM_PH_LLCSNAP
operator|)
condition|)
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Now load a DMA map with the packet. Allocate the first 		 * TPD to get a map. Additional TPDs may be allocated by the 		 * callback. */
if|if
condition|(
operator|(
name|tpd
operator|=
name|hatm_alloc_tpd
argument_list|(
name|sc
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|hatm_free_txmbuf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
continue|continue;
block|}
name|tpd
operator|->
name|cid
operator|=
name|cid
expr_stmt|;
name|tpd
operator|->
name|tpd
operator|.
name|addr
operator||=
name|arg
operator|.
name|pti
expr_stmt|;
name|arg
operator|.
name|first
operator|=
name|tpd
expr_stmt|;
name|arg
operator|.
name|error
operator|=
literal|0
expr_stmt|;
name|arg
operator|.
name|mbuf
operator|=
name|m
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf
argument_list|(
name|sc
operator|->
name|tx_tag
argument_list|,
name|tpd
operator|->
name|map
argument_list|,
name|m
argument_list|,
name|hatm_load_txbuf
argument_list|,
operator|&
name|arg
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EFBIG
condition|)
block|{
comment|/* try to defragment the packet */
name|sc
operator|->
name|istats
operator|.
name|defrag
operator|++
expr_stmt|;
name|m
operator|=
name|m_defrag
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|tpd
operator|->
name|mbuf
operator|=
name|NULL
expr_stmt|;
name|hatm_free_txmbuf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hatm_free_tpd
argument_list|(
name|sc
argument_list|,
name|tpd
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
continue|continue;
block|}
name|arg
operator|.
name|mbuf
operator|=
name|m
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf
argument_list|(
name|sc
operator|->
name|tx_tag
argument_list|,
name|tpd
operator|->
name|map
argument_list|,
name|m
argument_list|,
name|hatm_load_txbuf
argument_list|,
operator|&
name|arg
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"mbuf loaded error=%d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|hatm_free_tpd
argument_list|(
name|sc
argument_list|,
name|tpd
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|arg
operator|.
name|error
condition|)
block|{
name|hatm_free_tpd
argument_list|(
name|sc
argument_list|,
name|tpd
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
continue|continue;
block|}
name|arg
operator|.
name|vcc
operator|->
name|opackets
operator|++
expr_stmt|;
name|arg
operator|.
name|vcc
operator|->
name|obytes
operator|+=
name|len
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|hatm_tx_complete
parameter_list|(
name|struct
name|hatm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|tpd
modifier|*
name|tpd
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|struct
name|hevcc
modifier|*
name|vcc
init|=
name|sc
operator|->
name|vccs
index|[
name|tpd
operator|->
name|cid
index|]
decl_stmt|;
name|DBG
argument_list|(
name|sc
argument_list|,
name|TX
argument_list|,
operator|(
literal|"tx_complete cid=%#x flags=%#x"
operator|,
name|tpd
operator|->
name|cid
operator|,
name|flags
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vcc
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|(
name|flags
operator|&
name|HE_REGM_TBRQ_EOS
operator|)
operator|&&
operator|(
name|vcc
operator|->
name|vflags
operator|&
name|HE_VCC_TX_CLOSING
operator|)
condition|)
block|{
name|vcc
operator|->
name|vflags
operator|&=
operator|~
name|HE_VCC_TX_CLOSING
expr_stmt|;
if|if
condition|(
name|vcc
operator|->
name|param
operator|.
name|flags
operator|&
name|ATMIO_FLAG_ASYNC
condition|)
block|{
name|hatm_tx_vcc_closed
argument_list|(
name|sc
argument_list|,
name|tpd
operator|->
name|cid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|vcc
operator|->
name|vflags
operator|&
name|HE_VCC_OPEN
operator|)
condition|)
block|{
name|hatm_vcc_closed
argument_list|(
name|sc
argument_list|,
name|tpd
operator|->
name|cid
argument_list|)
expr_stmt|;
name|vcc
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
name|cv_signal
argument_list|(
operator|&
name|sc
operator|->
name|vcc_cv
argument_list|)
expr_stmt|;
block|}
name|hatm_free_tpd
argument_list|(
name|sc
argument_list|,
name|tpd
argument_list|)
expr_stmt|;
if|if
condition|(
name|vcc
operator|==
name|NULL
condition|)
return|return;
name|vcc
operator|->
name|ntpds
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|vcc
operator|->
name|vflags
operator|&
name|HE_VCC_FLOW_CTRL
operator|)
operator|&&
name|vcc
operator|->
name|ntpds
operator|<=
name|HE_CONFIG_TPD_FLOW_ENB
condition|)
block|{
name|vcc
operator|->
name|vflags
operator|&=
operator|~
name|HE_VCC_FLOW_CTRL
expr_stmt|;
name|ATMEV_SEND_FLOW_CONTROL
argument_list|(
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
argument_list|,
name|HE_VPI
argument_list|(
name|tpd
operator|->
name|cid
argument_list|)
argument_list|,
name|HE_VCI
argument_list|(
name|tpd
operator|->
name|cid
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Convert CPS to Rate for a rate group  */
end_comment

begin_function
specifier|static
name|u_int
name|cps_to_rate
parameter_list|(
name|struct
name|hatm_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|cps
parameter_list|)
block|{
name|u_int
name|clk
init|=
name|sc
operator|->
name|he622
condition|?
name|HE_622_CLOCK
else|:
name|HE_155_CLOCK
decl_stmt|;
name|u_int
name|period
decl_stmt|,
name|rate
decl_stmt|;
comment|/* how many double ticks between two cells */
name|period
operator|=
operator|(
name|clk
operator|+
literal|2
operator|*
name|cps
operator|-
literal|1
operator|)
operator|/
operator|(
literal|2
operator|*
name|cps
operator|)
expr_stmt|;
name|rate
operator|=
name|hatm_cps2atmf
argument_list|(
name|period
argument_list|)
expr_stmt|;
if|if
condition|(
name|hatm_atmf2cps
argument_list|(
name|rate
argument_list|)
operator|<
name|period
condition|)
name|rate
operator|++
expr_stmt|;
return|return
operator|(
name|rate
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check whether the VCC is really closed on the hardware and available for  * open. Check that we have enough resources. If this function returns ok,  * a later actual open must succeed. Assume, that we are locked between this  * function and the next one, so that nothing does change. For CBR this  * assigns the rate group and set the rate group's parameter.  */
end_comment

begin_function
name|int
name|hatm_tx_vcc_can_open
parameter_list|(
name|struct
name|hatm_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|cid
parameter_list|,
name|struct
name|hevcc
modifier|*
name|vcc
parameter_list|)
block|{
name|uint32_t
name|v
decl_stmt|,
name|line_rate
decl_stmt|;
name|u_int
name|rc
decl_stmt|,
name|idx
decl_stmt|,
name|free_idx
decl_stmt|;
name|struct
name|atmio_tparam
modifier|*
name|t
init|=
operator|&
name|vcc
operator|->
name|param
operator|.
name|tparam
decl_stmt|;
comment|/* verify that connection is closed */
if|#
directive|if
literal|0
block|v = READ_TSR(sc, cid, 4); 	if(!(v& HE_REGM_TSR4_SESS_END)) { 		if_printf(sc->ifp, "cid=%#x not closed (TSR4)\n", cid); 		return (EBUSY); 	}
endif|#
directive|endif
name|v
operator|=
name|READ_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|&
name|HE_REGM_TSR0_CONN_STATE
operator|)
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
literal|"cid=%#x not closed (TSR0=%#x)\n"
argument_list|,
name|cid
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
comment|/* check traffic parameters */
name|line_rate
operator|=
name|sc
operator|->
name|he622
condition|?
name|ATM_RATE_622M
else|:
name|ATM_RATE_155M
expr_stmt|;
switch|switch
condition|(
name|vcc
operator|->
name|param
operator|.
name|traffic
condition|)
block|{
case|case
name|ATMIO_TRAFFIC_UBR
case|:
if|if
condition|(
name|t
operator|->
name|pcr
operator|==
literal|0
operator|||
name|t
operator|->
name|pcr
operator|>
name|line_rate
condition|)
name|t
operator|->
name|pcr
operator|=
name|line_rate
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|mcr
operator|!=
literal|0
operator|||
name|t
operator|->
name|icr
operator|!=
literal|0
operator|||
name|t
operator|->
name|tbe
operator|!=
literal|0
operator|||
name|t
operator|->
name|nrm
operator|!=
literal|0
operator|||
name|t
operator|->
name|trm
operator|!=
literal|0
operator|||
name|t
operator|->
name|adtf
operator|!=
literal|0
operator|||
name|t
operator|->
name|rif
operator|!=
literal|0
operator|||
name|t
operator|->
name|rdf
operator|!=
literal|0
operator|||
name|t
operator|->
name|cdf
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
case|case
name|ATMIO_TRAFFIC_CBR
case|:
comment|/* 		 * Compute rate group index 		 */
if|if
condition|(
name|t
operator|->
name|pcr
operator|<
literal|10
condition|)
name|t
operator|->
name|pcr
operator|=
literal|10
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cbr_bw
operator|+
name|t
operator|->
name|pcr
operator|>
name|line_rate
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|t
operator|->
name|mcr
operator|!=
literal|0
operator|||
name|t
operator|->
name|icr
operator|!=
literal|0
operator|||
name|t
operator|->
name|tbe
operator|!=
literal|0
operator|||
name|t
operator|->
name|nrm
operator|!=
literal|0
operator|||
name|t
operator|->
name|trm
operator|!=
literal|0
operator|||
name|t
operator|->
name|adtf
operator|!=
literal|0
operator|||
name|t
operator|->
name|rif
operator|!=
literal|0
operator|||
name|t
operator|->
name|rdf
operator|!=
literal|0
operator|||
name|t
operator|->
name|cdf
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|rc
operator|=
name|cps_to_rate
argument_list|(
name|sc
argument_list|,
name|t
operator|->
name|pcr
argument_list|)
expr_stmt|;
name|free_idx
operator|=
name|HE_REGN_CS_STPER
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|HE_REGN_CS_STPER
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|rate_ctrl
index|[
name|idx
index|]
operator|.
name|refcnt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|free_idx
operator|==
name|HE_REGN_CS_STPER
condition|)
name|free_idx
operator|=
name|idx
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|rate_ctrl
index|[
name|idx
index|]
operator|.
name|rate
operator|==
name|rc
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|idx
operator|==
name|HE_REGN_CS_STPER
condition|)
block|{
if|if
condition|(
operator|(
name|idx
operator|=
name|free_idx
operator|)
operator|==
name|HE_REGN_CS_STPER
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|sc
operator|->
name|rate_ctrl
index|[
name|idx
index|]
operator|.
name|rate
operator|=
name|rc
expr_stmt|;
block|}
name|vcc
operator|->
name|rc
operator|=
name|idx
expr_stmt|;
comment|/* commit */
name|sc
operator|->
name|rate_ctrl
index|[
name|idx
index|]
operator|.
name|refcnt
operator|++
expr_stmt|;
name|sc
operator|->
name|cbr_bw
operator|+=
name|t
operator|->
name|pcr
expr_stmt|;
break|break;
case|case
name|ATMIO_TRAFFIC_ABR
case|:
if|if
condition|(
name|t
operator|->
name|pcr
operator|>
name|line_rate
condition|)
name|t
operator|->
name|pcr
operator|=
name|line_rate
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|mcr
operator|>
name|line_rate
condition|)
name|t
operator|->
name|mcr
operator|=
name|line_rate
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|icr
operator|>
name|line_rate
condition|)
name|t
operator|->
name|icr
operator|=
name|line_rate
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|tbe
operator|==
literal|0
operator|||
name|t
operator|->
name|tbe
operator|>=
literal|1
operator|<<
literal|24
operator|||
name|t
operator|->
name|nrm
operator|>
literal|7
operator|||
name|t
operator|->
name|trm
operator|>
literal|7
operator|||
name|t
operator|->
name|adtf
operator|>=
literal|1
operator|<<
literal|10
operator|||
name|t
operator|->
name|rif
operator|>
literal|15
operator|||
name|t
operator|->
name|rdf
operator|>
literal|15
operator|||
name|t
operator|->
name|cdf
operator|>
literal|7
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|NRM_CODE2VAL
parameter_list|(
name|CODE
parameter_list|)
value|(2 * (1<< (CODE)))
end_define

begin_comment
comment|/*  * Actually open the transmit VCC  */
end_comment

begin_function
name|void
name|hatm_tx_vcc_open
parameter_list|(
name|struct
name|hatm_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|cid
parameter_list|)
block|{
name|struct
name|hevcc
modifier|*
name|vcc
init|=
name|sc
operator|->
name|vccs
index|[
name|cid
index|]
decl_stmt|;
name|uint32_t
name|tsr0
decl_stmt|,
name|tsr4
decl_stmt|,
name|atmf
decl_stmt|,
name|crm
decl_stmt|;
specifier|const
name|struct
name|atmio_tparam
modifier|*
name|t
init|=
operator|&
name|vcc
operator|->
name|param
operator|.
name|tparam
decl_stmt|;
if|if
condition|(
name|vcc
operator|->
name|param
operator|.
name|aal
operator|==
name|ATMIO_AAL_5
condition|)
block|{
name|tsr0
operator|=
name|HE_REGM_TSR0_AAL_5
operator|<<
name|HE_REGS_TSR0_AAL
expr_stmt|;
name|tsr4
operator|=
name|HE_REGM_TSR4_AAL_5
operator|<<
name|HE_REGS_TSR4_AAL
expr_stmt|;
block|}
else|else
block|{
name|tsr0
operator|=
name|HE_REGM_TSR0_AAL_0
operator|<<
name|HE_REGS_TSR0_AAL
expr_stmt|;
name|tsr4
operator|=
name|HE_REGM_TSR4_AAL_0
operator|<<
name|HE_REGS_TSR4_AAL
expr_stmt|;
block|}
name|tsr4
operator||=
literal|1
expr_stmt|;
switch|switch
condition|(
name|vcc
operator|->
name|param
operator|.
name|traffic
condition|)
block|{
case|case
name|ATMIO_TRAFFIC_UBR
case|:
name|atmf
operator|=
name|hatm_cps2atmf
argument_list|(
name|t
operator|->
name|pcr
argument_list|)
expr_stmt|;
name|tsr0
operator||=
name|HE_REGM_TSR0_TRAFFIC_UBR
operator|<<
name|HE_REGS_TSR0_TRAFFIC
expr_stmt|;
name|tsr0
operator||=
name|HE_REGM_TSR0_USE_WMIN
operator||
name|HE_REGM_TSR0_UPDATE_GER
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|0
argument_list|,
literal|0xf
argument_list|,
name|tsr0
argument_list|)
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|4
argument_list|,
literal|0xf
argument_list|,
name|tsr4
argument_list|)
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|1
argument_list|,
literal|0xf
argument_list|,
operator|(
name|atmf
operator|<<
name|HE_REGS_TSR1_PCR
operator|)
argument_list|)
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|2
argument_list|,
literal|0xf
argument_list|,
operator|(
name|atmf
operator|<<
name|HE_REGS_TSR2_ACR
operator|)
argument_list|)
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|9
argument_list|,
literal|0xf
argument_list|,
name|HE_REGM_TSR9_INIT
argument_list|)
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|3
argument_list|,
literal|0xf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|5
argument_list|,
literal|0xf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|6
argument_list|,
literal|0xf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|7
argument_list|,
literal|0xf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|8
argument_list|,
literal|0xf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|10
argument_list|,
literal|0xf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|11
argument_list|,
literal|0xf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|12
argument_list|,
literal|0xf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|13
argument_list|,
literal|0xf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|14
argument_list|,
literal|0xf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATMIO_TRAFFIC_CBR
case|:
name|atmf
operator|=
name|hatm_cps2atmf
argument_list|(
name|t
operator|->
name|pcr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rate_ctrl
index|[
name|vcc
operator|->
name|rc
index|]
operator|.
name|refcnt
operator|==
literal|1
condition|)
name|WRITE_MBOX4
argument_list|(
name|sc
argument_list|,
name|HE_REGO_CS_STPER
argument_list|(
name|vcc
operator|->
name|rc
argument_list|)
argument_list|,
name|sc
operator|->
name|rate_ctrl
index|[
name|vcc
operator|->
name|rc
index|]
operator|.
name|rate
argument_list|)
expr_stmt|;
name|tsr0
operator||=
name|HE_REGM_TSR0_TRAFFIC_CBR
operator|<<
name|HE_REGS_TSR0_TRAFFIC
expr_stmt|;
name|tsr0
operator||=
name|vcc
operator|->
name|rc
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|1
argument_list|,
literal|0xf
argument_list|,
operator|(
name|atmf
operator|<<
name|HE_REGS_TSR1_PCR
operator|)
argument_list|)
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|2
argument_list|,
literal|0xf
argument_list|,
operator|(
name|atmf
operator|<<
name|HE_REGS_TSR2_ACR
operator|)
argument_list|)
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|3
argument_list|,
literal|0xf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|5
argument_list|,
literal|0xf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|6
argument_list|,
literal|0xf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|7
argument_list|,
literal|0xf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|8
argument_list|,
literal|0xf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|10
argument_list|,
literal|0xf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|11
argument_list|,
literal|0xf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|12
argument_list|,
literal|0xf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|13
argument_list|,
literal|0xf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|14
argument_list|,
literal|0xf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|4
argument_list|,
literal|0xf
argument_list|,
name|tsr4
argument_list|)
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|9
argument_list|,
literal|0xf
argument_list|,
name|HE_REGM_TSR9_INIT
argument_list|)
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|0
argument_list|,
literal|0xf
argument_list|,
name|tsr0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATMIO_TRAFFIC_ABR
case|:
if|if
condition|(
operator|(
name|crm
operator|=
name|t
operator|->
name|tbe
operator|/
name|NRM_CODE2VAL
argument_list|(
name|t
operator|->
name|nrm
argument_list|)
operator|)
operator|>
literal|0xffff
condition|)
name|crm
operator|=
literal|0xffff
expr_stmt|;
name|tsr0
operator||=
name|HE_REGM_TSR0_TRAFFIC_ABR
operator|<<
name|HE_REGS_TSR0_TRAFFIC
expr_stmt|;
name|tsr0
operator||=
name|HE_REGM_TSR0_USE_WMIN
operator||
name|HE_REGM_TSR0_UPDATE_GER
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|0
argument_list|,
literal|0xf
argument_list|,
name|tsr0
argument_list|)
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|4
argument_list|,
literal|0xf
argument_list|,
name|tsr4
argument_list|)
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|1
argument_list|,
literal|0xf
argument_list|,
operator|(
operator|(
name|hatm_cps2atmf
argument_list|(
name|t
operator|->
name|pcr
argument_list|)
operator|<<
name|HE_REGS_TSR1_PCR
operator|)
operator||
operator|(
name|hatm_cps2atmf
argument_list|(
name|t
operator|->
name|mcr
argument_list|)
operator|<<
name|HE_REGS_TSR1_MCR
operator|)
operator|)
argument_list|)
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|2
argument_list|,
literal|0xf
argument_list|,
operator|(
name|hatm_cps2atmf
argument_list|(
name|t
operator|->
name|icr
argument_list|)
operator|<<
name|HE_REGS_TSR2_ACR
operator|)
argument_list|)
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|3
argument_list|,
literal|0xf
argument_list|,
operator|(
operator|(
name|NRM_CODE2VAL
argument_list|(
name|t
operator|->
name|nrm
argument_list|)
operator|-
literal|1
operator|)
operator|<<
name|HE_REGS_TSR3_NRM
operator|)
operator||
operator|(
name|crm
operator|<<
name|HE_REGS_TSR3_CRM
operator|)
argument_list|)
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|5
argument_list|,
literal|0xf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|6
argument_list|,
literal|0xf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|7
argument_list|,
literal|0xf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|8
argument_list|,
literal|0xf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|10
argument_list|,
literal|0xf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|12
argument_list|,
literal|0xf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|14
argument_list|,
literal|0xf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|9
argument_list|,
literal|0xf
argument_list|,
name|HE_REGM_TSR9_INIT
argument_list|)
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|11
argument_list|,
literal|0xf
argument_list|,
operator|(
name|hatm_cps2atmf
argument_list|(
name|t
operator|->
name|icr
argument_list|)
operator|<<
name|HE_REGS_TSR11_ICR
operator|)
operator||
operator|(
name|t
operator|->
name|trm
operator|<<
name|HE_REGS_TSR11_TRM
operator|)
operator||
operator|(
name|t
operator|->
name|nrm
operator|<<
name|HE_REGS_TSR11_NRM
operator|)
operator||
operator|(
name|t
operator|->
name|adtf
operator|<<
name|HE_REGS_TSR11_ADTF
operator|)
argument_list|)
expr_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|13
argument_list|,
literal|0xf
argument_list|,
operator|(
name|t
operator|->
name|rdf
operator|<<
name|HE_REGS_TSR13_RDF
operator|)
operator||
operator|(
name|t
operator|->
name|rif
operator|<<
name|HE_REGS_TSR13_RIF
operator|)
operator||
operator|(
name|t
operator|->
name|cdf
operator|<<
name|HE_REGS_TSR13_CDF
operator|)
operator||
operator|(
name|crm
operator|<<
name|HE_REGS_TSR13_CRM
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return;
block|}
name|vcc
operator|->
name|vflags
operator||=
name|HE_VCC_TX_OPEN
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Close the TX side of a VCC. Set the CLOSING flag.  */
end_comment

begin_function
name|void
name|hatm_tx_vcc_close
parameter_list|(
name|struct
name|hatm_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|cid
parameter_list|)
block|{
name|struct
name|hevcc
modifier|*
name|vcc
init|=
name|sc
operator|->
name|vccs
index|[
name|cid
index|]
decl_stmt|;
name|struct
name|tpd
modifier|*
name|tpd_list
index|[
literal|1
index|]
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|pcr
init|=
literal|0
decl_stmt|;
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|4
argument_list|,
literal|0x8
argument_list|,
name|HE_REGM_TSR4_FLUSH
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|vcc
operator|->
name|param
operator|.
name|traffic
condition|)
block|{
case|case
name|ATMIO_TRAFFIC_CBR
case|:
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|14
argument_list|,
literal|0x8
argument_list|,
name|HE_REGM_TSR14_CBR_DELETE
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATMIO_TRAFFIC_ABR
case|:
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|14
argument_list|,
literal|0x4
argument_list|,
name|HE_REGM_TSR14_ABR_CLOSE
argument_list|)
expr_stmt|;
name|pcr
operator|=
name|vcc
operator|->
name|param
operator|.
name|tparam
operator|.
name|pcr
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|ATMIO_TRAFFIC_UBR
case|:
name|WRITE_TSR
argument_list|(
name|sc
argument_list|,
name|cid
argument_list|,
literal|1
argument_list|,
literal|0xf
argument_list|,
name|hatm_cps2atmf
argument_list|(
name|HE_CONFIG_FLUSH_RATE
argument_list|)
operator|<<
name|HE_REGS_TSR1_MCR
operator||
name|hatm_cps2atmf
argument_list|(
name|pcr
argument_list|)
operator|<<
name|HE_REGS_TSR1_PCR
argument_list|)
expr_stmt|;
break|break;
block|}
name|tpd_list
index|[
literal|0
index|]
operator|=
name|hatm_alloc_tpd
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tpd_list
index|[
literal|0
index|]
operator|->
name|tpd
operator|.
name|addr
operator||=
name|HE_REGM_TPD_EOS
operator||
name|HE_REGM_TPD_INTR
expr_stmt|;
name|tpd_list
index|[
literal|0
index|]
operator|->
name|cid
operator|=
name|cid
expr_stmt|;
name|vcc
operator|->
name|vflags
operator||=
name|HE_VCC_TX_CLOSING
expr_stmt|;
name|vcc
operator|->
name|vflags
operator|&=
operator|~
name|HE_VCC_TX_OPEN
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|hatm_queue_tpds
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|,
name|tpd_list
argument_list|,
name|cid
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|++
name|i
operator|==
literal|1000
condition|)
name|panic
argument_list|(
literal|"TPDRQ permanently full"
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|hatm_tx_vcc_closed
parameter_list|(
name|struct
name|hatm_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|cid
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|vccs
index|[
name|cid
index|]
operator|->
name|param
operator|.
name|traffic
operator|==
name|ATMIO_TRAFFIC_CBR
condition|)
block|{
name|sc
operator|->
name|cbr_bw
operator|-=
name|sc
operator|->
name|vccs
index|[
name|cid
index|]
operator|->
name|param
operator|.
name|tparam
operator|.
name|pcr
expr_stmt|;
name|sc
operator|->
name|rate_ctrl
index|[
name|sc
operator|->
name|vccs
index|[
name|cid
index|]
operator|->
name|rc
index|]
operator|.
name|refcnt
operator|--
expr_stmt|;
block|}
block|}
end_function

end_unit

