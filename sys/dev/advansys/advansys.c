begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Generic driver for the Advanced Systems Inc. SCSI controllers  * Product specific probe and attach routines can be found in:  *   * i386/isa/adv_isa.c	ABP5140, ABP542, ABP5150, ABP842, ABP852  * i386/eisa/adv_eisa.c	ABP742, ABP752  * pci/adv_pci.c	ABP920, ABP930, ABP930U, ABP930UA, ABP940, ABP940U,  *			ABP940UA, ABP950, ABP960, ABP960U, ABP960UA,  *			ABP970, ABP970U  *  * Copyright (c) 1996-2000 Justin Gibbs.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Ported from:  * advansys.c - Linux Host Driver for AdvanSys SCSI Adapters  *       * Copyright (c) 1995-1997 Advanced System Products, Inc.  * All Rights Reserved.  *     * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that redistributions of source  * code retain the above copyright notice and this comment without  * modification.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/advansys/advansys.h>
end_include

begin_function_decl
specifier|static
name|void
name|adv_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|adv_execute_ccb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|int
name|nsegments
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|adv_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|adv_run_doneq
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|adv_ccb_info
modifier|*
name|adv_alloc_ccb_info
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|adv_destroy_ccb_info
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|struct
name|adv_ccb_info
modifier|*
name|cinfo
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|adv_ccb_info
operator|*
name|adv_get_ccb_info
argument_list|(
expr|struct
name|adv_softc
operator|*
name|adv
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|__inline
name|void
name|adv_free_ccb_info
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|struct
name|adv_ccb_info
modifier|*
name|cinfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|adv_set_state
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|adv_state
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|adv_clear_state
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|adv_clear_state_really
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|adv_ccb_info
operator|*
name|adv_get_ccb_info
argument_list|(
argument|struct adv_softc *adv
argument_list|)
block|{ 	struct
name|adv_ccb_info
operator|*
name|cinfo
block|;
name|int
name|opri
block|;
name|opri
operator|=
name|splcam
argument_list|()
block|;
if|if
condition|(
operator|(
name|cinfo
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|adv
operator|->
name|free_ccb_infos
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|adv
operator|->
name|free_ccb_infos
argument_list|,
name|links
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|cinfo
operator|=
name|adv_alloc_ccb_info
argument_list|(
name|adv
argument_list|)
expr_stmt|;
block|}
end_else

begin_expr_stmt
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|cinfo
operator|)
return|;
end_return

begin_function
unit|}  static
name|__inline
name|void
name|adv_free_ccb_info
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|struct
name|adv_ccb_info
modifier|*
name|cinfo
parameter_list|)
block|{
name|int
name|opri
decl_stmt|;
name|opri
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|cinfo
operator|->
name|state
operator|=
name|ACCB_FREE
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|adv
operator|->
name|free_ccb_infos
argument_list|,
name|cinfo
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|adv_set_state
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|adv_state
name|state
parameter_list|)
block|{
if|if
condition|(
name|adv
operator|->
name|state
operator|==
literal|0
condition|)
name|xpt_freeze_simq
argument_list|(
name|adv
operator|->
name|sim
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|adv
operator|->
name|state
operator||=
name|state
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|adv_clear_state
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
if|if
condition|(
name|adv
operator|->
name|state
operator|!=
literal|0
condition|)
name|adv_clear_state_really
argument_list|(
name|adv
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|adv_clear_state_really
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
if|if
condition|(
operator|(
name|adv
operator|->
name|state
operator|&
name|ADV_BUSDMA_BLOCK_CLEARED
operator|)
operator|!=
literal|0
condition|)
name|adv
operator|->
name|state
operator|&=
operator|~
operator|(
name|ADV_BUSDMA_BLOCK_CLEARED
operator||
name|ADV_BUSDMA_BLOCK
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|adv
operator|->
name|state
operator|&
name|ADV_RESOURCE_SHORTAGE
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|openings
decl_stmt|;
name|openings
operator|=
name|adv
operator|->
name|max_openings
operator|-
name|adv
operator|->
name|cur_active
operator|-
name|ADV_MIN_FREE_Q
expr_stmt|;
if|if
condition|(
name|openings
operator|>=
name|adv
operator|->
name|openings_needed
condition|)
block|{
name|adv
operator|->
name|state
operator|&=
operator|~
name|ADV_RESOURCE_SHORTAGE
expr_stmt|;
name|adv
operator|->
name|openings_needed
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|adv
operator|->
name|state
operator|&
name|ADV_IN_TIMEOUT
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|adv_ccb_info
modifier|*
name|cinfo
decl_stmt|;
name|cinfo
operator|=
operator|(
expr|struct
name|adv_ccb_info
operator|*
operator|)
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_cinfo_ptr
expr_stmt|;
if|if
condition|(
operator|(
name|cinfo
operator|->
name|state
operator|&
name|ACCB_RECOVERY_CCB
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
comment|/* 			 * We now traverse our list of pending CCBs 			 * and reinstate their timeouts. 			 */
name|ccb_h
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|adv
operator|->
name|pending_ccbs
argument_list|)
expr_stmt|;
while|while
condition|(
name|ccb_h
operator|!=
name|NULL
condition|)
block|{
name|ccb_h
operator|->
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|adv_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ccb_h
argument_list|,
operator|(
name|ccb_h
operator|->
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|ccb_h
operator|=
name|LIST_NEXT
argument_list|(
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|le
argument_list|)
expr_stmt|;
block|}
name|adv
operator|->
name|state
operator|&=
operator|~
name|ADV_IN_TIMEOUT
expr_stmt|;
name|printf
argument_list|(
literal|"%s: No longer in timeout\n"
argument_list|,
name|adv_name
argument_list|(
name|adv
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|adv
operator|->
name|state
operator|==
literal|0
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
block|}
end_function

begin_function
name|void
name|adv_map
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|bus_addr_t
modifier|*
name|physaddr
decl_stmt|;
name|physaddr
operator|=
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
expr_stmt|;
operator|*
name|physaddr
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|adv_name
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|)
block|{
specifier|static
name|char
name|name
index|[
literal|10
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"adv%d"
argument_list|,
name|adv
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|adv_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"adv_action\n"
operator|)
argument_list|)
expr_stmt|;
name|adv
operator|=
operator|(
expr|struct
name|adv_softc
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
comment|/* Common cases first */
case|case
name|XPT_SCSI_IO
case|:
comment|/* Execute the requested I/O operation */
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|struct
name|adv_ccb_info
modifier|*
name|cinfo
decl_stmt|;
name|ccb_h
operator|=
operator|&
name|ccb
operator|->
name|ccb_h
expr_stmt|;
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
name|cinfo
operator|=
name|adv_get_ccb_info
argument_list|(
name|adv
argument_list|)
expr_stmt|;
if|if
condition|(
name|cinfo
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"XXX Handle CCB info error!!!"
argument_list|)
expr_stmt|;
name|ccb_h
operator|->
name|ccb_cinfo_ptr
operator|=
name|cinfo
expr_stmt|;
name|cinfo
operator|->
name|ccb
operator|=
name|ccb
expr_stmt|;
comment|/* Only use S/G if there is a transfer */
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_SCATTER_VALID
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * We've been given a pointer 				 * to a single buffer 				 */
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|s
decl_stmt|;
name|int
name|error
decl_stmt|;
name|s
operator|=
name|splsoftvm
argument_list|()
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|adv
operator|->
name|buffer_dmat
argument_list|,
name|cinfo
operator|->
name|dmamap
argument_list|,
name|csio
operator|->
name|data_ptr
argument_list|,
name|csio
operator|->
name|dxfer_len
argument_list|,
name|adv_execute_ccb
argument_list|,
name|csio
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
block|{
comment|/* 						 * So as to maintain ordering, 						 * freeze the controller queue 						 * until our mapping is 						 * returned. 						 */
name|adv_set_state
argument_list|(
name|adv
argument_list|,
name|ADV_BUSDMA_BLOCK
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|bus_dma_segment
name|seg
decl_stmt|;
comment|/* Pointer to physical buffer */
name|seg
operator|.
name|ds_addr
operator|=
operator|(
name|bus_addr_t
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
name|seg
operator|.
name|ds_len
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
name|adv_execute_ccb
argument_list|(
name|csio
argument_list|,
operator|&
name|seg
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|struct
name|bus_dma_segment
modifier|*
name|segs
decl_stmt|;
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"adv_setup_data - Physical "
literal|"segment pointers unsupported"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_SG_LIST_PHYS
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"adv_setup_data - Virtual "
literal|"segment addresses unsupported"
argument_list|)
expr_stmt|;
comment|/* Just use the segments provided */
name|segs
operator|=
operator|(
expr|struct
name|bus_dma_segment
operator|*
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
name|adv_execute_ccb
argument_list|(
name|ccb
argument_list|,
name|segs
argument_list|,
name|csio
operator|->
name|sglist_cnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|adv_execute_ccb
argument_list|(
name|ccb
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|XPT_RESET_DEV
case|:
comment|/* Bus Device Reset the specified SCSI device */
case|case
name|XPT_TARGET_IO
case|:
comment|/* Execute target I/O request */
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
comment|/* Accept Host Target Mode CDB */
case|case
name|XPT_CONT_TARGET_IO
case|:
comment|/* Continue Host Target I/O Connection*/
case|case
name|XPT_EN_LUN
case|:
comment|/* Enable LUN as a target */
case|case
name|XPT_ABORT
case|:
comment|/* Abort the specified CCB */
comment|/* XXX Implement */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
define|#
directive|define
name|IS_CURRENT_SETTINGS
parameter_list|(
name|c
parameter_list|)
value|(c->type == CTS_TYPE_CURRENT_SETTINGS)
define|#
directive|define
name|IS_USER_SETTINGS
parameter_list|(
name|c
parameter_list|)
value|(c->type == CTS_TYPE_USER_SETTINGS)
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
block|{
name|struct
name|ccb_trans_settings_scsi
modifier|*
name|scsi
decl_stmt|;
name|struct
name|ccb_trans_settings_spi
modifier|*
name|spi
decl_stmt|;
name|struct
name|ccb_trans_settings
modifier|*
name|cts
decl_stmt|;
name|target_bit_vector
name|targ_mask
decl_stmt|;
name|struct
name|adv_transinfo
modifier|*
name|tconf
decl_stmt|;
name|u_int
name|update_type
decl_stmt|;
name|int
name|s
decl_stmt|;
name|cts
operator|=
operator|&
name|ccb
operator|->
name|cts
expr_stmt|;
name|targ_mask
operator|=
name|ADV_TID_TO_TARGET_MASK
argument_list|(
name|cts
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|)
expr_stmt|;
name|update_type
operator|=
literal|0
expr_stmt|;
comment|/* 		 * The user must specify which type of settings he wishes 		 * to change. 		 */
if|if
condition|(
name|IS_CURRENT_SETTINGS
argument_list|(
name|cts
argument_list|)
operator|&&
operator|!
name|IS_USER_SETTINGS
argument_list|(
name|cts
argument_list|)
condition|)
block|{
name|tconf
operator|=
operator|&
name|adv
operator|->
name|tinfo
index|[
name|cts
operator|->
name|ccb_h
operator|.
name|target_id
index|]
operator|.
name|current
expr_stmt|;
name|update_type
operator||=
name|ADV_TRANS_GOAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_USER_SETTINGS
argument_list|(
name|cts
argument_list|)
operator|&&
operator|!
name|IS_CURRENT_SETTINGS
argument_list|(
name|cts
argument_list|)
condition|)
block|{
name|tconf
operator|=
operator|&
name|adv
operator|->
name|tinfo
index|[
name|cts
operator|->
name|ccb_h
operator|.
name|target_id
index|]
operator|.
name|user
expr_stmt|;
name|update_type
operator||=
name|ADV_TRANS_USER
expr_stmt|;
block|}
else|else
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
break|break;
block|}
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|scsi
operator|=
operator|&
name|cts
operator|->
name|proto_specific
operator|.
name|scsi
expr_stmt|;
name|spi
operator|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|spi
expr_stmt|;
if|if
condition|(
operator|(
name|update_type
operator|&
name|ADV_TRANS_GOAL
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_DISC
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|spi
operator|->
name|flags
operator|&
name|CTS_SPI_FLAGS_DISC_ENB
operator|)
operator|!=
literal|0
condition|)
name|adv
operator|->
name|disc_enable
operator||=
name|targ_mask
expr_stmt|;
else|else
name|adv
operator|->
name|disc_enable
operator|&=
operator|~
name|targ_mask
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_DISC_ENABLE_B
argument_list|,
name|adv
operator|->
name|disc_enable
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|scsi
operator|->
name|valid
operator|&
name|CTS_SCSI_VALID_TQ
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|scsi
operator|->
name|flags
operator|&
name|CTS_SCSI_FLAGS_TAG_ENB
operator|)
operator|!=
literal|0
condition|)
name|adv
operator|->
name|cmd_qng_enabled
operator||=
name|targ_mask
expr_stmt|;
else|else
name|adv
operator|->
name|cmd_qng_enabled
operator|&=
operator|~
name|targ_mask
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|update_type
operator|&
name|ADV_TRANS_USER
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_DISC
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|spi
operator|->
name|flags
operator|&
name|CTS_SPI_VALID_DISC
operator|)
operator|!=
literal|0
condition|)
name|adv
operator|->
name|user_disc_enable
operator||=
name|targ_mask
expr_stmt|;
else|else
name|adv
operator|->
name|user_disc_enable
operator|&=
operator|~
name|targ_mask
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|scsi
operator|->
name|valid
operator|&
name|CTS_SCSI_VALID_TQ
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|scsi
operator|->
name|flags
operator|&
name|CTS_SCSI_FLAGS_TAG_ENB
operator|)
operator|!=
literal|0
condition|)
name|adv
operator|->
name|user_cmd_qng_enabled
operator||=
name|targ_mask
expr_stmt|;
else|else
name|adv
operator|->
name|user_cmd_qng_enabled
operator|&=
operator|~
name|targ_mask
expr_stmt|;
block|}
block|}
comment|/* 		 * If the user specifies either the sync rate, or offset, 		 * but not both, the unspecified parameter defaults to its 		 * current value in transfer negotiations. 		 */
if|if
condition|(
operator|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_RATE
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_OFFSET
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* 			 * If the user provided a sync rate but no offset, 			 * use the current offset. 			 */
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_OFFSET
operator|)
operator|==
literal|0
condition|)
name|spi
operator|->
name|sync_offset
operator|=
name|tconf
operator|->
name|offset
expr_stmt|;
comment|/* 			 * If the user provided an offset but no sync rate, 			 * use the current sync rate. 			 */
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_RATE
operator|)
operator|==
literal|0
condition|)
name|spi
operator|->
name|sync_period
operator|=
name|tconf
operator|->
name|period
expr_stmt|;
name|adv_period_offset_to_sdtr
argument_list|(
name|adv
argument_list|,
operator|&
name|spi
operator|->
name|sync_period
argument_list|,
operator|&
name|spi
operator|->
name|sync_offset
argument_list|,
name|cts
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|)
expr_stmt|;
name|adv_set_syncrate
argument_list|(
name|adv
argument_list|,
comment|/*struct cam_path */
name|NULL
argument_list|,
name|cts
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|spi
operator|->
name|sync_period
argument_list|,
name|spi
operator|->
name|sync_offset
argument_list|,
name|update_type
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
comment|/* Get default/user set transfer settings for the target */
block|{
name|struct
name|ccb_trans_settings_scsi
modifier|*
name|scsi
decl_stmt|;
name|struct
name|ccb_trans_settings_spi
modifier|*
name|spi
decl_stmt|;
name|struct
name|ccb_trans_settings
modifier|*
name|cts
decl_stmt|;
name|struct
name|adv_transinfo
modifier|*
name|tconf
decl_stmt|;
name|target_bit_vector
name|target_mask
decl_stmt|;
name|int
name|s
decl_stmt|;
name|cts
operator|=
operator|&
name|ccb
operator|->
name|cts
expr_stmt|;
name|target_mask
operator|=
name|ADV_TID_TO_TARGET_MASK
argument_list|(
name|cts
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|)
expr_stmt|;
name|scsi
operator|=
operator|&
name|cts
operator|->
name|proto_specific
operator|.
name|scsi
expr_stmt|;
name|spi
operator|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|spi
expr_stmt|;
name|cts
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cts
operator|->
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|cts
operator|->
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|cts
operator|->
name|transport_version
operator|=
literal|2
expr_stmt|;
name|scsi
operator|->
name|flags
operator|&=
operator|~
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
name|spi
operator|->
name|flags
operator|&=
operator|~
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_CURRENT_SETTINGS
condition|)
block|{
name|tconf
operator|=
operator|&
name|adv
operator|->
name|tinfo
index|[
name|cts
operator|->
name|ccb_h
operator|.
name|target_id
index|]
operator|.
name|current
expr_stmt|;
if|if
condition|(
operator|(
name|adv
operator|->
name|disc_enable
operator|&
name|target_mask
operator|)
operator|!=
literal|0
condition|)
name|spi
operator|->
name|flags
operator||=
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
if|if
condition|(
operator|(
name|adv
operator|->
name|cmd_qng_enabled
operator|&
name|target_mask
operator|)
operator|!=
literal|0
condition|)
name|scsi
operator|->
name|flags
operator||=
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
block|}
else|else
block|{
name|tconf
operator|=
operator|&
name|adv
operator|->
name|tinfo
index|[
name|cts
operator|->
name|ccb_h
operator|.
name|target_id
index|]
operator|.
name|user
expr_stmt|;
if|if
condition|(
operator|(
name|adv
operator|->
name|user_disc_enable
operator|&
name|target_mask
operator|)
operator|!=
literal|0
condition|)
name|spi
operator|->
name|flags
operator||=
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
if|if
condition|(
operator|(
name|adv
operator|->
name|user_cmd_qng_enabled
operator|&
name|target_mask
operator|)
operator|!=
literal|0
condition|)
name|scsi
operator|->
name|flags
operator||=
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
block|}
name|spi
operator|->
name|sync_period
operator|=
name|tconf
operator|->
name|period
expr_stmt|;
name|spi
operator|->
name|sync_offset
operator|=
name|tconf
operator|->
name|offset
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|spi
operator|->
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_8_BIT
expr_stmt|;
name|spi
operator|->
name|valid
operator|=
name|CTS_SPI_VALID_SYNC_RATE
operator||
name|CTS_SPI_VALID_SYNC_OFFSET
operator||
name|CTS_SPI_VALID_BUS_WIDTH
operator||
name|CTS_SPI_VALID_DISC
expr_stmt|;
name|scsi
operator|->
name|valid
operator|=
name|CTS_SCSI_VALID_TQ
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_CALC_GEOMETRY
case|:
block|{
name|int
name|extended
decl_stmt|;
name|extended
operator|=
operator|(
name|adv
operator|->
name|control
operator|&
name|ADV_CNTL_BIOS_GT_1GB
operator|)
operator|!=
literal|0
expr_stmt|;
name|cam_calc_geometry
argument_list|(
operator|&
name|ccb
operator|->
name|ccg
argument_list|,
name|extended
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_RESET_BUS
case|:
comment|/* Reset the specified SCSI bus */
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|adv_stop_execution
argument_list|(
name|adv
argument_list|)
expr_stmt|;
name|adv_reset_bus
argument_list|(
name|adv
argument_list|,
comment|/*initiate_reset*/
name|TRUE
argument_list|)
expr_stmt|;
name|adv_start_execution
argument_list|(
name|adv
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_TERM_IO
case|:
comment|/* Terminate the I/O process */
comment|/* XXX Implement */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_PATH_INQ
case|:
comment|/* Path routing inquiry */
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
init|=
operator|&
name|ccb
operator|->
name|cpi
decl_stmt|;
name|cpi
operator|->
name|version_num
operator|=
literal|1
expr_stmt|;
comment|/* XXX??? */
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_SDTR_ABLE
operator||
name|PI_TAG_ABLE
expr_stmt|;
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_misc
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_target
operator|=
literal|7
expr_stmt|;
name|cpi
operator|->
name|max_lun
operator|=
literal|7
expr_stmt|;
name|cpi
operator|->
name|initiator_id
operator|=
name|adv
operator|->
name|scsi_id
expr_stmt|;
name|cpi
operator|->
name|bus_id
operator|=
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|3300
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|"Advansys"
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|sim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|cam_sim_unit
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|cpi
operator|->
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|cpi
operator|->
name|transport_version
operator|=
literal|2
expr_stmt|;
name|cpi
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cpi
operator|->
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Currently, the output of bus_dmammap_load suits our needs just  * fine, but should it change, we'd need to do something here.  */
end_comment

begin_define
define|#
directive|define
name|adv_fixup_dmasegs
parameter_list|(
name|adv
parameter_list|,
name|dm_segs
parameter_list|)
value|(struct adv_sg_entry *)(dm_segs)
end_define

begin_function
specifier|static
name|void
name|adv_execute_ccb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|int
name|nsegments
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|struct
name|adv_ccb_info
modifier|*
name|cinfo
decl_stmt|;
name|struct
name|adv_scsi_q
name|scsiq
decl_stmt|;
name|struct
name|adv_sg_head
name|sghead
decl_stmt|;
name|int
name|s
decl_stmt|;
name|csio
operator|=
operator|(
expr|struct
name|ccb_scsiio
operator|*
operator|)
name|arg
expr_stmt|;
name|ccb_h
operator|=
operator|&
name|csio
operator|->
name|ccb_h
expr_stmt|;
name|sim
operator|=
name|xpt_path_sim
argument_list|(
name|ccb_h
operator|->
name|path
argument_list|)
expr_stmt|;
name|adv
operator|=
operator|(
expr|struct
name|adv_softc
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cinfo
operator|=
operator|(
expr|struct
name|adv_ccb_info
operator|*
operator|)
name|csio
operator|->
name|ccb_h
operator|.
name|ccb_cinfo_ptr
expr_stmt|;
comment|/* 	 * Setup our done routine to release the simq on 	 * the next ccb that completes. 	 */
if|if
condition|(
operator|(
name|adv
operator|->
name|state
operator|&
name|ADV_BUSDMA_BLOCK
operator|)
operator|!=
literal|0
condition|)
name|adv
operator|->
name|state
operator||=
name|ADV_BUSDMA_BLOCK_CLEARED
expr_stmt|;
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_CDB_POINTER
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_CDB_PHYS
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* XXX Need phystovirt!!!! */
comment|/* How about pmap_kenter??? */
name|scsiq
operator|.
name|cdbptr
operator|=
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
expr_stmt|;
block|}
else|else
block|{
name|scsiq
operator|.
name|cdbptr
operator|=
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
expr_stmt|;
block|}
block|}
else|else
block|{
name|scsiq
operator|.
name|cdbptr
operator|=
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
block|}
comment|/* 	 * Build up the request 	 */
name|scsiq
operator|.
name|q1
operator|.
name|status
operator|=
literal|0
expr_stmt|;
name|scsiq
operator|.
name|q1
operator|.
name|q_no
operator|=
literal|0
expr_stmt|;
name|scsiq
operator|.
name|q1
operator|.
name|cntl
operator|=
literal|0
expr_stmt|;
name|scsiq
operator|.
name|q1
operator|.
name|sg_queue_cnt
operator|=
literal|0
expr_stmt|;
name|scsiq
operator|.
name|q1
operator|.
name|target_id
operator|=
name|ADV_TID_TO_TARGET_MASK
argument_list|(
name|ccb_h
operator|->
name|target_id
argument_list|)
expr_stmt|;
name|scsiq
operator|.
name|q1
operator|.
name|target_lun
operator|=
name|ccb_h
operator|->
name|target_lun
expr_stmt|;
name|scsiq
operator|.
name|q1
operator|.
name|sense_len
operator|=
name|csio
operator|->
name|sense_len
expr_stmt|;
name|scsiq
operator|.
name|q1
operator|.
name|extra_bytes
operator|=
literal|0
expr_stmt|;
name|scsiq
operator|.
name|q2
operator|.
name|ccb_index
operator|=
name|cinfo
operator|-
name|adv
operator|->
name|ccb_infos
expr_stmt|;
name|scsiq
operator|.
name|q2
operator|.
name|target_ix
operator|=
name|ADV_TIDLUN_TO_IX
argument_list|(
name|ccb_h
operator|->
name|target_id
argument_list|,
name|ccb_h
operator|->
name|target_lun
argument_list|)
expr_stmt|;
name|scsiq
operator|.
name|q2
operator|.
name|flag
operator|=
literal|0
expr_stmt|;
name|scsiq
operator|.
name|q2
operator|.
name|cdb_len
operator|=
name|csio
operator|->
name|cdb_len
expr_stmt|;
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_TAG_ACTION_VALID
operator|)
operator|!=
literal|0
condition|)
name|scsiq
operator|.
name|q2
operator|.
name|tag_code
operator|=
name|csio
operator|->
name|tag_action
expr_stmt|;
else|else
name|scsiq
operator|.
name|q2
operator|.
name|tag_code
operator|=
literal|0
expr_stmt|;
name|scsiq
operator|.
name|q2
operator|.
name|vm_id
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nsegments
operator|!=
literal|0
condition|)
block|{
name|bus_dmasync_op_t
name|op
decl_stmt|;
name|scsiq
operator|.
name|q1
operator|.
name|data_addr
operator|=
name|dm_segs
operator|->
name|ds_addr
expr_stmt|;
name|scsiq
operator|.
name|q1
operator|.
name|data_cnt
operator|=
name|dm_segs
operator|->
name|ds_len
expr_stmt|;
if|if
condition|(
name|nsegments
operator|>
literal|1
condition|)
block|{
name|scsiq
operator|.
name|q1
operator|.
name|cntl
operator||=
name|QC_SG_HEAD
expr_stmt|;
name|sghead
operator|.
name|entry_cnt
operator|=
name|sghead
operator|.
name|entry_to_copy
operator|=
name|nsegments
expr_stmt|;
name|sghead
operator|.
name|res
operator|=
literal|0
expr_stmt|;
name|sghead
operator|.
name|sg_list
operator|=
name|adv_fixup_dmasegs
argument_list|(
name|adv
argument_list|,
name|dm_segs
argument_list|)
expr_stmt|;
name|scsiq
operator|.
name|sg_head
operator|=
operator|&
name|sghead
expr_stmt|;
block|}
else|else
block|{
name|scsiq
operator|.
name|sg_head
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
name|op
operator|=
name|BUS_DMASYNC_PREREAD
expr_stmt|;
else|else
name|op
operator|=
name|BUS_DMASYNC_PREWRITE
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|adv
operator|->
name|buffer_dmat
argument_list|,
name|cinfo
operator|->
name|dmamap
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|scsiq
operator|.
name|q1
operator|.
name|data_addr
operator|=
literal|0
expr_stmt|;
name|scsiq
operator|.
name|q1
operator|.
name|data_cnt
operator|=
literal|0
expr_stmt|;
name|scsiq
operator|.
name|sg_head
operator|=
name|NULL
expr_stmt|;
block|}
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
comment|/* 	 * Last time we need to check if this SCB needs to 	 * be aborted. 	 */
if|if
condition|(
name|ccb_h
operator|->
name|status
operator|!=
name|CAM_REQ_INPROG
condition|)
block|{
if|if
condition|(
name|nsegments
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|adv
operator|->
name|buffer_dmat
argument_list|,
name|cinfo
operator|->
name|dmamap
argument_list|)
expr_stmt|;
name|adv_clear_state
argument_list|(
name|adv
argument_list|,
operator|(
expr|union
name|ccb
operator|*
operator|)
name|csio
argument_list|)
expr_stmt|;
name|adv_free_ccb_info
argument_list|(
name|adv
argument_list|,
name|cinfo
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|csio
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|adv_execute_scsi_queue
argument_list|(
name|adv
argument_list|,
operator|&
name|scsiq
argument_list|,
name|csio
operator|->
name|dxfer_len
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Temporary resource shortage */
name|adv_set_state
argument_list|(
name|adv
argument_list|,
name|ADV_RESOURCE_SHORTAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsegments
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|adv
operator|->
name|buffer_dmat
argument_list|,
name|cinfo
operator|->
name|dmamap
argument_list|)
expr_stmt|;
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQUEUE_REQ
expr_stmt|;
name|adv_clear_state
argument_list|(
name|adv
argument_list|,
operator|(
expr|union
name|ccb
operator|*
operator|)
name|csio
argument_list|)
expr_stmt|;
name|adv_free_ccb_info
argument_list|(
name|adv
argument_list|,
name|cinfo
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|csio
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|cinfo
operator|->
name|state
operator||=
name|ACCB_ACTIVE
expr_stmt|;
name|ccb_h
operator|->
name|status
operator||=
name|CAM_SIM_QUEUED
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|adv
operator|->
name|pending_ccbs
argument_list|,
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|le
argument_list|)
expr_stmt|;
comment|/* Schedule our timeout */
name|ccb_h
operator|->
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|adv_timeout
argument_list|,
name|csio
argument_list|,
operator|(
name|ccb_h
operator|->
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|adv_ccb_info
modifier|*
name|adv_alloc_ccb_info
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|adv_ccb_info
modifier|*
name|cinfo
decl_stmt|;
name|cinfo
operator|=
operator|&
name|adv
operator|->
name|ccb_infos
index|[
name|adv
operator|->
name|ccb_infos_allocated
index|]
expr_stmt|;
name|cinfo
operator|->
name|state
operator|=
name|ACCB_FREE
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|adv
operator|->
name|buffer_dmat
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
operator|&
name|cinfo
operator|->
name|dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Unable to allocate CCB info "
literal|"dmamap - error %d\n"
argument_list|,
name|adv_name
argument_list|(
name|adv
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|adv
operator|->
name|ccb_infos_allocated
operator|++
expr_stmt|;
return|return
operator|(
name|cinfo
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|adv_destroy_ccb_info
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|struct
name|adv_ccb_info
modifier|*
name|cinfo
parameter_list|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|adv
operator|->
name|buffer_dmat
argument_list|,
name|cinfo
operator|->
name|dmamap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|adv_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|struct
name|adv_ccb_info
modifier|*
name|cinfo
decl_stmt|;
name|ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|arg
expr_stmt|;
name|adv
operator|=
operator|(
expr|struct
name|adv_softc
operator|*
operator|)
name|xpt_path_sim
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
operator|->
name|softc
expr_stmt|;
name|cinfo
operator|=
operator|(
expr|struct
name|adv_ccb_info
operator|*
operator|)
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_cinfo_ptr
expr_stmt|;
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Timed out\n"
argument_list|)
expr_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
comment|/* Have we been taken care of already?? */
if|if
condition|(
name|cinfo
operator|==
name|NULL
operator|||
name|cinfo
operator|->
name|state
operator|==
name|ACCB_FREE
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|adv_stop_execution
argument_list|(
name|adv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cinfo
operator|->
name|state
operator|&
name|ACCB_ABORT_QUEUED
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
comment|/* 		 * In order to simplify the recovery process, we ask the XPT 		 * layer to halt the queue of new transactions and we traverse 		 * the list of pending CCBs and remove their timeouts. This 		 * means that the driver attempts to clear only one error 		 * condition at a time.  In general, timeouts that occur 		 * close together are related anyway, so there is no benefit 		 * in attempting to handle errors in parrallel.  Timeouts will 		 * be reinstated when the recovery process ends. 		 */
name|adv_set_state
argument_list|(
name|adv
argument_list|,
name|ADV_IN_TIMEOUT
argument_list|)
expr_stmt|;
comment|/* This CCB is the CCB representing our recovery actions */
name|cinfo
operator|->
name|state
operator||=
name|ACCB_RECOVERY_CCB
operator||
name|ACCB_ABORT_QUEUED
expr_stmt|;
name|ccb_h
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|adv
operator|->
name|pending_ccbs
argument_list|)
expr_stmt|;
while|while
condition|(
name|ccb_h
operator|!=
name|NULL
condition|)
block|{
name|untimeout
argument_list|(
name|adv_timeout
argument_list|,
name|ccb_h
argument_list|,
name|ccb_h
operator|->
name|timeout_ch
argument_list|)
expr_stmt|;
name|ccb_h
operator|=
name|LIST_NEXT
argument_list|(
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|le
argument_list|)
expr_stmt|;
block|}
comment|/* XXX Should send a BDR */
comment|/* Attempt an abort as our first tact */
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Attempting abort\n"
argument_list|)
expr_stmt|;
name|adv_abort_ccb
argument_list|(
name|adv
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
name|ccb
argument_list|,
name|CAM_CMD_TIMEOUT
argument_list|,
comment|/*queued_only*/
name|FALSE
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|adv_timeout
argument_list|,
name|ccb
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Our attempt to perform an abort failed, go for a reset */
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Resetting bus\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_CMD_TIMEOUT
expr_stmt|;
name|adv_reset_bus
argument_list|(
name|adv
argument_list|,
comment|/*initiate_reset*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|adv_start_execution
argument_list|(
name|adv
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|adv_softc
modifier|*
name|adv_alloc
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|bus_space_tag_t
name|tag
parameter_list|,
name|bus_space_handle_t
name|bsh
parameter_list|)
block|{
name|struct
name|adv_softc
modifier|*
name|adv
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* 	 * Allocate a storage area for us 	 */
name|LIST_INIT
argument_list|(
operator|&
name|adv
operator|->
name|pending_ccbs
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|adv
operator|->
name|free_ccb_infos
argument_list|)
expr_stmt|;
name|adv
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|adv
operator|->
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|adv
operator|->
name|tag
operator|=
name|tag
expr_stmt|;
name|adv
operator|->
name|bsh
operator|=
name|bsh
expr_stmt|;
return|return
operator|(
name|adv
operator|)
return|;
block|}
end_function

begin_function
name|void
name|adv_free
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|)
block|{
switch|switch
condition|(
name|adv
operator|->
name|init_level
condition|)
block|{
case|case
literal|6
case|:
block|{
name|struct
name|adv_ccb_info
modifier|*
name|cinfo
decl_stmt|;
while|while
condition|(
operator|(
name|cinfo
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|adv
operator|->
name|free_ccb_infos
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|adv
operator|->
name|free_ccb_infos
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|adv_destroy_ccb_info
argument_list|(
name|adv
argument_list|,
name|cinfo
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_unload
argument_list|(
name|adv
operator|->
name|sense_dmat
argument_list|,
name|adv
operator|->
name|sense_dmamap
argument_list|)
expr_stmt|;
block|}
case|case
literal|5
case|:
name|bus_dmamem_free
argument_list|(
name|adv
operator|->
name|sense_dmat
argument_list|,
name|adv
operator|->
name|sense_buffers
argument_list|,
name|adv
operator|->
name|sense_dmamap
argument_list|)
expr_stmt|;
case|case
literal|4
case|:
name|bus_dma_tag_destroy
argument_list|(
name|adv
operator|->
name|sense_dmat
argument_list|)
expr_stmt|;
case|case
literal|3
case|:
name|bus_dma_tag_destroy
argument_list|(
name|adv
operator|->
name|buffer_dmat
argument_list|)
expr_stmt|;
case|case
literal|2
case|:
name|bus_dma_tag_destroy
argument_list|(
name|adv
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
if|if
condition|(
name|adv
operator|->
name|ccb_infos
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|adv
operator|->
name|ccb_infos
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
break|break;
block|}
block|}
end_function

begin_function
name|int
name|adv_init
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|)
block|{
name|struct
name|adv_eeprom_config
name|eeprom_config
decl_stmt|;
name|int
name|checksum
decl_stmt|,
name|i
decl_stmt|;
name|int
name|max_sync
decl_stmt|;
name|u_int16_t
name|config_lsw
decl_stmt|;
name|u_int16_t
name|config_msw
decl_stmt|;
name|adv_lib_init
argument_list|(
name|adv
argument_list|)
expr_stmt|;
comment|/* 	 * Stop script execution. 	 */
name|adv_write_lram_16
argument_list|(
name|adv
argument_list|,
name|ADV_HALTCODE_W
argument_list|,
literal|0x00FE
argument_list|)
expr_stmt|;
name|adv_stop_execution
argument_list|(
name|adv
argument_list|)
expr_stmt|;
if|if
condition|(
name|adv_stop_chip
argument_list|(
name|adv
argument_list|)
operator|==
literal|0
operator|||
name|adv_is_chip_halted
argument_list|(
name|adv
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"adv%d: Unable to halt adapter. Initialization"
literal|"failed\n"
argument_list|,
name|adv
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_REG_PROG_COUNTER
argument_list|,
name|ADV_MCODE_START_ADDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_REG_PROG_COUNTER
argument_list|)
operator|!=
name|ADV_MCODE_START_ADDR
condition|)
block|{
name|printf
argument_list|(
literal|"adv%d: Unable to set program counter. Initialization"
literal|"failed\n"
argument_list|,
name|adv
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|config_msw
operator|=
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_CONFIG_MSW
argument_list|)
expr_stmt|;
name|config_lsw
operator|=
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_CONFIG_LSW
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|config_msw
operator|&
name|ADV_CFG_MSW_CLR_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|config_msw
operator|&=
operator|~
name|ADV_CFG_MSW_CLR_MASK
expr_stmt|;
comment|/* 		 * XXX The Linux code flags this as an error, 		 * but what should we report to the user??? 		 * It seems that clearing the config register 		 * makes this error recoverable. 		 */
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_CONFIG_MSW
argument_list|,
name|config_msw
argument_list|)
expr_stmt|;
block|}
comment|/* Suck in the configuration from the EEProm */
name|checksum
operator|=
name|adv_get_eeprom_config
argument_list|(
name|adv
argument_list|,
operator|&
name|eeprom_config
argument_list|)
expr_stmt|;
if|if
condition|(
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_STATUS
argument_list|)
operator|&
name|ADV_CSW_AUTO_CONFIG
condition|)
block|{
comment|/* 		 * XXX The Linux code sets a warning level for this 		 * condition, yet nothing of meaning is printed to 		 * the user.  What does this mean??? 		 */
if|if
condition|(
name|adv
operator|->
name|chip_version
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|eeprom_config
operator|.
name|cfg_lsw
operator|!=
name|config_lsw
condition|)
name|eeprom_config
operator|.
name|cfg_lsw
operator|=
name|config_lsw
expr_stmt|;
if|if
condition|(
name|eeprom_config
operator|.
name|cfg_msw
operator|!=
name|config_msw
condition|)
block|{
name|eeprom_config
operator|.
name|cfg_msw
operator|=
name|config_msw
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|checksum
operator|==
name|eeprom_config
operator|.
name|chksum
condition|)
block|{
comment|/* Range/Sanity checking */
if|if
condition|(
name|eeprom_config
operator|.
name|max_total_qng
operator|<
name|ADV_MIN_TOTAL_QNG
condition|)
block|{
name|eeprom_config
operator|.
name|max_total_qng
operator|=
name|ADV_MIN_TOTAL_QNG
expr_stmt|;
block|}
if|if
condition|(
name|eeprom_config
operator|.
name|max_total_qng
operator|>
name|ADV_MAX_TOTAL_QNG
condition|)
block|{
name|eeprom_config
operator|.
name|max_total_qng
operator|=
name|ADV_MAX_TOTAL_QNG
expr_stmt|;
block|}
if|if
condition|(
name|eeprom_config
operator|.
name|max_tag_qng
operator|>
name|eeprom_config
operator|.
name|max_total_qng
condition|)
block|{
name|eeprom_config
operator|.
name|max_tag_qng
operator|=
name|eeprom_config
operator|.
name|max_total_qng
expr_stmt|;
block|}
if|if
condition|(
name|eeprom_config
operator|.
name|max_tag_qng
operator|<
name|ADV_MIN_TAG_Q_PER_DVC
condition|)
block|{
name|eeprom_config
operator|.
name|max_tag_qng
operator|=
name|ADV_MIN_TAG_Q_PER_DVC
expr_stmt|;
block|}
name|adv
operator|->
name|max_openings
operator|=
name|eeprom_config
operator|.
name|max_total_qng
expr_stmt|;
name|adv
operator|->
name|user_disc_enable
operator|=
name|eeprom_config
operator|.
name|disc_enable
expr_stmt|;
name|adv
operator|->
name|user_cmd_qng_enabled
operator|=
name|eeprom_config
operator|.
name|use_cmd_qng
expr_stmt|;
name|adv
operator|->
name|isa_dma_speed
operator|=
name|EEPROM_DMA_SPEED
argument_list|(
name|eeprom_config
argument_list|)
expr_stmt|;
name|adv
operator|->
name|scsi_id
operator|=
name|EEPROM_SCSIID
argument_list|(
name|eeprom_config
argument_list|)
operator|&
name|ADV_MAX_TID
expr_stmt|;
name|EEPROM_SET_SCSIID
argument_list|(
name|eeprom_config
argument_list|,
name|adv
operator|->
name|scsi_id
argument_list|)
expr_stmt|;
name|adv
operator|->
name|control
operator|=
name|eeprom_config
operator|.
name|cntl
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|ADV_MAX_TID
condition|;
name|i
operator|++
control|)
block|{
name|u_int8_t
name|sync_data
decl_stmt|;
if|if
condition|(
operator|(
name|eeprom_config
operator|.
name|init_sdtr
operator|&
operator|(
literal|0x1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
name|sync_data
operator|=
literal|0
expr_stmt|;
else|else
name|sync_data
operator|=
name|eeprom_config
operator|.
name|sdtr_data
index|[
name|i
index|]
expr_stmt|;
name|adv_sdtr_to_period_offset
argument_list|(
name|adv
argument_list|,
name|sync_data
argument_list|,
operator|&
name|adv
operator|->
name|tinfo
index|[
name|i
index|]
operator|.
name|user
operator|.
name|period
argument_list|,
operator|&
name|adv
operator|->
name|tinfo
index|[
name|i
index|]
operator|.
name|user
operator|.
name|offset
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|config_lsw
operator|=
name|eeprom_config
operator|.
name|cfg_lsw
expr_stmt|;
name|eeprom_config
operator|.
name|cfg_msw
operator|=
name|config_msw
expr_stmt|;
block|}
else|else
block|{
name|u_int8_t
name|sync_data
decl_stmt|;
name|printf
argument_list|(
literal|"adv%d: Warning EEPROM Checksum mismatch. "
literal|"Using default device parameters\n"
argument_list|,
name|adv
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* Set reasonable defaults since we can't read the EEPROM */
name|adv
operator|->
name|isa_dma_speed
operator|=
comment|/*ADV_DEF_ISA_DMA_SPEED*/
literal|1
expr_stmt|;
name|adv
operator|->
name|max_openings
operator|=
name|ADV_DEF_MAX_TOTAL_QNG
expr_stmt|;
name|adv
operator|->
name|disc_enable
operator|=
name|TARGET_BIT_VECTOR_SET
expr_stmt|;
name|adv
operator|->
name|user_disc_enable
operator|=
name|TARGET_BIT_VECTOR_SET
expr_stmt|;
name|adv
operator|->
name|cmd_qng_enabled
operator|=
name|TARGET_BIT_VECTOR_SET
expr_stmt|;
name|adv
operator|->
name|user_cmd_qng_enabled
operator|=
name|TARGET_BIT_VECTOR_SET
expr_stmt|;
name|adv
operator|->
name|scsi_id
operator|=
literal|7
expr_stmt|;
name|adv
operator|->
name|control
operator|=
literal|0xFFFF
expr_stmt|;
if|if
condition|(
name|adv
operator|->
name|chip_version
operator|==
name|ADV_CHIP_VER_PCI_ULTRA_3050
condition|)
comment|/* Default to no Ultra to support the 3030 */
name|adv
operator|->
name|control
operator|&=
operator|~
name|ADV_CNTL_SDTR_ENABLE_ULTRA
expr_stmt|;
name|sync_data
operator|=
name|ADV_DEF_SDTR_OFFSET
operator||
operator|(
name|ADV_DEF_SDTR_INDEX
operator|<<
literal|4
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|ADV_MAX_TID
condition|;
name|i
operator|++
control|)
block|{
name|adv_sdtr_to_period_offset
argument_list|(
name|adv
argument_list|,
name|sync_data
argument_list|,
operator|&
name|adv
operator|->
name|tinfo
index|[
name|i
index|]
operator|.
name|user
operator|.
name|period
argument_list|,
operator|&
name|adv
operator|->
name|tinfo
index|[
name|i
index|]
operator|.
name|user
operator|.
name|offset
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|config_lsw
operator||=
name|ADV_CFG_LSW_SCSI_PARITY_ON
expr_stmt|;
block|}
name|config_msw
operator|&=
operator|~
name|ADV_CFG_MSW_CLR_MASK
expr_stmt|;
name|config_lsw
operator||=
name|ADV_CFG_LSW_HOST_INT_ON
expr_stmt|;
if|if
condition|(
operator|(
name|adv
operator|->
name|type
operator|&
operator|(
name|ADV_PCI
operator||
name|ADV_ULTRA
operator|)
operator|)
operator|==
operator|(
name|ADV_PCI
operator||
name|ADV_ULTRA
operator|)
operator|&&
operator|(
name|adv
operator|->
name|control
operator|&
name|ADV_CNTL_SDTR_ENABLE_ULTRA
operator|)
operator|==
literal|0
condition|)
comment|/* 25ns or 10MHz */
name|max_sync
operator|=
literal|25
expr_stmt|;
else|else
comment|/* Unlimited */
name|max_sync
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|ADV_MAX_TID
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|adv
operator|->
name|tinfo
index|[
name|i
index|]
operator|.
name|user
operator|.
name|period
operator|<
name|max_sync
condition|)
name|adv
operator|->
name|tinfo
index|[
name|i
index|]
operator|.
name|user
operator|.
name|period
operator|=
name|max_sync
expr_stmt|;
block|}
if|if
condition|(
name|adv_test_external_lram
argument_list|(
name|adv
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|adv
operator|->
name|type
operator|&
operator|(
name|ADV_PCI
operator||
name|ADV_ULTRA
operator|)
operator|)
operator|==
operator|(
name|ADV_PCI
operator||
name|ADV_ULTRA
operator|)
condition|)
block|{
name|eeprom_config
operator|.
name|max_total_qng
operator|=
name|ADV_MAX_PCI_ULTRA_INRAM_TOTAL_QNG
expr_stmt|;
name|eeprom_config
operator|.
name|max_tag_qng
operator|=
name|ADV_MAX_PCI_ULTRA_INRAM_TAG_QNG
expr_stmt|;
block|}
else|else
block|{
name|eeprom_config
operator|.
name|cfg_msw
operator||=
literal|0x0800
expr_stmt|;
name|config_msw
operator||=
literal|0x0800
expr_stmt|;
name|eeprom_config
operator|.
name|max_total_qng
operator|=
name|ADV_MAX_PCI_INRAM_TOTAL_QNG
expr_stmt|;
name|eeprom_config
operator|.
name|max_tag_qng
operator|=
name|ADV_MAX_INRAM_TAG_QNG
expr_stmt|;
block|}
name|adv
operator|->
name|max_openings
operator|=
name|eeprom_config
operator|.
name|max_total_qng
expr_stmt|;
block|}
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_CONFIG_MSW
argument_list|,
name|config_msw
argument_list|)
expr_stmt|;
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_CONFIG_LSW
argument_list|,
name|config_lsw
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	 * Don't write the eeprom data back for now. 	 * I'd rather not mess up the user's card.  We also don't 	 * fully sanitize the eeprom settings above for the write-back 	 * to be 100% correct. 	 */
block|if (adv_set_eeprom_config(adv,&eeprom_config) != 0) 		printf("%s: WARNING! Failure writing to EEPROM.\n", 		       adv_name(adv));
endif|#
directive|endif
name|adv_set_chip_scsiid
argument_list|(
name|adv
argument_list|,
name|adv
operator|->
name|scsi_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|adv_init_lram_and_mcode
argument_list|(
name|adv
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|adv
operator|->
name|disc_enable
operator|=
name|adv
operator|->
name|user_disc_enable
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_DISC_ENABLE_B
argument_list|,
name|adv
operator|->
name|disc_enable
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|ADV_MAX_TID
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Start off in async mode. 		 */
name|adv_set_syncrate
argument_list|(
name|adv
argument_list|,
comment|/*struct cam_path */
name|NULL
argument_list|,
name|i
argument_list|,
comment|/*period*/
literal|0
argument_list|,
comment|/*offset*/
literal|0
argument_list|,
name|ADV_TRANS_CUR
argument_list|)
expr_stmt|;
comment|/* 		 * Enable the use of tagged commands on all targets. 		 * This allows the kernel driver to make up it's own mind 		 * as it sees fit to tag queue instead of having the 		 * firmware try and second guess the tag_code settins. 		 */
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_MAX_DVC_QNG_BEG
operator|+
name|i
argument_list|,
name|adv
operator|->
name|max_openings
argument_list|)
expr_stmt|;
block|}
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_USE_TAGGED_QNG_B
argument_list|,
name|TARGET_BIT_VECTOR_SET
argument_list|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_CAN_TAGGED_QNG_B
argument_list|,
name|TARGET_BIT_VECTOR_SET
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"adv%d: AdvanSys %s Host Adapter, SCSI ID %d, queue depth %d\n"
argument_list|,
name|adv
operator|->
name|unit
argument_list|,
operator|(
name|adv
operator|->
name|type
operator|&
name|ADV_ULTRA
operator|)
operator|&&
operator|(
name|max_sync
operator|==
literal|0
operator|)
condition|?
literal|"Ultra SCSI"
else|:
literal|"SCSI"
argument_list|,
name|adv
operator|->
name|scsi_id
argument_list|,
name|adv
operator|->
name|max_openings
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|adv_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|u_int16_t
name|chipstat
decl_stmt|;
name|u_int16_t
name|saved_ram_addr
decl_stmt|;
name|u_int8_t
name|ctrl_reg
decl_stmt|;
name|u_int8_t
name|saved_ctrl_reg
decl_stmt|;
name|u_int8_t
name|host_flag
decl_stmt|;
name|adv
operator|=
operator|(
expr|struct
name|adv_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|chipstat
operator|=
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_STATUS
argument_list|)
expr_stmt|;
comment|/* Is it for us? */
if|if
condition|(
operator|(
name|chipstat
operator|&
operator|(
name|ADV_CSW_INT_PENDING
operator||
name|ADV_CSW_SCSI_RESET_LATCH
operator|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|ctrl_reg
operator|=
name|ADV_INB
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_CTRL
argument_list|)
expr_stmt|;
name|saved_ctrl_reg
operator|=
name|ctrl_reg
operator|&
operator|(
operator|~
operator|(
name|ADV_CC_SCSI_RESET
operator||
name|ADV_CC_CHIP_RESET
operator||
name|ADV_CC_SINGLE_STEP
operator||
name|ADV_CC_DIAG
operator||
name|ADV_CC_TEST
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|chipstat
operator|&
operator|(
name|ADV_CSW_SCSI_RESET_LATCH
operator||
name|ADV_CSW_SCSI_RESET_ACTIVE
operator|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Detected Bus Reset\n"
argument_list|)
expr_stmt|;
name|adv_reset_bus
argument_list|(
name|adv
argument_list|,
comment|/*initiate_reset*/
name|FALSE
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|chipstat
operator|&
name|ADV_CSW_INT_PENDING
operator|)
operator|!=
literal|0
condition|)
block|{
name|saved_ram_addr
operator|=
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_ADDR
argument_list|)
expr_stmt|;
name|host_flag
operator|=
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_HOST_FLAG_B
argument_list|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_HOST_FLAG_B
argument_list|,
name|host_flag
operator||
name|ADV_HOST_FLAG_IN_ISR
argument_list|)
expr_stmt|;
name|adv_ack_interrupt
argument_list|(
name|adv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chipstat
operator|&
name|ADV_CSW_HALTED
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ctrl_reg
operator|&
name|ADV_CC_SINGLE_STEP
operator|)
operator|!=
literal|0
condition|)
block|{
name|adv_isr_chip_halted
argument_list|(
name|adv
argument_list|)
expr_stmt|;
name|saved_ctrl_reg
operator|&=
operator|~
name|ADV_CC_HALT
expr_stmt|;
block|}
else|else
block|{
name|adv_run_doneq
argument_list|(
name|adv
argument_list|)
expr_stmt|;
block|}
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_ADDR
argument_list|,
name|saved_ram_addr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_ADDR
argument_list|)
operator|!=
name|saved_ram_addr
condition|)
name|panic
argument_list|(
literal|"adv_intr: Unable to set LRAM addr"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_HOST_FLAG_B
argument_list|,
name|host_flag
argument_list|)
expr_stmt|;
block|}
name|ADV_OUTB
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_CTRL
argument_list|,
name|saved_ctrl_reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|adv_run_doneq
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|)
block|{
name|struct
name|adv_q_done_info
name|scsiq
decl_stmt|;
name|u_int
name|doneq_head
decl_stmt|;
name|u_int
name|done_qno
decl_stmt|;
name|doneq_head
operator|=
name|adv_read_lram_16
argument_list|(
name|adv
argument_list|,
name|ADVV_DONE_Q_TAIL_W
argument_list|)
operator|&
literal|0xFF
expr_stmt|;
name|done_qno
operator|=
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|ADV_QNO_TO_QADDR
argument_list|(
name|doneq_head
argument_list|)
operator|+
name|ADV_SCSIQ_B_FWD
argument_list|)
expr_stmt|;
while|while
condition|(
name|done_qno
operator|!=
name|ADV_QLINK_END
condition|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|adv_ccb_info
modifier|*
name|cinfo
decl_stmt|;
name|u_int
name|done_qaddr
decl_stmt|;
name|u_int
name|sg_queue_cnt
decl_stmt|;
name|int
name|aborted
decl_stmt|;
name|done_qaddr
operator|=
name|ADV_QNO_TO_QADDR
argument_list|(
name|done_qno
argument_list|)
expr_stmt|;
comment|/* Pull status from this request */
name|sg_queue_cnt
operator|=
name|adv_copy_lram_doneq
argument_list|(
name|adv
argument_list|,
name|done_qaddr
argument_list|,
operator|&
name|scsiq
argument_list|,
name|adv
operator|->
name|max_dma_count
argument_list|)
expr_stmt|;
comment|/* Mark it as free */
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|done_qaddr
operator|+
name|ADV_SCSIQ_B_STATUS
argument_list|,
name|scsiq
operator|.
name|q_status
operator|&
operator|~
operator|(
name|QS_READY
operator||
name|QS_ABORTED
operator|)
argument_list|)
expr_stmt|;
comment|/* Process request based on retrieved info */
if|if
condition|(
operator|(
name|scsiq
operator|.
name|cntl
operator|&
name|QC_SG_HEAD
operator|)
operator|!=
literal|0
condition|)
block|{
name|u_int
name|i
decl_stmt|;
comment|/* 			 * S/G based request.  Free all of the queue 			 * structures that contained S/G information. 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sg_queue_cnt
condition|;
name|i
operator|++
control|)
block|{
name|done_qno
operator|=
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|done_qaddr
operator|+
name|ADV_SCSIQ_B_FWD
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|done_qno
operator|==
name|ADV_QLINK_END
condition|)
block|{
name|panic
argument_list|(
literal|"adv_qdone: Corrupted SG "
literal|"list encountered"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|done_qaddr
operator|=
name|ADV_QNO_TO_QADDR
argument_list|(
name|done_qno
argument_list|)
expr_stmt|;
comment|/* Mark SG queue as free */
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|done_qaddr
operator|+
name|ADV_SCSIQ_B_STATUS
argument_list|,
name|QS_FREE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|sg_queue_cnt
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|adv
operator|->
name|cur_active
operator|<
operator|(
name|sg_queue_cnt
operator|+
literal|1
operator|)
condition|)
name|panic
argument_list|(
literal|"adv_qdone: Attempting to free more "
literal|"queues than are active"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|adv
operator|->
name|cur_active
operator|-=
name|sg_queue_cnt
operator|+
literal|1
expr_stmt|;
name|aborted
operator|=
operator|(
name|scsiq
operator|.
name|q_status
operator|&
name|QS_ABORTED
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|scsiq
operator|.
name|q_status
operator|!=
name|QS_DONE
operator|)
operator|&&
operator|(
name|scsiq
operator|.
name|q_status
operator|&
name|QS_ABORTED
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"adv_qdone: completed scsiq with unknown status"
argument_list|)
expr_stmt|;
name|scsiq
operator|.
name|remain_bytes
operator|+=
name|scsiq
operator|.
name|extra_bytes
expr_stmt|;
if|if
condition|(
operator|(
name|scsiq
operator|.
name|d3
operator|.
name|done_stat
operator|==
name|QD_WITH_ERROR
operator|)
operator|&&
operator|(
name|scsiq
operator|.
name|d3
operator|.
name|host_stat
operator|==
name|QHSTA_M_DATA_OVER_RUN
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|scsiq
operator|.
name|cntl
operator|&
operator|(
name|QC_DATA_IN
operator||
name|QC_DATA_OUT
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|scsiq
operator|.
name|d3
operator|.
name|done_stat
operator|=
name|QD_NO_ERROR
expr_stmt|;
name|scsiq
operator|.
name|d3
operator|.
name|host_stat
operator|=
name|QHSTA_NO_ERROR
expr_stmt|;
block|}
block|}
name|cinfo
operator|=
operator|&
name|adv
operator|->
name|ccb_infos
index|[
name|scsiq
operator|.
name|d2
operator|.
name|ccb_index
index|]
expr_stmt|;
name|ccb
operator|=
name|cinfo
operator|->
name|ccb
expr_stmt|;
name|ccb
operator|->
name|csio
operator|.
name|resid
operator|=
name|scsiq
operator|.
name|remain_bytes
expr_stmt|;
name|adv_done
argument_list|(
name|adv
argument_list|,
name|ccb
argument_list|,
name|scsiq
operator|.
name|d3
operator|.
name|done_stat
argument_list|,
name|scsiq
operator|.
name|d3
operator|.
name|host_stat
argument_list|,
name|scsiq
operator|.
name|d3
operator|.
name|scsi_stat
argument_list|,
name|scsiq
operator|.
name|q_no
argument_list|)
expr_stmt|;
name|doneq_head
operator|=
name|done_qno
expr_stmt|;
name|done_qno
operator|=
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|done_qaddr
operator|+
name|ADV_SCSIQ_B_FWD
argument_list|)
expr_stmt|;
block|}
name|adv_write_lram_16
argument_list|(
name|adv
argument_list|,
name|ADVV_DONE_Q_TAIL_W
argument_list|,
name|doneq_head
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|adv_done
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|u_int
name|done_stat
parameter_list|,
name|u_int
name|host_stat
parameter_list|,
name|u_int
name|scsi_status
parameter_list|,
name|u_int
name|q_no
parameter_list|)
block|{
name|struct
name|adv_ccb_info
modifier|*
name|cinfo
decl_stmt|;
name|cinfo
operator|=
operator|(
expr|struct
name|adv_ccb_info
operator|*
operator|)
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_cinfo_ptr
expr_stmt|;
name|LIST_REMOVE
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|le
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|adv_timeout
argument_list|,
name|ccb
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
name|bus_dmasync_op_t
name|op
decl_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
name|op
operator|=
name|BUS_DMASYNC_POSTREAD
expr_stmt|;
else|else
name|op
operator|=
name|BUS_DMASYNC_POSTWRITE
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|adv
operator|->
name|buffer_dmat
argument_list|,
name|cinfo
operator|->
name|dmamap
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|adv
operator|->
name|buffer_dmat
argument_list|,
name|cinfo
operator|->
name|dmamap
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|done_stat
condition|)
block|{
case|case
name|QD_NO_ERROR
case|:
if|if
condition|(
name|host_stat
operator|==
name|QHSTA_NO_ERROR
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"adv_done - queue done without error, "
literal|"but host status non-zero(%x)\n"
argument_list|,
name|host_stat
argument_list|)
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
name|QD_WITH_ERROR
case|:
switch|switch
condition|(
name|host_stat
condition|)
block|{
case|case
name|QHSTA_M_TARGET_STATUS_BUSY
case|:
case|case
name|QHSTA_M_BAD_QUEUE_FULL_OR_BUSY
case|:
comment|/* 			 * Assume that if we were a tagged transaction 			 * the target reported queue full.  Otherwise, 			 * report busy.  The firmware really should just 			 * pass the original status back up to us even 			 * if it thinks the target was in error for 			 * returning this status as no other transactions 			 * from this initiator are in effect, but this 			 * ignores multi-initiator setups and there is 			 * evidence that the firmware gets its per-device 			 * transaction counts screwed up occassionally. 			 */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SCSI_STATUS_ERROR
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_TAG_ACTION_VALID
operator|)
operator|!=
literal|0
operator|&&
name|host_stat
operator|!=
name|QHSTA_M_TARGET_STATUS_BUSY
condition|)
name|scsi_status
operator|=
name|SCSI_STATUS_QUEUE_FULL
expr_stmt|;
else|else
name|scsi_status
operator|=
name|SCSI_STATUS_BUSY
expr_stmt|;
name|adv_abort_ccb
argument_list|(
name|adv
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|,
comment|/*ccb*/
name|NULL
argument_list|,
name|CAM_REQUEUE_REQ
argument_list|,
comment|/*queued_only*/
name|TRUE
argument_list|)
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
name|QHSTA_M_NO_AUTO_REQ_SENSE
case|:
case|case
name|QHSTA_NO_ERROR
case|:
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|scsi_status
expr_stmt|;
switch|switch
condition|(
name|scsi_status
condition|)
block|{
case|case
name|SCSI_STATUS_CHECK_COND
case|:
case|case
name|SCSI_STATUS_CMD_TERMINATED
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_AUTOSNS_VALID
expr_stmt|;
comment|/* Structure copy */
name|ccb
operator|->
name|csio
operator|.
name|sense_data
operator|=
name|adv
operator|->
name|sense_buffers
index|[
name|q_no
operator|-
literal|1
index|]
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|SCSI_STATUS_BUSY
case|:
case|case
name|SCSI_STATUS_RESERV_CONFLICT
case|:
case|case
name|SCSI_STATUS_QUEUE_FULL
case|:
case|case
name|SCSI_STATUS_COND_MET
case|:
case|case
name|SCSI_STATUS_INTERMED
case|:
case|case
name|SCSI_STATUS_INTERMED_COND_MET
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SCSI_STATUS_ERROR
expr_stmt|;
break|break;
case|case
name|SCSI_STATUS_OK
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|QHSTA_M_SEL_TIMEOUT
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SEL_TIMEOUT
expr_stmt|;
break|break;
case|case
name|QHSTA_M_DATA_OVER_RUN
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_DATA_RUN_ERR
expr_stmt|;
break|break;
case|case
name|QHSTA_M_UNEXPECTED_BUS_FREE
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_UNEXP_BUSFREE
expr_stmt|;
break|break;
case|case
name|QHSTA_M_BAD_BUS_PHASE_SEQ
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SEQUENCE_FAIL
expr_stmt|;
break|break;
case|case
name|QHSTA_M_BAD_CMPL_STATUS_IN
case|:
comment|/* No command complete after a status message */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SEQUENCE_FAIL
expr_stmt|;
break|break;
case|case
name|QHSTA_D_EXE_SCSI_Q_BUSY_TIMEOUT
case|:
case|case
name|QHSTA_M_WTM_TIMEOUT
case|:
case|case
name|QHSTA_M_HUNG_REQ_SCSI_BUS_RESET
case|:
comment|/* The SCSI bus hung in a phase */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SEQUENCE_FAIL
expr_stmt|;
name|adv_reset_bus
argument_list|(
name|adv
argument_list|,
comment|/*initiate_reset*/
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|QHSTA_M_AUTO_REQ_SENSE_FAIL
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_AUTOSENSE_FAIL
expr_stmt|;
break|break;
case|case
name|QHSTA_D_QDONE_SG_LIST_CORRUPTED
case|:
case|case
name|QHSTA_D_ASC_DVC_ERROR_CODE_SET
case|:
case|case
name|QHSTA_D_HOST_ABORT_FAILED
case|:
case|case
name|QHSTA_D_EXE_SCSI_Q_FAILED
case|:
case|case
name|QHSTA_D_ASPI_NO_BUF_POOL
case|:
case|case
name|QHSTA_M_BAD_TAG_CODE
case|:
case|case
name|QHSTA_D_LRAM_CMP_ERROR
case|:
case|case
name|QHSTA_M_MICRO_CODE_ERROR_HALT
case|:
default|default:
name|panic
argument_list|(
literal|"%s: Unhandled Host status error %x"
argument_list|,
name|adv_name
argument_list|(
name|adv
argument_list|)
argument_list|,
name|host_stat
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
break|break;
case|case
name|QD_ABORTED_BY_HOST
case|:
comment|/* Don't clobber any, more explicit, error codes we've set */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_INPROG
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_ABORTED
expr_stmt|;
break|break;
default|default:
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"adv_done - queue done with unknown status %x:%x\n"
argument_list|,
name|done_stat
argument_list|,
name|host_stat
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
break|break;
block|}
name|adv_clear_state
argument_list|(
name|adv
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
operator|&&
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
operator|==
literal|0
condition|)
block|{
name|xpt_freeze_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_QFRZN
expr_stmt|;
block|}
name|adv_free_ccb_info
argument_list|(
name|adv
argument_list|,
name|cinfo
argument_list|)
expr_stmt|;
comment|/* 	 * Null this out so that we catch driver bugs that cause a 	 * ccb to be completed twice. 	 */
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_cinfo_ptr
operator|=
name|NULL
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function to poll for command completion when  * interrupts are disabled (crash dumps)  */
end_comment

begin_function
specifier|static
name|void
name|adv_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
name|adv_intr
argument_list|(
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Attach all the sub-devices we can find  */
end_comment

begin_function
name|int
name|adv_attach
parameter_list|(
name|adv
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
block|{
name|struct
name|ccb_setasync
name|csa
decl_stmt|;
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|int
name|max_sg
decl_stmt|;
comment|/* 	 * Allocate an array of ccb mapping structures.  We put the 	 * index of the ccb_info structure into the queue representing 	 * a transaction and use it for mapping the queue to the 	 * upper level SCSI transaction it represents. 	 */
name|adv
operator|->
name|ccb_infos
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|adv
operator|->
name|ccb_infos
argument_list|)
operator|*
name|adv
operator|->
name|max_openings
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|adv
operator|->
name|ccb_infos
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|adv
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* 	 * Create our DMA tags.  These tags define the kinds of device 	 * accessible memory allocations and memory mappings we will  	 * need to perform during normal operation. 	 * 	 * Unless we need to further restrict the allocation, we rely 	 * on the restrictions of the parent dmat, hence the common 	 * use of MAXADDR and MAXSIZE. 	 * 	 * The ASC boards use chains of "queues" (the transactional 	 * resources on the board) to represent long S/G lists. 	 * The first queue represents the command and holds a 	 * single address and data pair.  The queues that follow 	 * can each hold ADV_SG_LIST_PER_Q entries.  Given the 	 * total number of queues, we can express the largest 	 * transaction we can map.  We reserve a few queues for 	 * error recovery.  Take those into account as well. 	 * 	 * There is a way to take an interrupt to download the 	 * next batch of S/G entries if there are more than 255 	 * of them (the counter in the queue structure is a u_int8_t). 	 * We don't use this feature, so limit the S/G list size 	 * accordingly. 	 */
name|max_sg
operator|=
operator|(
name|adv
operator|->
name|max_openings
operator|-
name|ADV_MIN_FREE_Q
operator|-
literal|1
operator|)
operator|*
name|ADV_SG_LIST_PER_Q
expr_stmt|;
if|if
condition|(
name|max_sg
operator|>
literal|255
condition|)
name|max_sg
operator|=
literal|255
expr_stmt|;
comment|/* DMA tag for mapping buffers into device visible space. */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/* parent	*/
name|adv
operator|->
name|parent_dmat
argument_list|,
comment|/* alignment	*/
literal|1
argument_list|,
comment|/* boundary	*/
literal|0
argument_list|,
comment|/* lowaddr	*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr	*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* filter	*/
name|NULL
argument_list|,
comment|/* filterarg	*/
name|NULL
argument_list|,
comment|/* maxsize	*/
name|MAXPHYS
argument_list|,
comment|/* nsegments	*/
name|max_sg
argument_list|,
comment|/* maxsegsz	*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* flags	*/
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* lockfunc	*/
name|busdma_lock_mutex
argument_list|,
comment|/* lockarg	*/
operator|&
name|Giant
argument_list|,
operator|&
name|adv
operator|->
name|buffer_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|adv
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* DMA tag for our sense buffers */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/* parent	*/
name|adv
operator|->
name|parent_dmat
argument_list|,
comment|/* alignment	*/
literal|1
argument_list|,
comment|/* boundary	*/
literal|0
argument_list|,
comment|/* lowaddr	*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr	*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* filter	*/
name|NULL
argument_list|,
comment|/* filterarg	*/
name|NULL
argument_list|,
comment|/* maxsize	*/
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
operator|*
name|adv
operator|->
name|max_openings
argument_list|,
comment|/* nsegments	*/
literal|1
argument_list|,
comment|/* maxsegsz	*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* flags	*/
literal|0
argument_list|,
comment|/* lockfunc	*/
name|busdma_lock_mutex
argument_list|,
comment|/* lockarg	*/
operator|&
name|Giant
argument_list|,
operator|&
name|adv
operator|->
name|sense_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|adv
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* Allocation for our sense buffers */
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|adv
operator|->
name|sense_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|adv
operator|->
name|sense_buffers
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|adv
operator|->
name|sense_dmamap
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|adv
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* And permanently map them */
name|bus_dmamap_load
argument_list|(
name|adv
operator|->
name|sense_dmat
argument_list|,
name|adv
operator|->
name|sense_dmamap
argument_list|,
name|adv
operator|->
name|sense_buffers
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
operator|*
name|adv
operator|->
name|max_openings
argument_list|,
name|adv_map
argument_list|,
operator|&
name|adv
operator|->
name|sense_physbase
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
name|adv
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* 	 * Fire up the chip 	 */
if|if
condition|(
name|adv_start_chip
argument_list|(
name|adv
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"adv%d: Unable to start on board processor. Aborting.\n"
argument_list|,
name|adv
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * Create the device queue for our SIM. 	 */
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
name|adv
operator|->
name|max_openings
argument_list|)
expr_stmt|;
if|if
condition|(
name|devq
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* 	 * Construct our SIM entry. 	 */
name|adv
operator|->
name|sim
operator|=
name|cam_sim_alloc
argument_list|(
name|adv_action
argument_list|,
name|adv_poll
argument_list|,
literal|"adv"
argument_list|,
name|adv
argument_list|,
name|adv
operator|->
name|unit
argument_list|,
literal|1
argument_list|,
name|adv
operator|->
name|max_openings
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|adv
operator|->
name|sim
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* 	 * Register the bus. 	 * 	 * XXX Twin Channel EISA Cards??? 	 */
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|adv
operator|->
name|sim
argument_list|,
literal|0
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|cam_sim_free
argument_list|(
name|adv
operator|->
name|sim
argument_list|,
comment|/*free devq*/
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|adv
operator|->
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|adv
operator|->
name|sim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|adv
operator|->
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|adv
operator|->
name|sim
argument_list|,
comment|/*free devq*/
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|xpt_setup_ccb
argument_list|(
operator|&
name|csa
operator|.
name|ccb_h
argument_list|,
name|adv
operator|->
name|path
argument_list|,
comment|/*priority*/
literal|5
argument_list|)
expr_stmt|;
name|csa
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|csa
operator|.
name|event_enable
operator|=
name|AC_FOUND_DEVICE
operator||
name|AC_LOST_DEVICE
expr_stmt|;
name|csa
operator|.
name|callback
operator|=
name|advasync
expr_stmt|;
name|csa
operator|.
name|callback_arg
operator|=
name|adv
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|csa
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|adv
argument_list|,
name|cam
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

