begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Low level routines for the Advanced Systems Inc. SCSI controllers chips  *  * Copyright (c) 1996-1997, 1999-2000 Justin Gibbs.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * Ported from:  * advansys.c - Linux Host Driver for AdvanSys SCSI Adapters  *       * Copyright (c) 1995-1996 Advanced System Products, Inc.  * All Rights Reserved.  *     * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that redistributions of source  * code retain the above copyright notice and this comment without  * modification.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus_pio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_da.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_cd.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/advansys/advansys.h>
end_include

begin_include
include|#
directive|include
file|<dev/advansys/advmcode.h>
end_include

begin_struct
struct|struct
name|adv_quirk_entry
block|{
name|struct
name|scsi_inquiry_pattern
name|inq_pat
decl_stmt|;
name|u_int8_t
name|quirks
decl_stmt|;
define|#
directive|define
name|ADV_QUIRK_FIX_ASYN_XFER_ALWAYS
value|0x01
define|#
directive|define
name|ADV_QUIRK_FIX_ASYN_XFER
value|0x02
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|adv_quirk_entry
name|adv_quirk_table
index|[]
init|=
block|{
block|{
block|{
name|T_CDROM
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"HP"
block|,
literal|"*"
block|,
literal|"*"
block|}
block|,
name|ADV_QUIRK_FIX_ASYN_XFER_ALWAYS
operator||
name|ADV_QUIRK_FIX_ASYN_XFER
block|}
block|,
block|{
block|{
name|T_CDROM
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"NEC"
block|,
literal|"CD-ROM DRIVE"
block|,
literal|"*"
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"TANDBERG"
block|,
literal|" TDC 36"
block|,
literal|"*"
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
name|T_SEQUENTIAL
block|,
name|SIP_MEDIA_REMOVABLE
block|,
literal|"WANGTEK"
block|,
literal|"*"
block|,
literal|"*"
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
name|T_PROCESSOR
block|,
name|SIP_MEDIA_REMOVABLE
operator||
name|SIP_MEDIA_FIXED
block|,
literal|"*"
block|,
literal|"*"
block|,
literal|"*"
block|}
block|,
literal|0
block|}
block|,
block|{
block|{
name|T_SCANNER
block|,
name|SIP_MEDIA_REMOVABLE
operator||
name|SIP_MEDIA_FIXED
block|,
literal|"*"
block|,
literal|"*"
block|,
literal|"*"
block|}
block|,
literal|0
block|}
block|,
block|{
comment|/* Default quirk entry */
block|{
name|T_ANY
block|,
name|SIP_MEDIA_REMOVABLE
operator||
name|SIP_MEDIA_FIXED
block|,
comment|/*vendor*/
literal|"*"
block|,
comment|/*product*/
literal|"*"
block|,
comment|/*revision*/
literal|"*"
block|}
block|,
name|ADV_QUIRK_FIX_ASYN_XFER
block|, 	}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Allowable periods in ns  */
end_comment

begin_decl_stmt
specifier|static
name|u_int8_t
name|adv_sdtr_period_tbl
index|[]
init|=
block|{
literal|25
block|,
literal|30
block|,
literal|35
block|,
literal|40
block|,
literal|50
block|,
literal|60
block|,
literal|70
block|,
literal|85
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int8_t
name|adv_sdtr_period_tbl_ultra
index|[]
init|=
block|{
literal|12
block|,
literal|19
block|,
literal|25
block|,
literal|32
block|,
literal|38
block|,
literal|44
block|,
literal|50
block|,
literal|57
block|,
literal|63
block|,
literal|69
block|,
literal|75
block|,
literal|82
block|,
literal|88
block|,
literal|94
block|,
literal|100
block|,
literal|107
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|ext_msg
block|{
name|u_int8_t
name|msg_type
decl_stmt|;
name|u_int8_t
name|msg_len
decl_stmt|;
name|u_int8_t
name|msg_req
decl_stmt|;
union|union
block|{
struct|struct
block|{
name|u_int8_t
name|sdtr_xfer_period
decl_stmt|;
name|u_int8_t
name|sdtr_req_ack_offset
decl_stmt|;
block|}
name|sdtr
struct|;
struct|struct
block|{
name|u_int8_t
name|wdtr_width
decl_stmt|;
block|}
name|wdtr
struct|;
struct|struct
block|{
name|u_int8_t
name|mdp
index|[
literal|4
index|]
decl_stmt|;
block|}
name|mdp
struct|;
block|}
name|u_ext_msg
union|;
name|u_int8_t
name|res
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|xfer_period
value|u_ext_msg.sdtr.sdtr_xfer_period
end_define

begin_define
define|#
directive|define
name|req_ack_offset
value|u_ext_msg.sdtr.sdtr_req_ack_offset
end_define

begin_define
define|#
directive|define
name|wdtr_width
value|u_ext_msg.wdtr.wdtr_width
end_define

begin_define
define|#
directive|define
name|mdp_b3
value|u_ext_msg.mdp_b3
end_define

begin_define
define|#
directive|define
name|mdp_b2
value|u_ext_msg.mdp_b2
end_define

begin_define
define|#
directive|define
name|mdp_b1
value|u_ext_msg.mdp_b1
end_define

begin_define
define|#
directive|define
name|mdp_b0
value|u_ext_msg.mdp_b0
end_define

begin_comment
comment|/*  * Some of the early PCI adapters have problems with  * async transfers.  Instead use an offset of 1.  */
end_comment

begin_define
define|#
directive|define
name|ASYN_SDTR_DATA_FIX_PCI_REV_AB
value|0x41
end_define

begin_comment
comment|/* LRAM routines */
end_comment

begin_function_decl
specifier|static
name|void
name|adv_read_lram_16_multi
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int16_t
name|s_addr
parameter_list|,
name|u_int16_t
modifier|*
name|buffer
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|adv_write_lram_16_multi
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int16_t
name|s_addr
parameter_list|,
name|u_int16_t
modifier|*
name|buffer
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|adv_mset_lram_16
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int16_t
name|s_addr
parameter_list|,
name|u_int16_t
name|set_value
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|adv_msum_lram_16
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int16_t
name|s_addr
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|adv_write_and_verify_lram_16
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int16_t
name|addr
parameter_list|,
name|u_int16_t
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|adv_read_lram_32
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int16_t
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|adv_write_lram_32
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int16_t
name|addr
parameter_list|,
name|u_int32_t
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|adv_write_lram_32_multi
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int16_t
name|s_addr
parameter_list|,
name|u_int32_t
modifier|*
name|buffer
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* EEPROM routines */
end_comment

begin_function_decl
specifier|static
name|u_int16_t
name|adv_read_eeprom_16
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int8_t
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int16_t
name|adv_write_eeprom_16
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int8_t
name|addr
parameter_list|,
name|u_int16_t
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|adv_write_eeprom_cmd_reg
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int8_t
name|cmd_reg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|adv_set_eeprom_config_once
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|struct
name|adv_eeprom_config
modifier|*
name|eeconfig
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Initialization */
end_comment

begin_function_decl
specifier|static
name|u_int32_t
name|adv_load_microcode
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int16_t
name|s_addr
parameter_list|,
name|u_int16_t
modifier|*
name|mcode_buf
parameter_list|,
name|u_int16_t
name|mcode_size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|adv_reinit_lram
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|adv_init_lram
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|adv_init_microcode_var
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|adv_init_qlink_var
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Interrupts */
end_comment

begin_function_decl
specifier|static
name|void
name|adv_disable_interrupt
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|adv_enable_interrupt
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|adv_toggle_irq_act
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Chip Control */
end_comment

begin_function_decl
specifier|static
name|int
name|adv_host_req_chip_halt
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|adv_set_chip_ih
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int16_t
name|ins_code
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|UNUSED
end_if

begin_function_decl
specifier|static
name|u_int8_t
name|adv_get_chip_scsi_ctrl
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Queue handling and execution */
end_comment

begin_function_decl
specifier|static
name|__inline
name|int
name|adv_sgcount_to_qcount
parameter_list|(
name|int
name|sgcount
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|__inline
name|int
name|adv_sgcount_to_qcount
parameter_list|(
name|int
name|sgcount
parameter_list|)
block|{
name|int
name|n_sg_list_qs
decl_stmt|;
name|n_sg_list_qs
operator|=
operator|(
operator|(
name|sgcount
operator|-
literal|1
operator|)
operator|/
name|ADV_SG_LIST_PER_Q
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|sgcount
operator|-
literal|1
operator|)
operator|%
name|ADV_SG_LIST_PER_Q
operator|)
operator|!=
literal|0
condition|)
name|n_sg_list_qs
operator|++
expr_stmt|;
return|return
operator|(
name|n_sg_list_qs
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|adv_adj_endian_qdone_info
parameter_list|(
name|struct
name|adv_q_done_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|adv_adj_scsiq_endian
parameter_list|(
name|struct
name|adv_scsi_q
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|adv_get_q_info
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int16_t
name|s_addr
parameter_list|,
name|u_int16_t
modifier|*
name|inbuf
parameter_list|,
name|int
name|words
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|adv_get_num_free_queues
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int8_t
name|n_qs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int8_t
name|adv_alloc_free_queues
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int8_t
name|free_q_head
parameter_list|,
name|u_int8_t
name|n_free_q
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int8_t
name|adv_alloc_free_queue
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int8_t
name|free_q_head
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|adv_send_scsi_queue
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|struct
name|adv_scsi_q
modifier|*
name|scsiq
parameter_list|,
name|u_int8_t
name|n_q_required
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|adv_put_ready_sg_list_queue
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|struct
name|adv_scsi_q
modifier|*
name|scsiq
parameter_list|,
name|u_int
name|q_no
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|adv_put_ready_queue
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|struct
name|adv_scsi_q
modifier|*
name|scsiq
parameter_list|,
name|u_int
name|q_no
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|adv_put_scsiq
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int16_t
name|s_addr
parameter_list|,
name|u_int16_t
modifier|*
name|buffer
parameter_list|,
name|int
name|words
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Messages */
end_comment

begin_function_decl
specifier|static
name|void
name|adv_handle_extmsg_in
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int16_t
name|halt_q_addr
parameter_list|,
name|u_int8_t
name|q_cntl
parameter_list|,
name|target_bit_vector
name|target_id
parameter_list|,
name|int
name|tid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|adv_msgout_sdtr
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int8_t
name|sdtr_period
parameter_list|,
name|u_int8_t
name|sdtr_offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|adv_set_sdtr_reg_at_id
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|int
name|id
parameter_list|,
name|u_int8_t
name|sdtr_data
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Exported functions first */
end_comment

begin_function
name|void
name|advasync
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|u_int32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|adv
operator|=
operator|(
expr|struct
name|adv_softc
operator|*
operator|)
name|callback_arg
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|AC_FOUND_DEVICE
case|:
block|{
name|struct
name|ccb_getdev
modifier|*
name|cgd
decl_stmt|;
name|target_bit_vector
name|target_mask
decl_stmt|;
name|int
name|num_entries
decl_stmt|;
name|caddr_t
name|match
decl_stmt|;
name|struct
name|adv_quirk_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|adv_target_transinfo
modifier|*
name|tinfo
decl_stmt|;
name|cgd
operator|=
operator|(
expr|struct
name|ccb_getdev
operator|*
operator|)
name|arg
expr_stmt|;
name|target_mask
operator|=
name|ADV_TID_TO_TARGET_MASK
argument_list|(
name|cgd
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|)
expr_stmt|;
name|num_entries
operator|=
sizeof|sizeof
argument_list|(
name|adv_quirk_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|adv_quirk_table
argument_list|)
expr_stmt|;
name|match
operator|=
name|cam_quirkmatch
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|cgd
operator|->
name|inq_data
argument_list|,
operator|(
name|caddr_t
operator|)
name|adv_quirk_table
argument_list|,
name|num_entries
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|adv_quirk_table
argument_list|)
argument_list|,
name|scsi_inquiry_match
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"advasync: device didn't match wildcard entry!!"
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|(
expr|struct
name|adv_quirk_entry
operator|*
operator|)
name|match
expr_stmt|;
if|if
condition|(
name|adv
operator|->
name|bug_fix_control
operator|&
name|ADV_BUG_FIX_ASYN_USE_SYN
condition|)
block|{
if|if
condition|(
operator|(
name|entry
operator|->
name|quirks
operator|&
name|ADV_QUIRK_FIX_ASYN_XFER_ALWAYS
operator|)
operator|!=
literal|0
condition|)
name|adv
operator|->
name|fix_asyn_xfer_always
operator||=
name|target_mask
expr_stmt|;
else|else
name|adv
operator|->
name|fix_asyn_xfer_always
operator|&=
operator|~
name|target_mask
expr_stmt|;
comment|/* 			 * We start out life with all bits set and clear them 			 * after we've determined that the fix isn't necessary. 			 * It may well be that we've already cleared a target 			 * before the full inquiry session completes, so don't 			 * gratuitously set a target bit even if it has this 			 * quirk.  But, if the quirk exonerates a device, clear 			 * the bit now. 			 */
if|if
condition|(
operator|(
name|entry
operator|->
name|quirks
operator|&
name|ADV_QUIRK_FIX_ASYN_XFER
operator|)
operator|==
literal|0
condition|)
name|adv
operator|->
name|fix_asyn_xfer
operator|&=
operator|~
name|target_mask
expr_stmt|;
block|}
comment|/* 		 * Reset our sync settings now that we've determined 		 * what quirks are in effect for the device. 		 */
name|tinfo
operator|=
operator|&
name|adv
operator|->
name|tinfo
index|[
name|cgd
operator|->
name|ccb_h
operator|.
name|target_id
index|]
expr_stmt|;
name|adv_set_syncrate
argument_list|(
name|adv
argument_list|,
name|cgd
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|cgd
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|tinfo
operator|->
name|current
operator|.
name|period
argument_list|,
name|tinfo
operator|->
name|current
operator|.
name|offset
argument_list|,
name|ADV_TRANS_CUR
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|AC_LOST_DEVICE
case|:
block|{
name|u_int
name|target_mask
decl_stmt|;
if|if
condition|(
name|adv
operator|->
name|bug_fix_control
operator|&
name|ADV_BUG_FIX_ASYN_USE_SYN
condition|)
block|{
name|target_mask
operator|=
literal|0x01
operator|<<
name|xpt_path_target_id
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|adv
operator|->
name|fix_asyn_xfer
operator||=
name|target_mask
expr_stmt|;
block|}
comment|/* 		 * Revert to async transfers 		 * for the next device. 		 */
name|adv_set_syncrate
argument_list|(
name|adv
argument_list|,
comment|/*path*/
name|NULL
argument_list|,
name|xpt_path_target_id
argument_list|(
name|path
argument_list|)
argument_list|,
comment|/*period*/
literal|0
argument_list|,
comment|/*offset*/
literal|0
argument_list|,
name|ADV_TRANS_GOAL
operator||
name|ADV_TRANS_CUR
argument_list|)
expr_stmt|;
block|}
default|default:
break|break;
block|}
block|}
end_function

begin_function
name|void
name|adv_set_bank
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int8_t
name|bank
parameter_list|)
block|{
name|u_int8_t
name|control
decl_stmt|;
comment|/* 	 * Start out with the bank reset to 0 	 */
name|control
operator|=
name|ADV_INB
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_CTRL
argument_list|)
operator|&
operator|(
operator|~
operator|(
name|ADV_CC_SINGLE_STEP
operator||
name|ADV_CC_TEST
operator||
name|ADV_CC_DIAG
operator||
name|ADV_CC_SCSI_RESET
operator||
name|ADV_CC_CHIP_RESET
operator||
name|ADV_CC_BANK_ONE
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|bank
operator|==
literal|1
condition|)
block|{
name|control
operator||=
name|ADV_CC_BANK_ONE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bank
operator|==
literal|2
condition|)
block|{
name|control
operator||=
name|ADV_CC_DIAG
operator||
name|ADV_CC_BANK_ONE
expr_stmt|;
block|}
name|ADV_OUTB
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_CTRL
argument_list|,
name|control
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|u_int8_t
name|adv_read_lram_8
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int16_t
name|addr
parameter_list|)
block|{
name|u_int8_t
name|byte_data
decl_stmt|;
name|u_int16_t
name|word_data
decl_stmt|;
comment|/* 	 * LRAM is accessed on 16bit boundaries. 	 */
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_ADDR
argument_list|,
name|addr
operator|&
literal|0xFFFE
argument_list|)
expr_stmt|;
name|word_data
operator|=
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|&
literal|1
condition|)
block|{
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
name|byte_data
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
name|word_data
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
else|#
directive|else
name|byte_data
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|word_data
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
name|byte_data
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|word_data
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
else|#
directive|else
name|byte_data
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
name|word_data
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
name|byte_data
operator|)
return|;
block|}
end_function

begin_function
name|void
name|adv_write_lram_8
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int16_t
name|addr
parameter_list|,
name|u_int8_t
name|value
parameter_list|)
block|{
name|u_int16_t
name|word_data
decl_stmt|;
name|word_data
operator|=
name|adv_read_lram_16
argument_list|(
name|adv
argument_list|,
name|addr
operator|&
literal|0xFFFE
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|&
literal|1
condition|)
block|{
name|word_data
operator|&=
literal|0x00FF
expr_stmt|;
name|word_data
operator||=
operator|(
operator|(
operator|(
name|u_int8_t
operator|)
name|value
operator|<<
literal|8
operator|)
operator|&
literal|0xFF00
operator|)
expr_stmt|;
block|}
else|else
block|{
name|word_data
operator|&=
literal|0xFF00
expr_stmt|;
name|word_data
operator||=
operator|(
operator|(
name|u_int8_t
operator|)
name|value
operator|&
literal|0x00FF
operator|)
expr_stmt|;
block|}
name|adv_write_lram_16
argument_list|(
name|adv
argument_list|,
name|addr
operator|&
literal|0xFFFE
argument_list|,
name|word_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|u_int16_t
name|adv_read_lram_16
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int16_t
name|addr
parameter_list|)
block|{
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
operator|(
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_DATA
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|adv_write_lram_16
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int16_t
name|addr
parameter_list|,
name|u_int16_t
name|value
parameter_list|)
block|{
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_DATA
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Determine if there is a board at "iobase" by looking  * for the AdvanSys signatures.  Return 1 if a board is  * found, 0 otherwise.  */
end_comment

begin_function
name|int
name|adv_find_signature
parameter_list|(
name|bus_space_tag_t
name|tag
parameter_list|,
name|bus_space_handle_t
name|bsh
parameter_list|)
block|{
name|u_int16_t
name|signature
decl_stmt|;
if|if
condition|(
name|bus_space_read_1
argument_list|(
name|tag
argument_list|,
name|bsh
argument_list|,
name|ADV_SIGNATURE_BYTE
argument_list|)
operator|==
name|ADV_1000_ID1B
condition|)
block|{
name|signature
operator|=
name|bus_space_read_2
argument_list|(
name|tag
argument_list|,
name|bsh
argument_list|,
name|ADV_SIGNATURE_WORD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|signature
operator|==
name|ADV_1000_ID0W
operator|)
operator|||
operator|(
name|signature
operator|==
name|ADV_1000_ID0W_FIX
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|adv_lib_init
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|)
block|{
if|if
condition|(
operator|(
name|adv
operator|->
name|type
operator|&
name|ADV_ULTRA
operator|)
operator|!=
literal|0
condition|)
block|{
name|adv
operator|->
name|sdtr_period_tbl
operator|=
name|adv_sdtr_period_tbl_ultra
expr_stmt|;
name|adv
operator|->
name|sdtr_period_tbl_size
operator|=
sizeof|sizeof
argument_list|(
name|adv_sdtr_period_tbl_ultra
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|adv
operator|->
name|sdtr_period_tbl
operator|=
name|adv_sdtr_period_tbl
expr_stmt|;
name|adv
operator|->
name|sdtr_period_tbl_size
operator|=
sizeof|sizeof
argument_list|(
name|adv_sdtr_period_tbl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|u_int16_t
name|adv_get_eeprom_config
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|struct
name|adv_eeprom_config
modifier|*
name|eeprom_config
parameter_list|)
block|{
name|u_int16_t
name|sum
decl_stmt|;
name|u_int16_t
modifier|*
name|wbuf
decl_stmt|;
name|u_int8_t
name|cfg_beg
decl_stmt|;
name|u_int8_t
name|cfg_end
decl_stmt|;
name|u_int8_t
name|s_addr
decl_stmt|;
name|wbuf
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|eeprom_config
expr_stmt|;
name|sum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|s_addr
operator|=
literal|0
init|;
name|s_addr
operator|<
literal|2
condition|;
name|s_addr
operator|++
operator|,
name|wbuf
operator|++
control|)
block|{
operator|*
name|wbuf
operator|=
name|adv_read_eeprom_16
argument_list|(
name|adv
argument_list|,
name|s_addr
argument_list|)
expr_stmt|;
name|sum
operator|+=
operator|*
name|wbuf
expr_stmt|;
block|}
if|if
condition|(
name|adv
operator|->
name|type
operator|&
name|ADV_VL
condition|)
block|{
name|cfg_beg
operator|=
name|ADV_EEPROM_CFG_BEG_VL
expr_stmt|;
name|cfg_end
operator|=
name|ADV_EEPROM_MAX_ADDR_VL
expr_stmt|;
block|}
else|else
block|{
name|cfg_beg
operator|=
name|ADV_EEPROM_CFG_BEG
expr_stmt|;
name|cfg_end
operator|=
name|ADV_EEPROM_MAX_ADDR
expr_stmt|;
block|}
for|for
control|(
name|s_addr
operator|=
name|cfg_beg
init|;
name|s_addr
operator|<=
operator|(
name|cfg_end
operator|-
literal|1
operator|)
condition|;
name|s_addr
operator|++
operator|,
name|wbuf
operator|++
control|)
block|{
operator|*
name|wbuf
operator|=
name|adv_read_eeprom_16
argument_list|(
name|adv
argument_list|,
name|s_addr
argument_list|)
expr_stmt|;
name|sum
operator|+=
operator|*
name|wbuf
expr_stmt|;
if|#
directive|if
name|ADV_DEBUG_EEPROM
name|printf
argument_list|(
literal|"Addr 0x%x: 0x%04x\n"
argument_list|,
name|s_addr
argument_list|,
operator|*
name|wbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
operator|*
name|wbuf
operator|=
name|adv_read_eeprom_16
argument_list|(
name|adv
argument_list|,
name|s_addr
argument_list|)
expr_stmt|;
return|return
operator|(
name|sum
operator|)
return|;
block|}
end_function

begin_function
name|int
name|adv_set_eeprom_config
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|struct
name|adv_eeprom_config
modifier|*
name|eeprom_config
parameter_list|)
block|{
name|int
name|retry
decl_stmt|;
name|retry
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|adv_set_eeprom_config_once
argument_list|(
name|adv
argument_list|,
name|eeprom_config
argument_list|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|++
name|retry
operator|>
name|ADV_EEPROM_MAX_RETRY
condition|)
block|{
break|break;
block|}
block|}
return|return
operator|(
name|retry
operator|>
name|ADV_EEPROM_MAX_RETRY
operator|)
return|;
block|}
end_function

begin_function
name|int
name|adv_reset_chip
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|int
name|reset_bus
parameter_list|)
block|{
name|adv_stop_chip
argument_list|(
name|adv
argument_list|)
expr_stmt|;
name|ADV_OUTB
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_CTRL
argument_list|,
name|ADV_CC_CHIP_RESET
operator||
name|ADV_CC_HALT
operator||
operator|(
name|reset_bus
condition|?
name|ADV_CC_SCSI_RESET
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|60
argument_list|)
expr_stmt|;
name|adv_set_chip_ih
argument_list|(
name|adv
argument_list|,
name|ADV_INS_RFLAG_WTM
argument_list|)
expr_stmt|;
name|adv_set_chip_ih
argument_list|(
name|adv
argument_list|,
name|ADV_INS_HALT
argument_list|)
expr_stmt|;
if|if
condition|(
name|reset_bus
condition|)
name|ADV_OUTB
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_CTRL
argument_list|,
name|ADV_CC_CHIP_RESET
operator||
name|ADV_CC_HALT
argument_list|)
expr_stmt|;
name|ADV_OUTB
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_CTRL
argument_list|,
name|ADV_CC_HALT
argument_list|)
expr_stmt|;
if|if
condition|(
name|reset_bus
condition|)
name|DELAY
argument_list|(
literal|200
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_STATUS
argument_list|,
name|ADV_CIW_CLR_SCSI_RESET_INT
argument_list|)
expr_stmt|;
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_STATUS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|adv_is_chip_halted
argument_list|(
name|adv
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|adv_test_external_lram
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|)
block|{
name|u_int16_t
name|q_addr
decl_stmt|;
name|u_int16_t
name|saved_value
decl_stmt|;
name|int
name|success
decl_stmt|;
name|success
operator|=
literal|0
expr_stmt|;
name|q_addr
operator|=
name|ADV_QNO_TO_QADDR
argument_list|(
literal|241
argument_list|)
expr_stmt|;
name|saved_value
operator|=
name|adv_read_lram_16
argument_list|(
name|adv
argument_list|,
name|q_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|adv_write_and_verify_lram_16
argument_list|(
name|adv
argument_list|,
name|q_addr
argument_list|,
literal|0x55AA
argument_list|)
operator|==
literal|0
condition|)
block|{
name|success
operator|=
literal|1
expr_stmt|;
name|adv_write_lram_16
argument_list|(
name|adv
argument_list|,
name|q_addr
argument_list|,
name|saved_value
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|success
operator|)
return|;
block|}
end_function

begin_function
name|int
name|adv_init_lram_and_mcode
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|)
block|{
name|u_int32_t
name|retval
decl_stmt|;
name|adv_disable_interrupt
argument_list|(
name|adv
argument_list|)
expr_stmt|;
name|adv_init_lram
argument_list|(
name|adv
argument_list|)
expr_stmt|;
name|retval
operator|=
name|adv_load_microcode
argument_list|(
name|adv
argument_list|,
literal|0
argument_list|,
operator|(
name|u_int16_t
operator|*
operator|)
name|adv_mcode
argument_list|,
name|adv_mcode_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|adv_mcode_chksum
condition|)
block|{
name|printf
argument_list|(
literal|"adv%d: Microcode download failed checksum!\n"
argument_list|,
name|adv
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|adv_init_microcode_var
argument_list|(
name|adv
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|adv_enable_interrupt
argument_list|(
name|adv
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|u_int8_t
name|adv_get_chip_irq
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|)
block|{
name|u_int16_t
name|cfg_lsw
decl_stmt|;
name|u_int8_t
name|chip_irq
decl_stmt|;
name|cfg_lsw
operator|=
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_CONFIG_LSW
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|adv
operator|->
name|type
operator|&
name|ADV_VL
operator|)
operator|!=
literal|0
condition|)
block|{
name|chip_irq
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
operator|(
name|cfg_lsw
operator|>>
literal|2
operator|)
operator|&
literal|0x07
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chip_irq
operator|==
literal|0
operator|)
operator|||
operator|(
name|chip_irq
operator|==
literal|4
operator|)
operator|||
operator|(
name|chip_irq
operator|==
literal|7
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|chip_irq
operator|+
operator|(
name|ADV_MIN_IRQ_NO
operator|-
literal|1
operator|)
operator|)
return|;
block|}
name|chip_irq
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
operator|(
name|cfg_lsw
operator|>>
literal|2
operator|)
operator|&
literal|0x03
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|chip_irq
operator|==
literal|3
condition|)
name|chip_irq
operator|+=
literal|2
expr_stmt|;
return|return
operator|(
name|chip_irq
operator|+
name|ADV_MIN_IRQ_NO
operator|)
return|;
block|}
end_function

begin_function
name|u_int8_t
name|adv_set_chip_irq
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int8_t
name|irq_no
parameter_list|)
block|{
name|u_int16_t
name|cfg_lsw
decl_stmt|;
if|if
condition|(
operator|(
name|adv
operator|->
name|type
operator|&
name|ADV_VL
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|irq_no
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|irq_no
operator|<
name|ADV_MIN_IRQ_NO
operator|)
operator|||
operator|(
name|irq_no
operator|>
name|ADV_MAX_IRQ_NO
operator|)
condition|)
block|{
name|irq_no
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|irq_no
operator|-=
name|ADV_MIN_IRQ_NO
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|cfg_lsw
operator|=
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_CONFIG_LSW
argument_list|)
operator|&
literal|0xFFE3
expr_stmt|;
name|cfg_lsw
operator||=
literal|0x0010
expr_stmt|;
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_CONFIG_LSW
argument_list|,
name|cfg_lsw
argument_list|)
expr_stmt|;
name|adv_toggle_irq_act
argument_list|(
name|adv
argument_list|)
expr_stmt|;
name|cfg_lsw
operator|=
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_CONFIG_LSW
argument_list|)
operator|&
literal|0xFFE0
expr_stmt|;
name|cfg_lsw
operator||=
operator|(
name|irq_no
operator|&
literal|0x07
operator|)
operator|<<
literal|2
expr_stmt|;
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_CONFIG_LSW
argument_list|,
name|cfg_lsw
argument_list|)
expr_stmt|;
name|adv_toggle_irq_act
argument_list|(
name|adv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|adv
operator|->
name|type
operator|&
name|ADV_ISA
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|irq_no
operator|==
literal|15
condition|)
name|irq_no
operator|-=
literal|2
expr_stmt|;
name|irq_no
operator|-=
name|ADV_MIN_IRQ_NO
expr_stmt|;
name|cfg_lsw
operator|=
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_CONFIG_LSW
argument_list|)
operator|&
literal|0xFFF3
expr_stmt|;
name|cfg_lsw
operator||=
operator|(
name|irq_no
operator|&
literal|0x03
operator|)
operator|<<
literal|2
expr_stmt|;
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_CONFIG_LSW
argument_list|,
name|cfg_lsw
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|adv_get_chip_irq
argument_list|(
name|adv
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|adv_set_chip_scsiid
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|int
name|new_id
parameter_list|)
block|{
name|u_int16_t
name|cfg_lsw
decl_stmt|;
name|cfg_lsw
operator|=
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_CONFIG_LSW
argument_list|)
expr_stmt|;
if|if
condition|(
name|ADV_CONFIG_SCSIID
argument_list|(
name|cfg_lsw
argument_list|)
operator|==
name|new_id
condition|)
return|return;
name|cfg_lsw
operator|&=
operator|~
name|ADV_CFG_LSW_SCSIID
expr_stmt|;
name|cfg_lsw
operator||=
operator|(
name|new_id
operator|&
name|ADV_MAX_TID
operator|)
operator|<<
name|ADV_CFG_LSW_SCSIID_SHIFT
expr_stmt|;
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_CONFIG_LSW
argument_list|,
name|cfg_lsw
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|adv_execute_scsi_queue
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|struct
name|adv_scsi_q
modifier|*
name|scsiq
parameter_list|,
name|u_int32_t
name|datalen
parameter_list|)
block|{
name|struct
name|adv_target_transinfo
modifier|*
name|tinfo
decl_stmt|;
name|u_int32_t
modifier|*
name|p_data_addr
decl_stmt|;
name|u_int32_t
modifier|*
name|p_data_bcount
decl_stmt|;
name|int
name|disable_syn_offset_one_fix
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|u_int
name|n_q_required
decl_stmt|;
name|u_int32_t
name|addr
decl_stmt|;
name|u_int8_t
name|sg_entry_cnt
decl_stmt|;
name|u_int8_t
name|target_ix
decl_stmt|;
name|u_int8_t
name|sg_entry_cnt_minus_one
decl_stmt|;
name|u_int8_t
name|tid_no
decl_stmt|;
name|scsiq
operator|->
name|q1
operator|.
name|q_no
operator|=
literal|0
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
comment|/* Default to error case */
name|target_ix
operator|=
name|scsiq
operator|->
name|q2
operator|.
name|target_ix
expr_stmt|;
name|tid_no
operator|=
name|ADV_TIX_TO_TID
argument_list|(
name|target_ix
argument_list|)
expr_stmt|;
name|tinfo
operator|=
operator|&
name|adv
operator|->
name|tinfo
index|[
name|tid_no
index|]
expr_stmt|;
if|if
condition|(
name|scsiq
operator|->
name|cdbptr
index|[
literal|0
index|]
operator|==
name|REQUEST_SENSE
condition|)
block|{
comment|/* Renegotiate if appropriate. */
name|adv_set_syncrate
argument_list|(
name|adv
argument_list|,
comment|/*struct cam_path */
name|NULL
argument_list|,
name|tid_no
argument_list|,
comment|/*period*/
literal|0
argument_list|,
comment|/*offset*/
literal|0
argument_list|,
name|ADV_TRANS_CUR
argument_list|)
expr_stmt|;
if|if
condition|(
name|tinfo
operator|->
name|current
operator|.
name|period
operator|!=
name|tinfo
operator|->
name|goal
operator|.
name|period
condition|)
block|{
name|adv_msgout_sdtr
argument_list|(
name|adv
argument_list|,
name|tinfo
operator|->
name|goal
operator|.
name|period
argument_list|,
name|tinfo
operator|->
name|goal
operator|.
name|offset
argument_list|)
expr_stmt|;
name|scsiq
operator|->
name|q1
operator|.
name|cntl
operator||=
operator|(
name|QC_MSG_OUT
operator||
name|QC_URGENT
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|scsiq
operator|->
name|q1
operator|.
name|cntl
operator|&
name|QC_SG_HEAD
operator|)
operator|!=
literal|0
condition|)
block|{
name|sg_entry_cnt
operator|=
name|scsiq
operator|->
name|sg_head
operator|->
name|entry_cnt
expr_stmt|;
name|sg_entry_cnt_minus_one
operator|=
name|sg_entry_cnt
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|sg_entry_cnt
operator|<=
literal|1
condition|)
name|panic
argument_list|(
literal|"adv_execute_scsi_queue: Queue "
literal|"with QC_SG_HEAD set but %d segs."
argument_list|,
name|sg_entry_cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sg_entry_cnt
operator|>
name|ADV_MAX_SG_LIST
condition|)
name|panic
argument_list|(
literal|"adv_execute_scsi_queue: "
literal|"Queue with too many segs."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|adv
operator|->
name|type
operator|&
operator|(
name|ADV_ISA
operator||
name|ADV_VL
operator||
name|ADV_EISA
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sg_entry_cnt_minus_one
condition|;
name|i
operator|++
control|)
block|{
name|addr
operator|=
name|scsiq
operator|->
name|sg_head
operator|->
name|sg_list
index|[
name|i
index|]
operator|.
name|addr
operator|+
name|scsiq
operator|->
name|sg_head
operator|->
name|sg_list
index|[
name|i
index|]
operator|.
name|bytes
expr_stmt|;
if|if
condition|(
operator|(
name|addr
operator|&
literal|0x0003
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"adv_execute_scsi_queue: SG "
literal|"with odd address or byte count"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|p_data_addr
operator|=
operator|&
name|scsiq
operator|->
name|sg_head
operator|->
name|sg_list
index|[
name|sg_entry_cnt_minus_one
index|]
operator|.
name|addr
expr_stmt|;
name|p_data_bcount
operator|=
operator|&
name|scsiq
operator|->
name|sg_head
operator|->
name|sg_list
index|[
name|sg_entry_cnt_minus_one
index|]
operator|.
name|bytes
expr_stmt|;
name|n_q_required
operator|=
name|adv_sgcount_to_qcount
argument_list|(
name|sg_entry_cnt
argument_list|)
expr_stmt|;
name|scsiq
operator|->
name|sg_head
operator|->
name|queue_cnt
operator|=
name|n_q_required
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|p_data_addr
operator|=
operator|&
name|scsiq
operator|->
name|q1
operator|.
name|data_addr
expr_stmt|;
name|p_data_bcount
operator|=
operator|&
name|scsiq
operator|->
name|q1
operator|.
name|data_cnt
expr_stmt|;
name|n_q_required
operator|=
literal|1
expr_stmt|;
block|}
name|disable_syn_offset_one_fix
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|adv
operator|->
name|fix_asyn_xfer
operator|&
name|scsiq
operator|->
name|q1
operator|.
name|target_id
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|adv
operator|->
name|fix_asyn_xfer_always
operator|&
name|scsiq
operator|->
name|q1
operator|.
name|target_id
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|datalen
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|datalen
operator|<
literal|512
condition|)
block|{
name|disable_syn_offset_one_fix
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|scsiq
operator|->
name|cdbptr
index|[
literal|0
index|]
operator|==
name|INQUIRY
operator|||
name|scsiq
operator|->
name|cdbptr
index|[
literal|0
index|]
operator|==
name|REQUEST_SENSE
operator|||
name|scsiq
operator|->
name|cdbptr
index|[
literal|0
index|]
operator|==
name|READ_CAPACITY
operator|||
name|scsiq
operator|->
name|cdbptr
index|[
literal|0
index|]
operator|==
name|MODE_SELECT_6
operator|||
name|scsiq
operator|->
name|cdbptr
index|[
literal|0
index|]
operator|==
name|MODE_SENSE_6
operator|||
name|scsiq
operator|->
name|cdbptr
index|[
literal|0
index|]
operator|==
name|MODE_SENSE_10
operator|||
name|scsiq
operator|->
name|cdbptr
index|[
literal|0
index|]
operator|==
name|MODE_SELECT_10
operator|||
name|scsiq
operator|->
name|cdbptr
index|[
literal|0
index|]
operator|==
name|READ_TOC
condition|)
block|{
name|disable_syn_offset_one_fix
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|disable_syn_offset_one_fix
condition|)
block|{
name|scsiq
operator|->
name|q2
operator|.
name|tag_code
operator|&=
operator|~
operator|(
name|MSG_SIMPLE_Q_TAG
operator||
name|MSG_HEAD_OF_Q_TAG
operator||
name|MSG_ORDERED_Q_TAG
operator|)
expr_stmt|;
name|scsiq
operator|->
name|q2
operator|.
name|tag_code
operator||=
operator|(
name|ADV_TAG_FLAG_DISABLE_ASYN_USE_SYN_FIX
operator||
name|ADV_TAG_FLAG_DISABLE_DISCONNECT
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|adv
operator|->
name|bug_fix_control
operator|&
name|ADV_BUG_FIX_IF_NOT_DWB
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|scsiq
operator|->
name|cdbptr
index|[
literal|0
index|]
operator|==
name|READ_10
operator|||
name|scsiq
operator|->
name|cdbptr
index|[
literal|0
index|]
operator|==
name|READ_6
operator|)
condition|)
block|{
name|u_int8_t
name|extra_bytes
decl_stmt|;
name|addr
operator|=
operator|*
name|p_data_addr
operator|+
operator|*
name|p_data_bcount
expr_stmt|;
name|extra_bytes
operator|=
name|addr
operator|&
literal|0x0003
expr_stmt|;
if|if
condition|(
name|extra_bytes
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|scsiq
operator|->
name|q1
operator|.
name|cntl
operator|&
name|QC_SG_HEAD
operator|)
operator|!=
literal|0
operator|||
operator|(
name|scsiq
operator|->
name|q1
operator|.
name|data_cnt
operator|&
literal|0x01FF
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|scsiq
operator|->
name|q2
operator|.
name|tag_code
operator||=
name|ADV_TAG_FLAG_EXTRA_BYTES
expr_stmt|;
name|scsiq
operator|->
name|q1
operator|.
name|extra_bytes
operator|=
name|extra_bytes
expr_stmt|;
operator|*
name|p_data_bcount
operator|-=
name|extra_bytes
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|adv_get_num_free_queues
argument_list|(
name|adv
argument_list|,
name|n_q_required
argument_list|)
operator|>=
name|n_q_required
operator|)
operator|||
operator|(
operator|(
name|scsiq
operator|->
name|q1
operator|.
name|cntl
operator|&
name|QC_URGENT
operator|)
operator|!=
literal|0
operator|)
condition|)
name|retval
operator|=
name|adv_send_scsi_queue
argument_list|(
name|adv
argument_list|,
name|scsiq
argument_list|,
name|n_q_required
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|u_int8_t
name|adv_copy_lram_doneq
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int16_t
name|q_addr
parameter_list|,
name|struct
name|adv_q_done_info
modifier|*
name|scsiq
parameter_list|,
name|u_int32_t
name|max_dma_count
parameter_list|)
block|{
name|u_int16_t
name|val
decl_stmt|;
name|u_int8_t
name|sg_queue_cnt
decl_stmt|;
name|adv_get_q_info
argument_list|(
name|adv
argument_list|,
name|q_addr
operator|+
name|ADV_SCSIQ_DONE_INFO_BEG
argument_list|,
operator|(
name|u_int16_t
operator|*
operator|)
name|scsiq
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|scsiq
operator|->
name|d2
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|scsiq
operator|->
name|d3
argument_list|)
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
name|adv_adj_endian_qdone_info
argument_list|(
name|scsiq
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|val
operator|=
name|adv_read_lram_16
argument_list|(
name|adv
argument_list|,
name|q_addr
operator|+
name|ADV_SCSIQ_B_STATUS
argument_list|)
expr_stmt|;
name|scsiq
operator|->
name|q_status
operator|=
name|val
operator|&
literal|0xFF
expr_stmt|;
name|scsiq
operator|->
name|q_no
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|0XFF
expr_stmt|;
name|val
operator|=
name|adv_read_lram_16
argument_list|(
name|adv
argument_list|,
name|q_addr
operator|+
name|ADV_SCSIQ_B_CNTL
argument_list|)
expr_stmt|;
name|scsiq
operator|->
name|cntl
operator|=
name|val
operator|&
literal|0xFF
expr_stmt|;
name|sg_queue_cnt
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|val
operator|=
name|adv_read_lram_16
argument_list|(
name|adv
argument_list|,
name|q_addr
operator|+
name|ADV_SCSIQ_B_SENSE_LEN
argument_list|)
expr_stmt|;
name|scsiq
operator|->
name|sense_len
operator|=
name|val
operator|&
literal|0xFF
expr_stmt|;
name|scsiq
operator|->
name|extra_bytes
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
comment|/* 	 * Due to a bug in accessing LRAM on the 940UA, the residual 	 * is split into separate high and low 16bit quantities. 	 */
name|scsiq
operator|->
name|remain_bytes
operator|=
name|adv_read_lram_16
argument_list|(
name|adv
argument_list|,
name|q_addr
operator|+
name|ADV_SCSIQ_DW_REMAIN_XFER_CNT
argument_list|)
expr_stmt|;
name|scsiq
operator|->
name|remain_bytes
operator||=
name|adv_read_lram_16
argument_list|(
name|adv
argument_list|,
name|q_addr
operator|+
name|ADV_SCSIQ_W_ALT_DC1
argument_list|)
operator|<<
literal|16
expr_stmt|;
comment|/* 	 * XXX Is this just a safeguard or will the counter really 	 * have bogus upper bits? 	 */
name|scsiq
operator|->
name|remain_bytes
operator|&=
name|max_dma_count
expr_stmt|;
return|return
operator|(
name|sg_queue_cnt
operator|)
return|;
block|}
end_function

begin_function
name|int
name|adv_start_chip
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|)
block|{
name|ADV_OUTB
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_CTRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_STATUS
argument_list|)
operator|&
name|ADV_CSW_HALTED
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|adv_stop_execution
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|)
block|{
name|int
name|count
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|ADV_STOP_CODE_B
argument_list|)
operator|==
literal|0
condition|)
block|{
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADV_STOP_CODE_B
argument_list|,
name|ADV_STOP_REQ_RISC_STOP
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|ADV_STOP_CODE_B
argument_list|)
operator|&
name|ADV_STOP_ACK_RISC_STOP
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|count
operator|++
operator|<
literal|20
condition|)
do|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|adv_is_chip_halted
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_STATUS
argument_list|)
operator|&
name|ADV_CSW_HALTED
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ADV_INB
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_CTRL
argument_list|)
operator|&
name|ADV_CC_HALT
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XXX The numeric constants and the loops in this routine  * need to be documented.  */
end_comment

begin_function
name|void
name|adv_ack_interrupt
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|)
block|{
name|u_int8_t
name|host_flag
decl_stmt|;
name|u_int8_t
name|risc_flag
decl_stmt|;
name|int
name|loop
decl_stmt|;
name|loop
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|risc_flag
operator|=
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_RISC_FLAG_B
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|++
operator|>
literal|0x7FFF
condition|)
block|{
break|break;
block|}
block|}
do|while
condition|(
operator|(
name|risc_flag
operator|&
name|ADV_RISC_FLAG_GEN_INT
operator|)
operator|!=
literal|0
condition|)
do|;
name|host_flag
operator|=
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_HOST_FLAG_B
argument_list|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_HOST_FLAG_B
argument_list|,
name|host_flag
operator||
name|ADV_HOST_FLAG_ACK_INT
argument_list|)
expr_stmt|;
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_STATUS
argument_list|,
name|ADV_CIW_INT_ACK
argument_list|)
expr_stmt|;
name|loop
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_STATUS
argument_list|)
operator|&
name|ADV_CSW_INT_PENDING
condition|)
block|{
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_STATUS
argument_list|,
name|ADV_CIW_INT_ACK
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|++
operator|>
literal|3
condition|)
block|{
break|break;
block|}
block|}
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_HOST_FLAG_B
argument_list|,
name|host_flag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle all conditions that may halt the chip waiting  * for us to intervene.  */
end_comment

begin_function
name|void
name|adv_isr_chip_halted
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|)
block|{
name|u_int16_t
name|int_halt_code
decl_stmt|;
name|u_int16_t
name|halt_q_addr
decl_stmt|;
name|target_bit_vector
name|target_mask
decl_stmt|;
name|target_bit_vector
name|scsi_busy
decl_stmt|;
name|u_int8_t
name|halt_qp
decl_stmt|;
name|u_int8_t
name|target_ix
decl_stmt|;
name|u_int8_t
name|q_cntl
decl_stmt|;
name|u_int8_t
name|tid_no
decl_stmt|;
name|int_halt_code
operator|=
name|adv_read_lram_16
argument_list|(
name|adv
argument_list|,
name|ADVV_HALTCODE_W
argument_list|)
expr_stmt|;
name|halt_qp
operator|=
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_CURCDB_B
argument_list|)
expr_stmt|;
name|halt_q_addr
operator|=
name|ADV_QNO_TO_QADDR
argument_list|(
name|halt_qp
argument_list|)
expr_stmt|;
name|target_ix
operator|=
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|halt_q_addr
operator|+
name|ADV_SCSIQ_B_TARGET_IX
argument_list|)
expr_stmt|;
name|q_cntl
operator|=
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|halt_q_addr
operator|+
name|ADV_SCSIQ_B_CNTL
argument_list|)
expr_stmt|;
name|tid_no
operator|=
name|ADV_TIX_TO_TID
argument_list|(
name|target_ix
argument_list|)
expr_stmt|;
name|target_mask
operator|=
name|ADV_TID_TO_TARGET_MASK
argument_list|(
name|tid_no
argument_list|)
expr_stmt|;
if|if
condition|(
name|int_halt_code
operator|==
name|ADV_HALT_DISABLE_ASYN_USE_SYN_FIX
condition|)
block|{
comment|/* 		 * Temporarily disable the async fix by removing 		 * this target from the list of affected targets, 		 * setting our async rate, and then putting us 		 * back into the mask. 		 */
name|adv
operator|->
name|fix_asyn_xfer
operator|&=
operator|~
name|target_mask
expr_stmt|;
name|adv_set_syncrate
argument_list|(
name|adv
argument_list|,
comment|/*struct cam_path */
name|NULL
argument_list|,
name|tid_no
argument_list|,
comment|/*period*/
literal|0
argument_list|,
comment|/*offset*/
literal|0
argument_list|,
name|ADV_TRANS_ACTIVE
argument_list|)
expr_stmt|;
name|adv
operator|->
name|fix_asyn_xfer
operator||=
name|target_mask
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|int_halt_code
operator|==
name|ADV_HALT_ENABLE_ASYN_USE_SYN_FIX
condition|)
block|{
name|adv_set_syncrate
argument_list|(
name|adv
argument_list|,
comment|/*struct cam_path */
name|NULL
argument_list|,
name|tid_no
argument_list|,
comment|/*period*/
literal|0
argument_list|,
comment|/*offset*/
literal|0
argument_list|,
name|ADV_TRANS_ACTIVE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|int_halt_code
operator|==
name|ADV_HALT_EXTMSG_IN
condition|)
block|{
name|adv_handle_extmsg_in
argument_list|(
name|adv
argument_list|,
name|halt_q_addr
argument_list|,
name|q_cntl
argument_list|,
name|target_mask
argument_list|,
name|tid_no
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|int_halt_code
operator|==
name|ADV_HALT_CHK_CONDITION
condition|)
block|{
name|struct
name|adv_target_transinfo
modifier|*
name|tinfo
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|u_int32_t
name|cinfo_index
decl_stmt|;
name|u_int8_t
name|tag_code
decl_stmt|;
name|u_int8_t
name|q_status
decl_stmt|;
name|tinfo
operator|=
operator|&
name|adv
operator|->
name|tinfo
index|[
name|tid_no
index|]
expr_stmt|;
name|q_cntl
operator||=
name|QC_REQ_SENSE
expr_stmt|;
comment|/* Renegotiate if appropriate. */
name|adv_set_syncrate
argument_list|(
name|adv
argument_list|,
comment|/*struct cam_path */
name|NULL
argument_list|,
name|tid_no
argument_list|,
comment|/*period*/
literal|0
argument_list|,
comment|/*offset*/
literal|0
argument_list|,
name|ADV_TRANS_CUR
argument_list|)
expr_stmt|;
if|if
condition|(
name|tinfo
operator|->
name|current
operator|.
name|period
operator|!=
name|tinfo
operator|->
name|goal
operator|.
name|period
condition|)
block|{
name|adv_msgout_sdtr
argument_list|(
name|adv
argument_list|,
name|tinfo
operator|->
name|goal
operator|.
name|period
argument_list|,
name|tinfo
operator|->
name|goal
operator|.
name|offset
argument_list|)
expr_stmt|;
name|q_cntl
operator||=
name|QC_MSG_OUT
expr_stmt|;
block|}
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|halt_q_addr
operator|+
name|ADV_SCSIQ_B_CNTL
argument_list|,
name|q_cntl
argument_list|)
expr_stmt|;
comment|/* Don't tag request sense commands */
name|tag_code
operator|=
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|halt_q_addr
operator|+
name|ADV_SCSIQ_B_TAG_CODE
argument_list|)
expr_stmt|;
name|tag_code
operator|&=
operator|~
operator|(
name|MSG_SIMPLE_Q_TAG
operator||
name|MSG_HEAD_OF_Q_TAG
operator||
name|MSG_ORDERED_Q_TAG
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|adv
operator|->
name|fix_asyn_xfer
operator|&
name|target_mask
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|adv
operator|->
name|fix_asyn_xfer_always
operator|&
name|target_mask
operator|)
operator|==
literal|0
condition|)
block|{
name|tag_code
operator||=
operator|(
name|ADV_TAG_FLAG_DISABLE_DISCONNECT
operator||
name|ADV_TAG_FLAG_DISABLE_ASYN_USE_SYN_FIX
operator|)
expr_stmt|;
block|}
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|halt_q_addr
operator|+
name|ADV_SCSIQ_B_TAG_CODE
argument_list|,
name|tag_code
argument_list|)
expr_stmt|;
name|q_status
operator|=
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|halt_q_addr
operator|+
name|ADV_SCSIQ_B_STATUS
argument_list|)
expr_stmt|;
name|q_status
operator||=
operator|(
name|QS_READY
operator||
name|QS_BUSY
operator|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|halt_q_addr
operator|+
name|ADV_SCSIQ_B_STATUS
argument_list|,
name|q_status
argument_list|)
expr_stmt|;
comment|/* 		 * Freeze the devq until we can handle the sense condition. 		 */
name|cinfo_index
operator|=
name|adv_read_lram_32
argument_list|(
name|adv
argument_list|,
name|halt_q_addr
operator|+
name|ADV_SCSIQ_D_CINFO_IDX
argument_list|)
expr_stmt|;
name|ccb
operator|=
name|adv
operator|->
name|ccb_infos
index|[
name|cinfo_index
index|]
operator|.
name|ccb
expr_stmt|;
name|xpt_freeze_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_QFRZN
expr_stmt|;
name|adv_abort_ccb
argument_list|(
name|adv
argument_list|,
name|tid_no
argument_list|,
name|ADV_TIX_TO_LUN
argument_list|(
name|target_ix
argument_list|)
argument_list|,
comment|/*ccb*/
name|NULL
argument_list|,
name|CAM_REQUEUE_REQ
argument_list|,
comment|/*queued_only*/
name|TRUE
argument_list|)
expr_stmt|;
name|scsi_busy
operator|=
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_SCSIBUSY_B
argument_list|)
expr_stmt|;
name|scsi_busy
operator|&=
operator|~
name|target_mask
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_SCSIBUSY_B
argument_list|,
name|scsi_busy
argument_list|)
expr_stmt|;
comment|/* 		 * Ensure we have enough time to actually 		 * retrieve the sense. 		 */
name|untimeout
argument_list|(
name|adv_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ccb
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|adv_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ccb
argument_list|,
literal|5
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|int_halt_code
operator|==
name|ADV_HALT_SDTR_REJECTED
condition|)
block|{
name|struct
name|ext_msg
name|out_msg
decl_stmt|;
name|adv_read_lram_16_multi
argument_list|(
name|adv
argument_list|,
name|ADVV_MSGOUT_BEG
argument_list|,
operator|(
name|u_int16_t
operator|*
operator|)
operator|&
name|out_msg
argument_list|,
sizeof|sizeof
argument_list|(
name|out_msg
argument_list|)
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|out_msg
operator|.
name|msg_type
operator|==
name|MSG_EXTENDED
operator|)
operator|&&
operator|(
name|out_msg
operator|.
name|msg_len
operator|==
name|MSG_EXT_SDTR_LEN
operator|)
operator|&&
operator|(
name|out_msg
operator|.
name|msg_req
operator|==
name|MSG_EXT_SDTR
operator|)
condition|)
block|{
comment|/* Revert to Async */
name|adv_set_syncrate
argument_list|(
name|adv
argument_list|,
comment|/*struct cam_path */
name|NULL
argument_list|,
name|tid_no
argument_list|,
comment|/*period*/
literal|0
argument_list|,
comment|/*offset*/
literal|0
argument_list|,
name|ADV_TRANS_GOAL
operator||
name|ADV_TRANS_ACTIVE
argument_list|)
expr_stmt|;
block|}
name|q_cntl
operator|&=
operator|~
name|QC_MSG_OUT
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|halt_q_addr
operator|+
name|ADV_SCSIQ_B_CNTL
argument_list|,
name|q_cntl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|int_halt_code
operator|==
name|ADV_HALT_SS_QUEUE_FULL
condition|)
block|{
name|u_int8_t
name|scsi_status
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|u_int32_t
name|cinfo_index
decl_stmt|;
name|scsi_status
operator|=
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|halt_q_addr
operator|+
name|ADV_SCSIQ_SCSI_STATUS
argument_list|)
expr_stmt|;
name|cinfo_index
operator|=
name|adv_read_lram_32
argument_list|(
name|adv
argument_list|,
name|halt_q_addr
operator|+
name|ADV_SCSIQ_D_CINFO_IDX
argument_list|)
expr_stmt|;
name|ccb
operator|=
name|adv
operator|->
name|ccb_infos
index|[
name|cinfo_index
index|]
operator|.
name|ccb
expr_stmt|;
name|xpt_freeze_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_QFRZN
operator||
name|CAM_SCSI_STATUS_ERROR
expr_stmt|;
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|SCSI_STATUS_QUEUE_FULL
expr_stmt|;
name|adv_abort_ccb
argument_list|(
name|adv
argument_list|,
name|tid_no
argument_list|,
name|ADV_TIX_TO_LUN
argument_list|(
name|target_ix
argument_list|)
argument_list|,
comment|/*ccb*/
name|NULL
argument_list|,
name|CAM_REQUEUE_REQ
argument_list|,
comment|/*queued_only*/
name|TRUE
argument_list|)
expr_stmt|;
name|scsi_busy
operator|=
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_SCSIBUSY_B
argument_list|)
expr_stmt|;
name|scsi_busy
operator|&=
operator|~
name|target_mask
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_SCSIBUSY_B
argument_list|,
name|scsi_busy
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Unhandled Halt Code %x\n"
argument_list|,
name|int_halt_code
argument_list|)
expr_stmt|;
block|}
name|adv_write_lram_16
argument_list|(
name|adv
argument_list|,
name|ADVV_HALTCODE_W
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|adv_sdtr_to_period_offset
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int8_t
name|sync_data
parameter_list|,
name|u_int8_t
modifier|*
name|period
parameter_list|,
name|u_int8_t
modifier|*
name|offset
parameter_list|,
name|int
name|tid
parameter_list|)
block|{
if|if
condition|(
name|adv
operator|->
name|fix_asyn_xfer
operator|&
name|ADV_TID_TO_TARGET_MASK
argument_list|(
name|tid
argument_list|)
operator|&&
operator|(
name|sync_data
operator|==
name|ASYN_SDTR_DATA_FIX_PCI_REV_AB
operator|)
condition|)
block|{
operator|*
name|period
operator|=
operator|*
name|offset
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|period
operator|=
name|adv
operator|->
name|sdtr_period_tbl
index|[
operator|(
operator|(
name|sync_data
operator|>>
literal|4
operator|)
operator|&
literal|0xF
operator|)
index|]
expr_stmt|;
operator|*
name|offset
operator|=
name|sync_data
operator|&
literal|0xF
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|adv_set_syncrate
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|u_int
name|tid
parameter_list|,
name|u_int
name|period
parameter_list|,
name|u_int
name|offset
parameter_list|,
name|u_int
name|type
parameter_list|)
block|{
name|struct
name|adv_target_transinfo
modifier|*
name|tinfo
decl_stmt|;
name|u_int
name|old_period
decl_stmt|;
name|u_int
name|old_offset
decl_stmt|;
name|u_int8_t
name|sdtr_data
decl_stmt|;
name|tinfo
operator|=
operator|&
name|adv
operator|->
name|tinfo
index|[
name|tid
index|]
expr_stmt|;
comment|/* Filter our input */
name|sdtr_data
operator|=
name|adv_period_offset_to_sdtr
argument_list|(
name|adv
argument_list|,
operator|&
name|period
argument_list|,
operator|&
name|offset
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|old_period
operator|=
name|tinfo
operator|->
name|current
operator|.
name|period
expr_stmt|;
name|old_offset
operator|=
name|tinfo
operator|->
name|current
operator|.
name|offset
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|&
name|ADV_TRANS_CUR
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|old_period
operator|!=
name|period
operator|||
name|old_offset
operator|!=
name|offset
operator|)
operator|||
name|period
operator|==
literal|0
operator|||
name|offset
operator|==
literal|0
operator|)
comment|/*Changes in asyn fix settings*/
condition|)
block|{
name|int
name|s
decl_stmt|;
name|int
name|halted
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|halted
operator|=
name|adv_is_chip_halted
argument_list|(
name|adv
argument_list|)
expr_stmt|;
if|if
condition|(
name|halted
operator|==
literal|0
condition|)
comment|/* Must halt the chip first */
name|adv_host_req_chip_halt
argument_list|(
name|adv
argument_list|)
expr_stmt|;
comment|/* Update current hardware settings */
name|adv_set_sdtr_reg_at_id
argument_list|(
name|adv
argument_list|,
name|tid
argument_list|,
name|sdtr_data
argument_list|)
expr_stmt|;
comment|/* 		 * If a target can run in sync mode, we don't need 		 * to check it for sync problems. 		 */
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
name|adv
operator|->
name|fix_asyn_xfer
operator|&=
operator|~
name|ADV_TID_TO_TARGET_MASK
argument_list|(
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|halted
operator|==
literal|0
condition|)
comment|/* Start the chip again */
name|adv_start_chip
argument_list|(
name|adv
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|tinfo
operator|->
name|current
operator|.
name|period
operator|=
name|period
expr_stmt|;
name|tinfo
operator|->
name|current
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|path
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Tell the SCSI layer about the 			 * new transfer parameters. 			 */
name|struct
name|ccb_trans_settings
name|neg
decl_stmt|;
name|neg
operator|.
name|sync_period
operator|=
name|period
expr_stmt|;
name|neg
operator|.
name|sync_offset
operator|=
name|offset
expr_stmt|;
name|neg
operator|.
name|valid
operator|=
name|CCB_TRANS_SYNC_RATE_VALID
operator||
name|CCB_TRANS_SYNC_OFFSET_VALID
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|neg
operator|.
name|ccb_h
argument_list|,
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_TRANSFER_NEG
argument_list|,
name|path
argument_list|,
operator|&
name|neg
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|type
operator|&
name|ADV_TRANS_GOAL
operator|)
operator|!=
literal|0
condition|)
block|{
name|tinfo
operator|->
name|goal
operator|.
name|period
operator|=
name|period
expr_stmt|;
name|tinfo
operator|->
name|goal
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|type
operator|&
name|ADV_TRANS_USER
operator|)
operator|!=
literal|0
condition|)
block|{
name|tinfo
operator|->
name|user
operator|.
name|period
operator|=
name|period
expr_stmt|;
name|tinfo
operator|->
name|user
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
block|}
block|}
end_function

begin_function
name|u_int8_t
name|adv_period_offset_to_sdtr
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int
modifier|*
name|period
parameter_list|,
name|u_int
modifier|*
name|offset
parameter_list|,
name|int
name|tid
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|u_int
name|dummy_offset
decl_stmt|;
name|u_int
name|dummy_period
decl_stmt|;
if|if
condition|(
name|offset
operator|==
name|NULL
condition|)
block|{
name|dummy_offset
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
operator|&
name|dummy_offset
expr_stmt|;
block|}
if|if
condition|(
name|period
operator|==
name|NULL
condition|)
block|{
name|dummy_period
operator|=
literal|0
expr_stmt|;
name|period
operator|=
operator|&
name|dummy_period
expr_stmt|;
block|}
operator|*
name|offset
operator|=
name|MIN
argument_list|(
name|ADV_SYN_MAX_OFFSET
argument_list|,
operator|*
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|period
operator|!=
literal|0
operator|&&
operator|*
name|offset
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adv
operator|->
name|sdtr_period_tbl_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|period
operator|<=
name|adv
operator|->
name|sdtr_period_tbl
index|[
name|i
index|]
condition|)
block|{
comment|/*        				 * When responding to a target that requests 				 * sync, the requested  rate may fall between 				 * two rates that we can output, but still be 				 * a rate that we can receive.  Because of this, 				 * we want to respond to the target with 				 * the same rate that it sent to us even 				 * if the period we use to send data to it 				 * is lower.  Only lower the response period 				 * if we must. 				 */
if|if
condition|(
name|i
operator|==
literal|0
comment|/* Our maximum rate */
condition|)
operator|*
name|period
operator|=
name|adv
operator|->
name|sdtr_period_tbl
index|[
literal|0
index|]
expr_stmt|;
return|return
operator|(
operator|(
name|i
operator|<<
literal|4
operator|)
operator||
operator|*
name|offset
operator|)
return|;
block|}
block|}
block|}
comment|/* Must go async */
operator|*
name|period
operator|=
literal|0
expr_stmt|;
operator|*
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|adv
operator|->
name|fix_asyn_xfer
operator|&
name|ADV_TID_TO_TARGET_MASK
argument_list|(
name|tid
argument_list|)
condition|)
return|return
operator|(
name|ASYN_SDTR_DATA_FIX_PCI_REV_AB
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Internal Routines */
end_comment

begin_function
specifier|static
name|void
name|adv_read_lram_16_multi
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int16_t
name|s_addr
parameter_list|,
name|u_int16_t
modifier|*
name|buffer
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_ADDR
argument_list|,
name|s_addr
argument_list|)
expr_stmt|;
name|ADV_INSW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_DATA
argument_list|,
name|buffer
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|adv_write_lram_16_multi
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int16_t
name|s_addr
parameter_list|,
name|u_int16_t
modifier|*
name|buffer
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_ADDR
argument_list|,
name|s_addr
argument_list|)
expr_stmt|;
name|ADV_OUTSW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_DATA
argument_list|,
name|buffer
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|adv_mset_lram_16
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int16_t
name|s_addr
parameter_list|,
name|u_int16_t
name|set_value
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_ADDR
argument_list|,
name|s_addr
argument_list|)
expr_stmt|;
name|bus_space_set_multi_2
argument_list|(
name|adv
operator|->
name|tag
argument_list|,
name|adv
operator|->
name|bsh
argument_list|,
name|ADV_LRAM_DATA
argument_list|,
name|set_value
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|adv_msum_lram_16
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int16_t
name|s_addr
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|u_int32_t
name|sum
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sum
operator|=
literal|0
expr_stmt|;
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_ADDR
argument_list|,
name|s_addr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|sum
operator|+=
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_DATA
argument_list|)
expr_stmt|;
return|return
operator|(
name|sum
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|adv_write_and_verify_lram_16
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int16_t
name|addr
parameter_list|,
name|u_int16_t
name|value
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_DATA
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_DATA
argument_list|)
condition|)
name|retval
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|adv_read_lram_32
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int16_t
name|addr
parameter_list|)
block|{
name|u_int16_t
name|val_low
decl_stmt|,
name|val_high
decl_stmt|;
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
name|val_high
operator|=
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_DATA
argument_list|)
expr_stmt|;
name|val_low
operator|=
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_DATA
argument_list|)
expr_stmt|;
else|#
directive|else
name|val_low
operator|=
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_DATA
argument_list|)
expr_stmt|;
name|val_high
operator|=
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_DATA
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|(
operator|(
name|u_int32_t
operator|)
name|val_high
operator|<<
literal|16
operator|)
operator||
operator|(
name|u_int32_t
operator|)
name|val_low
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|adv_write_lram_32
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int16_t
name|addr
parameter_list|,
name|u_int32_t
name|value
parameter_list|)
block|{
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_DATA
argument_list|,
call|(
name|u_int16_t
call|)
argument_list|(
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
literal|0xFFFF
argument_list|)
argument_list|)
expr_stmt|;
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_DATA
argument_list|,
call|(
name|u_int16_t
call|)
argument_list|(
name|value
operator|&
literal|0xFFFF
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_DATA
argument_list|,
call|(
name|u_int16_t
call|)
argument_list|(
name|value
operator|&
literal|0xFFFF
argument_list|)
argument_list|)
expr_stmt|;
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_DATA
argument_list|,
call|(
name|u_int16_t
call|)
argument_list|(
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
literal|0xFFFF
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|adv_write_lram_32_multi
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int16_t
name|s_addr
parameter_list|,
name|u_int32_t
modifier|*
name|buffer
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_ADDR
argument_list|,
name|s_addr
argument_list|)
expr_stmt|;
name|ADV_OUTSW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_DATA
argument_list|,
operator|(
name|u_int16_t
operator|*
operator|)
name|buffer
argument_list|,
name|count
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int16_t
name|adv_read_eeprom_16
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int8_t
name|addr
parameter_list|)
block|{
name|u_int16_t
name|read_wval
decl_stmt|;
name|u_int8_t
name|cmd_reg
decl_stmt|;
name|adv_write_eeprom_cmd_reg
argument_list|(
name|adv
argument_list|,
name|ADV_EEPROM_CMD_WRITE_DISABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|cmd_reg
operator|=
name|addr
operator||
name|ADV_EEPROM_CMD_READ
expr_stmt|;
name|adv_write_eeprom_cmd_reg
argument_list|(
name|adv
argument_list|,
name|cmd_reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|read_wval
operator|=
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_EEPROM_DATA
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
return|return
operator|(
name|read_wval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int16_t
name|adv_write_eeprom_16
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int8_t
name|addr
parameter_list|,
name|u_int16_t
name|value
parameter_list|)
block|{
name|u_int16_t
name|read_value
decl_stmt|;
name|read_value
operator|=
name|adv_read_eeprom_16
argument_list|(
name|adv
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_value
operator|!=
name|value
condition|)
block|{
name|adv_write_eeprom_cmd_reg
argument_list|(
name|adv
argument_list|,
name|ADV_EEPROM_CMD_WRITE_ENABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_EEPROM_DATA
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|adv_write_eeprom_cmd_reg
argument_list|(
name|adv
argument_list|,
name|ADV_EEPROM_CMD_WRITE
operator||
name|addr
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|20
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|adv_write_eeprom_cmd_reg
argument_list|(
name|adv
argument_list|,
name|ADV_EEPROM_CMD_WRITE_DISABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|read_value
operator|=
name|adv_read_eeprom_16
argument_list|(
name|adv
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|read_value
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|adv_write_eeprom_cmd_reg
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int8_t
name|cmd_reg
parameter_list|)
block|{
name|u_int8_t
name|read_back
decl_stmt|;
name|int
name|retry
decl_stmt|;
name|retry
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|ADV_OUTB
argument_list|(
name|adv
argument_list|,
name|ADV_EEPROM_CMD
argument_list|,
name|cmd_reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|read_back
operator|=
name|ADV_INB
argument_list|(
name|adv
argument_list|,
name|ADV_EEPROM_CMD
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_back
operator|==
name|cmd_reg
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|retry
operator|++
operator|>
name|ADV_EEPROM_MAX_RETRY
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|adv_set_eeprom_config_once
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|struct
name|adv_eeprom_config
modifier|*
name|eeprom_config
parameter_list|)
block|{
name|int
name|n_error
decl_stmt|;
name|u_int16_t
modifier|*
name|wbuf
decl_stmt|;
name|u_int16_t
name|sum
decl_stmt|;
name|u_int8_t
name|s_addr
decl_stmt|;
name|u_int8_t
name|cfg_beg
decl_stmt|;
name|u_int8_t
name|cfg_end
decl_stmt|;
name|wbuf
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|eeprom_config
expr_stmt|;
name|n_error
operator|=
literal|0
expr_stmt|;
name|sum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|s_addr
operator|=
literal|0
init|;
name|s_addr
operator|<
literal|2
condition|;
name|s_addr
operator|++
operator|,
name|wbuf
operator|++
control|)
block|{
name|sum
operator|+=
operator|*
name|wbuf
expr_stmt|;
if|if
condition|(
operator|*
name|wbuf
operator|!=
name|adv_write_eeprom_16
argument_list|(
name|adv
argument_list|,
name|s_addr
argument_list|,
operator|*
name|wbuf
argument_list|)
condition|)
block|{
name|n_error
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|adv
operator|->
name|type
operator|&
name|ADV_VL
condition|)
block|{
name|cfg_beg
operator|=
name|ADV_EEPROM_CFG_BEG_VL
expr_stmt|;
name|cfg_end
operator|=
name|ADV_EEPROM_MAX_ADDR_VL
expr_stmt|;
block|}
else|else
block|{
name|cfg_beg
operator|=
name|ADV_EEPROM_CFG_BEG
expr_stmt|;
name|cfg_end
operator|=
name|ADV_EEPROM_MAX_ADDR
expr_stmt|;
block|}
for|for
control|(
name|s_addr
operator|=
name|cfg_beg
init|;
name|s_addr
operator|<=
operator|(
name|cfg_end
operator|-
literal|1
operator|)
condition|;
name|s_addr
operator|++
operator|,
name|wbuf
operator|++
control|)
block|{
name|sum
operator|+=
operator|*
name|wbuf
expr_stmt|;
if|if
condition|(
operator|*
name|wbuf
operator|!=
name|adv_write_eeprom_16
argument_list|(
name|adv
argument_list|,
name|s_addr
argument_list|,
operator|*
name|wbuf
argument_list|)
condition|)
block|{
name|n_error
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|wbuf
operator|=
name|sum
expr_stmt|;
if|if
condition|(
name|sum
operator|!=
name|adv_write_eeprom_16
argument_list|(
name|adv
argument_list|,
name|s_addr
argument_list|,
name|sum
argument_list|)
condition|)
block|{
name|n_error
operator|++
expr_stmt|;
block|}
name|wbuf
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|eeprom_config
expr_stmt|;
for|for
control|(
name|s_addr
operator|=
literal|0
init|;
name|s_addr
operator|<
literal|2
condition|;
name|s_addr
operator|++
operator|,
name|wbuf
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|wbuf
operator|!=
name|adv_read_eeprom_16
argument_list|(
name|adv
argument_list|,
name|s_addr
argument_list|)
condition|)
block|{
name|n_error
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|s_addr
operator|=
name|cfg_beg
init|;
name|s_addr
operator|<=
name|cfg_end
condition|;
name|s_addr
operator|++
operator|,
name|wbuf
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|wbuf
operator|!=
name|adv_read_eeprom_16
argument_list|(
name|adv
argument_list|,
name|s_addr
argument_list|)
condition|)
block|{
name|n_error
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|n_error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|adv_load_microcode
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int16_t
name|s_addr
parameter_list|,
name|u_int16_t
modifier|*
name|mcode_buf
parameter_list|,
name|u_int16_t
name|mcode_size
parameter_list|)
block|{
name|u_int32_t
name|chksum
decl_stmt|;
name|u_int16_t
name|mcode_lram_size
decl_stmt|;
name|u_int16_t
name|mcode_chksum
decl_stmt|;
name|mcode_lram_size
operator|=
name|mcode_size
operator|>>
literal|1
expr_stmt|;
comment|/* XXX Why zero the memory just before you write the whole thing?? */
name|adv_mset_lram_16
argument_list|(
name|adv
argument_list|,
name|s_addr
argument_list|,
literal|0
argument_list|,
name|mcode_lram_size
argument_list|)
expr_stmt|;
name|adv_write_lram_16_multi
argument_list|(
name|adv
argument_list|,
name|s_addr
argument_list|,
name|mcode_buf
argument_list|,
name|mcode_lram_size
argument_list|)
expr_stmt|;
name|chksum
operator|=
name|adv_msum_lram_16
argument_list|(
name|adv
argument_list|,
name|s_addr
argument_list|,
name|mcode_lram_size
argument_list|)
expr_stmt|;
name|mcode_chksum
operator|=
operator|(
name|u_int16_t
operator|)
name|adv_msum_lram_16
argument_list|(
name|adv
argument_list|,
name|ADV_CODE_SEC_BEG
argument_list|,
operator|(
operator|(
name|mcode_size
operator|-
name|s_addr
operator|-
name|ADV_CODE_SEC_BEG
operator|)
operator|>>
literal|1
operator|)
argument_list|)
expr_stmt|;
name|adv_write_lram_16
argument_list|(
name|adv
argument_list|,
name|ADVV_MCODE_CHKSUM_W
argument_list|,
name|mcode_chksum
argument_list|)
expr_stmt|;
name|adv_write_lram_16
argument_list|(
name|adv
argument_list|,
name|ADVV_MCODE_SIZE_W
argument_list|,
name|mcode_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|chksum
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|adv_reinit_lram
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|)
block|{
name|adv_init_lram
argument_list|(
name|adv
argument_list|)
expr_stmt|;
name|adv_init_qlink_var
argument_list|(
name|adv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|adv_init_lram
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|)
block|{
name|u_int8_t
name|i
decl_stmt|;
name|u_int16_t
name|s_addr
decl_stmt|;
name|adv_mset_lram_16
argument_list|(
name|adv
argument_list|,
name|ADV_QADR_BEG
argument_list|,
literal|0
argument_list|,
operator|(
operator|(
operator|(
name|adv
operator|->
name|max_openings
operator|+
literal|2
operator|+
literal|1
operator|)
operator|*
literal|64
operator|)
operator|>>
literal|1
operator|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|ADV_MIN_ACTIVE_QNO
expr_stmt|;
name|s_addr
operator|=
name|ADV_QADR_BEG
operator|+
name|ADV_QBLK_SIZE
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|s_addr
operator|+
name|ADV_SCSIQ_B_FWD
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|s_addr
operator|+
name|ADV_SCSIQ_B_BWD
argument_list|,
name|adv
operator|->
name|max_openings
argument_list|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|s_addr
operator|+
name|ADV_SCSIQ_B_QNO
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|s_addr
operator|+=
name|ADV_QBLK_SIZE
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|adv
operator|->
name|max_openings
condition|;
name|i
operator|++
operator|,
name|s_addr
operator|+=
name|ADV_QBLK_SIZE
control|)
block|{
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|s_addr
operator|+
name|ADV_SCSIQ_B_FWD
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|s_addr
operator|+
name|ADV_SCSIQ_B_BWD
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|s_addr
operator|+
name|ADV_SCSIQ_B_QNO
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|s_addr
operator|+
name|ADV_SCSIQ_B_FWD
argument_list|,
name|ADV_QLINK_END
argument_list|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|s_addr
operator|+
name|ADV_SCSIQ_B_BWD
argument_list|,
name|adv
operator|->
name|max_openings
operator|-
literal|1
argument_list|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|s_addr
operator|+
name|ADV_SCSIQ_B_QNO
argument_list|,
name|adv
operator|->
name|max_openings
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|s_addr
operator|+=
name|ADV_QBLK_SIZE
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<=
name|adv
operator|->
name|max_openings
operator|+
literal|3
condition|;
name|i
operator|++
operator|,
name|s_addr
operator|+=
name|ADV_QBLK_SIZE
control|)
block|{
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|s_addr
operator|+
name|ADV_SCSIQ_B_FWD
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|s_addr
operator|+
name|ADV_SCSIQ_B_BWD
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|s_addr
operator|+
name|ADV_SCSIQ_B_QNO
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|adv_init_microcode_var
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|ADV_MAX_TID
condition|;
name|i
operator|++
control|)
block|{
comment|/* Start out async all around */
name|adv_set_syncrate
argument_list|(
name|adv
argument_list|,
comment|/*path*/
name|NULL
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ADV_TRANS_GOAL
operator||
name|ADV_TRANS_CUR
argument_list|)
expr_stmt|;
block|}
name|adv_init_qlink_var
argument_list|(
name|adv
argument_list|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_DISC_ENABLE_B
argument_list|,
name|adv
operator|->
name|disc_enable
argument_list|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_HOSTSCSI_ID_B
argument_list|,
literal|0x01
operator|<<
name|adv
operator|->
name|scsi_id
argument_list|)
expr_stmt|;
name|adv_write_lram_32
argument_list|(
name|adv
argument_list|,
name|ADVV_OVERRUN_PADDR_D
argument_list|,
name|adv
operator|->
name|overrun_physbase
argument_list|)
expr_stmt|;
name|adv_write_lram_32
argument_list|(
name|adv
argument_list|,
name|ADVV_OVERRUN_BSIZE_D
argument_list|,
name|ADV_OVERRUN_BSIZE
argument_list|)
expr_stmt|;
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_REG_PROG_COUNTER
argument_list|,
name|ADV_MCODE_START_ADDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_REG_PROG_COUNTER
argument_list|)
operator|!=
name|ADV_MCODE_START_ADDR
condition|)
block|{
name|printf
argument_list|(
literal|"adv%d: Unable to set program counter. Aborting.\n"
argument_list|,
name|adv
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|adv_init_qlink_var
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int16_t
name|lram_addr
decl_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_NEXTRDY_B
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_DONENEXT_B
argument_list|,
name|adv
operator|->
name|max_openings
argument_list|)
expr_stmt|;
name|adv_write_lram_16
argument_list|(
name|adv
argument_list|,
name|ADVV_FREE_Q_HEAD_W
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|adv_write_lram_16
argument_list|(
name|adv
argument_list|,
name|ADVV_DONE_Q_TAIL_W
argument_list|,
name|adv
operator|->
name|max_openings
argument_list|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_BUSY_QHEAD_B
argument_list|,
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|int
operator|)
name|adv
operator|->
name|max_openings
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_DISC1_QHEAD_B
argument_list|,
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|int
operator|)
name|adv
operator|->
name|max_openings
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_TOTAL_READY_Q_B
argument_list|,
name|adv
operator|->
name|max_openings
argument_list|)
expr_stmt|;
name|adv_write_lram_16
argument_list|(
name|adv
argument_list|,
name|ADVV_ASCDVC_ERR_CODE_W
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|adv_write_lram_16
argument_list|(
name|adv
argument_list|,
name|ADVV_HALTCODE_W
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_STOP_CODE_B
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_SCSIBUSY_B
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_WTM_FLAG_B
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_Q_DONE_IN_PROGRESS_B
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lram_addr
operator|=
name|ADV_QADR_BEG
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
operator|,
name|lram_addr
operator|+=
literal|2
control|)
name|adv_write_lram_16
argument_list|(
name|adv
argument_list|,
name|lram_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|adv_disable_interrupt
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|)
block|{
name|u_int16_t
name|cfg
decl_stmt|;
name|cfg
operator|=
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_CONFIG_LSW
argument_list|)
expr_stmt|;
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_CONFIG_LSW
argument_list|,
name|cfg
operator|&
operator|~
name|ADV_CFG_LSW_HOST_INT_ON
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|adv_enable_interrupt
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|)
block|{
name|u_int16_t
name|cfg
decl_stmt|;
name|cfg
operator|=
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_CONFIG_LSW
argument_list|)
expr_stmt|;
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_CONFIG_LSW
argument_list|,
name|cfg
operator||
name|ADV_CFG_LSW_HOST_INT_ON
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|adv_toggle_irq_act
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|)
block|{
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_STATUS
argument_list|,
name|ADV_CIW_IRQ_ACT
argument_list|)
expr_stmt|;
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_STATUS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|adv_start_execution
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|)
block|{
if|if
condition|(
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|ADV_STOP_CODE_B
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADV_STOP_CODE_B
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|adv_stop_chip
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|)
block|{
name|u_int8_t
name|cc_val
decl_stmt|;
name|cc_val
operator|=
name|ADV_INB
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_CTRL
argument_list|)
operator|&
operator|(
operator|~
operator|(
name|ADV_CC_SINGLE_STEP
operator||
name|ADV_CC_TEST
operator||
name|ADV_CC_DIAG
operator|)
operator|)
expr_stmt|;
name|ADV_OUTB
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_CTRL
argument_list|,
name|cc_val
operator||
name|ADV_CC_HALT
argument_list|)
expr_stmt|;
name|adv_set_chip_ih
argument_list|(
name|adv
argument_list|,
name|ADV_INS_HALT
argument_list|)
expr_stmt|;
name|adv_set_chip_ih
argument_list|(
name|adv
argument_list|,
name|ADV_INS_RFLAG_WTM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_STATUS
argument_list|)
operator|&
name|ADV_CSW_HALTED
operator|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|adv_host_req_chip_halt
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|)
block|{
name|int
name|count
decl_stmt|;
name|u_int8_t
name|saved_stop_code
decl_stmt|;
if|if
condition|(
name|adv_is_chip_halted
argument_list|(
name|adv
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|count
operator|=
literal|0
expr_stmt|;
name|saved_stop_code
operator|=
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_STOP_CODE_B
argument_list|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_STOP_CODE_B
argument_list|,
name|ADV_STOP_HOST_REQ_RISC_HALT
operator||
name|ADV_STOP_REQ_RISC_STOP
argument_list|)
expr_stmt|;
while|while
condition|(
name|adv_is_chip_halted
argument_list|(
name|adv
argument_list|)
operator|==
literal|0
operator|&&
name|count
operator|++
operator|<
literal|2000
condition|)
empty_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_STOP_CODE_B
argument_list|,
name|saved_stop_code
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|<
literal|2000
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|adv_set_chip_ih
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int16_t
name|ins_code
parameter_list|)
block|{
name|adv_set_bank
argument_list|(
name|adv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_REG_IH
argument_list|,
name|ins_code
argument_list|)
expr_stmt|;
name|adv_set_bank
argument_list|(
name|adv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|UNUSED
end_if

begin_function
specifier|static
name|u_int8_t
name|adv_get_chip_scsi_ctrl
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|)
block|{
name|u_int8_t
name|scsi_ctrl
decl_stmt|;
name|adv_set_bank
argument_list|(
name|adv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|scsi_ctrl
operator|=
name|ADV_INB
argument_list|(
name|adv
argument_list|,
name|ADV_REG_SC
argument_list|)
expr_stmt|;
name|adv_set_bank
argument_list|(
name|adv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|scsi_ctrl
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * XXX Looks like more padding issues in this routine as well.  *     There has to be a way to turn this into an insw.  */
end_comment

begin_function
specifier|static
name|void
name|adv_get_q_info
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int16_t
name|s_addr
parameter_list|,
name|u_int16_t
modifier|*
name|inbuf
parameter_list|,
name|int
name|words
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_ADDR
argument_list|,
name|s_addr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
operator|,
name|inbuf
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|5
condition|)
block|{
continue|continue;
block|}
operator|*
name|inbuf
operator|=
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_DATA
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|u_int
name|adv_get_num_free_queues
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int8_t
name|n_qs
parameter_list|)
block|{
name|u_int
name|cur_used_qs
decl_stmt|;
name|u_int
name|cur_free_qs
decl_stmt|;
name|cur_used_qs
operator|=
name|adv
operator|->
name|cur_active
operator|+
name|ADV_MIN_FREE_Q
expr_stmt|;
if|if
condition|(
operator|(
name|cur_used_qs
operator|+
name|n_qs
operator|)
operator|<=
name|adv
operator|->
name|max_openings
condition|)
block|{
name|cur_free_qs
operator|=
name|adv
operator|->
name|max_openings
operator|-
name|cur_used_qs
expr_stmt|;
return|return
operator|(
name|cur_free_qs
operator|)
return|;
block|}
name|adv
operator|->
name|openings_needed
operator|=
name|n_qs
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|adv_alloc_free_queues
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int8_t
name|free_q_head
parameter_list|,
name|u_int8_t
name|n_free_q
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_free_q
condition|;
name|i
operator|++
control|)
block|{
name|free_q_head
operator|=
name|adv_alloc_free_queue
argument_list|(
name|adv
argument_list|,
name|free_q_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_q_head
operator|==
name|ADV_QLINK_END
condition|)
break|break;
block|}
return|return
operator|(
name|free_q_head
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|adv_alloc_free_queue
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int8_t
name|free_q_head
parameter_list|)
block|{
name|u_int16_t
name|q_addr
decl_stmt|;
name|u_int8_t
name|next_qp
decl_stmt|;
name|u_int8_t
name|q_status
decl_stmt|;
name|next_qp
operator|=
name|ADV_QLINK_END
expr_stmt|;
name|q_addr
operator|=
name|ADV_QNO_TO_QADDR
argument_list|(
name|free_q_head
argument_list|)
expr_stmt|;
name|q_status
operator|=
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|q_addr
operator|+
name|ADV_SCSIQ_B_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|q_status
operator|&
name|QS_READY
operator|)
operator|==
literal|0
condition|)
name|next_qp
operator|=
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|q_addr
operator|+
name|ADV_SCSIQ_B_FWD
argument_list|)
expr_stmt|;
return|return
operator|(
name|next_qp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|adv_send_scsi_queue
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|struct
name|adv_scsi_q
modifier|*
name|scsiq
parameter_list|,
name|u_int8_t
name|n_q_required
parameter_list|)
block|{
name|u_int8_t
name|free_q_head
decl_stmt|;
name|u_int8_t
name|next_qp
decl_stmt|;
name|u_int8_t
name|tid_no
decl_stmt|;
name|u_int8_t
name|target_ix
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
name|target_ix
operator|=
name|scsiq
operator|->
name|q2
operator|.
name|target_ix
expr_stmt|;
name|tid_no
operator|=
name|ADV_TIX_TO_TID
argument_list|(
name|target_ix
argument_list|)
expr_stmt|;
name|free_q_head
operator|=
name|adv_read_lram_16
argument_list|(
name|adv
argument_list|,
name|ADVV_FREE_Q_HEAD_W
argument_list|)
operator|&
literal|0xFF
expr_stmt|;
if|if
condition|(
operator|(
name|next_qp
operator|=
name|adv_alloc_free_queues
argument_list|(
name|adv
argument_list|,
name|free_q_head
argument_list|,
name|n_q_required
argument_list|)
operator|)
operator|!=
name|ADV_QLINK_END
condition|)
block|{
name|scsiq
operator|->
name|q1
operator|.
name|q_no
operator|=
name|free_q_head
expr_stmt|;
comment|/* 		 * Now that we know our Q number, point our sense 		 * buffer pointer to a bus dma mapped area where 		 * we can dma the data to. 		 */
name|scsiq
operator|->
name|q1
operator|.
name|sense_addr
operator|=
name|adv
operator|->
name|sense_physbase
operator|+
operator|(
operator|(
name|free_q_head
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
operator|)
expr_stmt|;
name|adv_put_ready_sg_list_queue
argument_list|(
name|adv
argument_list|,
name|scsiq
argument_list|,
name|free_q_head
argument_list|)
expr_stmt|;
name|adv_write_lram_16
argument_list|(
name|adv
argument_list|,
name|ADVV_FREE_Q_HEAD_W
argument_list|,
name|next_qp
argument_list|)
expr_stmt|;
name|adv
operator|->
name|cur_active
operator|+=
name|n_q_required
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|adv_put_ready_sg_list_queue
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|struct
name|adv_scsi_q
modifier|*
name|scsiq
parameter_list|,
name|u_int
name|q_no
parameter_list|)
block|{
name|u_int8_t
name|sg_list_dwords
decl_stmt|;
name|u_int8_t
name|sg_index
decl_stmt|,
name|i
decl_stmt|;
name|u_int8_t
name|sg_entry_cnt
decl_stmt|;
name|u_int8_t
name|next_qp
decl_stmt|;
name|u_int16_t
name|q_addr
decl_stmt|;
name|struct
name|adv_sg_head
modifier|*
name|sg_head
decl_stmt|;
name|struct
name|adv_sg_list_q
name|scsi_sg_q
decl_stmt|;
name|sg_head
operator|=
name|scsiq
operator|->
name|sg_head
expr_stmt|;
if|if
condition|(
name|sg_head
condition|)
block|{
name|sg_entry_cnt
operator|=
name|sg_head
operator|->
name|entry_cnt
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|sg_entry_cnt
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"adv_put_ready_sg_list_queue: ScsiQ with "
literal|"a SG list but only one element"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scsiq
operator|->
name|q1
operator|.
name|cntl
operator|&
name|QC_SG_HEAD
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"adv_put_ready_sg_list_queue: ScsiQ with "
literal|"a SG list but QC_SG_HEAD not set"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|q_addr
operator|=
name|ADV_QNO_TO_QADDR
argument_list|(
name|q_no
argument_list|)
expr_stmt|;
name|sg_index
operator|=
literal|1
expr_stmt|;
name|scsiq
operator|->
name|q1
operator|.
name|sg_queue_cnt
operator|=
name|sg_head
operator|->
name|queue_cnt
expr_stmt|;
name|scsi_sg_q
operator|.
name|sg_head_qp
operator|=
name|q_no
expr_stmt|;
name|scsi_sg_q
operator|.
name|cntl
operator|=
name|QCSG_SG_XFER_LIST
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sg_head
operator|->
name|queue_cnt
condition|;
name|i
operator|++
control|)
block|{
name|u_int8_t
name|segs_this_q
decl_stmt|;
if|if
condition|(
name|sg_entry_cnt
operator|>
name|ADV_SG_LIST_PER_Q
condition|)
name|segs_this_q
operator|=
name|ADV_SG_LIST_PER_Q
expr_stmt|;
else|else
block|{
comment|/* This will be the last segment then */
name|segs_this_q
operator|=
name|sg_entry_cnt
expr_stmt|;
name|scsi_sg_q
operator|.
name|cntl
operator||=
name|QCSG_SG_XFER_END
expr_stmt|;
block|}
name|scsi_sg_q
operator|.
name|seq_no
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|sg_list_dwords
operator|=
name|segs_this_q
operator|<<
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|scsi_sg_q
operator|.
name|sg_list_cnt
operator|=
name|segs_this_q
expr_stmt|;
name|scsi_sg_q
operator|.
name|sg_cur_list_cnt
operator|=
name|segs_this_q
expr_stmt|;
block|}
else|else
block|{
name|scsi_sg_q
operator|.
name|sg_list_cnt
operator|=
name|segs_this_q
operator|-
literal|1
expr_stmt|;
name|scsi_sg_q
operator|.
name|sg_cur_list_cnt
operator|=
name|segs_this_q
operator|-
literal|1
expr_stmt|;
block|}
name|next_qp
operator|=
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|q_addr
operator|+
name|ADV_SCSIQ_B_FWD
argument_list|)
expr_stmt|;
name|scsi_sg_q
operator|.
name|q_no
operator|=
name|next_qp
expr_stmt|;
name|q_addr
operator|=
name|ADV_QNO_TO_QADDR
argument_list|(
name|next_qp
argument_list|)
expr_stmt|;
name|adv_write_lram_16_multi
argument_list|(
name|adv
argument_list|,
name|q_addr
operator|+
name|ADV_SCSIQ_SGHD_CPY_BEG
argument_list|,
operator|(
name|u_int16_t
operator|*
operator|)
operator|&
name|scsi_sg_q
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_sg_q
argument_list|)
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|adv_write_lram_32_multi
argument_list|(
name|adv
argument_list|,
name|q_addr
operator|+
name|ADV_SGQ_LIST_BEG
argument_list|,
operator|(
name|u_int32_t
operator|*
operator|)
operator|&
name|sg_head
operator|->
name|sg_list
index|[
name|sg_index
index|]
argument_list|,
name|sg_list_dwords
argument_list|)
expr_stmt|;
name|sg_entry_cnt
operator|-=
name|segs_this_q
expr_stmt|;
name|sg_index
operator|+=
name|ADV_SG_LIST_PER_Q
expr_stmt|;
block|}
block|}
name|adv_put_ready_queue
argument_list|(
name|adv
argument_list|,
name|scsiq
argument_list|,
name|q_no
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|adv_put_ready_queue
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|struct
name|adv_scsi_q
modifier|*
name|scsiq
parameter_list|,
name|u_int
name|q_no
parameter_list|)
block|{
name|struct
name|adv_target_transinfo
modifier|*
name|tinfo
decl_stmt|;
name|u_int
name|q_addr
decl_stmt|;
name|u_int
name|tid_no
decl_stmt|;
name|tid_no
operator|=
name|ADV_TIX_TO_TID
argument_list|(
name|scsiq
operator|->
name|q2
operator|.
name|target_ix
argument_list|)
expr_stmt|;
name|tinfo
operator|=
operator|&
name|adv
operator|->
name|tinfo
index|[
name|tid_no
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|tinfo
operator|->
name|current
operator|.
name|period
operator|!=
name|tinfo
operator|->
name|goal
operator|.
name|period
operator|)
operator|||
operator|(
name|tinfo
operator|->
name|current
operator|.
name|offset
operator|!=
name|tinfo
operator|->
name|goal
operator|.
name|offset
operator|)
condition|)
block|{
name|adv_msgout_sdtr
argument_list|(
name|adv
argument_list|,
name|tinfo
operator|->
name|goal
operator|.
name|period
argument_list|,
name|tinfo
operator|->
name|goal
operator|.
name|offset
argument_list|)
expr_stmt|;
name|scsiq
operator|->
name|q1
operator|.
name|cntl
operator||=
name|QC_MSG_OUT
expr_stmt|;
block|}
name|q_addr
operator|=
name|ADV_QNO_TO_QADDR
argument_list|(
name|q_no
argument_list|)
expr_stmt|;
name|scsiq
operator|->
name|q1
operator|.
name|status
operator|=
name|QS_FREE
expr_stmt|;
name|adv_write_lram_16_multi
argument_list|(
name|adv
argument_list|,
name|q_addr
operator|+
name|ADV_SCSIQ_CDB_BEG
argument_list|,
operator|(
name|u_int16_t
operator|*
operator|)
name|scsiq
operator|->
name|cdbptr
argument_list|,
name|scsiq
operator|->
name|q2
operator|.
name|cdb_len
operator|>>
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
name|adv_adj_scsiq_endian
argument_list|(
name|scsiq
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|adv_put_scsiq
argument_list|(
name|adv
argument_list|,
name|q_addr
operator|+
name|ADV_SCSIQ_CPY_BEG
argument_list|,
operator|(
name|u_int16_t
operator|*
operator|)
operator|&
name|scsiq
operator|->
name|q1
operator|.
name|cntl
argument_list|,
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|scsiq
operator|->
name|q1
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|scsiq
operator|->
name|q2
argument_list|)
operator|)
operator|/
literal|2
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|CC_WRITE_IO_COUNT
name|adv_write_lram_16
argument_list|(
name|adv
argument_list|,
name|q_addr
operator|+
name|ADV_SCSIQ_W_REQ_COUNT
argument_list|,
name|adv
operator|->
name|req_count
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|CC_CLEAR_DMA_REMAIN
name|adv_write_lram_32
argument_list|(
name|adv
argument_list|,
name|q_addr
operator|+
name|ADV_SCSIQ_DW_REMAIN_XFER_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|adv_write_lram_32
argument_list|(
name|adv
argument_list|,
name|q_addr
operator|+
name|ADV_SCSIQ_DW_REMAIN_XFER_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|adv_write_lram_16
argument_list|(
name|adv
argument_list|,
name|q_addr
operator|+
name|ADV_SCSIQ_B_STATUS
argument_list|,
operator|(
name|scsiq
operator|->
name|q1
operator|.
name|q_no
operator|<<
literal|8
operator|)
operator||
name|QS_READY
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|adv_put_scsiq
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int16_t
name|s_addr
parameter_list|,
name|u_int16_t
modifier|*
name|buffer
parameter_list|,
name|int
name|words
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 	 * XXX This routine makes *gross* assumptions 	 * about padding in the data structures. 	 * Either the data structures should have explicit 	 * padding members added, or they should have padding 	 * turned off via compiler attributes depending on 	 * which yields better overall performance.  My hunch 	 * would be that turning off padding would be the 	 * faster approach as an outsw is much faster than 	 * this crude loop and accessing un-aligned data 	 * members isn't *that* expensive.  The other choice 	 * would be to modify the ASC script so that the 	 * the adv_scsiq_1 structure can be re-arranged so 	 * padding isn't required. 	 */
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_ADDR
argument_list|,
name|s_addr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
operator|,
name|buffer
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|2
operator|||
name|i
operator|==
literal|10
condition|)
block|{
continue|continue;
block|}
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_DATA
argument_list|,
operator|*
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
end_if

begin_function
name|void
name|adv_adj_endian_qdone_info
parameter_list|(
name|struct
name|adv_q_done_info
modifier|*
name|scsiq
parameter_list|)
block|{
name|panic
argument_list|(
literal|"adv(4) not supported on big-endian machines.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|adv_adj_scsiq_endian
parameter_list|(
name|struct
name|adv_scsi_q
modifier|*
name|scsiq
parameter_list|)
block|{
name|panic
argument_list|(
literal|"adv(4) not supported on big-endian machines.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|adv_handle_extmsg_in
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int16_t
name|halt_q_addr
parameter_list|,
name|u_int8_t
name|q_cntl
parameter_list|,
name|target_bit_vector
name|target_mask
parameter_list|,
name|int
name|tid_no
parameter_list|)
block|{
name|struct
name|ext_msg
name|ext_msg
decl_stmt|;
name|adv_read_lram_16_multi
argument_list|(
name|adv
argument_list|,
name|ADVV_MSGIN_BEG
argument_list|,
operator|(
name|u_int16_t
operator|*
operator|)
operator|&
name|ext_msg
argument_list|,
sizeof|sizeof
argument_list|(
name|ext_msg
argument_list|)
operator|>>
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ext_msg
operator|.
name|msg_type
operator|==
name|MSG_EXTENDED
operator|)
operator|&&
operator|(
name|ext_msg
operator|.
name|msg_req
operator|==
name|MSG_EXT_SDTR
operator|)
operator|&&
operator|(
name|ext_msg
operator|.
name|msg_len
operator|==
name|MSG_EXT_SDTR_LEN
operator|)
condition|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|adv_target_transinfo
modifier|*
name|tinfo
decl_stmt|;
name|u_int32_t
name|cinfo_index
decl_stmt|;
name|u_int
name|period
decl_stmt|;
name|u_int
name|offset
decl_stmt|;
name|int
name|sdtr_accept
decl_stmt|;
name|u_int8_t
name|orig_offset
decl_stmt|;
name|cinfo_index
operator|=
name|adv_read_lram_32
argument_list|(
name|adv
argument_list|,
name|halt_q_addr
operator|+
name|ADV_SCSIQ_D_CINFO_IDX
argument_list|)
expr_stmt|;
name|ccb
operator|=
name|adv
operator|->
name|ccb_infos
index|[
name|cinfo_index
index|]
operator|.
name|ccb
expr_stmt|;
name|tinfo
operator|=
operator|&
name|adv
operator|->
name|tinfo
index|[
name|tid_no
index|]
expr_stmt|;
name|sdtr_accept
operator|=
name|TRUE
expr_stmt|;
name|orig_offset
operator|=
name|ext_msg
operator|.
name|req_ack_offset
expr_stmt|;
if|if
condition|(
name|ext_msg
operator|.
name|xfer_period
operator|<
name|tinfo
operator|->
name|goal
operator|.
name|period
condition|)
block|{
name|sdtr_accept
operator|=
name|FALSE
expr_stmt|;
name|ext_msg
operator|.
name|xfer_period
operator|=
name|tinfo
operator|->
name|goal
operator|.
name|period
expr_stmt|;
block|}
comment|/* Perform range checking */
name|period
operator|=
name|ext_msg
operator|.
name|xfer_period
expr_stmt|;
name|offset
operator|=
name|ext_msg
operator|.
name|req_ack_offset
expr_stmt|;
name|adv_period_offset_to_sdtr
argument_list|(
name|adv
argument_list|,
operator|&
name|period
argument_list|,
operator|&
name|offset
argument_list|,
name|tid_no
argument_list|)
expr_stmt|;
name|ext_msg
operator|.
name|xfer_period
operator|=
name|period
expr_stmt|;
name|ext_msg
operator|.
name|req_ack_offset
operator|=
name|offset
expr_stmt|;
comment|/* Record our current sync settings */
name|adv_set_syncrate
argument_list|(
name|adv
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|tid_no
argument_list|,
name|ext_msg
operator|.
name|xfer_period
argument_list|,
name|ext_msg
operator|.
name|req_ack_offset
argument_list|,
name|ADV_TRANS_GOAL
operator||
name|ADV_TRANS_ACTIVE
argument_list|)
expr_stmt|;
comment|/* Offset too high or large period forced async */
if|if
condition|(
name|orig_offset
operator|!=
name|ext_msg
operator|.
name|req_ack_offset
condition|)
name|sdtr_accept
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|sdtr_accept
operator|&&
operator|(
name|q_cntl
operator|&
name|QC_MSG_OUT
operator|)
condition|)
block|{
comment|/* Valid response to our requested negotiation */
name|q_cntl
operator|&=
operator|~
name|QC_MSG_OUT
expr_stmt|;
block|}
else|else
block|{
comment|/* Must Respond */
name|q_cntl
operator||=
name|QC_MSG_OUT
expr_stmt|;
name|adv_msgout_sdtr
argument_list|(
name|adv
argument_list|,
name|ext_msg
operator|.
name|xfer_period
argument_list|,
name|ext_msg
operator|.
name|req_ack_offset
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ext_msg
operator|.
name|msg_type
operator|==
name|MSG_EXTENDED
operator|&&
name|ext_msg
operator|.
name|msg_req
operator|==
name|MSG_EXT_WDTR
operator|&&
name|ext_msg
operator|.
name|msg_len
operator|==
name|MSG_EXT_WDTR_LEN
condition|)
block|{
name|ext_msg
operator|.
name|wdtr_width
operator|=
literal|0
expr_stmt|;
name|adv_write_lram_16_multi
argument_list|(
name|adv
argument_list|,
name|ADVV_MSGOUT_BEG
argument_list|,
operator|(
name|u_int16_t
operator|*
operator|)
operator|&
name|ext_msg
argument_list|,
sizeof|sizeof
argument_list|(
name|ext_msg
argument_list|)
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|q_cntl
operator||=
name|QC_MSG_OUT
expr_stmt|;
block|}
else|else
block|{
name|ext_msg
operator|.
name|msg_type
operator|=
name|MSG_MESSAGE_REJECT
expr_stmt|;
name|adv_write_lram_16_multi
argument_list|(
name|adv
argument_list|,
name|ADVV_MSGOUT_BEG
argument_list|,
operator|(
name|u_int16_t
operator|*
operator|)
operator|&
name|ext_msg
argument_list|,
sizeof|sizeof
argument_list|(
name|ext_msg
argument_list|)
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|q_cntl
operator||=
name|QC_MSG_OUT
expr_stmt|;
block|}
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|halt_q_addr
operator|+
name|ADV_SCSIQ_B_CNTL
argument_list|,
name|q_cntl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|adv_msgout_sdtr
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|u_int8_t
name|sdtr_period
parameter_list|,
name|u_int8_t
name|sdtr_offset
parameter_list|)
block|{
name|struct
name|ext_msg
name|sdtr_buf
decl_stmt|;
name|sdtr_buf
operator|.
name|msg_type
operator|=
name|MSG_EXTENDED
expr_stmt|;
name|sdtr_buf
operator|.
name|msg_len
operator|=
name|MSG_EXT_SDTR_LEN
expr_stmt|;
name|sdtr_buf
operator|.
name|msg_req
operator|=
name|MSG_EXT_SDTR
expr_stmt|;
name|sdtr_buf
operator|.
name|xfer_period
operator|=
name|sdtr_period
expr_stmt|;
name|sdtr_offset
operator|&=
name|ADV_SYN_MAX_OFFSET
expr_stmt|;
name|sdtr_buf
operator|.
name|req_ack_offset
operator|=
name|sdtr_offset
expr_stmt|;
name|adv_write_lram_16_multi
argument_list|(
name|adv
argument_list|,
name|ADVV_MSGOUT_BEG
argument_list|,
operator|(
name|u_int16_t
operator|*
operator|)
operator|&
name|sdtr_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|sdtr_buf
argument_list|)
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|adv_abort_ccb
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|lun
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|u_int32_t
name|status
parameter_list|,
name|int
name|queued_only
parameter_list|)
block|{
name|u_int16_t
name|q_addr
decl_stmt|;
name|u_int8_t
name|q_no
decl_stmt|;
name|struct
name|adv_q_done_info
name|scsiq_buf
decl_stmt|;
name|struct
name|adv_q_done_info
modifier|*
name|scsiq
decl_stmt|;
name|u_int8_t
name|target_ix
decl_stmt|;
name|int
name|count
decl_stmt|;
name|scsiq
operator|=
operator|&
name|scsiq_buf
expr_stmt|;
name|target_ix
operator|=
name|ADV_TIDLUN_TO_IX
argument_list|(
name|target
argument_list|,
name|lun
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|q_no
operator|=
name|ADV_MIN_ACTIVE_QNO
init|;
name|q_no
operator|<=
name|adv
operator|->
name|max_openings
condition|;
name|q_no
operator|++
control|)
block|{
name|struct
name|adv_ccb_info
modifier|*
name|ccb_info
decl_stmt|;
name|q_addr
operator|=
name|ADV_QNO_TO_QADDR
argument_list|(
name|q_no
argument_list|)
expr_stmt|;
name|adv_copy_lram_doneq
argument_list|(
name|adv
argument_list|,
name|q_addr
argument_list|,
name|scsiq
argument_list|,
name|adv
operator|->
name|max_dma_count
argument_list|)
expr_stmt|;
name|ccb_info
operator|=
operator|&
name|adv
operator|->
name|ccb_infos
index|[
name|scsiq
operator|->
name|d2
operator|.
name|ccb_index
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|scsiq
operator|->
name|q_status
operator|&
name|QS_READY
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|scsiq
operator|->
name|q_status
operator|&
name|QS_ABORTED
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|scsiq
operator|->
name|cntl
operator|&
name|QCSG_SG_XFER_LIST
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|scsiq
operator|->
name|d2
operator|.
name|target_ix
operator|==
name|target_ix
operator|)
operator|&&
operator|(
name|queued_only
operator|==
literal|0
operator|||
operator|!
operator|(
name|scsiq
operator|->
name|q_status
operator|&
operator|(
name|QS_DISC1
operator||
name|QS_DISC2
operator||
name|QS_BUSY
operator||
name|QS_DONE
operator|)
operator|)
operator|)
operator|&&
operator|(
name|ccb
operator|==
name|NULL
operator|||
operator|(
name|ccb
operator|==
name|ccb_info
operator|->
name|ccb
operator|)
operator|)
condition|)
block|{
name|union
name|ccb
modifier|*
name|aborted_ccb
decl_stmt|;
name|struct
name|adv_ccb_info
modifier|*
name|cinfo
decl_stmt|;
name|scsiq
operator|->
name|q_status
operator||=
name|QS_ABORTED
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|q_addr
operator|+
name|ADV_SCSIQ_B_STATUS
argument_list|,
name|scsiq
operator|->
name|q_status
argument_list|)
expr_stmt|;
name|aborted_ccb
operator|=
name|ccb_info
operator|->
name|ccb
expr_stmt|;
comment|/* Don't clobber earlier error codes */
if|if
condition|(
operator|(
name|aborted_ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_INPROG
condition|)
name|aborted_ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|status
expr_stmt|;
name|cinfo
operator|=
operator|(
expr|struct
name|adv_ccb_info
operator|*
operator|)
name|aborted_ccb
operator|->
name|ccb_h
operator|.
name|ccb_cinfo_ptr
expr_stmt|;
name|cinfo
operator|->
name|state
operator||=
name|ACCB_ABORT_QUEUED
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_function
name|int
name|adv_reset_bus
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|int
name|initiate_bus_reset
parameter_list|)
block|{
name|int
name|count
decl_stmt|;
name|int
name|i
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|i
operator|=
literal|200
expr_stmt|;
while|while
condition|(
operator|(
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_STATUS
argument_list|)
operator|&
name|ADV_CSW_SCSI_RESET_ACTIVE
operator|)
operator|!=
literal|0
operator|&&
name|i
operator|--
condition|)
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|adv_reset_chip
argument_list|(
name|adv
argument_list|,
name|initiate_bus_reset
argument_list|)
expr_stmt|;
name|adv_reinit_lram
argument_list|(
name|adv
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|ADV_MAX_TID
condition|;
name|i
operator|++
control|)
name|adv_set_syncrate
argument_list|(
name|adv
argument_list|,
name|NULL
argument_list|,
name|i
argument_list|,
comment|/*period*/
literal|0
argument_list|,
comment|/*offset*/
literal|0
argument_list|,
name|ADV_TRANS_CUR
argument_list|)
expr_stmt|;
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_REG_PROG_COUNTER
argument_list|,
name|ADV_MCODE_START_ADDR
argument_list|)
expr_stmt|;
comment|/* Tell the XPT layer that a bus reset occured */
if|if
condition|(
name|adv
operator|->
name|path
operator|!=
name|NULL
condition|)
name|xpt_async
argument_list|(
name|AC_BUS_RESET
argument_list|,
name|adv
operator|->
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|LIST_FIRST
argument_list|(
operator|&
name|adv
operator|->
name|pending_ccbs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_INPROG
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SCSI_BUS_RESET
expr_stmt|;
name|adv_done
argument_list|(
name|adv
argument_list|,
name|ccb
argument_list|,
name|QD_ABORTED_BY_HOST
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|adv_start_chip
argument_list|(
name|adv
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|adv_set_sdtr_reg_at_id
parameter_list|(
name|struct
name|adv_softc
modifier|*
name|adv
parameter_list|,
name|int
name|tid
parameter_list|,
name|u_int8_t
name|sdtr_data
parameter_list|)
block|{
name|int
name|orig_id
decl_stmt|;
name|adv_set_bank
argument_list|(
name|adv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|orig_id
operator|=
name|ffs
argument_list|(
name|ADV_INB
argument_list|(
name|adv
argument_list|,
name|ADV_HOST_SCSIID
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
name|ADV_OUTB
argument_list|(
name|adv
argument_list|,
name|ADV_HOST_SCSIID
argument_list|,
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ADV_INB
argument_list|(
name|adv
argument_list|,
name|ADV_HOST_SCSIID
argument_list|)
operator|==
operator|(
literal|0x01
operator|<<
name|tid
operator|)
condition|)
block|{
name|adv_set_bank
argument_list|(
name|adv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ADV_OUTB
argument_list|(
name|adv
argument_list|,
name|ADV_SYN_OFFSET
argument_list|,
name|sdtr_data
argument_list|)
expr_stmt|;
block|}
name|adv_set_bank
argument_list|(
name|adv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ADV_OUTB
argument_list|(
name|adv
argument_list|,
name|ADV_HOST_SCSIID
argument_list|,
name|orig_id
argument_list|)
expr_stmt|;
name|adv_set_bank
argument_list|(
name|adv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

