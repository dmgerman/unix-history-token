begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Low level routines for the Advanced Systems Inc. SCSI controllers chips  *  * Copyright (c) 1996 Justin T. Gibbs.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice immediately at the beginning of the file, without modification,  *    this list of conditions, and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *      $Id$  */
end_comment

begin_comment
comment|/*  * Ported from:  * advansys.c - Linux Host Driver for AdvanSys SCSI Adapters  *       * Copyright (c) 1995-1996 Advanced System Products, Inc.  * All Rights Reserved.  *     * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that redistributions of source  * code retain the above copyright notice and this comment without  * modification.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsi_disk.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/advansys/advlib.h>
end_include

begin_include
include|#
directive|include
file|<dev/advansys/advmcode.h>
end_include

begin_comment
comment|/*  * Allowable periods in ns  */
end_comment

begin_decl_stmt
name|u_int8_t
name|adv_sdtr_period_tbl
index|[]
init|=
block|{
literal|25
block|,
literal|30
block|,
literal|35
block|,
literal|40
block|,
literal|50
block|,
literal|60
block|,
literal|70
block|,
literal|85
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|sdtr_xmsg
block|{
name|u_int8_t
name|msg_type
decl_stmt|;
name|u_int8_t
name|msg_len
decl_stmt|;
name|u_int8_t
name|msg_req
decl_stmt|;
name|u_int8_t
name|xfer_period
decl_stmt|;
name|u_int8_t
name|req_ack_offset
decl_stmt|;
name|u_int8_t
name|res
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Some of the early PCI adapters have problems with  * async transfers.  Instead try to use an offset of  * 1.  */
end_comment

begin_define
define|#
directive|define
name|ASYN_SDTR_DATA_FIX
value|0x41
end_define

begin_comment
comment|/* LRAM routines */
end_comment

begin_decl_stmt
specifier|static
name|void
name|adv_read_lram_16_multi
name|__P
argument_list|(
operator|(
expr|struct
name|adv_softc
operator|*
name|adv
operator|,
name|u_int16_t
name|s_addr
operator|,
name|u_int16_t
operator|*
name|buffer
operator|,
name|int
name|count
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|adv_write_lram_16_multi
name|__P
argument_list|(
operator|(
expr|struct
name|adv_softc
operator|*
name|adv
operator|,
name|u_int16_t
name|s_addr
operator|,
name|u_int16_t
operator|*
name|buffer
operator|,
name|int
name|count
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|adv_mset_lram_16
name|__P
argument_list|(
operator|(
expr|struct
name|adv_softc
operator|*
name|adv
operator|,
name|u_int16_t
name|s_addr
operator|,
name|u_int16_t
name|set_value
operator|,
name|int
name|count
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|adv_msum_lram_16
name|__P
argument_list|(
operator|(
expr|struct
name|adv_softc
operator|*
name|adv
operator|,
name|u_int16_t
name|s_addr
operator|,
name|int
name|count
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|adv_write_and_verify_lram_16
name|__P
argument_list|(
operator|(
expr|struct
name|adv_softc
operator|*
name|adv
operator|,
name|u_int16_t
name|addr
operator|,
name|u_int16_t
name|value
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|adv_read_lram_32
name|__P
argument_list|(
operator|(
expr|struct
name|adv_softc
operator|*
name|adv
operator|,
name|u_int16_t
name|addr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|adv_write_lram_32
name|__P
argument_list|(
operator|(
expr|struct
name|adv_softc
operator|*
name|adv
operator|,
name|u_int16_t
name|addr
operator|,
name|u_int32_t
name|value
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|adv_write_lram_32_multi
name|__P
argument_list|(
operator|(
expr|struct
name|adv_softc
operator|*
name|adv
operator|,
name|u_int16_t
name|s_addr
operator|,
name|u_int32_t
operator|*
name|buffer
operator|,
name|int
name|count
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* EEPROM routines */
end_comment

begin_decl_stmt
specifier|static
name|u_int16_t
name|adv_read_eeprom_16
name|__P
argument_list|(
operator|(
expr|struct
name|adv_softc
operator|*
name|adv
operator|,
name|u_int8_t
name|addr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int16_t
name|adv_write_eeprom_16
name|__P
argument_list|(
operator|(
expr|struct
name|adv_softc
operator|*
name|adv
operator|,
name|u_int8_t
name|addr
operator|,
name|u_int16_t
name|value
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|adv_write_eeprom_cmd_reg
name|__P
argument_list|(
operator|(
expr|struct
name|adv_softc
operator|*
name|adv
operator|,
name|u_int8_t
name|cmd_reg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|adv_set_eeprom_config_once
name|__P
argument_list|(
operator|(
expr|struct
name|adv_softc
operator|*
name|adv
operator|,
expr|struct
name|adv_eeprom_config
operator|*
name|eeprom_config
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialization */
end_comment

begin_decl_stmt
specifier|static
name|u_int32_t
name|adv_load_microcode
name|__P
argument_list|(
operator|(
expr|struct
name|adv_softc
operator|*
name|adv
operator|,
name|u_int16_t
name|s_addr
operator|,
name|u_int16_t
operator|*
name|mcode_buf
operator|,
name|u_int16_t
name|mcode_size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|adv_init_lram
name|__P
argument_list|(
operator|(
expr|struct
name|adv_softc
operator|*
name|adv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|adv_init_microcode_var
name|__P
argument_list|(
operator|(
expr|struct
name|adv_softc
operator|*
name|adv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|adv_init_qlink_var
name|__P
argument_list|(
operator|(
expr|struct
name|adv_softc
operator|*
name|adv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Interrupts */
end_comment

begin_decl_stmt
specifier|static
name|void
name|adv_disable_interrupt
name|__P
argument_list|(
operator|(
expr|struct
name|adv_softc
operator|*
name|adv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|adv_enable_interrupt
name|__P
argument_list|(
operator|(
expr|struct
name|adv_softc
operator|*
name|adv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|adv_toggle_irq_act
name|__P
argument_list|(
operator|(
expr|struct
name|adv_softc
operator|*
name|adv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chip Control */
end_comment

begin_if
if|#
directive|if
name|UNUSED
end_if

begin_decl_stmt
specifier|static
name|void
name|adv_start_execution
name|__P
argument_list|(
operator|(
expr|struct
name|adv_softc
operator|*
name|adv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|adv_start_chip
name|__P
argument_list|(
operator|(
expr|struct
name|adv_softc
operator|*
name|adv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|adv_stop_chip
name|__P
argument_list|(
operator|(
expr|struct
name|adv_softc
operator|*
name|adv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|adv_set_chip_ih
name|__P
argument_list|(
operator|(
expr|struct
name|adv_softc
operator|*
name|adv
operator|,
name|u_int16_t
name|ins_code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|adv_set_bank
name|__P
argument_list|(
operator|(
expr|struct
name|adv_softc
operator|*
name|adv
operator|,
name|u_int8_t
name|bank
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|UNUSED
end_if

begin_decl_stmt
specifier|static
name|u_int8_t
name|adv_get_chip_scsi_ctrl
name|__P
argument_list|(
operator|(
expr|struct
name|adv_softc
operator|*
name|adv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Queue handling and execution */
end_comment

begin_decl_stmt
specifier|static
name|int
name|adv_sgcount_to_qcount
name|__P
argument_list|(
operator|(
name|int
name|sgcount
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|adv_get_q_info
name|__P
argument_list|(
operator|(
expr|struct
name|adv_softc
operator|*
name|adv
operator|,
name|u_int16_t
name|s_addr
operator|,
name|u_int16_t
operator|*
name|inbuf
operator|,
name|int
name|words
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|adv_get_num_free_queues
name|__P
argument_list|(
operator|(
expr|struct
name|adv_softc
operator|*
name|adv
operator|,
name|u_int8_t
name|n_qs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int8_t
name|adv_alloc_free_queues
name|__P
argument_list|(
operator|(
expr|struct
name|adv_softc
operator|*
name|adv
operator|,
name|u_int8_t
name|free_q_head
operator|,
name|u_int8_t
name|n_free_q
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int8_t
name|adv_alloc_free_queue
name|__P
argument_list|(
operator|(
expr|struct
name|adv_softc
operator|*
name|adv
operator|,
name|u_int8_t
name|free_q_head
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|adv_send_scsi_queue
name|__P
argument_list|(
operator|(
expr|struct
name|adv_softc
operator|*
name|adv
operator|,
expr|struct
name|adv_scsi_q
operator|*
name|scsiq
operator|,
name|u_int8_t
name|n_q_required
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|adv_put_ready_sg_list_queue
name|__P
argument_list|(
operator|(
expr|struct
name|adv_softc
operator|*
name|adv
operator|,
expr|struct
name|adv_scsi_q
operator|*
name|scsiq
operator|,
name|u_int8_t
name|q_no
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|adv_put_ready_queue
name|__P
argument_list|(
operator|(
expr|struct
name|adv_softc
operator|*
name|adv
operator|,
expr|struct
name|adv_scsi_q
operator|*
name|scsiq
operator|,
name|u_int8_t
name|q_no
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|adv_put_scsiq
name|__P
argument_list|(
operator|(
expr|struct
name|adv_softc
operator|*
name|adv
operator|,
name|u_int16_t
name|s_addr
operator|,
name|u_int16_t
operator|*
name|buffer
operator|,
name|int
name|words
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SDTR */
end_comment

begin_decl_stmt
specifier|static
name|u_int8_t
name|adv_msgout_sdtr
name|__P
argument_list|(
operator|(
expr|struct
name|adv_softc
operator|*
name|adv
operator|,
name|u_int8_t
name|sdtr_period
operator|,
name|u_int8_t
name|sdtr_offset
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int8_t
name|adv_get_card_sync_setting
name|__P
argument_list|(
operator|(
name|u_int8_t
name|period
operator|,
name|u_int8_t
name|offset
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|adv_set_chip_sdtr
name|__P
argument_list|(
operator|(
expr|struct
name|adv_softc
operator|*
name|adv
operator|,
name|u_int8_t
name|sdtr_data
operator|,
name|u_int8_t
name|tid_no
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Exported Function first */
end_comment

begin_function
name|u_int8_t
name|adv_read_lram_8
parameter_list|(
name|adv
parameter_list|,
name|addr
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|u_int16_t
name|addr
decl_stmt|;
block|{
name|u_int8_t
name|byte_data
decl_stmt|;
name|u_int16_t
name|word_data
decl_stmt|;
comment|/* 	 * LRAM is accessed on 16bit boundaries. 	 */
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_ADDR
argument_list|,
name|addr
operator|&
literal|0xFFFE
argument_list|)
expr_stmt|;
name|word_data
operator|=
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|&
literal|1
condition|)
block|{
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
name|byte_data
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
name|word_data
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
else|#
directive|else
name|byte_data
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|word_data
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
name|byte_data
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|word_data
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
else|#
directive|else
name|byte_data
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
name|word_data
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
name|byte_data
operator|)
return|;
block|}
end_function

begin_function
name|void
name|adv_write_lram_8
parameter_list|(
name|adv
parameter_list|,
name|addr
parameter_list|,
name|value
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|u_int16_t
name|addr
decl_stmt|;
name|u_int8_t
name|value
decl_stmt|;
block|{
name|u_int16_t
name|word_data
decl_stmt|;
name|word_data
operator|=
name|adv_read_lram_16
argument_list|(
name|adv
argument_list|,
name|addr
operator|&
literal|0xFFFE
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|&
literal|1
condition|)
block|{
name|word_data
operator|&=
literal|0x00FF
expr_stmt|;
name|word_data
operator||=
operator|(
operator|(
operator|(
name|u_int8_t
operator|)
name|value
operator|<<
literal|8
operator|)
operator|&
literal|0xFF00
operator|)
expr_stmt|;
block|}
else|else
block|{
name|word_data
operator|&=
literal|0xFF00
expr_stmt|;
name|word_data
operator||=
operator|(
operator|(
name|u_int8_t
operator|)
name|value
operator|&
literal|0x00FF
operator|)
expr_stmt|;
block|}
name|adv_write_lram_16
argument_list|(
name|adv
argument_list|,
name|addr
operator|&
literal|0xFFFE
argument_list|,
name|word_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|u_int16_t
name|adv_read_lram_16
parameter_list|(
name|adv
parameter_list|,
name|addr
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|u_int16_t
name|addr
decl_stmt|;
block|{
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
operator|(
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_DATA
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|adv_write_lram_16
parameter_list|(
name|adv
parameter_list|,
name|addr
parameter_list|,
name|value
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|u_int16_t
name|addr
decl_stmt|;
name|u_int16_t
name|value
decl_stmt|;
block|{
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_DATA
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the fully qualified board type for the adapter.  * The chip_revision must be set before this function is called.  */
end_comment

begin_function
name|void
name|adv_get_board_type
parameter_list|(
name|adv
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|adv
operator|->
name|chip_version
operator|>=
name|ADV_CHIP_MIN_VER_VL
operator|)
operator|&&
operator|(
name|adv
operator|->
name|chip_version
operator|<=
name|ADV_CHIP_MAX_VER_VL
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|adv
operator|->
name|iobase
operator|&
literal|0x0C30
operator|)
operator|==
literal|0x0C30
operator|)
operator|||
operator|(
operator|(
name|adv
operator|->
name|iobase
operator|&
literal|0x0C50
operator|)
operator|==
literal|0x0C50
operator|)
condition|)
block|{
name|adv
operator|->
name|type
operator|=
name|ADV_EISA
expr_stmt|;
block|}
else|else
name|adv
operator|->
name|type
operator|=
name|ADV_VL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|adv
operator|->
name|chip_version
operator|>=
name|ADV_CHIP_MIN_VER_ISA
operator|)
operator|&&
operator|(
name|adv
operator|->
name|chip_version
operator|<=
name|ADV_CHIP_MAX_VER_ISA
operator|)
condition|)
block|{
if|if
condition|(
name|adv
operator|->
name|chip_version
operator|>=
name|ADV_CHIP_MIN_VER_ISA_PNP
condition|)
block|{
name|adv
operator|->
name|type
operator|=
name|ADV_ISAPNP
expr_stmt|;
block|}
else|else
name|adv
operator|->
name|type
operator|=
name|ADV_ISA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|adv
operator|->
name|chip_version
operator|>=
name|ADV_CHIP_MIN_VER_PCI
operator|)
operator|&&
operator|(
name|adv
operator|->
name|chip_version
operator|<=
name|ADV_CHIP_MAX_VER_PCI
operator|)
condition|)
block|{
name|adv
operator|->
name|type
operator|=
name|ADV_PCI
expr_stmt|;
block|}
else|else
name|panic
argument_list|(
literal|"adv_get_board_type: Unknown board type encountered"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|u_int16_t
name|adv_get_eeprom_config
parameter_list|(
name|adv
parameter_list|,
name|eeprom_config
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|struct
name|adv_eeprom_config
modifier|*
name|eeprom_config
decl_stmt|;
block|{
name|u_int16_t
name|sum
decl_stmt|;
name|u_int16_t
modifier|*
name|wbuf
decl_stmt|;
name|u_int8_t
name|cfg_beg
decl_stmt|;
name|u_int8_t
name|cfg_end
decl_stmt|;
name|u_int8_t
name|s_addr
decl_stmt|;
name|wbuf
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|eeprom_config
expr_stmt|;
name|sum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|s_addr
operator|=
literal|0
init|;
name|s_addr
operator|<
literal|2
condition|;
name|s_addr
operator|++
operator|,
name|wbuf
operator|++
control|)
block|{
operator|*
name|wbuf
operator|=
name|adv_read_eeprom_16
argument_list|(
name|adv
argument_list|,
name|s_addr
argument_list|)
expr_stmt|;
name|sum
operator|+=
operator|*
name|wbuf
expr_stmt|;
block|}
if|if
condition|(
name|adv
operator|->
name|type
operator|&
name|ADV_VL
condition|)
block|{
name|cfg_beg
operator|=
name|ADV_EEPROM_CFG_BEG_VL
expr_stmt|;
name|cfg_end
operator|=
name|ADV_EEPROM_MAX_ADDR_VL
expr_stmt|;
block|}
else|else
block|{
name|cfg_beg
operator|=
name|ADV_EEPROM_CFG_BEG
expr_stmt|;
name|cfg_end
operator|=
name|ADV_EEPROM_MAX_ADDR
expr_stmt|;
block|}
for|for
control|(
name|s_addr
operator|=
name|cfg_beg
init|;
name|s_addr
operator|<=
operator|(
name|cfg_end
operator|-
literal|1
operator|)
condition|;
name|s_addr
operator|++
operator|,
name|wbuf
operator|++
control|)
block|{
operator|*
name|wbuf
operator|=
name|adv_read_eeprom_16
argument_list|(
name|adv
argument_list|,
name|s_addr
argument_list|)
expr_stmt|;
name|sum
operator|+=
operator|*
name|wbuf
expr_stmt|;
if|#
directive|if
name|ADV_DEBUG_EEPROM
name|printf
argument_list|(
literal|"Addr 0x%x: 0x%04x\n"
argument_list|,
name|s_addr
argument_list|,
operator|*
name|wbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
operator|*
name|wbuf
operator|=
name|adv_read_eeprom_16
argument_list|(
name|adv
argument_list|,
name|s_addr
argument_list|)
expr_stmt|;
return|return
operator|(
name|sum
operator|)
return|;
block|}
end_function

begin_function
name|int
name|adv_set_eeprom_config
parameter_list|(
name|adv
parameter_list|,
name|eeprom_config
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|struct
name|adv_eeprom_config
modifier|*
name|eeprom_config
decl_stmt|;
block|{
name|int
name|retry
decl_stmt|;
name|retry
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|adv_set_eeprom_config_once
argument_list|(
name|adv
argument_list|,
name|eeprom_config
argument_list|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|++
name|retry
operator|>
name|ADV_EEPROM_MAX_RETRY
condition|)
block|{
break|break;
block|}
block|}
return|return
operator|(
name|retry
operator|>
name|ADV_EEPROM_MAX_RETRY
operator|)
return|;
block|}
end_function

begin_function
name|int
name|adv_reset_chip_and_scsi_bus
parameter_list|(
name|adv
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
block|{
name|adv_stop_chip
argument_list|(
name|adv
argument_list|)
expr_stmt|;
name|ADV_OUTB
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_CTRL
argument_list|,
name|ADV_CC_CHIP_RESET
operator||
name|ADV_CC_SCSI_RESET
operator||
name|ADV_CC_HALT
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|adv_set_chip_ih
argument_list|(
name|adv
argument_list|,
name|ADV_INS_RFLAG_WTM
argument_list|)
expr_stmt|;
name|adv_set_chip_ih
argument_list|(
name|adv
argument_list|,
name|ADV_INS_HALT
argument_list|)
expr_stmt|;
name|ADV_OUTB
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_CTRL
argument_list|,
name|ADV_CC_CHIP_RESET
operator||
name|ADV_CC_HALT
argument_list|)
expr_stmt|;
name|ADV_OUTB
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_CTRL
argument_list|,
name|ADV_CC_HALT
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
operator|*
literal|1000
argument_list|)
expr_stmt|;
return|return
operator|(
name|adv_is_chip_halted
argument_list|(
name|adv
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|adv_test_external_lram
parameter_list|(
name|adv
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
block|{
name|u_int16_t
name|q_addr
decl_stmt|;
name|u_int16_t
name|saved_value
decl_stmt|;
name|int
name|success
decl_stmt|;
name|success
operator|=
literal|0
expr_stmt|;
comment|/* XXX Why 241? */
name|q_addr
operator|=
name|ADV_QNO_TO_QADDR
argument_list|(
literal|241
argument_list|)
expr_stmt|;
name|saved_value
operator|=
name|adv_read_lram_16
argument_list|(
name|adv
argument_list|,
name|q_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|adv_write_and_verify_lram_16
argument_list|(
name|adv
argument_list|,
name|q_addr
argument_list|,
literal|0x55AA
argument_list|)
operator|==
literal|0
condition|)
block|{
name|success
operator|=
literal|1
expr_stmt|;
name|adv_write_lram_16
argument_list|(
name|adv
argument_list|,
name|q_addr
argument_list|,
name|saved_value
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|success
operator|)
return|;
block|}
end_function

begin_function
name|int
name|adv_init_lram_and_mcode
parameter_list|(
name|adv
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
block|{
name|u_int32_t
name|retval
decl_stmt|;
name|adv_disable_interrupt
argument_list|(
name|adv
argument_list|)
expr_stmt|;
name|adv_init_lram
argument_list|(
name|adv
argument_list|)
expr_stmt|;
name|retval
operator|=
name|adv_load_microcode
argument_list|(
name|adv
argument_list|,
literal|0
argument_list|,
operator|(
name|u_int16_t
operator|*
operator|)
name|adv_mcode
argument_list|,
name|adv_mcode_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|adv_mcode_chksum
condition|)
block|{
name|printf
argument_list|(
literal|"adv%d: Microcode download failed checksum!\n"
argument_list|,
name|adv
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|adv_init_microcode_var
argument_list|(
name|adv
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|adv_enable_interrupt
argument_list|(
name|adv
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|u_int8_t
name|adv_get_chip_irq
parameter_list|(
name|adv
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
block|{
name|u_int16_t
name|cfg_lsw
decl_stmt|;
name|u_int8_t
name|chip_irq
decl_stmt|;
name|cfg_lsw
operator|=
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_CONFIG_LSW
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|adv
operator|->
name|type
operator|&
name|ADV_VL
operator|)
operator|!=
literal|0
condition|)
block|{
name|chip_irq
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
operator|(
name|cfg_lsw
operator|>>
literal|2
operator|)
operator|&
literal|0x07
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chip_irq
operator|==
literal|0
operator|)
operator|||
operator|(
name|chip_irq
operator|==
literal|4
operator|)
operator|||
operator|(
name|chip_irq
operator|==
literal|7
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|chip_irq
operator|+
operator|(
name|ADV_MIN_IRQ_NO
operator|-
literal|1
operator|)
operator|)
return|;
block|}
name|chip_irq
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
operator|(
name|cfg_lsw
operator|>>
literal|2
operator|)
operator|&
literal|0x03
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|chip_irq
operator|==
literal|3
condition|)
name|chip_irq
operator|+=
literal|2
expr_stmt|;
return|return
operator|(
name|chip_irq
operator|+
name|ADV_MIN_IRQ_NO
operator|)
return|;
block|}
end_function

begin_function
name|u_int8_t
name|adv_set_chip_irq
parameter_list|(
name|adv
parameter_list|,
name|irq_no
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|u_int8_t
name|irq_no
decl_stmt|;
block|{
name|u_int16_t
name|cfg_lsw
decl_stmt|;
if|if
condition|(
operator|(
name|adv
operator|->
name|type
operator|&
name|ADV_VL
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|irq_no
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|irq_no
operator|<
name|ADV_MIN_IRQ_NO
operator|)
operator|||
operator|(
name|irq_no
operator|>
name|ADV_MAX_IRQ_NO
operator|)
condition|)
block|{
name|irq_no
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|irq_no
operator|-=
name|ADV_MIN_IRQ_NO
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|cfg_lsw
operator|=
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_CONFIG_LSW
argument_list|)
operator|&
literal|0xFFE3
expr_stmt|;
name|cfg_lsw
operator||=
literal|0x0010
expr_stmt|;
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_CONFIG_LSW
argument_list|,
name|cfg_lsw
argument_list|)
expr_stmt|;
name|adv_toggle_irq_act
argument_list|(
name|adv
argument_list|)
expr_stmt|;
name|cfg_lsw
operator|=
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_CONFIG_LSW
argument_list|)
operator|&
literal|0xFFE0
expr_stmt|;
name|cfg_lsw
operator||=
operator|(
name|irq_no
operator|&
literal|0x07
operator|)
operator|<<
literal|2
expr_stmt|;
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_CONFIG_LSW
argument_list|,
name|cfg_lsw
argument_list|)
expr_stmt|;
name|adv_toggle_irq_act
argument_list|(
name|adv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|adv
operator|->
name|type
operator|&
name|ADV_ISA
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|irq_no
operator|==
literal|15
condition|)
name|irq_no
operator|-=
literal|2
expr_stmt|;
name|irq_no
operator|-=
name|ADV_MIN_IRQ_NO
expr_stmt|;
name|cfg_lsw
operator|=
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_CONFIG_LSW
argument_list|)
operator|&
literal|0xFFF3
expr_stmt|;
name|cfg_lsw
operator||=
operator|(
name|irq_no
operator|&
literal|0x03
operator|)
operator|<<
literal|2
expr_stmt|;
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_CONFIG_LSW
argument_list|,
name|cfg_lsw
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|adv_get_chip_irq
argument_list|(
name|adv
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|adv_execute_scsi_queue
parameter_list|(
name|adv
parameter_list|,
name|scsiq
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|struct
name|adv_scsi_q
modifier|*
name|scsiq
decl_stmt|;
block|{
name|int
name|retval
decl_stmt|;
name|u_int
name|n_q_required
decl_stmt|;
name|int
name|s
decl_stmt|;
name|u_int32_t
name|addr
decl_stmt|;
name|u_int8_t
name|sg_entry_cnt
decl_stmt|;
name|u_int8_t
name|target_ix
decl_stmt|;
name|u_int8_t
name|sg_entry_cnt_minus_one
decl_stmt|;
name|u_int8_t
name|tid_no
decl_stmt|;
name|u_int8_t
name|sdtr_data
decl_stmt|;
name|u_int32_t
modifier|*
name|p_data_addr
decl_stmt|;
name|u_int32_t
modifier|*
name|p_data_bcount
decl_stmt|;
name|scsiq
operator|->
name|q1
operator|.
name|q_no
operator|=
literal|0
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
comment|/* Default to error case */
name|target_ix
operator|=
name|scsiq
operator|->
name|q2
operator|.
name|target_ix
expr_stmt|;
name|tid_no
operator|=
name|ADV_TIX_TO_TID
argument_list|(
name|target_ix
argument_list|)
expr_stmt|;
name|n_q_required
operator|=
literal|1
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
name|scsiq
operator|->
name|cdbptr
operator|->
name|opcode
operator|==
name|REQUEST_SENSE
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|adv
operator|->
name|initiate_sdtr
operator|&
name|scsiq
operator|->
name|q1
operator|.
name|target_id
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|adv
operator|->
name|sdtr_done
operator|&
name|scsiq
operator|->
name|q1
operator|.
name|target_id
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|int
name|sdtr_index
decl_stmt|;
name|sdtr_data
operator|=
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_SDTR_DATA_BEG
operator|+
name|tid_no
argument_list|)
expr_stmt|;
name|sdtr_index
operator|=
operator|(
name|sdtr_data
operator|>>
literal|4
operator|)
expr_stmt|;
name|adv_msgout_sdtr
argument_list|(
name|adv
argument_list|,
name|adv_sdtr_period_tbl
index|[
name|sdtr_index
index|]
argument_list|,
operator|(
name|sdtr_data
operator|&
name|ADV_SYN_MAX_OFFSET
operator|)
argument_list|)
expr_stmt|;
name|scsiq
operator|->
name|q1
operator|.
name|cntl
operator||=
operator|(
name|QC_MSG_OUT
operator||
name|QC_URGENT
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|scsiq
operator|->
name|q1
operator|.
name|cntl
operator|&
name|QC_SG_HEAD
operator|)
operator|!=
literal|0
condition|)
block|{
name|sg_entry_cnt
operator|=
name|scsiq
operator|->
name|sg_head
operator|->
name|entry_cnt
expr_stmt|;
name|sg_entry_cnt_minus_one
operator|=
name|sg_entry_cnt
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|sg_entry_cnt
operator|<=
literal|1
condition|)
name|panic
argument_list|(
literal|"adv_execute_scsi_queue: Queue with QC_SG_HEAD set but %d segs."
argument_list|,
name|sg_entry_cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sg_entry_cnt
operator|>
name|ADV_MAX_SG_LIST
condition|)
name|panic
argument_list|(
literal|"adv_execute_scsi_queue: Queue with too many segs."
argument_list|)
expr_stmt|;
if|if
condition|(
name|adv
operator|->
name|type
operator|&
operator|(
name|ADV_ISA
operator||
name|ADV_VL
operator||
name|ADV_EISA
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sg_entry_cnt_minus_one
condition|;
name|i
operator|++
control|)
block|{
name|addr
operator|=
name|scsiq
operator|->
name|sg_head
operator|->
name|sg_list
index|[
name|i
index|]
operator|.
name|addr
operator|+
name|scsiq
operator|->
name|sg_head
operator|->
name|sg_list
index|[
name|i
index|]
operator|.
name|bytes
expr_stmt|;
if|if
condition|(
operator|(
name|addr
operator|&
literal|0x0003
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"adv_execute_scsi_queue: SG with odd address or byte count"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|p_data_addr
operator|=
operator|&
name|scsiq
operator|->
name|sg_head
operator|->
name|sg_list
index|[
name|sg_entry_cnt_minus_one
index|]
operator|.
name|addr
expr_stmt|;
name|p_data_bcount
operator|=
operator|&
name|scsiq
operator|->
name|sg_head
operator|->
name|sg_list
index|[
name|sg_entry_cnt_minus_one
index|]
operator|.
name|bytes
expr_stmt|;
name|n_q_required
operator|=
name|adv_sgcount_to_qcount
argument_list|(
name|sg_entry_cnt
argument_list|)
expr_stmt|;
name|scsiq
operator|->
name|sg_head
operator|->
name|queue_cnt
operator|=
name|n_q_required
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|p_data_addr
operator|=
operator|&
name|scsiq
operator|->
name|q1
operator|.
name|data_addr
expr_stmt|;
name|p_data_bcount
operator|=
operator|&
name|scsiq
operator|->
name|q1
operator|.
name|data_cnt
expr_stmt|;
name|n_q_required
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|adv
operator|->
name|bug_fix_control
operator|&
name|ADV_BUG_FIX_ADD_ONE_BYTE
condition|)
block|{
name|addr
operator|=
operator|*
name|p_data_addr
operator|+
operator|*
name|p_data_bcount
expr_stmt|;
if|if
condition|(
operator|(
name|addr
operator|&
literal|0x0003
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * XXX Is this extra test (the one on data_cnt) really only supposed to apply 			 * to the non SG case or was it a bug due to code duplication? 			 */
if|if
condition|(
operator|(
name|scsiq
operator|->
name|q1
operator|.
name|cntl
operator|&
name|QC_SG_HEAD
operator|)
operator|!=
literal|0
operator|||
operator|(
name|scsiq
operator|->
name|q1
operator|.
name|data_cnt
operator|&
literal|0x01FF
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|scsiq
operator|->
name|cdbptr
operator|->
name|opcode
operator|==
name|READ_COMMAND
operator|)
operator|||
operator|(
name|scsiq
operator|->
name|cdbptr
operator|->
name|opcode
operator|==
name|READ_BIG
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|scsiq
operator|->
name|q2
operator|.
name|tag_code
operator|&
name|ADV_TAG_FLAG_ADD_ONE_BYTE
operator|)
operator|==
literal|0
condition|)
block|{
operator|(
operator|*
name|p_data_bcount
operator|)
operator|++
expr_stmt|;
name|scsiq
operator|->
name|q2
operator|.
name|tag_code
operator||=
name|ADV_TAG_FLAG_ADD_ONE_BYTE
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
operator|(
name|adv_get_num_free_queues
argument_list|(
name|adv
argument_list|,
name|n_q_required
argument_list|)
operator|>=
name|n_q_required
operator|)
operator|||
operator|(
operator|(
name|scsiq
operator|->
name|q1
operator|.
name|cntl
operator|&
name|QC_URGENT
operator|)
operator|!=
literal|0
operator|)
condition|)
name|retval
operator|=
name|adv_send_scsi_queue
argument_list|(
name|adv
argument_list|,
name|scsiq
argument_list|,
name|n_q_required
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|u_int8_t
name|adv_copy_lram_doneq
parameter_list|(
name|adv
parameter_list|,
name|q_addr
parameter_list|,
name|scsiq
parameter_list|,
name|max_dma_count
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|u_int16_t
name|q_addr
decl_stmt|;
name|struct
name|adv_q_done_info
modifier|*
name|scsiq
decl_stmt|;
name|u_int32_t
name|max_dma_count
decl_stmt|;
block|{
name|u_int16_t
name|val
decl_stmt|;
name|u_int8_t
name|sg_queue_cnt
decl_stmt|;
name|adv_get_q_info
argument_list|(
name|adv
argument_list|,
name|q_addr
operator|+
name|ADV_SCSIQ_DONE_INFO_BEG
argument_list|,
operator|(
name|u_int16_t
operator|*
operator|)
name|scsiq
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|scsiq
operator|->
name|d2
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|scsiq
operator|->
name|d3
argument_list|)
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
name|adv_adj_endian_qdone_info
argument_list|(
name|scsiq
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|val
operator|=
name|adv_read_lram_16
argument_list|(
name|adv
argument_list|,
name|q_addr
operator|+
name|ADV_SCSIQ_B_STATUS
argument_list|)
expr_stmt|;
name|scsiq
operator|->
name|q_status
operator|=
name|val
operator|&
literal|0xFF
expr_stmt|;
name|scsiq
operator|->
name|q_no
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|0XFF
expr_stmt|;
name|val
operator|=
name|adv_read_lram_16
argument_list|(
name|adv
argument_list|,
name|q_addr
operator|+
name|ADV_SCSIQ_B_CNTL
argument_list|)
expr_stmt|;
name|scsiq
operator|->
name|cntl
operator|=
name|val
operator|&
literal|0xFF
expr_stmt|;
name|sg_queue_cnt
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|val
operator|=
name|adv_read_lram_16
argument_list|(
name|adv
argument_list|,
name|q_addr
operator|+
name|ADV_SCSIQ_B_SENSE_LEN
argument_list|)
expr_stmt|;
name|scsiq
operator|->
name|sense_len
operator|=
name|val
operator|&
literal|0xFF
expr_stmt|;
name|scsiq
operator|->
name|user_def
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|scsiq
operator|->
name|remain_bytes
operator|=
name|adv_read_lram_32
argument_list|(
name|adv
argument_list|,
name|q_addr
operator|+
name|ADV_SCSIQ_DW_REMAIN_XFER_CNT
argument_list|)
expr_stmt|;
comment|/* 	 * XXX Is this just a safeguard or will the counter really 	 * have bogus upper bits? 	 */
name|scsiq
operator|->
name|remain_bytes
operator|&=
name|max_dma_count
expr_stmt|;
return|return
operator|(
name|sg_queue_cnt
operator|)
return|;
block|}
end_function

begin_function
name|int
name|adv_stop_execution
parameter_list|(
name|adv
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
block|{
name|int
name|count
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|ADV_STOP_CODE_B
argument_list|)
operator|==
literal|0
condition|)
block|{
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADV_STOP_CODE_B
argument_list|,
name|ADV_STOP_REQ_RISC_STOP
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|ADV_STOP_CODE_B
argument_list|)
operator|&
name|ADV_STOP_ACK_RISC_STOP
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|count
operator|++
operator|<
literal|20
condition|)
do|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|adv_is_chip_halted
parameter_list|(
name|adv
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_STATUS
argument_list|)
operator|&
name|ADV_CSW_HALTED
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ADV_INB
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_CTRL
argument_list|)
operator|&
name|ADV_CC_HALT
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XXX The numeric constants and the loops in this routine  * need to be documented.  */
end_comment

begin_function
name|void
name|adv_ack_interrupt
parameter_list|(
name|adv
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
block|{
name|u_int8_t
name|host_flag
decl_stmt|;
name|u_int8_t
name|risc_flag
decl_stmt|;
name|int
name|loop
decl_stmt|;
name|loop
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|risc_flag
operator|=
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_RISC_FLAG_B
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|++
operator|>
literal|0x7FFF
condition|)
block|{
break|break;
block|}
block|}
do|while
condition|(
operator|(
name|risc_flag
operator|&
name|ADV_RISC_FLAG_GEN_INT
operator|)
operator|!=
literal|0
condition|)
do|;
name|host_flag
operator|=
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_HOST_FLAG_B
argument_list|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_HOST_FLAG_B
argument_list|,
name|host_flag
operator||
name|ADV_HOST_FLAG_ACK_INT
argument_list|)
expr_stmt|;
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_STATUS
argument_list|,
name|ADV_CIW_INT_ACK
argument_list|)
expr_stmt|;
name|loop
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_STATUS
argument_list|)
operator|&
name|ADV_CSW_INT_PENDING
condition|)
block|{
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_STATUS
argument_list|,
name|ADV_CIW_INT_ACK
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|++
operator|>
literal|3
condition|)
block|{
break|break;
block|}
block|}
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_HOST_FLAG_B
argument_list|,
name|host_flag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle all conditions that may halt the chip waiting  * for us to intervene.  */
end_comment

begin_function
name|void
name|adv_isr_chip_halted
parameter_list|(
name|adv
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
block|{
name|u_int16_t
name|int_halt_code
decl_stmt|;
name|u_int8_t
name|halt_qp
decl_stmt|;
name|u_int16_t
name|halt_q_addr
decl_stmt|;
name|u_int8_t
name|target_ix
decl_stmt|;
name|u_int8_t
name|q_cntl
decl_stmt|;
name|u_int8_t
name|tid_no
decl_stmt|;
name|target_bit_vector
name|target_id
decl_stmt|;
name|target_bit_vector
name|scsi_busy
decl_stmt|;
name|u_int8_t
name|asyn_sdtr
decl_stmt|;
name|u_int8_t
name|sdtr_data
decl_stmt|;
name|int_halt_code
operator|=
name|adv_read_lram_16
argument_list|(
name|adv
argument_list|,
name|ADVV_HALTCODE_W
argument_list|)
expr_stmt|;
name|halt_qp
operator|=
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_CURCDB_B
argument_list|)
expr_stmt|;
name|halt_q_addr
operator|=
name|ADV_QNO_TO_QADDR
argument_list|(
name|halt_qp
argument_list|)
expr_stmt|;
name|target_ix
operator|=
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|halt_q_addr
operator|+
name|ADV_SCSIQ_B_TARGET_IX
argument_list|)
expr_stmt|;
name|q_cntl
operator|=
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|halt_q_addr
operator|+
name|ADV_SCSIQ_B_CNTL
argument_list|)
expr_stmt|;
name|tid_no
operator|=
name|ADV_TIX_TO_TID
argument_list|(
name|target_ix
argument_list|)
expr_stmt|;
name|target_id
operator|=
name|ADV_TID_TO_TARGET_ID
argument_list|(
name|tid_no
argument_list|)
expr_stmt|;
if|if
condition|(
name|adv
operator|->
name|needs_async_bug_fix
operator|&
name|target_id
condition|)
name|asyn_sdtr
operator|=
name|ASYN_SDTR_DATA_FIX
expr_stmt|;
else|else
name|asyn_sdtr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|int_halt_code
operator|==
name|ADV_HALT_EXTMSG_IN
condition|)
block|{
name|struct
name|sdtr_xmsg
name|sdtr_xmsg
decl_stmt|;
name|int
name|sdtr_accept
decl_stmt|;
name|adv_read_lram_16_multi
argument_list|(
name|adv
argument_list|,
name|ADVV_MSGIN_BEG
argument_list|,
operator|(
name|u_int16_t
operator|*
operator|)
operator|&
name|sdtr_xmsg
argument_list|,
sizeof|sizeof
argument_list|(
name|sdtr_xmsg
argument_list|)
operator|>>
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sdtr_xmsg
operator|.
name|msg_type
operator|==
name|MSG_EXTENDED
operator|)
operator|&&
operator|(
name|sdtr_xmsg
operator|.
name|msg_len
operator|==
name|MSG_EXT_SDTR_LEN
operator|)
condition|)
block|{
name|sdtr_accept
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|sdtr_xmsg
operator|.
name|msg_req
operator|==
name|MSG_EXT_SDTR
condition|)
block|{
if|if
condition|(
name|sdtr_xmsg
operator|.
name|req_ack_offset
operator|>
name|ADV_SYN_MAX_OFFSET
condition|)
block|{
name|sdtr_accept
operator|=
name|FALSE
expr_stmt|;
name|sdtr_xmsg
operator|.
name|req_ack_offset
operator|=
name|ADV_SYN_MAX_OFFSET
expr_stmt|;
block|}
name|sdtr_data
operator|=
name|adv_get_card_sync_setting
argument_list|(
name|sdtr_xmsg
operator|.
name|xfer_period
argument_list|,
name|sdtr_xmsg
operator|.
name|req_ack_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdtr_xmsg
operator|.
name|req_ack_offset
operator|==
literal|0
condition|)
block|{
name|q_cntl
operator|&=
operator|~
name|QC_MSG_OUT
expr_stmt|;
name|adv
operator|->
name|initiate_sdtr
operator|&=
operator|~
name|target_id
expr_stmt|;
name|adv
operator|->
name|sdtr_done
operator|&=
operator|~
name|target_id
expr_stmt|;
name|adv_set_chip_sdtr
argument_list|(
name|adv
argument_list|,
name|asyn_sdtr
argument_list|,
name|tid_no
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sdtr_data
operator|==
literal|0
condition|)
block|{
name|q_cntl
operator||=
name|QC_MSG_OUT
expr_stmt|;
name|adv
operator|->
name|initiate_sdtr
operator|&=
operator|~
name|target_id
expr_stmt|;
name|adv
operator|->
name|sdtr_done
operator|&=
operator|~
name|target_id
expr_stmt|;
name|adv_set_chip_sdtr
argument_list|(
name|adv
argument_list|,
name|asyn_sdtr
argument_list|,
name|tid_no
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sdtr_accept
operator|&&
operator|(
name|q_cntl
operator|&
name|QC_MSG_OUT
operator|)
condition|)
block|{
name|q_cntl
operator|&=
operator|~
name|QC_MSG_OUT
expr_stmt|;
name|adv
operator|->
name|sdtr_done
operator||=
name|target_id
expr_stmt|;
name|adv
operator|->
name|initiate_sdtr
operator||=
name|target_id
expr_stmt|;
name|adv
operator|->
name|needs_async_bug_fix
operator|&=
operator|~
name|target_id
expr_stmt|;
name|adv_set_chip_sdtr
argument_list|(
name|adv
argument_list|,
name|sdtr_data
argument_list|,
name|tid_no
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|q_cntl
operator||=
name|QC_MSG_OUT
expr_stmt|;
name|adv_msgout_sdtr
argument_list|(
name|adv
argument_list|,
name|sdtr_xmsg
operator|.
name|xfer_period
argument_list|,
name|sdtr_xmsg
operator|.
name|req_ack_offset
argument_list|)
expr_stmt|;
name|adv
operator|->
name|needs_async_bug_fix
operator|&=
operator|~
name|target_id
expr_stmt|;
name|adv_set_chip_sdtr
argument_list|(
name|adv
argument_list|,
name|sdtr_data
argument_list|,
name|tid_no
argument_list|)
expr_stmt|;
name|adv
operator|->
name|sdtr_done
operator||=
name|target_id
expr_stmt|;
name|adv
operator|->
name|initiate_sdtr
operator||=
name|target_id
expr_stmt|;
block|}
block|}
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|halt_q_addr
operator|+
name|ADV_SCSIQ_B_CNTL
argument_list|,
name|q_cntl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * XXX Hey, shouldn't we be rejecting any messages we don't understand? 		 *     The old code also did not un-halt the processor if it recieved 		 *     an extended message that it didn't understand.  That didn't 		 *     seem right, so I changed this routine to always un-halt the 		 *     processor at the end. 		 */
block|}
elseif|else
if|if
condition|(
name|int_halt_code
operator|==
name|ADV_HALT_CHK_CONDITION
condition|)
block|{
name|u_int8_t
name|tag_code
decl_stmt|;
name|u_int8_t
name|q_status
decl_stmt|;
name|q_cntl
operator||=
name|QC_REQ_SENSE
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|adv
operator|->
name|initiate_sdtr
operator|&
name|target_id
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|adv
operator|->
name|sdtr_done
operator|&
name|target_id
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|sdtr_data
operator|=
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_SDTR_DATA_BEG
operator|+
name|tid_no
argument_list|)
expr_stmt|;
comment|/* XXX Macrotize the extraction of the index from sdtr_data ??? */
name|adv_msgout_sdtr
argument_list|(
name|adv
argument_list|,
name|adv_sdtr_period_tbl
index|[
operator|(
name|sdtr_data
operator|>>
literal|4
operator|)
operator|&
literal|0x0F
index|]
argument_list|,
name|sdtr_data
operator|&
name|ADV_SYN_MAX_OFFSET
argument_list|)
expr_stmt|;
name|q_cntl
operator||=
name|QC_MSG_OUT
expr_stmt|;
block|}
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|halt_q_addr
operator|+
name|ADV_SCSIQ_B_CNTL
argument_list|,
name|q_cntl
argument_list|)
expr_stmt|;
comment|/* Don't tag request sense commands */
name|tag_code
operator|=
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|halt_q_addr
operator|+
name|ADV_SCSIQ_B_TAG_CODE
argument_list|)
expr_stmt|;
name|tag_code
operator|&=
operator|~
operator|(
name|MSG_SIMPLE_Q_TAG
operator||
name|MSG_HEAD_OF_Q_TAG
operator||
name|MSG_ORDERED_Q_TAG
operator|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|halt_q_addr
operator|+
name|ADV_SCSIQ_B_TAG_CODE
argument_list|,
name|tag_code
argument_list|)
expr_stmt|;
name|q_status
operator|=
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|halt_q_addr
operator|+
name|ADV_SCSIQ_B_STATUS
argument_list|)
expr_stmt|;
name|q_status
operator||=
operator|(
name|QS_READY
operator||
name|QS_BUSY
operator|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|halt_q_addr
operator|+
name|ADV_SCSIQ_B_STATUS
argument_list|,
name|q_status
argument_list|)
expr_stmt|;
name|scsi_busy
operator|=
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_SCSIBUSY_B
argument_list|)
expr_stmt|;
name|scsi_busy
operator|&=
operator|~
name|target_id
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_SCSIBUSY_B
argument_list|,
name|scsi_busy
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|int_halt_code
operator|==
name|ADV_HALT_SDTR_REJECTED
condition|)
block|{
name|struct
name|sdtr_xmsg
name|out_msg
decl_stmt|;
name|adv_read_lram_16_multi
argument_list|(
name|adv
argument_list|,
name|ADVV_MSGOUT_BEG
argument_list|,
operator|(
name|u_int16_t
operator|*
operator|)
operator|&
name|out_msg
argument_list|,
sizeof|sizeof
argument_list|(
name|out_msg
argument_list|)
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|out_msg
operator|.
name|msg_type
operator|==
name|MSG_EXTENDED
operator|)
operator|&&
operator|(
name|out_msg
operator|.
name|msg_len
operator|==
name|MSG_EXT_SDTR_LEN
operator|)
operator|&&
operator|(
name|out_msg
operator|.
name|msg_req
operator|==
name|MSG_EXT_SDTR
operator|)
condition|)
block|{
name|adv
operator|->
name|initiate_sdtr
operator|&=
operator|~
name|target_id
expr_stmt|;
name|adv
operator|->
name|sdtr_done
operator|&=
operator|~
name|target_id
expr_stmt|;
name|adv_set_chip_sdtr
argument_list|(
name|adv
argument_list|,
name|asyn_sdtr
argument_list|,
name|tid_no
argument_list|)
expr_stmt|;
block|}
name|q_cntl
operator|&=
operator|~
name|QC_MSG_OUT
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|halt_q_addr
operator|+
name|ADV_SCSIQ_B_CNTL
argument_list|,
name|q_cntl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|int_halt_code
operator|==
name|ADV_HALT_SS_QUEUE_FULL
condition|)
block|{
name|u_int8_t
name|cur_dvc_qng
decl_stmt|;
name|u_int8_t
name|scsi_status
decl_stmt|;
comment|/* 		 * XXX It would be nice if we could push the responsibility for handling 		 *     this situation onto the generic SCSI layer as other drivers do. 		 *     This would be done by completing the command with the status byte 		 *     set to QUEUE_FULL, whereupon it will request that any transactions 		 *     pending on the target that where scheduled after this one be aborted 		 *     (so as to maintain queue ordering) and the number of requests the 		 *     upper level will attempt to send this target will be reduced. 		 * 		 *     With this current strategy, am I guaranteed that once I unbusy the 		 *     target the queued up transactions will be sent in the order they 		 *     were queued?  If the ASC chip does a round-robin on all queued 		 *     transactions looking for queues to run, the order is not guaranteed. 		 */
name|scsi_status
operator|=
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|halt_q_addr
operator|+
name|ADV_SCSIQ_SCSI_STATUS
argument_list|)
expr_stmt|;
name|cur_dvc_qng
operator|=
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|ADV_QADR_BEG
operator|+
name|target_ix
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"adv%d: Queue full - target %d, active transactions %d\n"
argument_list|,
name|adv
operator|->
name|unit
argument_list|,
name|tid_no
argument_list|,
name|cur_dvc_qng
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX FIX LATER */
block|if ((cur_dvc_qng> 0)&& (adv->cur_dvc_qng[tid_no]> 0)) { 			scsi_busy = adv_read_lram_8(adv, ADVV_SCSIBUSY_B); 			scsi_busy |= target_id; 			adv_write_lram_8(adv, ADVV_SCSIBUSY_B, scsi_busy); 			asc_dvc->queue_full_or_busy |= target_id;  			if (scsi_status == SS_QUEUE_FULL) { 				if (cur_dvc_qng> ASC_MIN_TAGGED_CMD) { 					cur_dvc_qng -= 1; 					asc_dvc->max_dvc_qng[tid_no] = cur_dvc_qng;  					adv_write_lram_8(adv, ADVV_MAX_DVC_QNG_BEG + tid_no, 							 cur_dvc_qng); 				} 			} 		}
endif|#
directive|endif
block|}
name|adv_write_lram_16
argument_list|(
name|adv
argument_list|,
name|ADVV_HALTCODE_W
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Internal Routines */
end_comment

begin_function
specifier|static
name|void
name|adv_read_lram_16_multi
parameter_list|(
name|adv
parameter_list|,
name|s_addr
parameter_list|,
name|buffer
parameter_list|,
name|count
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|u_int16_t
name|s_addr
decl_stmt|;
name|u_int16_t
modifier|*
name|buffer
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_ADDR
argument_list|,
name|s_addr
argument_list|)
expr_stmt|;
name|ADV_INSW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_DATA
argument_list|,
name|buffer
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|adv_write_lram_16_multi
parameter_list|(
name|adv
parameter_list|,
name|s_addr
parameter_list|,
name|buffer
parameter_list|,
name|count
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|u_int16_t
name|s_addr
decl_stmt|;
name|u_int16_t
modifier|*
name|buffer
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_ADDR
argument_list|,
name|s_addr
argument_list|)
expr_stmt|;
name|ADV_OUTSW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_DATA
argument_list|,
name|buffer
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|adv_mset_lram_16
parameter_list|(
name|adv
parameter_list|,
name|s_addr
parameter_list|,
name|set_value
parameter_list|,
name|count
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|u_int16_t
name|s_addr
decl_stmt|;
name|u_int16_t
name|set_value
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_ADDR
argument_list|,
name|s_addr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_DATA
argument_list|,
name|set_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|adv_msum_lram_16
parameter_list|(
name|adv
parameter_list|,
name|s_addr
parameter_list|,
name|count
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|u_int16_t
name|s_addr
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
name|u_int32_t
name|sum
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|s_addr
operator|+=
literal|2
control|)
name|sum
operator|+=
name|adv_read_lram_16
argument_list|(
name|adv
argument_list|,
name|s_addr
argument_list|)
expr_stmt|;
return|return
operator|(
name|sum
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|adv_write_and_verify_lram_16
parameter_list|(
name|adv
parameter_list|,
name|addr
parameter_list|,
name|value
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|u_int16_t
name|addr
decl_stmt|;
name|u_int16_t
name|value
decl_stmt|;
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_DATA
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_DATA
argument_list|)
condition|)
name|retval
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|adv_read_lram_32
parameter_list|(
name|adv
parameter_list|,
name|addr
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|u_int16_t
name|addr
decl_stmt|;
block|{
name|u_int16_t
name|val_low
decl_stmt|,
name|val_high
decl_stmt|;
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
name|val_high
operator|=
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_DATA
argument_list|)
expr_stmt|;
name|val_low
operator|=
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_DATA
argument_list|)
expr_stmt|;
else|#
directive|else
name|val_low
operator|=
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_DATA
argument_list|)
expr_stmt|;
name|val_high
operator|=
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_DATA
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|(
operator|(
name|u_int32_t
operator|)
name|val_high
operator|<<
literal|16
operator|)
operator||
operator|(
name|u_int32_t
operator|)
name|val_low
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|adv_write_lram_32
parameter_list|(
name|adv
parameter_list|,
name|addr
parameter_list|,
name|value
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|u_int16_t
name|addr
decl_stmt|;
name|u_int32_t
name|value
decl_stmt|;
block|{
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_DATA
argument_list|,
call|(
name|u_int16_t
call|)
argument_list|(
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
literal|0xFFFF
argument_list|)
argument_list|)
expr_stmt|;
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_DATA
argument_list|,
call|(
name|u_int16_t
call|)
argument_list|(
name|value
operator|&
literal|0xFFFF
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_DATA
argument_list|,
call|(
name|u_int16_t
call|)
argument_list|(
name|value
operator|&
literal|0xFFFF
argument_list|)
argument_list|)
expr_stmt|;
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_DATA
argument_list|,
call|(
name|u_int16_t
call|)
argument_list|(
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
literal|0xFFFF
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|adv_write_lram_32_multi
parameter_list|(
name|adv
parameter_list|,
name|s_addr
parameter_list|,
name|buffer
parameter_list|,
name|count
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|u_int16_t
name|s_addr
decl_stmt|;
name|u_int32_t
modifier|*
name|buffer
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_ADDR
argument_list|,
name|s_addr
argument_list|)
expr_stmt|;
name|ADV_OUTSW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_DATA
argument_list|,
name|buffer
argument_list|,
name|count
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int16_t
name|adv_read_eeprom_16
parameter_list|(
name|adv
parameter_list|,
name|addr
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|u_int8_t
name|addr
decl_stmt|;
block|{
name|u_int16_t
name|read_wval
decl_stmt|;
name|u_int8_t
name|cmd_reg
decl_stmt|;
name|adv_write_eeprom_cmd_reg
argument_list|(
name|adv
argument_list|,
name|ADV_EEPROM_CMD_WRITE_DISABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|cmd_reg
operator|=
name|addr
operator||
name|ADV_EEPROM_CMD_READ
expr_stmt|;
name|adv_write_eeprom_cmd_reg
argument_list|(
name|adv
argument_list|,
name|cmd_reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|read_wval
operator|=
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_EEPROM_DATA
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
return|return
operator|(
name|read_wval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int16_t
name|adv_write_eeprom_16
parameter_list|(
name|adv
parameter_list|,
name|addr
parameter_list|,
name|value
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|u_int8_t
name|addr
decl_stmt|;
name|u_int16_t
name|value
decl_stmt|;
block|{
name|u_int16_t
name|read_value
decl_stmt|;
name|read_value
operator|=
name|adv_read_eeprom_16
argument_list|(
name|adv
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_value
operator|!=
name|value
condition|)
block|{
name|adv_write_eeprom_cmd_reg
argument_list|(
name|adv
argument_list|,
name|ADV_EEPROM_CMD_WRITE_ENABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_EEPROM_DATA
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|adv_write_eeprom_cmd_reg
argument_list|(
name|adv
argument_list|,
name|ADV_EEPROM_CMD_WRITE
operator||
name|addr
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|20
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|adv_write_eeprom_cmd_reg
argument_list|(
name|adv
argument_list|,
name|ADV_EEPROM_CMD_WRITE_DISABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|read_value
operator|=
name|adv_read_eeprom_16
argument_list|(
name|adv
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|read_value
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|adv_write_eeprom_cmd_reg
parameter_list|(
name|adv
parameter_list|,
name|cmd_reg
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|u_int8_t
name|cmd_reg
decl_stmt|;
block|{
name|u_int8_t
name|read_back
decl_stmt|;
name|int
name|retry
decl_stmt|;
name|retry
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|ADV_OUTB
argument_list|(
name|adv
argument_list|,
name|ADV_EEPROM_CMD
argument_list|,
name|cmd_reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|read_back
operator|=
name|ADV_INB
argument_list|(
name|adv
argument_list|,
name|ADV_EEPROM_CMD
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_back
operator|==
name|cmd_reg
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|retry
operator|++
operator|>
name|ADV_EEPROM_MAX_RETRY
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|adv_set_eeprom_config_once
parameter_list|(
name|adv
parameter_list|,
name|eeprom_config
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|struct
name|adv_eeprom_config
modifier|*
name|eeprom_config
decl_stmt|;
block|{
name|int
name|n_error
decl_stmt|;
name|u_int16_t
modifier|*
name|wbuf
decl_stmt|;
name|u_int16_t
name|sum
decl_stmt|;
name|u_int8_t
name|s_addr
decl_stmt|;
name|u_int8_t
name|cfg_beg
decl_stmt|;
name|u_int8_t
name|cfg_end
decl_stmt|;
name|wbuf
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|eeprom_config
expr_stmt|;
name|n_error
operator|=
literal|0
expr_stmt|;
name|sum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|s_addr
operator|=
literal|0
init|;
name|s_addr
operator|<
literal|2
condition|;
name|s_addr
operator|++
operator|,
name|wbuf
operator|++
control|)
block|{
name|sum
operator|+=
operator|*
name|wbuf
expr_stmt|;
if|if
condition|(
operator|*
name|wbuf
operator|!=
name|adv_write_eeprom_16
argument_list|(
name|adv
argument_list|,
name|s_addr
argument_list|,
operator|*
name|wbuf
argument_list|)
condition|)
block|{
name|n_error
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|adv
operator|->
name|type
operator|&
name|ADV_VL
condition|)
block|{
name|cfg_beg
operator|=
name|ADV_EEPROM_CFG_BEG_VL
expr_stmt|;
name|cfg_end
operator|=
name|ADV_EEPROM_MAX_ADDR_VL
expr_stmt|;
block|}
else|else
block|{
name|cfg_beg
operator|=
name|ADV_EEPROM_CFG_BEG
expr_stmt|;
name|cfg_end
operator|=
name|ADV_EEPROM_MAX_ADDR
expr_stmt|;
block|}
for|for
control|(
name|s_addr
operator|=
name|cfg_beg
init|;
name|s_addr
operator|<=
operator|(
name|cfg_end
operator|-
literal|1
operator|)
condition|;
name|s_addr
operator|++
operator|,
name|wbuf
operator|++
control|)
block|{
name|sum
operator|+=
operator|*
name|wbuf
expr_stmt|;
if|if
condition|(
operator|*
name|wbuf
operator|!=
name|adv_write_eeprom_16
argument_list|(
name|adv
argument_list|,
name|s_addr
argument_list|,
operator|*
name|wbuf
argument_list|)
condition|)
block|{
name|n_error
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|wbuf
operator|=
name|sum
expr_stmt|;
if|if
condition|(
name|sum
operator|!=
name|adv_write_eeprom_16
argument_list|(
name|adv
argument_list|,
name|s_addr
argument_list|,
name|sum
argument_list|)
condition|)
block|{
name|n_error
operator|++
expr_stmt|;
block|}
name|wbuf
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|eeprom_config
expr_stmt|;
for|for
control|(
name|s_addr
operator|=
literal|0
init|;
name|s_addr
operator|<
literal|2
condition|;
name|s_addr
operator|++
operator|,
name|wbuf
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|wbuf
operator|!=
name|adv_read_eeprom_16
argument_list|(
name|adv
argument_list|,
name|s_addr
argument_list|)
condition|)
block|{
name|n_error
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|s_addr
operator|=
name|cfg_beg
init|;
name|s_addr
operator|<=
name|cfg_end
condition|;
name|s_addr
operator|++
operator|,
name|wbuf
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|wbuf
operator|!=
name|adv_read_eeprom_16
argument_list|(
name|adv
argument_list|,
name|s_addr
argument_list|)
condition|)
block|{
name|n_error
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|n_error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|adv_load_microcode
parameter_list|(
name|adv
parameter_list|,
name|s_addr
parameter_list|,
name|mcode_buf
parameter_list|,
name|mcode_size
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|u_int16_t
name|s_addr
decl_stmt|;
name|u_int16_t
modifier|*
name|mcode_buf
decl_stmt|;
name|u_int16_t
name|mcode_size
decl_stmt|;
block|{
name|u_int32_t
name|chksum
decl_stmt|;
name|u_int16_t
name|mcode_lram_size
decl_stmt|;
name|u_int16_t
name|mcode_chksum
decl_stmt|;
name|mcode_lram_size
operator|=
name|mcode_size
operator|>>
literal|1
expr_stmt|;
comment|/* XXX Why zero the memory just before you write the whole thing?? */
comment|/* adv_mset_lram_16(adv, s_addr, 0, mcode_lram_size);*/
name|adv_write_lram_16_multi
argument_list|(
name|adv
argument_list|,
name|s_addr
argument_list|,
name|mcode_buf
argument_list|,
name|mcode_lram_size
argument_list|)
expr_stmt|;
name|chksum
operator|=
name|adv_msum_lram_16
argument_list|(
name|adv
argument_list|,
name|s_addr
argument_list|,
name|mcode_lram_size
argument_list|)
expr_stmt|;
name|mcode_chksum
operator|=
operator|(
name|u_int16_t
operator|)
name|adv_msum_lram_16
argument_list|(
name|adv
argument_list|,
name|ADV_CODE_SEC_BEG
argument_list|,
operator|(
operator|(
name|mcode_size
operator|-
name|s_addr
operator|-
name|ADV_CODE_SEC_BEG
operator|)
operator|>>
literal|1
operator|)
argument_list|)
expr_stmt|;
name|adv_write_lram_16
argument_list|(
name|adv
argument_list|,
name|ADVV_MCODE_CHKSUM_W
argument_list|,
name|mcode_chksum
argument_list|)
expr_stmt|;
name|adv_write_lram_16
argument_list|(
name|adv
argument_list|,
name|ADVV_MCODE_SIZE_W
argument_list|,
name|mcode_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|chksum
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|adv_init_lram
parameter_list|(
name|adv
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
block|{
name|u_int8_t
name|i
decl_stmt|;
name|u_int16_t
name|s_addr
decl_stmt|;
name|adv_mset_lram_16
argument_list|(
name|adv
argument_list|,
name|ADV_QADR_BEG
argument_list|,
literal|0
argument_list|,
call|(
name|u_int16_t
call|)
argument_list|(
operator|(
operator|(
operator|(
name|int
operator|)
name|adv
operator|->
name|max_openings
operator|+
literal|2
operator|+
literal|1
operator|)
operator|*
literal|64
operator|)
operator|>>
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|ADV_MIN_ACTIVE_QNO
expr_stmt|;
name|s_addr
operator|=
name|ADV_QADR_BEG
operator|+
name|ADV_QBLK_SIZE
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|s_addr
operator|+
name|ADV_SCSIQ_B_FWD
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|s_addr
operator|+
name|ADV_SCSIQ_B_BWD
argument_list|,
name|adv
operator|->
name|max_openings
argument_list|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|s_addr
operator|+
name|ADV_SCSIQ_B_QNO
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|s_addr
operator|+=
name|ADV_QBLK_SIZE
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|adv
operator|->
name|max_openings
condition|;
name|i
operator|++
operator|,
name|s_addr
operator|+=
name|ADV_QBLK_SIZE
control|)
block|{
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|s_addr
operator|+
name|ADV_SCSIQ_B_FWD
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|s_addr
operator|+
name|ADV_SCSIQ_B_BWD
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|s_addr
operator|+
name|ADV_SCSIQ_B_QNO
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|s_addr
operator|+
name|ADV_SCSIQ_B_FWD
argument_list|,
name|ADV_QLINK_END
argument_list|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|s_addr
operator|+
name|ADV_SCSIQ_B_BWD
argument_list|,
name|adv
operator|->
name|max_openings
operator|-
literal|1
argument_list|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|s_addr
operator|+
name|ADV_SCSIQ_B_QNO
argument_list|,
name|adv
operator|->
name|max_openings
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|s_addr
operator|+=
name|ADV_QBLK_SIZE
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<=
name|adv
operator|->
name|max_openings
operator|+
literal|3
condition|;
name|i
operator|++
operator|,
name|s_addr
operator|+=
name|ADV_QBLK_SIZE
control|)
block|{
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|s_addr
operator|+
name|ADV_SCSIQ_B_FWD
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|s_addr
operator|+
name|ADV_SCSIQ_B_BWD
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|s_addr
operator|+
name|ADV_SCSIQ_B_QNO
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|adv_init_microcode_var
parameter_list|(
name|adv
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|ADV_MAX_TID
condition|;
name|i
operator|++
control|)
block|{
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_SDTR_DATA_BEG
operator|+
name|i
argument_list|,
name|adv
operator|->
name|sdtr_data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|adv_init_qlink_var
argument_list|(
name|adv
argument_list|)
expr_stmt|;
comment|/* XXX Again, what about wide busses??? */
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_DISC_ENABLE_B
argument_list|,
name|adv
operator|->
name|disc_enable
argument_list|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_HOSTSCSI_ID_B
argument_list|,
literal|0x01
operator|<<
name|adv
operator|->
name|scsi_id
argument_list|)
expr_stmt|;
comment|/* What are the extra 8 bytes for?? */
name|adv_write_lram_32
argument_list|(
name|adv
argument_list|,
name|ADVV_OVERRUN_PADDR_D
argument_list|,
name|vtophys
argument_list|(
operator|&
operator|(
name|adv
operator|->
name|overrun_buf
index|[
literal|0
index|]
operator|)
argument_list|)
operator|+
literal|8
argument_list|)
expr_stmt|;
name|adv_write_lram_32
argument_list|(
name|adv
argument_list|,
name|ADVV_OVERRUN_BSIZE_D
argument_list|,
name|ADV_OVERRUN_BSIZE
operator|-
literal|8
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* If we're going to print anything, RCS ids are more meaningful */
block|mcode_date = adv_read_lram_16(adv, ADVV_MC_DATE_W); 	mcode_version = adv_read_lram_16(adv, ADVV_MC_VER_W);
endif|#
directive|endif
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_REG_PROG_COUNTER
argument_list|,
name|ADV_MCODE_START_ADDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_REG_PROG_COUNTER
argument_list|)
operator|!=
name|ADV_MCODE_START_ADDR
condition|)
block|{
name|printf
argument_list|(
literal|"adv%d: Unable to set program counter. Aborting.\n"
argument_list|,
name|adv
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|adv_start_chip
argument_list|(
name|adv
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"adv%d: Unable to start on board processor. Aborting.\n"
argument_list|,
name|adv
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|adv_init_qlink_var
parameter_list|(
name|adv
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|u_int16_t
name|lram_addr
decl_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_NEXTRDY_B
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_DONENEXT_B
argument_list|,
name|adv
operator|->
name|max_openings
argument_list|)
expr_stmt|;
name|adv_write_lram_16
argument_list|(
name|adv
argument_list|,
name|ADVV_FREE_Q_HEAD_W
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|adv_write_lram_16
argument_list|(
name|adv
argument_list|,
name|ADVV_DONE_Q_TAIL_W
argument_list|,
name|adv
operator|->
name|max_openings
argument_list|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_BUSY_QHEAD_B
argument_list|,
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|int
operator|)
name|adv
operator|->
name|max_openings
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_DISC1_QHEAD_B
argument_list|,
call|(
name|u_int8_t
call|)
argument_list|(
operator|(
name|int
operator|)
name|adv
operator|->
name|max_openings
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_TOTAL_READY_Q_B
argument_list|,
name|adv
operator|->
name|max_openings
argument_list|)
expr_stmt|;
name|adv_write_lram_16
argument_list|(
name|adv
argument_list|,
name|ADVV_ASCDVC_ERR_CODE_W
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|adv_write_lram_16
argument_list|(
name|adv
argument_list|,
name|ADVV_HALTCODE_W
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_STOP_CODE_B
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_SCSIBUSY_B
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_WTM_FLAG_B
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_CDBCNT_B
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lram_addr
operator|=
name|ADV_QADR_BEG
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
operator|,
name|lram_addr
operator|+=
literal|2
control|)
name|adv_write_lram_16
argument_list|(
name|adv
argument_list|,
name|lram_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|adv_disable_interrupt
parameter_list|(
name|adv
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
block|{
name|u_int16_t
name|cfg
decl_stmt|;
name|cfg
operator|=
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_CONFIG_LSW
argument_list|)
expr_stmt|;
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_CONFIG_LSW
argument_list|,
name|cfg
operator|&
operator|~
name|ADV_CFG_LSW_HOST_INT_ON
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|adv_enable_interrupt
parameter_list|(
name|adv
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
block|{
name|u_int16_t
name|cfg
decl_stmt|;
name|cfg
operator|=
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_CONFIG_LSW
argument_list|)
expr_stmt|;
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_CONFIG_LSW
argument_list|,
name|cfg
operator||
name|ADV_CFG_LSW_HOST_INT_ON
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|adv_toggle_irq_act
parameter_list|(
name|adv
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
block|{
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_STATUS
argument_list|,
name|ADV_CIW_IRQ_ACT
argument_list|)
expr_stmt|;
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_STATUS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|UNUSED
end_if

begin_function
specifier|static
name|void
name|adv_start_execution
parameter_list|(
name|adv
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
block|{
if|if
condition|(
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|ADV_STOP_CODE_B
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADV_STOP_CODE_B
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|adv_start_chip
parameter_list|(
name|adv
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
block|{
name|ADV_OUTB
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_CTRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_STATUS
argument_list|)
operator|&
name|ADV_CSW_HALTED
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|adv_stop_chip
parameter_list|(
name|adv
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
block|{
name|u_int8_t
name|cc_val
decl_stmt|;
name|cc_val
operator|=
name|ADV_INB
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_CTRL
argument_list|)
operator|&
operator|(
operator|~
operator|(
name|ADV_CC_SINGLE_STEP
operator||
name|ADV_CC_TEST
operator||
name|ADV_CC_DIAG
operator|)
operator|)
expr_stmt|;
name|ADV_OUTB
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_CTRL
argument_list|,
name|cc_val
operator||
name|ADV_CC_HALT
argument_list|)
expr_stmt|;
name|adv_set_chip_ih
argument_list|(
name|adv
argument_list|,
name|ADV_INS_HALT
argument_list|)
expr_stmt|;
name|adv_set_chip_ih
argument_list|(
name|adv
argument_list|,
name|ADV_INS_RFLAG_WTM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_STATUS
argument_list|)
operator|&
name|ADV_CSW_HALTED
operator|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|adv_set_chip_ih
parameter_list|(
name|adv
parameter_list|,
name|ins_code
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|u_int16_t
name|ins_code
decl_stmt|;
block|{
name|adv_set_bank
argument_list|(
name|adv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_REG_IH
argument_list|,
name|ins_code
argument_list|)
expr_stmt|;
name|adv_set_bank
argument_list|(
name|adv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|adv_set_bank
parameter_list|(
name|adv
parameter_list|,
name|bank
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|u_int8_t
name|bank
decl_stmt|;
block|{
name|u_int8_t
name|control
decl_stmt|;
comment|/* 	 * Start out with the bank reset to 0 	 */
name|control
operator|=
name|ADV_INB
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_CTRL
argument_list|)
operator|&
operator|(
operator|~
operator|(
name|ADV_CC_SINGLE_STEP
operator||
name|ADV_CC_TEST
operator||
name|ADV_CC_DIAG
operator||
name|ADV_CC_SCSI_RESET
operator||
name|ADV_CC_CHIP_RESET
operator||
name|ADV_CC_BANK_ONE
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|bank
operator|==
literal|1
condition|)
block|{
name|control
operator||=
name|ADV_CC_BANK_ONE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bank
operator|==
literal|2
condition|)
block|{
name|control
operator||=
name|ADV_CC_DIAG
operator||
name|ADV_CC_BANK_ONE
expr_stmt|;
block|}
name|ADV_OUTB
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_CTRL
argument_list|,
name|control
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|UNUSED
end_if

begin_function
specifier|static
name|u_int8_t
name|adv_get_chip_scsi_ctrl
parameter_list|(
name|adv
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
block|{
name|u_int8_t
name|scsi_ctrl
decl_stmt|;
name|adv_set_bank
argument_list|(
name|adv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|scsi_ctrl
operator|=
name|ADV_INB
argument_list|(
name|adv
argument_list|,
name|ADV_REG_SC
argument_list|)
expr_stmt|;
name|adv_set_bank
argument_list|(
name|adv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|scsi_ctrl
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|adv_sgcount_to_qcount
parameter_list|(
name|sgcount
parameter_list|)
name|int
name|sgcount
decl_stmt|;
block|{
name|int
name|n_sg_list_qs
decl_stmt|;
name|n_sg_list_qs
operator|=
operator|(
operator|(
name|sgcount
operator|-
literal|1
operator|)
operator|/
name|ADV_SG_LIST_PER_Q
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|sgcount
operator|-
literal|1
operator|)
operator|%
name|ADV_SG_LIST_PER_Q
operator|)
operator|!=
literal|0
condition|)
name|n_sg_list_qs
operator|++
expr_stmt|;
return|return
operator|(
name|n_sg_list_qs
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XXX Looks like more padding issues in this routine as well.  *     There has to be a way to turn this into an insw.  */
end_comment

begin_function
specifier|static
name|void
name|adv_get_q_info
parameter_list|(
name|adv
parameter_list|,
name|s_addr
parameter_list|,
name|inbuf
parameter_list|,
name|words
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|u_int16_t
name|s_addr
decl_stmt|;
name|u_int16_t
modifier|*
name|inbuf
decl_stmt|;
name|int
name|words
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_ADDR
argument_list|,
name|s_addr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
operator|,
name|inbuf
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|5
condition|)
block|{
continue|continue;
block|}
operator|*
name|inbuf
operator|=
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_DATA
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|u_int
name|adv_get_num_free_queues
parameter_list|(
name|adv
parameter_list|,
name|n_qs
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|u_int8_t
name|n_qs
decl_stmt|;
block|{
name|u_int
name|cur_used_qs
decl_stmt|;
name|u_int
name|cur_free_qs
decl_stmt|;
if|if
condition|(
name|n_qs
operator|==
literal|1
condition|)
name|cur_used_qs
operator|=
name|adv
operator|->
name|cur_active
operator|+
name|adv
operator|->
name|openings_needed
operator|+
name|ADV_MIN_FREE_Q
expr_stmt|;
else|else
name|cur_used_qs
operator|=
name|adv
operator|->
name|cur_active
operator|+
name|ADV_MIN_FREE_Q
expr_stmt|;
if|if
condition|(
operator|(
name|cur_used_qs
operator|+
name|n_qs
operator|)
operator|<=
name|adv
operator|->
name|max_openings
condition|)
block|{
name|cur_free_qs
operator|=
name|adv
operator|->
name|max_openings
operator|-
name|cur_used_qs
expr_stmt|;
return|return
operator|(
name|cur_free_qs
operator|)
return|;
block|}
if|if
condition|(
name|n_qs
operator|>
literal|1
condition|)
if|if
condition|(
name|n_qs
operator|>
name|adv
operator|->
name|openings_needed
condition|)
name|adv
operator|->
name|openings_needed
operator|=
name|n_qs
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|adv_alloc_free_queues
parameter_list|(
name|adv
parameter_list|,
name|free_q_head
parameter_list|,
name|n_free_q
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|u_int8_t
name|free_q_head
decl_stmt|;
name|u_int8_t
name|n_free_q
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_free_q
condition|;
name|i
operator|++
control|)
block|{
name|free_q_head
operator|=
name|adv_alloc_free_queue
argument_list|(
name|adv
argument_list|,
name|free_q_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_q_head
operator|==
name|ADV_QLINK_END
condition|)
break|break;
block|}
return|return
operator|(
name|free_q_head
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|adv_alloc_free_queue
parameter_list|(
name|adv
parameter_list|,
name|free_q_head
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|u_int8_t
name|free_q_head
decl_stmt|;
block|{
name|u_int16_t
name|q_addr
decl_stmt|;
name|u_int8_t
name|next_qp
decl_stmt|;
name|u_int8_t
name|q_status
decl_stmt|;
name|next_qp
operator|=
name|ADV_QLINK_END
expr_stmt|;
name|q_addr
operator|=
name|ADV_QNO_TO_QADDR
argument_list|(
name|free_q_head
argument_list|)
expr_stmt|;
name|q_status
operator|=
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|q_addr
operator|+
name|ADV_SCSIQ_B_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|q_status
operator|&
name|QS_READY
operator|)
operator|==
literal|0
condition|)
name|next_qp
operator|=
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|q_addr
operator|+
name|ADV_SCSIQ_B_FWD
argument_list|)
expr_stmt|;
return|return
operator|(
name|next_qp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|adv_send_scsi_queue
parameter_list|(
name|adv
parameter_list|,
name|scsiq
parameter_list|,
name|n_q_required
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|struct
name|adv_scsi_q
modifier|*
name|scsiq
decl_stmt|;
name|u_int8_t
name|n_q_required
decl_stmt|;
block|{
name|u_int8_t
name|free_q_head
decl_stmt|;
name|u_int8_t
name|next_qp
decl_stmt|;
name|u_int8_t
name|tid_no
decl_stmt|;
name|u_int8_t
name|target_ix
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
name|target_ix
operator|=
name|scsiq
operator|->
name|q2
operator|.
name|target_ix
expr_stmt|;
name|tid_no
operator|=
name|ADV_TIX_TO_TID
argument_list|(
name|target_ix
argument_list|)
expr_stmt|;
name|free_q_head
operator|=
name|adv_read_lram_16
argument_list|(
name|adv
argument_list|,
name|ADVV_FREE_Q_HEAD_W
argument_list|)
operator|&
literal|0xFF
expr_stmt|;
if|if
condition|(
operator|(
name|next_qp
operator|=
name|adv_alloc_free_queues
argument_list|(
name|adv
argument_list|,
name|free_q_head
argument_list|,
name|n_q_required
argument_list|)
operator|)
operator|!=
name|ADV_QLINK_END
condition|)
block|{
if|if
condition|(
name|n_q_required
operator|>
literal|1
condition|)
block|{
comment|/* 			 * Only reset the shortage value when processing 			 * a "normal" request and not error recovery or 			 * other requests that dip into our reserved queues. 			 * Generally speaking, a normal request will need more 			 * than one queue. 			 */
name|adv
operator|->
name|openings_needed
operator|=
literal|0
expr_stmt|;
block|}
name|scsiq
operator|->
name|q1
operator|.
name|q_no
operator|=
name|free_q_head
expr_stmt|;
comment|/* 		 * Now that we know our Q number, point our sense 		 * buffer pointer to an area below 16M if we are 		 * an ISA adapter. 		 */
if|if
condition|(
name|adv
operator|->
name|sense_buffers
operator|!=
name|NULL
condition|)
name|scsiq
operator|->
name|q1
operator|.
name|sense_addr
operator|=
operator|(
name|u_int32_t
operator|)
name|vtophys
argument_list|(
operator|&
operator|(
name|adv
operator|->
name|sense_buffers
index|[
name|free_q_head
index|]
operator|)
argument_list|)
expr_stmt|;
name|adv_put_ready_sg_list_queue
argument_list|(
name|adv
argument_list|,
name|scsiq
argument_list|,
name|free_q_head
argument_list|)
expr_stmt|;
name|adv_write_lram_16
argument_list|(
name|adv
argument_list|,
name|ADVV_FREE_Q_HEAD_W
argument_list|,
name|next_qp
argument_list|)
expr_stmt|;
name|adv
operator|->
name|cur_active
operator|+=
name|n_q_required
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|adv_put_ready_sg_list_queue
parameter_list|(
name|adv
parameter_list|,
name|scsiq
parameter_list|,
name|q_no
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|struct
name|adv_scsi_q
modifier|*
name|scsiq
decl_stmt|;
name|u_int8_t
name|q_no
decl_stmt|;
block|{
name|u_int8_t
name|sg_list_dwords
decl_stmt|;
name|u_int8_t
name|sg_index
decl_stmt|,
name|i
decl_stmt|;
name|u_int8_t
name|sg_entry_cnt
decl_stmt|;
name|u_int8_t
name|next_qp
decl_stmt|;
name|u_int16_t
name|q_addr
decl_stmt|;
name|struct
name|adv_sg_head
modifier|*
name|sg_head
decl_stmt|;
name|struct
name|adv_sg_list_q
name|scsi_sg_q
decl_stmt|;
name|sg_head
operator|=
name|scsiq
operator|->
name|sg_head
expr_stmt|;
if|if
condition|(
name|sg_head
condition|)
block|{
name|sg_entry_cnt
operator|=
name|sg_head
operator|->
name|entry_cnt
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|sg_entry_cnt
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"adv_put_ready_sg_list_queue: ScsiQ with a SG list but only one element"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scsiq
operator|->
name|q1
operator|.
name|cntl
operator|&
name|QC_SG_HEAD
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"adv_put_ready_sg_list_queue: ScsiQ with a SG list but QC_SG_HEAD not set"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|q_addr
operator|=
name|ADV_QNO_TO_QADDR
argument_list|(
name|q_no
argument_list|)
expr_stmt|;
name|sg_index
operator|=
literal|1
expr_stmt|;
name|scsiq
operator|->
name|q1
operator|.
name|sg_queue_cnt
operator|=
name|sg_head
operator|->
name|queue_cnt
expr_stmt|;
name|scsi_sg_q
operator|.
name|sg_head_qp
operator|=
name|q_no
expr_stmt|;
name|scsi_sg_q
operator|.
name|cntl
operator|=
name|QCSG_SG_XFER_LIST
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sg_head
operator|->
name|queue_cnt
condition|;
name|i
operator|++
control|)
block|{
name|u_int8_t
name|segs_this_q
decl_stmt|;
if|if
condition|(
name|sg_entry_cnt
operator|>
name|ADV_SG_LIST_PER_Q
condition|)
name|segs_this_q
operator|=
name|ADV_SG_LIST_PER_Q
expr_stmt|;
else|else
block|{
comment|/* This will be the last segment then */
name|segs_this_q
operator|=
name|sg_entry_cnt
expr_stmt|;
name|scsi_sg_q
operator|.
name|cntl
operator||=
name|QCSG_SG_XFER_END
expr_stmt|;
block|}
name|scsi_sg_q
operator|.
name|seq_no
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|sg_list_dwords
operator|=
name|segs_this_q
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|scsi_sg_q
operator|.
name|sg_list_cnt
operator|=
name|segs_this_q
expr_stmt|;
name|scsi_sg_q
operator|.
name|sg_cur_list_cnt
operator|=
name|segs_this_q
expr_stmt|;
block|}
else|else
block|{
name|scsi_sg_q
operator|.
name|sg_list_cnt
operator|=
name|segs_this_q
operator|-
literal|1
expr_stmt|;
name|scsi_sg_q
operator|.
name|sg_cur_list_cnt
operator|=
name|segs_this_q
operator|-
literal|1
expr_stmt|;
block|}
name|next_qp
operator|=
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|q_addr
operator|+
name|ADV_SCSIQ_B_FWD
argument_list|)
expr_stmt|;
name|scsi_sg_q
operator|.
name|q_no
operator|=
name|next_qp
expr_stmt|;
name|q_addr
operator|=
name|ADV_QNO_TO_QADDR
argument_list|(
name|next_qp
argument_list|)
expr_stmt|;
name|adv_write_lram_16_multi
argument_list|(
name|adv
argument_list|,
name|q_addr
operator|+
name|ADV_SCSIQ_SGHD_CPY_BEG
argument_list|,
operator|(
name|u_int16_t
operator|*
operator|)
operator|&
name|scsi_sg_q
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_sg_q
argument_list|)
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|adv_write_lram_32_multi
argument_list|(
name|adv
argument_list|,
name|q_addr
operator|+
name|ADV_SGQ_LIST_BEG
argument_list|,
operator|(
name|u_int32_t
operator|*
operator|)
operator|&
name|sg_head
operator|->
name|sg_list
index|[
name|sg_index
index|]
argument_list|,
name|sg_list_dwords
argument_list|)
expr_stmt|;
name|sg_entry_cnt
operator|-=
name|segs_this_q
expr_stmt|;
name|sg_index
operator|+=
name|ADV_SG_LIST_PER_Q
expr_stmt|;
block|}
block|}
name|adv_put_ready_queue
argument_list|(
name|adv
argument_list|,
name|scsiq
argument_list|,
name|q_no
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|adv_put_ready_queue
parameter_list|(
name|adv
parameter_list|,
name|scsiq
parameter_list|,
name|q_no
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|struct
name|adv_scsi_q
modifier|*
name|scsiq
decl_stmt|;
name|u_int8_t
name|q_no
decl_stmt|;
block|{
name|u_int16_t
name|q_addr
decl_stmt|;
name|u_int8_t
name|tid_no
decl_stmt|;
name|u_int8_t
name|sdtr_data
decl_stmt|;
name|u_int8_t
name|syn_period_ix
decl_stmt|;
name|u_int8_t
name|syn_offset
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|adv
operator|->
name|initiate_sdtr
operator|&
name|scsiq
operator|->
name|q1
operator|.
name|target_id
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|adv
operator|->
name|sdtr_done
operator|&
name|scsiq
operator|->
name|q1
operator|.
name|target_id
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|tid_no
operator|=
name|ADV_TIX_TO_TID
argument_list|(
name|scsiq
operator|->
name|q2
operator|.
name|target_ix
argument_list|)
expr_stmt|;
name|sdtr_data
operator|=
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_SDTR_DATA_BEG
operator|+
name|tid_no
argument_list|)
expr_stmt|;
name|syn_period_ix
operator|=
operator|(
name|sdtr_data
operator|>>
literal|4
operator|)
operator|&
operator|(
name|ADV_SYN_XFER_NO
operator|-
literal|1
operator|)
expr_stmt|;
name|syn_offset
operator|=
name|sdtr_data
operator|&
name|ADV_SYN_MAX_OFFSET
expr_stmt|;
name|adv_msgout_sdtr
argument_list|(
name|adv
argument_list|,
name|adv_sdtr_period_tbl
index|[
name|syn_period_ix
index|]
argument_list|,
name|syn_offset
argument_list|)
expr_stmt|;
name|scsiq
operator|->
name|q1
operator|.
name|cntl
operator||=
name|QC_MSG_OUT
expr_stmt|;
block|}
name|q_addr
operator|=
name|ADV_QNO_TO_QADDR
argument_list|(
name|q_no
argument_list|)
expr_stmt|;
name|scsiq
operator|->
name|q1
operator|.
name|status
operator|=
name|QS_FREE
expr_stmt|;
name|adv_write_lram_16_multi
argument_list|(
name|adv
argument_list|,
name|q_addr
operator|+
name|ADV_SCSIQ_CDB_BEG
argument_list|,
operator|(
name|u_int16_t
operator|*
operator|)
name|scsiq
operator|->
name|cdbptr
argument_list|,
name|scsiq
operator|->
name|q2
operator|.
name|cdb_len
operator|>>
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
name|adv_adj_scsiq_endian
argument_list|(
name|scsiq
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|adv_put_scsiq
argument_list|(
name|adv
argument_list|,
name|q_addr
operator|+
name|ADV_SCSIQ_CPY_BEG
argument_list|,
operator|(
name|u_int16_t
operator|*
operator|)
operator|&
name|scsiq
operator|->
name|q1
operator|.
name|cntl
argument_list|,
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|scsiq
operator|->
name|q1
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|scsiq
operator|->
name|q2
argument_list|)
operator|)
operator|/
literal|2
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|CC_WRITE_IO_COUNT
name|adv_write_lram_16
argument_list|(
name|adv
argument_list|,
name|q_addr
operator|+
name|ADV_SCSIQ_W_REQ_COUNT
argument_list|,
name|adv
operator|->
name|req_count
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|CC_CLEAR_DMA_REMAIN
name|adv_write_lram_32
argument_list|(
name|adv
argument_list|,
name|q_addr
operator|+
name|ADV_SCSIQ_DW_REMAIN_XFER_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|adv_write_lram_32
argument_list|(
name|adv
argument_list|,
name|q_addr
operator|+
name|ADV_SCSIQ_DW_REMAIN_XFER_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|adv_write_lram_16
argument_list|(
name|adv
argument_list|,
name|q_addr
operator|+
name|ADV_SCSIQ_B_STATUS
argument_list|,
operator|(
name|scsiq
operator|->
name|q1
operator|.
name|q_no
operator|<<
literal|8
operator|)
operator||
name|QS_READY
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|adv_put_scsiq
parameter_list|(
name|adv
parameter_list|,
name|s_addr
parameter_list|,
name|buffer
parameter_list|,
name|words
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|u_int16_t
name|s_addr
decl_stmt|;
name|u_int16_t
modifier|*
name|buffer
decl_stmt|;
name|int
name|words
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* 	 * XXX This routine makes *gross* assumptions 	 * about padding in the data structures. 	 * Either the data structures should have explicit 	 * padding members added, or they should have padding 	 * turned off via compiler attributes depending on 	 * which yields better overall performance.  My hunch 	 * would be that turning off padding would be the 	 * faster approach as an outsw is much faster than 	 * this crude loop and accessing un-aligned data 	 * members isn't *that* expensive.  The other choice 	 * would be to modify the ASC script so that the 	 * the adv_scsiq_1 structure can be re-arranged so 	 * padding isn't required. 	 */
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_ADDR
argument_list|,
name|s_addr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
operator|,
name|buffer
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|2
operator|||
name|i
operator|==
literal|10
condition|)
block|{
continue|continue;
block|}
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_DATA
argument_list|,
operator|*
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|adv_msgout_sdtr
parameter_list|(
name|adv
parameter_list|,
name|sdtr_period
parameter_list|,
name|sdtr_offset
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|u_int8_t
name|sdtr_period
decl_stmt|;
name|u_int8_t
name|sdtr_offset
decl_stmt|;
block|{
name|struct
name|sdtr_xmsg
name|sdtr_buf
decl_stmt|;
name|sdtr_buf
operator|.
name|msg_type
operator|=
name|MSG_EXTENDED
expr_stmt|;
name|sdtr_buf
operator|.
name|msg_len
operator|=
name|MSG_EXT_SDTR_LEN
expr_stmt|;
name|sdtr_buf
operator|.
name|msg_req
operator|=
name|MSG_EXT_SDTR
expr_stmt|;
name|sdtr_buf
operator|.
name|xfer_period
operator|=
name|sdtr_period
expr_stmt|;
name|sdtr_offset
operator|&=
name|ADV_SYN_MAX_OFFSET
expr_stmt|;
name|sdtr_buf
operator|.
name|req_ack_offset
operator|=
name|sdtr_offset
expr_stmt|;
name|adv_write_lram_16_multi
argument_list|(
name|adv
argument_list|,
name|ADVV_MSGOUT_BEG
argument_list|,
operator|(
name|u_int16_t
operator|*
operator|)
operator|&
name|sdtr_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|sdtr_buf
argument_list|)
operator|/
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
name|adv_get_card_sync_setting
argument_list|(
name|sdtr_period
argument_list|,
name|sdtr_offset
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|adv_get_card_sync_setting
parameter_list|(
name|period
parameter_list|,
name|offset
parameter_list|)
name|u_int8_t
name|period
decl_stmt|;
name|u_int8_t
name|offset
decl_stmt|;
block|{
name|u_int
name|i
decl_stmt|;
if|if
condition|(
name|period
operator|>=
name|adv_sdtr_period_tbl
index|[
literal|0
index|]
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|adv_sdtr_period_tbl
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|period
operator|<=
name|adv_sdtr_period_tbl
index|[
name|i
index|]
condition|)
return|return
operator|(
operator|(
name|adv_sdtr_period_tbl
index|[
name|i
index|]
operator|<<
literal|4
operator|)
operator||
name|offset
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|adv_set_chip_sdtr
parameter_list|(
name|adv
parameter_list|,
name|sdtr_data
parameter_list|,
name|tid_no
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|u_int8_t
name|sdtr_data
decl_stmt|;
name|u_int8_t
name|tid_no
decl_stmt|;
block|{
name|ADV_OUTB
argument_list|(
name|adv
argument_list|,
name|ADV_SYN_OFFSET
argument_list|,
name|sdtr_data
argument_list|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_SDTR_DONE_BEG
operator|+
name|tid_no
argument_list|,
name|sdtr_data
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

