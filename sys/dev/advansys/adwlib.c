begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Low level routines for Second Generation  * Advanced Systems Inc. SCSI controllers chips  *  * Copyright (c) 1998 Justin Gibbs.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *      $Id$  */
end_comment

begin_comment
comment|/*  * Ported from:  * advansys.c - Linux Host Driver for AdvanSys SCSI Adapters  *       * Copyright (c) 1995-1998 Advanced System Products, Inc.  * All Rights Reserved.  *     * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that redistributions of source  * code retain the above copyright notice and this comment without  * modification.  */
end_comment

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus_pio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus_memio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<dev/advansys/adwlib.h>
end_include

begin_decl_stmt
name|struct
name|adw_eeprom
name|adw_default_eeprom
init|=
block|{
name|ADW_EEPROM_BIOS_ENABLE
block|,
comment|/* cfg_lsw */
literal|0x0000
block|,
comment|/* cfg_msw */
literal|0xFFFF
block|,
comment|/* disc_enable */
literal|0xFFFF
block|,
comment|/* wdtr_able */
literal|0xFFFF
block|,
comment|/* sdtr_able */
literal|0xFFFF
block|,
comment|/* start_motor */
literal|0xFFFF
block|,
comment|/* tagqng_able */
literal|0xFFFF
block|,
comment|/* bios_scan */
literal|0
block|,
comment|/* scam_tolerant */
literal|7
block|,
comment|/* adapter_scsi_id */
literal|0
block|,
comment|/* bios_boot_delay */
literal|3
block|,
comment|/* scsi_reset_delay */
literal|0
block|,
comment|/* bios_id_lun */
literal|0
block|,
comment|/* termination */
literal|0
block|,
comment|/* reserved1 */
block|{
comment|/* Bios Ctrl */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|, 	}
block|,
literal|0xFFFF
block|,
comment|/* ultra_able */
literal|0
block|,
comment|/* reserved2 */
name|ADW_DEF_MAX_HOST_QNG
block|,
comment|/* max_host_qng */
name|ADW_DEF_MAX_DVC_QNG
block|,
comment|/* max_dvc_qng */
literal|0
block|,
comment|/* dvc_cntl */
literal|0
block|,
comment|/* bug_fix */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* serial_number */
literal|0
block|,
comment|/* check_sum */
block|{
comment|/* oem_name[16] */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
comment|/* dvc_err_code */
literal|0
block|,
comment|/* adv_err_code */
literal|0
block|,
comment|/* adv_err_addr */
literal|0
block|,
comment|/* saved_dvc_err_code */
literal|0
block|,
comment|/* saved_adv_err_code */
literal|0
block|,
comment|/* saved_adv_err_addr */
literal|0
comment|/* num_of_err */
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|u_int16_t
name|adw_eeprom_read_16
parameter_list|(
name|struct
name|adw_softc
modifier|*
name|adw
parameter_list|,
name|int
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|adw_eeprom_write_16
parameter_list|(
name|struct
name|adw_softc
modifier|*
name|adw
parameter_list|,
name|int
name|addr
parameter_list|,
name|u_int
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|adw_eeprom_wait
parameter_list|(
name|struct
name|adw_softc
modifier|*
name|adw
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|adw_find_signature
parameter_list|(
name|bus_space_tag_t
name|tag
parameter_list|,
name|bus_space_handle_t
name|bsh
parameter_list|)
block|{
if|if
condition|(
name|bus_space_read_1
argument_list|(
name|tag
argument_list|,
name|bsh
argument_list|,
name|ADW_SIGNATURE_BYTE
argument_list|)
operator|==
name|ADW_CHIP_ID_BYTE
operator|&&
name|bus_space_read_2
argument_list|(
name|tag
argument_list|,
name|bsh
argument_list|,
name|ADW_SIGNATURE_WORD
argument_list|)
operator|==
name|ADW_CHIP_ID_WORD
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reset Chip.  */
end_comment

begin_function
name|void
name|adw_reset_chip
parameter_list|(
name|struct
name|adw_softc
modifier|*
name|adw
parameter_list|)
block|{
name|adw_outw
argument_list|(
name|adw
argument_list|,
name|ADW_CTRL_REG
argument_list|,
name|ADW_CTRL_REG_CMD_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|adw_outw
argument_list|(
name|adw
argument_list|,
name|ADW_CTRL_REG
argument_list|,
name|ADW_CTRL_REG_CMD_WR_IO_REG
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize Chip registers. 	 */
name|adw_outb
argument_list|(
name|adw
argument_list|,
name|ADW_MEM_CFG
argument_list|,
name|adw_inb
argument_list|(
name|adw
argument_list|,
name|ADW_MEM_CFG
argument_list|)
operator||
name|ADW_MEM_CFG_RAM_SZ_8KB
argument_list|)
expr_stmt|;
name|adw_outw
argument_list|(
name|adw
argument_list|,
name|ADW_SCSI_CFG1
argument_list|,
name|adw_inw
argument_list|(
name|adw
argument_list|,
name|ADW_SCSI_CFG1
argument_list|)
operator|&
operator|~
name|ADW_SCSI_CFG1_BIG_ENDIAN
argument_list|)
expr_stmt|;
comment|/* 	 * Setting the START_CTL_EM_FU 3:2 bits sets a FIFO threshold 	 * of 128 bytes. This register is only accessible to the host. 	 */
name|adw_outb
argument_list|(
name|adw
argument_list|,
name|ADW_DMA_CFG0
argument_list|,
name|ADW_DMA_CFG0_START_CTL_EM_FU
operator||
name|ADW_DMA_CFG0_READ_CMD_MRM
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read the specified EEPROM location  */
end_comment

begin_function
specifier|static
name|u_int16_t
name|adw_eeprom_read_16
parameter_list|(
name|struct
name|adw_softc
modifier|*
name|adw
parameter_list|,
name|int
name|addr
parameter_list|)
block|{
name|adw_outw
argument_list|(
name|adw
argument_list|,
name|ADW_EEP_CMD
argument_list|,
name|ADW_EEP_CMD_READ
operator||
name|addr
argument_list|)
expr_stmt|;
name|adw_eeprom_wait
argument_list|(
name|adw
argument_list|)
expr_stmt|;
return|return
operator|(
name|adw_inw
argument_list|(
name|adw
argument_list|,
name|ADW_EEP_DATA
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|adw_eeprom_write_16
parameter_list|(
name|struct
name|adw_softc
modifier|*
name|adw
parameter_list|,
name|int
name|addr
parameter_list|,
name|u_int
name|data
parameter_list|)
block|{
name|adw_outw
argument_list|(
name|adw
argument_list|,
name|ADW_EEP_DATA
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|adw_outw
argument_list|(
name|adw
argument_list|,
name|ADW_EEP_CMD
argument_list|,
name|ADW_EEP_CMD_WRITE
operator||
name|addr
argument_list|)
expr_stmt|;
name|adw_eeprom_wait
argument_list|(
name|adw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Wait for and EEPROM command to complete  */
end_comment

begin_function
specifier|static
name|void
name|adw_eeprom_wait
parameter_list|(
name|struct
name|adw_softc
modifier|*
name|adw
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ADW_EEP_DELAY_MS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|adw_inw
argument_list|(
name|adw
argument_list|,
name|ADW_EEP_CMD
argument_list|)
operator|&
name|ADW_EEP_CMD_DONE
operator|)
operator|!=
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|ADW_EEP_DELAY_MS
condition|)
name|panic
argument_list|(
literal|"%s: Timedout Reading EEPROM"
argument_list|,
name|adw_name
argument_list|(
name|adw
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read EEPROM configuration into the specified buffer.  *  * Return a checksum based on the EEPROM configuration read.  */
end_comment

begin_function
name|u_int16_t
name|adw_eeprom_read
parameter_list|(
name|struct
name|adw_softc
modifier|*
name|adw
parameter_list|,
name|struct
name|adw_eeprom
modifier|*
name|eep_buf
parameter_list|)
block|{
name|u_int16_t
modifier|*
name|wbuf
decl_stmt|;
name|u_int16_t
name|wval
decl_stmt|;
name|u_int16_t
name|chksum
decl_stmt|;
name|int
name|eep_addr
decl_stmt|;
name|wbuf
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|eep_buf
expr_stmt|;
name|chksum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|eep_addr
operator|=
name|ADW_EEP_DVC_CFG_BEGIN
init|;
name|eep_addr
operator|<
name|ADW_EEP_DVC_CFG_END
condition|;
name|eep_addr
operator|++
operator|,
name|wbuf
operator|++
control|)
block|{
name|wval
operator|=
name|adw_eeprom_read_16
argument_list|(
name|adw
argument_list|,
name|eep_addr
argument_list|)
expr_stmt|;
name|chksum
operator|+=
name|wval
expr_stmt|;
operator|*
name|wbuf
operator|=
name|wval
expr_stmt|;
block|}
comment|/* checksum field is not counted in the checksum */
operator|*
name|wbuf
operator|=
name|adw_eeprom_read_16
argument_list|(
name|adw
argument_list|,
name|eep_addr
argument_list|)
expr_stmt|;
name|wbuf
operator|++
expr_stmt|;
comment|/* Driver seeprom variables are not included in the checksum */
for|for
control|(
name|eep_addr
operator|=
name|ADW_EEP_DVC_CTL_BEGIN
init|;
name|eep_addr
operator|<
name|ADW_EEP_MAX_WORD_ADDR
condition|;
name|eep_addr
operator|++
operator|,
name|wbuf
operator|++
control|)
operator|*
name|wbuf
operator|=
name|adw_eeprom_read_16
argument_list|(
name|adw
argument_list|,
name|eep_addr
argument_list|)
expr_stmt|;
return|return
operator|(
name|chksum
operator|)
return|;
block|}
end_function

begin_function
name|void
name|adw_eeprom_write
parameter_list|(
name|struct
name|adw_softc
modifier|*
name|adw
parameter_list|,
name|struct
name|adw_eeprom
modifier|*
name|eep_buf
parameter_list|)
block|{
name|u_int16_t
modifier|*
name|wbuf
decl_stmt|;
name|u_int16_t
name|addr
decl_stmt|;
name|u_int16_t
name|chksum
decl_stmt|;
name|wbuf
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|eep_buf
expr_stmt|;
name|chksum
operator|=
literal|0
expr_stmt|;
name|adw_outw
argument_list|(
name|adw
argument_list|,
name|ADW_EEP_CMD
argument_list|,
name|ADW_EEP_CMD_WRITE_ABLE
argument_list|)
expr_stmt|;
name|adw_eeprom_wait
argument_list|(
name|adw
argument_list|)
expr_stmt|;
comment|/* 	 * Write EEPROM until checksum. 	 */
for|for
control|(
name|addr
operator|=
name|ADW_EEP_DVC_CFG_BEGIN
init|;
name|addr
operator|<
name|ADW_EEP_DVC_CFG_END
condition|;
name|addr
operator|++
operator|,
name|wbuf
operator|++
control|)
block|{
name|chksum
operator|+=
operator|*
name|wbuf
expr_stmt|;
name|adw_eeprom_write_16
argument_list|(
name|adw
argument_list|,
name|addr
argument_list|,
operator|*
name|wbuf
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Write calculated EEPROM checksum 	 */
name|adw_eeprom_write_16
argument_list|(
name|adw
argument_list|,
name|addr
argument_list|,
name|chksum
argument_list|)
expr_stmt|;
comment|/* skip over buffer's checksum */
name|wbuf
operator|++
expr_stmt|;
comment|/* 	 * Write the rest. 	 */
for|for
control|(
name|addr
operator|=
name|ADW_EEP_DVC_CTL_BEGIN
init|;
name|addr
operator|<
name|ADW_EEP_MAX_WORD_ADDR
condition|;
name|addr
operator|++
operator|,
name|wbuf
operator|++
control|)
name|adw_eeprom_write_16
argument_list|(
name|adw
argument_list|,
name|addr
argument_list|,
operator|*
name|wbuf
argument_list|)
expr_stmt|;
name|adw_outw
argument_list|(
name|adw
argument_list|,
name|ADW_EEP_CMD
argument_list|,
name|ADW_EEP_CMD_WRITE_DISABLE
argument_list|)
expr_stmt|;
name|adw_eeprom_wait
argument_list|(
name|adw
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|adw_init_chip
parameter_list|(
name|struct
name|adw_softc
modifier|*
name|adw
parameter_list|,
name|u_int
name|term_scsicfg1
parameter_list|)
block|{
name|u_int8_t
name|biosmem
index|[
name|ADW_MC_BIOSLEN
index|]
decl_stmt|;
name|u_int16_t
modifier|*
name|mcodebuf
decl_stmt|;
name|u_int
name|addr
decl_stmt|;
name|u_int
name|end_addr
decl_stmt|;
name|u_int
name|checksum
decl_stmt|;
name|u_int
name|scsicfg1
decl_stmt|;
name|u_int
name|i
decl_stmt|;
comment|/* 	 * Save the RISC memory BIOS region before writing the microcode. 	 * The BIOS may already be loaded and using its RISC LRAM region 	 * so its region must be saved and restored. 	 */
for|for
control|(
name|addr
operator|=
literal|0
init|;
name|addr
operator|<
name|ADW_MC_BIOSLEN
condition|;
name|addr
operator|++
control|)
name|biosmem
index|[
name|addr
index|]
operator|=
name|adw_lram_read_8
argument_list|(
name|adw
argument_list|,
name|ADW_MC_BIOSMEM
operator|+
name|addr
argument_list|)
expr_stmt|;
comment|/* 	 * Load the Microcode.  Casting here was less work than 	 * reformatting the supplied microcode into an array of 	 * 16bit values... 	 */
name|mcodebuf
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|adw_mcode
expr_stmt|;
name|adw_outw
argument_list|(
name|adw
argument_list|,
name|ADW_RAM_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|addr
operator|=
literal|0
init|;
name|addr
operator|<
name|adw_mcode_size
operator|/
literal|2
condition|;
name|addr
operator|++
control|)
name|adw_outw
argument_list|(
name|adw
argument_list|,
name|ADW_RAM_DATA
argument_list|,
name|mcodebuf
index|[
name|addr
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Clear the rest of LRAM. 	 */
for|for
control|(
init|;
name|addr
operator|<
name|ADW_CONDOR_MEMSIZE
operator|/
literal|2
condition|;
name|addr
operator|++
control|)
name|adw_outw
argument_list|(
name|adw
argument_list|,
name|ADW_RAM_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Verify the microcode checksum. 	 */
name|checksum
operator|=
literal|0
expr_stmt|;
name|adw_outw
argument_list|(
name|adw
argument_list|,
name|ADW_RAM_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|addr
operator|=
literal|0
init|;
name|addr
operator|<
name|adw_mcode_size
operator|/
literal|2
condition|;
name|addr
operator|++
control|)
name|checksum
operator|+=
name|adw_inw
argument_list|(
name|adw
argument_list|,
name|ADW_RAM_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|checksum
operator|!=
name|adw_mcode_chksum
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Firmware load failed!\n"
argument_list|,
name|adw_name
argument_list|(
name|adw
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Restore the RISC memory BIOS region. 	 */
for|for
control|(
name|addr
operator|=
literal|0
init|;
name|addr
operator|<
name|ADW_MC_BIOSLEN
condition|;
name|addr
operator|++
control|)
name|adw_lram_write_8
argument_list|(
name|adw
argument_list|,
name|addr
operator|+
name|ADW_MC_BIOSLEN
argument_list|,
name|biosmem
index|[
name|addr
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate and write the microcode code checksum to 	 * the microcode code checksum location. 	 */
name|addr
operator|=
name|adw_lram_read_16
argument_list|(
name|adw
argument_list|,
name|ADW_MC_CODE_BEGIN_ADDR
argument_list|)
operator|/
literal|2
expr_stmt|;
name|end_addr
operator|=
name|adw_lram_read_16
argument_list|(
name|adw
argument_list|,
name|ADW_MC_CODE_END_ADDR
argument_list|)
operator|/
literal|2
expr_stmt|;
name|checksum
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|addr
operator|<
name|end_addr
condition|;
name|addr
operator|++
control|)
name|checksum
operator|+=
name|mcodebuf
index|[
name|addr
index|]
expr_stmt|;
name|adw_lram_write_16
argument_list|(
name|adw
argument_list|,
name|ADW_MC_CODE_CHK_SUM
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize microcode operating variables 	 */
name|adw_lram_write_16
argument_list|(
name|adw
argument_list|,
name|ADW_MC_ADAPTER_SCSI_ID
argument_list|,
name|adw
operator|->
name|initiator_id
argument_list|)
expr_stmt|;
comment|/* 	 * Leave WDTR and SDTR negotiation disabled until the XPT has 	 * informed us of device capabilities, but do set the ultra mask 	 * in case we receive an SDTR request from the target before we 	 * negotiate.  We turn on tagged queuing at the microcode level 	 * for all devices, and modulate this on a per command basis. 	 */
name|adw_lram_write_16
argument_list|(
name|adw
argument_list|,
name|ADW_MC_ULTRA_ABLE
argument_list|,
name|adw
operator|->
name|user_ultra
argument_list|)
expr_stmt|;
name|adw_lram_write_16
argument_list|(
name|adw
argument_list|,
name|ADW_MC_DISC_ENABLE
argument_list|,
name|adw
operator|->
name|user_discenb
argument_list|)
expr_stmt|;
name|adw_lram_write_16
argument_list|(
name|adw
argument_list|,
name|ADW_MC_TAGQNG_ABLE
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Set SCSI_CFG0 Microcode Default Value. 	 * 	 * The microcode will set the SCSI_CFG0 register using this value 	 * after it is started. 	 */
name|adw_lram_write_16
argument_list|(
name|adw
argument_list|,
name|ADW_MC_DEFAULT_SCSI_CFG0
argument_list|,
name|ADW_SCSI_CFG0_PARITY_EN
operator||
name|ADW_SCSI_CFG0_SEL_TMO_LONG
operator||
name|ADW_SCSI_CFG0_OUR_ID_EN
operator||
name|adw
operator|->
name|initiator_id
argument_list|)
expr_stmt|;
comment|/* 	 * Determine SCSI_CFG1 Microcode Default Value. 	 * 	 * The microcode will set the SCSI_CFG1 register using this value 	 * after it is started below. 	 */
name|scsicfg1
operator|=
name|adw_inw
argument_list|(
name|adw
argument_list|,
name|ADW_SCSI_CFG1
argument_list|)
expr_stmt|;
comment|/* 	 * If all three connectors are in use, return an error. 	 */
if|if
condition|(
operator|(
name|scsicfg1
operator|&
name|ADW_SCSI_CFG1_ILLEGAL_CABLE_CONF_A_MASK
operator|)
operator|==
literal|0
operator|||
operator|(
name|scsicfg1
operator|&
name|ADW_SCSI_CFG1_ILLEGAL_CABLE_CONF_B_MASK
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Illegal Cable Config!\n"
argument_list|,
name|adw_name
argument_list|(
name|adw
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Only Two Ports may be used at a time!\n"
argument_list|,
name|adw_name
argument_list|(
name|adw
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * If the internal narrow cable is reversed all of the SCSI_CTRL 	 * register signals will be set. Check for and return an error if 	 * this condition is found. 	 */
if|if
condition|(
operator|(
name|adw_inw
argument_list|(
name|adw
argument_list|,
name|ADW_SCSI_CTRL
argument_list|)
operator|&
literal|0x3F07
operator|)
operator|==
literal|0x3F07
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Illegal Cable Config!\n"
argument_list|,
name|adw_name
argument_list|(
name|adw
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Internal cable is reversed!\n"
argument_list|,
name|adw_name
argument_list|(
name|adw
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * If this is a differential board and a single-ended device 	 * is attached to one of the connectors, return an error. 	 */
if|if
condition|(
operator|(
name|scsicfg1
operator|&
name|ADW_SCSI_CFG1_DIFF_MODE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|scsicfg1
operator|&
name|ADW_SCSI_CFG1_DIFF_SENSE
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: A Single Ended Device is attached to our "
literal|"differential bus!\n"
argument_list|,
name|adw_name
argument_list|(
name|adw
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Perform automatic termination control if desired. 	 */
if|if
condition|(
name|term_scsicfg1
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|scsicfg1
operator|&
name|ADW_SCSI_CFG1_CABLE_DETECT
condition|)
block|{
case|case
operator|(
name|ADW_SCSI_CFG1_INT16_MASK
operator||
name|ADW_SCSI_CFG1_INT8_MASK
operator|)
case|:
case|case
operator|(
name|ADW_SCSI_CFG1_INT16_MASK
operator||
name|ADW_SCSI_CFG1_INT8_MASK
operator||
name|ADW_SCSI_CFG1_EXT8_MASK
operator|)
case|:
case|case
operator|(
name|ADW_SCSI_CFG1_INT16_MASK
operator||
name|ADW_SCSI_CFG1_INT8_MASK
operator||
name|ADW_SCSI_CFG1_EXT16_MASK
operator|)
case|:
case|case
operator|(
name|ADW_SCSI_CFG1_INT16_MASK
operator||
name|ADW_SCSI_CFG1_EXT8_MASK
operator||
name|ADW_SCSI_CFG1_EXT16_MASK
operator|)
case|:
case|case
operator|(
name|ADW_SCSI_CFG1_INT8_MASK
operator||
name|ADW_SCSI_CFG1_EXT8_MASK
operator||
name|ADW_SCSI_CFG1_EXT16_MASK
operator|)
case|:
case|case
operator|(
name|ADW_SCSI_CFG1_INT16_MASK
operator||
name|ADW_SCSI_CFG1_INT8_MASK
operator||
name|ADW_SCSI_CFG1_EXT8_MASK
operator||
name|ADW_SCSI_CFG1_EXT16_MASK
operator|)
case|:
comment|/* Two out of three cables missing.  Both on. */
name|term_scsicfg1
operator||=
name|ADW_SCSI_CFG1_TERM_CTL_L
operator||
name|ADW_SCSI_CFG1_TERM_CTL_H
expr_stmt|;
break|break;
case|case
operator|(
name|ADW_SCSI_CFG1_INT16_MASK
operator|)
case|:
case|case
operator|(
name|ADW_SCSI_CFG1_INT16_MASK
operator||
name|ADW_SCSI_CFG1_EXT8_MASK
operator|)
case|:
case|case
operator|(
name|ADW_SCSI_CFG1_INT16_MASK
operator||
name|ADW_SCSI_CFG1_EXT16_MASK
operator|)
case|:
case|case
operator|(
name|ADW_SCSI_CFG1_INT8_MASK
operator||
name|ADW_SCSI_CFG1_EXT16_MASK
operator|)
case|:
case|case
operator|(
name|ADW_SCSI_CFG1_EXT8_MASK
operator||
name|ADW_SCSI_CFG1_EXT16_MASK
operator|)
case|:
comment|/* No two 16bit cables present.  High on. */
name|term_scsicfg1
operator||=
name|ADW_SCSI_CFG1_TERM_CTL_H
expr_stmt|;
break|break;
case|case
operator|(
name|ADW_SCSI_CFG1_INT8_MASK
operator|)
case|:
case|case
operator|(
name|ADW_SCSI_CFG1_INT8_MASK
operator||
name|ADW_SCSI_CFG1_EXT8_MASK
operator|)
case|:
comment|/* Wide -> Wide or Narrow -> Wide. Both off */
break|break;
block|}
block|}
comment|/* Tell the user about our decission */
switch|switch
condition|(
name|term_scsicfg1
operator|&
name|ADW_SCSI_CFG1_TERM_CTL_MASK
condition|)
block|{
case|case
name|ADW_SCSI_CFG1_TERM_CTL_MASK
case|:
name|printf
argument_list|(
literal|"High& Low Termination Enabled, "
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADW_SCSI_CFG1_TERM_CTL_H
case|:
name|printf
argument_list|(
literal|"High Termination Enabled, "
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADW_SCSI_CFG1_TERM_CTL_L
case|:
name|printf
argument_list|(
literal|"Low Termination Enabled, "
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* 	 * Invert the TERM_CTL_H and TERM_CTL_L bits and then 	 * set 'scsicfg1'. The TERM_POL bit does not need to be 	 * referenced, because the hardware internally inverts 	 * the Termination High and Low bits if TERM_POL is set. 	 */
name|term_scsicfg1
operator|=
operator|~
name|term_scsicfg1
operator|&
name|ADW_SCSI_CFG1_TERM_CTL_MASK
expr_stmt|;
name|scsicfg1
operator|&=
operator|~
name|ADW_SCSI_CFG1_TERM_CTL_MASK
expr_stmt|;
name|scsicfg1
operator||=
name|term_scsicfg1
operator||
name|ADW_SCSI_CFG1_TERM_CTL_MANUAL
expr_stmt|;
comment|/* 	 * Set SCSI_CFG1 Microcode Default Value 	 * 	 * Set filter value and possibly modified termination control 	 * bits in the Microcode SCSI_CFG1 Register Value. 	 * 	 * The microcode will set the SCSI_CFG1 register using this value 	 * after it is started below. 	 */
name|adw_lram_write_16
argument_list|(
name|adw
argument_list|,
name|ADW_MC_DEFAULT_SCSI_CFG1
argument_list|,
name|scsicfg1
operator||
name|ADW_SCSI_CFG1_FLTR_11_TO_20NS
argument_list|)
expr_stmt|;
comment|/* 	 * Only accept selections on our initiator target id. 	 * This may change in target mode scenarios... 	 */
name|adw_lram_write_16
argument_list|(
name|adw
argument_list|,
name|ADW_MC_DEFAULT_SEL_MASK
argument_list|,
operator|(
literal|0x01
operator|<<
name|adw
operator|->
name|initiator_id
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Link all the RISC Queue Lists together in a doubly-linked 	 * NULL terminated list. 	 * 	 * Skip the NULL (0) queue which is not used. 	 */
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|addr
operator|=
name|ADW_MC_RISC_Q_LIST_BASE
operator|+
name|ADW_MC_RISC_Q_LIST_SIZE
init|;
name|i
operator|<
name|ADW_MC_RISC_Q_TOTAL_CNT
condition|;
name|i
operator|++
operator|,
name|addr
operator|+=
name|ADW_MC_RISC_Q_LIST_SIZE
control|)
block|{
comment|/* 		 * Set the current RISC Queue List's 		 * RQL_FWD and RQL_BWD pointers in a 		 * one word write and set the state 		 * (RQL_STATE) to free. 		 */
name|adw_lram_write_16
argument_list|(
name|adw
argument_list|,
name|addr
argument_list|,
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator||
operator|(
operator|(
name|i
operator|-
literal|1
operator|)
operator|<<
literal|8
operator|)
operator|)
argument_list|)
expr_stmt|;
name|adw_lram_write_8
argument_list|(
name|adw
argument_list|,
name|addr
operator|+
name|RQL_STATE
argument_list|,
name|ADW_MC_QS_FREE
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set the Host and RISC Queue List pointers. 	 * 	 * Both sets of pointers are initialized with the same values: 	 * ADW_MC_RISC_Q_FIRST(0x01) and ADW_MC_RISC_Q_LAST (0xFF). 	 */
name|adw_lram_write_8
argument_list|(
name|adw
argument_list|,
name|ADW_MC_HOST_NEXT_READY
argument_list|,
name|ADW_MC_RISC_Q_FIRST
argument_list|)
expr_stmt|;
name|adw_lram_write_8
argument_list|(
name|adw
argument_list|,
name|ADW_MC_HOST_NEXT_DONE
argument_list|,
name|ADW_MC_RISC_Q_LAST
argument_list|)
expr_stmt|;
name|adw_lram_write_8
argument_list|(
name|adw
argument_list|,
name|ADW_MC_RISC_NEXT_READY
argument_list|,
name|ADW_MC_RISC_Q_FIRST
argument_list|)
expr_stmt|;
name|adw_lram_write_8
argument_list|(
name|adw
argument_list|,
name|ADW_MC_RISC_NEXT_DONE
argument_list|,
name|ADW_MC_RISC_Q_LAST
argument_list|)
expr_stmt|;
comment|/* 	 * Set up the last RISC Queue List (255) with a NULL forward pointer. 	 */
name|adw_lram_write_16
argument_list|(
name|adw
argument_list|,
name|addr
argument_list|,
operator|(
name|ADW_MC_NULL_Q
operator|+
operator|(
operator|(
name|i
operator|-
literal|1
operator|)
operator|<<
literal|8
operator|)
operator|)
argument_list|)
expr_stmt|;
name|adw_lram_write_8
argument_list|(
name|adw
argument_list|,
name|addr
operator|+
name|RQL_STATE
argument_list|,
name|ADW_MC_QS_FREE
argument_list|)
expr_stmt|;
name|adw_outb
argument_list|(
name|adw
argument_list|,
name|ADW_INTR_ENABLES
argument_list|,
name|ADW_INTR_ENABLE_HOST_INTR
operator||
name|ADW_INTR_ENABLE_GLOBAL_INTR
argument_list|)
expr_stmt|;
name|adw_outw
argument_list|(
name|adw
argument_list|,
name|ADW_PC
argument_list|,
name|adw_lram_read_16
argument_list|(
name|adw
argument_list|,
name|ADW_MC_CODE_BEGIN_ADDR
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send an idle command to the chip and optionally wait for completion.  */
end_comment

begin_function
name|void
name|adw_idle_cmd_send
parameter_list|(
name|struct
name|adw_softc
modifier|*
name|adw
parameter_list|,
name|adw_idle_cmd_t
name|cmd
parameter_list|,
name|u_int
name|parameter
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|adw
operator|->
name|idle_command_cmp
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
name|adw
operator|->
name|idle_cmd
operator|!=
name|ADW_IDLE_CMD_COMPLETED
condition|)
name|printf
argument_list|(
literal|"%s: Warning! Overlapped Idle Commands Attempted\n"
argument_list|,
name|adw_name
argument_list|(
name|adw
argument_list|)
argument_list|)
expr_stmt|;
name|adw
operator|->
name|idle_cmd
operator|=
name|cmd
expr_stmt|;
name|adw
operator|->
name|idle_cmd_param
operator|=
name|parameter
expr_stmt|;
comment|/* 	 * Write the idle command value after the idle command parameter 	 * has been written to avoid a race condition. If the order is not 	 * followed, the microcode may process the idle command before the 	 * parameters have been written to LRAM. 	 */
name|adw_lram_write_16
argument_list|(
name|adw
argument_list|,
name|ADW_MC_IDLE_PARA_STAT
argument_list|,
name|parameter
argument_list|)
expr_stmt|;
name|adw_lram_write_16
argument_list|(
name|adw
argument_list|,
name|ADW_MC_IDLE_CMD
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wait for an idle command to complete */
end_comment

begin_function
name|adw_idle_cmd_status_t
name|adw_idle_cmd_wait
parameter_list|(
name|struct
name|adw_softc
modifier|*
name|adw
parameter_list|)
block|{
name|u_int
name|timeout
decl_stmt|;
name|adw_idle_cmd_status_t
name|status
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* Wait for up to 10 seconds for the command to complete */
name|timeout
operator|=
literal|10000
expr_stmt|;
while|while
condition|(
operator|--
name|timeout
condition|)
block|{
if|if
condition|(
name|adw
operator|->
name|idle_command_cmp
operator|!=
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"%s: Idle Command Timed Out!\n"
argument_list|,
name|adw_name
argument_list|(
name|adw
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|status
operator|=
name|adw_lram_read_16
argument_list|(
name|adw
argument_list|,
name|ADW_MC_IDLE_PARA_STAT
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

end_unit

