begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Low level routines for Second Generation  * Advanced Systems Inc. SCSI controllers chips  *  * Copyright (c) 1998, 1999, 2000 Justin Gibbs.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * Ported from:  * advansys.c - Linux Host Driver for AdvanSys SCSI Adapters  *       * Copyright (c) 1995-1998 Advanced System Products, Inc.  * All Rights Reserved.  *     * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that redistributions of source  * code retain the above copyright notice and this comment without  * modification.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus_pio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus_memio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<dev/advansys/adwlib.h>
end_include

begin_decl_stmt
specifier|const
name|struct
name|adw_eeprom
name|adw_asc3550_default_eeprom
init|=
block|{
name|ADW_EEPROM_BIOS_ENABLE
block|,
comment|/* cfg_lsw */
literal|0x0000
block|,
comment|/* cfg_msw */
literal|0xFFFF
block|,
comment|/* disc_enable */
literal|0xFFFF
block|,
comment|/* wdtr_able */
block|{
literal|0xFFFF
block|}
block|,
comment|/* sdtr_able */
literal|0xFFFF
block|,
comment|/* start_motor */
literal|0xFFFF
block|,
comment|/* tagqng_able */
literal|0xFFFF
block|,
comment|/* bios_scan */
literal|0
block|,
comment|/* scam_tolerant */
literal|7
block|,
comment|/* adapter_scsi_id */
literal|0
block|,
comment|/* bios_boot_delay */
literal|3
block|,
comment|/* scsi_reset_delay */
literal|0
block|,
comment|/* bios_id_lun */
literal|0
block|,
comment|/* termination */
literal|0
block|,
comment|/* reserved1 */
literal|0xFFE7
block|,
comment|/* bios_ctrl */
block|{
literal|0xFFFF
block|}
block|,
comment|/* ultra_able */
block|{
literal|0
block|}
block|,
comment|/* reserved2 */
name|ADW_DEF_MAX_HOST_QNG
block|,
comment|/* max_host_qng */
name|ADW_DEF_MAX_DVC_QNG
block|,
comment|/* max_dvc_qng */
literal|0
block|,
comment|/* dvc_cntl */
block|{
literal|0
block|}
block|,
comment|/* bug_fix */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* serial_number */
literal|0
block|,
comment|/* check_sum */
block|{
comment|/* oem_name[16] */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
comment|/* dvc_err_code */
literal|0
block|,
comment|/* adv_err_code */
literal|0
block|,
comment|/* adv_err_addr */
literal|0
block|,
comment|/* saved_dvc_err_code */
literal|0
block|,
comment|/* saved_adv_err_code */
literal|0
comment|/* saved_adv_err_addr */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|adw_eeprom
name|adw_asc38C0800_default_eeprom
init|=
block|{
name|ADW_EEPROM_BIOS_ENABLE
block|,
comment|/* 00 cfg_lsw */
literal|0x0000
block|,
comment|/* 01 cfg_msw */
literal|0xFFFF
block|,
comment|/* 02 disc_enable */
literal|0xFFFF
block|,
comment|/* 03 wdtr_able */
block|{
literal|0x4444
block|}
block|,
comment|/* 04 sdtr_speed1 */
literal|0xFFFF
block|,
comment|/* 05 start_motor */
literal|0xFFFF
block|,
comment|/* 06 tagqng_able */
literal|0xFFFF
block|,
comment|/* 07 bios_scan */
literal|0
block|,
comment|/* 08 scam_tolerant */
literal|7
block|,
comment|/* 09 adapter_scsi_id */
literal|0
block|,
comment|/*    bios_boot_delay */
literal|3
block|,
comment|/* 10 scsi_reset_delay */
literal|0
block|,
comment|/*    bios_id_lun */
literal|0
block|,
comment|/* 11 termination_se */
literal|0
block|,
comment|/*    termination_lvd */
literal|0xFFE7
block|,
comment|/* 12 bios_ctrl */
block|{
literal|0x4444
block|}
block|,
comment|/* 13 sdtr_speed2 */
block|{
literal|0x4444
block|}
block|,
comment|/* 14 sdtr_speed3 */
name|ADW_DEF_MAX_HOST_QNG
block|,
comment|/* 15 max_host_qng */
name|ADW_DEF_MAX_DVC_QNG
block|,
comment|/*    max_dvc_qng */
literal|0
block|,
comment|/* 16 dvc_cntl */
block|{
literal|0x4444
block|}
block|,
comment|/* 17 sdtr_speed4 */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 18-20 serial_number */
literal|0
block|,
comment|/* 21 check_sum */
block|{
comment|/* 22-29 oem_name[16] */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
comment|/* 30 dvc_err_code */
literal|0
block|,
comment|/* 31 adv_err_code */
literal|0
block|,
comment|/* 32 adv_err_addr */
literal|0
block|,
comment|/* 33 saved_dvc_err_code */
literal|0
block|,
comment|/* 34 saved_adv_err_code */
literal|0
block|,
comment|/* 35 saved_adv_err_addr */
block|{
comment|/* 36 - 55 reserved */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|, 	}
block|,
literal|0
block|,
comment|/* 56 cisptr_lsw */
literal|0
block|,
comment|/* 57 cisprt_msw */
comment|/* 58-59 sub-id */
operator|(
name|PCI_ID_ADVANSYS_38C0800_REV1
operator|&
name|PCI_ID_DEV_VENDOR_MASK
operator|)
operator|>>
literal|32
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ADW_MC_SDTR_OFFSET_ULTRA2_DT
value|0
end_define

begin_define
define|#
directive|define
name|ADW_MC_SDTR_OFFSET_ULTRA2
value|1
end_define

begin_define
define|#
directive|define
name|ADW_MC_SDTR_OFFSET_ULTRA
value|2
end_define

begin_decl_stmt
specifier|const
name|struct
name|adw_syncrate
name|adw_syncrates
index|[]
init|=
block|{
comment|/*   mc_sdtr		  period      rate */
block|{
name|ADW_MC_SDTR_80
block|,
literal|9
block|,
literal|"80.0"
block|}
block|,
block|{
name|ADW_MC_SDTR_40
block|,
literal|10
block|,
literal|"40.0"
block|}
block|,
block|{
name|ADW_MC_SDTR_20
block|,
literal|12
block|,
literal|"20.0"
block|}
block|,
block|{
name|ADW_MC_SDTR_10
block|,
literal|25
block|,
literal|"10.0"
block|}
block|,
block|{
name|ADW_MC_SDTR_5
block|,
literal|50
block|,
literal|"5.0"
block|}
block|,
block|{
name|ADW_MC_SDTR_ASYNC
block|,
literal|0
block|,
literal|"async"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|adw_num_syncrates
init|=
sizeof|sizeof
argument_list|(
name|adw_syncrates
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|adw_syncrates
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|u_int16_t
name|adw_eeprom_read_16
parameter_list|(
name|struct
name|adw_softc
modifier|*
name|adw
parameter_list|,
name|int
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|adw_eeprom_write_16
parameter_list|(
name|struct
name|adw_softc
modifier|*
name|adw
parameter_list|,
name|int
name|addr
parameter_list|,
name|u_int
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|adw_eeprom_wait
parameter_list|(
name|struct
name|adw_softc
modifier|*
name|adw
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|adw_find_signature
parameter_list|(
name|struct
name|adw_softc
modifier|*
name|adw
parameter_list|)
block|{
if|if
condition|(
name|adw_inb
argument_list|(
name|adw
argument_list|,
name|ADW_SIGNATURE_BYTE
argument_list|)
operator|==
name|ADW_CHIP_ID_BYTE
operator|&&
name|adw_inw
argument_list|(
name|adw
argument_list|,
name|ADW_SIGNATURE_WORD
argument_list|)
operator|==
name|ADW_CHIP_ID_WORD
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reset Chip.  */
end_comment

begin_function
name|void
name|adw_reset_chip
parameter_list|(
name|struct
name|adw_softc
modifier|*
name|adw
parameter_list|)
block|{
name|adw_outw
argument_list|(
name|adw
argument_list|,
name|ADW_CTRL_REG
argument_list|,
name|ADW_CTRL_REG_CMD_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
operator|*
literal|100
argument_list|)
expr_stmt|;
name|adw_outw
argument_list|(
name|adw
argument_list|,
name|ADW_CTRL_REG
argument_list|,
name|ADW_CTRL_REG_CMD_WR_IO_REG
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize Chip registers. 	 */
name|adw_outw
argument_list|(
name|adw
argument_list|,
name|ADW_SCSI_CFG1
argument_list|,
name|adw_inw
argument_list|(
name|adw
argument_list|,
name|ADW_SCSI_CFG1
argument_list|)
operator|&
operator|~
name|ADW_SCSI_CFG1_BIG_ENDIAN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset the SCSI bus.  */
end_comment

begin_function
name|int
name|adw_reset_bus
parameter_list|(
name|struct
name|adw_softc
modifier|*
name|adw
parameter_list|)
block|{
name|adw_idle_cmd_status_t
name|status
decl_stmt|;
name|status
operator|=
name|adw_idle_cmd_send
argument_list|(
name|adw
argument_list|,
name|ADW_IDLE_CMD_SCSI_RESET_START
argument_list|,
comment|/*param*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ADW_IDLE_CMD_SUCCESS
condition|)
block|{
name|xpt_print_path
argument_list|(
name|adw
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Bus Reset start attempt failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|DELAY
argument_list|(
name|ADW_BUS_RESET_HOLD_DELAY_US
argument_list|)
expr_stmt|;
name|status
operator|=
name|adw_idle_cmd_send
argument_list|(
name|adw
argument_list|,
name|ADW_IDLE_CMD_SCSI_RESET_END
argument_list|,
comment|/*param*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|ADW_IDLE_CMD_SUCCESS
condition|)
block|{
name|xpt_print_path
argument_list|(
name|adw
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Bus Reset end attempt failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read the specified EEPROM location  */
end_comment

begin_function
specifier|static
name|u_int16_t
name|adw_eeprom_read_16
parameter_list|(
name|struct
name|adw_softc
modifier|*
name|adw
parameter_list|,
name|int
name|addr
parameter_list|)
block|{
name|adw_outw
argument_list|(
name|adw
argument_list|,
name|ADW_EEP_CMD
argument_list|,
name|ADW_EEP_CMD_READ
operator||
name|addr
argument_list|)
expr_stmt|;
name|adw_eeprom_wait
argument_list|(
name|adw
argument_list|)
expr_stmt|;
return|return
operator|(
name|adw_inw
argument_list|(
name|adw
argument_list|,
name|ADW_EEP_DATA
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|adw_eeprom_write_16
parameter_list|(
name|struct
name|adw_softc
modifier|*
name|adw
parameter_list|,
name|int
name|addr
parameter_list|,
name|u_int
name|data
parameter_list|)
block|{
name|adw_outw
argument_list|(
name|adw
argument_list|,
name|ADW_EEP_DATA
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|adw_outw
argument_list|(
name|adw
argument_list|,
name|ADW_EEP_CMD
argument_list|,
name|ADW_EEP_CMD_WRITE
operator||
name|addr
argument_list|)
expr_stmt|;
name|adw_eeprom_wait
argument_list|(
name|adw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Wait for and EEPROM command to complete  */
end_comment

begin_function
specifier|static
name|void
name|adw_eeprom_wait
parameter_list|(
name|struct
name|adw_softc
modifier|*
name|adw
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ADW_EEP_DELAY_MS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|adw_inw
argument_list|(
name|adw
argument_list|,
name|ADW_EEP_CMD
argument_list|)
operator|&
name|ADW_EEP_CMD_DONE
operator|)
operator|!=
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|ADW_EEP_DELAY_MS
condition|)
name|panic
argument_list|(
literal|"%s: Timedout Reading EEPROM"
argument_list|,
name|adw_name
argument_list|(
name|adw
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read EEPROM configuration into the specified buffer.  *  * Return a checksum based on the EEPROM configuration read.  */
end_comment

begin_function
name|u_int16_t
name|adw_eeprom_read
parameter_list|(
name|struct
name|adw_softc
modifier|*
name|adw
parameter_list|,
name|struct
name|adw_eeprom
modifier|*
name|eep_buf
parameter_list|)
block|{
name|u_int16_t
modifier|*
name|wbuf
decl_stmt|;
name|u_int16_t
name|wval
decl_stmt|;
name|u_int16_t
name|chksum
decl_stmt|;
name|int
name|eep_addr
decl_stmt|;
name|wbuf
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|eep_buf
expr_stmt|;
name|chksum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|eep_addr
operator|=
name|ADW_EEP_DVC_CFG_BEGIN
init|;
name|eep_addr
operator|<
name|ADW_EEP_DVC_CFG_END
condition|;
name|eep_addr
operator|++
operator|,
name|wbuf
operator|++
control|)
block|{
name|wval
operator|=
name|adw_eeprom_read_16
argument_list|(
name|adw
argument_list|,
name|eep_addr
argument_list|)
expr_stmt|;
name|chksum
operator|+=
name|wval
expr_stmt|;
operator|*
name|wbuf
operator|=
name|wval
expr_stmt|;
block|}
comment|/* checksum field is not counted in the checksum */
operator|*
name|wbuf
operator|=
name|adw_eeprom_read_16
argument_list|(
name|adw
argument_list|,
name|eep_addr
argument_list|)
expr_stmt|;
name|wbuf
operator|++
expr_stmt|;
comment|/* Driver seeprom variables are not included in the checksum */
for|for
control|(
name|eep_addr
operator|=
name|ADW_EEP_DVC_CTL_BEGIN
init|;
name|eep_addr
operator|<
name|ADW_EEP_MAX_WORD_ADDR
condition|;
name|eep_addr
operator|++
operator|,
name|wbuf
operator|++
control|)
operator|*
name|wbuf
operator|=
name|adw_eeprom_read_16
argument_list|(
name|adw
argument_list|,
name|eep_addr
argument_list|)
expr_stmt|;
return|return
operator|(
name|chksum
operator|)
return|;
block|}
end_function

begin_function
name|void
name|adw_eeprom_write
parameter_list|(
name|struct
name|adw_softc
modifier|*
name|adw
parameter_list|,
name|struct
name|adw_eeprom
modifier|*
name|eep_buf
parameter_list|)
block|{
name|u_int16_t
modifier|*
name|wbuf
decl_stmt|;
name|u_int16_t
name|addr
decl_stmt|;
name|u_int16_t
name|chksum
decl_stmt|;
name|wbuf
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|eep_buf
expr_stmt|;
name|chksum
operator|=
literal|0
expr_stmt|;
name|adw_outw
argument_list|(
name|adw
argument_list|,
name|ADW_EEP_CMD
argument_list|,
name|ADW_EEP_CMD_WRITE_ABLE
argument_list|)
expr_stmt|;
name|adw_eeprom_wait
argument_list|(
name|adw
argument_list|)
expr_stmt|;
comment|/* 	 * Write EEPROM until checksum. 	 */
for|for
control|(
name|addr
operator|=
name|ADW_EEP_DVC_CFG_BEGIN
init|;
name|addr
operator|<
name|ADW_EEP_DVC_CFG_END
condition|;
name|addr
operator|++
operator|,
name|wbuf
operator|++
control|)
block|{
name|chksum
operator|+=
operator|*
name|wbuf
expr_stmt|;
name|adw_eeprom_write_16
argument_list|(
name|adw
argument_list|,
name|addr
argument_list|,
operator|*
name|wbuf
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Write calculated EEPROM checksum 	 */
name|adw_eeprom_write_16
argument_list|(
name|adw
argument_list|,
name|addr
argument_list|,
name|chksum
argument_list|)
expr_stmt|;
comment|/* skip over buffer's checksum */
name|wbuf
operator|++
expr_stmt|;
comment|/* 	 * Write the rest. 	 */
for|for
control|(
name|addr
operator|=
name|ADW_EEP_DVC_CTL_BEGIN
init|;
name|addr
operator|<
name|ADW_EEP_MAX_WORD_ADDR
condition|;
name|addr
operator|++
operator|,
name|wbuf
operator|++
control|)
name|adw_eeprom_write_16
argument_list|(
name|adw
argument_list|,
name|addr
argument_list|,
operator|*
name|wbuf
argument_list|)
expr_stmt|;
name|adw_outw
argument_list|(
name|adw
argument_list|,
name|ADW_EEP_CMD
argument_list|,
name|ADW_EEP_CMD_WRITE_DISABLE
argument_list|)
expr_stmt|;
name|adw_eeprom_wait
argument_list|(
name|adw
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|adw_init_chip
parameter_list|(
name|struct
name|adw_softc
modifier|*
name|adw
parameter_list|,
name|u_int
name|term_scsicfg1
parameter_list|)
block|{
name|u_int8_t
name|biosmem
index|[
name|ADW_MC_BIOSLEN
index|]
decl_stmt|;
specifier|const
name|u_int16_t
modifier|*
name|word_table
decl_stmt|;
specifier|const
name|u_int8_t
modifier|*
name|byte_codes
decl_stmt|;
specifier|const
name|u_int8_t
modifier|*
name|byte_codes_end
decl_stmt|;
name|u_int
name|bios_sig
decl_stmt|;
name|u_int
name|bytes_downloaded
decl_stmt|;
name|u_int
name|addr
decl_stmt|;
name|u_int
name|end_addr
decl_stmt|;
name|u_int
name|checksum
decl_stmt|;
name|u_int
name|scsicfg1
decl_stmt|;
name|u_int
name|tid
decl_stmt|;
comment|/* 	 * Save the RISC memory BIOS region before writing the microcode. 	 * The BIOS may already be loaded and using its RISC LRAM region 	 * so its region must be saved and restored. 	 */
for|for
control|(
name|addr
operator|=
literal|0
init|;
name|addr
operator|<
name|ADW_MC_BIOSLEN
condition|;
name|addr
operator|++
control|)
name|biosmem
index|[
name|addr
index|]
operator|=
name|adw_lram_read_8
argument_list|(
name|adw
argument_list|,
name|ADW_MC_BIOSMEM
operator|+
name|addr
argument_list|)
expr_stmt|;
comment|/* 	 * Save current per TID negotiated values if the BIOS has been 	 * loaded (BIOS signature is present).  These will be used if 	 * we cannot get information from the EEPROM. 	 */
name|addr
operator|=
name|ADW_MC_BIOS_SIGNATURE
operator|-
name|ADW_MC_BIOSMEM
expr_stmt|;
name|bios_sig
operator|=
name|biosmem
index|[
name|addr
index|]
operator||
operator|(
name|biosmem
index|[
name|addr
operator|+
literal|1
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|bios_sig
operator|==
literal|0x55AA
operator|&&
operator|(
name|adw
operator|->
name|flags
operator|&
name|ADW_EEPROM_FAILED
operator|)
operator|!=
literal|0
condition|)
block|{
name|u_int
name|major_ver
decl_stmt|;
name|u_int
name|minor_ver
decl_stmt|;
name|u_int
name|sdtr_able
decl_stmt|;
name|addr
operator|=
name|ADW_MC_BIOS_VERSION
operator|-
name|ADW_MC_BIOSMEM
expr_stmt|;
name|minor_ver
operator|=
name|biosmem
index|[
name|addr
operator|+
literal|1
index|]
operator|&
literal|0xF
expr_stmt|;
name|major_ver
operator|=
operator|(
name|biosmem
index|[
name|addr
operator|+
literal|1
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xF
expr_stmt|;
if|if
condition|(
operator|(
name|adw
operator|->
name|chip
operator|==
name|ADW_CHIP_ASC3550
operator|)
operator|&&
operator|(
name|major_ver
operator|<=
literal|3
operator|||
operator|(
name|major_ver
operator|==
literal|3
operator|&&
name|minor_ver
operator|==
literal|1
operator|)
operator|)
condition|)
block|{
comment|/* 			 * BIOS 3.1 and earlier location of 			 * 'wdtr_able' variable. 			 */
name|adw
operator|->
name|user_wdtr
operator|=
name|adw_lram_read_16
argument_list|(
name|adw
argument_list|,
name|ADW_MC_WDTR_ABLE_BIOS_31
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|adw
operator|->
name|user_wdtr
operator|=
name|adw_lram_read_16
argument_list|(
name|adw
argument_list|,
name|ADW_MC_WDTR_ABLE
argument_list|)
expr_stmt|;
block|}
name|sdtr_able
operator|=
name|adw_lram_read_16
argument_list|(
name|adw
argument_list|,
name|ADW_MC_SDTR_ABLE
argument_list|)
expr_stmt|;
for|for
control|(
name|tid
operator|=
literal|0
init|;
name|tid
operator|<
name|ADW_MAX_TID
condition|;
name|tid
operator|++
control|)
block|{
name|u_int
name|tid_mask
decl_stmt|;
name|u_int
name|mc_sdtr
decl_stmt|;
name|tid_mask
operator|=
literal|0x1
operator|<<
name|tid
expr_stmt|;
if|if
condition|(
operator|(
name|sdtr_able
operator|&
name|tid_mask
operator|)
operator|==
literal|0
condition|)
name|mc_sdtr
operator|=
name|ADW_MC_SDTR_ASYNC
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|adw
operator|->
name|features
operator|&
name|ADW_DT
operator|)
operator|!=
literal|0
condition|)
name|mc_sdtr
operator|=
name|ADW_MC_SDTR_80
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|adw
operator|->
name|features
operator|&
name|ADW_ULTRA2
operator|)
operator|!=
literal|0
condition|)
name|mc_sdtr
operator|=
name|ADW_MC_SDTR_40
expr_stmt|;
else|else
name|mc_sdtr
operator|=
name|ADW_MC_SDTR_20
expr_stmt|;
name|adw_set_user_sdtr
argument_list|(
name|adw
argument_list|,
name|tid
argument_list|,
name|mc_sdtr
argument_list|)
expr_stmt|;
block|}
name|adw
operator|->
name|user_tagenb
operator|=
name|adw_lram_read_16
argument_list|(
name|adw
argument_list|,
name|ADW_MC_TAGQNG_ABLE
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Load the Microcode. 	 * 	 * Assume the following compressed format of the microcode buffer: 	 * 	 *	253 word (506 byte) table indexed by byte code followed 	 *	by the following byte codes: 	 * 	 *	1-Byte Code: 	 *		00: Emit word 0 in table. 	 *		01: Emit word 1 in table. 	 *		. 	 *		FD: Emit word 253 in table. 	 * 	 *	Multi-Byte Code: 	 *		FD RESEVED 	 * 	 *		FE WW WW: (3 byte code) 	 *			Word to emit is the next word WW WW. 	 *		FF BB WW WW: (4 byte code) 	 *			Emit BB count times next word WW WW. 	 * 	 */
name|bytes_downloaded
operator|=
literal|0
expr_stmt|;
name|word_table
operator|=
operator|(
specifier|const
name|u_int16_t
operator|*
operator|)
name|adw
operator|->
name|mcode_data
operator|->
name|mcode_buf
expr_stmt|;
name|byte_codes
operator|=
operator|(
specifier|const
name|u_int8_t
operator|*
operator|)
operator|&
name|word_table
index|[
literal|253
index|]
expr_stmt|;
name|byte_codes_end
operator|=
name|adw
operator|->
name|mcode_data
operator|->
name|mcode_buf
operator|+
name|adw
operator|->
name|mcode_data
operator|->
name|mcode_size
expr_stmt|;
name|adw_outw
argument_list|(
name|adw
argument_list|,
name|ADW_RAM_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|byte_codes
operator|<
name|byte_codes_end
condition|)
block|{
if|if
condition|(
operator|*
name|byte_codes
operator|==
literal|0xFF
condition|)
block|{
name|u_int16_t
name|value
decl_stmt|;
name|value
operator|=
name|byte_codes
index|[
literal|2
index|]
operator||
name|byte_codes
index|[
literal|3
index|]
operator|<<
literal|8
expr_stmt|;
name|adw_set_multi_2
argument_list|(
name|adw
argument_list|,
name|ADW_RAM_DATA
argument_list|,
name|value
argument_list|,
name|byte_codes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|bytes_downloaded
operator|+=
name|byte_codes
index|[
literal|1
index|]
expr_stmt|;
name|byte_codes
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|byte_codes
operator|==
literal|0xFE
condition|)
block|{
name|u_int16_t
name|value
decl_stmt|;
name|value
operator|=
name|byte_codes
index|[
literal|1
index|]
operator||
name|byte_codes
index|[
literal|2
index|]
operator|<<
literal|8
expr_stmt|;
name|adw_outw
argument_list|(
name|adw
argument_list|,
name|ADW_RAM_DATA
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|bytes_downloaded
operator|++
expr_stmt|;
name|byte_codes
operator|+=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|adw_outw
argument_list|(
name|adw
argument_list|,
name|ADW_RAM_DATA
argument_list|,
name|word_table
index|[
operator|*
name|byte_codes
index|]
argument_list|)
expr_stmt|;
name|bytes_downloaded
operator|++
expr_stmt|;
name|byte_codes
operator|++
expr_stmt|;
block|}
block|}
comment|/* Convert from words to bytes */
name|bytes_downloaded
operator|*=
literal|2
expr_stmt|;
comment|/* 	 * Clear the rest of LRAM. 	 */
for|for
control|(
name|addr
operator|=
name|bytes_downloaded
init|;
name|addr
operator|<
name|adw
operator|->
name|memsize
condition|;
name|addr
operator|+=
literal|2
control|)
name|adw_outw
argument_list|(
name|adw
argument_list|,
name|ADW_RAM_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Verify the microcode checksum. 	 */
name|checksum
operator|=
literal|0
expr_stmt|;
name|adw_outw
argument_list|(
name|adw
argument_list|,
name|ADW_RAM_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|addr
operator|=
literal|0
init|;
name|addr
operator|<
name|bytes_downloaded
condition|;
name|addr
operator|+=
literal|2
control|)
name|checksum
operator|+=
name|adw_inw
argument_list|(
name|adw
argument_list|,
name|ADW_RAM_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|checksum
operator|!=
name|adw
operator|->
name|mcode_data
operator|->
name|mcode_chksum
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Firmware load failed!\n"
argument_list|,
name|adw_name
argument_list|(
name|adw
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* 	 * Restore the RISC memory BIOS region. 	 */
for|for
control|(
name|addr
operator|=
literal|0
init|;
name|addr
operator|<
name|ADW_MC_BIOSLEN
condition|;
name|addr
operator|++
control|)
name|adw_lram_write_8
argument_list|(
name|adw
argument_list|,
name|addr
operator|+
name|ADW_MC_BIOSLEN
argument_list|,
name|biosmem
index|[
name|addr
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate and write the microcode code checksum to 	 * the microcode code checksum location. 	 */
name|addr
operator|=
name|adw_lram_read_16
argument_list|(
name|adw
argument_list|,
name|ADW_MC_CODE_BEGIN_ADDR
argument_list|)
expr_stmt|;
name|end_addr
operator|=
name|adw_lram_read_16
argument_list|(
name|adw
argument_list|,
name|ADW_MC_CODE_END_ADDR
argument_list|)
expr_stmt|;
name|checksum
operator|=
literal|0
expr_stmt|;
name|adw_outw
argument_list|(
name|adw
argument_list|,
name|ADW_RAM_ADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|addr
operator|<
name|end_addr
condition|;
name|addr
operator|+=
literal|2
control|)
name|checksum
operator|+=
name|adw_inw
argument_list|(
name|adw
argument_list|,
name|ADW_RAM_DATA
argument_list|)
expr_stmt|;
name|adw_lram_write_16
argument_list|(
name|adw
argument_list|,
name|ADW_MC_CODE_CHK_SUM
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
comment|/* 	 * Tell the microcode what kind of chip it's running on. 	 */
name|adw_lram_write_16
argument_list|(
name|adw
argument_list|,
name|ADW_MC_CHIP_TYPE
argument_list|,
name|adw
operator|->
name|chip
argument_list|)
expr_stmt|;
comment|/* 	 * Leave WDTR and SDTR negotiation disabled until the XPT has 	 * informed us of device capabilities, but do set the desired 	 * user rates in case we receive an SDTR request from the target 	 * before we negotiate.  We turn on tagged queuing at the microcode 	 * level for all devices, and modulate this on a per command basis. 	 */
name|adw_lram_write_16
argument_list|(
name|adw
argument_list|,
name|ADW_MC_SDTR_SPEED1
argument_list|,
name|adw
operator|->
name|user_sdtr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|adw_lram_write_16
argument_list|(
name|adw
argument_list|,
name|ADW_MC_SDTR_SPEED2
argument_list|,
name|adw
operator|->
name|user_sdtr
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|adw_lram_write_16
argument_list|(
name|adw
argument_list|,
name|ADW_MC_SDTR_SPEED3
argument_list|,
name|adw
operator|->
name|user_sdtr
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|adw_lram_write_16
argument_list|(
name|adw
argument_list|,
name|ADW_MC_SDTR_SPEED4
argument_list|,
name|adw
operator|->
name|user_sdtr
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|adw_lram_write_16
argument_list|(
name|adw
argument_list|,
name|ADW_MC_DISC_ENABLE
argument_list|,
name|adw
operator|->
name|user_discenb
argument_list|)
expr_stmt|;
for|for
control|(
name|tid
operator|=
literal|0
init|;
name|tid
operator|<
name|ADW_MAX_TID
condition|;
name|tid
operator|++
control|)
block|{
comment|/* Cam limits the maximum number of commands for us */
name|adw_lram_write_8
argument_list|(
name|adw
argument_list|,
name|ADW_MC_NUMBER_OF_MAX_CMD
operator|+
name|tid
argument_list|,
name|adw
operator|->
name|max_acbs
argument_list|)
expr_stmt|;
block|}
name|adw_lram_write_16
argument_list|(
name|adw
argument_list|,
name|ADW_MC_TAGQNG_ABLE
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Set SCSI_CFG0 Microcode Default Value. 	 * 	 * The microcode will set the SCSI_CFG0 register using this value 	 * after it is started. 	 */
name|adw_lram_write_16
argument_list|(
name|adw
argument_list|,
name|ADW_MC_DEFAULT_SCSI_CFG0
argument_list|,
name|ADW_SCSI_CFG0_PARITY_EN
operator||
name|ADW_SCSI_CFG0_SEL_TMO_LONG
operator||
name|ADW_SCSI_CFG0_OUR_ID_EN
operator||
name|adw
operator|->
name|initiator_id
argument_list|)
expr_stmt|;
comment|/* 	 * Tell the MC about the memory size that 	 * was setup by the probe code. 	 */
name|adw_lram_write_16
argument_list|(
name|adw
argument_list|,
name|ADW_MC_DEFAULT_MEM_CFG
argument_list|,
name|adw_inb
argument_list|(
name|adw
argument_list|,
name|ADW_MEM_CFG
argument_list|)
operator|&
name|ADW_MEM_CFG_RAM_SZ_MASK
argument_list|)
expr_stmt|;
comment|/* 	 * Determine SCSI_CFG1 Microcode Default Value. 	 * 	 * The microcode will set the SCSI_CFG1 register using this value 	 * after it is started below. 	 */
name|scsicfg1
operator|=
name|adw_inw
argument_list|(
name|adw
argument_list|,
name|ADW_SCSI_CFG1
argument_list|)
expr_stmt|;
comment|/* 	 * If the internal narrow cable is reversed all of the SCSI_CTRL 	 * register signals will be set. Check for and return an error if 	 * this condition is found. 	 */
if|if
condition|(
operator|(
name|adw_inw
argument_list|(
name|adw
argument_list|,
name|ADW_SCSI_CTRL
argument_list|)
operator|&
literal|0x3F07
operator|)
operator|==
literal|0x3F07
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Illegal Cable Config!\n"
argument_list|,
name|adw_name
argument_list|(
name|adw
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Internal cable is reversed!\n"
argument_list|,
name|adw_name
argument_list|(
name|adw
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* 	 * If this is a differential board and a single-ended device 	 * is attached to one of the connectors, return an error. 	 */
if|if
condition|(
operator|(
name|adw
operator|->
name|features
operator|&
name|ADW_ULTRA
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|scsicfg1
operator|&
name|ADW_SCSI_CFG1_DIFF_MODE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|scsicfg1
operator|&
name|ADW_SCSI_CFG1_DIFF_SENSE
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: A Single Ended Device is attached to our "
literal|"differential bus!\n"
argument_list|,
name|adw_name
argument_list|(
name|adw
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|scsicfg1
operator|&
name|ADW2_SCSI_CFG1_DEV_DETECT_HVD
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: A High Voltage Differential Device "
literal|"is attached to this controller.\n"
argument_list|,
name|adw_name
argument_list|(
name|adw
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: HVD devices are not supported.\n"
argument_list|,
name|adw_name
argument_list|(
name|adw
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
comment|/* 	 * Perform automatic termination control if desired. 	 */
if|if
condition|(
operator|(
name|adw
operator|->
name|features
operator|&
name|ADW_ULTRA2
operator|)
operator|!=
literal|0
condition|)
block|{
name|u_int
name|cable_det
decl_stmt|;
comment|/* 		 * Ultra2 Chips require termination disabled to 		 * detect cable presence. 		 */
name|adw_outw
argument_list|(
name|adw
argument_list|,
name|ADW_SCSI_CFG1
argument_list|,
name|scsicfg1
operator||
name|ADW2_SCSI_CFG1_DIS_TERM_DRV
argument_list|)
expr_stmt|;
name|cable_det
operator|=
name|adw_inw
argument_list|(
name|adw
argument_list|,
name|ADW_SCSI_CFG1
argument_list|)
expr_stmt|;
name|adw_outw
argument_list|(
name|adw
argument_list|,
name|ADW_SCSI_CFG1
argument_list|,
name|scsicfg1
argument_list|)
expr_stmt|;
comment|/* SE Termination first if auto-term has been specified */
if|if
condition|(
operator|(
name|term_scsicfg1
operator|&
name|ADW_SCSI_CFG1_TERM_CTL_MASK
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * For all SE cable configurations, high byte 			 * termination is enabled. 			 */
name|term_scsicfg1
operator||=
name|ADW_SCSI_CFG1_TERM_CTL_H
expr_stmt|;
if|if
condition|(
operator|(
name|cable_det
operator|&
name|ADW_SCSI_CFG1_INT8_MASK
operator|)
operator|!=
literal|0
operator|||
operator|(
name|cable_det
operator|&
name|ADW_SCSI_CFG1_INT16_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * If either cable is not present, the 				 * low byte must be terminated as well. 				 */
name|term_scsicfg1
operator||=
name|ADW_SCSI_CFG1_TERM_CTL_L
expr_stmt|;
block|}
block|}
comment|/* LVD auto-term */
if|if
condition|(
operator|(
name|term_scsicfg1
operator|&
name|ADW2_SCSI_CFG1_TERM_CTL_LVD
operator|)
operator|==
literal|0
operator|&&
operator|(
name|term_scsicfg1
operator|&
name|ADW2_SCSI_CFG1_DIS_TERM_DRV
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * If both cables are installed, termination 			 * is disabled.  Otherwise it is enabled. 			 */
if|if
condition|(
operator|(
name|cable_det
operator|&
name|ADW2_SCSI_CFG1_EXTLVD_MASK
operator|)
operator|!=
literal|0
operator|||
operator|(
name|cable_det
operator|&
name|ADW2_SCSI_CFG1_INTLVD_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|term_scsicfg1
operator||=
name|ADW2_SCSI_CFG1_TERM_CTL_LVD
expr_stmt|;
block|}
block|}
name|term_scsicfg1
operator|&=
operator|~
name|ADW2_SCSI_CFG1_DIS_TERM_DRV
expr_stmt|;
block|}
else|else
block|{
comment|/* Ultra Controller Termination */
if|if
condition|(
operator|(
name|term_scsicfg1
operator|&
name|ADW_SCSI_CFG1_TERM_CTL_MASK
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|cable_count
decl_stmt|;
name|int
name|wide_cable_count
decl_stmt|;
name|cable_count
operator|=
literal|0
expr_stmt|;
name|wide_cable_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|scsicfg1
operator|&
name|ADW_SCSI_CFG1_INT16_MASK
operator|)
operator|==
literal|0
condition|)
block|{
name|cable_count
operator|++
expr_stmt|;
name|wide_cable_count
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|scsicfg1
operator|&
name|ADW_SCSI_CFG1_INT8_MASK
operator|)
operator|==
literal|0
condition|)
name|cable_count
operator|++
expr_stmt|;
comment|/* There is only one external port */
if|if
condition|(
operator|(
name|scsicfg1
operator|&
name|ADW_SCSI_CFG1_EXT16_MASK
operator|)
operator|==
literal|0
condition|)
block|{
name|cable_count
operator|++
expr_stmt|;
name|wide_cable_count
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|scsicfg1
operator|&
name|ADW_SCSI_CFG1_EXT8_MASK
operator|)
operator|==
literal|0
condition|)
name|cable_count
operator|++
expr_stmt|;
if|if
condition|(
name|cable_count
operator|==
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Illegal Cable Config!\n"
argument_list|,
name|adw_name
argument_list|(
name|adw
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Only Two Ports may be used at "
literal|"a time!\n"
argument_list|,
name|adw_name
argument_list|(
name|adw
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cable_count
operator|<=
literal|1
condition|)
block|{
comment|/* 				 * At least two out of three cables missing. 				 * Terminate both bytes. 				 */
name|term_scsicfg1
operator||=
name|ADW_SCSI_CFG1_TERM_CTL_H
operator||
name|ADW_SCSI_CFG1_TERM_CTL_L
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wide_cable_count
operator|<=
literal|1
condition|)
block|{
comment|/* No two 16bit cables present.  High on. */
name|term_scsicfg1
operator||=
name|ADW_SCSI_CFG1_TERM_CTL_H
expr_stmt|;
block|}
block|}
block|}
comment|/* Tell the user about our decission */
switch|switch
condition|(
name|term_scsicfg1
operator|&
name|ADW_SCSI_CFG1_TERM_CTL_MASK
condition|)
block|{
case|case
name|ADW_SCSI_CFG1_TERM_CTL_MASK
case|:
name|printf
argument_list|(
literal|"High& Low SE Term Enabled, "
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADW_SCSI_CFG1_TERM_CTL_H
case|:
name|printf
argument_list|(
literal|"High SE Termination Enabled, "
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADW_SCSI_CFG1_TERM_CTL_L
case|:
name|printf
argument_list|(
literal|"Low SE Term Enabled, "
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
operator|(
name|adw
operator|->
name|features
operator|&
name|ADW_ULTRA2
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|term_scsicfg1
operator|&
name|ADW2_SCSI_CFG1_TERM_CTL_LVD
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"LVD Term Enabled, "
argument_list|)
expr_stmt|;
comment|/* 	 * Invert the TERM_CTL_H and TERM_CTL_L bits and then 	 * set 'scsicfg1'. The TERM_POL bit does not need to be 	 * referenced, because the hardware internally inverts 	 * the Termination High and Low bits if TERM_POL is set. 	 */
if|if
condition|(
operator|(
name|adw
operator|->
name|features
operator|&
name|ADW_ULTRA2
operator|)
operator|!=
literal|0
condition|)
block|{
name|term_scsicfg1
operator|=
operator|~
name|term_scsicfg1
expr_stmt|;
name|term_scsicfg1
operator|&=
name|ADW_SCSI_CFG1_TERM_CTL_MASK
operator||
name|ADW2_SCSI_CFG1_TERM_CTL_LVD
expr_stmt|;
name|scsicfg1
operator|&=
operator|~
operator|(
name|ADW_SCSI_CFG1_TERM_CTL_MASK
operator||
name|ADW2_SCSI_CFG1_TERM_CTL_LVD
operator||
name|ADW_SCSI_CFG1_BIG_ENDIAN
operator||
name|ADW_SCSI_CFG1_TERM_POL
operator||
name|ADW2_SCSI_CFG1_DEV_DETECT
operator|)
expr_stmt|;
name|scsicfg1
operator||=
name|term_scsicfg1
expr_stmt|;
block|}
else|else
block|{
name|term_scsicfg1
operator|=
operator|~
name|term_scsicfg1
operator|&
name|ADW_SCSI_CFG1_TERM_CTL_MASK
expr_stmt|;
name|scsicfg1
operator|&=
operator|~
name|ADW_SCSI_CFG1_TERM_CTL_MASK
expr_stmt|;
name|scsicfg1
operator||=
name|term_scsicfg1
operator||
name|ADW_SCSI_CFG1_TERM_CTL_MANUAL
expr_stmt|;
name|scsicfg1
operator||=
name|ADW_SCSI_CFG1_FLTR_DISABLE
expr_stmt|;
block|}
comment|/* 	 * Set SCSI_CFG1 Microcode Default Value 	 * 	 * The microcode will set the SCSI_CFG1 register using this value 	 * after it is started below. 	 */
name|adw_lram_write_16
argument_list|(
name|adw
argument_list|,
name|ADW_MC_DEFAULT_SCSI_CFG1
argument_list|,
name|scsicfg1
argument_list|)
expr_stmt|;
comment|/* 	 * Only accept selections on our initiator target id. 	 * This may change in target mode scenarios... 	 */
name|adw_lram_write_16
argument_list|(
name|adw
argument_list|,
name|ADW_MC_DEFAULT_SEL_MASK
argument_list|,
operator|(
literal|0x01
operator|<<
name|adw
operator|->
name|initiator_id
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Tell the microcode where it can find our 	 * Initiator Command Queue (ICQ).  It is 	 * currently empty hence the "stopper" address. 	 */
name|adw
operator|->
name|commandq
operator|=
name|adw
operator|->
name|free_carriers
expr_stmt|;
name|adw
operator|->
name|free_carriers
operator|=
name|carrierbotov
argument_list|(
name|adw
argument_list|,
name|adw
operator|->
name|commandq
operator|->
name|next_ba
argument_list|)
expr_stmt|;
name|adw
operator|->
name|commandq
operator|->
name|next_ba
operator|=
name|ADW_CQ_STOPPER
expr_stmt|;
name|adw_lram_write_32
argument_list|(
name|adw
argument_list|,
name|ADW_MC_ICQ
argument_list|,
name|adw
operator|->
name|commandq
operator|->
name|carr_ba
argument_list|)
expr_stmt|;
comment|/* 	 * Tell the microcode where it can find our 	 * Initiator Response Queue (IRQ).  It too 	 * is currently empty. 	 */
name|adw
operator|->
name|responseq
operator|=
name|adw
operator|->
name|free_carriers
expr_stmt|;
name|adw
operator|->
name|free_carriers
operator|=
name|carrierbotov
argument_list|(
name|adw
argument_list|,
name|adw
operator|->
name|responseq
operator|->
name|next_ba
argument_list|)
expr_stmt|;
name|adw
operator|->
name|responseq
operator|->
name|next_ba
operator|=
name|ADW_CQ_STOPPER
expr_stmt|;
name|adw_lram_write_32
argument_list|(
name|adw
argument_list|,
name|ADW_MC_IRQ
argument_list|,
name|adw
operator|->
name|responseq
operator|->
name|carr_ba
argument_list|)
expr_stmt|;
name|adw_outb
argument_list|(
name|adw
argument_list|,
name|ADW_INTR_ENABLES
argument_list|,
name|ADW_INTR_ENABLE_HOST_INTR
operator||
name|ADW_INTR_ENABLE_GLOBAL_INTR
argument_list|)
expr_stmt|;
name|adw_outw
argument_list|(
name|adw
argument_list|,
name|ADW_PC
argument_list|,
name|adw_lram_read_16
argument_list|(
name|adw
argument_list|,
name|ADW_MC_CODE_BEGIN_ADDR
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|adw_set_user_sdtr
parameter_list|(
name|struct
name|adw_softc
modifier|*
name|adw
parameter_list|,
name|u_int
name|tid
parameter_list|,
name|u_int
name|mc_sdtr
parameter_list|)
block|{
name|adw
operator|->
name|user_sdtr
index|[
name|ADW_TARGET_GROUP
argument_list|(
name|tid
argument_list|)
index|]
operator|&=
operator|~
name|ADW_TARGET_GROUP_MASK
argument_list|(
name|tid
argument_list|)
expr_stmt|;
name|adw
operator|->
name|user_sdtr
index|[
name|ADW_TARGET_GROUP
argument_list|(
name|tid
argument_list|)
index|]
operator||=
name|mc_sdtr
operator|<<
name|ADW_TARGET_GROUP_SHIFT
argument_list|(
name|tid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|u_int
name|adw_get_user_sdtr
parameter_list|(
name|struct
name|adw_softc
modifier|*
name|adw
parameter_list|,
name|u_int
name|tid
parameter_list|)
block|{
name|u_int
name|mc_sdtr
decl_stmt|;
name|mc_sdtr
operator|=
name|adw
operator|->
name|user_sdtr
index|[
name|ADW_TARGET_GROUP
argument_list|(
name|tid
argument_list|)
index|]
expr_stmt|;
name|mc_sdtr
operator|&=
name|ADW_TARGET_GROUP_MASK
argument_list|(
name|tid
argument_list|)
expr_stmt|;
name|mc_sdtr
operator|>>=
name|ADW_TARGET_GROUP_SHIFT
argument_list|(
name|tid
argument_list|)
expr_stmt|;
return|return
operator|(
name|mc_sdtr
operator|)
return|;
block|}
end_function

begin_function
name|void
name|adw_set_chip_sdtr
parameter_list|(
name|struct
name|adw_softc
modifier|*
name|adw
parameter_list|,
name|u_int
name|tid
parameter_list|,
name|u_int
name|sdtr
parameter_list|)
block|{
name|u_int
name|mc_sdtr_offset
decl_stmt|;
name|u_int
name|mc_sdtr
decl_stmt|;
name|mc_sdtr_offset
operator|=
name|ADW_MC_SDTR_SPEED1
expr_stmt|;
name|mc_sdtr_offset
operator|+=
name|ADW_TARGET_GROUP
argument_list|(
name|tid
argument_list|)
operator|*
literal|2
expr_stmt|;
name|mc_sdtr
operator|=
name|adw_lram_read_16
argument_list|(
name|adw
argument_list|,
name|mc_sdtr_offset
argument_list|)
expr_stmt|;
name|mc_sdtr
operator|&=
operator|~
name|ADW_TARGET_GROUP_MASK
argument_list|(
name|tid
argument_list|)
expr_stmt|;
name|mc_sdtr
operator||=
name|sdtr
operator|<<
name|ADW_TARGET_GROUP_SHIFT
argument_list|(
name|tid
argument_list|)
expr_stmt|;
name|adw_lram_write_16
argument_list|(
name|adw
argument_list|,
name|mc_sdtr_offset
argument_list|,
name|mc_sdtr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|u_int
name|adw_get_chip_sdtr
parameter_list|(
name|struct
name|adw_softc
modifier|*
name|adw
parameter_list|,
name|u_int
name|tid
parameter_list|)
block|{
name|u_int
name|mc_sdtr_offset
decl_stmt|;
name|u_int
name|mc_sdtr
decl_stmt|;
name|mc_sdtr_offset
operator|=
name|ADW_MC_SDTR_SPEED1
expr_stmt|;
name|mc_sdtr_offset
operator|+=
name|ADW_TARGET_GROUP
argument_list|(
name|tid
argument_list|)
operator|*
literal|2
expr_stmt|;
name|mc_sdtr
operator|=
name|adw_lram_read_16
argument_list|(
name|adw
argument_list|,
name|mc_sdtr_offset
argument_list|)
expr_stmt|;
name|mc_sdtr
operator|&=
name|ADW_TARGET_GROUP_MASK
argument_list|(
name|tid
argument_list|)
expr_stmt|;
name|mc_sdtr
operator|>>=
name|ADW_TARGET_GROUP_SHIFT
argument_list|(
name|tid
argument_list|)
expr_stmt|;
return|return
operator|(
name|mc_sdtr
operator|)
return|;
block|}
end_function

begin_function
name|u_int
name|adw_find_sdtr
parameter_list|(
name|struct
name|adw_softc
modifier|*
name|adw
parameter_list|,
name|u_int
name|period
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|adw
operator|->
name|features
operator|&
name|ADW_DT
operator|)
operator|==
literal|0
condition|)
name|i
operator|=
name|ADW_MC_SDTR_OFFSET_ULTRA2
expr_stmt|;
if|if
condition|(
operator|(
name|adw
operator|->
name|features
operator|&
name|ADW_ULTRA2
operator|)
operator|==
literal|0
condition|)
name|i
operator|=
name|ADW_MC_SDTR_OFFSET_ULTRA
expr_stmt|;
if|if
condition|(
name|period
operator|==
literal|0
condition|)
return|return
name|ADW_MC_SDTR_ASYNC
return|;
for|for
control|(
init|;
name|i
operator|<
name|adw_num_syncrates
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|period
operator|<=
name|adw_syncrates
index|[
name|i
index|]
operator|.
name|period
condition|)
return|return
operator|(
name|adw_syncrates
index|[
name|i
index|]
operator|.
name|mc_sdtr
operator|)
return|;
block|}
return|return
name|ADW_MC_SDTR_ASYNC
return|;
block|}
end_function

begin_function
name|u_int
name|adw_find_period
parameter_list|(
name|struct
name|adw_softc
modifier|*
name|adw
parameter_list|,
name|u_int
name|mc_sdtr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adw_num_syncrates
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mc_sdtr
operator|==
name|adw_syncrates
index|[
name|i
index|]
operator|.
name|mc_sdtr
condition|)
break|break;
block|}
return|return
operator|(
name|adw_syncrates
index|[
name|i
index|]
operator|.
name|period
operator|)
return|;
block|}
end_function

begin_function
name|u_int
name|adw_hshk_cfg_period_factor
parameter_list|(
name|u_int
name|tinfo
parameter_list|)
block|{
name|tinfo
operator|&=
name|ADW_HSHK_CFG_RATE_MASK
expr_stmt|;
name|tinfo
operator|>>=
name|ADW_HSHK_CFG_RATE_SHIFT
expr_stmt|;
if|if
condition|(
name|tinfo
operator|==
literal|0x11
condition|)
comment|/* 80MHz/DT */
return|return
operator|(
literal|9
operator|)
return|;
elseif|else
if|if
condition|(
name|tinfo
operator|==
literal|0x10
condition|)
comment|/* 40MHz */
return|return
operator|(
literal|10
operator|)
return|;
else|else
return|return
operator|(
operator|(
operator|(
name|tinfo
operator|*
literal|25
operator|)
operator|+
literal|50
operator|)
operator|/
literal|4
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send an idle command to the chip and wait for completion.  */
end_comment

begin_function
name|adw_idle_cmd_status_t
name|adw_idle_cmd_send
parameter_list|(
name|struct
name|adw_softc
modifier|*
name|adw
parameter_list|,
name|adw_idle_cmd_t
name|cmd
parameter_list|,
name|u_int
name|parameter
parameter_list|)
block|{
name|u_int
name|timeout
decl_stmt|;
name|adw_idle_cmd_status_t
name|status
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
comment|/* 	 * Clear the idle command status which is set by the microcode 	 * to a non-zero value to indicate when the command is completed. 	 */
name|adw_lram_write_16
argument_list|(
name|adw
argument_list|,
name|ADW_MC_IDLE_CMD_STATUS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Write the idle command value after the idle command parameter 	 * has been written to avoid a race condition. If the order is not 	 * followed, the microcode may process the idle command before the 	 * parameters have been written to LRAM. 	 */
name|adw_lram_write_32
argument_list|(
name|adw
argument_list|,
name|ADW_MC_IDLE_CMD_PARAMETER
argument_list|,
name|parameter
argument_list|)
expr_stmt|;
name|adw_lram_write_16
argument_list|(
name|adw
argument_list|,
name|ADW_MC_IDLE_CMD
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
comment|/* 	 * Tickle the RISC to tell it to process the idle command. 	 */
name|adw_tickle_risc
argument_list|(
name|adw
argument_list|,
name|ADW_TICKLE_B
argument_list|)
expr_stmt|;
comment|/* Wait for up to 10 seconds for the command to complete */
name|timeout
operator|=
literal|5000000
expr_stmt|;
while|while
condition|(
operator|--
name|timeout
condition|)
block|{
name|status
operator|=
name|adw_lram_read_16
argument_list|(
name|adw
argument_list|,
name|ADW_MC_IDLE_CMD_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|20
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"%s: Idle Command Timed Out!\n"
argument_list|,
name|adw_name
argument_list|(
name|adw
argument_list|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

end_unit

