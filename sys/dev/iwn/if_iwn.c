begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2007-2009  *	Damien Bergamini<damien.bergamini@free.fr>  * Copyright (c) 2008  *	Benjamin Close<benjsc@FreeBSD.org>  * Copyright (c) 2008 Sam Leffler, Errno Consulting  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/*  * Driver for Intel WiFi Link 4965 and 1000/5000/6000 Series 802.11 network  * adapters.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/firmware.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_amrr.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_radiotap.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_regdomain.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwn/if_iwnreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwn/if_iwnvar.h>
end_include

begin_function_decl
specifier|static
name|int
name|iwn_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|const
name|struct
name|iwn_hal
modifier|*
name|iwn_hal_attach
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_radiotap_attach
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ieee80211vap
modifier|*
name|iwn_vap_create
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
specifier|const
name|char
name|name
index|[
name|IFNAMSIZ
index|]
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|opmode
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|uint8_t
name|bssid
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_vap_delete
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_cleanup
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_nic_lock
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_eeprom_lock
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_init_otprom
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_read_prom_data
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_dma_contig_alloc
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_dma_info
modifier|*
parameter_list|,
name|void
modifier|*
modifier|*
parameter_list|,
name|bus_size_t
parameter_list|,
name|bus_size_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_dma_contig_free
parameter_list|(
name|struct
name|iwn_dma_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_alloc_sched
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_free_sched
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_alloc_kw
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_free_kw
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_alloc_ict
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_free_ict
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_alloc_fwmem
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_free_fwmem
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_alloc_rx_ring
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_reset_rx_ring
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_free_rx_ring
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_alloc_tx_ring
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_tx_ring
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_reset_tx_ring
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_free_tx_ring
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn5000_ict_reset
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_read_eeprom
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn4965_read_eeprom
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn4965_print_power_group
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn5000_read_eeprom
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_read_eeprom_channels
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_read_eeprom_enhinfo
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|ieee80211_node
modifier|*
name|iwn_node_alloc
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_newassoc
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_newstate
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|enum
name|ieee80211_state
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_rx_phy
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_timer_timeout
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_calib_reset
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_rx_done
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* HT */
end_comment

begin_endif
unit|void		iwn_rx_compressed_ba(struct iwn_softc *, struct iwn_rx_desc *, 		    struct iwn_rx_data *);
endif|#
directive|endif
end_endif

begin_function_decl
name|void
name|iwn5000_rx_calib_results
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_rx_statistics
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn4965_tx_done
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn5000_tx_done
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_tx_done
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_cmd_done
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_notif_intr
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_wakeup_intr
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_rftoggle_intr
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_fatal_intr
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn4965_update_sched
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|uint8_t
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn5000_update_sched
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|uint8_t
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn5000_reset_sched
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_tx_data
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|struct
name|iwn_tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_raw_xmit
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_watchdog
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_cmd
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn4965_add_node
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_node_info
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn5000_add_node
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_node_info
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_set_link_quality
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_add_broadcast_node
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_wme_update
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_update_mcast
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_set_led
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_set_critical_temp
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_set_timing
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn4965_power_calibration
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn4965_set_txpower
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn5000_set_txpower
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn4965_get_rssi
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_stat
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn5000_get_rssi
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_stat
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_get_noise
parameter_list|(
specifier|const
name|struct
name|iwn_rx_general_stats
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn4965_get_temperature
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn5000_get_temperature
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_init_sensitivity
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_collect_noise
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|iwn_rx_general_stats
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn4965_init_gains
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn5000_init_gains
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn4965_set_gains
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn5000_set_gains
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_tune_sensitivity
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|iwn_rx_stats
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_send_sensitivity
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_set_pslevel
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_config
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_scan
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_auth
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_run
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn5000_query_calibration
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn5000_send_calibration
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn5000_send_wimax_coex
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn4965_post_alive
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn5000_post_alive
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn4965_load_bootcode
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn4965_load_firmware
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn5000_load_firmware_section
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn5000_load_firmware
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_read_firmware
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_clock_wait
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_apm_init
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_apm_stop_master
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_apm_stop
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn4965_nic_config
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn5000_nic_config
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_hw_prepare
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_hw_init
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_hw_stop
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_init_locked
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_stop_locked
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_stop
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_scan_start
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_scan_end
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_set_channel
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_scan_curchan
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
parameter_list|,
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_scan_mindwell
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_setregdomain
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
name|struct
name|ieee80211_regdomain
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|ieee80211_channel
type|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_hw_reset
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_radio_on
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_radio_off
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_sysctlattach
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_shutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_suspend
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_resume
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|IWN_DEBUG
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|IWN_DEBUG
end_ifdef

begin_enum
enum|enum
block|{
name|IWN_DEBUG_XMIT
init|=
literal|0x00000001
block|,
comment|/* basic xmit operation */
name|IWN_DEBUG_RECV
init|=
literal|0x00000002
block|,
comment|/* basic recv operation */
name|IWN_DEBUG_STATE
init|=
literal|0x00000004
block|,
comment|/* 802.11 state transitions */
name|IWN_DEBUG_TXPOW
init|=
literal|0x00000008
block|,
comment|/* tx power processing */
name|IWN_DEBUG_RESET
init|=
literal|0x00000010
block|,
comment|/* reset processing */
name|IWN_DEBUG_OPS
init|=
literal|0x00000020
block|,
comment|/* iwn_ops processing */
name|IWN_DEBUG_BEACON
init|=
literal|0x00000040
block|,
comment|/* beacon handling */
name|IWN_DEBUG_WATCHDOG
init|=
literal|0x00000080
block|,
comment|/* watchdog timeout */
name|IWN_DEBUG_INTR
init|=
literal|0x00000100
block|,
comment|/* ISR */
name|IWN_DEBUG_CALIBRATE
init|=
literal|0x00000200
block|,
comment|/* periodic calibration */
name|IWN_DEBUG_NODE
init|=
literal|0x00000400
block|,
comment|/* node management */
name|IWN_DEBUG_LED
init|=
literal|0x00000800
block|,
comment|/* led management */
name|IWN_DEBUG_CMD
init|=
literal|0x00001000
block|,
comment|/* cmd submission */
name|IWN_DEBUG_FATAL
init|=
literal|0x80000000
block|,
comment|/* fatal errors */
name|IWN_DEBUG_ANY
init|=
literal|0xffffffff
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|sc
parameter_list|,
name|m
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
value|do {			\ 	if (sc->sc_debug& (m))				\ 		printf(fmt, __VA_ARGS__);		\ } while (0)
end_define

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|iwn_intr_str
parameter_list|(
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|sc
parameter_list|,
name|m
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
value|do { (void) sc; } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|iwn_ident
block|{
name|uint16_t
name|vendor
decl_stmt|;
name|uint16_t
name|device
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|iwn_ident
name|iwn_ident_table
index|[]
init|=
block|{
block|{
literal|0x8086
block|,
literal|0x4229
block|,
literal|"Intel(R) PRO/Wireless 4965BGN"
block|}
block|,
block|{
literal|0x8086
block|,
literal|0x422D
block|,
literal|"Intel(R) PRO/Wireless 4965BGN"
block|}
block|,
block|{
literal|0x8086
block|,
literal|0x4230
block|,
literal|"Intel(R) PRO/Wireless 4965BGN"
block|}
block|,
block|{
literal|0x8086
block|,
literal|0x4233
block|,
literal|"Intel(R) PRO/Wireless 4965BGN"
block|}
block|,
block|{
literal|0x8086
block|,
literal|0x4232
block|,
literal|"Intel(R) PRO/Wireless 5100"
block|}
block|,
block|{
literal|0x8086
block|,
literal|0x4237
block|,
literal|"Intel(R) PRO/Wireless 5100"
block|}
block|,
block|{
literal|0x8086
block|,
literal|0x423C
block|,
literal|"Intel(R) PRO/Wireless 5150"
block|}
block|,
block|{
literal|0x8086
block|,
literal|0x423D
block|,
literal|"Intel(R) PRO/Wireless 5150"
block|}
block|,
block|{
literal|0x8086
block|,
literal|0x4235
block|,
literal|"Intel(R) PRO/Wireless 5300"
block|}
block|,
block|{
literal|0x8086
block|,
literal|0x4236
block|,
literal|"Intel(R) PRO/Wireless 5300"
block|}
block|,
block|{
literal|0x8086
block|,
literal|0x4236
block|,
literal|"Intel(R) PRO/Wireless 5350"
block|}
block|,
block|{
literal|0x8086
block|,
literal|0x423A
block|,
literal|"Intel(R) PRO/Wireless 5350"
block|}
block|,
block|{
literal|0x8086
block|,
literal|0x423B
block|,
literal|"Intel(R) PRO/Wireless 5350"
block|}
block|,
block|{
literal|0x8086
block|,
literal|0x0083
block|,
literal|"Intel(R) PRO/Wireless 1000"
block|}
block|,
block|{
literal|0x8086
block|,
literal|0x0084
block|,
literal|"Intel(R) PRO/Wireless 1000"
block|}
block|,
block|{
literal|0x8086
block|,
literal|0x008D
block|,
literal|"Intel(R) PRO/Wireless 6000"
block|}
block|,
block|{
literal|0x8086
block|,
literal|0x008E
block|,
literal|"Intel(R) PRO/Wireless 6000"
block|}
block|,
block|{
literal|0x8086
block|,
literal|0x4238
block|,
literal|"Intel(R) PRO/Wireless 6000"
block|}
block|,
block|{
literal|0x8086
block|,
literal|0x4239
block|,
literal|"Intel(R) PRO/Wireless 6000"
block|}
block|,
block|{
literal|0x8086
block|,
literal|0x422B
block|,
literal|"Intel(R) PRO/Wireless 6000"
block|}
block|,
block|{
literal|0x8086
block|,
literal|0x422C
block|,
literal|"Intel(R) PRO/Wireless 6000"
block|}
block|,
block|{
literal|0x8086
block|,
literal|0x0086
block|,
literal|"Intel(R) PRO/Wireless 6050"
block|}
block|,
block|{
literal|0x8086
block|,
literal|0x0087
block|,
literal|"Intel(R) PRO/Wireless 6050"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|iwn_hal
name|iwn4965_hal
init|=
block|{
name|iwn4965_load_firmware
block|,
name|iwn4965_read_eeprom
block|,
name|iwn4965_post_alive
block|,
name|iwn4965_nic_config
block|,
name|iwn4965_update_sched
block|,
name|iwn4965_get_temperature
block|,
name|iwn4965_get_rssi
block|,
name|iwn4965_set_txpower
block|,
name|iwn4965_init_gains
block|,
name|iwn4965_set_gains
block|,
name|iwn4965_add_node
block|,
name|iwn4965_tx_done
block|,
if|#
directive|if
literal|0
comment|/* HT */
block|iwn4965_ampdu_tx_start, 	iwn4965_ampdu_tx_stop,
endif|#
directive|endif
name|IWN4965_NTXQUEUES
block|,
name|IWN4965_NDMACHNLS
block|,
name|IWN4965_ID_BROADCAST
block|,
name|IWN4965_RXONSZ
block|,
name|IWN4965_SCHEDSZ
block|,
name|IWN4965_FW_TEXT_MAXSZ
block|,
name|IWN4965_FW_DATA_MAXSZ
block|,
name|IWN4965_FWSZ
block|,
name|IWN4965_SCHED_TXFACT
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|iwn_hal
name|iwn5000_hal
init|=
block|{
name|iwn5000_load_firmware
block|,
name|iwn5000_read_eeprom
block|,
name|iwn5000_post_alive
block|,
name|iwn5000_nic_config
block|,
name|iwn5000_update_sched
block|,
name|iwn5000_get_temperature
block|,
name|iwn5000_get_rssi
block|,
name|iwn5000_set_txpower
block|,
name|iwn5000_init_gains
block|,
name|iwn5000_set_gains
block|,
name|iwn5000_add_node
block|,
name|iwn5000_tx_done
block|,
if|#
directive|if
literal|0
comment|/* HT */
block|iwn5000_ampdu_tx_start, 	iwn5000_ampdu_tx_stop,
endif|#
directive|endif
name|IWN5000_NTXQUEUES
block|,
name|IWN5000_NDMACHNLS
block|,
name|IWN5000_ID_BROADCAST
block|,
name|IWN5000_RXONSZ
block|,
name|IWN5000_SCHEDSZ
block|,
name|IWN5000_FW_TEXT_MAXSZ
block|,
name|IWN5000_FW_DATA_MAXSZ
block|,
name|IWN5000_FWSZ
block|,
name|IWN5000_SCHED_TXFACT
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|iwn_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
specifier|const
name|struct
name|iwn_ident
modifier|*
name|ident
decl_stmt|;
for|for
control|(
name|ident
operator|=
name|iwn_ident_table
init|;
name|ident
operator|->
name|name
operator|!=
name|NULL
condition|;
name|ident
operator|++
control|)
block|{
if|if
condition|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|ident
operator|->
name|vendor
operator|&&
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|ident
operator|->
name|device
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|ident
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
name|ENXIO
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|iwn_softc
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
specifier|const
name|struct
name|iwn_hal
modifier|*
name|hal
decl_stmt|;
name|uint32_t
name|tmp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|result
decl_stmt|;
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
decl_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
comment|/* 	 * Get the offset of the PCI Express Capability Structure in PCI 	 * Configuration Space. 	 */
name|error
operator|=
name|pci_find_extcap
argument_list|(
name|dev
argument_list|,
name|PCIY_EXPRESS
argument_list|,
operator|&
name|sc
operator|->
name|sc_cap_off
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"PCIe capability structure not found!\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Clear device-specific "PCI retry timeout" register (41h). */
name|pci_write_config
argument_list|(
name|dev
argument_list|,
literal|0x41
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Hardware bug workaround. */
name|tmp
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&
name|PCIM_CMD_INTxDIS
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"%s: PCIe INTx Disable set\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|tmp
operator|&=
operator|~
name|PCIM_CMD_INTxDIS
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|tmp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Enable bus-mastering. */
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mem_rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|mem_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate memory resources\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
return|return
name|error
return|;
block|}
name|sc
operator|->
name|sc_st
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|mem
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_sh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|mem
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq_rid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|result
operator|=
name|pci_msi_count
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
literal|1
operator|&&
name|pci_alloc_msi
argument_list|(
name|dev
argument_list|,
operator|&
name|result
argument_list|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|irq_rid
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|irq_rid
argument_list|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate interrupt resource\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|IWN_LOCK_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_timer_to
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_reinit_task
argument_list|,
literal|0
argument_list|,
name|iwn_hw_reset
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_radioon_task
argument_list|,
literal|0
argument_list|,
name|iwn_radio_on
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_radiooff_task
argument_list|,
literal|0
argument_list|,
name|iwn_radio_off
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* Attach Hardware Abstraction Layer. */
name|hal
operator|=
name|iwn_hal_attach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|hal
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
comment|/* XXX: Wrong error code? */
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|iwn_hw_prepare
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"hardware not ready, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Allocate DMA memory for firmware transfers. */
name|error
operator|=
name|iwn_alloc_fwmem
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate memory for firmware, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Allocate "Keep Warm" page. */
name|error
operator|=
name|iwn_alloc_kw
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate \"Keep Warm\" page, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Allocate ICT table for 5000 Series. */
if|if
condition|(
name|sc
operator|->
name|hw_type
operator|!=
name|IWN_HW_REV_TYPE_4965
operator|&&
operator|(
name|error
operator|=
name|iwn_alloc_ict
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: could not allocate ICT table, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Allocate TX scheduler "rings". */
name|error
operator|=
name|iwn_alloc_sched
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate TX scheduler rings, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Allocate TX rings (16 on 4965AGN, 20 on 5000). */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hal
operator|->
name|ntxqs
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|iwn_alloc_tx_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|txq
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate Tx ring %d, error %d\n"
argument_list|,
name|i
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* Allocate RX ring. */
name|error
operator|=
name|iwn_alloc_rx_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rxq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate Rx ring, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Clear pending interrupts. */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_INT
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* Count the number of available chains. */
name|sc
operator|->
name|ntxchains
operator|=
operator|(
operator|(
name|sc
operator|->
name|txchainmask
operator|>>
literal|2
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|sc
operator|->
name|txchainmask
operator|>>
literal|1
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|sc
operator|->
name|txchainmask
operator|>>
literal|0
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
name|sc
operator|->
name|nrxchains
operator|=
operator|(
operator|(
name|sc
operator|->
name|rxchainmask
operator|>>
literal|2
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|sc
operator|->
name|rxchainmask
operator|>>
literal|1
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|sc
operator|->
name|rxchainmask
operator|>>
literal|0
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|sc_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_IEEE80211
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can not allocate ifnet structure\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ic
operator|=
name|ifp
operator|->
name|if_l2com
expr_stmt|;
name|ic
operator|->
name|ic_ifp
operator|=
name|ifp
expr_stmt|;
name|ic
operator|->
name|ic_phytype
operator|=
name|IEEE80211_T_OFDM
expr_stmt|;
comment|/* not only, but not used */
name|ic
operator|->
name|ic_opmode
operator|=
name|IEEE80211_M_STA
expr_stmt|;
comment|/* default to BSS mode */
comment|/* Set device capabilities. */
name|ic
operator|->
name|ic_caps
operator|=
name|IEEE80211_C_STA
comment|/* station mode supported */
operator||
name|IEEE80211_C_MONITOR
comment|/* monitor mode supported */
operator||
name|IEEE80211_C_TXPMGT
comment|/* tx power management */
operator||
name|IEEE80211_C_SHSLOT
comment|/* short slot time supported */
operator||
name|IEEE80211_C_WPA
operator||
name|IEEE80211_C_SHPREAMBLE
comment|/* short preamble supported */
operator||
name|IEEE80211_C_BGSCAN
comment|/* background scanning */
if|#
directive|if
literal|0
expr|| IEEE80211_C_IBSS
comment|/* ibss/adhoc mode */
endif|#
directive|endif
operator||
name|IEEE80211_C_WME
comment|/* WME */
expr_stmt|;
if|#
directive|if
literal|0
comment|/* HT */
comment|/* XXX disable until HT channel setup works */
block|ic->ic_htcaps = 		  IEEE80211_HTCAP_SMPS_ENA
comment|/* SM PS mode enabled */
block|| IEEE80211_HTCAP_CHWIDTH40
comment|/* 40MHz channel width */
block|| IEEE80211_HTCAP_SHORTGI20
comment|/* short GI in 20MHz */
block|| IEEE80211_HTCAP_SHORTGI40
comment|/* short GI in 40MHz */
block|| IEEE80211_HTCAP_RXSTBC_2STREAM
comment|/* 1-2 spatial streams */
block|| IEEE80211_HTCAP_MAXAMSDU_3839
comment|/* max A-MSDU length */
comment|/* s/w capabilities */
block|| IEEE80211_HTC_HT
comment|/* HT operation */
block|| IEEE80211_HTC_AMPDU
comment|/* tx A-MPDU */
block|| IEEE80211_HTC_AMSDU
comment|/* tx A-MSDU */
block|;
comment|/* Set HT capabilities. */
block|ic->ic_htcaps =
if|#
directive|if
name|IWN_RBUF_SIZE
operator|==
literal|8192
block|IEEE80211_HTCAP_AMSDU7935 |
endif|#
directive|endif
block|IEEE80211_HTCAP_SMPS_DIS | 	    IEEE80211_HTCAP_CBW20_40 | 	    IEEE80211_HTCAP_SGI20 | 	    IEEE80211_HTCAP_SGI40; 	if (sc->hw_type != IWN_HW_REV_TYPE_4965) 		ic->ic_htcaps |= IEEE80211_HTCAP_GF;
endif|#
directive|endif
comment|/* Read MAC address, channels, etc from EEPROM. */
name|error
operator|=
name|iwn_read_eeprom
argument_list|(
name|sc
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not read EEPROM, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"MIMO %dT%dR, %.4s, address %6D\n"
argument_list|,
name|sc
operator|->
name|ntxchains
argument_list|,
name|sc
operator|->
name|nrxchains
argument_list|,
name|sc
operator|->
name|eeprom_domain
argument_list|,
name|macaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* HT */
comment|/* Set supported HT rates. */
block|ic->ic_sup_mcs[0] = 0xff; 	if (sc->nrxchains> 1) 		ic->ic_sup_mcs[1] = 0xff; 	if (sc->nrxchains> 2) 		ic->ic_sup_mcs[2] = 0xff;
endif|#
directive|endif
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|iwn_init
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|iwn_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|iwn_start
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|IFQ_MAXLEN
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|ieee80211_ifattach
argument_list|(
name|ic
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_vap_create
operator|=
name|iwn_vap_create
expr_stmt|;
name|ic
operator|->
name|ic_vap_delete
operator|=
name|iwn_vap_delete
expr_stmt|;
name|ic
operator|->
name|ic_raw_xmit
operator|=
name|iwn_raw_xmit
expr_stmt|;
name|ic
operator|->
name|ic_node_alloc
operator|=
name|iwn_node_alloc
expr_stmt|;
name|ic
operator|->
name|ic_newassoc
operator|=
name|iwn_newassoc
expr_stmt|;
name|ic
operator|->
name|ic_wme
operator|.
name|wme_update
operator|=
name|iwn_wme_update
expr_stmt|;
name|ic
operator|->
name|ic_update_mcast
operator|=
name|iwn_update_mcast
expr_stmt|;
name|ic
operator|->
name|ic_scan_start
operator|=
name|iwn_scan_start
expr_stmt|;
name|ic
operator|->
name|ic_scan_end
operator|=
name|iwn_scan_end
expr_stmt|;
name|ic
operator|->
name|ic_set_channel
operator|=
name|iwn_set_channel
expr_stmt|;
name|ic
operator|->
name|ic_scan_curchan
operator|=
name|iwn_scan_curchan
expr_stmt|;
name|ic
operator|->
name|ic_scan_mindwell
operator|=
name|iwn_scan_mindwell
expr_stmt|;
name|ic
operator|->
name|ic_setregdomain
operator|=
name|iwn_setregdomain
expr_stmt|;
if|#
directive|if
literal|0
comment|/* HT */
block|ic->ic_ampdu_rx_start = iwn_ampdu_rx_start; 	ic->ic_ampdu_rx_stop = iwn_ampdu_rx_stop; 	ic->ic_ampdu_tx_start = iwn_ampdu_tx_start; 	ic->ic_ampdu_tx_stop = iwn_ampdu_tx_stop;
endif|#
directive|endif
name|iwn_radiotap_attach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwn_sysctlattach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Hook our interrupt after all initialization is complete. 	 */
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|iwn_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not set up interrupt, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ieee80211_announce
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
name|iwn_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|const
name|struct
name|iwn_hal
modifier|*
name|iwn_hal_attach
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|hw_type
operator|=
operator|(
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_HW_REV
argument_list|)
operator|>>
literal|4
operator|)
operator|&
literal|0xf
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|hw_type
condition|)
block|{
case|case
name|IWN_HW_REV_TYPE_4965
case|:
name|sc
operator|->
name|sc_hal
operator|=
operator|&
name|iwn4965_hal
expr_stmt|;
name|sc
operator|->
name|limits
operator|=
operator|&
name|iwn4965_sensitivity_limits
expr_stmt|;
name|sc
operator|->
name|fwname
operator|=
literal|"iwn4965fw"
expr_stmt|;
name|sc
operator|->
name|txchainmask
operator|=
name|IWN_ANT_AB
expr_stmt|;
name|sc
operator|->
name|rxchainmask
operator|=
name|IWN_ANT_ABC
expr_stmt|;
break|break;
case|case
name|IWN_HW_REV_TYPE_5100
case|:
name|sc
operator|->
name|sc_hal
operator|=
operator|&
name|iwn5000_hal
expr_stmt|;
name|sc
operator|->
name|limits
operator|=
operator|&
name|iwn5000_sensitivity_limits
expr_stmt|;
name|sc
operator|->
name|fwname
operator|=
literal|"iwn5000fw"
expr_stmt|;
name|sc
operator|->
name|txchainmask
operator|=
name|IWN_ANT_B
expr_stmt|;
name|sc
operator|->
name|rxchainmask
operator|=
name|IWN_ANT_AB
expr_stmt|;
break|break;
case|case
name|IWN_HW_REV_TYPE_5150
case|:
name|sc
operator|->
name|sc_hal
operator|=
operator|&
name|iwn5000_hal
expr_stmt|;
name|sc
operator|->
name|limits
operator|=
operator|&
name|iwn5150_sensitivity_limits
expr_stmt|;
name|sc
operator|->
name|fwname
operator|=
literal|"iwn5150fw"
expr_stmt|;
name|sc
operator|->
name|txchainmask
operator|=
name|IWN_ANT_A
expr_stmt|;
name|sc
operator|->
name|rxchainmask
operator|=
name|IWN_ANT_AB
expr_stmt|;
break|break;
case|case
name|IWN_HW_REV_TYPE_5300
case|:
case|case
name|IWN_HW_REV_TYPE_5350
case|:
name|sc
operator|->
name|sc_hal
operator|=
operator|&
name|iwn5000_hal
expr_stmt|;
name|sc
operator|->
name|limits
operator|=
operator|&
name|iwn5000_sensitivity_limits
expr_stmt|;
name|sc
operator|->
name|fwname
operator|=
literal|"iwn5000fw"
expr_stmt|;
name|sc
operator|->
name|txchainmask
operator|=
name|IWN_ANT_ABC
expr_stmt|;
name|sc
operator|->
name|rxchainmask
operator|=
name|IWN_ANT_ABC
expr_stmt|;
break|break;
case|case
name|IWN_HW_REV_TYPE_1000
case|:
name|sc
operator|->
name|sc_hal
operator|=
operator|&
name|iwn5000_hal
expr_stmt|;
name|sc
operator|->
name|limits
operator|=
operator|&
name|iwn5000_sensitivity_limits
expr_stmt|;
name|sc
operator|->
name|fwname
operator|=
literal|"iwn1000fw"
expr_stmt|;
name|sc
operator|->
name|txchainmask
operator|=
name|IWN_ANT_A
expr_stmt|;
name|sc
operator|->
name|rxchainmask
operator|=
name|IWN_ANT_AB
expr_stmt|;
break|break;
case|case
name|IWN_HW_REV_TYPE_6000
case|:
name|sc
operator|->
name|sc_hal
operator|=
operator|&
name|iwn5000_hal
expr_stmt|;
name|sc
operator|->
name|limits
operator|=
operator|&
name|iwn6000_sensitivity_limits
expr_stmt|;
name|sc
operator|->
name|fwname
operator|=
literal|"iwn6000fw"
expr_stmt|;
switch|switch
condition|(
name|pci_get_device
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
condition|)
block|{
case|case
literal|0x422C
case|:
case|case
literal|0x4239
case|:
name|sc
operator|->
name|sc_flags
operator||=
name|IWN_FLAG_INTERNAL_PA
expr_stmt|;
name|sc
operator|->
name|txchainmask
operator|=
name|IWN_ANT_BC
expr_stmt|;
name|sc
operator|->
name|rxchainmask
operator|=
name|IWN_ANT_BC
expr_stmt|;
break|break;
default|default:
name|sc
operator|->
name|txchainmask
operator|=
name|IWN_ANT_ABC
expr_stmt|;
name|sc
operator|->
name|rxchainmask
operator|=
name|IWN_ANT_ABC
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|IWN_HW_REV_TYPE_6050
case|:
name|sc
operator|->
name|sc_hal
operator|=
operator|&
name|iwn5000_hal
expr_stmt|;
name|sc
operator|->
name|limits
operator|=
operator|&
name|iwn6000_sensitivity_limits
expr_stmt|;
name|sc
operator|->
name|fwname
operator|=
literal|"iwn6000fw"
expr_stmt|;
name|sc
operator|->
name|txchainmask
operator|=
name|IWN_ANT_AB
expr_stmt|;
name|sc
operator|->
name|rxchainmask
operator|=
name|IWN_ANT_AB
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"adapter type %d not supported\n"
argument_list|,
name|sc
operator|->
name|hw_type
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|sc
operator|->
name|sc_hal
return|;
block|}
end_function

begin_comment
comment|/*  * Attach the interface to 802.11 radiotap.  */
end_comment

begin_function
name|void
name|iwn_radiotap_attach
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|ieee80211_radiotap_attach
argument_list|(
name|ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_txtap
operator|.
name|wt_ihdr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_txtap
argument_list|)
argument_list|,
name|IWN_TX_RADIOTAP_PRESENT
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxtap
operator|.
name|wr_ihdr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_rxtap
argument_list|)
argument_list|,
name|IWN_RX_RADIOTAP_PRESENT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ieee80211vap
modifier|*
name|iwn_vap_create
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|char
name|name
index|[
name|IFNAMSIZ
index|]
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|opmode
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|uint8_t
name|bssid
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|iwn_vap
modifier|*
name|ivp
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
condition|)
comment|/* only one at a time */
return|return
name|NULL
return|;
name|ivp
operator|=
operator|(
expr|struct
name|iwn_vap
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_vap
argument_list|)
argument_list|,
name|M_80211_VAP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ivp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|vap
operator|=
operator|&
name|ivp
operator|->
name|iv_vap
expr_stmt|;
name|ieee80211_vap_setup
argument_list|(
name|ic
argument_list|,
name|vap
argument_list|,
name|name
argument_list|,
name|unit
argument_list|,
name|opmode
argument_list|,
name|flags
argument_list|,
name|bssid
argument_list|,
name|mac
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_bmissthreshold
operator|=
literal|10
expr_stmt|;
comment|/* override default */
comment|/* Override with driver methods. */
name|ivp
operator|->
name|iv_newstate
operator|=
name|vap
operator|->
name|iv_newstate
expr_stmt|;
name|vap
operator|->
name|iv_newstate
operator|=
name|iwn_newstate
expr_stmt|;
name|ieee80211_amrr_init
argument_list|(
operator|&
name|ivp
operator|->
name|iv_amrr
argument_list|,
name|vap
argument_list|,
name|IEEE80211_AMRR_MIN_SUCCESS_THRESHOLD
argument_list|,
name|IEEE80211_AMRR_MAX_SUCCESS_THRESHOLD
argument_list|,
literal|500
comment|/* ms */
argument_list|)
expr_stmt|;
comment|/* Complete setup. */
name|ieee80211_vap_attach
argument_list|(
name|vap
argument_list|,
name|ieee80211_media_change
argument_list|,
name|ieee80211_media_status
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_opmode
operator|=
name|opmode
expr_stmt|;
return|return
name|vap
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_vap_delete
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|iwn_vap
modifier|*
name|ivp
init|=
name|IWN_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|ieee80211_amrr_cleanup
argument_list|(
operator|&
name|ivp
operator|->
name|iv_amrr
argument_list|)
expr_stmt|;
name|ieee80211_vap_detach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ivp
argument_list|,
name|M_80211_VAP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|iwn_cleanup
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
block|{
name|ic
operator|=
name|ifp
operator|->
name|if_l2com
expr_stmt|;
name|ieee80211_draintask
argument_list|(
name|ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_reinit_task
argument_list|)
expr_stmt|;
name|ieee80211_draintask
argument_list|(
name|ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_radioon_task
argument_list|)
expr_stmt|;
name|ieee80211_draintask
argument_list|(
name|ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_radiooff_task
argument_list|)
expr_stmt|;
name|iwn_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_timer_to
argument_list|)
expr_stmt|;
name|ieee80211_ifdetach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
comment|/* Free DMA resources. */
name|iwn_free_rx_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rxq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_hal
operator|!=
name|NULL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_hal
operator|->
name|ntxqs
condition|;
name|i
operator|++
control|)
name|iwn_free_tx_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|iwn_free_sched
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwn_free_kw
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ict
operator|!=
name|NULL
condition|)
name|iwn_free_ict
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwn_free_fwmem
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq
operator|!=
name|NULL
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|sc
operator|->
name|sc_ih
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irq_rid
argument_list|,
name|sc
operator|->
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq_rid
operator|==
literal|1
condition|)
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|mem
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|mem_rid
argument_list|,
name|sc
operator|->
name|mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|IWN_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|iwn_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|iwn_nic_lock
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|ntries
decl_stmt|;
comment|/* Request exclusive access to NIC. */
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_GP_CNTRL
argument_list|,
name|IWN_GP_CNTRL_MAC_ACCESS_REQ
argument_list|)
expr_stmt|;
comment|/* Spin until we actually get the lock. */
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|1000
condition|;
name|ntries
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_GP_CNTRL
argument_list|)
operator|&
operator|(
name|IWN_GP_CNTRL_MAC_ACCESS_ENA
operator||
name|IWN_GP_CNTRL_SLEEP
operator|)
operator|)
operator|==
name|IWN_GP_CNTRL_MAC_ACCESS_ENA
condition|)
return|return
literal|0
return|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
return|return
name|ETIMEDOUT
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|iwn_nic_unlock
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|IWN_CLRBITS
argument_list|(
name|sc
argument_list|,
name|IWN_GP_CNTRL
argument_list|,
name|IWN_GP_CNTRL_MAC_ACCESS_REQ
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint32_t
name|iwn_prph_read
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|)
block|{
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_PRPH_RADDR
argument_list|,
name|IWN_PRPH_DWORD
operator||
name|addr
argument_list|)
expr_stmt|;
name|IWN_BARRIER_READ_WRITE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_PRPH_RDATA
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|iwn_prph_write
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|data
parameter_list|)
block|{
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_PRPH_WADDR
argument_list|,
name|IWN_PRPH_DWORD
operator||
name|addr
argument_list|)
expr_stmt|;
name|IWN_BARRIER_WRITE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_PRPH_WDATA
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|iwn_prph_setbits
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|mask
parameter_list|)
block|{
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|iwn_prph_read
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
operator||
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|iwn_prph_clrbits
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|mask
parameter_list|)
block|{
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|iwn_prph_read
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
operator|&
operator|~
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|iwn_prph_write_region_4
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
specifier|const
name|uint32_t
modifier|*
name|data
parameter_list|,
name|int
name|count
parameter_list|)
block|{
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|data
operator|++
operator|,
name|addr
operator|+=
literal|4
control|)
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
operator|*
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint32_t
name|iwn_mem_read
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|)
block|{
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_MEM_RADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|IWN_BARRIER_READ_WRITE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_MEM_RDATA
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|iwn_mem_write
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|data
parameter_list|)
block|{
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_MEM_WADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|IWN_BARRIER_WRITE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_MEM_WDATA
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|iwn_mem_write_2
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint16_t
name|data
parameter_list|)
block|{
name|uint32_t
name|tmp
decl_stmt|;
name|tmp
operator|=
name|iwn_mem_read
argument_list|(
name|sc
argument_list|,
name|addr
operator|&
operator|~
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|&
literal|3
condition|)
name|tmp
operator|=
operator|(
name|tmp
operator|&
literal|0x0000ffff
operator|)
operator||
name|data
operator|<<
literal|16
expr_stmt|;
else|else
name|tmp
operator|=
operator|(
name|tmp
operator|&
literal|0xffff0000
operator|)
operator||
name|data
expr_stmt|;
name|iwn_mem_write
argument_list|(
name|sc
argument_list|,
name|addr
operator|&
operator|~
literal|3
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|iwn_mem_read_region_4
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
modifier|*
name|data
parameter_list|,
name|int
name|count
parameter_list|)
block|{
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|addr
operator|+=
literal|4
control|)
operator|*
name|data
operator|++
operator|=
name|iwn_mem_read
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|iwn_mem_set_region_4
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|val
parameter_list|,
name|int
name|count
parameter_list|)
block|{
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|addr
operator|+=
literal|4
control|)
name|iwn_mem_write
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|iwn_eeprom_lock
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ntries
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
comment|/* Request exclusive access to EEPROM. */
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_HW_IF_CONFIG
argument_list|,
name|IWN_HW_IF_CONFIG_EEPROM_LOCKED
argument_list|)
expr_stmt|;
comment|/* Spin until we actually get the lock. */
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|100
condition|;
name|ntries
operator|++
control|)
block|{
if|if
condition|(
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_HW_IF_CONFIG
argument_list|)
operator|&
name|IWN_HW_IF_CONFIG_EEPROM_LOCKED
condition|)
return|return
literal|0
return|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ETIMEDOUT
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|iwn_eeprom_unlock
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|IWN_CLRBITS
argument_list|(
name|sc
argument_list|,
name|IWN_HW_IF_CONFIG
argument_list|,
name|IWN_HW_IF_CONFIG_EEPROM_LOCKED
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize access by host to One Time Programmable ROM.  * NB: This kind of ROM can be found on 1000 or 6000 Series only.  */
end_comment

begin_function
name|int
name|iwn_init_otprom
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|base
decl_stmt|;
name|uint16_t
name|next
decl_stmt|;
name|int
name|count
decl_stmt|,
name|error
decl_stmt|;
comment|/* Wait for clock stabilization before accessing prph. */
name|error
operator|=
name|iwn_clock_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|error
operator|=
name|iwn_nic_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|iwn_prph_setbits
argument_list|(
name|sc
argument_list|,
name|IWN_APMG_PS
argument_list|,
name|IWN_APMG_PS_RESET_REQ
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|iwn_prph_clrbits
argument_list|(
name|sc
argument_list|,
name|IWN_APMG_PS
argument_list|,
name|IWN_APMG_PS_RESET_REQ
argument_list|)
expr_stmt|;
name|iwn_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Set auto clock gate disable bit for HW with OTP shadow RAM. */
if|if
condition|(
name|sc
operator|->
name|hw_type
operator|!=
name|IWN_HW_REV_TYPE_1000
condition|)
block|{
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_DBG_LINK_PWR_MGMT
argument_list|,
name|IWN_RESET_LINK_PWR_MGMT_DIS
argument_list|)
expr_stmt|;
block|}
name|IWN_CLRBITS
argument_list|(
name|sc
argument_list|,
name|IWN_EEPROM_GP
argument_list|,
name|IWN_EEPROM_GP_IF_OWNER
argument_list|)
expr_stmt|;
comment|/* Clear ECC status. */
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_OTP_GP
argument_list|,
name|IWN_OTP_GP_ECC_CORR_STTS
operator||
name|IWN_OTP_GP_ECC_UNCORR_STTS
argument_list|)
expr_stmt|;
comment|/* 	 * Find last valid OTP block (contains the EEPROM image) for HW 	 * without OTP shadow RAM. 	 */
if|if
condition|(
name|sc
operator|->
name|hw_type
operator|==
name|IWN_HW_REV_TYPE_1000
condition|)
block|{
comment|/* Switch to absolute addressing mode. */
name|IWN_CLRBITS
argument_list|(
name|sc
argument_list|,
name|IWN_OTP_GP
argument_list|,
name|IWN_OTP_GP_RELATIVE_ACCESS
argument_list|)
expr_stmt|;
name|base
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|IWN1000_OTP_NBLOCKS
condition|;
name|count
operator|++
control|)
block|{
name|error
operator|=
name|iwn_read_prom_data
argument_list|(
name|sc
argument_list|,
name|base
argument_list|,
operator|&
name|next
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
name|next
operator|==
literal|0
condition|)
comment|/* End of linked-list. */
break|break;
name|base
operator|=
name|le16toh
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|base
operator|==
literal|0
operator|||
name|count
operator|==
name|IWN1000_OTP_NBLOCKS
condition|)
return|return
name|EIO
return|;
comment|/* Skip "next" word. */
name|sc
operator|->
name|prom_base
operator|=
name|base
operator|+
literal|1
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|iwn_read_prom_data
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|,
name|tmp
decl_stmt|;
name|int
name|ntries
decl_stmt|;
name|uint8_t
modifier|*
name|out
init|=
name|data
decl_stmt|;
name|addr
operator|+=
name|sc
operator|->
name|prom_base
expr_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|-=
literal|2
operator|,
name|addr
operator|++
control|)
block|{
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_EEPROM
argument_list|,
name|addr
operator|<<
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|10
condition|;
name|ntries
operator|++
control|)
block|{
name|val
operator|=
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_EEPROM
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|IWN_EEPROM_READ_VALID
condition|)
break|break;
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ntries
operator|==
literal|10
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"timeout reading ROM at 0x%x\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|ETIMEDOUT
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWN_FLAG_HAS_OTPROM
condition|)
block|{
comment|/* OTPROM, check for ECC errors. */
name|tmp
operator|=
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_OTP_GP
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&
name|IWN_OTP_GP_ECC_UNCORR_STTS
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"OTPROM ECC error at 0x%x\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
if|if
condition|(
name|tmp
operator|&
name|IWN_OTP_GP_ECC_CORR_STTS
condition|)
block|{
comment|/* Correctable ECC error, clear bit. */
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_OTP_GP
argument_list|,
name|IWN_OTP_GP_ECC_CORR_STTS
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|out
operator|++
operator|=
name|val
operator|>>
literal|16
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
operator|*
name|out
operator|++
operator|=
name|val
operator|>>
literal|24
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_dma_map_addr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return;
name|KASSERT
argument_list|(
name|nsegs
operator|==
literal|1
argument_list|,
operator|(
literal|"too many DMA segments, %d should be 1"
operator|,
name|nsegs
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_dma_contig_alloc
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_dma_info
modifier|*
name|dma
parameter_list|,
name|void
modifier|*
modifier|*
name|kvap
parameter_list|,
name|bus_size_t
name|size
parameter_list|,
name|bus_size_t
name|alignment
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|dma
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|dma
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|alignment
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|size
argument_list|,
literal|1
argument_list|,
name|size
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|dma
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: bus_dma_tag_create failed, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|dma
operator|->
name|vaddr
argument_list|,
name|flags
operator||
name|BUS_DMA_ZERO
argument_list|,
operator|&
name|dma
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: bus_dmamem_alloc failed, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|,
name|dma
operator|->
name|vaddr
argument_list|,
name|size
argument_list|,
name|iwn_dma_map_addr
argument_list|,
operator|&
name|dma
operator|->
name|paddr
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: bus_dmamap_load failed, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|kvap
operator|!=
name|NULL
condition|)
operator|*
name|kvap
operator|=
name|dma
operator|->
name|vaddr
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
name|iwn_dma_contig_free
argument_list|(
name|dma
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|void
name|iwn_dma_contig_free
parameter_list|(
name|struct
name|iwn_dma_info
modifier|*
name|dma
parameter_list|)
block|{
if|if
condition|(
name|dma
operator|->
name|tag
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dma
operator|->
name|map
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dma
operator|->
name|paddr
operator|==
literal|0
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|)
expr_stmt|;
block|}
name|bus_dmamem_free
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
operator|&
name|dma
operator|->
name|vaddr
argument_list|,
name|dma
operator|->
name|map
argument_list|)
expr_stmt|;
block|}
name|bus_dma_tag_destroy
argument_list|(
name|dma
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|iwn_alloc_sched
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* TX scheduler rings must be aligned on a 1KB boundary. */
return|return
name|iwn_dma_contig_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sched_dma
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|sched
argument_list|,
name|sc
operator|->
name|sc_hal
operator|->
name|schedsz
argument_list|,
literal|1024
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|iwn_free_sched
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|iwn_dma_contig_free
argument_list|(
operator|&
name|sc
operator|->
name|sched_dma
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|iwn_alloc_kw
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* "Keep Warm" page must be aligned on a 4KB boundary. */
return|return
name|iwn_dma_contig_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|kw_dma
argument_list|,
name|NULL
argument_list|,
literal|4096
argument_list|,
literal|4096
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|iwn_free_kw
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|iwn_dma_contig_free
argument_list|(
operator|&
name|sc
operator|->
name|kw_dma
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|iwn_alloc_ict
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* ICT table must be aligned on a 4KB boundary. */
return|return
name|iwn_dma_contig_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|ict_dma
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|ict
argument_list|,
name|IWN_ICT_SIZE
argument_list|,
literal|4096
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|iwn_free_ict
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|iwn_dma_contig_free
argument_list|(
operator|&
name|sc
operator|->
name|ict_dma
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|iwn_alloc_fwmem
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Must be aligned on a 16-byte boundary. */
return|return
name|iwn_dma_contig_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|fw_dma
argument_list|,
name|NULL
argument_list|,
name|sc
operator|->
name|sc_hal
operator|->
name|fwsz
argument_list|,
literal|16
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|iwn_free_fwmem
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|iwn_dma_contig_free
argument_list|(
operator|&
name|sc
operator|->
name|fw_dma
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|iwn_alloc_rx_ring
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_rx_ring
modifier|*
name|ring
parameter_list|)
block|{
name|bus_size_t
name|size
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|ring
operator|->
name|cur
operator|=
literal|0
expr_stmt|;
comment|/* Allocate RX descriptors (256-byte aligned). */
name|size
operator|=
name|IWN_RX_RING_COUNT
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_dma_contig_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|ring
operator|->
name|desc_dma
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ring
operator|->
name|desc
argument_list|,
name|size
argument_list|,
literal|256
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not allocate Rx ring DMA memory, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MJUMPAGESIZE
argument_list|,
literal|1
argument_list|,
name|MJUMPAGESIZE
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|ring
operator|->
name|data_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: bus_dma_tag_create_failed, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Allocate RX status area (16-byte aligned). */
name|error
operator|=
name|iwn_dma_contig_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|ring
operator|->
name|stat_dma
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ring
operator|->
name|stat
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_rx_status
argument_list|)
argument_list|,
literal|16
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not allocate Rx status DMA memory, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * Allocate and map RX buffers. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWN_RX_RING_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|iwn_rx_data
modifier|*
name|data
init|=
operator|&
name|ring
operator|->
name|data
index|[
name|i
index|]
decl_stmt|;
name|bus_addr_t
name|paddr
decl_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: bus_dmamap_create failed, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|data
operator|->
name|m
operator|=
name|m_getjcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|MJUMPAGESIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|m
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not allocate rx mbuf\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Map page. */
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|mtod
argument_list|(
name|data
operator|->
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|MJUMPAGESIZE
argument_list|,
name|iwn_dma_map_addr
argument_list|,
operator|&
name|paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|EFBIG
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: bus_dmamap_load failed, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|data
operator|->
name|m
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
comment|/* XXX unique code */
goto|goto
name|fail
goto|;
block|}
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Set physical address of RX buffer (256-byte aligned). */
name|ring
operator|->
name|desc
index|[
name|i
index|]
operator|=
name|htole32
argument_list|(
name|paddr
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|desc_dma
operator|.
name|tag
argument_list|,
name|ring
operator|->
name|desc_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
name|iwn_free_rx_ring
argument_list|(
name|sc
argument_list|,
name|ring
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|void
name|iwn_reset_rx_ring
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_rx_ring
modifier|*
name|ring
parameter_list|)
block|{
name|int
name|ntries
decl_stmt|;
if|if
condition|(
name|iwn_nic_lock
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
condition|)
block|{
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_RX_CONFIG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|1000
condition|;
name|ntries
operator|++
control|)
block|{
if|if
condition|(
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_FH_RX_STATUS
argument_list|)
operator|&
name|IWN_FH_RX_STATUS_IDLE
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|iwn_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IWN_DEBUG
if|if
condition|(
name|ntries
operator|==
literal|1000
condition|)
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_ANY
argument_list|,
literal|"%s\n"
argument_list|,
literal|"timeout resetting Rx ring"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|ring
operator|->
name|cur
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|last_rx_valid
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|iwn_free_rx_ring
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_rx_ring
modifier|*
name|ring
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|iwn_dma_contig_free
argument_list|(
operator|&
name|ring
operator|->
name|desc_dma
argument_list|)
expr_stmt|;
name|iwn_dma_contig_free
argument_list|(
operator|&
name|ring
operator|->
name|stat_dma
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWN_RX_RING_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|iwn_rx_data
modifier|*
name|data
init|=
operator|&
name|ring
operator|->
name|data
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|data
operator|->
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|->
name|map
operator|!=
name|NULL
condition|)
name|bus_dmamap_destroy
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|iwn_alloc_tx_ring
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_tx_ring
modifier|*
name|ring
parameter_list|,
name|int
name|qid
parameter_list|)
block|{
name|bus_size_t
name|size
decl_stmt|;
name|bus_addr_t
name|paddr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|ring
operator|->
name|qid
operator|=
name|qid
expr_stmt|;
name|ring
operator|->
name|queued
operator|=
literal|0
expr_stmt|;
name|ring
operator|->
name|cur
operator|=
literal|0
expr_stmt|;
comment|/* Allocate TX descriptors (256-byte aligned.) */
name|size
operator|=
name|IWN_TX_RING_COUNT
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_tx_desc
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_dma_contig_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|ring
operator|->
name|desc_dma
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ring
operator|->
name|desc
argument_list|,
name|size
argument_list|,
literal|256
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not allocate TX ring DMA memory, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * We only use rings 0 through 4 (4 EDCA + cmd) so there is no need 	 * to allocate commands space for other rings. 	 */
if|if
condition|(
name|qid
operator|>
literal|4
condition|)
return|return
literal|0
return|;
name|size
operator|=
name|IWN_TX_RING_COUNT
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_tx_cmd
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_dma_contig_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|ring
operator|->
name|cmd_dma
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ring
operator|->
name|cmd
argument_list|,
name|size
argument_list|,
literal|4
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not allocate TX cmd DMA memory, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MCLBYTES
argument_list|,
name|IWN_MAX_SCATTER
operator|-
literal|1
argument_list|,
name|MCLBYTES
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|ring
operator|->
name|data_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: bus_dma_tag_create_failed, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|paddr
operator|=
name|ring
operator|->
name|cmd_dma
operator|.
name|paddr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWN_TX_RING_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|iwn_tx_data
modifier|*
name|data
init|=
operator|&
name|ring
operator|->
name|data
index|[
name|i
index|]
decl_stmt|;
name|data
operator|->
name|cmd_paddr
operator|=
name|paddr
expr_stmt|;
name|data
operator|->
name|scratch_paddr
operator|=
name|paddr
operator|+
literal|12
expr_stmt|;
name|paddr
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_tx_cmd
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: bus_dmamap_create failed, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
name|fail
label|:
name|iwn_free_tx_ring
argument_list|(
name|sc
argument_list|,
name|ring
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|void
name|iwn_reset_tx_ring
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_tx_ring
modifier|*
name|ring
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWN_TX_RING_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|iwn_tx_data
modifier|*
name|data
init|=
operator|&
name|ring
operator|->
name|data
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|data
operator|->
name|m
argument_list|)
expr_stmt|;
name|data
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Clear TX descriptors. */
name|memset
argument_list|(
name|ring
operator|->
name|desc
argument_list|,
literal|0
argument_list|,
name|ring
operator|->
name|desc_dma
operator|.
name|size
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|desc_dma
operator|.
name|tag
argument_list|,
name|ring
operator|->
name|desc_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|qfullmsk
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|ring
operator|->
name|qid
operator|)
expr_stmt|;
name|ring
operator|->
name|queued
operator|=
literal|0
expr_stmt|;
name|ring
operator|->
name|cur
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|iwn_free_tx_ring
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_tx_ring
modifier|*
name|ring
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|iwn_dma_contig_free
argument_list|(
operator|&
name|ring
operator|->
name|desc_dma
argument_list|)
expr_stmt|;
name|iwn_dma_contig_free
argument_list|(
operator|&
name|ring
operator|->
name|cmd_dma
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWN_TX_RING_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|iwn_tx_data
modifier|*
name|data
init|=
operator|&
name|ring
operator|->
name|data
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|data
operator|->
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|->
name|map
operator|!=
name|NULL
condition|)
name|bus_dmamap_destroy
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|iwn5000_ict_reset
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Disable interrupts. */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_INT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reset ICT table. */
name|memset
argument_list|(
name|sc
operator|->
name|ict
argument_list|,
literal|0
argument_list|,
name|IWN_ICT_SIZE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ict_cur
operator|=
literal|0
expr_stmt|;
comment|/* Set physical address of ICT table (4KB aligned.) */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"%s: enabling ICT\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_DRAM_INT_TBL
argument_list|,
name|IWN_DRAM_INT_TBL_ENABLE
operator||
name|IWN_DRAM_INT_TBL_WRAP_CHECK
operator||
name|sc
operator|->
name|ict_dma
operator|.
name|paddr
operator|>>
literal|12
argument_list|)
expr_stmt|;
comment|/* Enable periodic RX interrupt. */
name|sc
operator|->
name|int_mask
operator||=
name|IWN_INT_RX_PERIODIC
expr_stmt|;
comment|/* Switch to ICT interrupt mode in driver. */
name|sc
operator|->
name|sc_flags
operator||=
name|IWN_FLAG_USE_ICT
expr_stmt|;
comment|/* Re-enable interrupts. */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_INT
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_INT_MASK
argument_list|,
name|sc
operator|->
name|int_mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|iwn_read_eeprom
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
specifier|const
name|struct
name|iwn_hal
modifier|*
name|hal
init|=
name|sc
operator|->
name|sc_hal
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint16_t
name|val
decl_stmt|;
comment|/* Check whether adapter has an EEPROM or an OTPROM. */
if|if
condition|(
name|sc
operator|->
name|hw_type
operator|>=
name|IWN_HW_REV_TYPE_1000
operator|&&
operator|(
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_OTP_GP
argument_list|)
operator|&
name|IWN_OTP_GP_DEV_SEL_OTP
operator|)
condition|)
name|sc
operator|->
name|sc_flags
operator||=
name|IWN_FLAG_HAS_OTPROM
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"%s found\n"
argument_list|,
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWN_FLAG_HAS_OTPROM
operator|)
condition|?
literal|"OTPROM"
else|:
literal|"EEPROM"
argument_list|)
expr_stmt|;
comment|/* Adapter has to be powered on for EEPROM access to work. */
name|error
operator|=
name|iwn_apm_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not power ON adapter, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
operator|(
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_EEPROM_GP
argument_list|)
operator|&
literal|0x7
operator|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: bad ROM signature\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
name|error
operator|=
name|iwn_eeprom_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not lock ROM, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWN_FLAG_HAS_OTPROM
condition|)
block|{
name|error
operator|=
name|iwn_init_otprom
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not initialize OTPROM, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
name|iwn_read_prom_data
argument_list|(
name|sc
argument_list|,
name|IWN_EEPROM_RFCFG
argument_list|,
operator|&
name|val
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rfcfg
operator|=
name|le16toh
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"radio config=0x%04x\n"
argument_list|,
name|sc
operator|->
name|rfcfg
argument_list|)
expr_stmt|;
comment|/* Read MAC address. */
name|iwn_read_prom_data
argument_list|(
name|sc
argument_list|,
name|IWN_EEPROM_MAC
argument_list|,
name|macaddr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* Read adapter-specific information from EEPROM. */
name|hal
operator|->
name|read_eeprom
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwn_apm_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Power OFF adapter. */
name|iwn_eeprom_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|iwn4965_read_eeprom
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|addr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint16_t
name|val
decl_stmt|;
comment|/* Read regulatory domain (4 ASCII characters.) */
name|iwn_read_prom_data
argument_list|(
name|sc
argument_list|,
name|IWN4965_EEPROM_DOMAIN
argument_list|,
name|sc
operator|->
name|eeprom_domain
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Read the list of authorized channels (20MHz ones only.) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|addr
operator|=
name|iwn4965_regulatory_bands
index|[
name|i
index|]
expr_stmt|;
name|iwn_read_eeprom_channels
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
comment|/* Read maximum allowed TX power for 2GHz and 5GHz bands. */
name|iwn_read_prom_data
argument_list|(
name|sc
argument_list|,
name|IWN4965_EEPROM_MAXPOW
argument_list|,
operator|&
name|val
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|maxpwr2GHz
operator|=
name|val
operator|&
literal|0xff
expr_stmt|;
name|sc
operator|->
name|maxpwr5GHz
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
comment|/* Check that EEPROM values are within valid range. */
if|if
condition|(
name|sc
operator|->
name|maxpwr5GHz
operator|<
literal|20
operator|||
name|sc
operator|->
name|maxpwr5GHz
operator|>
literal|50
condition|)
name|sc
operator|->
name|maxpwr5GHz
operator|=
literal|38
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|maxpwr2GHz
operator|<
literal|20
operator|||
name|sc
operator|->
name|maxpwr2GHz
operator|>
literal|50
condition|)
name|sc
operator|->
name|maxpwr2GHz
operator|=
literal|38
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"maxpwr 2GHz=%d 5GHz=%d\n"
argument_list|,
name|sc
operator|->
name|maxpwr2GHz
argument_list|,
name|sc
operator|->
name|maxpwr5GHz
argument_list|)
expr_stmt|;
comment|/* Read samples for each TX power group. */
name|iwn_read_prom_data
argument_list|(
name|sc
argument_list|,
name|IWN4965_EEPROM_BANDS
argument_list|,
name|sc
operator|->
name|bands
argument_list|,
sizeof|sizeof
name|sc
operator|->
name|bands
argument_list|)
expr_stmt|;
comment|/* Read voltage at which samples were taken. */
name|iwn_read_prom_data
argument_list|(
name|sc
argument_list|,
name|IWN4965_EEPROM_VOLTAGE
argument_list|,
operator|&
name|val
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|eeprom_voltage
operator|=
operator|(
name|int16_t
operator|)
name|le16toh
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"voltage=%d (in 0.3V)\n"
argument_list|,
name|sc
operator|->
name|eeprom_voltage
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IWN_DEBUG
comment|/* Print samples. */
if|if
condition|(
name|sc
operator|->
name|sc_debug
operator|&
name|IWN_DEBUG_ANY
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWN_NBANDS
condition|;
name|i
operator|++
control|)
name|iwn4965_print_power_group
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IWN_DEBUG
end_ifdef

begin_function
name|void
name|iwn4965_print_power_group
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|struct
name|iwn4965_eeprom_band
modifier|*
name|band
init|=
operator|&
name|sc
operator|->
name|bands
index|[
name|i
index|]
decl_stmt|;
name|struct
name|iwn4965_eeprom_chan_samples
modifier|*
name|chans
init|=
name|band
operator|->
name|chans
decl_stmt|;
name|int
name|j
decl_stmt|,
name|c
decl_stmt|;
name|printf
argument_list|(
literal|"===band %d===\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"chan lo=%d, chan hi=%d\n"
argument_list|,
name|band
operator|->
name|lo
argument_list|,
name|band
operator|->
name|hi
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"chan1 num=%d\n"
argument_list|,
name|chans
index|[
literal|0
index|]
operator|.
name|num
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|2
condition|;
name|c
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|IWN_NSAMPLES
condition|;
name|j
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"chain %d, sample %d: temp=%d gain=%d "
literal|"power=%d pa_det=%d\n"
argument_list|,
name|c
argument_list|,
name|j
argument_list|,
name|chans
index|[
literal|0
index|]
operator|.
name|samples
index|[
name|c
index|]
index|[
name|j
index|]
operator|.
name|temp
argument_list|,
name|chans
index|[
literal|0
index|]
operator|.
name|samples
index|[
name|c
index|]
index|[
name|j
index|]
operator|.
name|gain
argument_list|,
name|chans
index|[
literal|0
index|]
operator|.
name|samples
index|[
name|c
index|]
index|[
name|j
index|]
operator|.
name|power
argument_list|,
name|chans
index|[
literal|0
index|]
operator|.
name|samples
index|[
name|c
index|]
index|[
name|j
index|]
operator|.
name|pa_det
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"chan2 num=%d\n"
argument_list|,
name|chans
index|[
literal|1
index|]
operator|.
name|num
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|2
condition|;
name|c
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|IWN_NSAMPLES
condition|;
name|j
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"chain %d, sample %d: temp=%d gain=%d "
literal|"power=%d pa_det=%d\n"
argument_list|,
name|c
argument_list|,
name|j
argument_list|,
name|chans
index|[
literal|1
index|]
operator|.
name|samples
index|[
name|c
index|]
index|[
name|j
index|]
operator|.
name|temp
argument_list|,
name|chans
index|[
literal|1
index|]
operator|.
name|samples
index|[
name|c
index|]
index|[
name|j
index|]
operator|.
name|gain
argument_list|,
name|chans
index|[
literal|1
index|]
operator|.
name|samples
index|[
name|c
index|]
index|[
name|j
index|]
operator|.
name|power
argument_list|,
name|chans
index|[
literal|1
index|]
operator|.
name|samples
index|[
name|c
index|]
index|[
name|j
index|]
operator|.
name|pa_det
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|iwn5000_read_eeprom
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int32_t
name|temp
decl_stmt|,
name|volt
decl_stmt|;
name|uint32_t
name|addr
decl_stmt|,
name|base
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint16_t
name|val
decl_stmt|;
comment|/* Read regulatory domain (4 ASCII characters.) */
name|iwn_read_prom_data
argument_list|(
name|sc
argument_list|,
name|IWN5000_EEPROM_REG
argument_list|,
operator|&
name|val
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|base
operator|=
name|le16toh
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|iwn_read_prom_data
argument_list|(
name|sc
argument_list|,
name|base
operator|+
name|IWN5000_EEPROM_DOMAIN
argument_list|,
name|sc
operator|->
name|eeprom_domain
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Read the list of authorized channels (20MHz ones only.) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|addr
operator|=
name|base
operator|+
name|iwn5000_regulatory_bands
index|[
name|i
index|]
expr_stmt|;
name|iwn_read_eeprom_channels
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
comment|/* Read enhanced TX power information for 6000 Series. */
if|if
condition|(
name|sc
operator|->
name|hw_type
operator|>=
name|IWN_HW_REV_TYPE_6000
condition|)
name|iwn_read_eeprom_enhinfo
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwn_read_prom_data
argument_list|(
name|sc
argument_list|,
name|IWN5000_EEPROM_CAL
argument_list|,
operator|&
name|val
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|base
operator|=
name|le16toh
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hw_type
operator|==
name|IWN_HW_REV_TYPE_5150
condition|)
block|{
comment|/* Compute temperature offset. */
name|iwn_read_prom_data
argument_list|(
name|sc
argument_list|,
name|base
operator|+
name|IWN5000_EEPROM_TEMP
argument_list|,
operator|&
name|val
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|temp
operator|=
name|le16toh
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|iwn_read_prom_data
argument_list|(
name|sc
argument_list|,
name|base
operator|+
name|IWN5000_EEPROM_VOLT
argument_list|,
operator|&
name|val
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|volt
operator|=
name|le16toh
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|sc
operator|->
name|temp_off
operator|=
name|temp
operator|-
operator|(
name|volt
operator|/
operator|-
literal|5
operator|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"temp=%d volt=%d offset=%dK\n"
argument_list|,
name|temp
argument_list|,
name|volt
argument_list|,
name|sc
operator|->
name|temp_off
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Read crystal calibration. */
name|iwn_read_prom_data
argument_list|(
name|sc
argument_list|,
name|base
operator|+
name|IWN5000_EEPROM_CRYSTAL
argument_list|,
operator|&
name|sc
operator|->
name|eeprom_crystal
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"crystal calibration 0x%08x\n"
argument_list|,
name|le32toh
argument_list|(
name|sc
operator|->
name|eeprom_crystal
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Translate EEPROM flags to net80211.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|iwn_eeprom_channel_flags
parameter_list|(
name|struct
name|iwn_eeprom_chan
modifier|*
name|channel
parameter_list|)
block|{
name|uint32_t
name|nflags
decl_stmt|;
name|nflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|channel
operator|->
name|flags
operator|&
name|IWN_EEPROM_CHAN_ACTIVE
operator|)
operator|==
literal|0
condition|)
name|nflags
operator||=
name|IEEE80211_CHAN_PASSIVE
expr_stmt|;
if|if
condition|(
operator|(
name|channel
operator|->
name|flags
operator|&
name|IWN_EEPROM_CHAN_IBSS
operator|)
operator|==
literal|0
condition|)
name|nflags
operator||=
name|IEEE80211_CHAN_NOADHOC
expr_stmt|;
if|if
condition|(
name|channel
operator|->
name|flags
operator|&
name|IWN_EEPROM_CHAN_RADAR
condition|)
block|{
name|nflags
operator||=
name|IEEE80211_CHAN_DFS
expr_stmt|;
comment|/* XXX apparently IBSS may still be marked */
name|nflags
operator||=
name|IEEE80211_CHAN_NOADHOC
expr_stmt|;
block|}
return|return
name|nflags
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_read_eeprom_band
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|iwn_eeprom_chan
modifier|*
name|channels
init|=
name|sc
operator|->
name|eeprom_channels
index|[
name|n
index|]
decl_stmt|;
specifier|const
name|struct
name|iwn_chan_band
modifier|*
name|band
init|=
operator|&
name|iwn_bands
index|[
name|n
index|]
decl_stmt|;
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|;
name|int
name|i
decl_stmt|,
name|chan
decl_stmt|,
name|nflags
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|band
operator|->
name|nchan
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|channels
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|IWN_EEPROM_CHAN_VALID
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"skip chan %d flags 0x%x maxpwr %d\n"
argument_list|,
name|band
operator|->
name|chan
index|[
name|i
index|]
argument_list|,
name|channels
index|[
name|i
index|]
operator|.
name|flags
argument_list|,
name|channels
index|[
name|i
index|]
operator|.
name|maxpwr
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|chan
operator|=
name|band
operator|->
name|chan
index|[
name|i
index|]
expr_stmt|;
name|nflags
operator|=
name|iwn_eeprom_channel_flags
argument_list|(
operator|&
name|channels
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"add chan %d flags 0x%x maxpwr %d\n"
argument_list|,
name|chan
argument_list|,
name|channels
index|[
name|i
index|]
operator|.
name|flags
argument_list|,
name|channels
index|[
name|i
index|]
operator|.
name|maxpwr
argument_list|)
expr_stmt|;
name|c
operator|=
operator|&
name|ic
operator|->
name|ic_channels
index|[
name|ic
operator|->
name|ic_nchans
operator|++
index|]
expr_stmt|;
name|c
operator|->
name|ic_ieee
operator|=
name|chan
expr_stmt|;
name|c
operator|->
name|ic_maxregpower
operator|=
name|channels
index|[
name|i
index|]
operator|.
name|maxpwr
expr_stmt|;
name|c
operator|->
name|ic_maxpower
operator|=
literal|2
operator|*
name|c
operator|->
name|ic_maxregpower
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
comment|/* 2GHz band */
name|c
operator|->
name|ic_freq
operator|=
name|ieee80211_ieee2mhz
argument_list|(
name|chan
argument_list|,
name|IEEE80211_CHAN_G
argument_list|)
expr_stmt|;
comment|/* G =>'s B is supported */
name|c
operator|->
name|ic_flags
operator|=
name|IEEE80211_CHAN_B
operator||
name|nflags
expr_stmt|;
name|c
operator|=
operator|&
name|ic
operator|->
name|ic_channels
index|[
name|ic
operator|->
name|ic_nchans
operator|++
index|]
expr_stmt|;
name|c
index|[
literal|0
index|]
operator|=
name|c
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|c
operator|->
name|ic_flags
operator|=
name|IEEE80211_CHAN_G
operator||
name|nflags
expr_stmt|;
block|}
else|else
block|{
comment|/* 5GHz band */
name|c
operator|->
name|ic_freq
operator|=
name|ieee80211_ieee2mhz
argument_list|(
name|chan
argument_list|,
name|IEEE80211_CHAN_A
argument_list|)
expr_stmt|;
name|c
operator|->
name|ic_flags
operator|=
name|IEEE80211_CHAN_A
operator||
name|nflags
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|IWN_FLAG_HAS_5GHZ
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* HT */
comment|/* XXX no constraints on using HT20 */
comment|/* add HT20, HT40 added separately */
block|c =&ic->ic_channels[ic->ic_nchans++]; 		c[0] = c[-1]; 		c->ic_flags |= IEEE80211_CHAN_HT20;
comment|/* XXX NARROW =>'s 1/2 and 1/4 width? */
endif|#
directive|endif
block|}
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* HT */
end_comment

begin_comment
unit|static void iwn_read_eeprom_ht40(struct iwn_softc *sc, int n) { 	struct ifnet *ifp = sc->sc_ifp; 	struct ieee80211com *ic = ifp->if_l2com; 	struct iwn_eeprom_chan *channels = sc->eeprom_channels[n]; 	const struct iwn_chan_band *band =&iwn_bands[n]; 	struct ieee80211_channel *c, *cent, *extc; 	int i;  	for (i = 0; i< band->nchan; i++) { 		if (!(channels[i].flags& IWN_EEPROM_CHAN_VALID) || 		    !(channels[i].flags& IWN_EEPROM_CHAN_WIDE)) { 			DPRINTF(sc, IWN_DEBUG_RESET, 			    "skip chan %d flags 0x%x maxpwr %d\n", 			    band->chan[i], channels[i].flags, 			    channels[i].maxpwr); 			continue; 		}
comment|/* 		 * Each entry defines an HT40 channel pair; find the 		 * center channel, then the extension channel above. 		 */
end_comment

begin_comment
unit|cent = ieee80211_find_channel_byieee(ic, band->chan[i], 		    band->flags& ~IEEE80211_CHAN_HT); 		if (cent == NULL) {
comment|/* XXX shouldn't happen */
end_comment

begin_endif
unit|device_printf(sc->sc_dev, 			    "%s: no entry for channel %d\n", 			    __func__, band->chan[i]); 			continue; 		} 		extc = ieee80211_find_channel(ic, cent->ic_freq+20, 		    band->flags& ~IEEE80211_CHAN_HT); 		if (extc == NULL) { 			DPRINTF(sc, IWN_DEBUG_RESET, 			    "skip chan %d, extension channel not found\n", 			    band->chan[i]); 			continue; 		}  		DPRINTF(sc, IWN_DEBUG_RESET, 		    "add ht40 chan %d flags 0x%x maxpwr %d\n", 		    band->chan[i], channels[i].flags, channels[i].maxpwr);  		c =&ic->ic_channels[ic->ic_nchans++]; 		c[0] = cent[0]; 		c->ic_extieee = extc->ic_ieee; 		c->ic_flags&= ~IEEE80211_CHAN_HT; 		c->ic_flags |= IEEE80211_CHAN_HT40U; 		c =&ic->ic_channels[ic->ic_nchans++]; 		c[0] = extc[0]; 		c->ic_extieee = cent->ic_ieee; 		c->ic_flags&= ~IEEE80211_CHAN_HT; 		c->ic_flags |= IEEE80211_CHAN_HT40D; 	} }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|iwn_read_eeprom_channels
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|n
parameter_list|,
name|uint32_t
name|addr
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|iwn_read_prom_data
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
operator|&
name|sc
operator|->
name|eeprom_channels
index|[
name|n
index|]
argument_list|,
name|iwn_bands
index|[
name|n
index|]
operator|.
name|nchan
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_eeprom_chan
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|5
condition|)
name|iwn_read_eeprom_band
argument_list|(
name|sc
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* HT */
block|else 		iwn_read_eeprom_ht40(sc, n);
endif|#
directive|endif
name|ieee80211_sort_channels
argument_list|(
name|ic
operator|->
name|ic_channels
argument_list|,
name|ic
operator|->
name|ic_nchans
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|nitems
parameter_list|(
name|_a
parameter_list|)
value|(sizeof((_a)) / sizeof((_a)[0]))
end_define

begin_function
name|void
name|iwn_read_eeprom_enhinfo
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwn_eeprom_enhinfo
name|enhinfo
index|[
literal|35
index|]
decl_stmt|;
name|uint16_t
name|val
decl_stmt|,
name|base
decl_stmt|;
name|int8_t
name|maxpwr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|iwn_read_prom_data
argument_list|(
name|sc
argument_list|,
name|IWN5000_EEPROM_REG
argument_list|,
operator|&
name|val
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|base
operator|=
name|le16toh
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|iwn_read_prom_data
argument_list|(
name|sc
argument_list|,
name|base
operator|+
name|IWN6000_EEPROM_ENHINFO
argument_list|,
name|enhinfo
argument_list|,
sizeof|sizeof
name|enhinfo
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sc
operator|->
name|enh_maxpwr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|sc
operator|->
name|enh_maxpwr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|enhinfo
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|enhinfo
index|[
name|i
index|]
operator|.
name|chan
operator|==
literal|0
operator|||
name|enhinfo
index|[
name|i
index|]
operator|.
name|reserved
operator|!=
literal|0
condition|)
continue|continue;
comment|/* Skip invalid entries. */
name|maxpwr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|txchainmask
operator|&
name|IWN_ANT_A
condition|)
name|maxpwr
operator|=
name|MAX
argument_list|(
name|maxpwr
argument_list|,
name|enhinfo
index|[
name|i
index|]
operator|.
name|chain
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|txchainmask
operator|&
name|IWN_ANT_B
condition|)
name|maxpwr
operator|=
name|MAX
argument_list|(
name|maxpwr
argument_list|,
name|enhinfo
index|[
name|i
index|]
operator|.
name|chain
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|txchainmask
operator|&
name|IWN_ANT_C
condition|)
name|maxpwr
operator|=
name|MAX
argument_list|(
name|maxpwr
argument_list|,
name|enhinfo
index|[
name|i
index|]
operator|.
name|chain
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ntxchains
operator|==
literal|2
condition|)
name|maxpwr
operator|=
name|MAX
argument_list|(
name|maxpwr
argument_list|,
name|enhinfo
index|[
name|i
index|]
operator|.
name|mimo2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|ntxchains
operator|==
literal|3
condition|)
name|maxpwr
operator|=
name|MAX
argument_list|(
name|maxpwr
argument_list|,
name|enhinfo
index|[
name|i
index|]
operator|.
name|mimo3
argument_list|)
expr_stmt|;
name|maxpwr
operator|/=
literal|2
expr_stmt|;
comment|/* Convert half-dBm to dBm. */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"enhinfo %d, maxpwr=%d\n"
argument_list|,
name|i
argument_list|,
name|maxpwr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|enh_maxpwr
index|[
name|i
index|]
operator|=
name|maxpwr
expr_stmt|;
block|}
block|}
end_function

begin_function
name|struct
name|ieee80211_node
modifier|*
name|iwn_node_alloc
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
return|return
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_node
argument_list|)
argument_list|,
name|M_80211_NODE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|iwn_newassoc
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|isnew
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|iwn_node
modifier|*
name|wn
init|=
operator|(
name|void
operator|*
operator|)
name|ni
decl_stmt|;
name|ieee80211_amrr_node_init
argument_list|(
operator|&
name|IWN_VAP
argument_list|(
name|vap
argument_list|)
operator|->
name|iv_amrr
argument_list|,
operator|&
name|wn
operator|->
name|amn
argument_list|,
name|ni
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|iwn_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|int
name|error
init|=
name|ieee80211_media_change
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
comment|/* NB: only the fixed rate can change and that doesn't need a reset */
return|return
operator|(
name|error
operator|==
name|ENETRESET
condition|?
literal|0
else|:
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|iwn_newstate
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|enum
name|ieee80211_state
name|nstate
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
name|struct
name|iwn_vap
modifier|*
name|ivp
init|=
name|IWN_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_STATE
argument_list|,
literal|"%s: %s -> %s\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_state_name
index|[
name|vap
operator|->
name|iv_state
index|]
argument_list|,
name|ieee80211_state_name
index|[
name|nstate
index|]
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_timer_to
argument_list|)
expr_stmt|;
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_AUTH
operator|&&
name|vap
operator|->
name|iv_state
operator|!=
name|IEEE80211_S_AUTH
condition|)
block|{
comment|/* !AUTH -> AUTH requires adapter config */
comment|/* Reset state to handle reassociations correctly. */
name|sc
operator|->
name|rxon
operator|.
name|associd
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rxon
operator|.
name|filter
operator|&=
operator|~
name|htole32
argument_list|(
name|IWN_FILTER_BSS
argument_list|)
expr_stmt|;
name|iwn_calib_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_auth
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_RUN
operator|&&
name|vap
operator|->
name|iv_state
operator|!=
name|IEEE80211_S_RUN
condition|)
block|{
comment|/* 		 * !RUN -> RUN requires setting the association id 		 * which is done with a firmware cmd.  We also defer 		 * starting the timers until that work is done. 		 */
name|error
operator|=
name|iwn_run
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_RUN
condition|)
block|{
comment|/* 		 * RUN -> RUN transition; just restart the timers. 		 */
name|iwn_calib_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return
name|ivp
operator|->
name|iv_newstate
argument_list|(
name|vap
argument_list|,
name|nstate
argument_list|,
name|arg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process an RX_PHY firmware notification.  This is usually immediately  * followed by an MPDU_RX_DONE notification.  */
end_comment

begin_function
name|void
name|iwn_rx_phy
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
name|desc
parameter_list|,
name|struct
name|iwn_rx_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|iwn_rx_stat
modifier|*
name|stat
init|=
operator|(
expr|struct
name|iwn_rx_stat
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s: received PHY stats\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Save RX statistics, they will be used on MPDU_RX_DONE. */
name|memcpy
argument_list|(
operator|&
name|sc
operator|->
name|last_rx_stat
argument_list|,
name|stat
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stat
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|last_rx_valid
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_timer_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|uint32_t
name|flags
init|=
literal|0
decl_stmt|;
name|IWN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|calib_cnt
operator|&&
operator|--
name|sc
operator|->
name|calib_cnt
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s\n"
argument_list|,
literal|"send statistics request"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_GET_STATISTICS
argument_list|,
operator|&
name|flags
argument_list|,
sizeof|sizeof
name|flags
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|calib_cnt
operator|=
literal|60
expr_stmt|;
comment|/* do calibration every 60s */
block|}
name|iwn_watchdog
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* NB: piggyback tx watchdog */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_timer_to
argument_list|,
name|hz
argument_list|,
name|iwn_timer_timeout
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_calib_reset
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_timer_to
argument_list|,
name|hz
argument_list|,
name|iwn_timer_timeout
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|calib_cnt
operator|=
literal|60
expr_stmt|;
comment|/* do calibration every 60s */
block|}
end_function

begin_comment
comment|/*  * Process an RX_DONE (4965AGN only) or MPDU_RX_DONE firmware notification.  * Each MPDU_RX_DONE notification must be preceded by an RX_PHY one.  */
end_comment

begin_function
name|void
name|iwn_rx_done
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
name|desc
parameter_list|,
name|struct
name|iwn_rx_data
modifier|*
name|data
parameter_list|)
block|{
specifier|const
name|struct
name|iwn_hal
modifier|*
name|hal
init|=
name|sc
operator|->
name|sc_hal
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|iwn_rx_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|rxq
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m1
decl_stmt|;
name|struct
name|iwn_rx_stat
modifier|*
name|stat
decl_stmt|;
name|caddr_t
name|head
decl_stmt|;
name|bus_addr_t
name|paddr
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|int
name|error
decl_stmt|,
name|len
decl_stmt|,
name|rssi
decl_stmt|,
name|nf
decl_stmt|;
if|if
condition|(
name|desc
operator|->
name|type
operator|==
name|IWN_MPDU_RX_DONE
condition|)
block|{
comment|/* Check for prior RX_PHY notification. */
if|if
condition|(
operator|!
name|sc
operator|->
name|last_rx_valid
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_ANY
argument_list|,
literal|"%s: missing RX_PHY\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|last_rx_valid
operator|=
literal|0
expr_stmt|;
name|stat
operator|=
operator|&
name|sc
operator|->
name|last_rx_stat
expr_stmt|;
block|}
else|else
name|stat
operator|=
operator|(
expr|struct
name|iwn_rx_stat
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|->
name|cfg_phy_len
operator|>
name|IWN_STAT_MAXLEN
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: invalid rx statistic header, len %d\n"
argument_list|,
name|__func__
argument_list|,
name|stat
operator|->
name|cfg_phy_len
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|desc
operator|->
name|type
operator|==
name|IWN_MPDU_RX_DONE
condition|)
block|{
name|struct
name|iwn_rx_mpdu
modifier|*
name|mpdu
init|=
operator|(
expr|struct
name|iwn_rx_mpdu
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
decl_stmt|;
name|head
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|mpdu
operator|+
literal|1
argument_list|)
expr_stmt|;
name|len
operator|=
name|le16toh
argument_list|(
name|mpdu
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|head
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|stat
operator|+
literal|1
argument_list|)
operator|+
name|stat
operator|->
name|cfg_phy_len
expr_stmt|;
name|len
operator|=
name|le16toh
argument_list|(
name|stat
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
name|flags
operator|=
name|le32toh
argument_list|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|head
operator|+
name|len
operator|)
argument_list|)
expr_stmt|;
comment|/* Discard frames with a bad FCS early. */
if|if
condition|(
operator|(
name|flags
operator|&
name|IWN_RX_NOERROR
operator|)
operator|!=
name|IWN_RX_NOERROR
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RECV
argument_list|,
literal|"%s: rx flags error %x\n"
argument_list|,
name|__func__
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
comment|/* Discard frames that are too short. */
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|wh
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RECV
argument_list|,
literal|"%s: frame too short: %d\n"
argument_list|,
name|__func__
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
comment|/* XXX don't need mbuf, just dma buffer */
name|m1
operator|=
name|m_getjcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|MJUMPAGESIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|m1
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_ANY
argument_list|,
literal|"%s: no mbuf to restock ring\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|mtod
argument_list|(
name|m1
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|MJUMPAGESIZE
argument_list|,
name|iwn_dma_map_addr
argument_list|,
operator|&
name|paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|EFBIG
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: bus_dmamap_load failed, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m1
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|m
operator|=
name|data
operator|->
name|m
expr_stmt|;
name|data
operator|->
name|m
operator|=
name|m1
expr_stmt|;
comment|/* Update RX descriptor. */
name|ring
operator|->
name|desc
index|[
name|ring
operator|->
name|cur
index|]
operator|=
name|htole32
argument_list|(
name|paddr
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|desc_dma
operator|.
name|tag
argument_list|,
name|ring
operator|->
name|desc_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Finalize mbuf. */
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_data
operator|=
name|head
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|rssi
operator|=
name|hal
operator|->
name|get_rssi
argument_list|(
name|sc
argument_list|,
name|stat
argument_list|)
expr_stmt|;
comment|/* Grab a reference to the source node. */
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|ni
operator|=
name|ieee80211_find_rxnode
argument_list|(
name|ic
argument_list|,
operator|(
expr|struct
name|ieee80211_frame_min
operator|*
operator|)
name|wh
argument_list|)
expr_stmt|;
name|nf
operator|=
operator|(
name|ni
operator|!=
name|NULL
operator|&&
name|ni
operator|->
name|ni_vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_RUN
operator|&&
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SCAN
operator|)
operator|==
literal|0
operator|)
condition|?
name|sc
operator|->
name|noise
else|:
operator|-
literal|95
expr_stmt|;
if|if
condition|(
name|ieee80211_radiotap_active
argument_list|(
name|ic
argument_list|)
condition|)
block|{
name|struct
name|iwn_rx_radiotap_header
modifier|*
name|tap
init|=
operator|&
name|sc
operator|->
name|sc_rxtap
decl_stmt|;
name|tap
operator|->
name|wr_tsft
operator|=
name|htole64
argument_list|(
name|stat
operator|->
name|tstamp
argument_list|)
expr_stmt|;
name|tap
operator|->
name|wr_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|stat
operator|->
name|flags
operator|&
name|htole16
argument_list|(
name|IWN_STAT_FLAG_SHPREAMBLE
argument_list|)
condition|)
name|tap
operator|->
name|wr_flags
operator||=
name|IEEE80211_RADIOTAP_F_SHORTPRE
expr_stmt|;
switch|switch
condition|(
name|stat
operator|->
name|rate
condition|)
block|{
comment|/* CCK rates. */
case|case
literal|10
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|20
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|55
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|11
expr_stmt|;
break|break;
case|case
literal|110
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|22
expr_stmt|;
break|break;
comment|/* OFDM rates. */
case|case
literal|0xd
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|12
expr_stmt|;
break|break;
case|case
literal|0xf
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|18
expr_stmt|;
break|break;
case|case
literal|0x5
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|24
expr_stmt|;
break|break;
case|case
literal|0x7
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|36
expr_stmt|;
break|break;
case|case
literal|0x9
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|48
expr_stmt|;
break|break;
case|case
literal|0xb
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|72
expr_stmt|;
break|break;
case|case
literal|0x1
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|96
expr_stmt|;
break|break;
case|case
literal|0x3
case|:
name|tap
operator|->
name|wr_rate
operator|=
literal|108
expr_stmt|;
break|break;
comment|/* Unknown rate: should not happen. */
default|default:
name|tap
operator|->
name|wr_rate
operator|=
literal|0
expr_stmt|;
block|}
name|tap
operator|->
name|wr_dbm_antsignal
operator|=
name|rssi
expr_stmt|;
name|tap
operator|->
name|wr_dbm_antnoise
operator|=
name|nf
expr_stmt|;
block|}
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Send the frame to the 802.11 layer. */
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|ieee80211_input
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
name|rssi
operator|-
name|nf
argument_list|,
name|nf
argument_list|)
expr_stmt|;
comment|/* Node is no longer needed. */
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|ieee80211_input_all
argument_list|(
name|ic
argument_list|,
name|m
argument_list|,
name|rssi
operator|-
name|nf
argument_list|,
name|nf
argument_list|)
expr_stmt|;
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* HT */
end_comment

begin_comment
comment|/* Process an incoming Compressed BlockAck. */
end_comment

begin_comment
unit|void iwn_rx_compressed_ba(struct iwn_softc *sc, struct iwn_rx_desc *desc,     struct iwn_rx_data *data) { 	struct iwn_compressed_ba *ba = (struct iwn_compressed_ba *)(desc + 1); 	struct iwn_tx_ring *txq;  	txq =&sc->txq[letoh16(ba->qid)];
comment|/* XXX TBD */
end_comment

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Process a CALIBRATION_RESULT notification sent by the initialization  * firmware on response to a CMD_CALIB_CONFIG command (5000 only.)  */
end_comment

begin_function
name|void
name|iwn5000_rx_calib_results
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
name|desc
parameter_list|,
name|struct
name|iwn_rx_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|iwn_phy_calib
modifier|*
name|calib
init|=
operator|(
expr|struct
name|iwn_phy_calib
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
decl_stmt|;
name|int
name|len
decl_stmt|,
name|idx
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Runtime firmware should not send such a notification. */
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWN_FLAG_CALIB_DONE
condition|)
return|return;
name|len
operator|=
operator|(
name|le32toh
argument_list|(
name|desc
operator|->
name|len
argument_list|)
operator|&
literal|0x3fff
operator|)
operator|-
literal|4
expr_stmt|;
switch|switch
condition|(
name|calib
operator|->
name|code
condition|)
block|{
case|case
name|IWN5000_PHY_CALIB_DC
case|:
if|if
condition|(
name|sc
operator|->
name|hw_type
operator|==
name|IWN_HW_REV_TYPE_5150
condition|)
name|idx
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|IWN5000_PHY_CALIB_LO
case|:
name|idx
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IWN5000_PHY_CALIB_TX_IQ
case|:
name|idx
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|IWN5000_PHY_CALIB_TX_IQ_PERIODIC
case|:
if|if
condition|(
name|sc
operator|->
name|hw_type
operator|<
name|IWN_HW_REV_TYPE_6000
operator|&&
name|sc
operator|->
name|hw_type
operator|!=
name|IWN_HW_REV_TYPE_5150
condition|)
name|idx
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|IWN5000_PHY_CALIB_BASE_BAND
case|:
name|idx
operator|=
literal|4
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
condition|)
comment|/* Ignore other results. */
return|return;
comment|/* Save calibration result. */
if|if
condition|(
name|sc
operator|->
name|calibcmd
index|[
name|idx
index|]
operator|.
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sc
operator|->
name|calibcmd
index|[
name|idx
index|]
operator|.
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|calibcmd
index|[
name|idx
index|]
operator|.
name|buf
operator|=
name|malloc
argument_list|(
name|len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|calibcmd
index|[
name|idx
index|]
operator|.
name|buf
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"not enough memory for calibration result %d\n"
argument_list|,
name|calib
operator|->
name|code
argument_list|)
expr_stmt|;
return|return;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"saving calibration result code=%d len=%d\n"
argument_list|,
name|calib
operator|->
name|code
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sc
operator|->
name|calibcmd
index|[
name|idx
index|]
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|sc
operator|->
name|calibcmd
index|[
name|idx
index|]
operator|.
name|buf
argument_list|,
name|calib
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process an RX_STATISTICS or BEACON_STATISTICS firmware notification.  * The latter is sent by the firmware after each received beacon.  */
end_comment

begin_function
name|void
name|iwn_rx_statistics
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
name|desc
parameter_list|,
name|struct
name|iwn_rx_data
modifier|*
name|data
parameter_list|)
block|{
specifier|const
name|struct
name|iwn_hal
modifier|*
name|hal
init|=
name|sc
operator|->
name|sc_hal
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
name|struct
name|iwn_calib_state
modifier|*
name|calib
init|=
operator|&
name|sc
operator|->
name|calib
decl_stmt|;
name|struct
name|iwn_stats
modifier|*
name|stats
init|=
operator|(
expr|struct
name|iwn_stats
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
decl_stmt|;
name|int
name|temp
decl_stmt|;
comment|/* Beacon stats are meaningful only when associated and not scanning. */
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|!=
name|IEEE80211_S_RUN
operator|||
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SCAN
operator|)
condition|)
return|return;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s: cmd %d\n"
argument_list|,
name|__func__
argument_list|,
name|desc
operator|->
name|type
argument_list|)
expr_stmt|;
name|iwn_calib_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Reset TX power calibration timeout. */
comment|/* Test if temperature has changed. */
if|if
condition|(
name|stats
operator|->
name|general
operator|.
name|temp
operator|!=
name|sc
operator|->
name|rawtemp
condition|)
block|{
comment|/* Convert "raw" temperature to degC. */
name|sc
operator|->
name|rawtemp
operator|=
name|stats
operator|->
name|general
operator|.
name|temp
expr_stmt|;
name|temp
operator|=
name|hal
operator|->
name|get_temperature
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s: temperature %d\n"
argument_list|,
name|__func__
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* Update TX power if need be (4965AGN only.) */
if|if
condition|(
name|sc
operator|->
name|hw_type
operator|==
name|IWN_HW_REV_TYPE_4965
condition|)
name|iwn4965_power_calibration
argument_list|(
name|sc
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|desc
operator|->
name|type
operator|!=
name|IWN_BEACON_STATISTICS
condition|)
return|return;
comment|/* Reply to a statistics request. */
name|sc
operator|->
name|noise
operator|=
name|iwn_get_noise
argument_list|(
operator|&
name|stats
operator|->
name|rx
operator|.
name|general
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s: noise %d\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|noise
argument_list|)
expr_stmt|;
comment|/* Test that RSSI and noise are present in stats report. */
if|if
condition|(
name|le32toh
argument_list|(
name|stats
operator|->
name|rx
operator|.
name|general
operator|.
name|flags
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_ANY
argument_list|,
literal|"%s\n"
argument_list|,
literal|"received statistics without RSSI"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|calib
operator|->
name|state
operator|==
name|IWN_CALIB_STATE_ASSOC
condition|)
name|iwn_collect_noise
argument_list|(
name|sc
argument_list|,
operator|&
name|stats
operator|->
name|rx
operator|.
name|general
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|calib
operator|->
name|state
operator|==
name|IWN_CALIB_STATE_RUN
condition|)
name|iwn_tune_sensitivity
argument_list|(
name|sc
argument_list|,
operator|&
name|stats
operator|->
name|rx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a TX_DONE firmware notification.  Unfortunately, the 4965AGN  * and 5000 adapters have different incompatible TX status formats.  */
end_comment

begin_function
name|void
name|iwn4965_tx_done
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
name|desc
parameter_list|,
name|struct
name|iwn_rx_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|iwn4965_tx_stat
modifier|*
name|stat
init|=
operator|(
expr|struct
name|iwn4965_tx_stat
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_XMIT
argument_list|,
literal|"%s: "
literal|"qid %d idx %d retries %d nkill %d rate %x duration %d status %x\n"
argument_list|,
name|__func__
argument_list|,
name|desc
operator|->
name|qid
argument_list|,
name|desc
operator|->
name|idx
argument_list|,
name|stat
operator|->
name|ackfailcnt
argument_list|,
name|stat
operator|->
name|btkillcnt
argument_list|,
name|stat
operator|->
name|rate
argument_list|,
name|le16toh
argument_list|(
name|stat
operator|->
name|duration
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|stat
operator|->
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|iwn_tx_done
argument_list|(
name|sc
argument_list|,
name|desc
argument_list|,
name|stat
operator|->
name|ackfailcnt
argument_list|,
name|le32toh
argument_list|(
name|stat
operator|->
name|status
argument_list|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|iwn5000_tx_done
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
name|desc
parameter_list|,
name|struct
name|iwn_rx_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|iwn5000_tx_stat
modifier|*
name|stat
init|=
operator|(
expr|struct
name|iwn5000_tx_stat
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_XMIT
argument_list|,
literal|"%s: "
literal|"qid %d idx %d retries %d nkill %d rate %x duration %d status %x\n"
argument_list|,
name|__func__
argument_list|,
name|desc
operator|->
name|qid
argument_list|,
name|desc
operator|->
name|idx
argument_list|,
name|stat
operator|->
name|ackfailcnt
argument_list|,
name|stat
operator|->
name|btkillcnt
argument_list|,
name|stat
operator|->
name|rate
argument_list|,
name|le16toh
argument_list|(
name|stat
operator|->
name|duration
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|stat
operator|->
name|status
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* Reset TX scheduler slot. */
name|iwn5000_reset_sched
argument_list|(
name|sc
argument_list|,
name|desc
operator|->
name|qid
operator|&
literal|0xf
argument_list|,
name|desc
operator|->
name|idx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|iwn_tx_done
argument_list|(
name|sc
argument_list|,
name|desc
argument_list|,
name|stat
operator|->
name|ackfailcnt
argument_list|,
name|le16toh
argument_list|(
name|stat
operator|->
name|status
argument_list|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Adapter-independent backend for TX_DONE firmware notifications.  */
end_comment

begin_function
name|void
name|iwn_tx_done
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
name|desc
parameter_list|,
name|int
name|ackfailcnt
parameter_list|,
name|uint8_t
name|status
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|iwn_tx_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|txq
index|[
name|desc
operator|->
name|qid
operator|&
literal|0xf
index|]
decl_stmt|;
name|struct
name|iwn_tx_data
modifier|*
name|data
init|=
operator|&
name|ring
operator|->
name|data
index|[
name|desc
operator|->
name|idx
index|]
decl_stmt|;
name|struct
name|iwn_node
modifier|*
name|wn
init|=
operator|(
name|void
operator|*
operator|)
name|data
operator|->
name|ni
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|KASSERT
argument_list|(
name|data
operator|->
name|ni
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no node"
operator|)
argument_list|)
expr_stmt|;
comment|/* Unmap and free mbuf. */
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
name|m
operator|=
name|data
operator|->
name|m
operator|,
name|data
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|ni
operator|=
name|data
operator|->
name|ni
operator|,
name|data
operator|->
name|ni
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_TXCB
condition|)
block|{
comment|/* 		 * Channels marked for "radar" require traffic to be received 		 * to unlock before we can transmit.  Until traffic is seen 		 * any attempt to transmit is returned immediately with status 		 * set to IWN_TX_FAIL_TX_LOCKED.  Unfortunately this can easily 		 * happen on first authenticate after scanning.  To workaround 		 * this we ignore a failure of this sort in AUTH state so the 		 * 802.11 layer will fall back to using a timeout to wait for 		 * the AUTH reply.  This allows the firmware time to see 		 * traffic so a subsequent retry of AUTH succeeds.  It's 		 * unclear why the firmware does not maintain state for 		 * channels recently visited as this would allow immediate 		 * use of the channel after a scan (where we see traffic). 		 */
if|if
condition|(
name|status
operator|==
name|IWN_TX_FAIL_TX_LOCKED
operator|&&
name|ni
operator|->
name|ni_vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_AUTH
condition|)
name|ieee80211_process_callback
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|ieee80211_process_callback
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
operator|(
name|status
operator|&
name|IWN_TX_FAIL
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Update rate control statistics for the node. 	 */
if|if
condition|(
name|status
operator|&
literal|0x80
condition|)
block|{
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|ieee80211_amrr_tx_complete
argument_list|(
operator|&
name|wn
operator|->
name|amn
argument_list|,
name|IEEE80211_AMRR_FAILURE
argument_list|,
name|ackfailcnt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ieee80211_amrr_tx_complete
argument_list|(
operator|&
name|wn
operator|->
name|amn
argument_list|,
name|IEEE80211_AMRR_SUCCESS
argument_list|,
name|ackfailcnt
argument_list|)
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|--
name|ring
operator|->
name|queued
operator|<
name|IWN_TX_RING_LOMARK
condition|)
block|{
name|sc
operator|->
name|qfullmsk
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|ring
operator|->
name|qid
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|qfullmsk
operator|==
literal|0
operator|&&
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_OACTIVE
operator|)
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|iwn_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Process a "command done" firmware notification.  This is where we wakeup  * processes waiting for a synchronous command completion.  */
end_comment

begin_function
name|void
name|iwn_cmd_done
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
name|desc
parameter_list|)
block|{
name|struct
name|iwn_tx_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|txq
index|[
literal|4
index|]
decl_stmt|;
name|struct
name|iwn_tx_data
modifier|*
name|data
decl_stmt|;
if|if
condition|(
operator|(
name|desc
operator|->
name|qid
operator|&
literal|0xf
operator|)
operator|!=
literal|4
condition|)
return|return;
comment|/* Not a command ack. */
name|data
operator|=
operator|&
name|ring
operator|->
name|data
index|[
name|desc
operator|->
name|idx
index|]
expr_stmt|;
comment|/* If the command was mapped in an mbuf, free it. */
if|if
condition|(
name|data
operator|->
name|m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|data
operator|->
name|m
argument_list|)
expr_stmt|;
name|data
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
name|wakeup
argument_list|(
operator|&
name|ring
operator|->
name|desc
index|[
name|desc
operator|->
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process an INT_FH_RX or INT_SW_RX interrupt.  */
end_comment

begin_function
name|void
name|iwn_notif_intr
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
name|uint16_t
name|hw
decl_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rxq
operator|.
name|stat_dma
operator|.
name|tag
argument_list|,
name|sc
operator|->
name|rxq
operator|.
name|stat_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|hw
operator|=
name|le16toh
argument_list|(
name|sc
operator|->
name|rxq
operator|.
name|stat
operator|->
name|closed_count
argument_list|)
operator|&
literal|0xfff
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|rxq
operator|.
name|cur
operator|!=
name|hw
condition|)
block|{
name|struct
name|iwn_rx_data
modifier|*
name|data
init|=
operator|&
name|sc
operator|->
name|rxq
operator|.
name|data
index|[
name|sc
operator|->
name|rxq
operator|.
name|cur
index|]
decl_stmt|;
name|struct
name|iwn_rx_desc
modifier|*
name|desc
decl_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rxq
operator|.
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|desc
operator|=
name|mtod
argument_list|(
name|data
operator|->
name|m
argument_list|,
expr|struct
name|iwn_rx_desc
operator|*
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RECV
argument_list|,
literal|"%s: qid %x idx %d flags %x type %d(%s) len %d\n"
argument_list|,
name|__func__
argument_list|,
name|desc
operator|->
name|qid
operator|&
literal|0xf
argument_list|,
name|desc
operator|->
name|idx
argument_list|,
name|desc
operator|->
name|flags
argument_list|,
name|desc
operator|->
name|type
argument_list|,
name|iwn_intr_str
argument_list|(
name|desc
operator|->
name|type
argument_list|)
argument_list|,
name|le16toh
argument_list|(
name|desc
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|desc
operator|->
name|qid
operator|&
literal|0x80
operator|)
condition|)
comment|/* Reply to a command. */
name|iwn_cmd_done
argument_list|(
name|sc
argument_list|,
name|desc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|desc
operator|->
name|type
condition|)
block|{
case|case
name|IWN_RX_PHY
case|:
name|iwn_rx_phy
argument_list|(
name|sc
argument_list|,
name|desc
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|IWN_RX_DONE
case|:
comment|/* 4965AGN only. */
case|case
name|IWN_MPDU_RX_DONE
case|:
comment|/* An 802.11 frame has been received. */
name|iwn_rx_done
argument_list|(
name|sc
argument_list|,
name|desc
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
literal|0
comment|/* HT */
block|case IWN_RX_COMPRESSED_BA:
comment|/* A Compressed BlockAck has been received. */
block|iwn_rx_compressed_ba(sc, desc, data); 			break;
endif|#
directive|endif
case|case
name|IWN_TX_DONE
case|:
comment|/* An 802.11 frame has been transmitted. */
name|sc
operator|->
name|sc_hal
operator|->
name|tx_done
argument_list|(
name|sc
argument_list|,
name|desc
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|IWN_RX_STATISTICS
case|:
case|case
name|IWN_BEACON_STATISTICS
case|:
name|iwn_rx_statistics
argument_list|(
name|sc
argument_list|,
name|desc
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|IWN_BEACON_MISSED
case|:
block|{
name|struct
name|iwn_beacon_missed
modifier|*
name|miss
init|=
operator|(
expr|struct
name|iwn_beacon_missed
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
decl_stmt|;
name|int
name|misses
init|=
name|le32toh
argument_list|(
name|miss
operator|->
name|consecutive
argument_list|)
decl_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rxq
operator|.
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
comment|/* XXX not sure why we're notified w/ zero */
if|if
condition|(
name|misses
operator|==
literal|0
condition|)
break|break;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_STATE
argument_list|,
literal|"%s: beacons missed %d/%d\n"
argument_list|,
name|__func__
argument_list|,
name|misses
argument_list|,
name|le32toh
argument_list|(
name|miss
operator|->
name|total
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * If more than 5 consecutive beacons are missed, 			 * reinitialize the sensitivity state machine. 			 */
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_RUN
operator|&&
name|misses
operator|>
literal|5
condition|)
operator|(
name|void
operator|)
name|iwn_init_sensitivity
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|misses
operator|>=
name|vap
operator|->
name|iv_bmissthreshold
condition|)
block|{
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ieee80211_beacon_miss
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|IWN_UC_READY
case|:
block|{
name|struct
name|iwn_ucode_info
modifier|*
name|uc
init|=
operator|(
expr|struct
name|iwn_ucode_info
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
decl_stmt|;
comment|/* The microcontroller is ready. */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rxq
operator|.
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"microcode alive notification version=%d.%d "
literal|"subtype=%x alive=%x\n"
argument_list|,
name|uc
operator|->
name|major
argument_list|,
name|uc
operator|->
name|minor
argument_list|,
name|uc
operator|->
name|subtype
argument_list|,
name|le32toh
argument_list|(
name|uc
operator|->
name|valid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|le32toh
argument_list|(
name|uc
operator|->
name|valid
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"microcontroller initialization failed"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|uc
operator|->
name|subtype
operator|==
name|IWN_UCODE_INIT
condition|)
block|{
comment|/* Save microcontroller report. */
name|memcpy
argument_list|(
operator|&
name|sc
operator|->
name|ucode_info
argument_list|,
name|uc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|uc
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Save the address of the error log in SRAM. */
name|sc
operator|->
name|errptr
operator|=
name|le32toh
argument_list|(
name|uc
operator|->
name|errptr
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IWN_STATE_CHANGED
case|:
block|{
name|uint32_t
modifier|*
name|status
init|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
decl_stmt|;
comment|/* 			 * State change allows hardware switch change to be 			 * noted. However, we handle this in iwn_intr as we 			 * get both the enable/disble intr. 			 */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rxq
operator|.
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_INTR
argument_list|,
literal|"state changed to %x\n"
argument_list|,
name|le32toh
argument_list|(
operator|*
name|status
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IWN_START_SCAN
case|:
block|{
name|struct
name|iwn_start_scan
modifier|*
name|scan
init|=
operator|(
expr|struct
name|iwn_start_scan
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
decl_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rxq
operator|.
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_ANY
argument_list|,
literal|"%s: scanning channel %d status %x\n"
argument_list|,
name|__func__
argument_list|,
name|scan
operator|->
name|chan
argument_list|,
name|le32toh
argument_list|(
name|scan
operator|->
name|status
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IWN_STOP_SCAN
case|:
block|{
name|struct
name|iwn_stop_scan
modifier|*
name|scan
init|=
operator|(
expr|struct
name|iwn_stop_scan
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
decl_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rxq
operator|.
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_STATE
argument_list|,
literal|"scan finished nchan=%d status=%d chan=%d\n"
argument_list|,
name|scan
operator|->
name|nchan
argument_list|,
name|scan
operator|->
name|status
argument_list|,
name|scan
operator|->
name|chan
argument_list|)
expr_stmt|;
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ieee80211_scan_next
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IWN5000_CALIBRATION_RESULT
case|:
name|iwn5000_rx_calib_results
argument_list|(
name|sc
argument_list|,
name|desc
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|IWN5000_CALIBRATION_DONE
case|:
name|sc
operator|->
name|sc_flags
operator||=
name|IWN_FLAG_CALIB_DONE
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|rxq
operator|.
name|cur
operator|=
operator|(
name|sc
operator|->
name|rxq
operator|.
name|cur
operator|+
literal|1
operator|)
operator|%
name|IWN_RX_RING_COUNT
expr_stmt|;
block|}
comment|/* Tell the firmware what we have processed. */
name|hw
operator|=
operator|(
name|hw
operator|==
literal|0
operator|)
condition|?
name|IWN_RX_RING_COUNT
operator|-
literal|1
else|:
name|hw
operator|-
literal|1
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_RX_WPTR
argument_list|,
name|hw
operator|&
operator|~
literal|7
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process an INT_WAKEUP interrupt raised when the microcontroller wakes up  * from power-down sleep mode.  */
end_comment

begin_function
name|void
name|iwn_wakeup_intr
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|qid
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"%s: ucode wakeup from power-down sleep\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Wakeup RX and TX rings. */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_RX_WPTR
argument_list|,
name|sc
operator|->
name|rxq
operator|.
name|cur
operator|&
operator|~
literal|7
argument_list|)
expr_stmt|;
for|for
control|(
name|qid
operator|=
literal|0
init|;
name|qid
operator|<
name|sc
operator|->
name|sc_hal
operator|->
name|ntxqs
condition|;
name|qid
operator|++
control|)
block|{
name|struct
name|iwn_tx_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|txq
index|[
name|qid
index|]
decl_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_HBUS_TARG_WRPTR
argument_list|,
name|qid
operator|<<
literal|8
operator||
name|ring
operator|->
name|cur
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|iwn_rftoggle_intr
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|uint32_t
name|tmp
init|=
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_GP_CNTRL
argument_list|)
decl_stmt|;
name|IWN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"RF switch: radio %s\n"
argument_list|,
operator|(
name|tmp
operator|&
name|IWN_GP_CNTRL_RFKILL
operator|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&
name|IWN_GP_CNTRL_RFKILL
condition|)
name|ieee80211_runtask
argument_list|(
name|ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_radioon_task
argument_list|)
expr_stmt|;
else|else
name|ieee80211_runtask
argument_list|(
name|ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_radiooff_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dump the error log of the firmware when a firmware panic occurs.  Although  * we can't debug the firmware because it is neither open source nor free, it  * can help us to identify certain classes of problems.  */
end_comment

begin_function
name|void
name|iwn_fatal_intr
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|struct
name|iwn_hal
modifier|*
name|hal
init|=
name|sc
operator|->
name|sc_hal
decl_stmt|;
name|struct
name|iwn_fw_dump
name|dump
decl_stmt|;
name|int
name|i
decl_stmt|;
name|IWN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Force a complete recalibration on next init. */
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|IWN_FLAG_CALIB_DONE
expr_stmt|;
comment|/* Check that the error log address is valid. */
if|if
condition|(
name|sc
operator|->
name|errptr
operator|<
name|IWN_FW_DATA_BASE
operator|||
name|sc
operator|->
name|errptr
operator|+
sizeof|sizeof
argument_list|(
name|dump
argument_list|)
operator|>
name|IWN_FW_DATA_BASE
operator|+
name|hal
operator|->
name|fw_data_maxsz
condition|)
block|{
name|printf
argument_list|(
literal|"%s: bad firmware error log address 0x%08x\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|errptr
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|iwn_nic_lock
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: could not read firmware error log\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Read firmware error log from SRAM. */
name|iwn_mem_read_region_4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|errptr
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|dump
argument_list|,
sizeof|sizeof
argument_list|(
name|dump
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|iwn_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump
operator|.
name|valid
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: firmware error log is empty\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"firmware error log:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  error type      = \"%s\" (0x%08X)\n"
argument_list|,
operator|(
name|dump
operator|.
name|id
operator|<
name|nitems
argument_list|(
name|iwn_fw_errmsg
argument_list|)
operator|)
condition|?
name|iwn_fw_errmsg
index|[
name|dump
operator|.
name|id
index|]
else|:
literal|"UNKNOWN"
argument_list|,
name|dump
operator|.
name|id
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  program counter = 0x%08X\n"
argument_list|,
name|dump
operator|.
name|pc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  source line     = 0x%08X\n"
argument_list|,
name|dump
operator|.
name|src_line
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  error data      = 0x%08X%08X\n"
argument_list|,
name|dump
operator|.
name|error_data
index|[
literal|0
index|]
argument_list|,
name|dump
operator|.
name|error_data
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  branch link     = 0x%08X%08X\n"
argument_list|,
name|dump
operator|.
name|branch_link
index|[
literal|0
index|]
argument_list|,
name|dump
operator|.
name|branch_link
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  interrupt link  = 0x%08X%08X\n"
argument_list|,
name|dump
operator|.
name|interrupt_link
index|[
literal|0
index|]
argument_list|,
name|dump
operator|.
name|interrupt_link
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  time            = %u\n"
argument_list|,
name|dump
operator|.
name|time
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Dump driver status (TX and RX rings) while we're here. */
name|printf
argument_list|(
literal|"driver status:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hal
operator|->
name|ntxqs
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|iwn_tx_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|txq
index|[
name|i
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"  tx ring %2d: qid=%-2d cur=%-3d queued=%-3d\n"
argument_list|,
name|i
argument_list|,
name|ring
operator|->
name|qid
argument_list|,
name|ring
operator|->
name|cur
argument_list|,
name|ring
operator|->
name|queued
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  rx ring: cur=%d\n"
argument_list|,
name|sc
operator|->
name|rxq
operator|.
name|cur
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|iwn_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|uint32_t
name|r1
decl_stmt|,
name|r2
decl_stmt|,
name|tmp
decl_stmt|;
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Disable interrupts. */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_INT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Read interrupts from ICT (fast) or from registers (slow). */
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWN_FLAG_USE_ICT
condition|)
block|{
name|tmp
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|ict
index|[
name|sc
operator|->
name|ict_cur
index|]
operator|!=
literal|0
condition|)
block|{
name|tmp
operator||=
name|sc
operator|->
name|ict
index|[
name|sc
operator|->
name|ict_cur
index|]
expr_stmt|;
name|sc
operator|->
name|ict
index|[
name|sc
operator|->
name|ict_cur
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Acknowledge. */
name|sc
operator|->
name|ict_cur
operator|=
operator|(
name|sc
operator|->
name|ict_cur
operator|+
literal|1
operator|)
operator|%
name|IWN_ICT_COUNT
expr_stmt|;
block|}
name|tmp
operator|=
name|le32toh
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|0xffffffff
condition|)
name|tmp
operator|=
literal|0
expr_stmt|;
comment|/* Shouldn't happen. */
name|r1
operator|=
operator|(
name|tmp
operator|&
literal|0xff00
operator|)
operator|<<
literal|16
operator||
operator|(
name|tmp
operator|&
literal|0xff
operator|)
expr_stmt|;
name|r2
operator|=
literal|0
expr_stmt|;
comment|/* Unused. */
block|}
else|else
block|{
name|r1
operator|=
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_INT
argument_list|)
expr_stmt|;
if|if
condition|(
name|r1
operator|==
literal|0xffffffff
operator|||
operator|(
name|r1
operator|&
literal|0xfffffff0
operator|)
operator|==
literal|0xa5a5a5a0
condition|)
return|return;
comment|/* Hardware gone! */
name|r2
operator|=
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_FH_INT
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_INTR
argument_list|,
literal|"interrupt reg1=%x reg2=%x\n"
argument_list|,
name|r1
argument_list|,
name|r2
argument_list|)
expr_stmt|;
if|if
condition|(
name|r1
operator|==
literal|0
operator|&&
name|r2
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* Interrupt not for us. */
comment|/* Acknowledge interrupts. */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_INT
argument_list|,
name|r1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWN_FLAG_USE_ICT
operator|)
condition|)
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_INT
argument_list|,
name|r2
argument_list|)
expr_stmt|;
if|if
condition|(
name|r1
operator|&
name|IWN_INT_RF_TOGGLED
condition|)
block|{
name|iwn_rftoggle_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|r1
operator|&
name|IWN_INT_CT_REACHED
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: critical temperature reached!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r1
operator|&
operator|(
name|IWN_INT_SW_ERR
operator||
name|IWN_INT_HW_ERR
operator|)
condition|)
block|{
name|iwn_fatal_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
name|iwn_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|(
name|r1
operator|&
operator|(
name|IWN_INT_FH_RX
operator||
name|IWN_INT_SW_RX
operator||
name|IWN_INT_RX_PERIODIC
operator|)
operator|)
operator|||
operator|(
name|r2
operator|&
name|IWN_FH_INT_RX
operator|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWN_FLAG_USE_ICT
condition|)
block|{
if|if
condition|(
name|r1
operator|&
operator|(
name|IWN_INT_FH_RX
operator||
name|IWN_INT_SW_RX
operator|)
condition|)
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_INT
argument_list|,
name|IWN_FH_INT_RX
argument_list|)
expr_stmt|;
name|IWN_WRITE_1
argument_list|(
name|sc
argument_list|,
name|IWN_INT_PERIODIC
argument_list|,
name|IWN_INT_PERIODIC_DIS
argument_list|)
expr_stmt|;
name|iwn_notif_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|r1
operator|&
operator|(
name|IWN_INT_FH_RX
operator||
name|IWN_INT_SW_RX
operator|)
condition|)
block|{
name|IWN_WRITE_1
argument_list|(
name|sc
argument_list|,
name|IWN_INT_PERIODIC
argument_list|,
name|IWN_INT_PERIODIC_ENA
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|iwn_notif_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|r1
operator|&
name|IWN_INT_FH_TX
operator|)
operator|||
operator|(
name|r2
operator|&
name|IWN_FH_INT_TX
operator|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWN_FLAG_USE_ICT
condition|)
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_INT
argument_list|,
name|IWN_FH_INT_TX
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* FH DMA transfer completed. */
block|}
if|if
condition|(
name|r1
operator|&
name|IWN_INT_ALIVE
condition|)
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Firmware is alive. */
if|if
condition|(
name|r1
operator|&
name|IWN_INT_WAKEUP
condition|)
name|iwn_wakeup_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|done
label|:
comment|/* Re-enable interrupts. */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_INT_MASK
argument_list|,
name|sc
operator|->
name|int_mask
argument_list|)
expr_stmt|;
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update TX scheduler ring when transmitting an 802.11 frame (4965AGN and  * 5000 adapters use a slightly different format.)  */
end_comment

begin_function
name|void
name|iwn4965_update_sched
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qid
parameter_list|,
name|int
name|idx
parameter_list|,
name|uint8_t
name|id
parameter_list|,
name|uint16_t
name|len
parameter_list|)
block|{
name|uint16_t
modifier|*
name|w
init|=
operator|&
name|sc
operator|->
name|sched
index|[
name|qid
operator|*
name|IWN4965_SCHED_COUNT
operator|+
name|idx
index|]
decl_stmt|;
operator|*
name|w
operator|=
name|htole16
argument_list|(
name|len
operator|+
literal|8
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sched_dma
operator|.
name|tag
argument_list|,
name|sc
operator|->
name|sched_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|<
name|IWN_SCHED_WINSZ
condition|)
block|{
operator|*
operator|(
name|w
operator|+
name|IWN_TX_RING_COUNT
operator|)
operator|=
operator|*
name|w
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sched_dma
operator|.
name|tag
argument_list|,
name|sc
operator|->
name|sched_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|iwn5000_update_sched
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qid
parameter_list|,
name|int
name|idx
parameter_list|,
name|uint8_t
name|id
parameter_list|,
name|uint16_t
name|len
parameter_list|)
block|{
name|uint16_t
modifier|*
name|w
init|=
operator|&
name|sc
operator|->
name|sched
index|[
name|qid
operator|*
name|IWN5000_SCHED_COUNT
operator|+
name|idx
index|]
decl_stmt|;
operator|*
name|w
operator|=
name|htole16
argument_list|(
name|id
operator|<<
literal|12
operator||
operator|(
name|len
operator|+
literal|8
operator|)
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sched_dma
operator|.
name|tag
argument_list|,
name|sc
operator|->
name|sched_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|<
name|IWN_SCHED_WINSZ
condition|)
block|{
operator|*
operator|(
name|w
operator|+
name|IWN_TX_RING_COUNT
operator|)
operator|=
operator|*
name|w
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sched_dma
operator|.
name|tag
argument_list|,
name|sc
operator|->
name|sched_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|iwn5000_reset_sched
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qid
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|uint16_t
modifier|*
name|w
init|=
operator|&
name|sc
operator|->
name|sched
index|[
name|qid
operator|*
name|IWN5000_SCHED_COUNT
operator|+
name|idx
index|]
decl_stmt|;
operator|*
name|w
operator|=
operator|(
operator|*
name|w
operator|&
name|htole16
argument_list|(
literal|0xf000
argument_list|)
operator|)
operator||
name|htole16
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sched_dma
operator|.
name|tag
argument_list|,
name|sc
operator|->
name|sched_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|<
name|IWN_SCHED_WINSZ
condition|)
block|{
operator|*
operator|(
name|w
operator|+
name|IWN_TX_RING_COUNT
operator|)
operator|=
operator|*
name|w
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sched_dma
operator|.
name|tag
argument_list|,
name|sc
operator|->
name|sched_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|iwn_plcp_signal
parameter_list|(
name|int
name|rate
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWN_RIDX_MAX
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rate
operator|==
name|iwn_rates
index|[
name|i
index|]
operator|.
name|rate
condition|)
return|return
name|i
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|iwn_tx_data
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|iwn_tx_ring
modifier|*
name|ring
parameter_list|)
block|{
specifier|const
name|struct
name|iwn_hal
modifier|*
name|hal
init|=
name|sc
operator|->
name|sc_hal
decl_stmt|;
specifier|const
name|struct
name|ieee80211_txparam
modifier|*
name|tp
decl_stmt|;
specifier|const
name|struct
name|iwn_rate
modifier|*
name|rinfo
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|iwn_node
modifier|*
name|wn
init|=
operator|(
name|void
operator|*
operator|)
name|ni
decl_stmt|;
name|struct
name|iwn_tx_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|iwn_tx_data
modifier|*
name|data
decl_stmt|;
name|struct
name|iwn_tx_cmd
modifier|*
name|cmd
decl_stmt|;
name|struct
name|iwn_cmd_data
modifier|*
name|tx
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|struct
name|ieee80211_key
modifier|*
name|k
init|=
name|NULL
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mnew
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
name|IWN_MAX_SCATTER
index|]
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|u_int
name|hdrlen
decl_stmt|;
name|int
name|totlen
decl_stmt|,
name|error
decl_stmt|,
name|pad
decl_stmt|,
name|nsegs
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|rate
decl_stmt|;
name|uint8_t
name|ridx
decl_stmt|,
name|type
decl_stmt|,
name|txant
decl_stmt|;
name|IWN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|hdrlen
operator|=
name|ieee80211_anyhdrsize
argument_list|(
name|wh
argument_list|)
expr_stmt|;
name|type
operator|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
expr_stmt|;
name|desc
operator|=
operator|&
name|ring
operator|->
name|desc
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|data
operator|=
operator|&
name|ring
operator|->
name|data
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
comment|/* Choose a TX rate index. */
name|tp
operator|=
operator|&
name|vap
operator|->
name|iv_txparms
index|[
name|ieee80211_chan2mode
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|IEEE80211_FC0_TYPE_MGT
condition|)
name|rate
operator|=
name|tp
operator|->
name|mgmtrate
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
condition|)
name|rate
operator|=
name|tp
operator|->
name|mcastrate
expr_stmt|;
elseif|else
if|if
condition|(
name|tp
operator|->
name|ucastrate
operator|!=
name|IEEE80211_FIXED_RATE_NONE
condition|)
name|rate
operator|=
name|tp
operator|->
name|ucastrate
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|ieee80211_amrr_choose
argument_list|(
name|ni
argument_list|,
operator|&
name|wn
operator|->
name|amn
argument_list|)
expr_stmt|;
name|rate
operator|=
name|ni
operator|->
name|ni_txrate
expr_stmt|;
block|}
name|ridx
operator|=
name|iwn_plcp_signal
argument_list|(
name|rate
argument_list|)
expr_stmt|;
name|rinfo
operator|=
operator|&
name|iwn_rates
index|[
name|ridx
index|]
expr_stmt|;
comment|/* Encrypt the frame if need be. */
if|if
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_WEP
condition|)
block|{
name|k
operator|=
name|ieee80211_crypto_encap
argument_list|(
name|ni
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
comment|/* Packet header may have moved, reset our local pointer. */
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
block|}
name|totlen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|ieee80211_radiotap_active_vap
argument_list|(
name|vap
argument_list|)
condition|)
block|{
name|struct
name|iwn_tx_radiotap_header
modifier|*
name|tap
init|=
operator|&
name|sc
operator|->
name|sc_txtap
decl_stmt|;
name|tap
operator|->
name|wt_flags
operator|=
literal|0
expr_stmt|;
name|tap
operator|->
name|wt_rate
operator|=
name|rinfo
operator|->
name|rate
expr_stmt|;
if|if
condition|(
name|k
operator|!=
name|NULL
condition|)
name|tap
operator|->
name|wt_flags
operator||=
name|IEEE80211_RADIOTAP_F_WEP
expr_stmt|;
name|ieee80211_radiotap_tx
argument_list|(
name|vap
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* Prepare TX firmware command. */
name|cmd
operator|=
operator|&
name|ring
operator|->
name|cmd
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|cmd
operator|->
name|code
operator|=
name|IWN_CMD_TX_DATA
expr_stmt|;
name|cmd
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|qid
operator|=
name|ring
operator|->
name|qid
expr_stmt|;
name|cmd
operator|->
name|idx
operator|=
name|ring
operator|->
name|cur
expr_stmt|;
name|tx
operator|=
operator|(
expr|struct
name|iwn_cmd_data
operator|*
operator|)
name|cmd
operator|->
name|data
expr_stmt|;
comment|/* NB: No need to clear tx, all fields are reinitialized here. */
name|tx
operator|->
name|scratch
operator|=
literal|0
expr_stmt|;
comment|/* clear "scratch" area */
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
condition|)
name|flags
operator||=
name|IWN_TX_NEED_ACK
expr_stmt|;
if|if
condition|(
operator|(
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
operator|(
name|IEEE80211_FC0_TYPE_MASK
operator||
name|IEEE80211_FC0_SUBTYPE_MASK
operator|)
operator|)
operator|==
operator|(
name|IEEE80211_FC0_TYPE_CTL
operator||
name|IEEE80211_FC0_SUBTYPE_BAR
operator|)
condition|)
name|flags
operator||=
name|IWN_TX_IMM_BA
expr_stmt|;
comment|/* Cannot happen yet. */
if|if
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_MORE_FRAG
condition|)
name|flags
operator||=
name|IWN_TX_MORE_FRAG
expr_stmt|;
comment|/* Cannot happen yet. */
comment|/* Check if frame must be protected using RTS/CTS or CTS-to-self. */
if|if
condition|(
operator|!
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
condition|)
block|{
comment|/* NB: Group frames are sent using CCK in 802.11b/g. */
if|if
condition|(
name|totlen
operator|+
name|IEEE80211_CRC_LEN
operator|>
name|vap
operator|->
name|iv_rtsthreshold
condition|)
block|{
name|flags
operator||=
name|IWN_TX_NEED_RTS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_USEPROT
operator|)
operator|&&
name|ridx
operator|>=
name|IWN_RIDX_OFDM6
condition|)
block|{
if|if
condition|(
name|ic
operator|->
name|ic_protmode
operator|==
name|IEEE80211_PROT_CTSONLY
condition|)
name|flags
operator||=
name|IWN_TX_NEED_CTS
expr_stmt|;
elseif|else
if|if
condition|(
name|ic
operator|->
name|ic_protmode
operator|==
name|IEEE80211_PROT_RTSCTS
condition|)
name|flags
operator||=
name|IWN_TX_NEED_RTS
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
operator|(
name|IWN_TX_NEED_RTS
operator||
name|IWN_TX_NEED_CTS
operator|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|hw_type
operator|!=
name|IWN_HW_REV_TYPE_4965
condition|)
block|{
comment|/* 5000 autoselects RTS/CTS or CTS-to-self. */
name|flags
operator|&=
operator|~
operator|(
name|IWN_TX_NEED_RTS
operator||
name|IWN_TX_NEED_CTS
operator|)
expr_stmt|;
name|flags
operator||=
name|IWN_TX_NEED_PROTECTION
expr_stmt|;
block|}
else|else
name|flags
operator||=
name|IWN_TX_FULL_TXOP
expr_stmt|;
block|}
block|}
if|if
condition|(
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
operator|||
name|type
operator|!=
name|IEEE80211_FC0_TYPE_DATA
condition|)
name|tx
operator|->
name|id
operator|=
name|hal
operator|->
name|broadcast_id
expr_stmt|;
else|else
name|tx
operator|->
name|id
operator|=
name|wn
operator|->
name|id
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|IEEE80211_FC0_TYPE_MGT
condition|)
block|{
name|uint8_t
name|subtype
init|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
decl_stmt|;
comment|/* Tell HW to set timestamp in probe responses. */
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_PROBE_RESP
condition|)
name|flags
operator||=
name|IWN_TX_INSERT_TSTAMP
expr_stmt|;
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_ASSOC_REQ
operator|||
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_REASSOC_REQ
condition|)
name|tx
operator|->
name|timeout
operator|=
name|htole16
argument_list|(
literal|3
argument_list|)
expr_stmt|;
else|else
name|tx
operator|->
name|timeout
operator|=
name|htole16
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
name|tx
operator|->
name|timeout
operator|=
name|htole16
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdrlen
operator|&
literal|3
condition|)
block|{
comment|/* First segment length must be a multiple of 4. */
name|flags
operator||=
name|IWN_TX_NEED_PADDING
expr_stmt|;
name|pad
operator|=
literal|4
operator|-
operator|(
name|hdrlen
operator|&
literal|3
operator|)
expr_stmt|;
block|}
else|else
name|pad
operator|=
literal|0
expr_stmt|;
name|tx
operator|->
name|len
operator|=
name|htole16
argument_list|(
name|totlen
argument_list|)
expr_stmt|;
name|tx
operator|->
name|tid
operator|=
literal|0
expr_stmt|;
name|tx
operator|->
name|rts_ntries
operator|=
literal|60
expr_stmt|;
name|tx
operator|->
name|data_ntries
operator|=
literal|15
expr_stmt|;
name|tx
operator|->
name|lifetime
operator|=
name|htole32
argument_list|(
name|IWN_LIFETIME_INFINITE
argument_list|)
expr_stmt|;
name|tx
operator|->
name|plcp
operator|=
name|rinfo
operator|->
name|plcp
expr_stmt|;
name|tx
operator|->
name|rflags
operator|=
name|rinfo
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|tx
operator|->
name|id
operator|==
name|hal
operator|->
name|broadcast_id
condition|)
block|{
comment|/* Group or management frame. */
name|tx
operator|->
name|linkq
operator|=
literal|0
expr_stmt|;
comment|/* XXX Alternate between antenna A and B? */
name|txant
operator|=
name|IWN_LSB
argument_list|(
name|sc
operator|->
name|txchainmask
argument_list|)
expr_stmt|;
name|tx
operator|->
name|rflags
operator||=
name|IWN_RFLAG_ANT
argument_list|(
name|txant
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tx
operator|->
name|linkq
operator|=
literal|0
expr_stmt|;
name|flags
operator||=
name|IWN_TX_LINKQ
expr_stmt|;
comment|/* enable MRR */
block|}
comment|/* Set physical address of "scratch area". */
name|tx
operator|->
name|loaddr
operator|=
name|htole32
argument_list|(
name|IWN_LOADDR
argument_list|(
name|data
operator|->
name|scratch_paddr
argument_list|)
argument_list|)
expr_stmt|;
name|tx
operator|->
name|hiaddr
operator|=
name|IWN_HIADDR
argument_list|(
name|data
operator|->
name|scratch_paddr
argument_list|)
expr_stmt|;
comment|/* Copy 802.11 header in TX command. */
name|memcpy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|tx
operator|+
literal|1
operator|)
argument_list|,
name|wh
argument_list|,
name|hdrlen
argument_list|)
expr_stmt|;
comment|/* Trim 802.11 header. */
name|m_adj
argument_list|(
name|m
argument_list|,
name|hdrlen
argument_list|)
expr_stmt|;
name|tx
operator|->
name|security
operator|=
literal|0
expr_stmt|;
name|tx
operator|->
name|flags
operator|=
name|htole32
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|m
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EFBIG
condition|)
block|{
comment|/* too many fragments, linearize */
name|mnew
operator|=
name|m_collapse
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|IWN_MAX_SCATTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|mnew
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not defrag mbuf\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|m
operator|=
name|mnew
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|m
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: bus_dmamap_load_mbuf_sg failed, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
name|data
operator|->
name|m
operator|=
name|m
expr_stmt|;
name|data
operator|->
name|ni
operator|=
name|ni
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_XMIT
argument_list|,
literal|"%s: qid %d idx %d len %d nsegs %d\n"
argument_list|,
name|__func__
argument_list|,
name|ring
operator|->
name|qid
argument_list|,
name|ring
operator|->
name|cur
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
comment|/* Fill TX descriptor. */
name|desc
operator|->
name|nsegs
operator|=
literal|1
operator|+
name|nsegs
expr_stmt|;
comment|/* First DMA segment is used by the TX command. */
name|desc
operator|->
name|segs
index|[
literal|0
index|]
operator|.
name|addr
operator|=
name|htole32
argument_list|(
name|IWN_LOADDR
argument_list|(
name|data
operator|->
name|cmd_paddr
argument_list|)
argument_list|)
expr_stmt|;
name|desc
operator|->
name|segs
index|[
literal|0
index|]
operator|.
name|len
operator|=
name|htole16
argument_list|(
name|IWN_HIADDR
argument_list|(
name|data
operator|->
name|cmd_paddr
argument_list|)
operator||
operator|(
literal|4
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|tx
argument_list|)
operator|+
name|hdrlen
operator|+
name|pad
operator|)
operator|<<
literal|4
argument_list|)
expr_stmt|;
comment|/* Other DMA segments are for data payload. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
name|desc
operator|->
name|segs
index|[
name|i
index|]
operator|.
name|addr
operator|=
name|htole32
argument_list|(
name|IWN_LOADDR
argument_list|(
name|segs
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|desc
operator|->
name|segs
index|[
name|i
index|]
operator|.
name|len
operator|=
name|htole16
argument_list|(
name|IWN_HIADDR
argument_list|(
name|segs
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|ds_addr
argument_list|)
operator||
name|segs
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|ds_len
operator|<<
literal|4
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|ring
operator|->
name|cmd_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|desc_dma
operator|.
name|tag
argument_list|,
name|ring
operator|->
name|desc_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* Update TX scheduler. */
name|hal
operator|->
name|update_sched
argument_list|(
name|sc
argument_list|,
name|ring
operator|->
name|qid
argument_list|,
name|ring
operator|->
name|cur
argument_list|,
name|tx
operator|->
name|id
argument_list|,
name|totlen
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Kick TX ring. */
name|ring
operator|->
name|cur
operator|=
operator|(
name|ring
operator|->
name|cur
operator|+
literal|1
operator|)
operator|%
name|IWN_TX_RING_COUNT
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_HBUS_TARG_WRPTR
argument_list|,
name|ring
operator|->
name|qid
operator|<<
literal|8
operator||
name|ring
operator|->
name|cur
argument_list|)
expr_stmt|;
comment|/* Mark TX ring as full if we reach a certain threshold. */
if|if
condition|(
operator|++
name|ring
operator|->
name|queued
operator|>
name|IWN_TX_RING_HIMARK
condition|)
name|sc
operator|->
name|qfullmsk
operator||=
literal|1
operator|<<
name|ring
operator|->
name|qid
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_tx_data_raw
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|iwn_tx_ring
modifier|*
name|ring
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
name|params
parameter_list|)
block|{
specifier|const
name|struct
name|iwn_hal
modifier|*
name|hal
init|=
name|sc
operator|->
name|sc_hal
decl_stmt|;
specifier|const
name|struct
name|iwn_rate
modifier|*
name|rinfo
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|iwn_tx_cmd
modifier|*
name|cmd
decl_stmt|;
name|struct
name|iwn_cmd_data
modifier|*
name|tx
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|struct
name|iwn_tx_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|iwn_tx_data
modifier|*
name|data
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mnew
decl_stmt|;
name|bus_addr_t
name|paddr
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
name|IWN_MAX_SCATTER
index|]
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|u_int
name|hdrlen
decl_stmt|;
name|int
name|totlen
decl_stmt|,
name|error
decl_stmt|,
name|pad
decl_stmt|,
name|nsegs
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|rate
decl_stmt|;
name|uint8_t
name|ridx
decl_stmt|,
name|type
decl_stmt|,
name|txant
decl_stmt|;
name|IWN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|hdrlen
operator|=
name|ieee80211_anyhdrsize
argument_list|(
name|wh
argument_list|)
expr_stmt|;
name|type
operator|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
expr_stmt|;
name|desc
operator|=
operator|&
name|ring
operator|->
name|desc
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|data
operator|=
operator|&
name|ring
operator|->
name|data
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
comment|/* Choose a TX rate index. */
name|rate
operator|=
name|params
operator|->
name|ibp_rate0
expr_stmt|;
if|if
condition|(
operator|!
name|ieee80211_isratevalid
argument_list|(
name|ic
operator|->
name|ic_rt
argument_list|,
name|rate
argument_list|)
condition|)
block|{
comment|/* XXX fall back to mcast/mgmt rate? */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|ridx
operator|=
name|iwn_plcp_signal
argument_list|(
name|rate
argument_list|)
expr_stmt|;
name|rinfo
operator|=
operator|&
name|iwn_rates
index|[
name|ridx
index|]
expr_stmt|;
name|totlen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* Prepare TX firmware command. */
name|cmd
operator|=
operator|&
name|ring
operator|->
name|cmd
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|cmd
operator|->
name|code
operator|=
name|IWN_CMD_TX_DATA
expr_stmt|;
name|cmd
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|qid
operator|=
name|ring
operator|->
name|qid
expr_stmt|;
name|cmd
operator|->
name|idx
operator|=
name|ring
operator|->
name|cur
expr_stmt|;
name|tx
operator|=
operator|(
expr|struct
name|iwn_cmd_data
operator|*
operator|)
name|cmd
operator|->
name|data
expr_stmt|;
comment|/* NB: No need to clear tx, all fields are reinitialized here. */
name|tx
operator|->
name|scratch
operator|=
literal|0
expr_stmt|;
comment|/* clear "scratch" area */
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_NOACK
operator|)
operator|==
literal|0
condition|)
name|flags
operator||=
name|IWN_TX_NEED_ACK
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_RTS
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|hw_type
operator|!=
name|IWN_HW_REV_TYPE_4965
condition|)
block|{
comment|/* 5000 autoselects RTS/CTS or CTS-to-self. */
name|flags
operator|&=
operator|~
name|IWN_TX_NEED_RTS
expr_stmt|;
name|flags
operator||=
name|IWN_TX_NEED_PROTECTION
expr_stmt|;
block|}
else|else
name|flags
operator||=
name|IWN_TX_NEED_RTS
operator||
name|IWN_TX_FULL_TXOP
expr_stmt|;
block|}
if|if
condition|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_CTS
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|hw_type
operator|!=
name|IWN_HW_REV_TYPE_4965
condition|)
block|{
comment|/* 5000 autoselects RTS/CTS or CTS-to-self. */
name|flags
operator|&=
operator|~
name|IWN_TX_NEED_CTS
expr_stmt|;
name|flags
operator||=
name|IWN_TX_NEED_PROTECTION
expr_stmt|;
block|}
else|else
name|flags
operator||=
name|IWN_TX_NEED_CTS
operator||
name|IWN_TX_FULL_TXOP
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|IEEE80211_FC0_TYPE_MGT
condition|)
block|{
name|uint8_t
name|subtype
init|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
decl_stmt|;
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_PROBE_RESP
condition|)
name|flags
operator||=
name|IWN_TX_INSERT_TSTAMP
expr_stmt|;
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_ASSOC_REQ
operator|||
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_REASSOC_REQ
condition|)
name|tx
operator|->
name|timeout
operator|=
name|htole16
argument_list|(
literal|3
argument_list|)
expr_stmt|;
else|else
name|tx
operator|->
name|timeout
operator|=
name|htole16
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
name|tx
operator|->
name|timeout
operator|=
name|htole16
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdrlen
operator|&
literal|3
condition|)
block|{
comment|/* First segment length must be a multiple of 4. */
name|flags
operator||=
name|IWN_TX_NEED_PADDING
expr_stmt|;
name|pad
operator|=
literal|4
operator|-
operator|(
name|hdrlen
operator|&
literal|3
operator|)
expr_stmt|;
block|}
else|else
name|pad
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ieee80211_radiotap_active_vap
argument_list|(
name|vap
argument_list|)
condition|)
block|{
name|struct
name|iwn_tx_radiotap_header
modifier|*
name|tap
init|=
operator|&
name|sc
operator|->
name|sc_txtap
decl_stmt|;
name|tap
operator|->
name|wt_flags
operator|=
literal|0
expr_stmt|;
name|tap
operator|->
name|wt_rate
operator|=
name|rate
expr_stmt|;
name|ieee80211_radiotap_tx
argument_list|(
name|vap
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|tx
operator|->
name|len
operator|=
name|htole16
argument_list|(
name|totlen
argument_list|)
expr_stmt|;
name|tx
operator|->
name|tid
operator|=
literal|0
expr_stmt|;
name|tx
operator|->
name|id
operator|=
name|hal
operator|->
name|broadcast_id
expr_stmt|;
name|tx
operator|->
name|rts_ntries
operator|=
name|params
operator|->
name|ibp_try1
expr_stmt|;
name|tx
operator|->
name|data_ntries
operator|=
name|params
operator|->
name|ibp_try0
expr_stmt|;
name|tx
operator|->
name|lifetime
operator|=
name|htole32
argument_list|(
name|IWN_LIFETIME_INFINITE
argument_list|)
expr_stmt|;
name|tx
operator|->
name|plcp
operator|=
name|rinfo
operator|->
name|plcp
expr_stmt|;
name|tx
operator|->
name|rflags
operator|=
name|rinfo
operator|->
name|flags
expr_stmt|;
comment|/* Group or management frame. */
name|tx
operator|->
name|linkq
operator|=
literal|0
expr_stmt|;
name|txant
operator|=
name|IWN_LSB
argument_list|(
name|sc
operator|->
name|txchainmask
argument_list|)
expr_stmt|;
name|tx
operator|->
name|rflags
operator||=
name|IWN_RFLAG_ANT
argument_list|(
name|txant
argument_list|)
expr_stmt|;
comment|/* Set physical address of "scratch area". */
name|paddr
operator|=
name|ring
operator|->
name|cmd_dma
operator|.
name|paddr
operator|+
name|ring
operator|->
name|cur
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_tx_cmd
argument_list|)
expr_stmt|;
name|tx
operator|->
name|loaddr
operator|=
name|htole32
argument_list|(
name|IWN_LOADDR
argument_list|(
name|paddr
argument_list|)
argument_list|)
expr_stmt|;
name|tx
operator|->
name|hiaddr
operator|=
name|IWN_HIADDR
argument_list|(
name|paddr
argument_list|)
expr_stmt|;
comment|/* Copy 802.11 header in TX command. */
name|memcpy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|tx
operator|+
literal|1
operator|)
argument_list|,
name|wh
argument_list|,
name|hdrlen
argument_list|)
expr_stmt|;
comment|/* Trim 802.11 header. */
name|m_adj
argument_list|(
name|m
argument_list|,
name|hdrlen
argument_list|)
expr_stmt|;
name|tx
operator|->
name|security
operator|=
literal|0
expr_stmt|;
name|tx
operator|->
name|flags
operator|=
name|htole32
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|m
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EFBIG
condition|)
block|{
comment|/* Too many fragments, linearize. */
name|mnew
operator|=
name|m_collapse
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|IWN_MAX_SCATTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|mnew
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not defrag mbuf\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|m
operator|=
name|mnew
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|m
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: bus_dmamap_load_mbuf_sg failed, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
name|data
operator|->
name|m
operator|=
name|m
expr_stmt|;
name|data
operator|->
name|ni
operator|=
name|ni
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_XMIT
argument_list|,
literal|"%s: qid %d idx %d len %d nsegs %d\n"
argument_list|,
name|__func__
argument_list|,
name|ring
operator|->
name|qid
argument_list|,
name|ring
operator|->
name|cur
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
comment|/* Fill TX descriptor. */
name|desc
operator|->
name|nsegs
operator|=
literal|1
operator|+
name|nsegs
expr_stmt|;
comment|/* First DMA segment is used by the TX command. */
name|desc
operator|->
name|segs
index|[
literal|0
index|]
operator|.
name|addr
operator|=
name|htole32
argument_list|(
name|IWN_LOADDR
argument_list|(
name|data
operator|->
name|cmd_paddr
argument_list|)
argument_list|)
expr_stmt|;
name|desc
operator|->
name|segs
index|[
literal|0
index|]
operator|.
name|len
operator|=
name|htole16
argument_list|(
name|IWN_HIADDR
argument_list|(
name|data
operator|->
name|cmd_paddr
argument_list|)
operator||
operator|(
literal|4
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|tx
argument_list|)
operator|+
name|hdrlen
operator|+
name|pad
operator|)
operator|<<
literal|4
argument_list|)
expr_stmt|;
comment|/* Other DMA segments are for data payload. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
name|desc
operator|->
name|segs
index|[
name|i
index|]
operator|.
name|addr
operator|=
name|htole32
argument_list|(
name|IWN_LOADDR
argument_list|(
name|segs
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|desc
operator|->
name|segs
index|[
name|i
index|]
operator|.
name|len
operator|=
name|htole16
argument_list|(
name|IWN_HIADDR
argument_list|(
name|segs
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|ds_addr
argument_list|)
operator||
name|segs
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|ds_len
operator|<<
literal|4
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|ring
operator|->
name|cmd_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|desc_dma
operator|.
name|tag
argument_list|,
name|ring
operator|->
name|desc_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* Update TX scheduler. */
name|hal
operator|->
name|update_sched
argument_list|(
name|sc
argument_list|,
name|ring
operator|->
name|qid
argument_list|,
name|ring
operator|->
name|cur
argument_list|,
name|tx
operator|->
name|id
argument_list|,
name|totlen
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Kick TX ring. */
name|ring
operator|->
name|cur
operator|=
operator|(
name|ring
operator|->
name|cur
operator|+
literal|1
operator|)
operator|%
name|IWN_TX_RING_COUNT
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_HBUS_TARG_WRPTR
argument_list|,
name|ring
operator|->
name|qid
operator|<<
literal|8
operator||
name|ring
operator|->
name|cur
argument_list|)
expr_stmt|;
comment|/* Mark TX ring as full if we reach a certain threshold. */
if|if
condition|(
operator|++
name|ring
operator|->
name|queued
operator|>
name|IWN_TX_RING_HIMARK
condition|)
name|sc
operator|->
name|qfullmsk
operator||=
literal|1
operator|<<
name|ring
operator|->
name|qid
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_raw_xmit
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|iwn_tx_ring
modifier|*
name|txq
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|ENETDOWN
return|;
block|}
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|==
name|NULL
condition|)
name|txq
operator|=
operator|&
name|sc
operator|->
name|txq
index|[
name|M_WME_GETAC
argument_list|(
name|m
argument_list|)
index|]
expr_stmt|;
else|else
name|txq
operator|=
operator|&
name|sc
operator|->
name|txq
index|[
name|params
operator|->
name|ibp_pri
operator|&
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|params
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Legacy path; interpret frame contents to decide 		 * precisely how to send the frame. 		 */
name|error
operator|=
name|iwn_tx_data
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|ni
argument_list|,
name|txq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Caller supplied explicit parameters to use in 		 * sending the frame. 		 */
name|error
operator|=
name|iwn_tx_data_raw
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|ni
argument_list|,
name|txq
argument_list|,
name|params
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* NB: m is reclaimed on tx failure */
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
block|}
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|void
name|iwn_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwn_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|iwn_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|iwn_tx_ring
modifier|*
name|txq
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|pri
decl_stmt|;
name|IWN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|qfullmsk
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
break|break;
block|}
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|ni
operator|=
operator|(
expr|struct
name|ieee80211_node
operator|*
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
name|pri
operator|=
name|M_WME_GETAC
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|txq
operator|=
operator|&
name|sc
operator|->
name|txq
index|[
name|pri
index|]
expr_stmt|;
if|if
condition|(
name|iwn_tx_data
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|ni
argument_list|,
name|txq
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|5
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_watchdog
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_tx_timer
operator|>
literal|0
operator|&&
operator|--
name|sc
operator|->
name|sc_tx_timer
operator|==
literal|0
condition|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"device timeout\n"
argument_list|)
expr_stmt|;
name|ieee80211_runtask
argument_list|(
name|ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_reinit_task
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|iwn_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|startall
init|=
literal|0
decl_stmt|,
name|stop
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|iwn_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_GP_CNTRL
argument_list|)
operator|&
name|IWN_GP_CNTRL_RFKILL
condition|)
name|startall
operator|=
literal|1
expr_stmt|;
else|else
name|stop
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|iwn_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|startall
condition|)
name|ieee80211_start_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vap
operator|!=
name|NULL
operator|&&
name|stop
condition|)
name|ieee80211_stop
argument_list|(
name|vap
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGIFMEDIA
case|:
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|ic
operator|->
name|ic_media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGIFADDR
case|:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Send a command to the firmware.  */
end_comment

begin_function
name|int
name|iwn_cmd
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|code
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|async
parameter_list|)
block|{
name|struct
name|iwn_tx_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|txq
index|[
literal|4
index|]
decl_stmt|;
name|struct
name|iwn_tx_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|iwn_tx_data
modifier|*
name|data
decl_stmt|;
name|struct
name|iwn_tx_cmd
modifier|*
name|cmd
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|bus_addr_t
name|paddr
decl_stmt|;
name|int
name|totlen
decl_stmt|,
name|error
decl_stmt|;
name|IWN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|desc
operator|=
operator|&
name|ring
operator|->
name|desc
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|data
operator|=
operator|&
name|ring
operator|->
name|data
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|totlen
operator|=
literal|4
operator|+
name|size
expr_stmt|;
if|if
condition|(
name|size
operator|>
sizeof|sizeof
name|cmd
operator|->
name|data
condition|)
block|{
comment|/* Command is too large to fit in a descriptor. */
if|if
condition|(
name|totlen
operator|>
name|MCLBYTES
condition|)
return|return
name|EINVAL
return|;
name|m
operator|=
name|m_getjcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|MJUMPAGESIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|cmd
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|iwn_tx_cmd
operator|*
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|cmd
argument_list|,
name|totlen
argument_list|,
name|iwn_dma_map_addr
argument_list|,
operator|&
name|paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|data
operator|->
name|m
operator|=
name|m
expr_stmt|;
block|}
else|else
block|{
name|cmd
operator|=
operator|&
name|ring
operator|->
name|cmd
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|paddr
operator|=
name|data
operator|->
name|cmd_paddr
expr_stmt|;
block|}
name|cmd
operator|->
name|code
operator|=
name|code
expr_stmt|;
name|cmd
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|qid
operator|=
name|ring
operator|->
name|qid
expr_stmt|;
name|cmd
operator|->
name|idx
operator|=
name|ring
operator|->
name|cur
expr_stmt|;
name|memcpy
argument_list|(
name|cmd
operator|->
name|data
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|desc
operator|->
name|nsegs
operator|=
literal|1
expr_stmt|;
name|desc
operator|->
name|segs
index|[
literal|0
index|]
operator|.
name|addr
operator|=
name|htole32
argument_list|(
name|IWN_LOADDR
argument_list|(
name|paddr
argument_list|)
argument_list|)
expr_stmt|;
name|desc
operator|->
name|segs
index|[
literal|0
index|]
operator|.
name|len
operator|=
name|htole16
argument_list|(
name|IWN_HIADDR
argument_list|(
name|paddr
argument_list|)
operator||
name|totlen
operator|<<
literal|4
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CMD
argument_list|,
literal|"%s: %s (0x%x) flags %d qid %d idx %d\n"
argument_list|,
name|__func__
argument_list|,
name|iwn_intr_str
argument_list|(
name|cmd
operator|->
name|code
argument_list|)
argument_list|,
name|cmd
operator|->
name|code
argument_list|,
name|cmd
operator|->
name|flags
argument_list|,
name|cmd
operator|->
name|qid
argument_list|,
name|cmd
operator|->
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
sizeof|sizeof
name|cmd
operator|->
name|data
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|ring
operator|->
name|cmd_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|desc_dma
operator|.
name|tag
argument_list|,
name|ring
operator|->
name|desc_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* Update TX scheduler. */
name|sc
operator|->
name|sc_hal
operator|->
name|update_sched
argument_list|(
name|sc
argument_list|,
name|ring
operator|->
name|qid
argument_list|,
name|ring
operator|->
name|cur
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Kick command ring. */
name|ring
operator|->
name|cur
operator|=
operator|(
name|ring
operator|->
name|cur
operator|+
literal|1
operator|)
operator|%
name|IWN_TX_RING_COUNT
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_HBUS_TARG_WRPTR
argument_list|,
name|ring
operator|->
name|qid
operator|<<
literal|8
operator||
name|ring
operator|->
name|cur
argument_list|)
expr_stmt|;
return|return
name|async
condition|?
literal|0
else|:
name|msleep
argument_list|(
name|desc
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|PCATCH
argument_list|,
literal|"iwncmd"
argument_list|,
name|hz
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|iwn4965_add_node
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_node_info
modifier|*
name|node
parameter_list|,
name|int
name|async
parameter_list|)
block|{
name|struct
name|iwn4965_node_info
name|hnode
decl_stmt|;
name|caddr_t
name|src
decl_stmt|,
name|dst
decl_stmt|;
comment|/* 	 * We use the node structure for 5000 Series internally (it is 	 * a superset of the one for 4965AGN). We thus copy the common 	 * fields before sending the command. 	 */
name|src
operator|=
operator|(
name|caddr_t
operator|)
name|node
expr_stmt|;
name|dst
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|hnode
expr_stmt|;
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
literal|48
argument_list|)
expr_stmt|;
comment|/* Skip TSC, RX MIC and TX MIC fields from ``src''. */
name|memcpy
argument_list|(
name|dst
operator|+
literal|48
argument_list|,
name|src
operator|+
literal|72
argument_list|,
literal|20
argument_list|)
expr_stmt|;
return|return
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_ADD_NODE
argument_list|,
operator|&
name|hnode
argument_list|,
sizeof|sizeof
name|hnode
argument_list|,
name|async
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|iwn5000_add_node
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_node_info
modifier|*
name|node
parameter_list|,
name|int
name|async
parameter_list|)
block|{
comment|/* Direct mapping. */
return|return
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_ADD_NODE
argument_list|,
name|node
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|node
argument_list|)
argument_list|,
name|async
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* HT */
end_comment

begin_comment
unit|static const uint8_t iwn_ridx_to_plcp[] = { 	10, 20, 55, 110,
comment|/* CCK */
end_comment

begin_comment
unit|0xd, 0xf, 0x5, 0x7, 0x9, 0xb, 0x1, 0x3, 0x3
comment|/* OFDM R1-R4 */
end_comment

begin_comment
unit|}; static const uint8_t iwn_siso_mcs_to_plcp[] = { 	0, 0, 0, 0,
comment|/* CCK */
end_comment

begin_comment
unit|0, 0, 1, 2, 3, 4, 5, 6, 7
comment|/* HT */
end_comment

begin_comment
unit|}; static const uint8_t iwn_mimo_mcs_to_plcp[] = { 	0, 0, 0, 0,
comment|/* CCK */
end_comment

begin_comment
unit|8, 8, 9, 10, 11, 12, 13, 14, 15
comment|/* HT */
end_comment

begin_endif
unit|};
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|uint8_t
name|iwn_prev_ridx
index|[]
init|=
block|{
comment|/* NB: allow fallback from CCK11 to OFDM9 and from OFDM6 to CCK5 */
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|5
block|,
comment|/* CCK */
literal|2
block|,
literal|4
block|,
literal|3
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|10
comment|/* OFDM */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Configure hardware link parameters for the specified  * node operating on the specified channel.  */
end_comment

begin_function
name|int
name|iwn_set_link_quality
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|id
parameter_list|,
name|int
name|async
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|iwn_cmd_link_quality
name|linkq
decl_stmt|;
specifier|const
name|struct
name|iwn_rate
modifier|*
name|rinfo
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint8_t
name|txant
decl_stmt|,
name|ridx
decl_stmt|;
comment|/* Use the first valid TX antenna. */
name|txant
operator|=
name|IWN_LSB
argument_list|(
name|sc
operator|->
name|txchainmask
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|linkq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|linkq
argument_list|)
expr_stmt|;
name|linkq
operator|.
name|id
operator|=
name|id
expr_stmt|;
name|linkq
operator|.
name|antmsk_1stream
operator|=
name|txant
expr_stmt|;
name|linkq
operator|.
name|antmsk_2stream
operator|=
name|IWN_ANT_AB
expr_stmt|;
name|linkq
operator|.
name|ampdu_max
operator|=
literal|31
expr_stmt|;
name|linkq
operator|.
name|ampdu_threshold
operator|=
literal|3
expr_stmt|;
name|linkq
operator|.
name|ampdu_limit
operator|=
name|htole16
argument_list|(
literal|4000
argument_list|)
expr_stmt|;
comment|/* 4ms */
if|#
directive|if
literal|0
comment|/* HT */
block|if (IEEE80211_IS_CHAN_HT(c)) 		linkq.mimo = 1;
endif|#
directive|endif
if|if
condition|(
name|id
operator|==
name|IWN_ID_BSS
condition|)
name|ridx
operator|=
name|IWN_RIDX_OFDM54
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_A
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
condition|)
name|ridx
operator|=
name|IWN_RIDX_OFDM6
expr_stmt|;
else|else
name|ridx
operator|=
name|IWN_RIDX_CCK1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWN_MAX_TX_RETRIES
condition|;
name|i
operator|++
control|)
block|{
name|rinfo
operator|=
operator|&
name|iwn_rates
index|[
name|ridx
index|]
expr_stmt|;
if|#
directive|if
literal|0
comment|/* HT */
block|if (IEEE80211_IS_CHAN_HT40(c)) { 			linkq.retry[i].plcp = iwn_mimo_mcs_to_plcp[ridx] 					 | IWN_RIDX_MCS; 			linkq.retry[i].rflags = IWN_RFLAG_HT 					 | IWN_RFLAG_HT40;
comment|/* XXX shortGI */
block|} else if (IEEE80211_IS_CHAN_HT(c)) { 			linkq.retry[i].plcp = iwn_siso_mcs_to_plcp[ridx] 					 | IWN_RIDX_MCS; 			linkq.retry[i].rflags = IWN_RFLAG_HT;
comment|/* XXX shortGI */
block|} else
endif|#
directive|endif
block|{
name|linkq
operator|.
name|retry
index|[
name|i
index|]
operator|.
name|plcp
operator|=
name|rinfo
operator|->
name|plcp
expr_stmt|;
name|linkq
operator|.
name|retry
index|[
name|i
index|]
operator|.
name|rflags
operator|=
name|rinfo
operator|->
name|flags
expr_stmt|;
block|}
name|linkq
operator|.
name|retry
index|[
name|i
index|]
operator|.
name|rflags
operator||=
name|IWN_RFLAG_ANT
argument_list|(
name|txant
argument_list|)
expr_stmt|;
name|ridx
operator|=
name|iwn_prev_ridx
index|[
name|ridx
index|]
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IWN_DEBUG
if|if
condition|(
name|sc
operator|->
name|sc_debug
operator|&
name|IWN_DEBUG_STATE
condition|)
block|{
name|printf
argument_list|(
literal|"%s: set link quality for node %d, mimo %d ssmask %d\n"
argument_list|,
name|__func__
argument_list|,
name|id
argument_list|,
name|linkq
operator|.
name|mimo
argument_list|,
name|linkq
operator|.
name|antmsk_1stream
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s:"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWN_MAX_TX_RETRIES
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %d:%x"
argument_list|,
name|linkq
operator|.
name|retry
index|[
name|i
index|]
operator|.
name|plcp
argument_list|,
name|linkq
operator|.
name|retry
index|[
name|i
index|]
operator|.
name|rflags
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_LINK_QUALITY
argument_list|,
operator|&
name|linkq
argument_list|,
sizeof|sizeof
name|linkq
argument_list|,
name|async
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Broadcast node is used to send group-addressed and management frames.  */
end_comment

begin_function
name|int
name|iwn_add_broadcast_node
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|async
parameter_list|)
block|{
specifier|const
name|struct
name|iwn_hal
modifier|*
name|hal
init|=
name|sc
operator|->
name|sc_hal
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|iwn_node_info
name|node
decl_stmt|;
name|int
name|error
decl_stmt|;
name|memset
argument_list|(
operator|&
name|node
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|node
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|node
operator|.
name|macaddr
argument_list|,
name|ifp
operator|->
name|if_broadcastaddr
argument_list|)
expr_stmt|;
name|node
operator|.
name|id
operator|=
name|hal
operator|->
name|broadcast_id
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"%s: adding broadcast node\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|hal
operator|->
name|add_node
argument_list|(
name|sc
argument_list|,
operator|&
name|node
argument_list|,
name|async
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|error
operator|=
name|iwn_set_link_quality
argument_list|(
name|sc
argument_list|,
name|hal
operator|->
name|broadcast_id
argument_list|,
name|async
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|iwn_wme_update
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
define|#
directive|define
name|IWN_EXP2
parameter_list|(
name|x
parameter_list|)
value|((1<< (x)) - 1)
comment|/* CWmin = 2^ECWmin - 1 */
define|#
directive|define
name|IWN_TXOP_TO_US
parameter_list|(
name|v
parameter_list|)
value|(v<<5)
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|iwn_edca_params
name|cmd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|flags
operator|=
name|htole32
argument_list|(
name|IWN_EDCA_UPDATE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WME_NUM_AC
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|wmeParams
modifier|*
name|wmep
init|=
operator|&
name|ic
operator|->
name|ic_wme
operator|.
name|wme_chanParams
operator|.
name|cap_wmeParams
index|[
name|i
index|]
decl_stmt|;
name|cmd
operator|.
name|ac
index|[
name|i
index|]
operator|.
name|aifsn
operator|=
name|wmep
operator|->
name|wmep_aifsn
expr_stmt|;
name|cmd
operator|.
name|ac
index|[
name|i
index|]
operator|.
name|cwmin
operator|=
name|htole16
argument_list|(
name|IWN_EXP2
argument_list|(
name|wmep
operator|->
name|wmep_logcwmin
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|ac
index|[
name|i
index|]
operator|.
name|cwmax
operator|=
name|htole16
argument_list|(
name|IWN_EXP2
argument_list|(
name|wmep
operator|->
name|wmep_logcwmax
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|ac
index|[
name|i
index|]
operator|.
name|txoplimit
operator|=
name|htole16
argument_list|(
name|IWN_TXOP_TO_US
argument_list|(
name|wmep
operator|->
name|wmep_txopLimit
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_EDCA_PARAMS
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
name|cmd
argument_list|,
literal|1
comment|/*async*/
argument_list|)
expr_stmt|;
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
undef|#
directive|undef
name|IWN_TXOP_TO_US
undef|#
directive|undef
name|IWN_EXP2
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_update_mcast
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
comment|/* Ignore */
block|}
end_function

begin_function
name|void
name|iwn_set_led
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|which
parameter_list|,
name|uint8_t
name|off
parameter_list|,
name|uint8_t
name|on
parameter_list|)
block|{
name|struct
name|iwn_cmd_led
name|led
decl_stmt|;
comment|/* Clear microcode LED ownership. */
name|IWN_CLRBITS
argument_list|(
name|sc
argument_list|,
name|IWN_LED
argument_list|,
name|IWN_LED_BSM_CTRL
argument_list|)
expr_stmt|;
name|led
operator|.
name|which
operator|=
name|which
expr_stmt|;
name|led
operator|.
name|unit
operator|=
name|htole32
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/* on/off in unit of 100ms */
name|led
operator|.
name|off
operator|=
name|off
expr_stmt|;
name|led
operator|.
name|on
operator|=
name|on
expr_stmt|;
operator|(
name|void
operator|)
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_SET_LED
argument_list|,
operator|&
name|led
argument_list|,
sizeof|sizeof
name|led
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the critical temperature at which the firmware will stop the radio  * and notify us.  */
end_comment

begin_function
name|int
name|iwn_set_critical_temp
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwn_critical_temp
name|crit
decl_stmt|;
name|int32_t
name|temp
decl_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_UCODE_GP1_CLR
argument_list|,
name|IWN_UCODE_GP1_CTEMP_STOP_RF
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hw_type
operator|==
name|IWN_HW_REV_TYPE_5150
condition|)
name|temp
operator|=
operator|(
name|IWN_CTOK
argument_list|(
literal|110
argument_list|)
operator|-
name|sc
operator|->
name|temp_off
operator|)
operator|*
operator|-
literal|5
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|hw_type
operator|==
name|IWN_HW_REV_TYPE_4965
condition|)
name|temp
operator|=
name|IWN_CTOK
argument_list|(
literal|110
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
literal|110
expr_stmt|;
name|memset
argument_list|(
operator|&
name|crit
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|crit
argument_list|)
expr_stmt|;
name|crit
operator|.
name|tempR
operator|=
name|htole32
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"setting critical temp to %d\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
return|return
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_SET_CRITICAL_TEMP
argument_list|,
operator|&
name|crit
argument_list|,
sizeof|sizeof
name|crit
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|iwn_set_timing
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|iwn_cmd_timing
name|cmd
decl_stmt|;
name|uint64_t
name|val
decl_stmt|,
name|mod
decl_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|cmd
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|cmd
operator|.
name|tstamp
argument_list|,
name|ni
operator|->
name|ni_tstamp
operator|.
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|bintval
operator|=
name|htole16
argument_list|(
name|ni
operator|->
name|ni_intval
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|lintval
operator|=
name|htole16
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* Compute remaining time until next beacon. */
name|val
operator|=
operator|(
name|uint64_t
operator|)
name|ni
operator|->
name|ni_intval
operator|*
literal|1024
expr_stmt|;
comment|/* msecs -> usecs */
name|mod
operator|=
name|le64toh
argument_list|(
name|cmd
operator|.
name|tstamp
argument_list|)
operator|%
name|val
expr_stmt|;
name|cmd
operator|.
name|binitval
operator|=
name|htole32
argument_list|(
call|(
name|uint32_t
call|)
argument_list|(
name|val
operator|-
name|mod
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"timing bintval=%u tstamp=%ju, init=%u\n"
argument_list|,
name|ni
operator|->
name|ni_intval
argument_list|,
name|le64toh
argument_list|(
name|cmd
operator|.
name|tstamp
argument_list|)
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|val
operator|-
name|mod
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_TIMING
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
name|cmd
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|iwn4965_power_calibration
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|temp
parameter_list|)
block|{
comment|/* Adjust TX power if need be (delta>= 3 degC.) */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s: temperature %d->%d\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|temp
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|temp
operator|-
name|sc
operator|->
name|temp
argument_list|)
operator|>=
literal|3
condition|)
block|{
comment|/* Record temperature of last calibration. */
name|sc
operator|->
name|temp
operator|=
name|temp
expr_stmt|;
operator|(
name|void
operator|)
name|iwn4965_set_txpower
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Set TX power for current channel (each rate has its own power settings).  * This function takes into account the regulatory information from EEPROM,  * the current temperature and the current voltage.  */
end_comment

begin_function
name|int
name|iwn4965_set_txpower
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|async
parameter_list|)
block|{
comment|/* Fixed-point arithmetic division using a n-bit fractional part. */
define|#
directive|define
name|fdivround
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|n
parameter_list|)
define|\
value|((((1<< n) * (a)) / (b) + (1<< n) / 2) / (1<< n))
comment|/* Linear interpolation. */
define|#
directive|define
name|interpolate
parameter_list|(
name|x
parameter_list|,
name|x1
parameter_list|,
name|y1
parameter_list|,
name|x2
parameter_list|,
name|y2
parameter_list|,
name|n
parameter_list|)
define|\
value|((y1) + fdivround(((int)(x) - (x1)) * ((y2) - (y1)), (x2) - (x1), n))
specifier|static
specifier|const
name|int
name|tdiv
index|[
name|IWN_NATTEN_GROUPS
index|]
init|=
block|{
literal|9
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|6
block|}
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|iwn_ucode_info
modifier|*
name|uc
init|=
operator|&
name|sc
operator|->
name|ucode_info
decl_stmt|;
name|struct
name|ieee80211_channel
modifier|*
name|ch
decl_stmt|;
name|struct
name|iwn4965_cmd_txpower
name|cmd
decl_stmt|;
name|struct
name|iwn4965_eeprom_chan_samples
modifier|*
name|chans
decl_stmt|;
name|int32_t
name|vdiff
decl_stmt|,
name|tdiff
decl_stmt|;
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|grp
decl_stmt|,
name|maxpwr
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|rf_gain
decl_stmt|,
modifier|*
name|dsp_gain
decl_stmt|;
name|uint8_t
name|chan
decl_stmt|;
comment|/* Retrieve current channel from last RXON. */
name|chan
operator|=
name|sc
operator|->
name|rxon
operator|.
name|chan
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"setting TX power for channel %d\n"
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|&
name|ic
operator|->
name|ic_channels
index|[
name|chan
index|]
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|band
operator|=
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|ch
argument_list|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|cmd
operator|.
name|chan
operator|=
name|chan
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|maxpwr
operator|=
name|sc
operator|->
name|maxpwr5GHz
expr_stmt|;
name|rf_gain
operator|=
name|iwn4965_rf_gain_5ghz
expr_stmt|;
name|dsp_gain
operator|=
name|iwn4965_dsp_gain_5ghz
expr_stmt|;
block|}
else|else
block|{
name|maxpwr
operator|=
name|sc
operator|->
name|maxpwr2GHz
expr_stmt|;
name|rf_gain
operator|=
name|iwn4965_rf_gain_2ghz
expr_stmt|;
name|dsp_gain
operator|=
name|iwn4965_dsp_gain_2ghz
expr_stmt|;
block|}
comment|/* Compute voltage compensation. */
name|vdiff
operator|=
operator|(
operator|(
name|int32_t
operator|)
name|le32toh
argument_list|(
name|uc
operator|->
name|volt
argument_list|)
operator|-
name|sc
operator|->
name|eeprom_voltage
operator|)
operator|/
literal|7
expr_stmt|;
if|if
condition|(
name|vdiff
operator|>
literal|0
condition|)
name|vdiff
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|vdiff
argument_list|)
operator|>
literal|2
condition|)
name|vdiff
operator|=
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
operator||
name|IWN_DEBUG_TXPOW
argument_list|,
literal|"%s: voltage compensation=%d (UCODE=%d, EEPROM=%d)\n"
argument_list|,
name|__func__
argument_list|,
name|vdiff
argument_list|,
name|le32toh
argument_list|(
name|uc
operator|->
name|volt
argument_list|)
argument_list|,
name|sc
operator|->
name|eeprom_voltage
argument_list|)
expr_stmt|;
comment|/* Get channel attenuation group. */
if|if
condition|(
name|chan
operator|<=
literal|20
condition|)
comment|/* 1-20 */
name|grp
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|chan
operator|<=
literal|43
condition|)
comment|/* 34-43 */
name|grp
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|chan
operator|<=
literal|70
condition|)
comment|/* 44-70 */
name|grp
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|chan
operator|<=
literal|124
condition|)
comment|/* 71-124 */
name|grp
operator|=
literal|2
expr_stmt|;
else|else
comment|/* 125-200 */
name|grp
operator|=
literal|3
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
operator||
name|IWN_DEBUG_TXPOW
argument_list|,
literal|"%s: chan %d, attenuation group=%d\n"
argument_list|,
name|__func__
argument_list|,
name|chan
argument_list|,
name|grp
argument_list|)
expr_stmt|;
comment|/* Get channel sub-band. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWN_NBANDS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|bands
index|[
name|i
index|]
operator|.
name|lo
operator|!=
literal|0
operator|&&
name|sc
operator|->
name|bands
index|[
name|i
index|]
operator|.
name|lo
operator|<=
name|chan
operator|&&
name|chan
operator|<=
name|sc
operator|->
name|bands
index|[
name|i
index|]
operator|.
name|hi
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|IWN_NBANDS
condition|)
comment|/* Can't happen in real-life. */
return|return
name|EINVAL
return|;
name|chans
operator|=
name|sc
operator|->
name|bands
index|[
name|i
index|]
operator|.
name|chans
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
operator||
name|IWN_DEBUG_TXPOW
argument_list|,
literal|"%s: chan %d sub-band=%d\n"
argument_list|,
name|__func__
argument_list|,
name|chan
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|2
condition|;
name|c
operator|++
control|)
block|{
name|uint8_t
name|power
decl_stmt|,
name|gain
decl_stmt|,
name|temp
decl_stmt|;
name|int
name|maxchpwr
decl_stmt|,
name|pwr
decl_stmt|,
name|ridx
decl_stmt|,
name|idx
decl_stmt|;
name|power
operator|=
name|interpolate
argument_list|(
name|chan
argument_list|,
name|chans
index|[
literal|0
index|]
operator|.
name|num
argument_list|,
name|chans
index|[
literal|0
index|]
operator|.
name|samples
index|[
name|c
index|]
index|[
literal|1
index|]
operator|.
name|power
argument_list|,
name|chans
index|[
literal|1
index|]
operator|.
name|num
argument_list|,
name|chans
index|[
literal|1
index|]
operator|.
name|samples
index|[
name|c
index|]
index|[
literal|1
index|]
operator|.
name|power
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gain
operator|=
name|interpolate
argument_list|(
name|chan
argument_list|,
name|chans
index|[
literal|0
index|]
operator|.
name|num
argument_list|,
name|chans
index|[
literal|0
index|]
operator|.
name|samples
index|[
name|c
index|]
index|[
literal|1
index|]
operator|.
name|gain
argument_list|,
name|chans
index|[
literal|1
index|]
operator|.
name|num
argument_list|,
name|chans
index|[
literal|1
index|]
operator|.
name|samples
index|[
name|c
index|]
index|[
literal|1
index|]
operator|.
name|gain
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|temp
operator|=
name|interpolate
argument_list|(
name|chan
argument_list|,
name|chans
index|[
literal|0
index|]
operator|.
name|num
argument_list|,
name|chans
index|[
literal|0
index|]
operator|.
name|samples
index|[
name|c
index|]
index|[
literal|1
index|]
operator|.
name|temp
argument_list|,
name|chans
index|[
literal|1
index|]
operator|.
name|num
argument_list|,
name|chans
index|[
literal|1
index|]
operator|.
name|samples
index|[
name|c
index|]
index|[
literal|1
index|]
operator|.
name|temp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
operator||
name|IWN_DEBUG_TXPOW
argument_list|,
literal|"%s: Tx chain %d: power=%d gain=%d temp=%d\n"
argument_list|,
name|__func__
argument_list|,
name|c
argument_list|,
name|power
argument_list|,
name|gain
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* Compute temperature compensation. */
name|tdiff
operator|=
operator|(
operator|(
name|sc
operator|->
name|temp
operator|-
name|temp
operator|)
operator|*
literal|2
operator|)
operator|/
name|tdiv
index|[
name|grp
index|]
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
operator||
name|IWN_DEBUG_TXPOW
argument_list|,
literal|"%s: temperature compensation=%d (current=%d, EEPROM=%d)\n"
argument_list|,
name|__func__
argument_list|,
name|tdiff
argument_list|,
name|sc
operator|->
name|temp
argument_list|,
name|temp
argument_list|)
expr_stmt|;
for|for
control|(
name|ridx
operator|=
literal|0
init|;
name|ridx
operator|<=
name|IWN_RIDX_MAX
condition|;
name|ridx
operator|++
control|)
block|{
comment|/* Convert dBm to half-dBm. */
name|maxchpwr
operator|=
name|sc
operator|->
name|maxpwr
index|[
name|chan
index|]
operator|*
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|ridx
operator|/
literal|8
operator|)
operator|&
literal|1
condition|)
name|maxchpwr
operator|-=
literal|6
expr_stmt|;
comment|/* MIMO 2T: -3dB */
name|pwr
operator|=
name|maxpwr
expr_stmt|;
comment|/* Adjust TX power based on rate. */
if|if
condition|(
operator|(
name|ridx
operator|%
literal|8
operator|)
operator|==
literal|5
condition|)
name|pwr
operator|-=
literal|15
expr_stmt|;
comment|/* OFDM48: -7.5dB */
elseif|else
if|if
condition|(
operator|(
name|ridx
operator|%
literal|8
operator|)
operator|==
literal|6
condition|)
name|pwr
operator|-=
literal|17
expr_stmt|;
comment|/* OFDM54: -8.5dB */
elseif|else
if|if
condition|(
operator|(
name|ridx
operator|%
literal|8
operator|)
operator|==
literal|7
condition|)
name|pwr
operator|-=
literal|20
expr_stmt|;
comment|/* OFDM60: -10dB */
else|else
name|pwr
operator|-=
literal|10
expr_stmt|;
comment|/* Others: -5dB */
comment|/* Do not exceed channel max TX power. */
if|if
condition|(
name|pwr
operator|>
name|maxchpwr
condition|)
name|pwr
operator|=
name|maxchpwr
expr_stmt|;
name|idx
operator|=
name|gain
operator|-
operator|(
name|pwr
operator|-
name|power
operator|)
operator|-
name|tdiff
operator|-
name|vdiff
expr_stmt|;
if|if
condition|(
operator|(
name|ridx
operator|/
literal|8
operator|)
operator|&
literal|1
condition|)
comment|/* MIMO */
name|idx
operator|+=
operator|(
name|int32_t
operator|)
name|le32toh
argument_list|(
name|uc
operator|->
name|atten
index|[
name|grp
index|]
index|[
name|c
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|.
name|band
operator|==
literal|0
condition|)
name|idx
operator|+=
literal|9
expr_stmt|;
comment|/* 5GHz */
if|if
condition|(
name|ridx
operator|==
name|IWN_RIDX_MAX
condition|)
name|idx
operator|+=
literal|5
expr_stmt|;
comment|/* CCK */
comment|/* Make sure idx stays in a valid range. */
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
name|idx
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|idx
operator|>
name|IWN4965_MAX_PWR_INDEX
condition|)
name|idx
operator|=
name|IWN4965_MAX_PWR_INDEX
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
operator||
name|IWN_DEBUG_TXPOW
argument_list|,
literal|"%s: Tx chain %d, rate idx %d: power=%d\n"
argument_list|,
name|__func__
argument_list|,
name|c
argument_list|,
name|ridx
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|power
index|[
name|ridx
index|]
operator|.
name|rf_gain
index|[
name|c
index|]
operator|=
name|rf_gain
index|[
name|idx
index|]
expr_stmt|;
name|cmd
operator|.
name|power
index|[
name|ridx
index|]
operator|.
name|dsp_gain
index|[
name|c
index|]
operator|=
name|dsp_gain
index|[
name|idx
index|]
expr_stmt|;
block|}
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
operator||
name|IWN_DEBUG_TXPOW
argument_list|,
literal|"%s: set tx power for chan %d\n"
argument_list|,
name|__func__
argument_list|,
name|chan
argument_list|)
expr_stmt|;
return|return
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_TXPOWER
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
name|cmd
argument_list|,
name|async
argument_list|)
return|;
undef|#
directive|undef
name|interpolate
undef|#
directive|undef
name|fdivround
block|}
end_function

begin_function
name|int
name|iwn5000_set_txpower
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|async
parameter_list|)
block|{
name|struct
name|iwn5000_cmd_txpower
name|cmd
decl_stmt|;
comment|/* 	 * TX power calibration is handled automatically by the firmware 	 * for 5000 Series. 	 */
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|global_limit
operator|=
literal|2
operator|*
name|IWN5000_TXPOWER_MAX_DBM
expr_stmt|;
comment|/* 16 dBm */
name|cmd
operator|.
name|flags
operator|=
name|IWN5000_TXPOWER_NO_CLOSED
expr_stmt|;
name|cmd
operator|.
name|srv_limit
operator|=
name|IWN5000_TXPOWER_AUTO
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s: setting TX power\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_TXPOWER_DBM
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
name|cmd
argument_list|,
name|async
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Retrieve the maximum RSSI (in dBm) among receivers.  */
end_comment

begin_function
name|int
name|iwn4965_get_rssi
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_rx_stat
modifier|*
name|stat
parameter_list|)
block|{
name|struct
name|iwn4965_rx_phystat
modifier|*
name|phy
init|=
operator|(
name|void
operator|*
operator|)
name|stat
operator|->
name|phybuf
decl_stmt|;
name|uint8_t
name|mask
decl_stmt|,
name|agc
decl_stmt|;
name|int
name|rssi
decl_stmt|;
name|mask
operator|=
operator|(
name|le16toh
argument_list|(
name|phy
operator|->
name|antenna
argument_list|)
operator|>>
literal|4
operator|)
operator|&
name|IWN_ANT_ABC
expr_stmt|;
name|agc
operator|=
operator|(
name|le16toh
argument_list|(
name|phy
operator|->
name|agc
argument_list|)
operator|>>
literal|7
operator|)
operator|&
literal|0x7f
expr_stmt|;
name|rssi
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
block|if (mask& IWN_ANT_A)
comment|/* Ant A */
block|rssi = max(rssi, phy->rssi[0]); 	if (mask& IWN_ATH_B)
comment|/* Ant B */
block|rssi = max(rssi, phy->rssi[2]); 	if (mask& IWN_ANT_C)
comment|/* Ant C */
block|rssi = max(rssi, phy->rssi[4]);
else|#
directive|else
name|rssi
operator|=
name|max
argument_list|(
name|rssi
argument_list|,
name|phy
operator|->
name|rssi
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|rssi
operator|=
name|max
argument_list|(
name|rssi
argument_list|,
name|phy
operator|->
name|rssi
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|rssi
operator|=
name|max
argument_list|(
name|rssi
argument_list|,
name|phy
operator|->
name|rssi
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RECV
argument_list|,
literal|"%s: agc %d mask 0x%x rssi %d %d %d "
literal|"result %d\n"
argument_list|,
name|__func__
argument_list|,
name|agc
argument_list|,
name|mask
argument_list|,
name|phy
operator|->
name|rssi
index|[
literal|0
index|]
argument_list|,
name|phy
operator|->
name|rssi
index|[
literal|2
index|]
argument_list|,
name|phy
operator|->
name|rssi
index|[
literal|4
index|]
argument_list|,
name|rssi
operator|-
name|agc
operator|-
name|IWN_RSSI_TO_DBM
argument_list|)
expr_stmt|;
return|return
name|rssi
operator|-
name|agc
operator|-
name|IWN_RSSI_TO_DBM
return|;
block|}
end_function

begin_function
name|int
name|iwn5000_get_rssi
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_rx_stat
modifier|*
name|stat
parameter_list|)
block|{
name|struct
name|iwn5000_rx_phystat
modifier|*
name|phy
init|=
operator|(
name|void
operator|*
operator|)
name|stat
operator|->
name|phybuf
decl_stmt|;
name|int
name|rssi
decl_stmt|;
name|uint8_t
name|agc
decl_stmt|;
name|agc
operator|=
operator|(
name|le32toh
argument_list|(
name|phy
operator|->
name|agc
argument_list|)
operator|>>
literal|9
operator|)
operator|&
literal|0x7f
expr_stmt|;
name|rssi
operator|=
name|MAX
argument_list|(
name|le16toh
argument_list|(
name|phy
operator|->
name|rssi
index|[
literal|0
index|]
argument_list|)
operator|&
literal|0xff
argument_list|,
name|le16toh
argument_list|(
name|phy
operator|->
name|rssi
index|[
literal|1
index|]
argument_list|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|rssi
operator|=
name|MAX
argument_list|(
name|le16toh
argument_list|(
name|phy
operator|->
name|rssi
index|[
literal|2
index|]
argument_list|)
operator|&
literal|0xff
argument_list|,
name|rssi
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RECV
argument_list|,
literal|"%s: agc %d rssi %d %d %d "
literal|"result %d\n"
argument_list|,
name|__func__
argument_list|,
name|agc
argument_list|,
name|phy
operator|->
name|rssi
index|[
literal|0
index|]
argument_list|,
name|phy
operator|->
name|rssi
index|[
literal|2
index|]
argument_list|,
name|phy
operator|->
name|rssi
index|[
literal|4
index|]
argument_list|,
name|rssi
operator|-
name|agc
operator|-
name|IWN_RSSI_TO_DBM
argument_list|)
expr_stmt|;
return|return
name|rssi
operator|-
name|agc
operator|-
name|IWN_RSSI_TO_DBM
return|;
block|}
end_function

begin_comment
comment|/*  * Retrieve the average noise (in dBm) among receivers.  */
end_comment

begin_function
name|int
name|iwn_get_noise
parameter_list|(
specifier|const
name|struct
name|iwn_rx_general_stats
modifier|*
name|stats
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|total
decl_stmt|,
name|nbant
decl_stmt|,
name|noise
decl_stmt|;
name|total
operator|=
name|nbant
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|noise
operator|=
name|le32toh
argument_list|(
name|stats
operator|->
name|noise
index|[
name|i
index|]
argument_list|)
operator|&
literal|0xff
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|total
operator|+=
name|noise
expr_stmt|;
name|nbant
operator|++
expr_stmt|;
block|}
comment|/* There should be at least one antenna but check anyway. */
return|return
operator|(
name|nbant
operator|==
literal|0
operator|)
condition|?
operator|-
literal|127
else|:
operator|(
name|total
operator|/
name|nbant
operator|)
operator|-
literal|107
return|;
block|}
end_function

begin_comment
comment|/*  * Compute temperature (in degC) from last received statistics.  */
end_comment

begin_function
name|int
name|iwn4965_get_temperature
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwn_ucode_info
modifier|*
name|uc
init|=
operator|&
name|sc
operator|->
name|ucode_info
decl_stmt|;
name|int32_t
name|r1
decl_stmt|,
name|r2
decl_stmt|,
name|r3
decl_stmt|,
name|r4
decl_stmt|,
name|temp
decl_stmt|;
name|r1
operator|=
name|le32toh
argument_list|(
name|uc
operator|->
name|temp
index|[
literal|0
index|]
operator|.
name|chan20MHz
argument_list|)
expr_stmt|;
name|r2
operator|=
name|le32toh
argument_list|(
name|uc
operator|->
name|temp
index|[
literal|1
index|]
operator|.
name|chan20MHz
argument_list|)
expr_stmt|;
name|r3
operator|=
name|le32toh
argument_list|(
name|uc
operator|->
name|temp
index|[
literal|2
index|]
operator|.
name|chan20MHz
argument_list|)
expr_stmt|;
name|r4
operator|=
name|le32toh
argument_list|(
name|sc
operator|->
name|rawtemp
argument_list|)
expr_stmt|;
if|if
condition|(
name|r1
operator|==
name|r3
condition|)
comment|/* Prevents division by 0 (should not happen.) */
return|return
literal|0
return|;
comment|/* Sign-extend 23-bit R4 value to 32-bit. */
name|r4
operator|=
operator|(
name|r4
operator|<<
literal|8
operator|)
operator|>>
literal|8
expr_stmt|;
comment|/* Compute temperature in Kelvin. */
name|temp
operator|=
operator|(
literal|259
operator|*
operator|(
name|r4
operator|-
name|r2
operator|)
operator|)
operator|/
operator|(
name|r3
operator|-
name|r1
operator|)
expr_stmt|;
name|temp
operator|=
operator|(
name|temp
operator|*
literal|97
operator|)
operator|/
literal|100
operator|+
literal|8
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_ANY
argument_list|,
literal|"temperature %dK/%dC\n"
argument_list|,
name|temp
argument_list|,
name|IWN_KTOC
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|IWN_KTOC
argument_list|(
name|temp
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|iwn5000_get_temperature
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int32_t
name|temp
decl_stmt|;
comment|/* 	 * Temperature is not used by the driver for 5000 Series because 	 * TX power calibration is handled by firmware.  We export it to 	 * users through the sensor framework though. 	 */
name|temp
operator|=
name|le32toh
argument_list|(
name|sc
operator|->
name|rawtemp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hw_type
operator|==
name|IWN_HW_REV_TYPE_5150
condition|)
block|{
name|temp
operator|=
operator|(
name|temp
operator|/
operator|-
literal|5
operator|)
operator|+
name|sc
operator|->
name|temp_off
expr_stmt|;
name|temp
operator|=
name|IWN_KTOC
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
return|return
name|temp
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize sensitivity calibration state machine.  */
end_comment

begin_function
name|int
name|iwn_init_sensitivity
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|struct
name|iwn_hal
modifier|*
name|hal
init|=
name|sc
operator|->
name|sc_hal
decl_stmt|;
name|struct
name|iwn_calib_state
modifier|*
name|calib
init|=
operator|&
name|sc
operator|->
name|calib
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Reset calibration state machine. */
name|memset
argument_list|(
name|calib
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|calib
argument_list|)
argument_list|)
expr_stmt|;
name|calib
operator|->
name|state
operator|=
name|IWN_CALIB_STATE_INIT
expr_stmt|;
name|calib
operator|->
name|cck_state
operator|=
name|IWN_CCK_STATE_HIFA
expr_stmt|;
comment|/* Set initial correlation values. */
name|calib
operator|->
name|ofdm_x1
operator|=
name|sc
operator|->
name|limits
operator|->
name|min_ofdm_x1
expr_stmt|;
name|calib
operator|->
name|ofdm_mrc_x1
operator|=
name|sc
operator|->
name|limits
operator|->
name|min_ofdm_mrc_x1
expr_stmt|;
name|calib
operator|->
name|ofdm_x4
operator|=
literal|90
expr_stmt|;
name|calib
operator|->
name|ofdm_mrc_x4
operator|=
name|sc
operator|->
name|limits
operator|->
name|min_ofdm_mrc_x4
expr_stmt|;
name|calib
operator|->
name|cck_x4
operator|=
literal|125
expr_stmt|;
name|calib
operator|->
name|cck_mrc_x4
operator|=
name|sc
operator|->
name|limits
operator|->
name|min_cck_mrc_x4
expr_stmt|;
name|calib
operator|->
name|energy_cck
operator|=
name|sc
operator|->
name|limits
operator|->
name|energy_cck
expr_stmt|;
comment|/* Write initial sensitivity. */
name|error
operator|=
name|iwn_send_sensitivity
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/* Write initial gains. */
name|error
operator|=
name|hal
operator|->
name|init_gains
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/* Request statistics at each beacon interval. */
name|flags
operator|=
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s: calibrate phy\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_GET_STATISTICS
argument_list|,
operator|&
name|flags
argument_list|,
sizeof|sizeof
name|flags
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Collect noise and RSSI statistics for the first 20 beacons received  * after association and use them to determine connected antennas and  * to set differential gains.  */
end_comment

begin_function
name|void
name|iwn_collect_noise
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|iwn_rx_general_stats
modifier|*
name|stats
parameter_list|)
block|{
specifier|const
name|struct
name|iwn_hal
modifier|*
name|hal
init|=
name|sc
operator|->
name|sc_hal
decl_stmt|;
name|struct
name|iwn_calib_state
modifier|*
name|calib
init|=
operator|&
name|sc
operator|->
name|calib
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Accumulate RSSI and noise for all 3 antennas. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|calib
operator|->
name|rssi
index|[
name|i
index|]
operator|+=
name|le32toh
argument_list|(
name|stats
operator|->
name|rssi
index|[
name|i
index|]
argument_list|)
operator|&
literal|0xff
expr_stmt|;
name|calib
operator|->
name|noise
index|[
name|i
index|]
operator|+=
name|le32toh
argument_list|(
name|stats
operator|->
name|noise
index|[
name|i
index|]
argument_list|)
operator|&
literal|0xff
expr_stmt|;
block|}
comment|/* NB: We update differential gains only once after 20 beacons. */
if|if
condition|(
operator|++
name|calib
operator|->
name|nbeacons
operator|<
literal|20
condition|)
return|return;
comment|/* Determine highest average RSSI. */
name|val
operator|=
name|MAX
argument_list|(
name|calib
operator|->
name|rssi
index|[
literal|0
index|]
argument_list|,
name|calib
operator|->
name|rssi
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|val
operator|=
name|MAX
argument_list|(
name|calib
operator|->
name|rssi
index|[
literal|2
index|]
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Determine which antennas are connected. */
name|sc
operator|->
name|chainmask
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|val
operator|-
name|calib
operator|->
name|rssi
index|[
name|i
index|]
operator|<=
literal|15
operator|*
literal|20
condition|)
name|sc
operator|->
name|chainmask
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
comment|/* If none of the TX antennas are connected, keep at least one. */
if|if
condition|(
operator|(
name|sc
operator|->
name|chainmask
operator|&
name|sc
operator|->
name|txchainmask
operator|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|chainmask
operator||=
name|IWN_LSB
argument_list|(
name|sc
operator|->
name|txchainmask
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|hal
operator|->
name|set_gains
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|calib
operator|->
name|state
operator|=
name|IWN_CALIB_STATE_RUN
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* XXX Disable RX chains with no antennas connected. */
name|sc
operator|->
name|rxon
operator|.
name|rxchain
operator|=
name|htole16
argument_list|(
name|IWN_RXCHAIN_SEL
argument_list|(
name|sc
operator|->
name|chainmask
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_RXON
argument_list|,
operator|&
name|sc
operator|->
name|rxon
argument_list|,
name|hal
operator|->
name|rxonsz
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* XXX: not yet */
comment|/* Enable power-saving mode if requested by user. */
block|if (sc->sc_ic.ic_flags& IEEE80211_F_PMGTON) 		(void)iwn_set_pslevel(sc, 0, 3, 1);
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|iwn4965_init_gains
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwn_phy_calib_gain
name|cmd
decl_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|code
operator|=
name|IWN4965_PHY_CALIB_DIFF_GAIN
expr_stmt|;
comment|/* Differential gains initially set to 0 for all 3 antennas. */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s: setting initial differential gains\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_PHY_CALIB
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
name|cmd
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|iwn5000_init_gains
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwn_phy_calib
name|cmd
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|hw_type
operator|==
name|IWN_HW_REV_TYPE_6050
condition|)
return|return
literal|0
return|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|code
operator|=
name|IWN5000_PHY_CALIB_RESET_NOISE_GAIN
expr_stmt|;
name|cmd
operator|.
name|ngroups
operator|=
literal|1
expr_stmt|;
name|cmd
operator|.
name|isvalid
operator|=
literal|1
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s: setting initial differential gains\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_PHY_CALIB
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
name|cmd
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|iwn4965_set_gains
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwn_calib_state
modifier|*
name|calib
init|=
operator|&
name|sc
operator|->
name|calib
decl_stmt|;
name|struct
name|iwn_phy_calib_gain
name|cmd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|delta
decl_stmt|,
name|noise
decl_stmt|;
comment|/* Get minimal noise among connected antennas. */
name|noise
operator|=
name|INT_MAX
expr_stmt|;
comment|/* NB: There's at least one antenna. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|chainmask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|noise
operator|=
name|MIN
argument_list|(
name|calib
operator|->
name|noise
index|[
name|i
index|]
argument_list|,
name|noise
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|code
operator|=
name|IWN4965_PHY_CALIB_DIFF_GAIN
expr_stmt|;
comment|/* Set differential gains for connected antennas. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|chainmask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
comment|/* Compute attenuation (in unit of 1.5dB). */
name|delta
operator|=
operator|(
name|noise
operator|-
operator|(
name|int32_t
operator|)
name|calib
operator|->
name|noise
index|[
name|i
index|]
operator|)
operator|/
literal|30
expr_stmt|;
comment|/* NB: delta<= 0 */
comment|/* Limit to [-4.5dB,0]. */
name|cmd
operator|.
name|gain
index|[
name|i
index|]
operator|=
name|MIN
argument_list|(
name|abs
argument_list|(
name|delta
argument_list|)
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
name|cmd
operator|.
name|gain
index|[
name|i
index|]
operator||=
literal|1
operator|<<
literal|2
expr_stmt|;
comment|/* sign bit */
block|}
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"setting differential gains Ant A/B/C: %x/%x/%x (%x)\n"
argument_list|,
name|cmd
operator|.
name|gain
index|[
literal|0
index|]
argument_list|,
name|cmd
operator|.
name|gain
index|[
literal|1
index|]
argument_list|,
name|cmd
operator|.
name|gain
index|[
literal|2
index|]
argument_list|,
name|sc
operator|->
name|chainmask
argument_list|)
expr_stmt|;
return|return
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_PHY_CALIB
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
name|cmd
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|iwn5000_set_gains
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwn_calib_state
modifier|*
name|calib
init|=
operator|&
name|sc
operator|->
name|calib
decl_stmt|;
name|struct
name|iwn_phy_calib_gain
name|cmd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ant
decl_stmt|,
name|delta
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|hw_type
operator|==
name|IWN_HW_REV_TYPE_6050
condition|)
return|return
literal|0
return|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|code
operator|=
name|IWN5000_PHY_CALIB_NOISE_GAIN
expr_stmt|;
name|cmd
operator|.
name|ngroups
operator|=
literal|1
expr_stmt|;
name|cmd
operator|.
name|isvalid
operator|=
literal|1
expr_stmt|;
comment|/* Get first available RX antenna as referential. */
name|ant
operator|=
name|IWN_LSB
argument_list|(
name|sc
operator|->
name|rxchainmask
argument_list|)
expr_stmt|;
comment|/* Set differential gains for other antennas. */
for|for
control|(
name|i
operator|=
name|ant
operator|+
literal|1
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|chainmask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
comment|/* The delta is relative to antenna "ant". */
name|delta
operator|=
operator|(
operator|(
name|int32_t
operator|)
name|calib
operator|->
name|noise
index|[
name|ant
index|]
operator|-
operator|(
name|int32_t
operator|)
name|calib
operator|->
name|noise
index|[
name|i
index|]
operator|)
operator|/
literal|30
expr_stmt|;
comment|/* Limit to [-4.5dB,+4.5dB]. */
name|cmd
operator|.
name|gain
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|MIN
argument_list|(
name|abs
argument_list|(
name|delta
argument_list|)
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
name|cmd
operator|.
name|gain
index|[
name|i
operator|-
literal|1
index|]
operator||=
literal|1
operator|<<
literal|2
expr_stmt|;
comment|/* sign bit */
block|}
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"setting differential gains Ant B/C: %x/%x (%x)\n"
argument_list|,
name|cmd
operator|.
name|gain
index|[
literal|0
index|]
argument_list|,
name|cmd
operator|.
name|gain
index|[
literal|1
index|]
argument_list|,
name|sc
operator|->
name|chainmask
argument_list|)
expr_stmt|;
return|return
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_PHY_CALIB
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
name|cmd
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Tune RF RX sensitivity based on the number of false alarms detected  * during the last beacon period.  */
end_comment

begin_function
name|void
name|iwn_tune_sensitivity
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|iwn_rx_stats
modifier|*
name|stats
parameter_list|)
block|{
define|#
directive|define
name|inc
parameter_list|(
name|val
parameter_list|,
name|inc
parameter_list|,
name|max
parameter_list|)
define|\
value|if ((val)< (max)) {			\ 		if ((val)< (max) - (inc))	\ 			(val) += (inc);		\ 		else				\ 			(val) = (max);		\ 		needs_update = 1;		\ 	}
define|#
directive|define
name|dec
parameter_list|(
name|val
parameter_list|,
name|dec
parameter_list|,
name|min
parameter_list|)
define|\
value|if ((val)> (min)) {			\ 		if ((val)> (min) + (dec))	\ 			(val) -= (dec);		\ 		else				\ 			(val) = (min);		\ 		needs_update = 1;		\ 	}
specifier|const
name|struct
name|iwn_sensitivity_limits
modifier|*
name|limits
init|=
name|sc
operator|->
name|limits
decl_stmt|;
name|struct
name|iwn_calib_state
modifier|*
name|calib
init|=
operator|&
name|sc
operator|->
name|calib
decl_stmt|;
name|uint32_t
name|val
decl_stmt|,
name|rxena
decl_stmt|,
name|fa
decl_stmt|;
name|uint32_t
name|energy
index|[
literal|3
index|]
decl_stmt|,
name|energy_min
decl_stmt|;
name|uint8_t
name|noise
index|[
literal|3
index|]
decl_stmt|,
name|noise_ref
decl_stmt|;
name|int
name|i
decl_stmt|,
name|needs_update
init|=
literal|0
decl_stmt|;
comment|/* Check that we've been enabled long enough. */
name|rxena
operator|=
name|le32toh
argument_list|(
name|stats
operator|->
name|general
operator|.
name|load
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxena
operator|==
literal|0
condition|)
return|return;
comment|/* Compute number of false alarms since last call for OFDM. */
name|fa
operator|=
name|le32toh
argument_list|(
name|stats
operator|->
name|ofdm
operator|.
name|bad_plcp
argument_list|)
operator|-
name|calib
operator|->
name|bad_plcp_ofdm
expr_stmt|;
name|fa
operator|+=
name|le32toh
argument_list|(
name|stats
operator|->
name|ofdm
operator|.
name|fa
argument_list|)
operator|-
name|calib
operator|->
name|fa_ofdm
expr_stmt|;
name|fa
operator|*=
literal|200
operator|*
literal|1024
expr_stmt|;
comment|/* 200TU */
comment|/* Save counters values for next call. */
name|calib
operator|->
name|bad_plcp_ofdm
operator|=
name|le32toh
argument_list|(
name|stats
operator|->
name|ofdm
operator|.
name|bad_plcp
argument_list|)
expr_stmt|;
name|calib
operator|->
name|fa_ofdm
operator|=
name|le32toh
argument_list|(
name|stats
operator|->
name|ofdm
operator|.
name|fa
argument_list|)
expr_stmt|;
if|if
condition|(
name|fa
operator|>
literal|50
operator|*
name|rxena
condition|)
block|{
comment|/* High false alarm count, decrease sensitivity. */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s: OFDM high false alarm count: %u\n"
argument_list|,
name|__func__
argument_list|,
name|fa
argument_list|)
expr_stmt|;
name|inc
argument_list|(
name|calib
operator|->
name|ofdm_x1
argument_list|,
literal|1
argument_list|,
name|limits
operator|->
name|max_ofdm_x1
argument_list|)
expr_stmt|;
name|inc
argument_list|(
name|calib
operator|->
name|ofdm_mrc_x1
argument_list|,
literal|1
argument_list|,
name|limits
operator|->
name|max_ofdm_mrc_x1
argument_list|)
expr_stmt|;
name|inc
argument_list|(
name|calib
operator|->
name|ofdm_x4
argument_list|,
literal|1
argument_list|,
name|limits
operator|->
name|max_ofdm_x4
argument_list|)
expr_stmt|;
name|inc
argument_list|(
name|calib
operator|->
name|ofdm_mrc_x4
argument_list|,
literal|1
argument_list|,
name|limits
operator|->
name|max_ofdm_mrc_x4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fa
operator|<
literal|5
operator|*
name|rxena
condition|)
block|{
comment|/* Low false alarm count, increase sensitivity. */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s: OFDM low false alarm count: %u\n"
argument_list|,
name|__func__
argument_list|,
name|fa
argument_list|)
expr_stmt|;
name|dec
argument_list|(
name|calib
operator|->
name|ofdm_x1
argument_list|,
literal|1
argument_list|,
name|limits
operator|->
name|min_ofdm_x1
argument_list|)
expr_stmt|;
name|dec
argument_list|(
name|calib
operator|->
name|ofdm_mrc_x1
argument_list|,
literal|1
argument_list|,
name|limits
operator|->
name|min_ofdm_mrc_x1
argument_list|)
expr_stmt|;
name|dec
argument_list|(
name|calib
operator|->
name|ofdm_x4
argument_list|,
literal|1
argument_list|,
name|limits
operator|->
name|min_ofdm_x4
argument_list|)
expr_stmt|;
name|dec
argument_list|(
name|calib
operator|->
name|ofdm_mrc_x4
argument_list|,
literal|1
argument_list|,
name|limits
operator|->
name|min_ofdm_mrc_x4
argument_list|)
expr_stmt|;
block|}
comment|/* Compute maximum noise among 3 receivers. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|noise
index|[
name|i
index|]
operator|=
operator|(
name|le32toh
argument_list|(
name|stats
operator|->
name|general
operator|.
name|noise
index|[
name|i
index|]
argument_list|)
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|val
operator|=
name|MAX
argument_list|(
name|noise
index|[
literal|0
index|]
argument_list|,
name|noise
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|val
operator|=
name|MAX
argument_list|(
name|noise
index|[
literal|2
index|]
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Insert it into our samples table. */
name|calib
operator|->
name|noise_samples
index|[
name|calib
operator|->
name|cur_noise_sample
index|]
operator|=
name|val
expr_stmt|;
name|calib
operator|->
name|cur_noise_sample
operator|=
operator|(
name|calib
operator|->
name|cur_noise_sample
operator|+
literal|1
operator|)
operator|%
literal|20
expr_stmt|;
comment|/* Compute maximum noise among last 20 samples. */
name|noise_ref
operator|=
name|calib
operator|->
name|noise_samples
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
name|noise_ref
operator|=
name|MAX
argument_list|(
name|noise_ref
argument_list|,
name|calib
operator|->
name|noise_samples
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Compute maximum energy among 3 receivers. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|energy
index|[
name|i
index|]
operator|=
name|le32toh
argument_list|(
name|stats
operator|->
name|general
operator|.
name|energy
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|val
operator|=
name|MIN
argument_list|(
name|energy
index|[
literal|0
index|]
argument_list|,
name|energy
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|val
operator|=
name|MIN
argument_list|(
name|energy
index|[
literal|2
index|]
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Insert it into our samples table. */
name|calib
operator|->
name|energy_samples
index|[
name|calib
operator|->
name|cur_energy_sample
index|]
operator|=
name|val
expr_stmt|;
name|calib
operator|->
name|cur_energy_sample
operator|=
operator|(
name|calib
operator|->
name|cur_energy_sample
operator|+
literal|1
operator|)
operator|%
literal|10
expr_stmt|;
comment|/* Compute minimum energy among last 10 samples. */
name|energy_min
operator|=
name|calib
operator|->
name|energy_samples
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
name|energy_min
operator|=
name|MAX
argument_list|(
name|energy_min
argument_list|,
name|calib
operator|->
name|energy_samples
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|energy_min
operator|+=
literal|6
expr_stmt|;
comment|/* Compute number of false alarms since last call for CCK. */
name|fa
operator|=
name|le32toh
argument_list|(
name|stats
operator|->
name|cck
operator|.
name|bad_plcp
argument_list|)
operator|-
name|calib
operator|->
name|bad_plcp_cck
expr_stmt|;
name|fa
operator|+=
name|le32toh
argument_list|(
name|stats
operator|->
name|cck
operator|.
name|fa
argument_list|)
operator|-
name|calib
operator|->
name|fa_cck
expr_stmt|;
name|fa
operator|*=
literal|200
operator|*
literal|1024
expr_stmt|;
comment|/* 200TU */
comment|/* Save counters values for next call. */
name|calib
operator|->
name|bad_plcp_cck
operator|=
name|le32toh
argument_list|(
name|stats
operator|->
name|cck
operator|.
name|bad_plcp
argument_list|)
expr_stmt|;
name|calib
operator|->
name|fa_cck
operator|=
name|le32toh
argument_list|(
name|stats
operator|->
name|cck
operator|.
name|fa
argument_list|)
expr_stmt|;
if|if
condition|(
name|fa
operator|>
literal|50
operator|*
name|rxena
condition|)
block|{
comment|/* High false alarm count, decrease sensitivity. */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s: CCK high false alarm count: %u\n"
argument_list|,
name|__func__
argument_list|,
name|fa
argument_list|)
expr_stmt|;
name|calib
operator|->
name|cck_state
operator|=
name|IWN_CCK_STATE_HIFA
expr_stmt|;
name|calib
operator|->
name|low_fa
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|calib
operator|->
name|cck_x4
operator|>
literal|160
condition|)
block|{
name|calib
operator|->
name|noise_ref
operator|=
name|noise_ref
expr_stmt|;
if|if
condition|(
name|calib
operator|->
name|energy_cck
operator|>
literal|2
condition|)
name|dec
argument_list|(
name|calib
operator|->
name|energy_cck
argument_list|,
literal|2
argument_list|,
name|energy_min
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|calib
operator|->
name|cck_x4
operator|<
literal|160
condition|)
block|{
name|calib
operator|->
name|cck_x4
operator|=
literal|161
expr_stmt|;
name|needs_update
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|inc
argument_list|(
name|calib
operator|->
name|cck_x4
argument_list|,
literal|3
argument_list|,
name|limits
operator|->
name|max_cck_x4
argument_list|)
expr_stmt|;
name|inc
argument_list|(
name|calib
operator|->
name|cck_mrc_x4
argument_list|,
literal|3
argument_list|,
name|limits
operator|->
name|max_cck_mrc_x4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fa
operator|<
literal|5
operator|*
name|rxena
condition|)
block|{
comment|/* Low false alarm count, increase sensitivity. */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s: CCK low false alarm count: %u\n"
argument_list|,
name|__func__
argument_list|,
name|fa
argument_list|)
expr_stmt|;
name|calib
operator|->
name|cck_state
operator|=
name|IWN_CCK_STATE_LOFA
expr_stmt|;
name|calib
operator|->
name|low_fa
operator|++
expr_stmt|;
if|if
condition|(
name|calib
operator|->
name|cck_state
operator|!=
name|IWN_CCK_STATE_INIT
operator|&&
operator|(
operator|(
operator|(
name|int32_t
operator|)
name|calib
operator|->
name|noise_ref
operator|-
operator|(
name|int32_t
operator|)
name|noise_ref
operator|)
operator|>
literal|2
operator|||
name|calib
operator|->
name|low_fa
operator|>
literal|100
operator|)
condition|)
block|{
name|inc
argument_list|(
name|calib
operator|->
name|energy_cck
argument_list|,
literal|2
argument_list|,
name|limits
operator|->
name|min_energy_cck
argument_list|)
expr_stmt|;
name|dec
argument_list|(
name|calib
operator|->
name|cck_x4
argument_list|,
literal|3
argument_list|,
name|limits
operator|->
name|min_cck_x4
argument_list|)
expr_stmt|;
name|dec
argument_list|(
name|calib
operator|->
name|cck_mrc_x4
argument_list|,
literal|3
argument_list|,
name|limits
operator|->
name|min_cck_mrc_x4
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Not worth to increase or decrease sensitivity. */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s: CCK normal false alarm count: %u\n"
argument_list|,
name|__func__
argument_list|,
name|fa
argument_list|)
expr_stmt|;
name|calib
operator|->
name|low_fa
operator|=
literal|0
expr_stmt|;
name|calib
operator|->
name|noise_ref
operator|=
name|noise_ref
expr_stmt|;
if|if
condition|(
name|calib
operator|->
name|cck_state
operator|==
name|IWN_CCK_STATE_HIFA
condition|)
block|{
comment|/* Previous interval had many false alarms. */
name|dec
argument_list|(
name|calib
operator|->
name|energy_cck
argument_list|,
literal|8
argument_list|,
name|energy_min
argument_list|)
expr_stmt|;
block|}
name|calib
operator|->
name|cck_state
operator|=
name|IWN_CCK_STATE_INIT
expr_stmt|;
block|}
if|if
condition|(
name|needs_update
condition|)
operator|(
name|void
operator|)
name|iwn_send_sensitivity
argument_list|(
name|sc
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|dec
undef|#
directive|undef
name|inc
block|}
end_function

begin_function
name|int
name|iwn_send_sensitivity
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwn_calib_state
modifier|*
name|calib
init|=
operator|&
name|sc
operator|->
name|calib
decl_stmt|;
name|struct
name|iwn_sensitivity_cmd
name|cmd
decl_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|which
operator|=
name|IWN_SENSITIVITY_WORKTBL
expr_stmt|;
comment|/* OFDM modulation. */
name|cmd
operator|.
name|corr_ofdm_x1
operator|=
name|htole16
argument_list|(
name|calib
operator|->
name|ofdm_x1
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|corr_ofdm_mrc_x1
operator|=
name|htole16
argument_list|(
name|calib
operator|->
name|ofdm_mrc_x1
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|corr_ofdm_x4
operator|=
name|htole16
argument_list|(
name|calib
operator|->
name|ofdm_x4
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|corr_ofdm_mrc_x4
operator|=
name|htole16
argument_list|(
name|calib
operator|->
name|ofdm_mrc_x4
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|energy_ofdm
operator|=
name|htole16
argument_list|(
name|sc
operator|->
name|limits
operator|->
name|energy_ofdm
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|energy_ofdm_th
operator|=
name|htole16
argument_list|(
literal|62
argument_list|)
expr_stmt|;
comment|/* CCK modulation. */
name|cmd
operator|.
name|corr_cck_x4
operator|=
name|htole16
argument_list|(
name|calib
operator|->
name|cck_x4
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|corr_cck_mrc_x4
operator|=
name|htole16
argument_list|(
name|calib
operator|->
name|cck_mrc_x4
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|energy_cck
operator|=
name|htole16
argument_list|(
name|calib
operator|->
name|energy_cck
argument_list|)
expr_stmt|;
comment|/* Barker modulation: use default values. */
name|cmd
operator|.
name|corr_barker
operator|=
name|htole16
argument_list|(
literal|190
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|corr_barker_mrc
operator|=
name|htole16
argument_list|(
literal|390
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"%s: set sensitivity %d/%d/%d/%d/%d/%d/%d\n"
argument_list|,
name|__func__
argument_list|,
name|calib
operator|->
name|ofdm_x1
argument_list|,
name|calib
operator|->
name|ofdm_mrc_x1
argument_list|,
name|calib
operator|->
name|ofdm_x4
argument_list|,
name|calib
operator|->
name|ofdm_mrc_x4
argument_list|,
name|calib
operator|->
name|cck_x4
argument_list|,
name|calib
operator|->
name|cck_mrc_x4
argument_list|,
name|calib
operator|->
name|energy_cck
argument_list|)
expr_stmt|;
return|return
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_SET_SENSITIVITY
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
name|cmd
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set STA mode power saving level (between 0 and 5).  * Level 0 is CAM (Continuously Aware Mode), 5 is for maximum power saving.  */
end_comment

begin_function
name|int
name|iwn_set_pslevel
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|dtim
parameter_list|,
name|int
name|level
parameter_list|,
name|int
name|async
parameter_list|)
block|{
specifier|const
name|struct
name|iwn_pmgt
modifier|*
name|pmgt
decl_stmt|;
name|struct
name|iwn_pmgt_cmd
name|cmd
decl_stmt|;
name|uint32_t
name|max
decl_stmt|,
name|skip_dtim
decl_stmt|;
name|uint32_t
name|tmp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Select which PS parameters to use. */
if|if
condition|(
name|dtim
operator|<=
literal|2
condition|)
name|pmgt
operator|=
operator|&
name|iwn_pmgt
index|[
literal|0
index|]
index|[
name|level
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|dtim
operator|<=
literal|10
condition|)
name|pmgt
operator|=
operator|&
name|iwn_pmgt
index|[
literal|1
index|]
index|[
name|level
index|]
expr_stmt|;
else|else
name|pmgt
operator|=
operator|&
name|iwn_pmgt
index|[
literal|2
index|]
index|[
name|level
index|]
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|!=
literal|0
condition|)
comment|/* not CAM */
name|cmd
operator|.
name|flags
operator||=
name|htole16
argument_list|(
name|IWN_PS_ALLOW_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|==
literal|5
condition|)
name|cmd
operator|.
name|flags
operator||=
name|htole16
argument_list|(
name|IWN_PS_FAST_PD
argument_list|)
expr_stmt|;
comment|/* Retrieve PCIe Active State Power Management (ASPM). */
name|tmp
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|sc
operator|->
name|sc_cap_off
operator|+
literal|0x10
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tmp
operator|&
literal|0x1
operator|)
condition|)
comment|/* L0s Entry disabled. */
name|cmd
operator|.
name|flags
operator||=
name|htole16
argument_list|(
name|IWN_PS_PCI_PMGT
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|rxtimeout
operator|=
name|htole32
argument_list|(
name|pmgt
operator|->
name|rxtimeout
operator|*
literal|1024
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|txtimeout
operator|=
name|htole32
argument_list|(
name|pmgt
operator|->
name|txtimeout
operator|*
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtim
operator|==
literal|0
condition|)
block|{
name|dtim
operator|=
literal|1
expr_stmt|;
name|skip_dtim
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|skip_dtim
operator|=
name|pmgt
operator|->
name|skip_dtim
expr_stmt|;
if|if
condition|(
name|skip_dtim
operator|!=
literal|0
condition|)
block|{
name|cmd
operator|.
name|flags
operator||=
name|htole16
argument_list|(
name|IWN_PS_SLEEP_OVER_DTIM
argument_list|)
expr_stmt|;
name|max
operator|=
name|pmgt
operator|->
name|intval
index|[
literal|4
index|]
expr_stmt|;
if|if
condition|(
name|max
operator|==
operator|(
name|uint32_t
operator|)
operator|-
literal|1
condition|)
name|max
operator|=
name|dtim
operator|*
operator|(
name|skip_dtim
operator|+
literal|1
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|max
operator|>
name|dtim
condition|)
name|max
operator|=
operator|(
name|max
operator|/
name|dtim
operator|)
operator|*
name|dtim
expr_stmt|;
block|}
else|else
name|max
operator|=
name|dtim
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
name|cmd
operator|.
name|intval
index|[
name|i
index|]
operator|=
name|htole32
argument_list|(
name|MIN
argument_list|(
name|max
argument_list|,
name|pmgt
operator|->
name|intval
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"setting power saving level to %d\n"
argument_list|,
name|level
argument_list|)
expr_stmt|;
return|return
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_SET_POWER_MODE
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
name|cmd
argument_list|,
name|async
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|iwn_config
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|struct
name|iwn_hal
modifier|*
name|hal
init|=
name|sc
operator|->
name|sc_hal
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|iwn_bluetooth
name|bluetooth
decl_stmt|;
name|uint32_t
name|txmask
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint16_t
name|rxchain
decl_stmt|;
comment|/* Configure valid TX chains for 5000 Series. */
if|if
condition|(
name|sc
operator|->
name|hw_type
operator|!=
name|IWN_HW_REV_TYPE_4965
condition|)
block|{
name|txmask
operator|=
name|htole32
argument_list|(
name|sc
operator|->
name|txchainmask
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"%s: configuring valid TX chains 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|txmask
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN5000_CMD_TX_ANT_CONFIG
argument_list|,
operator|&
name|txmask
argument_list|,
sizeof|sizeof
name|txmask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not configure valid TX chains, "
literal|"error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
comment|/* Configure bluetooth coexistence. */
name|memset
argument_list|(
operator|&
name|bluetooth
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|bluetooth
argument_list|)
expr_stmt|;
name|bluetooth
operator|.
name|flags
operator|=
name|IWN_BT_COEX_MODE_4WIRE
expr_stmt|;
name|bluetooth
operator|.
name|lead_time
operator|=
name|IWN_BT_LEAD_TIME_DEF
expr_stmt|;
name|bluetooth
operator|.
name|max_kill
operator|=
name|IWN_BT_MAX_KILL_DEF
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"%s: config bluetooth coexistence\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_BT_COEX
argument_list|,
operator|&
name|bluetooth
argument_list|,
sizeof|sizeof
name|bluetooth
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not configure bluetooth coexistence, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Set mode, channel, RX filter and enable RX. */
name|memset
argument_list|(
operator|&
name|sc
operator|->
name|rxon
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_rxon
argument_list|)
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|sc
operator|->
name|rxon
operator|.
name|myaddr
argument_list|,
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|sc
operator|->
name|rxon
operator|.
name|wlap
argument_list|,
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rxon
operator|.
name|chan
operator|=
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rxon
operator|.
name|flags
operator|=
name|htole32
argument_list|(
name|IWN_RXON_TSF
operator||
name|IWN_RXON_CTS_TO_SELF
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
condition|)
name|sc
operator|->
name|rxon
operator|.
name|flags
operator||=
name|htole32
argument_list|(
name|IWN_RXON_AUTO
operator||
name|IWN_RXON_24GHZ
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ic
operator|->
name|ic_opmode
condition|)
block|{
case|case
name|IEEE80211_M_STA
case|:
name|sc
operator|->
name|rxon
operator|.
name|mode
operator|=
name|IWN_MODE_STA
expr_stmt|;
name|sc
operator|->
name|rxon
operator|.
name|filter
operator|=
name|htole32
argument_list|(
name|IWN_FILTER_MULTICAST
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_MONITOR
case|:
name|sc
operator|->
name|rxon
operator|.
name|mode
operator|=
name|IWN_MODE_MONITOR
expr_stmt|;
name|sc
operator|->
name|rxon
operator|.
name|filter
operator|=
name|htole32
argument_list|(
name|IWN_FILTER_MULTICAST
operator||
name|IWN_FILTER_CTL
operator||
name|IWN_FILTER_PROMISC
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Should not get there. */
break|break;
block|}
name|sc
operator|->
name|rxon
operator|.
name|cck_mask
operator|=
literal|0x0f
expr_stmt|;
comment|/* not yet negotiated */
name|sc
operator|->
name|rxon
operator|.
name|ofdm_mask
operator|=
literal|0xff
expr_stmt|;
comment|/* not yet negotiated */
name|sc
operator|->
name|rxon
operator|.
name|ht_single_mask
operator|=
literal|0xff
expr_stmt|;
name|sc
operator|->
name|rxon
operator|.
name|ht_dual_mask
operator|=
literal|0xff
expr_stmt|;
name|sc
operator|->
name|rxon
operator|.
name|ht_triple_mask
operator|=
literal|0xff
expr_stmt|;
name|rxchain
operator|=
name|IWN_RXCHAIN_VALID
argument_list|(
name|sc
operator|->
name|rxchainmask
argument_list|)
operator||
name|IWN_RXCHAIN_MIMO_COUNT
argument_list|(
literal|2
argument_list|)
operator||
name|IWN_RXCHAIN_IDLE_COUNT
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rxon
operator|.
name|rxchain
operator|=
name|htole16
argument_list|(
name|rxchain
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"%s: setting configuration\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_RXON
argument_list|,
operator|&
name|sc
operator|->
name|rxon
argument_list|,
name|hal
operator|->
name|rxonsz
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: RXON command failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|iwn_add_broadcast_node
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not add broadcast node\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Configuration has changed, set TX power accordingly. */
name|error
operator|=
name|hal
operator|->
name|set_txpower
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not set TX power\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|iwn_set_critical_temp
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: ccould not set critical temperature\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Set power saving level to CAM during initialization. */
name|error
operator|=
name|iwn_set_pslevel
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not set power saving level\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|iwn_scan
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
init|=
name|ic
operator|->
name|ic_scan
decl_stmt|;
comment|/*XXX*/
name|struct
name|iwn_scan_hdr
modifier|*
name|hdr
decl_stmt|;
name|struct
name|iwn_cmd_data
modifier|*
name|tx
decl_stmt|;
name|struct
name|iwn_scan_essid
modifier|*
name|essid
decl_stmt|;
name|struct
name|iwn_scan_chan
modifier|*
name|chan
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|struct
name|ieee80211_rateset
modifier|*
name|rs
decl_stmt|;
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|;
name|int
name|buflen
decl_stmt|,
name|error
decl_stmt|,
name|nrates
decl_stmt|;
name|uint16_t
name|rxchain
decl_stmt|;
name|uint8_t
modifier|*
name|buf
decl_stmt|,
modifier|*
name|frm
decl_stmt|,
name|txant
decl_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|IWN_SCAN_MAXSZ
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not allocate buffer for scan command\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|hdr
operator|=
operator|(
expr|struct
name|iwn_scan_hdr
operator|*
operator|)
name|buf
expr_stmt|;
comment|/* 	 * Move to the next channel if no frames are received within 10ms 	 * after sending the probe request. 	 */
name|hdr
operator|->
name|quiet_time
operator|=
name|htole16
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* timeout in milliseconds */
name|hdr
operator|->
name|quiet_threshold
operator|=
name|htole16
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* min # of packets */
comment|/* Select antennas for scanning. */
name|rxchain
operator|=
name|IWN_RXCHAIN_VALID
argument_list|(
name|sc
operator|->
name|rxchainmask
argument_list|)
operator||
name|IWN_RXCHAIN_FORCE_MIMO_SEL
argument_list|(
name|sc
operator|->
name|rxchainmask
argument_list|)
operator||
name|IWN_RXCHAIN_DRIVER_FORCE
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_A
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
operator|&&
name|sc
operator|->
name|hw_type
operator|==
name|IWN_HW_REV_TYPE_4965
condition|)
block|{
comment|/* Ant A must be avoided in 5GHz because of an HW bug. */
name|rxchain
operator||=
name|IWN_RXCHAIN_FORCE_SEL
argument_list|(
name|IWN_ANT_BC
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Use all available RX antennas. */
name|rxchain
operator||=
name|IWN_RXCHAIN_FORCE_SEL
argument_list|(
name|sc
operator|->
name|rxchainmask
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|rxchain
operator|=
name|htole16
argument_list|(
name|rxchain
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|filter
operator|=
name|htole32
argument_list|(
name|IWN_FILTER_MULTICAST
operator||
name|IWN_FILTER_BEACON
argument_list|)
expr_stmt|;
name|tx
operator|=
operator|(
expr|struct
name|iwn_cmd_data
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
expr_stmt|;
name|tx
operator|->
name|flags
operator|=
name|htole32
argument_list|(
name|IWN_TX_AUTO_SEQ
argument_list|)
expr_stmt|;
name|tx
operator|->
name|id
operator|=
name|sc
operator|->
name|sc_hal
operator|->
name|broadcast_id
expr_stmt|;
name|tx
operator|->
name|lifetime
operator|=
name|htole32
argument_list|(
name|IWN_LIFETIME_INFINITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_A
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
condition|)
block|{
comment|/* Send probe requests at 6Mbps. */
name|tx
operator|->
name|plcp
operator|=
name|iwn_rates
index|[
name|IWN_RIDX_OFDM6
index|]
operator|.
name|plcp
expr_stmt|;
name|rs
operator|=
operator|&
name|ic
operator|->
name|ic_sup_rates
index|[
name|IEEE80211_MODE_11A
index|]
expr_stmt|;
block|}
else|else
block|{
name|hdr
operator|->
name|flags
operator|=
name|htole32
argument_list|(
name|IWN_RXON_24GHZ
operator||
name|IWN_RXON_AUTO
argument_list|)
expr_stmt|;
comment|/* Send probe requests at 1Mbps. */
name|tx
operator|->
name|plcp
operator|=
name|iwn_rates
index|[
name|IWN_RIDX_CCK1
index|]
operator|.
name|plcp
expr_stmt|;
name|tx
operator|->
name|rflags
operator|=
name|IWN_RFLAG_CCK
expr_stmt|;
name|rs
operator|=
operator|&
name|ic
operator|->
name|ic_sup_rates
index|[
name|IEEE80211_MODE_11G
index|]
expr_stmt|;
block|}
comment|/* Use the first valid TX antenna. */
name|txant
operator|=
name|IWN_LSB
argument_list|(
name|sc
operator|->
name|txchainmask
argument_list|)
expr_stmt|;
name|tx
operator|->
name|rflags
operator||=
name|IWN_RFLAG_ANT
argument_list|(
name|txant
argument_list|)
expr_stmt|;
name|essid
operator|=
operator|(
expr|struct
name|iwn_scan_essid
operator|*
operator|)
operator|(
name|tx
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|ss_ssid
index|[
literal|0
index|]
operator|.
name|len
operator|!=
literal|0
condition|)
block|{
name|essid
index|[
literal|0
index|]
operator|.
name|id
operator|=
name|IEEE80211_ELEMID_SSID
expr_stmt|;
name|essid
index|[
literal|0
index|]
operator|.
name|len
operator|=
name|ss
operator|->
name|ss_ssid
index|[
literal|0
index|]
operator|.
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|essid
index|[
literal|0
index|]
operator|.
name|data
argument_list|,
name|ss
operator|->
name|ss_ssid
index|[
literal|0
index|]
operator|.
name|ssid
argument_list|,
name|ss
operator|->
name|ss_ssid
index|[
literal|0
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Build a probe request frame.  Most of the following code is a 	 * copy& paste of what is done in net80211. 	 */
name|wh
operator|=
operator|(
expr|struct
name|ieee80211_frame
operator|*
operator|)
operator|(
name|essid
operator|+
literal|20
operator|)
expr_stmt|;
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|=
name|IEEE80211_FC0_VERSION_0
operator||
name|IEEE80211_FC0_TYPE_MGT
operator||
name|IEEE80211_FC0_SUBTYPE_PROBE_REQ
expr_stmt|;
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_DIR_NODS
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|ifp
operator|->
name|if_broadcastaddr
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|ifp
operator|->
name|if_broadcastaddr
argument_list|)
expr_stmt|;
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|wh
operator|->
name|i_dur
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* filled by HW */
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|wh
operator|->
name|i_seq
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* filled by HW */
name|frm
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|wh
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* Add SSID IE. */
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_SSID
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|ss
operator|->
name|ss_ssid
index|[
literal|0
index|]
operator|.
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|frm
argument_list|,
name|ss
operator|->
name|ss_ssid
index|[
literal|0
index|]
operator|.
name|ssid
argument_list|,
name|ss
operator|->
name|ss_ssid
index|[
literal|0
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
name|frm
operator|+=
name|ss
operator|->
name|ss_ssid
index|[
literal|0
index|]
operator|.
name|len
expr_stmt|;
comment|/* Add supported rates IE. */
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_RATES
expr_stmt|;
name|nrates
operator|=
name|rs
operator|->
name|rs_nrates
expr_stmt|;
if|if
condition|(
name|nrates
operator|>
name|IEEE80211_RATE_SIZE
condition|)
name|nrates
operator|=
name|IEEE80211_RATE_SIZE
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|nrates
expr_stmt|;
name|memcpy
argument_list|(
name|frm
argument_list|,
name|rs
operator|->
name|rs_rates
argument_list|,
name|nrates
argument_list|)
expr_stmt|;
name|frm
operator|+=
name|nrates
expr_stmt|;
comment|/* Add supported xrates IE. */
if|if
condition|(
name|rs
operator|->
name|rs_nrates
operator|>
name|IEEE80211_RATE_SIZE
condition|)
block|{
name|nrates
operator|=
name|rs
operator|->
name|rs_nrates
operator|-
name|IEEE80211_RATE_SIZE
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_XRATES
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
operator|(
name|uint8_t
operator|)
name|nrates
expr_stmt|;
name|memcpy
argument_list|(
name|frm
argument_list|,
name|rs
operator|->
name|rs_rates
operator|+
name|IEEE80211_RATE_SIZE
argument_list|,
name|nrates
argument_list|)
expr_stmt|;
name|frm
operator|+=
name|nrates
expr_stmt|;
block|}
comment|/* Set length of probe request. */
name|tx
operator|->
name|len
operator|=
name|htole16
argument_list|(
name|frm
operator|-
operator|(
name|uint8_t
operator|*
operator|)
name|wh
argument_list|)
expr_stmt|;
name|c
operator|=
name|ic
operator|->
name|ic_curchan
expr_stmt|;
name|chan
operator|=
operator|(
expr|struct
name|iwn_scan_chan
operator|*
operator|)
name|frm
expr_stmt|;
name|chan
operator|->
name|chan
operator|=
name|htole16
argument_list|(
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|chan
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|ss_nssid
operator|>
literal|0
condition|)
name|chan
operator|->
name|flags
operator||=
name|htole32
argument_list|(
name|IWN_CHAN_NPBREQS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|chan
operator|->
name|dsp_gain
operator|=
literal|0x6e
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|c
argument_list|)
operator|&&
operator|!
operator|(
name|c
operator|->
name|ic_flags
operator|&
name|IEEE80211_CHAN_PASSIVE
operator|)
condition|)
block|{
name|chan
operator|->
name|rf_gain
operator|=
literal|0x3b
expr_stmt|;
name|chan
operator|->
name|active
operator|=
name|htole16
argument_list|(
literal|24
argument_list|)
expr_stmt|;
name|chan
operator|->
name|passive
operator|=
name|htole16
argument_list|(
literal|110
argument_list|)
expr_stmt|;
name|chan
operator|->
name|flags
operator||=
name|htole32
argument_list|(
name|IWN_CHAN_ACTIVE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|chan
operator|->
name|rf_gain
operator|=
literal|0x3b
expr_stmt|;
name|chan
operator|->
name|active
operator|=
name|htole16
argument_list|(
literal|24
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rxon
operator|.
name|associd
condition|)
name|chan
operator|->
name|passive
operator|=
name|htole16
argument_list|(
literal|78
argument_list|)
expr_stmt|;
else|else
name|chan
operator|->
name|passive
operator|=
name|htole16
argument_list|(
literal|110
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|crc_threshold
operator|=
name|htole16
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|c
operator|->
name|ic_flags
operator|&
name|IEEE80211_CHAN_PASSIVE
operator|)
condition|)
block|{
name|chan
operator|->
name|rf_gain
operator|=
literal|0x28
expr_stmt|;
name|chan
operator|->
name|active
operator|=
name|htole16
argument_list|(
literal|36
argument_list|)
expr_stmt|;
name|chan
operator|->
name|passive
operator|=
name|htole16
argument_list|(
literal|120
argument_list|)
expr_stmt|;
name|chan
operator|->
name|flags
operator||=
name|htole32
argument_list|(
name|IWN_CHAN_ACTIVE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chan
operator|->
name|rf_gain
operator|=
literal|0x28
expr_stmt|;
name|chan
operator|->
name|active
operator|=
name|htole16
argument_list|(
literal|36
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rxon
operator|.
name|associd
condition|)
name|chan
operator|->
name|passive
operator|=
name|htole16
argument_list|(
literal|88
argument_list|)
expr_stmt|;
else|else
name|chan
operator|->
name|passive
operator|=
name|htole16
argument_list|(
literal|120
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|crc_threshold
operator|=
name|htole16
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_STATE
argument_list|,
literal|"%s: chan %u flags 0x%x rf_gain 0x%x "
literal|"dsp_gain 0x%x active 0x%x passive 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|chan
argument_list|,
name|chan
operator|->
name|flags
argument_list|,
name|chan
operator|->
name|rf_gain
argument_list|,
name|chan
operator|->
name|dsp_gain
argument_list|,
name|chan
operator|->
name|active
argument_list|,
name|chan
operator|->
name|passive
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|nchan
operator|++
expr_stmt|;
name|chan
operator|++
expr_stmt|;
name|buflen
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|chan
operator|-
name|buf
expr_stmt|;
name|hdr
operator|->
name|len
operator|=
name|htole16
argument_list|(
name|buflen
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_STATE
argument_list|,
literal|"sending scan command nchan=%d\n"
argument_list|,
name|hdr
operator|->
name|nchan
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_SCAN
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|iwn_auth
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
specifier|const
name|struct
name|iwn_hal
modifier|*
name|hal
init|=
name|sc
operator|->
name|sc_hal
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|vap
operator|->
name|iv_bss
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|->
name|calib
operator|.
name|state
operator|=
name|IWN_CALIB_STATE_INIT
expr_stmt|;
comment|/* Update adapter configuration. */
name|IEEE80211_ADDR_COPY
argument_list|(
name|sc
operator|->
name|rxon
operator|.
name|bssid
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rxon
operator|.
name|chan
operator|=
name|htole16
argument_list|(
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rxon
operator|.
name|flags
operator|=
name|htole32
argument_list|(
name|IWN_RXON_TSF
operator||
name|IWN_RXON_CTS_TO_SELF
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
name|sc
operator|->
name|rxon
operator|.
name|flags
operator||=
name|htole32
argument_list|(
name|IWN_RXON_AUTO
operator||
name|IWN_RXON_24GHZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHSLOT
condition|)
name|sc
operator|->
name|rxon
operator|.
name|flags
operator||=
name|htole32
argument_list|(
name|IWN_RXON_SHSLOT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHPREAMBLE
condition|)
name|sc
operator|->
name|rxon
operator|.
name|flags
operator||=
name|htole32
argument_list|(
name|IWN_RXON_SHPREAMBLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_A
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
block|{
name|sc
operator|->
name|rxon
operator|.
name|cck_mask
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rxon
operator|.
name|ofdm_mask
operator|=
literal|0x15
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_B
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
block|{
name|sc
operator|->
name|rxon
operator|.
name|cck_mask
operator|=
literal|0x03
expr_stmt|;
name|sc
operator|->
name|rxon
operator|.
name|ofdm_mask
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX assume 802.11b/g */
name|sc
operator|->
name|rxon
operator|.
name|cck_mask
operator|=
literal|0x0f
expr_stmt|;
name|sc
operator|->
name|rxon
operator|.
name|ofdm_mask
operator|=
literal|0x15
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_STATE
argument_list|,
literal|"%s: config chan %d mode %d flags 0x%x cck 0x%x ofdm 0x%x "
literal|"ht_single 0x%x ht_dual 0x%x rxchain 0x%x "
literal|"myaddr %6D wlap %6D bssid %6D associd %d filter 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|le16toh
argument_list|(
name|sc
operator|->
name|rxon
operator|.
name|chan
argument_list|)
argument_list|,
name|sc
operator|->
name|rxon
operator|.
name|mode
argument_list|,
name|le32toh
argument_list|(
name|sc
operator|->
name|rxon
operator|.
name|flags
argument_list|)
argument_list|,
name|sc
operator|->
name|rxon
operator|.
name|cck_mask
argument_list|,
name|sc
operator|->
name|rxon
operator|.
name|ofdm_mask
argument_list|,
name|sc
operator|->
name|rxon
operator|.
name|ht_single_mask
argument_list|,
name|sc
operator|->
name|rxon
operator|.
name|ht_dual_mask
argument_list|,
name|le16toh
argument_list|(
name|sc
operator|->
name|rxon
operator|.
name|rxchain
argument_list|)
argument_list|,
name|sc
operator|->
name|rxon
operator|.
name|myaddr
argument_list|,
literal|":"
argument_list|,
name|sc
operator|->
name|rxon
operator|.
name|wlap
argument_list|,
literal|":"
argument_list|,
name|sc
operator|->
name|rxon
operator|.
name|bssid
argument_list|,
literal|":"
argument_list|,
name|le16toh
argument_list|(
name|sc
operator|->
name|rxon
operator|.
name|associd
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|sc
operator|->
name|rxon
operator|.
name|filter
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_RXON
argument_list|,
operator|&
name|sc
operator|->
name|rxon
argument_list|,
name|hal
operator|->
name|rxonsz
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: RXON command failed, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Configuration has changed, set TX power accordingly. */
name|error
operator|=
name|hal
operator|->
name|set_txpower
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not set Tx power, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 	 * Reconfiguring RXON clears the firmware nodes table so we must 	 * add the broadcast node again. 	 */
name|error
operator|=
name|iwn_add_broadcast_node
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not add broadcast node, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Configure the adapter for associated state.  */
end_comment

begin_function
name|int
name|iwn_run
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
define|#
directive|define
name|MS
parameter_list|(
name|v
parameter_list|,
name|x
parameter_list|)
value|(((v)& x)>> x##_S)
specifier|const
name|struct
name|iwn_hal
modifier|*
name|hal
init|=
name|sc
operator|->
name|sc_hal
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|vap
operator|->
name|iv_bss
decl_stmt|;
name|struct
name|iwn_node_info
name|node
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|->
name|calib
operator|.
name|state
operator|=
name|IWN_CALIB_STATE_INIT
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_MONITOR
condition|)
block|{
comment|/* Link LED blinks while monitoring. */
name|iwn_set_led
argument_list|(
name|sc
argument_list|,
name|IWN_LED_LINK
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|error
operator|=
name|iwn_set_timing
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not set timing, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Update adapter configuration. */
name|IEEE80211_ADDR_COPY
argument_list|(
name|sc
operator|->
name|rxon
operator|.
name|bssid
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rxon
operator|.
name|chan
operator|=
name|htole16
argument_list|(
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rxon
operator|.
name|associd
operator|=
name|htole16
argument_list|(
name|IEEE80211_AID
argument_list|(
name|ni
operator|->
name|ni_associd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Short preamble and slot time are negotiated when associating. */
name|sc
operator|->
name|rxon
operator|.
name|flags
operator|&=
operator|~
name|htole32
argument_list|(
name|IWN_RXON_SHPREAMBLE
operator||
name|IWN_RXON_SHSLOT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rxon
operator|.
name|flags
operator||=
name|htole32
argument_list|(
name|IWN_RXON_TSF
operator||
name|IWN_RXON_CTS_TO_SELF
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
name|sc
operator|->
name|rxon
operator|.
name|flags
operator||=
name|htole32
argument_list|(
name|IWN_RXON_AUTO
operator||
name|IWN_RXON_24GHZ
argument_list|)
expr_stmt|;
else|else
name|sc
operator|->
name|rxon
operator|.
name|flags
operator|&=
operator|~
name|htole32
argument_list|(
name|IWN_RXON_AUTO
operator||
name|IWN_RXON_24GHZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHSLOT
condition|)
name|sc
operator|->
name|rxon
operator|.
name|flags
operator||=
name|htole32
argument_list|(
name|IWN_RXON_SHSLOT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHPREAMBLE
condition|)
name|sc
operator|->
name|rxon
operator|.
name|flags
operator||=
name|htole32
argument_list|(
name|IWN_RXON_SHPREAMBLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_A
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
block|{
name|sc
operator|->
name|rxon
operator|.
name|cck_mask
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rxon
operator|.
name|ofdm_mask
operator|=
literal|0x15
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_B
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
block|{
name|sc
operator|->
name|rxon
operator|.
name|cck_mask
operator|=
literal|0x03
expr_stmt|;
name|sc
operator|->
name|rxon
operator|.
name|ofdm_mask
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX assume 802.11b/g */
name|sc
operator|->
name|rxon
operator|.
name|cck_mask
operator|=
literal|0x0f
expr_stmt|;
name|sc
operator|->
name|rxon
operator|.
name|ofdm_mask
operator|=
literal|0x15
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* HT */
block|if (IEEE80211_IS_CHAN_HT(ni->ni_chan)) { 		sc->rxon.flags&= ~htole32(IWN_RXON_HT); 		if (IEEE80211_IS_CHAN_HT40U(ni->ni_chan)) 			sc->rxon.flags |= htole32(IWN_RXON_HT40U); 		else if (IEEE80211_IS_CHAN_HT40D(ni->ni_chan)) 			sc->rxon.flags |= htole32(IWN_RXON_HT40D); 		else 			sc->rxon.flags |= htole32(IWN_RXON_HT20); 		sc->rxon.rxchain = htole16( 			  IWN_RXCHAIN_VALID(3) 			| IWN_RXCHAIN_MIMO_COUNT(3) 			| IWN_RXCHAIN_IDLE_COUNT(1) 			| IWN_RXCHAIN_MIMO_FORCE);  		maxrxampdu = MS(ni->ni_htparam, IEEE80211_HTCAP_MAXRXAMPDU); 		ampdudensity = MS(ni->ni_htparam, IEEE80211_HTCAP_MPDUDENSITY); 	} else 		maxrxampdu = ampdudensity = 0;
endif|#
directive|endif
name|sc
operator|->
name|rxon
operator|.
name|filter
operator||=
name|htole32
argument_list|(
name|IWN_FILTER_BSS
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_STATE
argument_list|,
literal|"%s: config chan %d mode %d flags 0x%x cck 0x%x ofdm 0x%x "
literal|"ht_single 0x%x ht_dual 0x%x rxchain 0x%x "
literal|"myaddr %6D wlap %6D bssid %6D associd %d filter 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|le16toh
argument_list|(
name|sc
operator|->
name|rxon
operator|.
name|chan
argument_list|)
argument_list|,
name|sc
operator|->
name|rxon
operator|.
name|mode
argument_list|,
name|le32toh
argument_list|(
name|sc
operator|->
name|rxon
operator|.
name|flags
argument_list|)
argument_list|,
name|sc
operator|->
name|rxon
operator|.
name|cck_mask
argument_list|,
name|sc
operator|->
name|rxon
operator|.
name|ofdm_mask
argument_list|,
name|sc
operator|->
name|rxon
operator|.
name|ht_single_mask
argument_list|,
name|sc
operator|->
name|rxon
operator|.
name|ht_dual_mask
argument_list|,
name|le16toh
argument_list|(
name|sc
operator|->
name|rxon
operator|.
name|rxchain
argument_list|)
argument_list|,
name|sc
operator|->
name|rxon
operator|.
name|myaddr
argument_list|,
literal|":"
argument_list|,
name|sc
operator|->
name|rxon
operator|.
name|wlap
argument_list|,
literal|":"
argument_list|,
name|sc
operator|->
name|rxon
operator|.
name|bssid
argument_list|,
literal|":"
argument_list|,
name|le16toh
argument_list|(
name|sc
operator|->
name|rxon
operator|.
name|associd
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|sc
operator|->
name|rxon
operator|.
name|filter
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_RXON
argument_list|,
operator|&
name|sc
operator|->
name|rxon
argument_list|,
name|hal
operator|->
name|rxonsz
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not update configuration, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Configuration has changed, set TX power accordingly. */
name|error
operator|=
name|hal
operator|->
name|set_txpower
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not set Tx power, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Add BSS node. */
name|memset
argument_list|(
operator|&
name|node
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|node
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|node
operator|.
name|macaddr
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|)
expr_stmt|;
name|node
operator|.
name|id
operator|=
name|IWN_ID_BSS
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|node
operator|.
name|htflags
operator|=
name|htole32
argument_list|(
name|IWN_AMDPU_SIZE_FACTOR
argument_list|(
literal|3
argument_list|)
operator||
name|IWN_AMDPU_DENSITY
argument_list|(
literal|5
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 2us */
endif|#
directive|endif
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_STATE
argument_list|,
literal|"%s: add BSS node, id %d htflags 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|node
operator|.
name|id
argument_list|,
name|le32toh
argument_list|(
name|node
operator|.
name|htflags
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|hal
operator|->
name|add_node
argument_list|(
name|sc
argument_list|,
operator|&
name|node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not add BSS node\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_STATE
argument_list|,
literal|"setting link quality for node %d\n"
argument_list|,
name|node
operator|.
name|id
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_set_link_quality
argument_list|(
name|sc
argument_list|,
name|node
operator|.
name|id
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not setup MRR for node %d, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|node
operator|.
name|id
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|iwn_init_sensitivity
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not set sensitivity, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Start periodic calibration timer. */
name|sc
operator|->
name|calib
operator|.
name|state
operator|=
name|IWN_CALIB_STATE_ASSOC
expr_stmt|;
name|iwn_calib_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Link LED always on while associated. */
name|iwn_set_led
argument_list|(
name|sc
argument_list|,
name|IWN_LED_LINK
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
undef|#
directive|undef
name|MS
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* HT */
end_comment

begin_comment
comment|/*  * This function is called by upper layer when an ADDBA request is received  * from another STA and before the ADDBA response is sent.  */
end_comment

begin_comment
unit|int iwn_ampdu_rx_start(struct ieee80211com *ic, struct ieee80211_node *ni,     uint8_t tid) { 	struct ieee80211_rx_ba *ba =&ni->ni_rx_ba[tid]; 	struct iwn_softc *sc = ic->ic_softc; 	struct iwn_node *wn = (void *)ni; 	struct iwn_node_info node;  	memset(&node, 0, sizeof node); 	node.id = wn->id; 	node.control = IWN_NODE_UPDATE; 	node.flags = IWN_FLAG_SET_ADDBA; 	node.addba_tid = tid; 	node.addba_ssn = htole16(ba->ba_winstart); 	DPRINTF(sc, IWN_DEBUG_RECV, "ADDBA RA=%d TID=%d SSN=%d\n", 	    wn->id, tid, ba->ba_winstart)); 	return sc->sc_hal->add_node(sc,&node, 1); }
comment|/*  * This function is called by upper layer on teardown of an HT-immediate  * Block Ack agreement (eg. uppon receipt of a DELBA frame.)  */
end_comment

begin_comment
unit|void iwn_ampdu_rx_stop(struct ieee80211com *ic, struct ieee80211_node *ni,     uint8_t tid) { 	struct iwn_softc *sc = ic->ic_softc; 	struct iwn_node *wn = (void *)ni; 	struct iwn_node_info node;  	memset(&node, 0, sizeof node); 	node.id = wn->id; 	node.control = IWN_NODE_UPDATE; 	node.flags = IWN_FLAG_SET_DELBA; 	node.delba_tid = tid; 	DPRINTF(sc, IWN_DEBUG_RECV, "DELBA RA=%d TID=%d\n", wn->id, tid); 	(void)sc->sc_hal->add_node(sc,&node, 1); }
comment|/*  * This function is called by upper layer when an ADDBA response is received  * from another STA.  */
end_comment

begin_comment
unit|int iwn_ampdu_tx_start(struct ieee80211com *ic, struct ieee80211_node *ni,     uint8_t tid) { 	struct ieee80211_tx_ba *ba =&ni->ni_tx_ba[tid]; 	struct iwn_softc *sc = ic->ic_softc; 	const struct iwn_hal *hal = sc->sc_hal; 	struct iwn_node *wn = (void *)ni; 	struct iwn_node_info node; 	int error;
comment|/* Enable TX for the specified RA/TID. */
end_comment

begin_comment
unit|wn->disable_tid&= ~(1<< tid); 	memset(&node, 0, sizeof node); 	node.id = wn->id; 	node.control = IWN_NODE_UPDATE; 	node.flags = IWN_FLAG_SET_DISABLE_TID; 	node.disable_tid = htole16(wn->disable_tid); 	error = hal->add_node(sc,&node, 1); 	if (error != 0) 		return error;  	if ((error = iwn_nic_lock(sc)) != 0) 		return error; 	hal->ampdu_tx_start(sc, ni, tid, ba->ba_winstart); 	iwn_nic_unlock(sc); 	return 0; }  void iwn_ampdu_tx_stop(struct ieee80211com *ic, struct ieee80211_node *ni,     uint8_t tid) { 	struct ieee80211_tx_ba *ba =&ni->ni_tx_ba[tid]; 	struct iwn_softc *sc = ic->ic_softc; 	int error;  	error = iwn_nic_lock(sc); 	if (error != 0) 		return; 	sc->sc_hal->ampdu_tx_stop(sc, tid, ba->ba_winstart); 	iwn_nic_unlock(sc); }  void iwn4965_ampdu_tx_start(struct iwn_softc *sc, struct ieee80211_node *ni,     uint8_t tid, uint16_t ssn) { 	struct iwn_node *wn = (void *)ni; 	int qid = 7 + tid;
comment|/* Stop TX scheduler while we're changing its configuration. */
end_comment

begin_comment
unit|iwn_prph_write(sc, IWN4965_SCHED_QUEUE_STATUS(qid), 	    IWN4965_TXQ_STATUS_CHGACT);
comment|/* Assign RA/TID translation to the queue. */
end_comment

begin_comment
unit|iwn_mem_write_2(sc, sc->sched_base + IWN4965_SCHED_TRANS_TBL(qid), 	    wn->id<< 4 | tid);
comment|/* Enable chain-building mode for the queue. */
end_comment

begin_comment
unit|iwn_prph_setbits(sc, IWN4965_SCHED_QCHAIN_SEL, 1<< qid);
comment|/* Set starting sequence number from the ADDBA request. */
end_comment

begin_comment
unit|IWN_WRITE(sc, IWN_HBUS_TARG_WRPTR, qid<< 8 | (ssn& 0xff)); 	iwn_prph_write(sc, IWN4965_SCHED_QUEUE_RDPTR(qid), ssn);
comment|/* Set scheduler window size. */
end_comment

begin_comment
unit|iwn_mem_write(sc, sc->sched_base + IWN4965_SCHED_QUEUE_OFFSET(qid), 	    IWN_SCHED_WINSZ);
comment|/* Set scheduler frame limit. */
end_comment

begin_comment
unit|iwn_mem_write(sc, sc->sched_base + IWN4965_SCHED_QUEUE_OFFSET(qid) + 4, 	    IWN_SCHED_LIMIT<< 16);
comment|/* Enable interrupts for the queue. */
end_comment

begin_comment
unit|iwn_prph_setbits(sc, IWN4965_SCHED_INTR_MASK, 1<< qid);
comment|/* Mark the queue as active. */
end_comment

begin_comment
unit|iwn_prph_write(sc, IWN4965_SCHED_QUEUE_STATUS(qid), 	    IWN4965_TXQ_STATUS_ACTIVE | IWN4965_TXQ_STATUS_AGGR_ENA | 	    iwn_tid2fifo[tid]<< 1); }  void iwn4965_ampdu_tx_stop(struct iwn_softc *sc, uint8_t tid, uint16_t ssn) { 	int qid = 7 + tid;
comment|/* Stop TX scheduler while we're changing its configuration. */
end_comment

begin_comment
unit|iwn_prph_write(sc, IWN4965_SCHED_QUEUE_STATUS(qid), 	    IWN4965_TXQ_STATUS_CHGACT);
comment|/* Set starting sequence number from the ADDBA request. */
end_comment

begin_comment
unit|IWN_WRITE(sc, IWN_HBUS_TARG_WRPTR, qid<< 8 | (ssn& 0xff)); 	iwn_prph_write(sc, IWN4965_SCHED_QUEUE_RDPTR(qid), ssn);
comment|/* Disable interrupts for the queue. */
end_comment

begin_comment
unit|iwn_prph_clrbits(sc, IWN4965_SCHED_INTR_MASK, 1<< qid);
comment|/* Mark the queue as inactive. */
end_comment

begin_comment
unit|iwn_prph_write(sc, IWN4965_SCHED_QUEUE_STATUS(qid), 	    IWN4965_TXQ_STATUS_INACTIVE | iwn_tid2fifo[tid]<< 1); }  void iwn5000_ampdu_tx_start(struct iwn_softc *sc, struct ieee80211_node *ni,     uint8_t tid, uint16_t ssn) { 	struct iwn_node *wn = (void *)ni; 	int qid = 10 + tid;
comment|/* Stop TX scheduler while we're changing its configuration. */
end_comment

begin_comment
unit|iwn_prph_write(sc, IWN5000_SCHED_QUEUE_STATUS(qid), 	    IWN5000_TXQ_STATUS_CHGACT);
comment|/* Assign RA/TID translation to the queue. */
end_comment

begin_comment
unit|iwn_mem_write_2(sc, sc->sched_base + IWN5000_SCHED_TRANS_TBL(qid), 	    wn->id<< 4 | tid);
comment|/* Enable chain-building mode for the queue. */
end_comment

begin_comment
unit|iwn_prph_setbits(sc, IWN5000_SCHED_QCHAIN_SEL, 1<< qid);
comment|/* Enable aggregation for the queue. */
end_comment

begin_comment
unit|iwn_prph_setbits(sc, IWN5000_SCHED_AGGR_SEL, 1<< qid);
comment|/* Set starting sequence number from the ADDBA request. */
end_comment

begin_comment
unit|IWN_WRITE(sc, IWN_HBUS_TARG_WRPTR, qid<< 8 | (ssn& 0xff)); 	iwn_prph_write(sc, IWN5000_SCHED_QUEUE_RDPTR(qid), ssn);
comment|/* Set scheduler window size and frame limit. */
end_comment

begin_comment
unit|iwn_mem_write(sc, sc->sched_base + IWN5000_SCHED_QUEUE_OFFSET(qid) + 4, 	    IWN_SCHED_LIMIT<< 16 | IWN_SCHED_WINSZ);
comment|/* Enable interrupts for the queue. */
end_comment

begin_comment
unit|iwn_prph_setbits(sc, IWN5000_SCHED_INTR_MASK, 1<< qid);
comment|/* Mark the queue as active. */
end_comment

begin_comment
unit|iwn_prph_write(sc, IWN5000_SCHED_QUEUE_STATUS(qid), 	    IWN5000_TXQ_STATUS_ACTIVE | iwn_tid2fifo[tid]); }  void iwn5000_ampdu_tx_stop(struct iwn_softc *sc, uint8_t tid, uint16_t ssn) { 	int qid = 10 + tid;
comment|/* Stop TX scheduler while we're changing its configuration. */
end_comment

begin_comment
unit|iwn_prph_write(sc, IWN5000_SCHED_QUEUE_STATUS(qid), 	    IWN5000_TXQ_STATUS_CHGACT);
comment|/* Disable aggregation for the queue. */
end_comment

begin_comment
unit|iwn_prph_clrbits(sc, IWN5000_SCHED_AGGR_SEL, 1<< qid);
comment|/* Set starting sequence number from the ADDBA request. */
end_comment

begin_comment
unit|IWN_WRITE(sc, IWN_HBUS_TARG_WRPTR, qid<< 8 | (ssn& 0xff)); 	iwn_prph_write(sc, IWN5000_SCHED_QUEUE_RDPTR(qid), ssn);
comment|/* Disable interrupts for the queue. */
end_comment

begin_comment
unit|iwn_prph_clrbits(sc, IWN5000_SCHED_INTR_MASK, 1<< qid);
comment|/* Mark the queue as inactive. */
end_comment

begin_endif
unit|iwn_prph_write(sc, IWN5000_SCHED_QUEUE_STATUS(qid), 	    IWN5000_TXQ_STATUS_INACTIVE | iwn_tid2fifo[tid]); }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Query calibration tables from the initialization firmware.  We do this  * only once at first boot.  Called from a process context.  */
end_comment

begin_function
name|int
name|iwn5000_query_calibration
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwn5000_calib_config
name|cmd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|ucode
operator|.
name|once
operator|.
name|enable
operator|=
literal|0xffffffff
expr_stmt|;
name|cmd
operator|.
name|ucode
operator|.
name|once
operator|.
name|start
operator|=
literal|0xffffffff
expr_stmt|;
name|cmd
operator|.
name|ucode
operator|.
name|once
operator|.
name|send
operator|=
literal|0xffffffff
expr_stmt|;
name|cmd
operator|.
name|ucode
operator|.
name|flags
operator|=
literal|0xffffffff
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s: sending calibration query\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN5000_CMD_CALIB_CONFIG
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
name|cmd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/* Wait at most two seconds for calibration to complete. */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWN_FLAG_CALIB_DONE
operator|)
condition|)
name|error
operator|=
name|msleep
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|PCATCH
argument_list|,
literal|"iwninit"
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Send calibration results to the runtime firmware.  These results were  * obtained on first boot from the initialization firmware.  */
end_comment

begin_function
name|int
name|iwn5000_send_calibration
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|idx
decl_stmt|,
name|error
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
literal|5
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|calibcmd
index|[
name|idx
index|]
operator|.
name|buf
operator|==
name|NULL
condition|)
continue|continue;
comment|/* No results available. */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"send calibration result idx=%d len=%d\n"
argument_list|,
name|idx
argument_list|,
name|sc
operator|->
name|calibcmd
index|[
name|idx
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_PHY_CALIB
argument_list|,
name|sc
operator|->
name|calibcmd
index|[
name|idx
index|]
operator|.
name|buf
argument_list|,
name|sc
operator|->
name|calibcmd
index|[
name|idx
index|]
operator|.
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not send calibration result, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|iwn5000_send_wimax_coex
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwn5000_wimax_coex
name|wimax
decl_stmt|;
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
name|sc
operator|->
name|hw_type
operator|==
name|IWN_HW_REV_TYPE_6050
condition|)
block|{
comment|/* Enable WiMAX coexistence for combo adapters. */
name|wimax
operator|.
name|flags
operator|=
name|IWN_WIMAX_COEX_ASSOC_WA_UNMASK
operator||
name|IWN_WIMAX_COEX_UNASSOC_WA_UNMASK
operator||
name|IWN_WIMAX_COEX_STA_TABLE_VALID
operator||
name|IWN_WIMAX_COEX_ENABLE
expr_stmt|;
name|memcpy
argument_list|(
name|wimax
operator|.
name|events
argument_list|,
name|iwn6050_wimax_events
argument_list|,
sizeof|sizeof
name|iwn6050_wimax_events
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
comment|/* Disable WiMAX coexistence. */
name|wimax
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|wimax
operator|.
name|events
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|wimax
operator|.
name|events
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"%s: Configuring WiMAX coexistence\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN5000_CMD_WIMAX_COEX
argument_list|,
operator|&
name|wimax
argument_list|,
sizeof|sizeof
name|wimax
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function is called after the runtime firmware notifies us of its  * readiness (called in a process context.)  */
end_comment

begin_function
name|int
name|iwn4965_post_alive
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|qid
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_nic_lock
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/* Clear TX scheduler state in SRAM. */
name|sc
operator|->
name|sched_base
operator|=
name|iwn_prph_read
argument_list|(
name|sc
argument_list|,
name|IWN_SCHED_SRAM_ADDR
argument_list|)
expr_stmt|;
name|iwn_mem_set_region_4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sched_base
operator|+
name|IWN4965_SCHED_CTX_OFF
argument_list|,
literal|0
argument_list|,
name|IWN4965_SCHED_CTX_LEN
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set physical address of TX scheduler rings (1KB aligned.) */
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN4965_SCHED_DRAM_ADDR
argument_list|,
name|sc
operator|->
name|sched_dma
operator|.
name|paddr
operator|>>
literal|10
argument_list|)
expr_stmt|;
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_FH_TX_CHICKEN
argument_list|,
name|IWN_FH_TX_CHICKEN_SCHED_RETRY
argument_list|)
expr_stmt|;
comment|/* Disable chain mode for all our 16 queues. */
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN4965_SCHED_QCHAIN_SEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|qid
operator|=
literal|0
init|;
name|qid
operator|<
name|IWN4965_NTXQUEUES
condition|;
name|qid
operator|++
control|)
block|{
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN4965_SCHED_QUEUE_RDPTR
argument_list|(
name|qid
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_HBUS_TARG_WRPTR
argument_list|,
name|qid
operator|<<
literal|8
operator||
literal|0
argument_list|)
expr_stmt|;
comment|/* Set scheduler window size. */
name|iwn_mem_write
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sched_base
operator|+
name|IWN4965_SCHED_QUEUE_OFFSET
argument_list|(
name|qid
argument_list|)
argument_list|,
name|IWN_SCHED_WINSZ
argument_list|)
expr_stmt|;
comment|/* Set scheduler frame limit. */
name|iwn_mem_write
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sched_base
operator|+
name|IWN4965_SCHED_QUEUE_OFFSET
argument_list|(
name|qid
argument_list|)
operator|+
literal|4
argument_list|,
name|IWN_SCHED_LIMIT
operator|<<
literal|16
argument_list|)
expr_stmt|;
block|}
comment|/* Enable interrupts for all our 16 queues. */
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN4965_SCHED_INTR_MASK
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
comment|/* Identify TX FIFO rings (0-7). */
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN4965_SCHED_TXFACT
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Mark TX rings (4 EDCA + cmd + 2 HCCA) as active. */
for|for
control|(
name|qid
operator|=
literal|0
init|;
name|qid
operator|<
literal|7
condition|;
name|qid
operator|++
control|)
block|{
specifier|static
name|uint8_t
name|qid2fifo
index|[]
init|=
block|{
literal|3
block|,
literal|2
block|,
literal|1
block|,
literal|0
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|}
decl_stmt|;
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN4965_SCHED_QUEUE_STATUS
argument_list|(
name|qid
argument_list|)
argument_list|,
name|IWN4965_TXQ_STATUS_ACTIVE
operator||
name|qid2fifo
index|[
name|qid
index|]
operator|<<
literal|1
argument_list|)
expr_stmt|;
block|}
name|iwn_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * This function is called after the initialization or runtime firmware  * notifies us of its readiness (called in a process context.)  */
end_comment

begin_function
name|int
name|iwn5000_post_alive
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|qid
decl_stmt|;
comment|/* Switch to using ICT interrupt mode. */
name|iwn5000_ict_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_nic_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/* Clear TX scheduler state in SRAM. */
name|sc
operator|->
name|sched_base
operator|=
name|iwn_prph_read
argument_list|(
name|sc
argument_list|,
name|IWN_SCHED_SRAM_ADDR
argument_list|)
expr_stmt|;
name|iwn_mem_set_region_4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sched_base
operator|+
name|IWN5000_SCHED_CTX_OFF
argument_list|,
literal|0
argument_list|,
name|IWN5000_SCHED_CTX_LEN
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set physical address of TX scheduler rings (1KB aligned.) */
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN5000_SCHED_DRAM_ADDR
argument_list|,
name|sc
operator|->
name|sched_dma
operator|.
name|paddr
operator|>>
literal|10
argument_list|)
expr_stmt|;
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_FH_TX_CHICKEN
argument_list|,
name|IWN_FH_TX_CHICKEN_SCHED_RETRY
argument_list|)
expr_stmt|;
comment|/* Enable chain mode for all queues, except command queue. */
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN5000_SCHED_QCHAIN_SEL
argument_list|,
literal|0xfffef
argument_list|)
expr_stmt|;
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN5000_SCHED_AGGR_SEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|qid
operator|=
literal|0
init|;
name|qid
operator|<
name|IWN5000_NTXQUEUES
condition|;
name|qid
operator|++
control|)
block|{
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN5000_SCHED_QUEUE_RDPTR
argument_list|(
name|qid
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_HBUS_TARG_WRPTR
argument_list|,
name|qid
operator|<<
literal|8
operator||
literal|0
argument_list|)
expr_stmt|;
name|iwn_mem_write
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sched_base
operator|+
name|IWN5000_SCHED_QUEUE_OFFSET
argument_list|(
name|qid
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set scheduler window size and frame limit. */
name|iwn_mem_write
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sched_base
operator|+
name|IWN5000_SCHED_QUEUE_OFFSET
argument_list|(
name|qid
argument_list|)
operator|+
literal|4
argument_list|,
name|IWN_SCHED_LIMIT
operator|<<
literal|16
operator||
name|IWN_SCHED_WINSZ
argument_list|)
expr_stmt|;
block|}
comment|/* Enable interrupts for all our 20 queues. */
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN5000_SCHED_INTR_MASK
argument_list|,
literal|0xfffff
argument_list|)
expr_stmt|;
comment|/* Identify TX FIFO rings (0-7). */
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN5000_SCHED_TXFACT
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Mark TX rings (4 EDCA + cmd + 2 HCCA) as active. */
for|for
control|(
name|qid
operator|=
literal|0
init|;
name|qid
operator|<
literal|7
condition|;
name|qid
operator|++
control|)
block|{
specifier|static
name|uint8_t
name|qid2fifo
index|[]
init|=
block|{
literal|3
block|,
literal|2
block|,
literal|1
block|,
literal|0
block|,
literal|7
block|,
literal|5
block|,
literal|6
block|}
decl_stmt|;
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN5000_SCHED_QUEUE_STATUS
argument_list|(
name|qid
argument_list|)
argument_list|,
name|IWN5000_TXQ_STATUS_ACTIVE
operator||
name|qid2fifo
index|[
name|qid
index|]
argument_list|)
expr_stmt|;
block|}
name|iwn_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Configure WiMAX coexistence for combo adapters. */
name|error
operator|=
name|iwn5000_send_wimax_coex
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not configure WiMAX coexistence, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|hw_type
operator|!=
name|IWN_HW_REV_TYPE_5150
condition|)
block|{
name|struct
name|iwn5000_phy_calib_crystal
name|cmd
decl_stmt|;
comment|/* Perform crystal calibration. */
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|code
operator|=
name|IWN5000_PHY_CALIB_CRYSTAL
expr_stmt|;
name|cmd
operator|.
name|ngroups
operator|=
literal|1
expr_stmt|;
name|cmd
operator|.
name|isvalid
operator|=
literal|1
expr_stmt|;
name|cmd
operator|.
name|cap_pin
index|[
literal|0
index|]
operator|=
name|le32toh
argument_list|(
name|sc
operator|->
name|eeprom_crystal
argument_list|)
operator|&
literal|0xff
expr_stmt|;
name|cmd
operator|.
name|cap_pin
index|[
literal|1
index|]
operator|=
operator|(
name|le32toh
argument_list|(
name|sc
operator|->
name|eeprom_crystal
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"sending crystal calibration %d, %d\n"
argument_list|,
name|cmd
operator|.
name|cap_pin
index|[
literal|0
index|]
argument_list|,
name|cmd
operator|.
name|cap_pin
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_PHY_CALIB
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
name|cmd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: crystal calibration failed, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWN_FLAG_CALIB_DONE
operator|)
condition|)
block|{
comment|/* Query calibration from the initialization firmware. */
name|error
operator|=
name|iwn5000_query_calibration
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not query calibration, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 		 * We have the calibration results now, reboot with the 		 * runtime firmware (call ourselves recursively!) 		 */
name|iwn_hw_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_hw_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Send calibration results to runtime firmware. */
name|error
operator|=
name|iwn5000_send_calibration
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * The firmware boot code is small and is intended to be copied directly into  * the NIC internal memory (no DMA transfer.)  */
end_comment

begin_function
name|int
name|iwn4965_load_bootcode
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|ucode
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|ntries
decl_stmt|;
name|size
operator|/=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_nic_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/* Copy microcode image into NIC memory. */
name|iwn_prph_write_region_4
argument_list|(
name|sc
argument_list|,
name|IWN_BSM_SRAM_BASE
argument_list|,
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|ucode
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN_BSM_WR_MEM_SRC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN_BSM_WR_MEM_DST
argument_list|,
name|IWN_FW_TEXT_BASE
argument_list|)
expr_stmt|;
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN_BSM_WR_DWCOUNT
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Start boot load now. */
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN_BSM_WR_CTRL
argument_list|,
name|IWN_BSM_WR_CTRL_START
argument_list|)
expr_stmt|;
comment|/* Wait for transfer to complete. */
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|1000
condition|;
name|ntries
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|iwn_prph_read
argument_list|(
name|sc
argument_list|,
name|IWN_BSM_WR_CTRL
argument_list|)
operator|&
name|IWN_BSM_WR_CTRL_START
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ntries
operator|==
literal|1000
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not load boot firmware\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|iwn_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|ETIMEDOUT
return|;
block|}
comment|/* Enable boot after power up. */
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN_BSM_WR_CTRL
argument_list|,
name|IWN_BSM_WR_CTRL_START_EN
argument_list|)
expr_stmt|;
name|iwn_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|iwn4965_load_firmware
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwn_fw_info
modifier|*
name|fw
init|=
operator|&
name|sc
operator|->
name|fw
decl_stmt|;
name|struct
name|iwn_dma_info
modifier|*
name|dma
init|=
operator|&
name|sc
operator|->
name|fw_dma
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Copy initialization sections into pre-allocated DMA-safe memory. */
name|memcpy
argument_list|(
name|dma
operator|->
name|vaddr
argument_list|,
name|fw
operator|->
name|init
operator|.
name|data
argument_list|,
name|fw
operator|->
name|init
operator|.
name|datasz
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|fw_dma
operator|.
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dma
operator|->
name|vaddr
operator|+
name|IWN4965_FW_DATA_MAXSZ
argument_list|,
name|fw
operator|->
name|init
operator|.
name|text
argument_list|,
name|fw
operator|->
name|init
operator|.
name|textsz
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|fw_dma
operator|.
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Tell adapter where to find initialization sections. */
name|error
operator|=
name|iwn_nic_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN_BSM_DRAM_DATA_ADDR
argument_list|,
name|dma
operator|->
name|paddr
operator|>>
literal|4
argument_list|)
expr_stmt|;
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN_BSM_DRAM_DATA_SIZE
argument_list|,
name|fw
operator|->
name|init
operator|.
name|datasz
argument_list|)
expr_stmt|;
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN_BSM_DRAM_TEXT_ADDR
argument_list|,
operator|(
name|dma
operator|->
name|paddr
operator|+
name|IWN4965_FW_DATA_MAXSZ
operator|)
operator|>>
literal|4
argument_list|)
expr_stmt|;
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN_BSM_DRAM_TEXT_SIZE
argument_list|,
name|fw
operator|->
name|init
operator|.
name|textsz
argument_list|)
expr_stmt|;
name|iwn_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Load firmware boot code. */
name|error
operator|=
name|iwn4965_load_bootcode
argument_list|(
name|sc
argument_list|,
name|fw
operator|->
name|boot
operator|.
name|text
argument_list|,
name|fw
operator|->
name|boot
operator|.
name|textsz
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not load boot firmware\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Now press "execute". */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_RESET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Wait at most one second for first alive notification. */
name|error
operator|=
name|msleep
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|PCATCH
argument_list|,
literal|"iwninit"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: timeout waiting for adapter to initialize, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Retrieve current temperature for initial TX power calibration. */
name|sc
operator|->
name|rawtemp
operator|=
name|sc
operator|->
name|ucode_info
operator|.
name|temp
index|[
literal|3
index|]
operator|.
name|chan20MHz
expr_stmt|;
name|sc
operator|->
name|temp
operator|=
name|iwn4965_get_temperature
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Copy runtime sections into pre-allocated DMA-safe memory. */
name|memcpy
argument_list|(
name|dma
operator|->
name|vaddr
argument_list|,
name|fw
operator|->
expr|main
operator|.
name|data
argument_list|,
name|fw
operator|->
expr|main
operator|.
name|datasz
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|fw_dma
operator|.
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dma
operator|->
name|vaddr
operator|+
name|IWN4965_FW_DATA_MAXSZ
argument_list|,
name|fw
operator|->
expr|main
operator|.
name|text
argument_list|,
name|fw
operator|->
expr|main
operator|.
name|textsz
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|fw_dma
operator|.
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Tell adapter where to find runtime sections. */
name|error
operator|=
name|iwn_nic_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN_BSM_DRAM_DATA_ADDR
argument_list|,
name|dma
operator|->
name|paddr
operator|>>
literal|4
argument_list|)
expr_stmt|;
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN_BSM_DRAM_DATA_SIZE
argument_list|,
name|fw
operator|->
expr|main
operator|.
name|datasz
argument_list|)
expr_stmt|;
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN_BSM_DRAM_TEXT_ADDR
argument_list|,
operator|(
name|dma
operator|->
name|paddr
operator|+
name|IWN4965_FW_DATA_MAXSZ
operator|)
operator|>>
literal|4
argument_list|)
expr_stmt|;
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN_BSM_DRAM_TEXT_SIZE
argument_list|,
name|IWN_FW_UPDATED
operator||
name|fw
operator|->
expr|main
operator|.
name|textsz
argument_list|)
expr_stmt|;
name|iwn_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|iwn5000_load_firmware_section
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|dst
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|section
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|struct
name|iwn_dma_info
modifier|*
name|dma
init|=
operator|&
name|sc
operator|->
name|fw_dma
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Copy firmware section into pre-allocated DMA-safe memory. */
name|memcpy
argument_list|(
name|dma
operator|->
name|vaddr
argument_list|,
name|section
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|fw_dma
operator|.
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_nic_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_TX_CONFIG
argument_list|(
name|IWN_SRVC_DMACHNL
argument_list|)
argument_list|,
name|IWN_FH_TX_CONFIG_DMA_PAUSE
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_SRAM_ADDR
argument_list|(
name|IWN_SRVC_DMACHNL
argument_list|)
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_TFBD_CTRL0
argument_list|(
name|IWN_SRVC_DMACHNL
argument_list|)
argument_list|,
name|IWN_LOADDR
argument_list|(
name|dma
operator|->
name|paddr
argument_list|)
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_TFBD_CTRL1
argument_list|(
name|IWN_SRVC_DMACHNL
argument_list|)
argument_list|,
name|IWN_HIADDR
argument_list|(
name|dma
operator|->
name|paddr
argument_list|)
operator|<<
literal|28
operator||
name|size
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_TXBUF_STATUS
argument_list|(
name|IWN_SRVC_DMACHNL
argument_list|)
argument_list|,
name|IWN_FH_TXBUF_STATUS_TBNUM
argument_list|(
literal|1
argument_list|)
operator||
name|IWN_FH_TXBUF_STATUS_TBIDX
argument_list|(
literal|1
argument_list|)
operator||
name|IWN_FH_TXBUF_STATUS_TFBD_VALID
argument_list|)
expr_stmt|;
comment|/* Kick Flow Handler to start DMA transfer. */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_TX_CONFIG
argument_list|(
name|IWN_SRVC_DMACHNL
argument_list|)
argument_list|,
name|IWN_FH_TX_CONFIG_DMA_ENA
operator||
name|IWN_FH_TX_CONFIG_CIRQ_HOST_ENDTFD
argument_list|)
expr_stmt|;
name|iwn_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Wait at most five seconds for FH DMA transfer to complete. */
return|return
name|msleep
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|PCATCH
argument_list|,
literal|"iwninit"
argument_list|,
name|hz
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|iwn5000_load_firmware
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwn_fw_part
modifier|*
name|fw
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Load the initialization firmware on first boot only. */
name|fw
operator|=
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWN_FLAG_CALIB_DONE
operator|)
condition|?
operator|&
name|sc
operator|->
name|fw
operator|.
expr|main
else|:
operator|&
name|sc
operator|->
name|fw
operator|.
name|init
expr_stmt|;
name|error
operator|=
name|iwn5000_load_firmware_section
argument_list|(
name|sc
argument_list|,
name|IWN_FW_TEXT_BASE
argument_list|,
name|fw
operator|->
name|text
argument_list|,
name|fw
operator|->
name|textsz
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not load firmware %s section, error %d\n"
argument_list|,
name|__func__
argument_list|,
literal|".text"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|iwn5000_load_firmware_section
argument_list|(
name|sc
argument_list|,
name|IWN_FW_DATA_BASE
argument_list|,
name|fw
operator|->
name|data
argument_list|,
name|fw
operator|->
name|datasz
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not load firmware %s section, error %d\n"
argument_list|,
name|__func__
argument_list|,
literal|".data"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Now press "execute". */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_RESET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|iwn_read_firmware
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|struct
name|iwn_hal
modifier|*
name|hal
init|=
name|sc
operator|->
name|sc_hal
decl_stmt|;
name|struct
name|iwn_fw_info
modifier|*
name|fw
init|=
operator|&
name|sc
operator|->
name|fw
decl_stmt|;
specifier|const
name|uint32_t
modifier|*
name|ptr
decl_stmt|;
name|uint32_t
name|rev
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Read firmware image from filesystem. */
name|sc
operator|->
name|fw_fp
operator|=
name|firmware_get
argument_list|(
name|sc
operator|->
name|fwname
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|fw_fp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not load firmare image \"%s\"\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|fwname
argument_list|)
expr_stmt|;
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|size
operator|=
name|sc
operator|->
name|fw_fp
operator|->
name|datasize
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|28
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: truncated firmware header: %zu bytes\n"
argument_list|,
name|__func__
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* Process firmware header. */
name|ptr
operator|=
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|sc
operator|->
name|fw_fp
operator|->
name|data
expr_stmt|;
name|rev
operator|=
name|le32toh
argument_list|(
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
comment|/* Check firmware API version. */
if|if
condition|(
name|IWN_FW_API
argument_list|(
name|rev
argument_list|)
operator|<=
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: bad firmware, need API version>=2\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|IWN_FW_API
argument_list|(
name|rev
argument_list|)
operator|>=
literal|3
condition|)
block|{
comment|/* Skip build number (version 2 header). */
name|size
operator|-=
literal|4
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
block|}
name|fw
operator|->
expr|main
operator|.
name|textsz
operator|=
name|le32toh
argument_list|(
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
name|fw
operator|->
expr|main
operator|.
name|datasz
operator|=
name|le32toh
argument_list|(
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
name|fw
operator|->
name|init
operator|.
name|textsz
operator|=
name|le32toh
argument_list|(
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
name|fw
operator|->
name|init
operator|.
name|datasz
operator|=
name|le32toh
argument_list|(
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
name|fw
operator|->
name|boot
operator|.
name|textsz
operator|=
name|le32toh
argument_list|(
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
name|size
operator|-=
literal|24
expr_stmt|;
comment|/* Sanity-check firmware header. */
if|if
condition|(
name|fw
operator|->
expr|main
operator|.
name|textsz
operator|>
name|hal
operator|->
name|fw_text_maxsz
operator|||
name|fw
operator|->
expr|main
operator|.
name|datasz
operator|>
name|hal
operator|->
name|fw_data_maxsz
operator|||
name|fw
operator|->
name|init
operator|.
name|textsz
operator|>
name|hal
operator|->
name|fw_text_maxsz
operator|||
name|fw
operator|->
name|init
operator|.
name|datasz
operator|>
name|hal
operator|->
name|fw_data_maxsz
operator|||
name|fw
operator|->
name|boot
operator|.
name|textsz
operator|>
name|IWN_FW_BOOT_TEXT_MAXSZ
operator|||
operator|(
name|fw
operator|->
name|boot
operator|.
name|textsz
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: invalid firmware header\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* Check that all firmware sections fit. */
if|if
condition|(
name|fw
operator|->
expr|main
operator|.
name|textsz
operator|+
name|fw
operator|->
expr|main
operator|.
name|datasz
operator|+
name|fw
operator|->
name|init
operator|.
name|textsz
operator|+
name|fw
operator|->
name|init
operator|.
name|datasz
operator|+
name|fw
operator|->
name|boot
operator|.
name|textsz
operator|>
name|size
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: firmware file too short: %zu bytes\n"
argument_list|,
name|__func__
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* Get pointers to firmware sections. */
name|fw
operator|->
expr|main
operator|.
name|text
operator|=
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|ptr
expr_stmt|;
name|fw
operator|->
expr|main
operator|.
name|data
operator|=
name|fw
operator|->
expr|main
operator|.
name|text
operator|+
name|fw
operator|->
expr|main
operator|.
name|textsz
expr_stmt|;
name|fw
operator|->
name|init
operator|.
name|text
operator|=
name|fw
operator|->
expr|main
operator|.
name|data
operator|+
name|fw
operator|->
expr|main
operator|.
name|datasz
expr_stmt|;
name|fw
operator|->
name|init
operator|.
name|data
operator|=
name|fw
operator|->
name|init
operator|.
name|text
operator|+
name|fw
operator|->
name|init
operator|.
name|textsz
expr_stmt|;
name|fw
operator|->
name|boot
operator|.
name|text
operator|=
name|fw
operator|->
name|init
operator|.
name|data
operator|+
name|fw
operator|->
name|init
operator|.
name|datasz
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|iwn_clock_wait
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|ntries
decl_stmt|;
comment|/* Set "initialization complete" bit. */
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_GP_CNTRL
argument_list|,
name|IWN_GP_CNTRL_INIT_DONE
argument_list|)
expr_stmt|;
comment|/* Wait for clock stabilization. */
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|2500
condition|;
name|ntries
operator|++
control|)
block|{
if|if
condition|(
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_GP_CNTRL
argument_list|)
operator|&
name|IWN_GP_CNTRL_MAC_CLOCK_READY
condition|)
return|return
literal|0
return|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: timeout waiting for clock stabilization\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|ETIMEDOUT
return|;
block|}
end_function

begin_function
name|int
name|iwn_apm_init
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|tmp
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Disable L0s exit timer (NMI bug workaround.) */
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_GIO_CHICKEN
argument_list|,
name|IWN_GIO_CHICKEN_DIS_L0S_TIMER
argument_list|)
expr_stmt|;
comment|/* Don't wait for ICH L0s (ICH bug workaround.) */
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_GIO_CHICKEN
argument_list|,
name|IWN_GIO_CHICKEN_L1A_NO_L0S_RX
argument_list|)
expr_stmt|;
comment|/* Set FH wait threshold to max (HW bug under stress workaround.) */
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_DBG_HPET_MEM
argument_list|,
literal|0xffff0000
argument_list|)
expr_stmt|;
comment|/* Enable HAP INTA to move adapter from L1a to L0s. */
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_HW_IF_CONFIG
argument_list|,
name|IWN_HW_IF_CONFIG_HAP_WAKE_L1A
argument_list|)
expr_stmt|;
comment|/* Retrieve PCIe Active State Power Management (ASPM). */
name|tmp
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|sc
operator|->
name|sc_cap_off
operator|+
literal|0x10
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Workaround for HW instability in PCIe L0->L0s->L1 transition. */
if|if
condition|(
name|tmp
operator|&
literal|0x02
condition|)
comment|/* L1 Entry enabled. */
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_GIO
argument_list|,
name|IWN_GIO_L0S_ENA
argument_list|)
expr_stmt|;
else|else
name|IWN_CLRBITS
argument_list|(
name|sc
argument_list|,
name|IWN_GIO
argument_list|,
name|IWN_GIO_L0S_ENA
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hw_type
operator|!=
name|IWN_HW_REV_TYPE_4965
operator|&&
name|sc
operator|->
name|hw_type
operator|!=
name|IWN_HW_REV_TYPE_6000
operator|&&
name|sc
operator|->
name|hw_type
operator|!=
name|IWN_HW_REV_TYPE_6050
condition|)
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_ANA_PLL
argument_list|,
name|IWN_ANA_PLL_INIT
argument_list|)
expr_stmt|;
comment|/* Wait for clock stabilization before accessing prph. */
name|error
operator|=
name|iwn_clock_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|error
operator|=
name|iwn_nic_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
name|sc
operator|->
name|hw_type
operator|==
name|IWN_HW_REV_TYPE_4965
condition|)
block|{
comment|/* Enable DMA and BSM (Bootstrap State Machine.) */
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN_APMG_CLK_EN
argument_list|,
name|IWN_APMG_CLK_CTRL_DMA_CLK_RQT
operator||
name|IWN_APMG_CLK_CTRL_BSM_CLK_RQT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Enable DMA. */
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN_APMG_CLK_EN
argument_list|,
name|IWN_APMG_CLK_CTRL_DMA_CLK_RQT
argument_list|)
expr_stmt|;
block|}
name|DELAY
argument_list|(
literal|20
argument_list|)
expr_stmt|;
comment|/* Disable L1-Active. */
name|iwn_prph_setbits
argument_list|(
name|sc
argument_list|,
name|IWN_APMG_PCI_STT
argument_list|,
name|IWN_APMG_PCI_STT_L1A_DIS
argument_list|)
expr_stmt|;
name|iwn_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|iwn_apm_stop_master
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|ntries
decl_stmt|;
comment|/* Stop busmaster DMA activity. */
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_RESET
argument_list|,
name|IWN_RESET_STOP_MASTER
argument_list|)
expr_stmt|;
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|100
condition|;
name|ntries
operator|++
control|)
block|{
if|if
condition|(
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_RESET
argument_list|)
operator|&
name|IWN_RESET_MASTER_DISABLED
condition|)
return|return;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: timeout waiting for master\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|iwn_apm_stop
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|iwn_apm_stop_master
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Reset the entire device. */
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_RESET
argument_list|,
name|IWN_RESET_SW
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* Clear "initialization complete" bit. */
name|IWN_CLRBITS
argument_list|(
name|sc
argument_list|,
name|IWN_GP_CNTRL
argument_list|,
name|IWN_GP_CNTRL_INIT_DONE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|iwn4965_nic_config
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|IWN_RFCFG_TYPE
argument_list|(
name|sc
operator|->
name|rfcfg
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* 		 * I don't believe this to be correct but this is what the 		 * vendor driver is doing. Probably the bits should not be 		 * shifted in IWN_RFCFG_*. 		 */
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_HW_IF_CONFIG
argument_list|,
name|IWN_RFCFG_TYPE
argument_list|(
name|sc
operator|->
name|rfcfg
argument_list|)
operator||
name|IWN_RFCFG_STEP
argument_list|(
name|sc
operator|->
name|rfcfg
argument_list|)
operator||
name|IWN_RFCFG_DASH
argument_list|(
name|sc
operator|->
name|rfcfg
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_HW_IF_CONFIG
argument_list|,
name|IWN_HW_IF_CONFIG_RADIO_SI
operator||
name|IWN_HW_IF_CONFIG_MAC_SI
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|iwn5000_nic_config
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|tmp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|IWN_RFCFG_TYPE
argument_list|(
name|sc
operator|->
name|rfcfg
argument_list|)
operator|<
literal|3
condition|)
block|{
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_HW_IF_CONFIG
argument_list|,
name|IWN_RFCFG_TYPE
argument_list|(
name|sc
operator|->
name|rfcfg
argument_list|)
operator||
name|IWN_RFCFG_STEP
argument_list|(
name|sc
operator|->
name|rfcfg
argument_list|)
operator||
name|IWN_RFCFG_DASH
argument_list|(
name|sc
operator|->
name|rfcfg
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_HW_IF_CONFIG
argument_list|,
name|IWN_HW_IF_CONFIG_RADIO_SI
operator||
name|IWN_HW_IF_CONFIG_MAC_SI
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_nic_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|iwn_prph_setbits
argument_list|(
name|sc
argument_list|,
name|IWN_APMG_PS
argument_list|,
name|IWN_APMG_PS_EARLY_PWROFF_DIS
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hw_type
operator|==
name|IWN_HW_REV_TYPE_1000
condition|)
block|{
comment|/* 		 * Select first Switching Voltage Regulator (1.32V) to 		 * solve a stability issue related to noisy DC2DC line 		 * in the silicon of 1000 Series. 		 */
name|tmp
operator|=
name|iwn_prph_read
argument_list|(
name|sc
argument_list|,
name|IWN_APMG_DIGITAL_SVR
argument_list|)
expr_stmt|;
name|tmp
operator|&=
operator|~
name|IWN_APMG_DIGITAL_SVR_VOLTAGE_MASK
expr_stmt|;
name|tmp
operator||=
name|IWN_APMG_DIGITAL_SVR_VOLTAGE_1_32
expr_stmt|;
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN_APMG_DIGITAL_SVR
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
name|iwn_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWN_FLAG_INTERNAL_PA
condition|)
block|{
comment|/* Use internal power amplifier only. */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_GP_DRIVER
argument_list|,
name|IWN_GP_DRIVER_RADIO_2X2_IPA
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Take NIC ownership over Intel Active Management Technology (AMT).  */
end_comment

begin_function
name|int
name|iwn_hw_prepare
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|ntries
decl_stmt|;
comment|/* Check if hardware is ready. */
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_HW_IF_CONFIG
argument_list|,
name|IWN_HW_IF_CONFIG_NIC_READY
argument_list|)
expr_stmt|;
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|5
condition|;
name|ntries
operator|++
control|)
block|{
if|if
condition|(
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_HW_IF_CONFIG
argument_list|)
operator|&
name|IWN_HW_IF_CONFIG_NIC_READY
condition|)
return|return
literal|0
return|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
comment|/* Hardware not ready, force into ready state. */
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_HW_IF_CONFIG
argument_list|,
name|IWN_HW_IF_CONFIG_PREPARE
argument_list|)
expr_stmt|;
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|15000
condition|;
name|ntries
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_HW_IF_CONFIG
argument_list|)
operator|&
name|IWN_HW_IF_CONFIG_PREPARE_DONE
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ntries
operator|==
literal|15000
condition|)
return|return
name|ETIMEDOUT
return|;
comment|/* Hardware should be ready now. */
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_HW_IF_CONFIG
argument_list|,
name|IWN_HW_IF_CONFIG_NIC_READY
argument_list|)
expr_stmt|;
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|5
condition|;
name|ntries
operator|++
control|)
block|{
if|if
condition|(
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_HW_IF_CONFIG
argument_list|)
operator|&
name|IWN_HW_IF_CONFIG_NIC_READY
condition|)
return|return
literal|0
return|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
return|return
name|ETIMEDOUT
return|;
block|}
end_function

begin_function
name|int
name|iwn_hw_init
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|struct
name|iwn_hal
modifier|*
name|hal
init|=
name|sc
operator|->
name|sc_hal
decl_stmt|;
name|int
name|error
decl_stmt|,
name|chnl
decl_stmt|,
name|qid
decl_stmt|;
comment|/* Clear pending interrupts. */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_INT
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_apm_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not power ON adapter, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Select VMAIN power source. */
name|error
operator|=
name|iwn_nic_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|iwn_prph_clrbits
argument_list|(
name|sc
argument_list|,
name|IWN_APMG_PS
argument_list|,
name|IWN_APMG_PS_PWR_SRC_MASK
argument_list|)
expr_stmt|;
name|iwn_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Perform adapter-specific initialization. */
name|error
operator|=
name|hal
operator|->
name|nic_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/* Initialize RX ring. */
name|error
operator|=
name|iwn_nic_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_RX_CONFIG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_RX_WPTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set physical address of RX ring (256-byte aligned.) */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_RX_BASE
argument_list|,
name|sc
operator|->
name|rxq
operator|.
name|desc_dma
operator|.
name|paddr
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* Set physical address of RX status (16-byte aligned.) */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_STATUS_WPTR
argument_list|,
name|sc
operator|->
name|rxq
operator|.
name|stat_dma
operator|.
name|paddr
operator|>>
literal|4
argument_list|)
expr_stmt|;
comment|/* Enable RX. */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_RX_CONFIG
argument_list|,
name|IWN_FH_RX_CONFIG_ENA
operator||
name|IWN_FH_RX_CONFIG_IGN_RXF_EMPTY
operator||
comment|/* HW bug workaround */
name|IWN_FH_RX_CONFIG_IRQ_DST_HOST
operator||
name|IWN_FH_RX_CONFIG_SINGLE_FRAME
operator||
name|IWN_FH_RX_CONFIG_RB_TIMEOUT
argument_list|(
literal|0
argument_list|)
operator||
name|IWN_FH_RX_CONFIG_NRBD
argument_list|(
name|IWN_RX_RING_COUNT_LOG
argument_list|)
argument_list|)
expr_stmt|;
name|iwn_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_RX_WPTR
argument_list|,
operator|(
name|IWN_RX_RING_COUNT
operator|-
literal|1
operator|)
operator|&
operator|~
literal|7
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_nic_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/* Initialize TX scheduler. */
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|hal
operator|->
name|sched_txfact_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set physical address of "keep warm" page (16-byte aligned.) */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_KW_ADDR
argument_list|,
name|sc
operator|->
name|kw_dma
operator|.
name|paddr
operator|>>
literal|4
argument_list|)
expr_stmt|;
comment|/* Initialize TX rings. */
for|for
control|(
name|qid
operator|=
literal|0
init|;
name|qid
operator|<
name|hal
operator|->
name|ntxqs
condition|;
name|qid
operator|++
control|)
block|{
name|struct
name|iwn_tx_ring
modifier|*
name|txq
init|=
operator|&
name|sc
operator|->
name|txq
index|[
name|qid
index|]
decl_stmt|;
comment|/* Set physical address of TX ring (256-byte aligned.) */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_CBBC_QUEUE
argument_list|(
name|qid
argument_list|)
argument_list|,
name|txq
operator|->
name|desc_dma
operator|.
name|paddr
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
name|iwn_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Enable DMA channels. */
for|for
control|(
name|chnl
operator|=
literal|0
init|;
name|chnl
operator|<
name|hal
operator|->
name|ndmachnls
condition|;
name|chnl
operator|++
control|)
block|{
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_TX_CONFIG
argument_list|(
name|chnl
argument_list|)
argument_list|,
name|IWN_FH_TX_CONFIG_DMA_ENA
operator||
name|IWN_FH_TX_CONFIG_DMA_CREDIT_ENA
argument_list|)
expr_stmt|;
block|}
comment|/* Clear "radio off" and "commands blocked" bits. */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_UCODE_GP1_CLR
argument_list|,
name|IWN_UCODE_GP1_RFKILL
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_UCODE_GP1_CLR
argument_list|,
name|IWN_UCODE_GP1_CMD_BLOCKED
argument_list|)
expr_stmt|;
comment|/* Clear pending interrupts. */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_INT
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* Enable interrupt coalescing. */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_INT_COALESCING
argument_list|,
literal|512
operator|/
literal|8
argument_list|)
expr_stmt|;
comment|/* Enable interrupts. */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_INT_MASK
argument_list|,
name|sc
operator|->
name|int_mask
argument_list|)
expr_stmt|;
comment|/* _Really_ make sure "radio off" bit is cleared! */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_UCODE_GP1_CLR
argument_list|,
name|IWN_UCODE_GP1_RFKILL
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_UCODE_GP1_CLR
argument_list|,
name|IWN_UCODE_GP1_RFKILL
argument_list|)
expr_stmt|;
name|error
operator|=
name|hal
operator|->
name|load_firmware
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not load firmware, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Wait at most one second for firmware alive notification. */
name|error
operator|=
name|msleep
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|PCATCH
argument_list|,
literal|"iwninit"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: timeout waiting for adapter to initialize, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Do post-firmware initialization. */
return|return
name|hal
operator|->
name|post_alive
argument_list|(
name|sc
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|iwn_hw_stop
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|struct
name|iwn_hal
modifier|*
name|hal
init|=
name|sc
operator|->
name|sc_hal
decl_stmt|;
name|uint32_t
name|tmp
decl_stmt|;
name|int
name|chnl
decl_stmt|,
name|qid
decl_stmt|,
name|ntries
decl_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_RESET
argument_list|,
name|IWN_RESET_NEVO
argument_list|)
expr_stmt|;
comment|/* Disable interrupts. */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_INT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_INT
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_INT
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|IWN_FLAG_USE_ICT
expr_stmt|;
comment|/* Make sure we no longer hold the NIC lock. */
name|iwn_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Stop TX scheduler. */
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|hal
operator|->
name|sched_txfact_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Stop all DMA channels. */
if|if
condition|(
name|iwn_nic_lock
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|chnl
operator|=
literal|0
init|;
name|chnl
operator|<
name|hal
operator|->
name|ndmachnls
condition|;
name|chnl
operator|++
control|)
block|{
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_TX_CONFIG
argument_list|(
name|chnl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|200
condition|;
name|ntries
operator|++
control|)
block|{
name|tmp
operator|=
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_FH_TX_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|&
name|IWN_FH_TX_STATUS_IDLE
argument_list|(
name|chnl
argument_list|)
operator|)
operator|==
name|IWN_FH_TX_STATUS_IDLE
argument_list|(
name|chnl
argument_list|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
block|}
name|iwn_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* Stop RX ring. */
name|iwn_reset_rx_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rxq
argument_list|)
expr_stmt|;
comment|/* Reset all TX rings. */
for|for
control|(
name|qid
operator|=
literal|0
init|;
name|qid
operator|<
name|hal
operator|->
name|ntxqs
condition|;
name|qid
operator|++
control|)
name|iwn_reset_tx_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|txq
index|[
name|qid
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|iwn_nic_lock
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
condition|)
block|{
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN_APMG_CLK_DIS
argument_list|,
name|IWN_APMG_CLK_CTRL_DMA_CLK_RQT
argument_list|)
expr_stmt|;
name|iwn_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
comment|/* Power OFF adapter. */
name|iwn_apm_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|iwn_init_locked
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|IWN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_hw_prepare
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: hardware not ready, eror %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Initialize interrupt mask to default value. */
name|sc
operator|->
name|int_mask
operator|=
name|IWN_INT_MASK_DEF
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|IWN_FLAG_USE_ICT
expr_stmt|;
comment|/* Check that the radio is not disabled by hardware switch. */
if|if
condition|(
operator|!
operator|(
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_GP_CNTRL
argument_list|)
operator|&
name|IWN_GP_CNTRL_RFKILL
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"radio is disabled by hardware switch\n"
argument_list|)
expr_stmt|;
comment|/* Enable interrupts to get RF toggle notifications. */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_INT
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_INT_MASK
argument_list|,
name|sc
operator|->
name|int_mask
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Read firmware images from the filesystem. */
name|error
operator|=
name|iwn_read_firmware
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not read firmware, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Initialize hardware and upload firmware. */
name|error
operator|=
name|iwn_hw_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|firmware_put
argument_list|(
name|sc
operator|->
name|fw_fp
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fw_fp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not initialize hardware, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Configure adapter now that it is ready. */
name|error
operator|=
name|iwn_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not configure device, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
return|return;
name|fail
label|:
name|iwn_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|iwn_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwn_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|ieee80211_start_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|iwn_stop_locked
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|IWN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|0
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_timer_to
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
comment|/* Power OFF hardware. */
name|iwn_hw_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|iwn_stop
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwn_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Callback from net80211 to start a scan.  */
end_comment

begin_function
specifier|static
name|void
name|iwn_scan_start
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* make the link LED blink while we're scanning */
name|iwn_set_led
argument_list|(
name|sc
argument_list|,
name|IWN_LED_LINK
argument_list|,
literal|20
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Callback from net80211 to terminate a scan.  */
end_comment

begin_function
specifier|static
name|void
name|iwn_scan_end
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_RUN
condition|)
block|{
comment|/* Set link LED to ON status if we are associated */
name|iwn_set_led
argument_list|(
name|sc
argument_list|,
name|IWN_LED_LINK
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Callback from net80211 to force a channel change.  */
end_comment

begin_function
specifier|static
name|void
name|iwn_set_channel
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|c
init|=
name|ic
operator|->
name|ic_curchan
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rxtap
operator|.
name|wr_chan_freq
operator|=
name|htole16
argument_list|(
name|c
operator|->
name|ic_freq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rxtap
operator|.
name|wr_chan_flags
operator|=
name|htole16
argument_list|(
name|c
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txtap
operator|.
name|wt_chan_freq
operator|=
name|htole16
argument_list|(
name|c
operator|->
name|ic_freq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txtap
operator|.
name|wt_chan_flags
operator|=
name|htole16
argument_list|(
name|c
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Callback from net80211 to start scanning of the current channel.  */
end_comment

begin_function
specifier|static
name|void
name|iwn_scan_curchan
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|unsigned
name|long
name|maxdwell
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ss
operator|->
name|ss_vap
decl_stmt|;
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|vap
operator|->
name|iv_ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_scan
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|ieee80211_cancel_scan
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Callback from net80211 to handle the minimum dwell time being met.  * The intent is to terminate the scan but we just let the firmware  * notify us when it's finished as we have no safe way to abort it.  */
end_comment

begin_function
specifier|static
name|void
name|iwn_scan_mindwell
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|)
block|{
comment|/* NB: don't try to abort scan; wait for firmware to finish */
block|}
end_function

begin_function
specifier|static
name|struct
name|iwn_eeprom_chan
modifier|*
name|iwn_find_eeprom_channel
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|7
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iwn_bands
index|[
name|j
index|]
operator|.
name|nchan
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|iwn_bands
index|[
name|j
index|]
operator|.
name|chan
index|[
name|i
index|]
operator|==
name|c
operator|->
name|ic_ieee
condition|)
return|return
operator|&
name|sc
operator|->
name|eeprom_channels
index|[
name|j
index|]
index|[
name|i
index|]
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Enforce flags read from EEPROM.  */
end_comment

begin_function
specifier|static
name|int
name|iwn_setregdomain
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_regdomain
modifier|*
name|rd
parameter_list|,
name|int
name|nchan
parameter_list|,
name|struct
name|ieee80211_channel
name|chans
index|[]
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchan
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ieee80211_channel
modifier|*
name|c
init|=
operator|&
name|chans
index|[
name|i
index|]
decl_stmt|;
name|struct
name|iwn_eeprom_chan
modifier|*
name|channel
decl_stmt|;
name|channel
operator|=
name|iwn_find_eeprom_channel
argument_list|(
name|sc
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|==
name|NULL
condition|)
block|{
name|if_printf
argument_list|(
name|ic
operator|->
name|ic_ifp
argument_list|,
literal|"%s: invalid channel %u freq %u/0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|c
operator|->
name|ic_ieee
argument_list|,
name|c
operator|->
name|ic_freq
argument_list|,
name|c
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|c
operator|->
name|ic_flags
operator||=
name|iwn_eeprom_channel_flags
argument_list|(
name|channel
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_hw_reset
parameter_list|(
name|void
modifier|*
name|arg0
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|arg0
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|iwn_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwn_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ieee80211_notify_radio
argument_list|(
name|ic
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_radio_on
parameter_list|(
name|void
modifier|*
name|arg0
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|arg0
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
if|if
condition|(
name|vap
operator|!=
name|NULL
condition|)
block|{
name|iwn_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ieee80211_init
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_radio_off
parameter_list|(
name|void
modifier|*
name|arg0
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|arg0
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
name|iwn_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|!=
name|NULL
condition|)
name|ieee80211_stop
argument_list|(
name|vap
argument_list|)
expr_stmt|;
comment|/* Enable interrupts to get RF toggle notification. */
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_INT
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_INT_MASK
argument_list|,
name|sc
operator|->
name|int_mask
argument_list|)
expr_stmt|;
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_sysctlattach
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
init|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|tree
init|=
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|IWN_DEBUG
name|sc
operator|->
name|sc_debug
operator|=
literal|0
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"debug"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|sc_debug
argument_list|,
literal|0
argument_list|,
literal|"control debugging printfs"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|iwn_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
name|iwn_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|!=
name|NULL
condition|)
name|ieee80211_stop
argument_list|(
name|vap
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
comment|/* Clear device-specific "PCI retry timeout" register (41h). */
name|pci_write_config
argument_list|(
name|dev
argument_list|,
literal|0x41
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
name|iwn_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|!=
name|NULL
condition|)
name|ieee80211_init
argument_list|(
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|iwn_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IWN_DEBUG
end_ifdef

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|iwn_intr_str
parameter_list|(
name|uint8_t
name|cmd
parameter_list|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
comment|/* Notifications */
case|case
name|IWN_UC_READY
case|:
return|return
literal|"UC_READY"
return|;
case|case
name|IWN_ADD_NODE_DONE
case|:
return|return
literal|"ADD_NODE_DONE"
return|;
case|case
name|IWN_TX_DONE
case|:
return|return
literal|"TX_DONE"
return|;
case|case
name|IWN_START_SCAN
case|:
return|return
literal|"START_SCAN"
return|;
case|case
name|IWN_STOP_SCAN
case|:
return|return
literal|"STOP_SCAN"
return|;
case|case
name|IWN_RX_STATISTICS
case|:
return|return
literal|"RX_STATS"
return|;
case|case
name|IWN_BEACON_STATISTICS
case|:
return|return
literal|"BEACON_STATS"
return|;
case|case
name|IWN_STATE_CHANGED
case|:
return|return
literal|"STATE_CHANGED"
return|;
case|case
name|IWN_BEACON_MISSED
case|:
return|return
literal|"BEACON_MISSED"
return|;
case|case
name|IWN_RX_PHY
case|:
return|return
literal|"RX_PHY"
return|;
case|case
name|IWN_MPDU_RX_DONE
case|:
return|return
literal|"MPDU_RX_DONE"
return|;
case|case
name|IWN_RX_DONE
case|:
return|return
literal|"RX_DONE"
return|;
comment|/* Command Notifications */
case|case
name|IWN_CMD_RXON
case|:
return|return
literal|"IWN_CMD_RXON"
return|;
case|case
name|IWN_CMD_RXON_ASSOC
case|:
return|return
literal|"IWN_CMD_RXON_ASSOC"
return|;
case|case
name|IWN_CMD_EDCA_PARAMS
case|:
return|return
literal|"IWN_CMD_EDCA_PARAMS"
return|;
case|case
name|IWN_CMD_TIMING
case|:
return|return
literal|"IWN_CMD_TIMING"
return|;
case|case
name|IWN_CMD_LINK_QUALITY
case|:
return|return
literal|"IWN_CMD_LINK_QUALITY"
return|;
case|case
name|IWN_CMD_SET_LED
case|:
return|return
literal|"IWN_CMD_SET_LED"
return|;
case|case
name|IWN5000_CMD_WIMAX_COEX
case|:
return|return
literal|"IWN5000_CMD_WIMAX_COEX"
return|;
case|case
name|IWN5000_CMD_CALIB_CONFIG
case|:
return|return
literal|"IWN5000_CMD_CALIB_CONFIG"
return|;
case|case
name|IWN_CMD_SET_POWER_MODE
case|:
return|return
literal|"IWN_CMD_SET_POWER_MODE"
return|;
case|case
name|IWN_CMD_SCAN
case|:
return|return
literal|"IWN_CMD_SCAN"
return|;
case|case
name|IWN_CMD_TXPOWER
case|:
return|return
literal|"IWN_CMD_TXPOWER"
return|;
case|case
name|IWN_CMD_TXPOWER_DBM
case|:
return|return
literal|"IWN_CMD_TXPOWER_DBM"
return|;
case|case
name|IWN_CMD_BT_COEX
case|:
return|return
literal|"IWN_CMD_BT_COEX"
return|;
case|case
name|IWN_CMD_SET_CRITICAL_TEMP
case|:
return|return
literal|"IWN_CMD_SET_CRITICAL_TEMP"
return|;
case|case
name|IWN_CMD_SET_SENSITIVITY
case|:
return|return
literal|"IWN_CMD_SET_SENSITIVITY"
return|;
case|case
name|IWN_CMD_PHY_CALIB
case|:
return|return
literal|"IWN_CMD_PHY_CALIB"
return|;
block|}
return|return
literal|"UNKNOWN INTR NOTIF/CMD"
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IWN_DEBUG */
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|iwn_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|iwn_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|iwn_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|iwn_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|iwn_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|iwn_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|iwn_resume
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|iwn_driver
init|=
block|{
literal|"iwn"
block|,
name|iwn_methods
block|,
expr|sizeof
operator|(
expr|struct
name|iwn_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|iwn_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|iwn
argument_list|,
name|pci
argument_list|,
name|iwn_driver
argument_list|,
name|iwn_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|iwn
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|iwn
argument_list|,
name|firmware
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|iwn
argument_list|,
name|wlan
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|iwn
argument_list|,
name|wlan_amrr
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

