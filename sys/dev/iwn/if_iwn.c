begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2007  *	Damien Bergamini<damien.bergamini@free.fr>  * Copyright (c) 2008  *	Benjamin Close<benjsc@FreeBSD.org>  * Copyright (c) 2008 Sam Leffler, Errno Consulting  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/*  * Driver for Intel Wireless WiFi Link 4965AGN 802.11 network adapters.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/firmware.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_amrr.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_radiotap.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_regdomain.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwn/if_iwnreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwn/if_iwnvar.h>
end_include

begin_function_decl
specifier|static
name|int
name|iwn_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_cleanup
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ieee80211vap
modifier|*
name|iwn_vap_create
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
specifier|const
name|char
name|name
index|[
name|IFNAMSIZ
index|]
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|opmode
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|uint8_t
name|bssid
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_vap_delete
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_shutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_suspend
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_resume
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_dma_contig_alloc
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_dma_info
modifier|*
parameter_list|,
name|void
modifier|*
modifier|*
parameter_list|,
name|bus_size_t
parameter_list|,
name|bus_size_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_dma_contig_free
parameter_list|(
name|struct
name|iwn_dma_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_alloc_shared
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_free_shared
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_alloc_kw
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_free_kw
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_alloc_fwmem
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_free_fwmem
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|iwn_rbuf
modifier|*
name|iwn_alloc_rbuf
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_free_rbuf
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_alloc_rpool
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_free_rpool
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_alloc_rx_ring
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_reset_rx_ring
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_free_rx_ring
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_alloc_tx_ring
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_tx_ring
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_reset_tx_ring
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_free_tx_ring
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ieee80211_node
modifier|*
name|iwn_node_alloc
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
specifier|const
name|uint8_t
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_newassoc
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_newstate
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|enum
name|ieee80211_state
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_mem_lock
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_mem_unlock
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|uint32_t
name|iwn_mem_read
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_mem_write
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_mem_write_region_4
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
specifier|const
name|uint32_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_eeprom_lock
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_eeprom_unlock
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_read_prom_data
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_transfer_microcode
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_transfer_firmware
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_load_firmware
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_unload_firmware
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_timer_timeout
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_calib_reset
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_ampdu_rx_start
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_rx_intr
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_rx_statistics
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_tx_intr
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_cmd_intr
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_notif_intr
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_read_eeprom
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_read_eeprom_channels
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_print_power_group
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|uint8_t
name|iwn_plcp_signal
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_tx_data
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|struct
name|iwn_tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_raw_xmit
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_watchdog
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_cmd
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_set_link_quality
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_set_key
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_key
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_wme_update
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_set_led
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_set_critical_temp
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_enable_tsf
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_power_calibration
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_set_txpower
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int8_t
name|iwn_get_rssi
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|iwn_rx_stat
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_get_noise
parameter_list|(
specifier|const
name|struct
name|iwn_rx_general_stats
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_get_temperature
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_init_sensitivity
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_compute_differential_gain
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|iwn_rx_general_stats
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_tune_sensitivity
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|iwn_rx_stats
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_send_sensitivity
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_auth
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_run
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_scan
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_config
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_post_alive
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_stop_master
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iwn_reset
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_hw_config
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_init_locked
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_stop_locked
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iwn_stop
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_scan_start
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_scan_end
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_set_channel
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_scan_curchan
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
parameter_list|,
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_scan_mindwell
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_hwreset
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_radioon
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_radiooff
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_bpfattach
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_sysctlattach
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|IWN_DEBUG
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|IWN_DEBUG
end_ifdef

begin_enum
enum|enum
block|{
name|IWN_DEBUG_XMIT
init|=
literal|0x00000001
block|,
comment|/* basic xmit operation */
name|IWN_DEBUG_RECV
init|=
literal|0x00000002
block|,
comment|/* basic recv operation */
name|IWN_DEBUG_STATE
init|=
literal|0x00000004
block|,
comment|/* 802.11 state transitions */
name|IWN_DEBUG_TXPOW
init|=
literal|0x00000008
block|,
comment|/* tx power processing */
name|IWN_DEBUG_RESET
init|=
literal|0x00000010
block|,
comment|/* reset processing */
name|IWN_DEBUG_OPS
init|=
literal|0x00000020
block|,
comment|/* iwn_ops processing */
name|IWN_DEBUG_BEACON
init|=
literal|0x00000040
block|,
comment|/* beacon handling */
name|IWN_DEBUG_WATCHDOG
init|=
literal|0x00000080
block|,
comment|/* watchdog timeout */
name|IWN_DEBUG_INTR
init|=
literal|0x00000100
block|,
comment|/* ISR */
name|IWN_DEBUG_CALIBRATE
init|=
literal|0x00000200
block|,
comment|/* periodic calibration */
name|IWN_DEBUG_NODE
init|=
literal|0x00000400
block|,
comment|/* node management */
name|IWN_DEBUG_LED
init|=
literal|0x00000800
block|,
comment|/* led management */
name|IWN_DEBUG_CMD
init|=
literal|0x00001000
block|,
comment|/* cmd submission */
name|IWN_DEBUG_FATAL
init|=
literal|0x80000000
block|,
comment|/* fatal errors */
name|IWN_DEBUG_ANY
init|=
literal|0xffffffff
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|sc
parameter_list|,
name|m
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
value|do {			\ 	if (sc->sc_debug& (m))				\ 		printf(fmt, __VA_ARGS__);		\ } while (0)
end_define

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|iwn_intr_str
parameter_list|(
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|sc
parameter_list|,
name|m
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
value|do { (void) sc; } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|iwn_ident
block|{
name|uint16_t
name|vendor
decl_stmt|;
name|uint16_t
name|device
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|iwn_ident
name|iwn_ident_table
index|[]
init|=
block|{
block|{
literal|0x8086
block|,
literal|0x4229
block|,
literal|"Intel(R) PRO/Wireless 4965BGN"
block|}
block|,
block|{
literal|0x8086
block|,
literal|0x422D
block|,
literal|"Intel(R) PRO/Wireless 4965BGN"
block|}
block|,
block|{
literal|0x8086
block|,
literal|0x4230
block|,
literal|"Intel(R) PRO/Wireless 4965BGN"
block|}
block|,
block|{
literal|0x8086
block|,
literal|0x4233
block|,
literal|"Intel(R) PRO/Wireless 4965BGN"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|iwn_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
specifier|const
name|struct
name|iwn_ident
modifier|*
name|ident
decl_stmt|;
for|for
control|(
name|ident
operator|=
name|iwn_ident_table
init|;
name|ident
operator|->
name|name
operator|!=
name|NULL
condition|;
name|ident
operator|++
control|)
block|{
if|if
condition|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|ident
operator|->
name|vendor
operator|&&
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|ident
operator|->
name|device
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|ident
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
name|ENXIO
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|iwn_softc
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|result
decl_stmt|;
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
decl_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|pci_get_powerstate
argument_list|(
name|dev
argument_list|)
operator|!=
name|PCI_POWERSTATE_D0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"chip is in D%d power mode "
literal|"-- setting to D0\n"
argument_list|,
name|pci_get_powerstate
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|pci_set_powerstate
argument_list|(
name|dev
argument_list|,
name|PCI_POWERSTATE_D0
argument_list|)
expr_stmt|;
block|}
comment|/* clear device specific PCI configuration register 0x41 */
name|pci_write_config
argument_list|(
name|dev
argument_list|,
literal|0x41
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* enable bus-mastering */
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mem_rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|mem_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate memory resources\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
return|return
name|error
return|;
block|}
name|sc
operator|->
name|sc_st
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|mem
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_sh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|mem
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq_rid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|result
operator|=
name|pci_msi_count
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
literal|1
operator|&&
name|pci_alloc_msi
argument_list|(
name|dev
argument_list|,
operator|&
name|result
argument_list|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|irq_rid
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|irq_rid
argument_list|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate interrupt resource\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
return|return
name|error
return|;
block|}
name|IWN_LOCK_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_timer_to
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_reinit_task
argument_list|,
literal|0
argument_list|,
name|iwn_hwreset
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_radioon_task
argument_list|,
literal|0
argument_list|,
name|iwn_radioon
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_radiooff_task
argument_list|,
literal|0
argument_list|,
name|iwn_radiooff
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Put adapter into a known state. 	 */
name|error
operator|=
name|iwn_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not reset adapter, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * Allocate DMA memory for firmware transfers. 	 */
name|error
operator|=
name|iwn_alloc_fwmem
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate firmware memory, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * Allocate a "keep warm" page. 	 */
name|error
operator|=
name|iwn_alloc_kw
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate keep-warm page, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * Allocate shared area (communication area). 	 */
name|error
operator|=
name|iwn_alloc_shared
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate shared area, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * Allocate Tx rings. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWN_NTXQUEUES
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|iwn_alloc_tx_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|txq
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate Tx ring %d, error %d\n"
argument_list|,
name|i
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|error
operator|=
name|iwn_alloc_rx_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rxq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate Rx ring, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ifp
operator|=
name|sc
operator|->
name|sc_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_IEEE80211
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can not allocate ifnet structure\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ic
operator|=
name|ifp
operator|->
name|if_l2com
expr_stmt|;
name|ic
operator|->
name|ic_ifp
operator|=
name|ifp
expr_stmt|;
name|ic
operator|->
name|ic_phytype
operator|=
name|IEEE80211_T_OFDM
expr_stmt|;
comment|/* not only, but not used */
name|ic
operator|->
name|ic_opmode
operator|=
name|IEEE80211_M_STA
expr_stmt|;
comment|/* default to BSS mode */
comment|/* set device capabilities */
name|ic
operator|->
name|ic_caps
operator|=
name|IEEE80211_C_STA
comment|/* station mode supported */
operator||
name|IEEE80211_C_MONITOR
comment|/* monitor mode supported */
operator||
name|IEEE80211_C_TXPMGT
comment|/* tx power management */
operator||
name|IEEE80211_C_SHSLOT
comment|/* short slot time supported */
operator||
name|IEEE80211_C_WPA
operator||
name|IEEE80211_C_SHPREAMBLE
comment|/* short preamble supported */
if|#
directive|if
literal|0
expr|| IEEE80211_C_BGSCAN
comment|/* background scanning */
expr|| IEEE80211_C_IBSS
comment|/* ibss/adhoc mode */
endif|#
directive|endif
operator||
name|IEEE80211_C_WME
comment|/* WME */
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX disable until HT channel setup works */
block|ic->ic_htcaps = 		  IEEE80211_HTCAP_SMPS_ENA
comment|/* SM PS mode enabled */
block|| IEEE80211_HTCAP_CHWIDTH40
comment|/* 40MHz channel width */
block|| IEEE80211_HTCAP_SHORTGI20
comment|/* short GI in 20MHz */
block|| IEEE80211_HTCAP_SHORTGI40
comment|/* short GI in 40MHz */
block|| IEEE80211_HTCAP_RXSTBC_2STREAM
comment|/* 1-2 spatial streams */
block|| IEEE80211_HTCAP_MAXAMSDU_3839
comment|/* max A-MSDU length */
comment|/* s/w capabilities */
block|| IEEE80211_HTC_HT
comment|/* HT operation */
block|| IEEE80211_HTC_AMPDU
comment|/* tx A-MPDU */
block|| IEEE80211_HTC_AMSDU
comment|/* tx A-MSDU */
block|;
endif|#
directive|endif
comment|/* read supported channels and MAC address from EEPROM */
name|iwn_read_eeprom
argument_list|(
name|sc
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|iwn_init
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|iwn_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|iwn_start
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|IFQ_MAXLEN
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|ieee80211_ifattach
argument_list|(
name|ic
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_vap_create
operator|=
name|iwn_vap_create
expr_stmt|;
name|ic
operator|->
name|ic_vap_delete
operator|=
name|iwn_vap_delete
expr_stmt|;
name|ic
operator|->
name|ic_raw_xmit
operator|=
name|iwn_raw_xmit
expr_stmt|;
name|ic
operator|->
name|ic_node_alloc
operator|=
name|iwn_node_alloc
expr_stmt|;
name|ic
operator|->
name|ic_newassoc
operator|=
name|iwn_newassoc
expr_stmt|;
name|ic
operator|->
name|ic_wme
operator|.
name|wme_update
operator|=
name|iwn_wme_update
expr_stmt|;
name|ic
operator|->
name|ic_scan_start
operator|=
name|iwn_scan_start
expr_stmt|;
name|ic
operator|->
name|ic_scan_end
operator|=
name|iwn_scan_end
expr_stmt|;
name|ic
operator|->
name|ic_set_channel
operator|=
name|iwn_set_channel
expr_stmt|;
name|ic
operator|->
name|ic_scan_curchan
operator|=
name|iwn_scan_curchan
expr_stmt|;
name|ic
operator|->
name|ic_scan_mindwell
operator|=
name|iwn_scan_mindwell
expr_stmt|;
name|iwn_bpfattach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwn_sysctlattach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*          * Hook our interrupt after all initialization is complete.          */
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|iwn_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not set up interrupt, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ieee80211_announce
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
name|iwn_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|iwn_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Cleanup any device resources that were allocated  */
end_comment

begin_function
name|int
name|iwn_cleanup
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ieee80211_draintask
argument_list|(
name|ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_reinit_task
argument_list|)
expr_stmt|;
name|ieee80211_draintask
argument_list|(
name|ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_radioon_task
argument_list|)
expr_stmt|;
name|ieee80211_draintask
argument_list|(
name|ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_radiooff_task
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
block|{
name|iwn_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_timer_to
argument_list|)
expr_stmt|;
name|bpfdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ieee80211_ifdetach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
name|iwn_unload_firmware
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwn_free_rx_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rxq
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWN_NTXQUEUES
condition|;
name|i
operator|++
control|)
name|iwn_free_tx_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|iwn_free_kw
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwn_free_fwmem
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq
operator|!=
name|NULL
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|sc
operator|->
name|sc_ih
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irq_rid
argument_list|,
name|sc
operator|->
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq_rid
operator|==
literal|1
condition|)
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|mem
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|mem_rid
argument_list|,
name|sc
operator|->
name|mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|IWN_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ieee80211vap
modifier|*
name|iwn_vap_create
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|char
name|name
index|[
name|IFNAMSIZ
index|]
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|opmode
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|uint8_t
name|bssid
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|iwn_vap
modifier|*
name|ivp
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
condition|)
comment|/* only one at a time */
return|return
name|NULL
return|;
name|ivp
operator|=
operator|(
expr|struct
name|iwn_vap
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_vap
argument_list|)
argument_list|,
name|M_80211_VAP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ivp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|vap
operator|=
operator|&
name|ivp
operator|->
name|iv_vap
expr_stmt|;
name|ieee80211_vap_setup
argument_list|(
name|ic
argument_list|,
name|vap
argument_list|,
name|name
argument_list|,
name|unit
argument_list|,
name|opmode
argument_list|,
name|flags
argument_list|,
name|bssid
argument_list|,
name|mac
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_bmissthreshold
operator|=
literal|10
expr_stmt|;
comment|/* override default */
comment|/* override with driver methods */
name|ivp
operator|->
name|iv_newstate
operator|=
name|vap
operator|->
name|iv_newstate
expr_stmt|;
name|vap
operator|->
name|iv_newstate
operator|=
name|iwn_newstate
expr_stmt|;
name|ieee80211_amrr_init
argument_list|(
operator|&
name|ivp
operator|->
name|iv_amrr
argument_list|,
name|vap
argument_list|,
name|IEEE80211_AMRR_MIN_SUCCESS_THRESHOLD
argument_list|,
name|IEEE80211_AMRR_MAX_SUCCESS_THRESHOLD
argument_list|,
literal|500
comment|/*ms*/
argument_list|)
expr_stmt|;
comment|/* complete setup */
name|ieee80211_vap_attach
argument_list|(
name|vap
argument_list|,
name|ieee80211_media_change
argument_list|,
name|ieee80211_media_status
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_opmode
operator|=
name|opmode
expr_stmt|;
return|return
name|vap
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_vap_delete
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|iwn_vap
modifier|*
name|ivp
init|=
name|IWN_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|ieee80211_amrr_cleanup
argument_list|(
operator|&
name|ivp
operator|->
name|iv_amrr
argument_list|)
expr_stmt|;
name|ieee80211_vap_detach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ivp
argument_list|,
name|M_80211_VAP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|iwn_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|iwn_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
literal|0x41
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
name|iwn_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_dma_map_addr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return;
name|KASSERT
argument_list|(
name|nsegs
operator|==
literal|1
argument_list|,
operator|(
literal|"too many DMA segments, %d should be 1"
operator|,
name|nsegs
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_dma_contig_alloc
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_dma_info
modifier|*
name|dma
parameter_list|,
name|void
modifier|*
modifier|*
name|kvap
parameter_list|,
name|bus_size_t
name|size
parameter_list|,
name|bus_size_t
name|alignment
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|lalignment
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * FreeBSD can't guarrenty 16k alignment at the moment (11/2007) so 	 * we allocate an extra 12k with 4k alignement and walk through 	 * it trying to find where the alignment is. It's a nasty fix for 	 * a bigger problem. 	*/
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"Size: %zd - alignment %zd\n"
argument_list|,
name|size
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
if|if
condition|(
name|alignment
operator|==
literal|0x4000
condition|)
block|{
name|size
operator|+=
literal|12
operator|*
literal|1024
expr_stmt|;
name|lalignment
operator|=
literal|4096
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"%s\n"
argument_list|,
literal|"Attempting to find a 16k boundary"
argument_list|)
expr_stmt|;
block|}
else|else
name|lalignment
operator|=
name|alignment
expr_stmt|;
name|dma
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|dma
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|lalignment
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|size
argument_list|,
literal|1
argument_list|,
name|size
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|dma
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: bus_dma_tag_create failed, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|dma
operator|->
name|vaddr
argument_list|,
name|flags
operator||
name|BUS_DMA_ZERO
argument_list|,
operator|&
name|dma
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: bus_dmamem_alloc failed, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|alignment
operator|==
literal|0x4000
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
operator|&&
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
name|dma
operator|->
name|vaddr
operator|)
operator|&
literal|0x3fff
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"%s\n"
argument_list|,
literal|"Memory Unaligned, shifting pointer by 4k"
argument_list|)
expr_stmt|;
name|dma
operator|->
name|vaddr
operator|+=
literal|4096
expr_stmt|;
name|size
operator|-=
literal|4096
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
name|dma
operator|->
name|vaddr
operator|)
operator|&
operator|(
name|alignment
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_ANY
argument_list|,
literal|"%s: failed to align memory, vaddr %p, align %zd\n"
argument_list|,
name|__func__
argument_list|,
name|dma
operator|->
name|vaddr
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|,
name|dma
operator|->
name|vaddr
argument_list|,
name|size
argument_list|,
name|iwn_dma_map_addr
argument_list|,
operator|&
name|dma
operator|->
name|paddr
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: bus_dmamap_load failed, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|kvap
operator|!=
name|NULL
condition|)
operator|*
name|kvap
operator|=
name|dma
operator|->
name|vaddr
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
name|iwn_dma_contig_free
argument_list|(
name|dma
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_dma_contig_free
parameter_list|(
name|struct
name|iwn_dma_info
modifier|*
name|dma
parameter_list|)
block|{
if|if
condition|(
name|dma
operator|->
name|tag
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dma
operator|->
name|map
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dma
operator|->
name|paddr
operator|==
literal|0
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|)
expr_stmt|;
block|}
name|bus_dmamem_free
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
operator|&
name|dma
operator|->
name|vaddr
argument_list|,
name|dma
operator|->
name|map
argument_list|)
expr_stmt|;
block|}
name|bus_dma_tag_destroy
argument_list|(
name|dma
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|iwn_alloc_shared
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* must be aligned on a 1KB boundary */
return|return
name|iwn_dma_contig_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|shared_dma
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|shared
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_shared
argument_list|)
argument_list|,
literal|1024
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|iwn_free_shared
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|iwn_dma_contig_free
argument_list|(
operator|&
name|sc
operator|->
name|shared_dma
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|iwn_alloc_kw
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* must be aligned on a 4k boundary */
return|return
name|iwn_dma_contig_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|kw_dma
argument_list|,
name|NULL
argument_list|,
name|PAGE_SIZE
argument_list|,
name|PAGE_SIZE
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|iwn_free_kw
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|iwn_dma_contig_free
argument_list|(
operator|&
name|sc
operator|->
name|kw_dma
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|iwn_alloc_fwmem
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* allocate enough contiguous space to store text and data */
return|return
name|iwn_dma_contig_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|fw_dma
argument_list|,
name|NULL
argument_list|,
name|IWN_FW_MAIN_TEXT_MAXSZ
operator|+
name|IWN_FW_MAIN_DATA_MAXSZ
argument_list|,
literal|16
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|iwn_free_fwmem
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|iwn_dma_contig_free
argument_list|(
operator|&
name|sc
operator|->
name|fw_dma
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|iwn_alloc_rx_ring
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_rx_ring
modifier|*
name|ring
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|ring
operator|->
name|cur
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|iwn_dma_contig_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|ring
operator|->
name|desc_dma
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ring
operator|->
name|desc
argument_list|,
name|IWN_RX_RING_COUNT
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|IWN_RING_DMA_ALIGN
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not allocate rx ring DMA memory, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MJUMPAGESIZE
argument_list|,
literal|1
argument_list|,
name|MJUMPAGESIZE
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|ring
operator|->
name|data_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: bus_dma_tag_create_failed, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * Setup Rx buffers. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWN_RX_RING_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|iwn_rx_data
modifier|*
name|data
init|=
operator|&
name|ring
operator|->
name|data
index|[
name|i
index|]
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|bus_addr_t
name|paddr
decl_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: bus_dmamap_create failed, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|m
operator|=
name|m_getjcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|MJUMPAGESIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not allocate rx mbuf\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* map page */
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|MJUMPAGESIZE
argument_list|,
name|iwn_dma_map_addr
argument_list|,
operator|&
name|paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|EFBIG
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: bus_dmamap_load failed, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
comment|/* XXX unique code */
goto|goto
name|fail
goto|;
block|}
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|data
operator|->
name|m
operator|=
name|m
expr_stmt|;
comment|/* Rx buffers are aligned on a 256-byte boundary */
name|ring
operator|->
name|desc
index|[
name|i
index|]
operator|=
name|htole32
argument_list|(
name|paddr
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|desc_dma
operator|.
name|tag
argument_list|,
name|ring
operator|->
name|desc_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
name|iwn_free_rx_ring
argument_list|(
name|sc
argument_list|,
name|ring
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|void
name|iwn_reset_rx_ring
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_rx_ring
modifier|*
name|ring
parameter_list|)
block|{
name|int
name|ntries
decl_stmt|;
name|iwn_mem_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_RX_CONFIG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|100
condition|;
name|ntries
operator|++
control|)
block|{
if|if
condition|(
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_RX_STATUS
argument_list|)
operator|&
name|IWN_RX_IDLE
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IWN_DEBUG
if|if
condition|(
name|ntries
operator|==
literal|100
condition|)
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_ANY
argument_list|,
literal|"%s\n"
argument_list|,
literal|"timeout resetting Rx ring"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|iwn_mem_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ring
operator|->
name|cur
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|iwn_free_rx_ring
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_rx_ring
modifier|*
name|ring
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|iwn_dma_contig_free
argument_list|(
operator|&
name|ring
operator|->
name|desc_dma
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWN_RX_RING_COUNT
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ring
operator|->
name|data
index|[
name|i
index|]
operator|.
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|ring
operator|->
name|data
index|[
name|i
index|]
operator|.
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|iwn_alloc_tx_ring
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_tx_ring
modifier|*
name|ring
parameter_list|,
name|int
name|qid
parameter_list|)
block|{
name|bus_size_t
name|size
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|ring
operator|->
name|qid
operator|=
name|qid
expr_stmt|;
name|ring
operator|->
name|queued
operator|=
literal|0
expr_stmt|;
name|ring
operator|->
name|cur
operator|=
literal|0
expr_stmt|;
name|size
operator|=
name|IWN_TX_RING_COUNT
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_tx_desc
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_dma_contig_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|ring
operator|->
name|desc_dma
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ring
operator|->
name|desc
argument_list|,
name|size
argument_list|,
name|IWN_RING_DMA_ALIGN
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not allocate tx ring DMA memory, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|size
operator|=
name|IWN_TX_RING_COUNT
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_tx_cmd
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_dma_contig_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|ring
operator|->
name|cmd_dma
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ring
operator|->
name|cmd
argument_list|,
name|size
argument_list|,
literal|4
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not allocate tx cmd DMA memory, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MCLBYTES
argument_list|,
name|IWN_MAX_SCATTER
operator|-
literal|1
argument_list|,
name|MCLBYTES
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|ring
operator|->
name|data_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: bus_dma_tag_create_failed, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWN_TX_RING_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|iwn_tx_data
modifier|*
name|data
init|=
operator|&
name|ring
operator|->
name|data
index|[
name|i
index|]
decl_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: bus_dmamap_create failed, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
name|fail
label|:
name|iwn_free_tx_ring
argument_list|(
name|sc
argument_list|,
name|ring
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|void
name|iwn_reset_tx_ring
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_tx_ring
modifier|*
name|ring
parameter_list|)
block|{
name|uint32_t
name|tmp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ntries
decl_stmt|;
name|iwn_mem_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_TX_CONFIG
argument_list|(
name|ring
operator|->
name|qid
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|20
condition|;
name|ntries
operator|++
control|)
block|{
name|tmp
operator|=
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_TX_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|&
name|IWN_TX_IDLE
argument_list|(
name|ring
operator|->
name|qid
argument_list|)
operator|)
operator|==
name|IWN_TX_IDLE
argument_list|(
name|ring
operator|->
name|qid
argument_list|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IWN_DEBUG
if|if
condition|(
name|ntries
operator|==
literal|20
condition|)
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"%s: timeout resetting Tx ring %d\n"
argument_list|,
name|__func__
argument_list|,
name|ring
operator|->
name|qid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|iwn_mem_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWN_TX_RING_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|iwn_tx_data
modifier|*
name|data
init|=
operator|&
name|ring
operator|->
name|data
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|data
operator|->
name|m
argument_list|)
expr_stmt|;
name|data
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|ring
operator|->
name|queued
operator|=
literal|0
expr_stmt|;
name|ring
operator|->
name|cur
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|iwn_free_tx_ring
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_tx_ring
modifier|*
name|ring
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|iwn_dma_contig_free
argument_list|(
operator|&
name|ring
operator|->
name|desc_dma
argument_list|)
expr_stmt|;
name|iwn_dma_contig_free
argument_list|(
operator|&
name|ring
operator|->
name|cmd_dma
argument_list|)
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|data
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWN_TX_RING_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|iwn_tx_data
modifier|*
name|data
init|=
operator|&
name|ring
operator|->
name|data
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|data
operator|->
name|m
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|struct
name|ieee80211_node
modifier|*
name|iwn_node_alloc
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
return|return
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_node
argument_list|)
argument_list|,
name|M_80211_NODE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|iwn_newassoc
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|isnew
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|ieee80211_amrr_node_init
argument_list|(
operator|&
name|IWN_VAP
argument_list|(
name|vap
argument_list|)
operator|->
name|iv_amrr
argument_list|,
operator|&
name|IWN_NODE
argument_list|(
name|ni
argument_list|)
operator|->
name|amn
argument_list|,
name|ni
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|iwn_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|int
name|error
init|=
name|ieee80211_media_change
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
comment|/* NB: only the fixed rate can change and that doesn't need a reset */
return|return
operator|(
name|error
operator|==
name|ENETRESET
condition|?
literal|0
else|:
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|iwn_newstate
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|enum
name|ieee80211_state
name|nstate
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
name|struct
name|iwn_vap
modifier|*
name|ivp
init|=
name|IWN_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_STATE
argument_list|,
literal|"%s: %s -> %s\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_state_name
index|[
name|vap
operator|->
name|iv_state
index|]
argument_list|,
name|ieee80211_state_name
index|[
name|nstate
index|]
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_timer_to
argument_list|)
expr_stmt|;
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_AUTH
operator|&&
name|vap
operator|->
name|iv_state
operator|!=
name|IEEE80211_S_AUTH
condition|)
block|{
comment|/* !AUTH -> AUTH requires adapter config */
name|error
operator|=
name|iwn_auth
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_RUN
operator|&&
name|vap
operator|->
name|iv_state
operator|!=
name|IEEE80211_S_RUN
condition|)
block|{
comment|/* 		 * !RUN -> RUN requires setting the association id 		 * which is done with a firmware cmd.  We also defer 		 * starting the timers until that work is done. 		 */
name|error
operator|=
name|iwn_run
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_RUN
condition|)
block|{
comment|/* 		 * RUN -> RUN transition; just restart the timers. 		 */
name|iwn_calib_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return
name|ivp
operator|->
name|iv_newstate
argument_list|(
name|vap
argument_list|,
name|nstate
argument_list|,
name|arg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Grab exclusive access to NIC memory.  */
end_comment

begin_function
name|void
name|iwn_mem_lock
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|tmp
decl_stmt|;
name|int
name|ntries
decl_stmt|;
name|tmp
operator|=
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_GPIO_CTL
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_GPIO_CTL
argument_list|,
name|tmp
operator||
name|IWN_GPIO_MAC
argument_list|)
expr_stmt|;
comment|/* spin until we actually get the lock */
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|1000
condition|;
name|ntries
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_GPIO_CTL
argument_list|)
operator|&
operator|(
name|IWN_GPIO_CLOCK
operator||
name|IWN_GPIO_SLEEP
operator|)
operator|)
operator|==
name|IWN_GPIO_CLOCK
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ntries
operator|==
literal|1000
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not lock memory\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Release lock on NIC memory.  */
end_comment

begin_function
name|void
name|iwn_mem_unlock
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|tmp
init|=
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_GPIO_CTL
argument_list|)
decl_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_GPIO_CTL
argument_list|,
name|tmp
operator|&
operator|~
name|IWN_GPIO_MAC
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint32_t
name|iwn_mem_read
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|)
block|{
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_READ_MEM_ADDR
argument_list|,
name|IWN_MEM_4
operator||
name|addr
argument_list|)
expr_stmt|;
return|return
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_READ_MEM_DATA
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|iwn_mem_write
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|data
parameter_list|)
block|{
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_WRITE_MEM_ADDR
argument_list|,
name|IWN_MEM_4
operator||
name|addr
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_WRITE_MEM_DATA
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|iwn_mem_write_region_4
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
specifier|const
name|uint32_t
modifier|*
name|data
parameter_list|,
name|int
name|wlen
parameter_list|)
block|{
for|for
control|(
init|;
name|wlen
operator|>
literal|0
condition|;
name|wlen
operator|--
operator|,
name|data
operator|++
operator|,
name|addr
operator|+=
literal|4
control|)
name|iwn_mem_write
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
operator|*
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|iwn_eeprom_lock
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|tmp
decl_stmt|;
name|int
name|ntries
decl_stmt|;
name|tmp
operator|=
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_HWCONFIG
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_HWCONFIG
argument_list|,
name|tmp
operator||
name|IWN_HW_EEPROM_LOCKED
argument_list|)
expr_stmt|;
comment|/* spin until we actually get the lock */
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|100
condition|;
name|ntries
operator|++
control|)
block|{
if|if
condition|(
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_HWCONFIG
argument_list|)
operator|&
name|IWN_HW_EEPROM_LOCKED
condition|)
return|return
literal|0
return|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
return|return
name|ETIMEDOUT
return|;
block|}
end_function

begin_function
name|void
name|iwn_eeprom_unlock
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|tmp
init|=
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_HWCONFIG
argument_list|)
decl_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_HWCONFIG
argument_list|,
name|tmp
operator|&
operator|~
name|IWN_HW_EEPROM_LOCKED
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read `len' bytes from the EEPROM.  We access the EEPROM through the MAC  * instead of using the traditional bit-bang method.  */
end_comment

begin_function
name|int
name|iwn_read_prom_data
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|uint8_t
modifier|*
name|out
init|=
name|data
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|int
name|ntries
decl_stmt|,
name|tmp
decl_stmt|;
name|iwn_mem_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
name|len
operator|-=
literal|2
operator|,
name|addr
operator|++
control|)
block|{
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_EEPROM_CTL
argument_list|,
name|addr
operator|<<
literal|2
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_EEPROM_CTL
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_EEPROM_CTL
argument_list|,
name|tmp
operator|&
operator|~
name|IWN_EEPROM_MSK
argument_list|)
expr_stmt|;
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|10
condition|;
name|ntries
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|val
operator|=
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_EEPROM_CTL
argument_list|)
operator|)
operator|&
name|IWN_EEPROM_READY
condition|)
break|break;
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ntries
operator|==
literal|10
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not read EEPROM\n"
argument_list|)
expr_stmt|;
return|return
name|ETIMEDOUT
return|;
block|}
operator|*
name|out
operator|++
operator|=
name|val
operator|>>
literal|16
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|1
condition|)
operator|*
name|out
operator|++
operator|=
name|val
operator|>>
literal|24
expr_stmt|;
block|}
name|iwn_mem_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * The firmware boot code is small and is intended to be copied directly into  * the NIC internal memory.  */
end_comment

begin_function
name|int
name|iwn_transfer_microcode
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|ucode
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|ntries
decl_stmt|;
name|size
operator|/=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|iwn_mem_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* copy microcode image into NIC memory */
name|iwn_mem_write_region_4
argument_list|(
name|sc
argument_list|,
name|IWN_MEM_UCODE_BASE
argument_list|,
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|ucode
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|iwn_mem_write
argument_list|(
name|sc
argument_list|,
name|IWN_MEM_UCODE_SRC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iwn_mem_write
argument_list|(
name|sc
argument_list|,
name|IWN_MEM_UCODE_DST
argument_list|,
name|IWN_FW_TEXT
argument_list|)
expr_stmt|;
name|iwn_mem_write
argument_list|(
name|sc
argument_list|,
name|IWN_MEM_UCODE_SIZE
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* run microcode */
name|iwn_mem_write
argument_list|(
name|sc
argument_list|,
name|IWN_MEM_UCODE_CTL
argument_list|,
name|IWN_UC_RUN
argument_list|)
expr_stmt|;
comment|/* wait for transfer to complete */
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|1000
condition|;
name|ntries
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|iwn_mem_read
argument_list|(
name|sc
argument_list|,
name|IWN_MEM_UCODE_CTL
argument_list|)
operator|&
name|IWN_UC_RUN
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ntries
operator|==
literal|1000
condition|)
block|{
name|iwn_mem_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not load boot firmware\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|ETIMEDOUT
return|;
block|}
name|iwn_mem_write
argument_list|(
name|sc
argument_list|,
name|IWN_MEM_UCODE_CTL
argument_list|,
name|IWN_UC_ENABLE
argument_list|)
expr_stmt|;
name|iwn_mem_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|iwn_load_firmware
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|fw_fp
operator|==
name|NULL
argument_list|,
operator|(
literal|"firmware already loaded"
operator|)
argument_list|)
expr_stmt|;
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* load firmware image from disk */
name|sc
operator|->
name|fw_fp
operator|=
name|firmware_get
argument_list|(
literal|"iwnfw"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|fw_fp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not load firmare image \"iwnfw\"\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
name|error
operator|=
literal|0
expr_stmt|;
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|iwn_transfer_firmware
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwn_dma_info
modifier|*
name|dma
init|=
operator|&
name|sc
operator|->
name|fw_dma
decl_stmt|;
specifier|const
name|struct
name|iwn_firmware_hdr
modifier|*
name|hdr
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|init_text
decl_stmt|,
modifier|*
name|init_data
decl_stmt|,
modifier|*
name|main_text
decl_stmt|,
modifier|*
name|main_data
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|boot_text
decl_stmt|;
name|uint32_t
name|init_textsz
decl_stmt|,
name|init_datasz
decl_stmt|,
name|main_textsz
decl_stmt|,
name|main_datasz
decl_stmt|;
name|uint32_t
name|boot_textsz
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
specifier|const
name|struct
name|firmware
modifier|*
name|fp
init|=
name|sc
operator|->
name|fw_fp
decl_stmt|;
comment|/* extract firmware header information */
if|if
condition|(
name|fp
operator|->
name|datasize
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_firmware_hdr
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: truncated firmware header: %zu bytes, expecting %zu\n"
argument_list|,
name|__func__
argument_list|,
name|fp
operator|->
name|datasize
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_firmware_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|hdr
operator|=
operator|(
specifier|const
expr|struct
name|iwn_firmware_hdr
operator|*
operator|)
name|fp
operator|->
name|data
expr_stmt|;
name|main_textsz
operator|=
name|le32toh
argument_list|(
name|hdr
operator|->
name|main_textsz
argument_list|)
expr_stmt|;
name|main_datasz
operator|=
name|le32toh
argument_list|(
name|hdr
operator|->
name|main_datasz
argument_list|)
expr_stmt|;
name|init_textsz
operator|=
name|le32toh
argument_list|(
name|hdr
operator|->
name|init_textsz
argument_list|)
expr_stmt|;
name|init_datasz
operator|=
name|le32toh
argument_list|(
name|hdr
operator|->
name|init_datasz
argument_list|)
expr_stmt|;
name|boot_textsz
operator|=
name|le32toh
argument_list|(
name|hdr
operator|->
name|boot_textsz
argument_list|)
expr_stmt|;
comment|/* sanity-check firmware segments sizes */
if|if
condition|(
name|main_textsz
operator|>
name|IWN_FW_MAIN_TEXT_MAXSZ
operator|||
name|main_datasz
operator|>
name|IWN_FW_MAIN_DATA_MAXSZ
operator|||
name|init_textsz
operator|>
name|IWN_FW_INIT_TEXT_MAXSZ
operator|||
name|init_datasz
operator|>
name|IWN_FW_INIT_DATA_MAXSZ
operator|||
name|boot_textsz
operator|>
name|IWN_FW_BOOT_TEXT_MAXSZ
operator|||
operator|(
name|boot_textsz
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: invalid firmware header, main [%d,%d], init [%d,%d] "
literal|"boot %d\n"
argument_list|,
name|__func__
argument_list|,
name|main_textsz
argument_list|,
name|main_datasz
argument_list|,
name|init_textsz
argument_list|,
name|init_datasz
argument_list|,
name|boot_textsz
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* check that all firmware segments are present */
if|if
condition|(
name|fp
operator|->
name|datasize
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_firmware_hdr
argument_list|)
operator|+
name|main_textsz
operator|+
name|main_datasz
operator|+
name|init_textsz
operator|+
name|init_datasz
operator|+
name|boot_textsz
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: firmware file too short: "
literal|"%zu bytes, main [%d, %d], init [%d,%d] boot %d\n"
argument_list|,
name|__func__
argument_list|,
name|fp
operator|->
name|datasize
argument_list|,
name|main_textsz
argument_list|,
name|main_datasz
argument_list|,
name|init_textsz
argument_list|,
name|init_datasz
argument_list|,
name|boot_textsz
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* get pointers to firmware segments */
name|main_text
operator|=
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
expr_stmt|;
name|main_data
operator|=
name|main_text
operator|+
name|main_textsz
expr_stmt|;
name|init_text
operator|=
name|main_data
operator|+
name|main_datasz
expr_stmt|;
name|init_data
operator|=
name|init_text
operator|+
name|init_textsz
expr_stmt|;
name|boot_text
operator|=
name|init_data
operator|+
name|init_datasz
expr_stmt|;
comment|/* copy initialization images into pre-allocated DMA-safe memory */
name|memcpy
argument_list|(
name|dma
operator|->
name|vaddr
argument_list|,
name|init_data
argument_list|,
name|init_datasz
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dma
operator|->
name|vaddr
operator|+
name|IWN_FW_INIT_DATA_MAXSZ
argument_list|,
name|init_text
argument_list|,
name|init_textsz
argument_list|)
expr_stmt|;
comment|/* tell adapter where to find initialization images */
name|iwn_mem_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwn_mem_write
argument_list|(
name|sc
argument_list|,
name|IWN_MEM_DATA_BASE
argument_list|,
name|dma
operator|->
name|paddr
operator|>>
literal|4
argument_list|)
expr_stmt|;
name|iwn_mem_write
argument_list|(
name|sc
argument_list|,
name|IWN_MEM_DATA_SIZE
argument_list|,
name|init_datasz
argument_list|)
expr_stmt|;
name|iwn_mem_write
argument_list|(
name|sc
argument_list|,
name|IWN_MEM_TEXT_BASE
argument_list|,
operator|(
name|dma
operator|->
name|paddr
operator|+
name|IWN_FW_INIT_DATA_MAXSZ
operator|)
operator|>>
literal|4
argument_list|)
expr_stmt|;
name|iwn_mem_write
argument_list|(
name|sc
argument_list|,
name|IWN_MEM_TEXT_SIZE
argument_list|,
name|init_textsz
argument_list|)
expr_stmt|;
name|iwn_mem_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* load firmware boot code */
name|error
operator|=
name|iwn_transfer_microcode
argument_list|(
name|sc
argument_list|,
name|boot_text
argument_list|,
name|boot_textsz
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not load boot firmware, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* now press "execute" ;-) */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_RESET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* wait at most one second for first alive notification */
name|error
operator|=
name|msleep
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|PCATCH
argument_list|,
literal|"iwninit"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* this isn't what was supposed to happen.. */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: timeout waiting for first alive notice, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* copy runtime images into pre-allocated DMA-safe memory */
name|memcpy
argument_list|(
name|dma
operator|->
name|vaddr
argument_list|,
name|main_data
argument_list|,
name|main_datasz
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dma
operator|->
name|vaddr
operator|+
name|IWN_FW_MAIN_DATA_MAXSZ
argument_list|,
name|main_text
argument_list|,
name|main_textsz
argument_list|)
expr_stmt|;
comment|/* tell adapter where to find runtime images */
name|iwn_mem_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwn_mem_write
argument_list|(
name|sc
argument_list|,
name|IWN_MEM_DATA_BASE
argument_list|,
name|dma
operator|->
name|paddr
operator|>>
literal|4
argument_list|)
expr_stmt|;
name|iwn_mem_write
argument_list|(
name|sc
argument_list|,
name|IWN_MEM_DATA_SIZE
argument_list|,
name|main_datasz
argument_list|)
expr_stmt|;
name|iwn_mem_write
argument_list|(
name|sc
argument_list|,
name|IWN_MEM_TEXT_BASE
argument_list|,
operator|(
name|dma
operator|->
name|paddr
operator|+
name|IWN_FW_MAIN_DATA_MAXSZ
operator|)
operator|>>
literal|4
argument_list|)
expr_stmt|;
name|iwn_mem_write
argument_list|(
name|sc
argument_list|,
name|IWN_MEM_TEXT_SIZE
argument_list|,
name|IWN_FW_UPDATED
operator||
name|main_textsz
argument_list|)
expr_stmt|;
name|iwn_mem_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* wait at most one second for second alive notification */
name|error
operator|=
name|msleep
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|PCATCH
argument_list|,
literal|"iwninit"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* this isn't what was supposed to happen.. */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: timeout waiting for second alive notice, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
return|return
literal|0
return|;
name|fail
label|:
return|return
name|error
return|;
block|}
end_function

begin_function
name|void
name|iwn_unload_firmware
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|fw_fp
operator|!=
name|NULL
condition|)
block|{
name|firmware_put
argument_list|(
name|sc
operator|->
name|fw_fp
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fw_fp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_timer_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|IWN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|calib_cnt
operator|&&
operator|--
name|sc
operator|->
name|calib_cnt
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s\n"
argument_list|,
literal|"send statistics request"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_GET_STATISTICS
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|calib_cnt
operator|=
literal|60
expr_stmt|;
comment|/* do calibration every 60s */
block|}
name|iwn_watchdog
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* NB: piggyback tx watchdog */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_timer_to
argument_list|,
name|hz
argument_list|,
name|iwn_timer_timeout
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_calib_reset
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_timer_to
argument_list|,
name|hz
argument_list|,
name|iwn_timer_timeout
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|calib_cnt
operator|=
literal|60
expr_stmt|;
comment|/* do calibration every 60s */
block|}
end_function

begin_function
name|void
name|iwn_ampdu_rx_start
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
name|desc
parameter_list|)
block|{
name|struct
name|iwn_rx_stat
modifier|*
name|stat
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RECV
argument_list|,
literal|"%s\n"
argument_list|,
literal|"received AMPDU stats"
argument_list|)
expr_stmt|;
comment|/* save Rx statistics, they will be used on IWN_AMPDU_RX_DONE */
name|stat
operator|=
operator|(
expr|struct
name|iwn_rx_stat
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sc
operator|->
name|last_rx_stat
argument_list|,
name|stat
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stat
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|last_rx_valid
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|maprate
parameter_list|(
name|int
name|iwnrate
parameter_list|)
block|{
switch|switch
condition|(
name|iwnrate
condition|)
block|{
comment|/* CCK rates */
case|case
literal|10
case|:
return|return
literal|2
return|;
case|case
literal|20
case|:
return|return
literal|4
return|;
case|case
literal|55
case|:
return|return
literal|11
return|;
case|case
literal|110
case|:
return|return
literal|22
return|;
comment|/* OFDM rates */
case|case
literal|0xd
case|:
return|return
literal|12
return|;
case|case
literal|0xf
case|:
return|return
literal|18
return|;
case|case
literal|0x5
case|:
return|return
literal|24
return|;
case|case
literal|0x7
case|:
return|return
literal|36
return|;
case|case
literal|0x9
case|:
return|return
literal|48
return|;
case|case
literal|0xb
case|:
return|return
literal|72
return|;
case|case
literal|0x1
case|:
return|return
literal|96
return|;
case|case
literal|0x3
case|:
return|return
literal|108
return|;
comment|/* XXX MCS */
block|}
comment|/* unknown rate: should not happen */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|iwn_rx_intr
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
name|desc
parameter_list|,
name|struct
name|iwn_rx_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|iwn_rx_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|rxq
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|mnew
decl_stmt|;
name|struct
name|iwn_rx_stat
modifier|*
name|stat
decl_stmt|;
name|caddr_t
name|head
decl_stmt|;
name|uint32_t
modifier|*
name|tail
decl_stmt|;
name|int8_t
name|rssi
decl_stmt|,
name|nf
decl_stmt|;
name|int
name|len
decl_stmt|,
name|error
decl_stmt|;
name|bus_addr_t
name|paddr
decl_stmt|;
if|if
condition|(
name|desc
operator|->
name|type
operator|==
name|IWN_AMPDU_RX_DONE
condition|)
block|{
comment|/* check for prior AMPDU_RX_START */
if|if
condition|(
operator|!
name|sc
operator|->
name|last_rx_valid
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_ANY
argument_list|,
literal|"%s: missing AMPDU_RX_START\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|last_rx_valid
operator|=
literal|0
expr_stmt|;
name|stat
operator|=
operator|&
name|sc
operator|->
name|last_rx_stat
expr_stmt|;
block|}
else|else
name|stat
operator|=
operator|(
expr|struct
name|iwn_rx_stat
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|stat
operator|->
name|cfg_phy_len
operator|>
name|IWN_STAT_MAXLEN
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: invalid rx statistic header, len %d\n"
argument_list|,
name|__func__
argument_list|,
name|stat
operator|->
name|cfg_phy_len
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|desc
operator|->
name|type
operator|==
name|IWN_AMPDU_RX_DONE
condition|)
block|{
name|struct
name|iwn_rx_ampdu
modifier|*
name|ampdu
init|=
operator|(
expr|struct
name|iwn_rx_ampdu
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
decl_stmt|;
name|head
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|ampdu
operator|+
literal|1
argument_list|)
expr_stmt|;
name|len
operator|=
name|le16toh
argument_list|(
name|ampdu
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|head
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|stat
operator|+
literal|1
argument_list|)
operator|+
name|stat
operator|->
name|cfg_phy_len
expr_stmt|;
name|len
operator|=
name|le16toh
argument_list|(
name|stat
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* discard Rx frames with bad CRC early */
name|tail
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|head
operator|+
name|len
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|le32toh
argument_list|(
operator|*
name|tail
argument_list|)
operator|&
name|IWN_RX_NOERROR
operator|)
operator|!=
name|IWN_RX_NOERROR
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RECV
argument_list|,
literal|"%s: rx flags error %x\n"
argument_list|,
name|__func__
argument_list|,
name|le32toh
argument_list|(
operator|*
name|tail
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RECV
argument_list|,
literal|"%s: frame too short: %d\n"
argument_list|,
name|__func__
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
comment|/* XXX don't need mbuf, just dma buffer */
name|mnew
operator|=
name|m_getjcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|MJUMPAGESIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mnew
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_ANY
argument_list|,
literal|"%s: no mbuf to restock ring\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|mtod
argument_list|(
name|mnew
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|MJUMPAGESIZE
argument_list|,
name|iwn_dma_map_addr
argument_list|,
operator|&
name|paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|EFBIG
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: bus_dmamap_load failed, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mnew
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* finalize mbuf and swap in new one */
name|m
operator|=
name|data
operator|->
name|m
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_data
operator|=
name|head
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|data
operator|->
name|m
operator|=
name|mnew
expr_stmt|;
comment|/* update Rx descriptor */
name|ring
operator|->
name|desc
index|[
name|ring
operator|->
name|cur
index|]
operator|=
name|htole32
argument_list|(
name|paddr
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|rssi
operator|=
name|iwn_get_rssi
argument_list|(
name|sc
argument_list|,
name|stat
argument_list|)
expr_stmt|;
comment|/* grab a reference to the source node */
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|ni
operator|=
name|ieee80211_find_rxnode
argument_list|(
name|ic
argument_list|,
operator|(
expr|struct
name|ieee80211_frame_min
operator|*
operator|)
name|wh
argument_list|)
expr_stmt|;
name|nf
operator|=
operator|(
name|ni
operator|!=
name|NULL
operator|&&
name|ni
operator|->
name|ni_vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_RUN
operator|&&
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SCAN
operator|)
operator|==
literal|0
operator|)
condition|?
name|sc
operator|->
name|noise
else|:
operator|-
literal|95
expr_stmt|;
if|if
condition|(
name|bpf_peers_present
argument_list|(
name|ifp
operator|->
name|if_bpf
argument_list|)
condition|)
block|{
name|struct
name|iwn_rx_radiotap_header
modifier|*
name|tap
init|=
operator|&
name|sc
operator|->
name|sc_rxtap
decl_stmt|;
name|tap
operator|->
name|wr_flags
operator|=
literal|0
expr_stmt|;
name|tap
operator|->
name|wr_dbm_antsignal
operator|=
name|rssi
expr_stmt|;
name|tap
operator|->
name|wr_dbm_antnoise
operator|=
name|nf
expr_stmt|;
name|tap
operator|->
name|wr_rate
operator|=
name|maprate
argument_list|(
name|stat
operator|->
name|rate
argument_list|)
expr_stmt|;
name|tap
operator|->
name|wr_tsft
operator|=
name|htole64
argument_list|(
name|stat
operator|->
name|tstamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|->
name|flags
operator|&
name|htole16
argument_list|(
name|IWN_CONFIG_SHPREAMBLE
argument_list|)
condition|)
name|tap
operator|->
name|wr_flags
operator||=
name|IEEE80211_RADIOTAP_F_SHORTPRE
expr_stmt|;
name|bpf_mtap2
argument_list|(
name|ifp
operator|->
name|if_bpf
argument_list|,
name|tap
argument_list|,
name|sc
operator|->
name|sc_rxtap_len
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* send the frame to the 802.11 layer */
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|ieee80211_input
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
name|rssi
operator|-
name|nf
argument_list|,
name|nf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|ieee80211_input_all
argument_list|(
name|ic
argument_list|,
name|m
argument_list|,
name|rssi
operator|-
name|nf
argument_list|,
name|nf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|iwn_rx_statistics
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
name|desc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
name|struct
name|iwn_calib_state
modifier|*
name|calib
init|=
operator|&
name|sc
operator|->
name|calib
decl_stmt|;
name|struct
name|iwn_stats
modifier|*
name|stats
init|=
operator|(
expr|struct
name|iwn_stats
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
decl_stmt|;
comment|/* beacon stats are meaningful only when associated and not scanning */
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|!=
name|IEEE80211_S_RUN
operator|||
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SCAN
operator|)
condition|)
return|return;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s: cmd %d\n"
argument_list|,
name|__func__
argument_list|,
name|desc
operator|->
name|type
argument_list|)
expr_stmt|;
name|iwn_calib_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* test if temperature has changed */
if|if
condition|(
name|stats
operator|->
name|general
operator|.
name|temp
operator|!=
name|sc
operator|->
name|rawtemp
condition|)
block|{
name|int
name|temp
decl_stmt|;
name|sc
operator|->
name|rawtemp
operator|=
name|stats
operator|->
name|general
operator|.
name|temp
expr_stmt|;
name|temp
operator|=
name|iwn_get_temperature
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s: temperature %d\n"
argument_list|,
name|__func__
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* update Tx power if need be */
name|iwn_power_calibration
argument_list|(
name|sc
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|desc
operator|->
name|type
operator|!=
name|IWN_BEACON_STATISTICS
condition|)
return|return;
comment|/* reply to a statistics request */
name|sc
operator|->
name|noise
operator|=
name|iwn_get_noise
argument_list|(
operator|&
name|stats
operator|->
name|rx
operator|.
name|general
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s: noise %d\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|noise
argument_list|)
expr_stmt|;
comment|/* test that RSSI and noise are present in stats report */
if|if
condition|(
name|stats
operator|->
name|rx
operator|.
name|general
operator|.
name|flags
operator|!=
name|htole32
argument_list|(
literal|1
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_ANY
argument_list|,
literal|"%s\n"
argument_list|,
literal|"received statistics without RSSI"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|calib
operator|->
name|state
operator|==
name|IWN_CALIB_STATE_ASSOC
condition|)
name|iwn_compute_differential_gain
argument_list|(
name|sc
argument_list|,
operator|&
name|stats
operator|->
name|rx
operator|.
name|general
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|calib
operator|->
name|state
operator|==
name|IWN_CALIB_STATE_RUN
condition|)
name|iwn_tune_sensitivity
argument_list|(
name|sc
argument_list|,
operator|&
name|stats
operator|->
name|rx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|iwn_tx_intr
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
name|desc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|iwn_tx_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|txq
index|[
name|desc
operator|->
name|qid
operator|&
literal|0xf
index|]
decl_stmt|;
name|struct
name|iwn_tx_data
modifier|*
name|data
init|=
operator|&
name|ring
operator|->
name|data
index|[
name|desc
operator|->
name|idx
index|]
decl_stmt|;
name|struct
name|iwn_tx_stat
modifier|*
name|stat
init|=
operator|(
expr|struct
name|iwn_tx_stat
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
decl_stmt|;
name|struct
name|iwn_node
modifier|*
name|wn
init|=
name|IWN_NODE
argument_list|(
name|data
operator|->
name|ni
argument_list|)
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|KASSERT
argument_list|(
name|data
operator|->
name|ni
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no node"
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_XMIT
argument_list|,
literal|"%s: "
literal|"qid %d idx %d retries %d nkill %d rate %x duration %d status %x\n"
argument_list|,
name|__func__
argument_list|,
name|desc
operator|->
name|qid
argument_list|,
name|desc
operator|->
name|idx
argument_list|,
name|stat
operator|->
name|ntries
argument_list|,
name|stat
operator|->
name|nkill
argument_list|,
name|stat
operator|->
name|rate
argument_list|,
name|le16toh
argument_list|(
name|stat
operator|->
name|duration
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|stat
operator|->
name|status
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Update rate control statistics for the node. 	 */
name|status
operator|=
name|le32toh
argument_list|(
name|stat
operator|->
name|status
argument_list|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|0x80
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_ANY
argument_list|,
literal|"%s: status 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|le32toh
argument_list|(
name|stat
operator|->
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|ieee80211_amrr_tx_complete
argument_list|(
operator|&
name|wn
operator|->
name|amn
argument_list|,
name|IEEE80211_AMRR_FAILURE
argument_list|,
name|stat
operator|->
name|ntries
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ieee80211_amrr_tx_complete
argument_list|(
operator|&
name|wn
operator|->
name|amn
argument_list|,
name|IEEE80211_AMRR_SUCCESS
argument_list|,
name|stat
operator|->
name|ntries
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
name|m
operator|=
name|data
operator|->
name|m
operator|,
name|data
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|ni
operator|=
name|data
operator|->
name|ni
operator|,
name|data
operator|->
name|ni
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_TXCB
condition|)
block|{
comment|/* 		 * Channels marked for "radar" require traffic to be received 		 * to unlock before we can transmit.  Until traffic is seen 		 * any attempt to transmit is returned immediately with status 		 * set to IWN_TX_FAIL_TX_LOCKED.  Unfortunately this can easily 		 * happen on first authenticate after scanning.  To workaround 		 * this we ignore a failure of this sort in AUTH state so the 		 * 802.11 layer will fall back to using a timeout to wait for 		 * the AUTH reply.  This allows the firmware time to see 		 * traffic so a subsequent retry of AUTH succeeds.  It's 		 * unclear why the firmware does not maintain state for 		 * channels recently visited as this would allow immediate 		 * use of the channel after a scan (where we see traffic). 		 */
if|if
condition|(
name|status
operator|==
name|IWN_TX_FAIL_TX_LOCKED
operator|&&
name|ni
operator|->
name|ni_vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_AUTH
condition|)
name|ieee80211_process_callback
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|ieee80211_process_callback
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
operator|(
name|status
operator|&
name|IWN_TX_FAIL
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|ring
operator|->
name|queued
operator|--
expr_stmt|;
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|iwn_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|iwn_cmd_intr
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
name|desc
parameter_list|)
block|{
name|struct
name|iwn_tx_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|txq
index|[
literal|4
index|]
decl_stmt|;
name|struct
name|iwn_tx_data
modifier|*
name|data
decl_stmt|;
if|if
condition|(
operator|(
name|desc
operator|->
name|qid
operator|&
literal|0xf
operator|)
operator|!=
literal|4
condition|)
return|return;
comment|/* not a command ack */
name|data
operator|=
operator|&
name|ring
operator|->
name|data
index|[
name|desc
operator|->
name|idx
index|]
expr_stmt|;
comment|/* if the command was mapped in a mbuf, free it */
if|if
condition|(
name|data
operator|->
name|m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|data
operator|->
name|m
argument_list|)
expr_stmt|;
name|data
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
name|wakeup
argument_list|(
operator|&
name|ring
operator|->
name|cmd
index|[
name|desc
operator|->
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|iwn_notif_intr
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
name|uint16_t
name|hw
decl_stmt|;
name|hw
operator|=
name|le16toh
argument_list|(
name|sc
operator|->
name|shared
operator|->
name|closed_count
argument_list|)
operator|&
literal|0xfff
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|rxq
operator|.
name|cur
operator|!=
name|hw
condition|)
block|{
name|struct
name|iwn_rx_data
modifier|*
name|data
init|=
operator|&
name|sc
operator|->
name|rxq
operator|.
name|data
index|[
name|sc
operator|->
name|rxq
operator|.
name|cur
index|]
decl_stmt|;
name|struct
name|iwn_rx_desc
modifier|*
name|desc
init|=
operator|(
name|void
operator|*
operator|)
name|data
operator|->
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RECV
argument_list|,
literal|"%s: qid %x idx %d flags %x type %d(%s) len %d\n"
argument_list|,
name|__func__
argument_list|,
name|desc
operator|->
name|qid
argument_list|,
name|desc
operator|->
name|idx
argument_list|,
name|desc
operator|->
name|flags
argument_list|,
name|desc
operator|->
name|type
argument_list|,
name|iwn_intr_str
argument_list|(
name|desc
operator|->
name|type
argument_list|)
argument_list|,
name|le16toh
argument_list|(
name|desc
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|desc
operator|->
name|qid
operator|&
literal|0x80
operator|)
condition|)
comment|/* reply to a command */
name|iwn_cmd_intr
argument_list|(
name|sc
argument_list|,
name|desc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|desc
operator|->
name|type
condition|)
block|{
case|case
name|IWN_RX_DONE
case|:
case|case
name|IWN_AMPDU_RX_DONE
case|:
name|iwn_rx_intr
argument_list|(
name|sc
argument_list|,
name|desc
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|IWN_AMPDU_RX_START
case|:
name|iwn_ampdu_rx_start
argument_list|(
name|sc
argument_list|,
name|desc
argument_list|)
expr_stmt|;
break|break;
case|case
name|IWN_TX_DONE
case|:
comment|/* a 802.11 frame has been transmitted */
name|iwn_tx_intr
argument_list|(
name|sc
argument_list|,
name|desc
argument_list|)
expr_stmt|;
break|break;
case|case
name|IWN_RX_STATISTICS
case|:
case|case
name|IWN_BEACON_STATISTICS
case|:
name|iwn_rx_statistics
argument_list|(
name|sc
argument_list|,
name|desc
argument_list|)
expr_stmt|;
break|break;
case|case
name|IWN_BEACON_MISSED
case|:
block|{
name|struct
name|iwn_beacon_missed
modifier|*
name|miss
init|=
operator|(
expr|struct
name|iwn_beacon_missed
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
decl_stmt|;
name|int
name|misses
init|=
name|le32toh
argument_list|(
name|miss
operator|->
name|consecutive
argument_list|)
decl_stmt|;
comment|/* XXX not sure why we're notified w/ zero */
if|if
condition|(
name|misses
operator|==
literal|0
condition|)
break|break;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_STATE
argument_list|,
literal|"%s: beacons missed %d/%d\n"
argument_list|,
name|__func__
argument_list|,
name|misses
argument_list|,
name|le32toh
argument_list|(
name|miss
operator|->
name|total
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * If more than 5 consecutive beacons are missed, 			 * reinitialize the sensitivity state machine. 			 */
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_RUN
operator|&&
name|misses
operator|>
literal|5
condition|)
operator|(
name|void
operator|)
name|iwn_init_sensitivity
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|misses
operator|>=
name|vap
operator|->
name|iv_bmissthreshold
condition|)
name|ieee80211_beacon_miss
argument_list|(
name|ic
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IWN_UC_READY
case|:
block|{
name|struct
name|iwn_ucode_info
modifier|*
name|uc
init|=
operator|(
expr|struct
name|iwn_ucode_info
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
decl_stmt|;
comment|/* the microcontroller is ready */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"microcode alive notification version=%d.%d "
literal|"subtype=%x alive=%x\n"
argument_list|,
name|uc
operator|->
name|major
argument_list|,
name|uc
operator|->
name|minor
argument_list|,
name|uc
operator|->
name|subtype
argument_list|,
name|le32toh
argument_list|(
name|uc
operator|->
name|valid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|le32toh
argument_list|(
name|uc
operator|->
name|valid
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"microcontroller initialization failed"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|uc
operator|->
name|subtype
operator|==
name|IWN_UCODE_INIT
condition|)
block|{
comment|/* save microcontroller's report */
name|memcpy
argument_list|(
operator|&
name|sc
operator|->
name|ucode_info
argument_list|,
name|uc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|uc
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|IWN_STATE_CHANGED
case|:
block|{
name|uint32_t
modifier|*
name|status
init|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
decl_stmt|;
comment|/* 			 * State change allows hardware switch change to be 			 * noted. However, we handle this in iwn_intr as we 			 * get both the enable/disble intr. 			 */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_INTR
argument_list|,
literal|"state changed to %x\n"
argument_list|,
name|le32toh
argument_list|(
operator|*
name|status
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IWN_START_SCAN
case|:
block|{
name|struct
name|iwn_start_scan
modifier|*
name|scan
init|=
operator|(
expr|struct
name|iwn_start_scan
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_ANY
argument_list|,
literal|"%s: scanning channel %d status %x\n"
argument_list|,
name|__func__
argument_list|,
name|scan
operator|->
name|chan
argument_list|,
name|le32toh
argument_list|(
name|scan
operator|->
name|status
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IWN_STOP_SCAN
case|:
block|{
name|struct
name|iwn_stop_scan
modifier|*
name|scan
init|=
operator|(
expr|struct
name|iwn_stop_scan
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_STATE
argument_list|,
literal|"scan finished nchan=%d status=%d chan=%d\n"
argument_list|,
name|scan
operator|->
name|nchan
argument_list|,
name|scan
operator|->
name|status
argument_list|,
name|scan
operator|->
name|chan
argument_list|)
expr_stmt|;
name|ieee80211_scan_next
argument_list|(
name|vap
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|sc
operator|->
name|rxq
operator|.
name|cur
operator|=
operator|(
name|sc
operator|->
name|rxq
operator|.
name|cur
operator|+
literal|1
operator|)
operator|%
name|IWN_RX_RING_COUNT
expr_stmt|;
block|}
comment|/* tell the firmware what we have processed */
name|hw
operator|=
operator|(
name|hw
operator|==
literal|0
operator|)
condition|?
name|IWN_RX_RING_COUNT
operator|-
literal|1
else|:
name|hw
operator|-
literal|1
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_RX_WIDX
argument_list|,
name|hw
operator|&
operator|~
literal|7
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_rftoggle_intr
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|uint32_t
name|tmp
init|=
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_GPIO_CTL
argument_list|)
decl_stmt|;
name|IWN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"RF switch: radio %s\n"
argument_list|,
operator|(
name|tmp
operator|&
name|IWN_GPIO_RF_ENABLED
operator|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&
name|IWN_GPIO_RF_ENABLED
condition|)
name|ieee80211_runtask
argument_list|(
name|ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_radioon_task
argument_list|)
expr_stmt|;
else|else
name|ieee80211_runtask
argument_list|(
name|ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_radiooff_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_error_intr
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|r1
parameter_list|,
name|uint32_t
name|r2
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|IWN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"error, INTR=%b STATUS=0x%x\n"
argument_list|,
name|r1
argument_list|,
name|IWN_INTR_BITS
argument_list|,
name|r2
argument_list|)
expr_stmt|;
name|ieee80211_runtask
argument_list|(
name|ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_reinit_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|iwn_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|uint32_t
name|r1
decl_stmt|,
name|r2
decl_stmt|;
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* disable interrupts */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r1
operator|=
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_INTR
argument_list|)
expr_stmt|;
name|r2
operator|=
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_INTR_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|r1
operator|==
literal|0
operator|&&
name|r2
operator|==
literal|0
condition|)
block|{
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_MASK
argument_list|,
name|IWN_INTR_MASK
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
comment|/* not for us */
block|}
if|if
condition|(
name|r1
operator|==
literal|0xffffffff
condition|)
goto|goto
name|done
goto|;
comment|/* hardware gone */
comment|/* ack interrupts */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_INTR
argument_list|,
name|r1
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_INTR_STATUS
argument_list|,
name|r2
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_INTR
argument_list|,
literal|"interrupt reg1=%x reg2=%x\n"
argument_list|,
name|r1
argument_list|,
name|r2
argument_list|)
expr_stmt|;
if|if
condition|(
name|r1
operator|&
name|IWN_RF_TOGGLED
condition|)
name|iwn_rftoggle_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|r1
operator|&
name|IWN_CT_REACHED
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"critical temperature reached!\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r1
operator|&
operator|(
name|IWN_SW_ERROR
operator||
name|IWN_HW_ERROR
operator|)
condition|)
block|{
name|iwn_error_intr
argument_list|(
name|sc
argument_list|,
name|r1
argument_list|,
name|r2
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|(
name|r1
operator|&
operator|(
name|IWN_RX_INTR
operator||
name|IWN_SW_RX_INTR
operator|)
operator|)
operator|||
operator|(
name|r2
operator|&
name|IWN_RX_STATUS_INTR
operator|)
condition|)
name|iwn_notif_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|r1
operator|&
name|IWN_ALIVE_INTR
condition|)
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* re-enable interrupts */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_MASK
argument_list|,
name|IWN_INTR_MASK
argument_list|)
expr_stmt|;
name|done
label|:
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint8_t
name|iwn_plcp_signal
parameter_list|(
name|int
name|rate
parameter_list|)
block|{
switch|switch
condition|(
name|rate
condition|)
block|{
comment|/* CCK rates (returned values are device-dependent) */
case|case
literal|2
case|:
return|return
literal|10
return|;
case|case
literal|4
case|:
return|return
literal|20
return|;
case|case
literal|11
case|:
return|return
literal|55
return|;
case|case
literal|22
case|:
return|return
literal|110
return|;
comment|/* OFDM rates (cf IEEE Std 802.11a-1999, pp. 14 Table 80) */
comment|/* R1-R4, (u)ral is R4-R1 */
case|case
literal|12
case|:
return|return
literal|0xd
return|;
case|case
literal|18
case|:
return|return
literal|0xf
return|;
case|case
literal|24
case|:
return|return
literal|0x5
return|;
case|case
literal|36
case|:
return|return
literal|0x7
return|;
case|case
literal|48
case|:
return|return
literal|0x9
return|;
case|case
literal|72
case|:
return|return
literal|0xb
return|;
case|case
literal|96
case|:
return|return
literal|0x1
return|;
case|case
literal|108
case|:
return|return
literal|0x3
return|;
case|case
literal|120
case|:
return|return
literal|0x3
return|;
block|}
comment|/* unknown rate (should not get there) */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* determine if a given rate is CCK or OFDM */
end_comment

begin_define
define|#
directive|define
name|IWN_RATE_IS_OFDM
parameter_list|(
name|rate
parameter_list|)
value|((rate)>= 12&& (rate) != 22)
end_define

begin_function
name|int
name|iwn_tx_data
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|iwn_tx_ring
modifier|*
name|ring
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
specifier|const
name|struct
name|ieee80211_txparam
modifier|*
name|tp
decl_stmt|;
name|struct
name|iwn_tx_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|iwn_tx_data
modifier|*
name|data
decl_stmt|;
name|struct
name|iwn_tx_cmd
modifier|*
name|cmd
decl_stmt|;
name|struct
name|iwn_cmd_data
modifier|*
name|tx
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|struct
name|ieee80211_key
modifier|*
name|k
decl_stmt|;
name|bus_addr_t
name|paddr
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|uint16_t
name|timeout
decl_stmt|;
name|uint8_t
name|type
decl_stmt|;
name|u_int
name|hdrlen
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mnew
decl_stmt|;
name|int
name|rate
decl_stmt|,
name|error
decl_stmt|,
name|pad
decl_stmt|,
name|nsegs
decl_stmt|,
name|i
decl_stmt|,
name|ismcast
decl_stmt|,
name|id
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
name|IWN_MAX_SCATTER
index|]
decl_stmt|;
name|IWN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|type
operator|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
expr_stmt|;
name|ismcast
operator|=
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
expr_stmt|;
name|hdrlen
operator|=
name|ieee80211_anyhdrsize
argument_list|(
name|wh
argument_list|)
expr_stmt|;
comment|/* pick a tx rate */
comment|/* XXX ni_chan */
name|tp
operator|=
operator|&
name|vap
operator|->
name|iv_txparms
index|[
name|ieee80211_chan2mode
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|IEEE80211_FC0_TYPE_MGT
condition|)
name|rate
operator|=
name|tp
operator|->
name|mgmtrate
expr_stmt|;
elseif|else
if|if
condition|(
name|ismcast
condition|)
name|rate
operator|=
name|tp
operator|->
name|mcastrate
expr_stmt|;
elseif|else
if|if
condition|(
name|tp
operator|->
name|ucastrate
operator|!=
name|IEEE80211_FIXED_RATE_NONE
condition|)
name|rate
operator|=
name|tp
operator|->
name|ucastrate
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|ieee80211_amrr_choose
argument_list|(
name|ni
argument_list|,
operator|&
name|IWN_NODE
argument_list|(
name|ni
argument_list|)
operator|->
name|amn
argument_list|)
expr_stmt|;
name|rate
operator|=
name|ni
operator|->
name|ni_txrate
expr_stmt|;
block|}
if|if
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_WEP
condition|)
block|{
name|k
operator|=
name|ieee80211_crypto_encap
argument_list|(
name|ni
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
comment|/* packet header may have moved, reset our local pointer */
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
block|}
else|else
name|k
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bpf_peers_present
argument_list|(
name|ifp
operator|->
name|if_bpf
argument_list|)
condition|)
block|{
name|struct
name|iwn_tx_radiotap_header
modifier|*
name|tap
init|=
operator|&
name|sc
operator|->
name|sc_txtap
decl_stmt|;
name|tap
operator|->
name|wt_flags
operator|=
literal|0
expr_stmt|;
name|tap
operator|->
name|wt_rate
operator|=
name|rate
expr_stmt|;
if|if
condition|(
name|k
operator|!=
name|NULL
condition|)
name|tap
operator|->
name|wt_flags
operator||=
name|IEEE80211_RADIOTAP_F_WEP
expr_stmt|;
name|bpf_mtap2
argument_list|(
name|ifp
operator|->
name|if_bpf
argument_list|,
name|tap
argument_list|,
name|sc
operator|->
name|sc_txtap_len
argument_list|,
name|m0
argument_list|)
expr_stmt|;
block|}
name|flags
operator|=
name|IWN_TX_AUTO_SEQ
expr_stmt|;
comment|/* XXX honor ACM */
if|if
condition|(
operator|!
name|ismcast
condition|)
name|flags
operator||=
name|IWN_TX_NEED_ACK
expr_stmt|;
if|if
condition|(
name|ismcast
operator|||
name|type
operator|!=
name|IEEE80211_FC0_TYPE_DATA
condition|)
name|id
operator|=
name|IWN_ID_BROADCAST
expr_stmt|;
else|else
name|id
operator|=
name|IWN_ID_BSS
expr_stmt|;
comment|/* check if RTS/CTS or CTS-to-self protection must be used */
if|if
condition|(
operator|!
name|ismcast
condition|)
block|{
comment|/* multicast frames are not sent at OFDM rates in 802.11b/g */
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|+
name|IEEE80211_CRC_LEN
operator|>
name|vap
operator|->
name|iv_rtsthreshold
condition|)
block|{
name|flags
operator||=
name|IWN_TX_NEED_RTS
operator||
name|IWN_TX_FULL_TXOP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_USEPROT
operator|)
operator|&&
name|IWN_RATE_IS_OFDM
argument_list|(
name|rate
argument_list|)
condition|)
block|{
if|if
condition|(
name|ic
operator|->
name|ic_protmode
operator|==
name|IEEE80211_PROT_CTSONLY
condition|)
name|flags
operator||=
name|IWN_TX_NEED_CTS
operator||
name|IWN_TX_FULL_TXOP
expr_stmt|;
elseif|else
if|if
condition|(
name|ic
operator|->
name|ic_protmode
operator|==
name|IEEE80211_PROT_RTSCTS
condition|)
name|flags
operator||=
name|IWN_TX_NEED_RTS
operator||
name|IWN_TX_FULL_TXOP
expr_stmt|;
block|}
block|}
if|if
condition|(
name|type
operator|==
name|IEEE80211_FC0_TYPE_MGT
condition|)
block|{
name|uint8_t
name|subtype
init|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
decl_stmt|;
comment|/* tell h/w to set timestamp in probe responses */
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_PROBE_RESP
condition|)
name|flags
operator||=
name|IWN_TX_INSERT_TSTAMP
expr_stmt|;
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_ASSOC_REQ
operator|||
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_REASSOC_REQ
condition|)
name|timeout
operator|=
name|htole16
argument_list|(
literal|3
argument_list|)
expr_stmt|;
else|else
name|timeout
operator|=
name|htole16
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
name|timeout
operator|=
name|htole16
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdrlen
operator|&
literal|3
condition|)
block|{
comment|/* first segment's length must be a multiple of 4 */
name|flags
operator||=
name|IWN_TX_NEED_PADDING
expr_stmt|;
name|pad
operator|=
literal|4
operator|-
operator|(
name|hdrlen
operator|&
literal|3
operator|)
expr_stmt|;
block|}
else|else
name|pad
operator|=
literal|0
expr_stmt|;
name|desc
operator|=
operator|&
name|ring
operator|->
name|desc
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|data
operator|=
operator|&
name|ring
operator|->
name|data
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|cmd
operator|=
operator|&
name|ring
operator|->
name|cmd
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|cmd
operator|->
name|code
operator|=
name|IWN_CMD_TX_DATA
expr_stmt|;
name|cmd
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|qid
operator|=
name|ring
operator|->
name|qid
expr_stmt|;
name|cmd
operator|->
name|idx
operator|=
name|ring
operator|->
name|cur
expr_stmt|;
name|tx
operator|=
operator|(
expr|struct
name|iwn_cmd_data
operator|*
operator|)
name|cmd
operator|->
name|data
expr_stmt|;
comment|/* NB: no need to bzero tx, all fields are reinitialized here */
name|tx
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|tx
operator|->
name|flags
operator|=
name|htole32
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|tx
operator|->
name|len
operator|=
name|htole16
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|tx
operator|->
name|rate
operator|=
name|iwn_plcp_signal
argument_list|(
name|rate
argument_list|)
expr_stmt|;
name|tx
operator|->
name|rts_ntries
operator|=
literal|60
expr_stmt|;
comment|/* XXX? */
name|tx
operator|->
name|data_ntries
operator|=
literal|15
expr_stmt|;
comment|/* XXX? */
name|tx
operator|->
name|lifetime
operator|=
name|htole32
argument_list|(
name|IWN_LIFETIME_INFINITE
argument_list|)
expr_stmt|;
name|tx
operator|->
name|timeout
operator|=
name|timeout
expr_stmt|;
if|if
condition|(
name|k
operator|!=
name|NULL
condition|)
block|{
comment|/* XXX fill in */
empty_stmt|;
block|}
else|else
name|tx
operator|->
name|security
operator|=
literal|0
expr_stmt|;
comment|/* XXX alternate between Ant A and Ant B ? */
name|tx
operator|->
name|rflags
operator|=
name|IWN_RFLAG_ANT_B
expr_stmt|;
if|if
condition|(
name|tx
operator|->
name|id
operator|==
name|IWN_ID_BROADCAST
condition|)
block|{
name|tx
operator|->
name|ridx
operator|=
name|IWN_MAX_TX_RETRIES
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|IWN_RATE_IS_OFDM
argument_list|(
name|rate
argument_list|)
condition|)
name|tx
operator|->
name|rflags
operator||=
name|IWN_RFLAG_CCK
expr_stmt|;
block|}
else|else
block|{
name|tx
operator|->
name|ridx
operator|=
literal|0
expr_stmt|;
comment|/* tell adapter to ignore rflags */
name|tx
operator|->
name|flags
operator||=
name|htole32
argument_list|(
name|IWN_TX_USE_NODE_RATE
argument_list|)
expr_stmt|;
block|}
comment|/* copy and trim IEEE802.11 header */
name|memcpy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|tx
operator|+
literal|1
operator|)
argument_list|,
name|wh
argument_list|,
name|hdrlen
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m0
argument_list|,
name|hdrlen
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|m0
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|EFBIG
condition|)
block|{
comment|/* too many fragments, linearize */
name|mnew
operator|=
name|m_collapse
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|,
name|IWN_MAX_SCATTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|mnew
operator|==
name|NULL
condition|)
block|{
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not defrag mbuf\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|m0
operator|=
name|mnew
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|m0
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: bus_dmamap_load_mbuf_sg failed, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
name|data
operator|->
name|m
operator|=
name|m0
expr_stmt|;
name|data
operator|->
name|ni
operator|=
name|ni
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_XMIT
argument_list|,
literal|"%s: qid %d idx %d len %d nsegs %d\n"
argument_list|,
name|__func__
argument_list|,
name|ring
operator|->
name|qid
argument_list|,
name|ring
operator|->
name|cur
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
name|paddr
operator|=
name|ring
operator|->
name|cmd_dma
operator|.
name|paddr
operator|+
name|ring
operator|->
name|cur
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_tx_cmd
argument_list|)
expr_stmt|;
name|tx
operator|->
name|loaddr
operator|=
name|htole32
argument_list|(
name|paddr
operator|+
literal|4
operator|+
name|offsetof
argument_list|(
expr|struct
name|iwn_cmd_data
argument_list|,
name|ntries
argument_list|)
argument_list|)
expr_stmt|;
name|tx
operator|->
name|hiaddr
operator|=
literal|0
expr_stmt|;
comment|/* limit to 32-bit physical addresses */
comment|/* first scatter/gather segment is used by the tx data command */
name|IWN_SET_DESC_NSEGS
argument_list|(
name|desc
argument_list|,
literal|1
operator|+
name|nsegs
argument_list|)
expr_stmt|;
name|IWN_SET_DESC_SEG
argument_list|(
name|desc
argument_list|,
literal|0
argument_list|,
name|paddr
argument_list|,
literal|4
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|tx
argument_list|)
operator|+
name|hdrlen
operator|+
name|pad
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
name|IWN_SET_DESC_SEG
argument_list|(
name|desc
argument_list|,
name|i
argument_list|,
name|segs
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|ds_addr
argument_list|,
name|segs
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|shared
operator|->
name|len
index|[
name|ring
operator|->
name|qid
index|]
index|[
name|ring
operator|->
name|cur
index|]
operator|=
name|htole16
argument_list|(
name|hdrlen
operator|+
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|+
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|cur
operator|<
name|IWN_TX_WINDOW
condition|)
name|sc
operator|->
name|shared
operator|->
name|len
index|[
name|ring
operator|->
name|qid
index|]
index|[
name|ring
operator|->
name|cur
operator|+
name|IWN_TX_RING_COUNT
index|]
operator|=
name|htole16
argument_list|(
name|hdrlen
operator|+
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|+
literal|8
argument_list|)
expr_stmt|;
name|ring
operator|->
name|queued
operator|++
expr_stmt|;
comment|/* kick Tx ring */
name|ring
operator|->
name|cur
operator|=
operator|(
name|ring
operator|->
name|cur
operator|+
literal|1
operator|)
operator|%
name|IWN_TX_RING_COUNT
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_TX_WIDX
argument_list|,
name|ring
operator|->
name|qid
operator|<<
literal|8
operator||
name|ring
operator|->
name|cur
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|5
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|iwn_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwn_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|iwn_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|iwn_tx_ring
modifier|*
name|txq
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|pri
decl_stmt|;
name|IWN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|ni
operator|=
operator|(
expr|struct
name|ieee80211_node
operator|*
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
name|pri
operator|=
name|M_WME_GETAC
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|txq
operator|=
operator|&
name|sc
operator|->
name|txq
index|[
name|pri
index|]
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|queued
operator|>=
name|IWN_TX_RING_COUNT
operator|-
literal|8
condition|)
block|{
comment|/* XXX not right */
comment|/* ring is nearly full, stop flow */
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
block|}
if|if
condition|(
name|iwn_tx_data
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|ni
argument_list|,
name|txq
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_tx_handoff
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_tx_ring
modifier|*
name|ring
parameter_list|,
name|struct
name|iwn_tx_cmd
modifier|*
name|cmd
parameter_list|,
name|struct
name|iwn_cmd_data
modifier|*
name|tx
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|u_int
name|hdrlen
parameter_list|,
name|int
name|pad
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|iwn_tx_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|iwn_tx_data
modifier|*
name|data
decl_stmt|;
name|bus_addr_t
name|paddr
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mnew
decl_stmt|;
name|int
name|error
decl_stmt|,
name|nsegs
decl_stmt|,
name|i
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
name|IWN_MAX_SCATTER
index|]
decl_stmt|;
comment|/* copy and trim IEEE802.11 header */
name|memcpy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|tx
operator|+
literal|1
operator|)
argument_list|,
name|mtod
argument_list|(
name|m0
argument_list|,
name|uint8_t
operator|*
argument_list|)
argument_list|,
name|hdrlen
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m0
argument_list|,
name|hdrlen
argument_list|)
expr_stmt|;
name|desc
operator|=
operator|&
name|ring
operator|->
name|desc
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|data
operator|=
operator|&
name|ring
operator|->
name|data
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|m0
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|EFBIG
condition|)
block|{
comment|/* too many fragments, linearize */
name|mnew
operator|=
name|m_collapse
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|,
name|IWN_MAX_SCATTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|mnew
operator|==
name|NULL
condition|)
block|{
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not defrag mbuf\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|m0
operator|=
name|mnew
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|m0
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: bus_dmamap_load_mbuf_sg failed, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
name|data
operator|->
name|m
operator|=
name|m0
expr_stmt|;
name|data
operator|->
name|ni
operator|=
name|ni
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_XMIT
argument_list|,
literal|"%s: qid %d idx %d len %d nsegs %d\n"
argument_list|,
name|__func__
argument_list|,
name|ring
operator|->
name|qid
argument_list|,
name|ring
operator|->
name|cur
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
name|paddr
operator|=
name|ring
operator|->
name|cmd_dma
operator|.
name|paddr
operator|+
name|ring
operator|->
name|cur
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_tx_cmd
argument_list|)
expr_stmt|;
name|tx
operator|->
name|loaddr
operator|=
name|htole32
argument_list|(
name|paddr
operator|+
literal|4
operator|+
name|offsetof
argument_list|(
expr|struct
name|iwn_cmd_data
argument_list|,
name|ntries
argument_list|)
argument_list|)
expr_stmt|;
name|tx
operator|->
name|hiaddr
operator|=
literal|0
expr_stmt|;
comment|/* limit to 32-bit physical addresses */
comment|/* first scatter/gather segment is used by the tx data command */
name|IWN_SET_DESC_NSEGS
argument_list|(
name|desc
argument_list|,
literal|1
operator|+
name|nsegs
argument_list|)
expr_stmt|;
name|IWN_SET_DESC_SEG
argument_list|(
name|desc
argument_list|,
literal|0
argument_list|,
name|paddr
argument_list|,
literal|4
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|tx
argument_list|)
operator|+
name|hdrlen
operator|+
name|pad
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
name|IWN_SET_DESC_SEG
argument_list|(
name|desc
argument_list|,
name|i
argument_list|,
name|segs
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|ds_addr
argument_list|,
name|segs
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|shared
operator|->
name|len
index|[
name|ring
operator|->
name|qid
index|]
index|[
name|ring
operator|->
name|cur
index|]
operator|=
name|htole16
argument_list|(
name|hdrlen
operator|+
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|+
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|cur
operator|<
name|IWN_TX_WINDOW
condition|)
name|sc
operator|->
name|shared
operator|->
name|len
index|[
name|ring
operator|->
name|qid
index|]
index|[
name|ring
operator|->
name|cur
operator|+
name|IWN_TX_RING_COUNT
index|]
operator|=
name|htole16
argument_list|(
name|hdrlen
operator|+
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|+
literal|8
argument_list|)
expr_stmt|;
name|ring
operator|->
name|queued
operator|++
expr_stmt|;
comment|/* kick Tx ring */
name|ring
operator|->
name|cur
operator|=
operator|(
name|ring
operator|->
name|cur
operator|+
literal|1
operator|)
operator|%
name|IWN_TX_RING_COUNT
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_TX_WIDX
argument_list|,
name|ring
operator|->
name|qid
operator|<<
literal|8
operator||
name|ring
operator|->
name|cur
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|5
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_tx_data_raw
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|iwn_tx_ring
modifier|*
name|ring
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|iwn_tx_cmd
modifier|*
name|cmd
decl_stmt|;
name|struct
name|iwn_cmd_data
modifier|*
name|tx
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|uint8_t
name|type
decl_stmt|,
name|subtype
decl_stmt|;
name|u_int
name|hdrlen
decl_stmt|;
name|int
name|rate
decl_stmt|,
name|pad
decl_stmt|;
name|IWN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|type
operator|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
expr_stmt|;
name|subtype
operator|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
expr_stmt|;
name|hdrlen
operator|=
name|ieee80211_anyhdrsize
argument_list|(
name|wh
argument_list|)
expr_stmt|;
name|flags
operator|=
name|IWN_TX_AUTO_SEQ
expr_stmt|;
if|if
condition|(
operator|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_NOACK
operator|)
operator|==
literal|0
condition|)
name|flags
operator||=
name|IWN_TX_NEED_ACK
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_RTS
condition|)
name|flags
operator||=
name|IWN_TX_NEED_RTS
operator||
name|IWN_TX_FULL_TXOP
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_CTS
condition|)
name|flags
operator||=
name|IWN_TX_NEED_CTS
operator||
name|IWN_TX_FULL_TXOP
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|IEEE80211_FC0_TYPE_MGT
operator|&&
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_PROBE_RESP
condition|)
block|{
comment|/* tell h/w to set timestamp in probe responses */
name|flags
operator||=
name|IWN_TX_INSERT_TSTAMP
expr_stmt|;
block|}
if|if
condition|(
name|hdrlen
operator|&
literal|3
condition|)
block|{
comment|/* first segment's length must be a multiple of 4 */
name|flags
operator||=
name|IWN_TX_NEED_PADDING
expr_stmt|;
name|pad
operator|=
literal|4
operator|-
operator|(
name|hdrlen
operator|&
literal|3
operator|)
expr_stmt|;
block|}
else|else
name|pad
operator|=
literal|0
expr_stmt|;
comment|/* pick a tx rate */
name|rate
operator|=
name|params
operator|->
name|ibp_rate0
expr_stmt|;
if|if
condition|(
name|bpf_peers_present
argument_list|(
name|ifp
operator|->
name|if_bpf
argument_list|)
condition|)
block|{
name|struct
name|iwn_tx_radiotap_header
modifier|*
name|tap
init|=
operator|&
name|sc
operator|->
name|sc_txtap
decl_stmt|;
name|tap
operator|->
name|wt_flags
operator|=
literal|0
expr_stmt|;
name|tap
operator|->
name|wt_rate
operator|=
name|rate
expr_stmt|;
name|bpf_mtap2
argument_list|(
name|ifp
operator|->
name|if_bpf
argument_list|,
name|tap
argument_list|,
name|sc
operator|->
name|sc_txtap_len
argument_list|,
name|m0
argument_list|)
expr_stmt|;
block|}
name|cmd
operator|=
operator|&
name|ring
operator|->
name|cmd
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|cmd
operator|->
name|code
operator|=
name|IWN_CMD_TX_DATA
expr_stmt|;
name|cmd
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|qid
operator|=
name|ring
operator|->
name|qid
expr_stmt|;
name|cmd
operator|->
name|idx
operator|=
name|ring
operator|->
name|cur
expr_stmt|;
name|tx
operator|=
operator|(
expr|struct
name|iwn_cmd_data
operator|*
operator|)
name|cmd
operator|->
name|data
expr_stmt|;
comment|/* NB: no need to bzero tx, all fields are reinitialized here */
name|tx
operator|->
name|id
operator|=
name|IWN_ID_BROADCAST
expr_stmt|;
name|tx
operator|->
name|flags
operator|=
name|htole32
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|tx
operator|->
name|len
operator|=
name|htole16
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|tx
operator|->
name|rate
operator|=
name|iwn_plcp_signal
argument_list|(
name|rate
argument_list|)
expr_stmt|;
name|tx
operator|->
name|rts_ntries
operator|=
name|params
operator|->
name|ibp_try1
expr_stmt|;
comment|/* XXX? */
name|tx
operator|->
name|data_ntries
operator|=
name|params
operator|->
name|ibp_try0
expr_stmt|;
name|tx
operator|->
name|lifetime
operator|=
name|htole32
argument_list|(
name|IWN_LIFETIME_INFINITE
argument_list|)
expr_stmt|;
comment|/* XXX use try count? */
if|if
condition|(
name|type
operator|==
name|IEEE80211_FC0_TYPE_MGT
condition|)
block|{
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_ASSOC_REQ
operator|||
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_REASSOC_REQ
condition|)
name|tx
operator|->
name|timeout
operator|=
name|htole16
argument_list|(
literal|3
argument_list|)
expr_stmt|;
else|else
name|tx
operator|->
name|timeout
operator|=
name|htole16
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
name|tx
operator|->
name|timeout
operator|=
name|htole16
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|tx
operator|->
name|security
operator|=
literal|0
expr_stmt|;
comment|/* XXX alternate between Ant A and Ant B ? */
name|tx
operator|->
name|rflags
operator|=
name|IWN_RFLAG_ANT_B
expr_stmt|;
comment|/* XXX params->ibp_pri>> 2 */
name|tx
operator|->
name|ridx
operator|=
name|IWN_MAX_TX_RETRIES
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|IWN_RATE_IS_OFDM
argument_list|(
name|rate
argument_list|)
condition|)
name|tx
operator|->
name|rflags
operator||=
name|IWN_RFLAG_CCK
expr_stmt|;
return|return
name|iwn_tx_handoff
argument_list|(
name|sc
argument_list|,
name|ring
argument_list|,
name|cmd
argument_list|,
name|tx
argument_list|,
name|ni
argument_list|,
name|m0
argument_list|,
name|hdrlen
argument_list|,
name|pad
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_raw_xmit
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|iwn_tx_ring
modifier|*
name|txq
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|ENETDOWN
return|;
block|}
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|==
name|NULL
condition|)
name|txq
operator|=
operator|&
name|sc
operator|->
name|txq
index|[
name|M_WME_GETAC
argument_list|(
name|m
argument_list|)
index|]
expr_stmt|;
else|else
name|txq
operator|=
operator|&
name|sc
operator|->
name|txq
index|[
name|params
operator|->
name|ibp_pri
operator|&
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|queued
operator|>=
name|IWN_TX_RING_COUNT
operator|-
literal|8
condition|)
block|{
comment|/* XXX not right */
comment|/* ring is nearly full, stop flow */
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
block|}
if|if
condition|(
name|params
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Legacy path; interpret frame contents to decide 		 * precisely how to send the frame. 		 */
name|error
operator|=
name|iwn_tx_data
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|ni
argument_list|,
name|txq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Caller supplied explicit parameters to use in 		 * sending the frame. 		 */
name|error
operator|=
name|iwn_tx_data_raw
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|ni
argument_list|,
name|txq
argument_list|,
name|params
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* NB: m is reclaimed on tx failure */
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
block|}
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_watchdog
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_tx_timer
operator|>
literal|0
operator|&&
operator|--
name|sc
operator|->
name|sc_tx_timer
operator|==
literal|0
condition|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"device timeout\n"
argument_list|)
expr_stmt|;
name|ieee80211_runtask
argument_list|(
name|ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_reinit_task
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|iwn_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|startall
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|iwn_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|startall
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|iwn_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|startall
condition|)
name|ieee80211_start_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGIFMEDIA
case|:
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|ic
operator|->
name|ic_media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGIFADDR
case|:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
name|void
name|iwn_read_eeprom
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|char
name|domain
index|[
literal|4
index|]
decl_stmt|;
name|uint16_t
name|val
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_eeprom_lock
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not lock EEPROM, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* read and print regulatory domain */
name|iwn_read_prom_data
argument_list|(
name|sc
argument_list|,
name|IWN_EEPROM_DOMAIN
argument_list|,
name|domain
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Reg Domain: %.4s"
argument_list|,
name|domain
argument_list|)
expr_stmt|;
comment|/* read and print MAC address */
name|iwn_read_prom_data
argument_list|(
name|sc
argument_list|,
name|IWN_EEPROM_MAC
argument_list|,
name|macaddr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", address %6D\n"
argument_list|,
name|macaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
comment|/* read the list of authorized channels */
name|iwn_read_eeprom_channels
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* read maximum allowed Tx power for 2GHz and 5GHz bands */
name|iwn_read_prom_data
argument_list|(
name|sc
argument_list|,
name|IWN_EEPROM_MAXPOW
argument_list|,
operator|&
name|val
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|maxpwr2GHz
operator|=
name|val
operator|&
literal|0xff
expr_stmt|;
name|sc
operator|->
name|maxpwr5GHz
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
comment|/* check that EEPROM values are correct */
if|if
condition|(
name|sc
operator|->
name|maxpwr5GHz
operator|<
literal|20
operator|||
name|sc
operator|->
name|maxpwr5GHz
operator|>
literal|50
condition|)
name|sc
operator|->
name|maxpwr5GHz
operator|=
literal|38
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|maxpwr2GHz
operator|<
literal|20
operator|||
name|sc
operator|->
name|maxpwr2GHz
operator|>
literal|50
condition|)
name|sc
operator|->
name|maxpwr2GHz
operator|=
literal|38
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"maxpwr 2GHz=%d 5GHz=%d\n"
argument_list|,
name|sc
operator|->
name|maxpwr2GHz
argument_list|,
name|sc
operator|->
name|maxpwr5GHz
argument_list|)
expr_stmt|;
comment|/* read voltage at which samples were taken */
name|iwn_read_prom_data
argument_list|(
name|sc
argument_list|,
name|IWN_EEPROM_VOLTAGE
argument_list|,
operator|&
name|val
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|eeprom_voltage
operator|=
operator|(
name|int16_t
operator|)
name|le16toh
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"voltage=%d (in 0.3V)\n"
argument_list|,
name|sc
operator|->
name|eeprom_voltage
argument_list|)
expr_stmt|;
comment|/* read power groups */
name|iwn_read_prom_data
argument_list|(
name|sc
argument_list|,
name|IWN_EEPROM_BANDS
argument_list|,
name|sc
operator|->
name|bands
argument_list|,
sizeof|sizeof
name|sc
operator|->
name|bands
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IWN_DEBUG
if|if
condition|(
name|sc
operator|->
name|sc_debug
operator|&
name|IWN_DEBUG_ANY
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWN_NBANDS
condition|;
name|i
operator|++
control|)
name|iwn_print_power_group
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|iwn_eeprom_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|iwn_chan_band
block|{
name|uint32_t
name|addr
decl_stmt|;
comment|/* offset in EEPROM */
name|uint32_t
name|flags
decl_stmt|;
comment|/* net80211 flags */
name|uint8_t
name|nchan
decl_stmt|;
define|#
directive|define
name|IWN_MAX_CHAN_PER_BAND
value|14
name|uint8_t
name|chan
index|[
name|IWN_MAX_CHAN_PER_BAND
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|iwn_read_eeprom_band
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|iwn_chan_band
modifier|*
name|band
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|iwn_eeprom_chan
name|channels
index|[
name|IWN_MAX_CHAN_PER_BAND
index|]
decl_stmt|;
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|;
name|int
name|i
decl_stmt|,
name|chan
decl_stmt|,
name|flags
decl_stmt|;
name|iwn_read_prom_data
argument_list|(
name|sc
argument_list|,
name|band
operator|->
name|addr
argument_list|,
name|channels
argument_list|,
name|band
operator|->
name|nchan
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_eeprom_chan
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|band
operator|->
name|nchan
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|channels
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|IWN_EEPROM_CHAN_VALID
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"skip chan %d flags 0x%x maxpwr %d\n"
argument_list|,
name|band
operator|->
name|chan
index|[
name|i
index|]
argument_list|,
name|channels
index|[
name|i
index|]
operator|.
name|flags
argument_list|,
name|channels
index|[
name|i
index|]
operator|.
name|maxpwr
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|chan
operator|=
name|band
operator|->
name|chan
index|[
name|i
index|]
expr_stmt|;
comment|/* translate EEPROM flags to net80211 */
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|channels
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|IWN_EEPROM_CHAN_ACTIVE
operator|)
operator|==
literal|0
condition|)
name|flags
operator||=
name|IEEE80211_CHAN_PASSIVE
expr_stmt|;
if|if
condition|(
operator|(
name|channels
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|IWN_EEPROM_CHAN_IBSS
operator|)
operator|==
literal|0
condition|)
name|flags
operator||=
name|IEEE80211_CHAN_NOADHOC
expr_stmt|;
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|IWN_EEPROM_CHAN_RADAR
condition|)
block|{
name|flags
operator||=
name|IEEE80211_CHAN_DFS
expr_stmt|;
comment|/* XXX apparently IBSS may still be marked */
name|flags
operator||=
name|IEEE80211_CHAN_NOADHOC
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"add chan %d flags 0x%x maxpwr %d\n"
argument_list|,
name|chan
argument_list|,
name|channels
index|[
name|i
index|]
operator|.
name|flags
argument_list|,
name|channels
index|[
name|i
index|]
operator|.
name|maxpwr
argument_list|)
expr_stmt|;
name|c
operator|=
operator|&
name|ic
operator|->
name|ic_channels
index|[
name|ic
operator|->
name|ic_nchans
operator|++
index|]
expr_stmt|;
name|c
operator|->
name|ic_ieee
operator|=
name|chan
expr_stmt|;
name|c
operator|->
name|ic_freq
operator|=
name|ieee80211_ieee2mhz
argument_list|(
name|chan
argument_list|,
name|band
operator|->
name|flags
argument_list|)
expr_stmt|;
name|c
operator|->
name|ic_maxregpower
operator|=
name|channels
index|[
name|i
index|]
operator|.
name|maxpwr
expr_stmt|;
name|c
operator|->
name|ic_maxpower
operator|=
literal|2
operator|*
name|c
operator|->
name|ic_maxregpower
expr_stmt|;
if|if
condition|(
name|band
operator|->
name|flags
operator|&
name|IEEE80211_CHAN_2GHZ
condition|)
block|{
comment|/* G =>'s B is supported */
name|c
operator|->
name|ic_flags
operator|=
name|IEEE80211_CHAN_B
operator||
name|flags
expr_stmt|;
name|c
operator|=
operator|&
name|ic
operator|->
name|ic_channels
index|[
name|ic
operator|->
name|ic_nchans
operator|++
index|]
expr_stmt|;
name|c
index|[
literal|0
index|]
operator|=
name|c
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|c
operator|->
name|ic_flags
operator|=
name|IEEE80211_CHAN_G
operator||
name|flags
expr_stmt|;
block|}
else|else
block|{
comment|/* 5GHz band */
name|c
operator|->
name|ic_flags
operator|=
name|IEEE80211_CHAN_A
operator||
name|flags
expr_stmt|;
block|}
comment|/* XXX no constraints on using HT20 */
comment|/* add HT20, HT40 added separately */
name|c
operator|=
operator|&
name|ic
operator|->
name|ic_channels
index|[
name|ic
operator|->
name|ic_nchans
operator|++
index|]
expr_stmt|;
name|c
index|[
literal|0
index|]
operator|=
name|c
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|c
operator|->
name|ic_flags
operator||=
name|IEEE80211_CHAN_HT20
expr_stmt|;
comment|/* XXX NARROW =>'s 1/2 and 1/4 width? */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_read_eeprom_ht40
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|iwn_chan_band
modifier|*
name|band
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|iwn_eeprom_chan
name|channels
index|[
name|IWN_MAX_CHAN_PER_BAND
index|]
decl_stmt|;
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|,
modifier|*
name|cent
decl_stmt|,
modifier|*
name|extc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|iwn_read_prom_data
argument_list|(
name|sc
argument_list|,
name|band
operator|->
name|addr
argument_list|,
name|channels
argument_list|,
name|band
operator|->
name|nchan
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_eeprom_chan
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|band
operator|->
name|nchan
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|channels
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|IWN_EEPROM_CHAN_VALID
operator|)
operator|||
operator|!
operator|(
name|channels
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|IWN_EEPROM_CHAN_WIDE
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"skip chan %d flags 0x%x maxpwr %d\n"
argument_list|,
name|band
operator|->
name|chan
index|[
name|i
index|]
argument_list|,
name|channels
index|[
name|i
index|]
operator|.
name|flags
argument_list|,
name|channels
index|[
name|i
index|]
operator|.
name|maxpwr
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Each entry defines an HT40 channel pair; find the 		 * center channel, then the extension channel above. 		 */
name|cent
operator|=
name|ieee80211_find_channel_byieee
argument_list|(
name|ic
argument_list|,
name|band
operator|->
name|chan
index|[
name|i
index|]
argument_list|,
name|band
operator|->
name|flags
operator|&
operator|~
name|IEEE80211_CHAN_HT
argument_list|)
expr_stmt|;
if|if
condition|(
name|cent
operator|==
name|NULL
condition|)
block|{
comment|/* XXX shouldn't happen */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: no entry for channel %d\n"
argument_list|,
name|__func__
argument_list|,
name|band
operator|->
name|chan
index|[
name|i
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|extc
operator|=
name|ieee80211_find_channel
argument_list|(
name|ic
argument_list|,
name|cent
operator|->
name|ic_freq
operator|+
literal|20
argument_list|,
name|band
operator|->
name|flags
operator|&
operator|~
name|IEEE80211_CHAN_HT
argument_list|)
expr_stmt|;
if|if
condition|(
name|extc
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"skip chan %d, extension channel not found\n"
argument_list|,
name|band
operator|->
name|chan
index|[
name|i
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"add ht40 chan %d flags 0x%x maxpwr %d\n"
argument_list|,
name|band
operator|->
name|chan
index|[
name|i
index|]
argument_list|,
name|channels
index|[
name|i
index|]
operator|.
name|flags
argument_list|,
name|channels
index|[
name|i
index|]
operator|.
name|maxpwr
argument_list|)
expr_stmt|;
name|c
operator|=
operator|&
name|ic
operator|->
name|ic_channels
index|[
name|ic
operator|->
name|ic_nchans
operator|++
index|]
expr_stmt|;
name|c
index|[
literal|0
index|]
operator|=
name|cent
index|[
literal|0
index|]
expr_stmt|;
name|c
operator|->
name|ic_extieee
operator|=
name|extc
operator|->
name|ic_ieee
expr_stmt|;
name|c
operator|->
name|ic_flags
operator|&=
operator|~
name|IEEE80211_CHAN_HT
expr_stmt|;
name|c
operator|->
name|ic_flags
operator||=
name|IEEE80211_CHAN_HT40U
expr_stmt|;
name|c
operator|=
operator|&
name|ic
operator|->
name|ic_channels
index|[
name|ic
operator|->
name|ic_nchans
operator|++
index|]
expr_stmt|;
name|c
index|[
literal|0
index|]
operator|=
name|extc
index|[
literal|0
index|]
expr_stmt|;
name|c
operator|->
name|ic_extieee
operator|=
name|cent
operator|->
name|ic_ieee
expr_stmt|;
name|c
operator|->
name|ic_flags
operator|&=
operator|~
name|IEEE80211_CHAN_HT
expr_stmt|;
name|c
operator|->
name|ic_flags
operator||=
name|IEEE80211_CHAN_HT40D
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_read_eeprom_channels
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a)/sizeof(a[0]))
specifier|static
specifier|const
name|struct
name|iwn_chan_band
name|iwn_bands
index|[]
init|=
block|{
block|{
name|IWN_EEPROM_BAND1
block|,
name|IEEE80211_CHAN_G
block|,
literal|14
block|,
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|}
block|}
block|,
block|{
name|IWN_EEPROM_BAND2
block|,
name|IEEE80211_CHAN_A
block|,
literal|13
block|,
block|{
literal|183
block|,
literal|184
block|,
literal|185
block|,
literal|187
block|,
literal|188
block|,
literal|189
block|,
literal|192
block|,
literal|196
block|,
literal|7
block|,
literal|8
block|,
literal|11
block|,
literal|12
block|,
literal|16
block|}
block|}
block|,
block|{
name|IWN_EEPROM_BAND3
block|,
name|IEEE80211_CHAN_A
block|,
literal|12
block|,
block|{
literal|34
block|,
literal|36
block|,
literal|38
block|,
literal|40
block|,
literal|42
block|,
literal|44
block|,
literal|46
block|,
literal|48
block|,
literal|52
block|,
literal|56
block|,
literal|60
block|,
literal|64
block|}
block|}
block|,
block|{
name|IWN_EEPROM_BAND4
block|,
name|IEEE80211_CHAN_A
block|,
literal|11
block|,
block|{
literal|100
block|,
literal|104
block|,
literal|108
block|,
literal|112
block|,
literal|116
block|,
literal|120
block|,
literal|124
block|,
literal|128
block|,
literal|132
block|,
literal|136
block|,
literal|140
block|}
block|}
block|,
block|{
name|IWN_EEPROM_BAND5
block|,
name|IEEE80211_CHAN_A
block|,
literal|6
block|,
block|{
literal|145
block|,
literal|149
block|,
literal|153
block|,
literal|157
block|,
literal|161
block|,
literal|165
block|}
block|}
block|,
block|{
name|IWN_EEPROM_BAND6
block|,
name|IEEE80211_CHAN_G
operator||
name|IEEE80211_CHAN_HT40
block|,
literal|7
block|,
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|}
block|}
block|,
block|{
name|IWN_EEPROM_BAND7
block|,
name|IEEE80211_CHAN_A
operator||
name|IEEE80211_CHAN_HT40
block|,
literal|11
block|,
block|{
literal|36
block|,
literal|44
block|,
literal|52
block|,
literal|60
block|,
literal|100
block|,
literal|108
block|,
literal|116
block|,
literal|124
block|,
literal|132
block|,
literal|149
block|,
literal|157
block|}
block|}
block|}
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* read the list of authorized channels */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|iwn_bands
argument_list|)
operator|-
literal|2
condition|;
name|i
operator|++
control|)
name|iwn_read_eeprom_band
argument_list|(
name|sc
argument_list|,
operator|&
name|iwn_bands
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|N
argument_list|(
name|iwn_bands
argument_list|)
condition|;
name|i
operator|++
control|)
name|iwn_read_eeprom_ht40
argument_list|(
name|sc
argument_list|,
operator|&
name|iwn_bands
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ieee80211_sort_channels
argument_list|(
name|ic
operator|->
name|ic_channels
argument_list|,
name|ic
operator|->
name|ic_nchans
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|N
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IWN_DEBUG
end_ifdef

begin_function
name|void
name|iwn_print_power_group
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|struct
name|iwn_eeprom_band
modifier|*
name|band
init|=
operator|&
name|sc
operator|->
name|bands
index|[
name|i
index|]
decl_stmt|;
name|struct
name|iwn_eeprom_chan_samples
modifier|*
name|chans
init|=
name|band
operator|->
name|chans
decl_stmt|;
name|int
name|j
decl_stmt|,
name|c
decl_stmt|;
name|printf
argument_list|(
literal|"===band %d===\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"chan lo=%d, chan hi=%d\n"
argument_list|,
name|band
operator|->
name|lo
argument_list|,
name|band
operator|->
name|hi
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"chan1 num=%d\n"
argument_list|,
name|chans
index|[
literal|0
index|]
operator|.
name|num
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|IWN_NTXCHAINS
condition|;
name|c
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|IWN_NSAMPLES
condition|;
name|j
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"chain %d, sample %d: temp=%d gain=%d "
literal|"power=%d pa_det=%d\n"
argument_list|,
name|c
argument_list|,
name|j
argument_list|,
name|chans
index|[
literal|0
index|]
operator|.
name|samples
index|[
name|c
index|]
index|[
name|j
index|]
operator|.
name|temp
argument_list|,
name|chans
index|[
literal|0
index|]
operator|.
name|samples
index|[
name|c
index|]
index|[
name|j
index|]
operator|.
name|gain
argument_list|,
name|chans
index|[
literal|0
index|]
operator|.
name|samples
index|[
name|c
index|]
index|[
name|j
index|]
operator|.
name|power
argument_list|,
name|chans
index|[
literal|0
index|]
operator|.
name|samples
index|[
name|c
index|]
index|[
name|j
index|]
operator|.
name|pa_det
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"chan2 num=%d\n"
argument_list|,
name|chans
index|[
literal|1
index|]
operator|.
name|num
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|IWN_NTXCHAINS
condition|;
name|c
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|IWN_NSAMPLES
condition|;
name|j
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"chain %d, sample %d: temp=%d gain=%d "
literal|"power=%d pa_det=%d\n"
argument_list|,
name|c
argument_list|,
name|j
argument_list|,
name|chans
index|[
literal|1
index|]
operator|.
name|samples
index|[
name|c
index|]
index|[
name|j
index|]
operator|.
name|temp
argument_list|,
name|chans
index|[
literal|1
index|]
operator|.
name|samples
index|[
name|c
index|]
index|[
name|j
index|]
operator|.
name|gain
argument_list|,
name|chans
index|[
literal|1
index|]
operator|.
name|samples
index|[
name|c
index|]
index|[
name|j
index|]
operator|.
name|power
argument_list|,
name|chans
index|[
literal|1
index|]
operator|.
name|samples
index|[
name|c
index|]
index|[
name|j
index|]
operator|.
name|pa_det
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Send a command to the firmware.  */
end_comment

begin_function
name|int
name|iwn_cmd
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|code
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|async
parameter_list|)
block|{
name|struct
name|iwn_tx_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|txq
index|[
literal|4
index|]
decl_stmt|;
name|struct
name|iwn_tx_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|iwn_tx_cmd
modifier|*
name|cmd
decl_stmt|;
name|bus_addr_t
name|paddr
decl_stmt|;
name|IWN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|size
operator|<=
sizeof|sizeof
name|cmd
operator|->
name|data
argument_list|,
operator|(
literal|"Command too big"
operator|)
argument_list|)
expr_stmt|;
name|desc
operator|=
operator|&
name|ring
operator|->
name|desc
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|cmd
operator|=
operator|&
name|ring
operator|->
name|cmd
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|cmd
operator|->
name|code
operator|=
name|code
expr_stmt|;
name|cmd
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|qid
operator|=
name|ring
operator|->
name|qid
expr_stmt|;
name|cmd
operator|->
name|idx
operator|=
name|ring
operator|->
name|cur
expr_stmt|;
name|memcpy
argument_list|(
name|cmd
operator|->
name|data
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|paddr
operator|=
name|ring
operator|->
name|cmd_dma
operator|.
name|paddr
operator|+
name|ring
operator|->
name|cur
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_tx_cmd
argument_list|)
expr_stmt|;
name|IWN_SET_DESC_NSEGS
argument_list|(
name|desc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|IWN_SET_DESC_SEG
argument_list|(
name|desc
argument_list|,
literal|0
argument_list|,
name|paddr
argument_list|,
literal|4
operator|+
name|size
argument_list|)
expr_stmt|;
name|sc
operator|->
name|shared
operator|->
name|len
index|[
name|ring
operator|->
name|qid
index|]
index|[
name|ring
operator|->
name|cur
index|]
operator|=
name|htole16
argument_list|(
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|cur
operator|<
name|IWN_TX_WINDOW
condition|)
block|{
name|sc
operator|->
name|shared
operator|->
name|len
index|[
name|ring
operator|->
name|qid
index|]
index|[
name|ring
operator|->
name|cur
operator|+
name|IWN_TX_RING_COUNT
index|]
operator|=
name|htole16
argument_list|(
literal|8
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CMD
argument_list|,
literal|"%s: %s (0x%x) flags %d qid %d idx %d\n"
argument_list|,
name|__func__
argument_list|,
name|iwn_intr_str
argument_list|(
name|cmd
operator|->
name|code
argument_list|)
argument_list|,
name|cmd
operator|->
name|code
argument_list|,
name|cmd
operator|->
name|flags
argument_list|,
name|cmd
operator|->
name|qid
argument_list|,
name|cmd
operator|->
name|idx
argument_list|)
expr_stmt|;
comment|/* kick cmd ring */
name|ring
operator|->
name|cur
operator|=
operator|(
name|ring
operator|->
name|cur
operator|+
literal|1
operator|)
operator|%
name|IWN_TX_RING_COUNT
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_TX_WIDX
argument_list|,
name|ring
operator|->
name|qid
operator|<<
literal|8
operator||
name|ring
operator|->
name|cur
argument_list|)
expr_stmt|;
return|return
name|async
condition|?
literal|0
else|:
name|msleep
argument_list|(
name|cmd
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|PCATCH
argument_list|,
literal|"iwncmd"
argument_list|,
name|hz
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|uint8_t
name|iwn_ridx_to_plcp
index|[]
init|=
block|{
literal|10
block|,
literal|20
block|,
literal|55
block|,
literal|110
block|,
comment|/* CCK */
literal|0xd
block|,
literal|0xf
block|,
literal|0x5
block|,
literal|0x7
block|,
literal|0x9
block|,
literal|0xb
block|,
literal|0x1
block|,
literal|0x3
block|,
literal|0x3
comment|/* OFDM R1-R4 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint8_t
name|iwn_siso_mcs_to_plcp
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* CCK */
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
comment|/* HT */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint8_t
name|iwn_mimo_mcs_to_plcp
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* CCK */
literal|8
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
comment|/* HT */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint8_t
name|iwn_prev_ridx
index|[]
init|=
block|{
comment|/* NB: allow fallback from CCK11 to OFDM9 and from OFDM6 to CCK5 */
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|5
block|,
comment|/* CCK */
literal|2
block|,
literal|4
block|,
literal|3
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|10
comment|/* OFDM */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Configure hardware link parameters for the specified  * node operating on the specified channel.  */
end_comment

begin_function
name|int
name|iwn_set_link_quality
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|id
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|,
name|int
name|async
parameter_list|)
block|{
name|struct
name|iwn_cmd_link_quality
name|lq
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ridx
decl_stmt|;
name|memset
argument_list|(
operator|&
name|lq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|lq
argument_list|)
argument_list|)
expr_stmt|;
name|lq
operator|.
name|id
operator|=
name|id
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|lq
operator|.
name|mimo
operator|=
literal|1
expr_stmt|;
name|lq
operator|.
name|ssmask
operator|=
literal|0x1
expr_stmt|;
block|}
else|else
name|lq
operator|.
name|ssmask
operator|=
literal|0x2
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|IWN_ID_BSS
condition|)
name|ridx
operator|=
name|IWN_RATE_OFDM54
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_A
argument_list|(
name|c
argument_list|)
condition|)
name|ridx
operator|=
name|IWN_RATE_OFDM6
expr_stmt|;
else|else
name|ridx
operator|=
name|IWN_RATE_CCK1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWN_MAX_TX_RETRIES
condition|;
name|i
operator|++
control|)
block|{
comment|/* XXX toggle antenna for retry patterns */
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|lq
operator|.
name|table
index|[
name|i
index|]
operator|.
name|rate
operator|=
name|iwn_mimo_mcs_to_plcp
index|[
name|ridx
index|]
operator||
name|IWN_RATE_MCS
expr_stmt|;
name|lq
operator|.
name|table
index|[
name|i
index|]
operator|.
name|rflags
operator|=
name|IWN_RFLAG_HT
operator||
name|IWN_RFLAG_HT40
operator||
name|IWN_RFLAG_ANT_A
expr_stmt|;
comment|/* XXX shortGI */
block|}
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_HT
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|lq
operator|.
name|table
index|[
name|i
index|]
operator|.
name|rate
operator|=
name|iwn_siso_mcs_to_plcp
index|[
name|ridx
index|]
operator||
name|IWN_RATE_MCS
expr_stmt|;
name|lq
operator|.
name|table
index|[
name|i
index|]
operator|.
name|rflags
operator|=
name|IWN_RFLAG_HT
operator||
name|IWN_RFLAG_ANT_A
expr_stmt|;
comment|/* XXX shortGI */
block|}
else|else
block|{
name|lq
operator|.
name|table
index|[
name|i
index|]
operator|.
name|rate
operator|=
name|iwn_ridx_to_plcp
index|[
name|ridx
index|]
expr_stmt|;
if|if
condition|(
name|ridx
operator|<=
name|IWN_RATE_CCK11
condition|)
name|lq
operator|.
name|table
index|[
name|i
index|]
operator|.
name|rflags
operator|=
name|IWN_RFLAG_CCK
expr_stmt|;
name|lq
operator|.
name|table
index|[
name|i
index|]
operator|.
name|rflags
operator||=
name|IWN_RFLAG_ANT_B
expr_stmt|;
block|}
name|ridx
operator|=
name|iwn_prev_ridx
index|[
name|ridx
index|]
expr_stmt|;
block|}
name|lq
operator|.
name|dsmask
operator|=
literal|0x3
expr_stmt|;
name|lq
operator|.
name|ampdu_disable
operator|=
literal|3
expr_stmt|;
name|lq
operator|.
name|ampdu_limit
operator|=
name|htole16
argument_list|(
literal|4000
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IWN_DEBUG
if|if
condition|(
name|sc
operator|->
name|sc_debug
operator|&
name|IWN_DEBUG_STATE
condition|)
block|{
name|printf
argument_list|(
literal|"%s: set link quality for node %d, mimo %d ssmask %d\n"
argument_list|,
name|__func__
argument_list|,
name|id
argument_list|,
name|lq
operator|.
name|mimo
argument_list|,
name|lq
operator|.
name|ssmask
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s:"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWN_MAX_TX_RETRIES
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %d:%x"
argument_list|,
name|lq
operator|.
name|table
index|[
name|i
index|]
operator|.
name|rate
argument_list|,
name|lq
operator|.
name|table
index|[
name|i
index|]
operator|.
name|rflags
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_TX_LINK_QUALITY
argument_list|,
operator|&
name|lq
argument_list|,
sizeof|sizeof
argument_list|(
name|lq
argument_list|)
argument_list|,
name|async
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * Install a pairwise key into the hardware.  */
end_comment

begin_endif
unit|int iwn_set_key(struct ieee80211com *ic, struct ieee80211_node *ni,     const struct ieee80211_key *k) { 	struct iwn_softc *sc = ic->ic_softc; 	struct iwn_node_info node;  	if (k->k_flags& IEEE80211_KEY_GROUP) 		return 0;  	memset(&node, 0, sizeof node);  	switch (k->k_cipher) { 	case IEEE80211_CIPHER_CCMP: 		node.security = htole16(IWN_CIPHER_CCMP); 		memcpy(node.key, k->k_key, k->k_len); 		break; 	default: 		return 0; 	}  	node.id = IWN_ID_BSS; 	IEEE80211_ADDR_COPY(node.macaddr, ni->ni_macaddr); 	node.control = IWN_NODE_UPDATE; 	node.flags = IWN_FLAG_SET_KEY;  	return iwn_cmd(sc, IWN_CMD_ADD_NODE,&node, sizeof node, 1); }
endif|#
directive|endif
end_endif

begin_function
name|int
name|iwn_wme_update
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
define|#
directive|define
name|IWN_EXP2
parameter_list|(
name|x
parameter_list|)
value|((1<< (x)) - 1)
comment|/* CWmin = 2^ECWmin - 1 */
define|#
directive|define
name|IWN_TXOP_TO_US
parameter_list|(
name|v
parameter_list|)
value|(v<<5)
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|iwn_edca_params
name|cmd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|flags
operator|=
name|htole32
argument_list|(
name|IWN_EDCA_UPDATE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WME_NUM_AC
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|wmeParams
modifier|*
name|wmep
init|=
operator|&
name|ic
operator|->
name|ic_wme
operator|.
name|wme_chanParams
operator|.
name|cap_wmeParams
index|[
name|i
index|]
decl_stmt|;
name|cmd
operator|.
name|ac
index|[
name|i
index|]
operator|.
name|aifsn
operator|=
name|wmep
operator|->
name|wmep_aifsn
expr_stmt|;
name|cmd
operator|.
name|ac
index|[
name|i
index|]
operator|.
name|cwmin
operator|=
name|htole16
argument_list|(
name|IWN_EXP2
argument_list|(
name|wmep
operator|->
name|wmep_logcwmin
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|ac
index|[
name|i
index|]
operator|.
name|cwmax
operator|=
name|htole16
argument_list|(
name|IWN_EXP2
argument_list|(
name|wmep
operator|->
name|wmep_logcwmax
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|ac
index|[
name|i
index|]
operator|.
name|txoplimit
operator|=
name|htole16
argument_list|(
name|IWN_TXOP_TO_US
argument_list|(
name|wmep
operator|->
name|wmep_txopLimit
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_EDCA_PARAMS
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
name|cmd
argument_list|,
literal|1
comment|/*async*/
argument_list|)
expr_stmt|;
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
undef|#
directive|undef
name|IWN_TXOP_TO_US
undef|#
directive|undef
name|IWN_EXP2
block|}
end_function

begin_function
name|void
name|iwn_set_led
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|which
parameter_list|,
name|uint8_t
name|off
parameter_list|,
name|uint8_t
name|on
parameter_list|)
block|{
name|struct
name|iwn_cmd_led
name|led
decl_stmt|;
name|led
operator|.
name|which
operator|=
name|which
expr_stmt|;
name|led
operator|.
name|unit
operator|=
name|htole32
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
comment|/* on/off in unit of 100ms */
name|led
operator|.
name|off
operator|=
name|off
expr_stmt|;
name|led
operator|.
name|on
operator|=
name|on
expr_stmt|;
operator|(
name|void
operator|)
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_SET_LED
argument_list|,
operator|&
name|led
argument_list|,
sizeof|sizeof
name|led
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the critical temperature at which the firmware will automatically stop  * the radio transmitter.  */
end_comment

begin_function
name|int
name|iwn_set_critical_temp
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwn_ucode_info
modifier|*
name|uc
init|=
operator|&
name|sc
operator|->
name|ucode_info
decl_stmt|;
name|struct
name|iwn_critical_temp
name|crit
decl_stmt|;
name|uint32_t
name|r1
decl_stmt|,
name|r2
decl_stmt|,
name|r3
decl_stmt|,
name|temp
decl_stmt|;
name|r1
operator|=
name|le32toh
argument_list|(
name|uc
operator|->
name|temp
index|[
literal|0
index|]
operator|.
name|chan20MHz
argument_list|)
expr_stmt|;
name|r2
operator|=
name|le32toh
argument_list|(
name|uc
operator|->
name|temp
index|[
literal|1
index|]
operator|.
name|chan20MHz
argument_list|)
expr_stmt|;
name|r3
operator|=
name|le32toh
argument_list|(
name|uc
operator|->
name|temp
index|[
literal|2
index|]
operator|.
name|chan20MHz
argument_list|)
expr_stmt|;
comment|/* inverse function of iwn_get_temperature() */
name|temp
operator|=
name|r2
operator|+
operator|(
name|IWN_CTOK
argument_list|(
literal|110
argument_list|)
operator|*
operator|(
name|r3
operator|-
name|r1
operator|)
operator|)
operator|/
literal|259
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_UCODE_CLR
argument_list|,
name|IWN_CTEMP_STOP_RF
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|crit
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|crit
argument_list|)
expr_stmt|;
name|crit
operator|.
name|tempR
operator|=
name|htole32
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"setting critical temp to %u\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
return|return
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_SET_CRITICAL_TEMP
argument_list|,
operator|&
name|crit
argument_list|,
sizeof|sizeof
name|crit
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|iwn_enable_tsf
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|iwn_cmd_tsf
name|tsf
decl_stmt|;
name|uint64_t
name|val
decl_stmt|,
name|mod
decl_stmt|;
name|memset
argument_list|(
operator|&
name|tsf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|tsf
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|tsf
operator|.
name|tstamp
argument_list|,
name|ni
operator|->
name|ni_tstamp
operator|.
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|tsf
operator|.
name|bintval
operator|=
name|htole16
argument_list|(
name|ni
operator|->
name|ni_intval
argument_list|)
expr_stmt|;
name|tsf
operator|.
name|lintval
operator|=
name|htole16
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* XXX all wrong */
comment|/* compute remaining time until next beacon */
name|val
operator|=
operator|(
name|uint64_t
operator|)
name|ni
operator|->
name|ni_intval
operator|*
literal|1024
expr_stmt|;
comment|/* msecs -> usecs */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_ANY
argument_list|,
literal|"%s: val = %ju %s\n"
argument_list|,
name|__func__
argument_list|,
name|val
argument_list|,
name|val
operator|==
literal|0
condition|?
literal|"correcting"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|val
operator|=
literal|1
expr_stmt|;
name|mod
operator|=
name|le64toh
argument_list|(
name|tsf
operator|.
name|tstamp
argument_list|)
operator|%
name|val
expr_stmt|;
name|tsf
operator|.
name|binitval
operator|=
name|htole32
argument_list|(
call|(
name|uint32_t
call|)
argument_list|(
name|val
operator|-
name|mod
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"TSF bintval=%u tstamp=%ju, init=%u\n"
argument_list|,
name|ni
operator|->
name|ni_intval
argument_list|,
name|le64toh
argument_list|(
name|tsf
operator|.
name|tstamp
argument_list|)
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|val
operator|-
name|mod
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_TSF
argument_list|,
operator|&
name|tsf
argument_list|,
sizeof|sizeof
name|tsf
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not enable TSF\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|iwn_power_calibration
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|temp
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
if|#
directive|if
literal|0
block|KASSERT(ic->ic_state == IEEE80211_S_RUN, ("not running"));
endif|#
directive|endif
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s: temperature %d->%d\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|temp
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* adjust Tx power if need be (delta>= 3°C) */
if|if
condition|(
name|abs
argument_list|(
name|temp
operator|-
name|sc
operator|->
name|temp
argument_list|)
operator|<
literal|3
condition|)
return|return;
name|sc
operator|->
name|temp
operator|=
name|temp
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s: set Tx power for channel %d\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_bsschan
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iwn_set_txpower
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_bsschan
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* just warn, too bad for the automatic calibration... */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not adjust Tx power\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Set Tx power for a given channel (each rate has its own power settings).  * This function takes into account the regulatory information from EEPROM,  * the current temperature and the current voltage.  */
end_comment

begin_function
name|int
name|iwn_set_txpower
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|ch
parameter_list|,
name|int
name|async
parameter_list|)
block|{
comment|/* fixed-point arithmetic division using a n-bit fractional part */
define|#
directive|define
name|fdivround
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|n
parameter_list|)
define|\
value|((((1<< n) * (a)) / (b) + (1<< n) / 2) / (1<< n))
comment|/* linear interpolation */
define|#
directive|define
name|interpolate
parameter_list|(
name|x
parameter_list|,
name|x1
parameter_list|,
name|y1
parameter_list|,
name|x2
parameter_list|,
name|y2
parameter_list|,
name|n
parameter_list|)
define|\
value|((y1) + fdivround(((int)(x) - (x1)) * ((y2) - (y1)), (x2) - (x1), n))
specifier|static
specifier|const
name|int
name|tdiv
index|[
name|IWN_NATTEN_GROUPS
index|]
init|=
block|{
literal|9
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|6
block|}
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|iwn_ucode_info
modifier|*
name|uc
init|=
operator|&
name|sc
operator|->
name|ucode_info
decl_stmt|;
name|struct
name|iwn_cmd_txpower
name|cmd
decl_stmt|;
name|struct
name|iwn_eeprom_chan_samples
modifier|*
name|chans
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|rf_gain
decl_stmt|,
modifier|*
name|dsp_gain
decl_stmt|;
name|int32_t
name|vdiff
decl_stmt|,
name|tdiff
decl_stmt|;
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|grp
decl_stmt|,
name|maxpwr
decl_stmt|;
name|u_int
name|chan
decl_stmt|;
comment|/* get channel number */
name|chan
operator|=
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|band
operator|=
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|ch
argument_list|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|cmd
operator|.
name|chan
operator|=
name|chan
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|maxpwr
operator|=
name|sc
operator|->
name|maxpwr5GHz
expr_stmt|;
name|rf_gain
operator|=
name|iwn_rf_gain_5ghz
expr_stmt|;
name|dsp_gain
operator|=
name|iwn_dsp_gain_5ghz
expr_stmt|;
block|}
else|else
block|{
name|maxpwr
operator|=
name|sc
operator|->
name|maxpwr2GHz
expr_stmt|;
name|rf_gain
operator|=
name|iwn_rf_gain_2ghz
expr_stmt|;
name|dsp_gain
operator|=
name|iwn_dsp_gain_2ghz
expr_stmt|;
block|}
comment|/* compute voltage compensation */
name|vdiff
operator|=
operator|(
operator|(
name|int32_t
operator|)
name|le32toh
argument_list|(
name|uc
operator|->
name|volt
argument_list|)
operator|-
name|sc
operator|->
name|eeprom_voltage
operator|)
operator|/
literal|7
expr_stmt|;
if|if
condition|(
name|vdiff
operator|>
literal|0
condition|)
name|vdiff
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|vdiff
argument_list|)
operator|>
literal|2
condition|)
name|vdiff
operator|=
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
operator||
name|IWN_DEBUG_TXPOW
argument_list|,
literal|"%s: voltage compensation=%d (UCODE=%d, EEPROM=%d)\n"
argument_list|,
name|__func__
argument_list|,
name|vdiff
argument_list|,
name|le32toh
argument_list|(
name|uc
operator|->
name|volt
argument_list|)
argument_list|,
name|sc
operator|->
name|eeprom_voltage
argument_list|)
expr_stmt|;
comment|/* get channel's attenuation group */
if|if
condition|(
name|chan
operator|<=
literal|20
condition|)
comment|/* 1-20 */
name|grp
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|chan
operator|<=
literal|43
condition|)
comment|/* 34-43 */
name|grp
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|chan
operator|<=
literal|70
condition|)
comment|/* 44-70 */
name|grp
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|chan
operator|<=
literal|124
condition|)
comment|/* 71-124 */
name|grp
operator|=
literal|2
expr_stmt|;
else|else
comment|/* 125-200 */
name|grp
operator|=
literal|3
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
operator||
name|IWN_DEBUG_TXPOW
argument_list|,
literal|"%s: chan %d, attenuation group=%d\n"
argument_list|,
name|__func__
argument_list|,
name|chan
argument_list|,
name|grp
argument_list|)
expr_stmt|;
comment|/* get channel's sub-band */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWN_NBANDS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|bands
index|[
name|i
index|]
operator|.
name|lo
operator|!=
literal|0
operator|&&
name|sc
operator|->
name|bands
index|[
name|i
index|]
operator|.
name|lo
operator|<=
name|chan
operator|&&
name|chan
operator|<=
name|sc
operator|->
name|bands
index|[
name|i
index|]
operator|.
name|hi
condition|)
break|break;
name|chans
operator|=
name|sc
operator|->
name|bands
index|[
name|i
index|]
operator|.
name|chans
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
operator||
name|IWN_DEBUG_TXPOW
argument_list|,
literal|"%s: chan %d sub-band=%d\n"
argument_list|,
name|__func__
argument_list|,
name|chan
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|IWN_NTXCHAINS
condition|;
name|c
operator|++
control|)
block|{
name|uint8_t
name|power
decl_stmt|,
name|gain
decl_stmt|,
name|temp
decl_stmt|;
name|int
name|maxchpwr
decl_stmt|,
name|pwr
decl_stmt|,
name|ridx
decl_stmt|,
name|idx
decl_stmt|;
name|power
operator|=
name|interpolate
argument_list|(
name|chan
argument_list|,
name|chans
index|[
literal|0
index|]
operator|.
name|num
argument_list|,
name|chans
index|[
literal|0
index|]
operator|.
name|samples
index|[
name|c
index|]
index|[
literal|1
index|]
operator|.
name|power
argument_list|,
name|chans
index|[
literal|1
index|]
operator|.
name|num
argument_list|,
name|chans
index|[
literal|1
index|]
operator|.
name|samples
index|[
name|c
index|]
index|[
literal|1
index|]
operator|.
name|power
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gain
operator|=
name|interpolate
argument_list|(
name|chan
argument_list|,
name|chans
index|[
literal|0
index|]
operator|.
name|num
argument_list|,
name|chans
index|[
literal|0
index|]
operator|.
name|samples
index|[
name|c
index|]
index|[
literal|1
index|]
operator|.
name|gain
argument_list|,
name|chans
index|[
literal|1
index|]
operator|.
name|num
argument_list|,
name|chans
index|[
literal|1
index|]
operator|.
name|samples
index|[
name|c
index|]
index|[
literal|1
index|]
operator|.
name|gain
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|temp
operator|=
name|interpolate
argument_list|(
name|chan
argument_list|,
name|chans
index|[
literal|0
index|]
operator|.
name|num
argument_list|,
name|chans
index|[
literal|0
index|]
operator|.
name|samples
index|[
name|c
index|]
index|[
literal|1
index|]
operator|.
name|temp
argument_list|,
name|chans
index|[
literal|1
index|]
operator|.
name|num
argument_list|,
name|chans
index|[
literal|1
index|]
operator|.
name|samples
index|[
name|c
index|]
index|[
literal|1
index|]
operator|.
name|temp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
operator||
name|IWN_DEBUG_TXPOW
argument_list|,
literal|"%s: Tx chain %d: power=%d gain=%d temp=%d\n"
argument_list|,
name|__func__
argument_list|,
name|c
argument_list|,
name|power
argument_list|,
name|gain
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* compute temperature compensation */
name|tdiff
operator|=
operator|(
operator|(
name|sc
operator|->
name|temp
operator|-
name|temp
operator|)
operator|*
literal|2
operator|)
operator|/
name|tdiv
index|[
name|grp
index|]
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
operator||
name|IWN_DEBUG_TXPOW
argument_list|,
literal|"%s: temperature compensation=%d (current=%d, EEPROM=%d)\n"
argument_list|,
name|__func__
argument_list|,
name|tdiff
argument_list|,
name|sc
operator|->
name|temp
argument_list|,
name|temp
argument_list|)
expr_stmt|;
for|for
control|(
name|ridx
operator|=
literal|0
init|;
name|ridx
operator|<=
name|IWN_RIDX_MAX
condition|;
name|ridx
operator|++
control|)
block|{
name|maxchpwr
operator|=
name|ch
operator|->
name|ic_maxpower
expr_stmt|;
if|if
condition|(
operator|(
name|ridx
operator|/
literal|8
operator|)
operator|&
literal|1
condition|)
block|{
comment|/* MIMO: decrease Tx power (-3dB) */
name|maxchpwr
operator|-=
literal|6
expr_stmt|;
block|}
name|pwr
operator|=
name|maxpwr
operator|-
literal|10
expr_stmt|;
comment|/* decrease power for highest OFDM rates */
if|if
condition|(
operator|(
name|ridx
operator|%
literal|8
operator|)
operator|==
literal|5
condition|)
comment|/* 48Mbit/s */
name|pwr
operator|-=
literal|5
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ridx
operator|%
literal|8
operator|)
operator|==
literal|6
condition|)
comment|/* 54Mbit/s */
name|pwr
operator|-=
literal|7
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ridx
operator|%
literal|8
operator|)
operator|==
literal|7
condition|)
comment|/* 60Mbit/s */
name|pwr
operator|-=
literal|10
expr_stmt|;
if|if
condition|(
name|pwr
operator|>
name|maxchpwr
condition|)
name|pwr
operator|=
name|maxchpwr
expr_stmt|;
name|idx
operator|=
name|gain
operator|-
operator|(
name|pwr
operator|-
name|power
operator|)
operator|-
name|tdiff
operator|-
name|vdiff
expr_stmt|;
if|if
condition|(
operator|(
name|ridx
operator|/
literal|8
operator|)
operator|&
literal|1
condition|)
comment|/* MIMO */
name|idx
operator|+=
operator|(
name|int32_t
operator|)
name|le32toh
argument_list|(
name|uc
operator|->
name|atten
index|[
name|grp
index|]
index|[
name|c
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|.
name|band
operator|==
literal|0
condition|)
name|idx
operator|+=
literal|9
expr_stmt|;
comment|/* 5GHz */
if|if
condition|(
name|ridx
operator|==
name|IWN_RIDX_MAX
condition|)
name|idx
operator|+=
literal|5
expr_stmt|;
comment|/* CCK */
comment|/* make sure idx stays in a valid range */
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
name|idx
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|idx
operator|>
name|IWN_MAX_PWR_INDEX
condition|)
name|idx
operator|=
name|IWN_MAX_PWR_INDEX
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
operator||
name|IWN_DEBUG_TXPOW
argument_list|,
literal|"%s: Tx chain %d, rate idx %d: power=%d\n"
argument_list|,
name|__func__
argument_list|,
name|c
argument_list|,
name|ridx
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|power
index|[
name|ridx
index|]
operator|.
name|rf_gain
index|[
name|c
index|]
operator|=
name|rf_gain
index|[
name|idx
index|]
expr_stmt|;
name|cmd
operator|.
name|power
index|[
name|ridx
index|]
operator|.
name|dsp_gain
index|[
name|c
index|]
operator|=
name|dsp_gain
index|[
name|idx
index|]
expr_stmt|;
block|}
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
operator||
name|IWN_DEBUG_TXPOW
argument_list|,
literal|"%s: set tx power for chan %d\n"
argument_list|,
name|__func__
argument_list|,
name|chan
argument_list|)
expr_stmt|;
return|return
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_TXPOWER
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
name|cmd
argument_list|,
name|async
argument_list|)
return|;
undef|#
directive|undef
name|interpolate
undef|#
directive|undef
name|fdivround
block|}
end_function

begin_comment
comment|/*  * Get the best (maximum) RSSI among the  * connected antennas and convert to dBm.  */
end_comment

begin_function
name|int8_t
name|iwn_get_rssi
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|iwn_rx_stat
modifier|*
name|stat
parameter_list|)
block|{
name|int
name|mask
decl_stmt|,
name|agc
decl_stmt|,
name|rssi
decl_stmt|;
name|mask
operator|=
operator|(
name|le16toh
argument_list|(
name|stat
operator|->
name|antenna
argument_list|)
operator|>>
literal|4
operator|)
operator|&
literal|0x7
expr_stmt|;
name|agc
operator|=
operator|(
name|le16toh
argument_list|(
name|stat
operator|->
name|agc
argument_list|)
operator|>>
literal|7
operator|)
operator|&
literal|0x7f
expr_stmt|;
name|rssi
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
block|if (mask& (1<< 0))
comment|/* Ant A */
block|rssi = max(rssi, stat->rssi[0]); 	if (mask& (1<< 1))
comment|/* Ant B */
block|rssi = max(rssi, stat->rssi[2]); 	if (mask& (1<< 2))
comment|/* Ant C */
block|rssi = max(rssi, stat->rssi[4]);
else|#
directive|else
name|rssi
operator|=
name|max
argument_list|(
name|rssi
argument_list|,
name|stat
operator|->
name|rssi
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|rssi
operator|=
name|max
argument_list|(
name|rssi
argument_list|,
name|stat
operator|->
name|rssi
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|rssi
operator|=
name|max
argument_list|(
name|rssi
argument_list|,
name|stat
operator|->
name|rssi
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RECV
argument_list|,
literal|"%s: agc %d mask 0x%x rssi %d %d %d "
literal|"result %d\n"
argument_list|,
name|__func__
argument_list|,
name|agc
argument_list|,
name|mask
argument_list|,
name|stat
operator|->
name|rssi
index|[
literal|0
index|]
argument_list|,
name|stat
operator|->
name|rssi
index|[
literal|2
index|]
argument_list|,
name|stat
operator|->
name|rssi
index|[
literal|4
index|]
argument_list|,
name|rssi
operator|-
name|agc
operator|-
name|IWN_RSSI_TO_DBM
argument_list|)
expr_stmt|;
return|return
name|rssi
operator|-
name|agc
operator|-
name|IWN_RSSI_TO_DBM
return|;
block|}
end_function

begin_comment
comment|/*  * Get the average noise among Rx antennas (in dBm).  */
end_comment

begin_function
name|int
name|iwn_get_noise
parameter_list|(
specifier|const
name|struct
name|iwn_rx_general_stats
modifier|*
name|stats
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|total
decl_stmt|,
name|nbant
decl_stmt|,
name|noise
decl_stmt|;
name|total
operator|=
name|nbant
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|noise
operator|=
name|le32toh
argument_list|(
name|stats
operator|->
name|noise
index|[
name|i
index|]
argument_list|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|noise
operator|!=
literal|0
condition|)
block|{
name|total
operator|+=
name|noise
expr_stmt|;
name|nbant
operator|++
expr_stmt|;
block|}
block|}
comment|/* there should be at least one antenna but check anyway */
return|return
operator|(
name|nbant
operator|==
literal|0
operator|)
condition|?
operator|-
literal|127
else|:
operator|(
name|total
operator|/
name|nbant
operator|)
operator|-
literal|107
return|;
block|}
end_function

begin_comment
comment|/*  * Read temperature (in degC) from the on-board thermal sensor.  */
end_comment

begin_function
name|int
name|iwn_get_temperature
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwn_ucode_info
modifier|*
name|uc
init|=
operator|&
name|sc
operator|->
name|ucode_info
decl_stmt|;
name|int32_t
name|r1
decl_stmt|,
name|r2
decl_stmt|,
name|r3
decl_stmt|,
name|r4
decl_stmt|,
name|temp
decl_stmt|;
name|r1
operator|=
name|le32toh
argument_list|(
name|uc
operator|->
name|temp
index|[
literal|0
index|]
operator|.
name|chan20MHz
argument_list|)
expr_stmt|;
name|r2
operator|=
name|le32toh
argument_list|(
name|uc
operator|->
name|temp
index|[
literal|1
index|]
operator|.
name|chan20MHz
argument_list|)
expr_stmt|;
name|r3
operator|=
name|le32toh
argument_list|(
name|uc
operator|->
name|temp
index|[
literal|2
index|]
operator|.
name|chan20MHz
argument_list|)
expr_stmt|;
name|r4
operator|=
name|le32toh
argument_list|(
name|sc
operator|->
name|rawtemp
argument_list|)
expr_stmt|;
if|if
condition|(
name|r1
operator|==
name|r3
condition|)
comment|/* prevents division by 0 (should not happen) */
return|return
literal|0
return|;
comment|/* sign-extend 23-bit R4 value to 32-bit */
name|r4
operator|=
operator|(
name|r4
operator|<<
literal|8
operator|)
operator|>>
literal|8
expr_stmt|;
comment|/* compute temperature */
name|temp
operator|=
operator|(
literal|259
operator|*
operator|(
name|r4
operator|-
name|r2
operator|)
operator|)
operator|/
operator|(
name|r3
operator|-
name|r1
operator|)
expr_stmt|;
name|temp
operator|=
operator|(
name|temp
operator|*
literal|97
operator|)
operator|/
literal|100
operator|+
literal|8
expr_stmt|;
return|return
name|IWN_KTOC
argument_list|(
name|temp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize sensitivity calibration state machine.  */
end_comment

begin_function
name|int
name|iwn_init_sensitivity
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwn_calib_state
modifier|*
name|calib
init|=
operator|&
name|sc
operator|->
name|calib
decl_stmt|;
name|struct
name|iwn_phy_calib_cmd
name|cmd
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* reset calibration state */
name|memset
argument_list|(
name|calib
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|calib
argument_list|)
argument_list|)
expr_stmt|;
name|calib
operator|->
name|state
operator|=
name|IWN_CALIB_STATE_INIT
expr_stmt|;
name|calib
operator|->
name|cck_state
operator|=
name|IWN_CCK_STATE_HIFA
expr_stmt|;
comment|/* initial values taken from the reference driver */
name|calib
operator|->
name|corr_ofdm_x1
operator|=
literal|105
expr_stmt|;
name|calib
operator|->
name|corr_ofdm_mrc_x1
operator|=
literal|220
expr_stmt|;
name|calib
operator|->
name|corr_ofdm_x4
operator|=
literal|90
expr_stmt|;
name|calib
operator|->
name|corr_ofdm_mrc_x4
operator|=
literal|170
expr_stmt|;
name|calib
operator|->
name|corr_cck_x4
operator|=
literal|125
expr_stmt|;
name|calib
operator|->
name|corr_cck_mrc_x4
operator|=
literal|200
expr_stmt|;
name|calib
operator|->
name|energy_cck
operator|=
literal|100
expr_stmt|;
comment|/* write initial sensitivity values */
name|error
operator|=
name|iwn_send_sensitivity
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|code
operator|=
name|IWN_SET_DIFF_GAIN
expr_stmt|;
comment|/* differential gains initially set to 0 for all 3 antennas */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s: calibrate phy\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_PHY_CALIB
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
name|cmd
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Collect noise and RSSI statistics for the first 20 beacons received  * after association and use them to determine connected antennas and  * set differential gains.  */
end_comment

begin_function
name|void
name|iwn_compute_differential_gain
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|iwn_rx_general_stats
modifier|*
name|stats
parameter_list|)
block|{
name|struct
name|iwn_calib_state
modifier|*
name|calib
init|=
operator|&
name|sc
operator|->
name|calib
decl_stmt|;
name|struct
name|iwn_phy_calib_cmd
name|cmd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|val
decl_stmt|;
comment|/* accumulate RSSI and noise for all 3 antennas */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|calib
operator|->
name|rssi
index|[
name|i
index|]
operator|+=
name|le32toh
argument_list|(
name|stats
operator|->
name|rssi
index|[
name|i
index|]
argument_list|)
operator|&
literal|0xff
expr_stmt|;
name|calib
operator|->
name|noise
index|[
name|i
index|]
operator|+=
name|le32toh
argument_list|(
name|stats
operator|->
name|noise
index|[
name|i
index|]
argument_list|)
operator|&
literal|0xff
expr_stmt|;
block|}
comment|/* we update differential gain only once after 20 beacons */
if|if
condition|(
operator|++
name|calib
operator|->
name|nbeacons
operator|<
literal|20
condition|)
return|return;
comment|/* determine antenna with highest average RSSI */
name|val
operator|=
name|max
argument_list|(
name|calib
operator|->
name|rssi
index|[
literal|0
index|]
argument_list|,
name|calib
operator|->
name|rssi
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|val
operator|=
name|max
argument_list|(
name|calib
operator|->
name|rssi
index|[
literal|2
index|]
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* determine which antennas are connected */
name|sc
operator|->
name|antmsk
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|val
operator|-
name|calib
operator|->
name|rssi
index|[
name|i
index|]
operator|<=
literal|15
operator|*
literal|20
condition|)
name|sc
operator|->
name|antmsk
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
comment|/* if neither Ant A and Ant B are connected.. */
if|if
condition|(
operator|(
name|sc
operator|->
name|antmsk
operator|&
operator|(
literal|1
operator|<<
literal|0
operator||
literal|1
operator|<<
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|antmsk
operator||=
literal|1
operator|<<
literal|1
expr_stmt|;
comment|/* ..mark Ant B as connected! */
comment|/* get minimal noise among connected antennas */
name|val
operator|=
name|INT_MAX
expr_stmt|;
comment|/* ok, there's at least one */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|antmsk
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|val
operator|=
name|min
argument_list|(
name|calib
operator|->
name|noise
index|[
name|i
index|]
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|code
operator|=
name|IWN_SET_DIFF_GAIN
expr_stmt|;
comment|/* set differential gains for connected antennas */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|antmsk
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|cmd
operator|.
name|gain
index|[
name|i
index|]
operator|=
operator|(
name|calib
operator|->
name|noise
index|[
name|i
index|]
operator|-
name|val
operator|)
operator|/
literal|30
expr_stmt|;
comment|/* limit differential gain to 3 */
name|cmd
operator|.
name|gain
index|[
name|i
index|]
operator|=
name|min
argument_list|(
name|cmd
operator|.
name|gain
index|[
name|i
index|]
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|gain
index|[
name|i
index|]
operator||=
name|IWN_GAIN_SET
expr_stmt|;
block|}
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s: set differential gains Ant A/B/C: %x/%x/%x (%x)\n"
argument_list|,
name|__func__
argument_list|,
name|cmd
operator|.
name|gain
index|[
literal|0
index|]
argument_list|,
name|cmd
operator|.
name|gain
index|[
literal|1
index|]
argument_list|,
name|cmd
operator|.
name|gain
index|[
literal|2
index|]
argument_list|,
name|sc
operator|->
name|antmsk
argument_list|)
expr_stmt|;
if|if
condition|(
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_PHY_CALIB
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
name|cmd
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|calib
operator|->
name|state
operator|=
name|IWN_CALIB_STATE_RUN
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Tune RF Rx sensitivity based on the number of false alarms detected  * during the last beacon period.  */
end_comment

begin_function
name|void
name|iwn_tune_sensitivity
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|iwn_rx_stats
modifier|*
name|stats
parameter_list|)
block|{
define|#
directive|define
name|inc_clip
parameter_list|(
name|val
parameter_list|,
name|inc
parameter_list|,
name|max
parameter_list|)
define|\
value|if ((val)< (max)) {			\ 		if ((val)< (max) - (inc))	\ 			(val) += (inc);		\ 		else				\ 			(val) = (max);		\ 		needs_update = 1;		\ 	}
define|#
directive|define
name|dec_clip
parameter_list|(
name|val
parameter_list|,
name|dec
parameter_list|,
name|min
parameter_list|)
define|\
value|if ((val)> (min)) {			\ 		if ((val)> (min) + (dec))	\ 			(val) -= (dec);		\ 		else				\ 			(val) = (min);		\ 		needs_update = 1;		\ 	}
name|struct
name|iwn_calib_state
modifier|*
name|calib
init|=
operator|&
name|sc
operator|->
name|calib
decl_stmt|;
name|uint32_t
name|val
decl_stmt|,
name|rxena
decl_stmt|,
name|fa
decl_stmt|;
name|uint32_t
name|energy
index|[
literal|3
index|]
decl_stmt|,
name|energy_min
decl_stmt|;
name|uint8_t
name|noise
index|[
literal|3
index|]
decl_stmt|,
name|noise_ref
decl_stmt|;
name|int
name|i
decl_stmt|,
name|needs_update
init|=
literal|0
decl_stmt|;
comment|/* check that we've been enabled long enough */
if|if
condition|(
operator|(
name|rxena
operator|=
name|le32toh
argument_list|(
name|stats
operator|->
name|general
operator|.
name|load
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* compute number of false alarms since last call for OFDM */
name|fa
operator|=
name|le32toh
argument_list|(
name|stats
operator|->
name|ofdm
operator|.
name|bad_plcp
argument_list|)
operator|-
name|calib
operator|->
name|bad_plcp_ofdm
expr_stmt|;
name|fa
operator|+=
name|le32toh
argument_list|(
name|stats
operator|->
name|ofdm
operator|.
name|fa
argument_list|)
operator|-
name|calib
operator|->
name|fa_ofdm
expr_stmt|;
name|fa
operator|*=
literal|200
operator|*
literal|1024
expr_stmt|;
comment|/* 200TU */
comment|/* save counters values for next call */
name|calib
operator|->
name|bad_plcp_ofdm
operator|=
name|le32toh
argument_list|(
name|stats
operator|->
name|ofdm
operator|.
name|bad_plcp
argument_list|)
expr_stmt|;
name|calib
operator|->
name|fa_ofdm
operator|=
name|le32toh
argument_list|(
name|stats
operator|->
name|ofdm
operator|.
name|fa
argument_list|)
expr_stmt|;
if|if
condition|(
name|fa
operator|>
literal|50
operator|*
name|rxena
condition|)
block|{
comment|/* high false alarm count, decrease sensitivity */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s: OFDM high false alarm count: %u\n"
argument_list|,
name|__func__
argument_list|,
name|fa
argument_list|)
expr_stmt|;
name|inc_clip
argument_list|(
name|calib
operator|->
name|corr_ofdm_x1
argument_list|,
literal|1
argument_list|,
literal|140
argument_list|)
expr_stmt|;
name|inc_clip
argument_list|(
name|calib
operator|->
name|corr_ofdm_mrc_x1
argument_list|,
literal|1
argument_list|,
literal|270
argument_list|)
expr_stmt|;
name|inc_clip
argument_list|(
name|calib
operator|->
name|corr_ofdm_x4
argument_list|,
literal|1
argument_list|,
literal|120
argument_list|)
expr_stmt|;
name|inc_clip
argument_list|(
name|calib
operator|->
name|corr_ofdm_mrc_x4
argument_list|,
literal|1
argument_list|,
literal|210
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fa
operator|<
literal|5
operator|*
name|rxena
condition|)
block|{
comment|/* low false alarm count, increase sensitivity */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s: OFDM low false alarm count: %u\n"
argument_list|,
name|__func__
argument_list|,
name|fa
argument_list|)
expr_stmt|;
name|dec_clip
argument_list|(
name|calib
operator|->
name|corr_ofdm_x1
argument_list|,
literal|1
argument_list|,
literal|105
argument_list|)
expr_stmt|;
name|dec_clip
argument_list|(
name|calib
operator|->
name|corr_ofdm_mrc_x1
argument_list|,
literal|1
argument_list|,
literal|220
argument_list|)
expr_stmt|;
name|dec_clip
argument_list|(
name|calib
operator|->
name|corr_ofdm_x4
argument_list|,
literal|1
argument_list|,
literal|85
argument_list|)
expr_stmt|;
name|dec_clip
argument_list|(
name|calib
operator|->
name|corr_ofdm_mrc_x4
argument_list|,
literal|1
argument_list|,
literal|170
argument_list|)
expr_stmt|;
block|}
comment|/* compute maximum noise among 3 antennas */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|noise
index|[
name|i
index|]
operator|=
operator|(
name|le32toh
argument_list|(
name|stats
operator|->
name|general
operator|.
name|noise
index|[
name|i
index|]
argument_list|)
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|val
operator|=
name|max
argument_list|(
name|noise
index|[
literal|0
index|]
argument_list|,
name|noise
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|val
operator|=
name|max
argument_list|(
name|noise
index|[
literal|2
index|]
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* insert it into our samples table */
name|calib
operator|->
name|noise_samples
index|[
name|calib
operator|->
name|cur_noise_sample
index|]
operator|=
name|val
expr_stmt|;
name|calib
operator|->
name|cur_noise_sample
operator|=
operator|(
name|calib
operator|->
name|cur_noise_sample
operator|+
literal|1
operator|)
operator|%
literal|20
expr_stmt|;
comment|/* compute maximum noise among last 20 samples */
name|noise_ref
operator|=
name|calib
operator|->
name|noise_samples
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
name|noise_ref
operator|=
name|max
argument_list|(
name|noise_ref
argument_list|,
name|calib
operator|->
name|noise_samples
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* compute maximum energy among 3 antennas */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|energy
index|[
name|i
index|]
operator|=
name|le32toh
argument_list|(
name|stats
operator|->
name|general
operator|.
name|energy
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|val
operator|=
name|min
argument_list|(
name|energy
index|[
literal|0
index|]
argument_list|,
name|energy
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|val
operator|=
name|min
argument_list|(
name|energy
index|[
literal|2
index|]
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* insert it into our samples table */
name|calib
operator|->
name|energy_samples
index|[
name|calib
operator|->
name|cur_energy_sample
index|]
operator|=
name|val
expr_stmt|;
name|calib
operator|->
name|cur_energy_sample
operator|=
operator|(
name|calib
operator|->
name|cur_energy_sample
operator|+
literal|1
operator|)
operator|%
literal|10
expr_stmt|;
comment|/* compute minimum energy among last 10 samples */
name|energy_min
operator|=
name|calib
operator|->
name|energy_samples
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
name|energy_min
operator|=
name|max
argument_list|(
name|energy_min
argument_list|,
name|calib
operator|->
name|energy_samples
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|energy_min
operator|+=
literal|6
expr_stmt|;
comment|/* compute number of false alarms since last call for CCK */
name|fa
operator|=
name|le32toh
argument_list|(
name|stats
operator|->
name|cck
operator|.
name|bad_plcp
argument_list|)
operator|-
name|calib
operator|->
name|bad_plcp_cck
expr_stmt|;
name|fa
operator|+=
name|le32toh
argument_list|(
name|stats
operator|->
name|cck
operator|.
name|fa
argument_list|)
operator|-
name|calib
operator|->
name|fa_cck
expr_stmt|;
name|fa
operator|*=
literal|200
operator|*
literal|1024
expr_stmt|;
comment|/* 200TU */
comment|/* save counters values for next call */
name|calib
operator|->
name|bad_plcp_cck
operator|=
name|le32toh
argument_list|(
name|stats
operator|->
name|cck
operator|.
name|bad_plcp
argument_list|)
expr_stmt|;
name|calib
operator|->
name|fa_cck
operator|=
name|le32toh
argument_list|(
name|stats
operator|->
name|cck
operator|.
name|fa
argument_list|)
expr_stmt|;
if|if
condition|(
name|fa
operator|>
literal|50
operator|*
name|rxena
condition|)
block|{
comment|/* high false alarm count, decrease sensitivity */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s: CCK high false alarm count: %u\n"
argument_list|,
name|__func__
argument_list|,
name|fa
argument_list|)
expr_stmt|;
name|calib
operator|->
name|cck_state
operator|=
name|IWN_CCK_STATE_HIFA
expr_stmt|;
name|calib
operator|->
name|low_fa
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|calib
operator|->
name|corr_cck_x4
operator|>
literal|160
condition|)
block|{
name|calib
operator|->
name|noise_ref
operator|=
name|noise_ref
expr_stmt|;
if|if
condition|(
name|calib
operator|->
name|energy_cck
operator|>
literal|2
condition|)
name|dec_clip
argument_list|(
name|calib
operator|->
name|energy_cck
argument_list|,
literal|2
argument_list|,
name|energy_min
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|calib
operator|->
name|corr_cck_x4
operator|<
literal|160
condition|)
block|{
name|calib
operator|->
name|corr_cck_x4
operator|=
literal|161
expr_stmt|;
name|needs_update
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|inc_clip
argument_list|(
name|calib
operator|->
name|corr_cck_x4
argument_list|,
literal|3
argument_list|,
literal|200
argument_list|)
expr_stmt|;
name|inc_clip
argument_list|(
name|calib
operator|->
name|corr_cck_mrc_x4
argument_list|,
literal|3
argument_list|,
literal|400
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fa
operator|<
literal|5
operator|*
name|rxena
condition|)
block|{
comment|/* low false alarm count, increase sensitivity */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s: CCK low false alarm count: %u\n"
argument_list|,
name|__func__
argument_list|,
name|fa
argument_list|)
expr_stmt|;
name|calib
operator|->
name|cck_state
operator|=
name|IWN_CCK_STATE_LOFA
expr_stmt|;
name|calib
operator|->
name|low_fa
operator|++
expr_stmt|;
if|if
condition|(
name|calib
operator|->
name|cck_state
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|calib
operator|->
name|noise_ref
operator|-
name|noise_ref
operator|)
operator|>
literal|2
operator|||
name|calib
operator|->
name|low_fa
operator|>
literal|100
operator|)
condition|)
block|{
name|inc_clip
argument_list|(
name|calib
operator|->
name|energy_cck
argument_list|,
literal|2
argument_list|,
literal|97
argument_list|)
expr_stmt|;
name|dec_clip
argument_list|(
name|calib
operator|->
name|corr_cck_x4
argument_list|,
literal|3
argument_list|,
literal|125
argument_list|)
expr_stmt|;
name|dec_clip
argument_list|(
name|calib
operator|->
name|corr_cck_mrc_x4
argument_list|,
literal|3
argument_list|,
literal|200
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* not worth to increase or decrease sensitivity */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s: CCK normal false alarm count: %u\n"
argument_list|,
name|__func__
argument_list|,
name|fa
argument_list|)
expr_stmt|;
name|calib
operator|->
name|low_fa
operator|=
literal|0
expr_stmt|;
name|calib
operator|->
name|noise_ref
operator|=
name|noise_ref
expr_stmt|;
if|if
condition|(
name|calib
operator|->
name|cck_state
operator|==
name|IWN_CCK_STATE_HIFA
condition|)
block|{
comment|/* previous interval had many false alarms */
name|dec_clip
argument_list|(
name|calib
operator|->
name|energy_cck
argument_list|,
literal|8
argument_list|,
name|energy_min
argument_list|)
expr_stmt|;
block|}
name|calib
operator|->
name|cck_state
operator|=
name|IWN_CCK_STATE_INIT
expr_stmt|;
block|}
if|if
condition|(
name|needs_update
condition|)
operator|(
name|void
operator|)
name|iwn_send_sensitivity
argument_list|(
name|sc
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|dec_clip
undef|#
directive|undef
name|inc_clip
block|}
end_function

begin_function
name|int
name|iwn_send_sensitivity
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwn_calib_state
modifier|*
name|calib
init|=
operator|&
name|sc
operator|->
name|calib
decl_stmt|;
name|struct
name|iwn_sensitivity_cmd
name|cmd
decl_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|which
operator|=
name|IWN_SENSITIVITY_WORKTBL
expr_stmt|;
comment|/* OFDM modulation */
name|cmd
operator|.
name|corr_ofdm_x1
operator|=
name|htole16
argument_list|(
name|calib
operator|->
name|corr_ofdm_x1
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|corr_ofdm_mrc_x1
operator|=
name|htole16
argument_list|(
name|calib
operator|->
name|corr_ofdm_mrc_x1
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|corr_ofdm_x4
operator|=
name|htole16
argument_list|(
name|calib
operator|->
name|corr_ofdm_x4
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|corr_ofdm_mrc_x4
operator|=
name|htole16
argument_list|(
name|calib
operator|->
name|corr_ofdm_mrc_x4
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|energy_ofdm
operator|=
name|htole16
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|energy_ofdm_th
operator|=
name|htole16
argument_list|(
literal|62
argument_list|)
expr_stmt|;
comment|/* CCK modulation */
name|cmd
operator|.
name|corr_cck_x4
operator|=
name|htole16
argument_list|(
name|calib
operator|->
name|corr_cck_x4
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|corr_cck_mrc_x4
operator|=
name|htole16
argument_list|(
name|calib
operator|->
name|corr_cck_mrc_x4
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|energy_cck
operator|=
name|htole16
argument_list|(
name|calib
operator|->
name|energy_cck
argument_list|)
expr_stmt|;
comment|/* Barker modulation: use default values */
name|cmd
operator|.
name|corr_barker
operator|=
name|htole16
argument_list|(
literal|190
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|corr_barker_mrc
operator|=
name|htole16
argument_list|(
literal|390
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"%s: set sensitivity %d/%d/%d/%d/%d/%d/%d\n"
argument_list|,
name|__func__
argument_list|,
name|calib
operator|->
name|corr_ofdm_x1
argument_list|,
name|calib
operator|->
name|corr_ofdm_mrc_x1
argument_list|,
name|calib
operator|->
name|corr_ofdm_x4
argument_list|,
name|calib
operator|->
name|corr_ofdm_mrc_x4
argument_list|,
name|calib
operator|->
name|corr_cck_x4
argument_list|,
name|calib
operator|->
name|corr_cck_mrc_x4
argument_list|,
name|calib
operator|->
name|energy_cck
argument_list|)
expr_stmt|;
return|return
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_SENSITIVITY
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
name|cmd
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|iwn_auth
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|vap
operator|->
name|iv_bss
decl_stmt|;
name|struct
name|iwn_node_info
name|node
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|->
name|calib
operator|.
name|state
operator|=
name|IWN_CALIB_STATE_INIT
expr_stmt|;
comment|/* update adapter's configuration */
name|sc
operator|->
name|config
operator|.
name|associd
operator|=
literal|0
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|sc
operator|->
name|config
operator|.
name|bssid
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|chan
operator|=
name|htole16
argument_list|(
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|flags
operator|=
name|htole32
argument_list|(
name|IWN_CONFIG_TSF
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
name|sc
operator|->
name|config
operator|.
name|flags
operator||=
name|htole32
argument_list|(
name|IWN_CONFIG_AUTO
operator||
name|IWN_CONFIG_24GHZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_A
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
block|{
name|sc
operator|->
name|config
operator|.
name|cck_mask
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|ofdm_mask
operator|=
literal|0x15
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_B
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
block|{
name|sc
operator|->
name|config
operator|.
name|cck_mask
operator|=
literal|0x03
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|ofdm_mask
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX assume 802.11b/g */
name|sc
operator|->
name|config
operator|.
name|cck_mask
operator|=
literal|0x0f
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|ofdm_mask
operator|=
literal|0x15
expr_stmt|;
block|}
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHSLOT
condition|)
name|sc
operator|->
name|config
operator|.
name|flags
operator||=
name|htole32
argument_list|(
name|IWN_CONFIG_SHSLOT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHPREAMBLE
condition|)
name|sc
operator|->
name|config
operator|.
name|flags
operator||=
name|htole32
argument_list|(
name|IWN_CONFIG_SHPREAMBLE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|filter
operator|&=
operator|~
name|htole32
argument_list|(
name|IWN_FILTER_BSS
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_STATE
argument_list|,
literal|"%s: config chan %d mode %d flags 0x%x cck 0x%x ofdm 0x%x "
literal|"ht_single 0x%x ht_dual 0x%x rxchain 0x%x "
literal|"myaddr %6D wlap %6D bssid %6D associd %d filter 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|le16toh
argument_list|(
name|sc
operator|->
name|config
operator|.
name|chan
argument_list|)
argument_list|,
name|sc
operator|->
name|config
operator|.
name|mode
argument_list|,
name|le32toh
argument_list|(
name|sc
operator|->
name|config
operator|.
name|flags
argument_list|)
argument_list|,
name|sc
operator|->
name|config
operator|.
name|cck_mask
argument_list|,
name|sc
operator|->
name|config
operator|.
name|ofdm_mask
argument_list|,
name|sc
operator|->
name|config
operator|.
name|ht_single_mask
argument_list|,
name|sc
operator|->
name|config
operator|.
name|ht_dual_mask
argument_list|,
name|le16toh
argument_list|(
name|sc
operator|->
name|config
operator|.
name|rxchain
argument_list|)
argument_list|,
name|sc
operator|->
name|config
operator|.
name|myaddr
argument_list|,
literal|":"
argument_list|,
name|sc
operator|->
name|config
operator|.
name|wlap
argument_list|,
literal|":"
argument_list|,
name|sc
operator|->
name|config
operator|.
name|bssid
argument_list|,
literal|":"
argument_list|,
name|le16toh
argument_list|(
name|sc
operator|->
name|config
operator|.
name|associd
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|sc
operator|->
name|config
operator|.
name|filter
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_CONFIGURE
argument_list|,
operator|&
name|sc
operator|->
name|config
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_config
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not configure, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|sc
operator|->
name|sc_curchan
operator|=
name|ic
operator|->
name|ic_curchan
expr_stmt|;
comment|/* configuration has changed, set Tx power accordingly */
name|error
operator|=
name|iwn_set_txpower
argument_list|(
name|sc
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not set Tx power, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 	 * Reconfiguring clears the adapter's nodes table so we must 	 * add the broadcast node again. 	 */
name|memset
argument_list|(
operator|&
name|node
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|node
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|node
operator|.
name|macaddr
argument_list|,
name|ifp
operator|->
name|if_broadcastaddr
argument_list|)
expr_stmt|;
name|node
operator|.
name|id
operator|=
name|IWN_ID_BROADCAST
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_STATE
argument_list|,
literal|"%s: add broadcast node\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_ADD_NODE
argument_list|,
operator|&
name|node
argument_list|,
sizeof|sizeof
name|node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not add broadcast node, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|iwn_set_link_quality
argument_list|(
name|sc
argument_list|,
name|node
operator|.
name|id
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not setup MRR for broadcast node, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Configure the adapter for associated state.  */
end_comment

begin_function
name|int
name|iwn_run
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
define|#
directive|define
name|MS
parameter_list|(
name|v
parameter_list|,
name|x
parameter_list|)
value|(((v)& x)>> x##_S)
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|vap
operator|->
name|iv_bss
decl_stmt|;
name|struct
name|iwn_node_info
name|node
decl_stmt|;
name|int
name|error
decl_stmt|,
name|maxrxampdu
decl_stmt|,
name|ampdudensity
decl_stmt|;
name|sc
operator|->
name|calib
operator|.
name|state
operator|=
name|IWN_CALIB_STATE_INIT
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_MONITOR
condition|)
block|{
comment|/* link LED blinks while monitoring */
name|iwn_set_led
argument_list|(
name|sc
argument_list|,
name|IWN_LED_LINK
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|iwn_enable_tsf
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|)
expr_stmt|;
comment|/* update adapter's configuration */
name|sc
operator|->
name|config
operator|.
name|associd
operator|=
name|htole16
argument_list|(
name|IEEE80211_AID
argument_list|(
name|ni
operator|->
name|ni_associd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* short preamble/slot time are negotiated when associating */
name|sc
operator|->
name|config
operator|.
name|flags
operator|&=
operator|~
name|htole32
argument_list|(
name|IWN_CONFIG_SHPREAMBLE
operator||
name|IWN_CONFIG_SHSLOT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHSLOT
condition|)
name|sc
operator|->
name|config
operator|.
name|flags
operator||=
name|htole32
argument_list|(
name|IWN_CONFIG_SHSLOT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHPREAMBLE
condition|)
name|sc
operator|->
name|config
operator|.
name|flags
operator||=
name|htole32
argument_list|(
name|IWN_CONFIG_SHPREAMBLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
block|{
name|sc
operator|->
name|config
operator|.
name|flags
operator|&=
operator|~
name|htole32
argument_list|(
name|IWN_CONFIG_HT
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40U
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
name|sc
operator|->
name|config
operator|.
name|flags
operator||=
name|htole32
argument_list|(
name|IWN_CONFIG_HT40U
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40D
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
name|sc
operator|->
name|config
operator|.
name|flags
operator||=
name|htole32
argument_list|(
name|IWN_CONFIG_HT40D
argument_list|)
expr_stmt|;
else|else
name|sc
operator|->
name|config
operator|.
name|flags
operator||=
name|htole32
argument_list|(
name|IWN_CONFIG_HT20
argument_list|)
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|rxchain
operator|=
name|htole16
argument_list|(
operator|(
literal|3
operator|<<
name|IWN_RXCHAIN_VALID_S
operator|)
operator||
operator|(
literal|3
operator|<<
name|IWN_RXCHAIN_MIMO_CNT_S
operator|)
operator||
operator|(
literal|1
operator|<<
name|IWN_RXCHAIN_CNT_S
operator|)
operator||
name|IWN_RXCHAIN_MIMO_FORCE
argument_list|)
expr_stmt|;
name|maxrxampdu
operator|=
name|MS
argument_list|(
name|ni
operator|->
name|ni_htparam
argument_list|,
name|IEEE80211_HTCAP_MAXRXAMPDU
argument_list|)
expr_stmt|;
name|ampdudensity
operator|=
name|MS
argument_list|(
name|ni
operator|->
name|ni_htparam
argument_list|,
name|IEEE80211_HTCAP_MPDUDENSITY
argument_list|)
expr_stmt|;
block|}
else|else
name|maxrxampdu
operator|=
name|ampdudensity
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|filter
operator||=
name|htole32
argument_list|(
name|IWN_FILTER_BSS
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_STATE
argument_list|,
literal|"%s: config chan %d mode %d flags 0x%x cck 0x%x ofdm 0x%x "
literal|"ht_single 0x%x ht_dual 0x%x rxchain 0x%x "
literal|"myaddr %6D wlap %6D bssid %6D associd %d filter 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|le16toh
argument_list|(
name|sc
operator|->
name|config
operator|.
name|chan
argument_list|)
argument_list|,
name|sc
operator|->
name|config
operator|.
name|mode
argument_list|,
name|le32toh
argument_list|(
name|sc
operator|->
name|config
operator|.
name|flags
argument_list|)
argument_list|,
name|sc
operator|->
name|config
operator|.
name|cck_mask
argument_list|,
name|sc
operator|->
name|config
operator|.
name|ofdm_mask
argument_list|,
name|sc
operator|->
name|config
operator|.
name|ht_single_mask
argument_list|,
name|sc
operator|->
name|config
operator|.
name|ht_dual_mask
argument_list|,
name|le16toh
argument_list|(
name|sc
operator|->
name|config
operator|.
name|rxchain
argument_list|)
argument_list|,
name|sc
operator|->
name|config
operator|.
name|myaddr
argument_list|,
literal|":"
argument_list|,
name|sc
operator|->
name|config
operator|.
name|wlap
argument_list|,
literal|":"
argument_list|,
name|sc
operator|->
name|config
operator|.
name|bssid
argument_list|,
literal|":"
argument_list|,
name|le16toh
argument_list|(
name|sc
operator|->
name|config
operator|.
name|associd
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|sc
operator|->
name|config
operator|.
name|filter
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_CONFIGURE
argument_list|,
operator|&
name|sc
operator|->
name|config
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_config
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not update configuration, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|sc
operator|->
name|sc_curchan
operator|=
name|ni
operator|->
name|ni_chan
expr_stmt|;
comment|/* configuration has changed, set Tx power accordingly */
name|error
operator|=
name|iwn_set_txpower
argument_list|(
name|sc
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not set Tx power, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* add BSS node */
name|memset
argument_list|(
operator|&
name|node
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|node
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|node
operator|.
name|macaddr
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|)
expr_stmt|;
name|node
operator|.
name|id
operator|=
name|IWN_ID_BSS
expr_stmt|;
name|node
operator|.
name|htflags
operator|=
name|htole32
argument_list|(
operator|(
name|maxrxampdu
operator|<<
name|IWN_MAXRXAMPDU_S
operator|)
operator||
operator|(
name|ampdudensity
operator|<<
name|IWN_MPDUDENSITY_S
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_STATE
argument_list|,
literal|"%s: add BSS node, id %d htflags 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|node
operator|.
name|id
argument_list|,
name|le32toh
argument_list|(
name|node
operator|.
name|htflags
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_ADD_NODE
argument_list|,
operator|&
name|node
argument_list|,
sizeof|sizeof
name|node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"could not add BSS node\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|iwn_set_link_quality
argument_list|(
name|sc
argument_list|,
name|node
operator|.
name|id
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not setup MRR for node %d, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|node
operator|.
name|id
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|iwn_init_sensitivity
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not set sensitivity, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* start/restart periodic calibration timer */
name|sc
operator|->
name|calib
operator|.
name|state
operator|=
name|IWN_CALIB_STATE_ASSOC
expr_stmt|;
name|iwn_calib_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* link LED always on while associated */
name|iwn_set_led
argument_list|(
name|sc
argument_list|,
name|IWN_LED_LINK
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
undef|#
directive|undef
name|MS
block|}
end_function

begin_comment
comment|/*  * Send a scan request to the firmware.  Since this command is huge, we map it  * into a mbuf instead of using the pre-allocated set of commands.  */
end_comment

begin_function
name|int
name|iwn_scan
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
init|=
name|ic
operator|->
name|ic_scan
decl_stmt|;
comment|/*XXX*/
name|struct
name|iwn_tx_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|txq
index|[
literal|4
index|]
decl_stmt|;
name|struct
name|iwn_tx_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|iwn_tx_data
modifier|*
name|data
decl_stmt|;
name|struct
name|iwn_tx_cmd
modifier|*
name|cmd
decl_stmt|;
name|struct
name|iwn_cmd_data
modifier|*
name|tx
decl_stmt|;
name|struct
name|iwn_scan_hdr
modifier|*
name|hdr
decl_stmt|;
name|struct
name|iwn_scan_essid
modifier|*
name|essid
decl_stmt|;
name|struct
name|iwn_scan_chan
modifier|*
name|chan
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|struct
name|ieee80211_rateset
modifier|*
name|rs
decl_stmt|;
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|;
name|enum
name|ieee80211_phymode
name|mode
decl_stmt|;
name|uint8_t
modifier|*
name|frm
decl_stmt|;
name|int
name|pktlen
decl_stmt|,
name|error
decl_stmt|,
name|nrates
decl_stmt|;
name|bus_addr_t
name|physaddr
decl_stmt|;
name|desc
operator|=
operator|&
name|ring
operator|->
name|desc
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|data
operator|=
operator|&
name|ring
operator|->
name|data
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
comment|/* XXX malloc */
name|data
operator|->
name|m
operator|=
name|m_getcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|m
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not allocate mbuf for scan command\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|cmd
operator|=
name|mtod
argument_list|(
name|data
operator|->
name|m
argument_list|,
expr|struct
name|iwn_tx_cmd
operator|*
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|code
operator|=
name|IWN_CMD_SCAN
expr_stmt|;
name|cmd
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|qid
operator|=
name|ring
operator|->
name|qid
expr_stmt|;
name|cmd
operator|->
name|idx
operator|=
name|ring
operator|->
name|cur
expr_stmt|;
name|hdr
operator|=
operator|(
expr|struct
name|iwn_scan_hdr
operator|*
operator|)
name|cmd
operator|->
name|data
expr_stmt|;
name|memset
argument_list|(
name|hdr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_scan_hdr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX use scan state */
comment|/* 	 * Move to the next channel if no packets are received within 5 msecs 	 * after sending the probe request (this helps to reduce the duration 	 * of active scans). 	 */
name|hdr
operator|->
name|quiet
operator|=
name|htole16
argument_list|(
literal|5
argument_list|)
expr_stmt|;
comment|/* timeout in milliseconds */
name|hdr
operator|->
name|plcp_threshold
operator|=
name|htole16
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* min # of packets */
comment|/* select Ant B and Ant C for scanning */
name|hdr
operator|->
name|rxchain
operator|=
name|htole16
argument_list|(
literal|0x3e1
operator||
operator|(
literal|7
operator|<<
name|IWN_RXCHAIN_VALID_S
operator|)
argument_list|)
expr_stmt|;
name|tx
operator|=
operator|(
expr|struct
name|iwn_cmd_data
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
expr_stmt|;
name|memset
argument_list|(
name|tx
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_cmd_data
argument_list|)
argument_list|)
expr_stmt|;
name|tx
operator|->
name|flags
operator|=
name|htole32
argument_list|(
name|IWN_TX_AUTO_SEQ
operator||
literal|0x200
argument_list|)
expr_stmt|;
comment|/* XXX */
name|tx
operator|->
name|id
operator|=
name|IWN_ID_BROADCAST
expr_stmt|;
name|tx
operator|->
name|lifetime
operator|=
name|htole32
argument_list|(
name|IWN_LIFETIME_INFINITE
argument_list|)
expr_stmt|;
name|tx
operator|->
name|rflags
operator|=
name|IWN_RFLAG_ANT_B
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_A
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
condition|)
block|{
name|hdr
operator|->
name|crc_threshold
operator|=
name|htole16
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* send probe requests at 6Mbps */
name|tx
operator|->
name|rate
operator|=
name|iwn_ridx_to_plcp
index|[
name|IWN_RATE_OFDM6
index|]
expr_stmt|;
block|}
else|else
block|{
name|hdr
operator|->
name|flags
operator|=
name|htole32
argument_list|(
name|IWN_CONFIG_24GHZ
operator||
name|IWN_CONFIG_AUTO
argument_list|)
expr_stmt|;
comment|/* send probe requests at 1Mbps */
name|tx
operator|->
name|rate
operator|=
name|iwn_ridx_to_plcp
index|[
name|IWN_RATE_CCK1
index|]
expr_stmt|;
name|tx
operator|->
name|rflags
operator||=
name|IWN_RFLAG_CCK
expr_stmt|;
block|}
name|essid
operator|=
operator|(
expr|struct
name|iwn_scan_essid
operator|*
operator|)
operator|(
name|tx
operator|+
literal|1
operator|)
expr_stmt|;
name|memset
argument_list|(
name|essid
argument_list|,
literal|0
argument_list|,
literal|4
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_scan_essid
argument_list|)
argument_list|)
expr_stmt|;
name|essid
index|[
literal|0
index|]
operator|.
name|id
operator|=
name|IEEE80211_ELEMID_SSID
expr_stmt|;
name|essid
index|[
literal|0
index|]
operator|.
name|len
operator|=
name|ss
operator|->
name|ss_ssid
index|[
literal|0
index|]
operator|.
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|essid
index|[
literal|0
index|]
operator|.
name|data
argument_list|,
name|ss
operator|->
name|ss_ssid
index|[
literal|0
index|]
operator|.
name|ssid
argument_list|,
name|ss
operator|->
name|ss_ssid
index|[
literal|0
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
comment|/* 	 * Build a probe request frame.  Most of the following code is a 	 * copy& paste of what is done in net80211. 	 */
name|wh
operator|=
operator|(
expr|struct
name|ieee80211_frame
operator|*
operator|)
operator|&
name|essid
index|[
literal|4
index|]
expr_stmt|;
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|=
name|IEEE80211_FC0_VERSION_0
operator||
name|IEEE80211_FC0_TYPE_MGT
operator||
name|IEEE80211_FC0_SUBTYPE_PROBE_REQ
expr_stmt|;
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_DIR_NODS
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|ifp
operator|->
name|if_broadcastaddr
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|ifp
operator|->
name|if_broadcastaddr
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
operator|&
name|wh
operator|->
name|i_dur
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* filled by h/w */
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
operator|&
name|wh
operator|->
name|i_seq
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* filled by h/w */
name|frm
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|wh
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* add SSID IE */
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_SSID
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|ss
operator|->
name|ss_ssid
index|[
literal|0
index|]
operator|.
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|frm
argument_list|,
name|ss
operator|->
name|ss_ssid
index|[
literal|0
index|]
operator|.
name|ssid
argument_list|,
name|ss
operator|->
name|ss_ssid
index|[
literal|0
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
name|frm
operator|+=
name|ss
operator|->
name|ss_ssid
index|[
literal|0
index|]
operator|.
name|len
expr_stmt|;
name|mode
operator|=
name|ieee80211_chan2mode
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
name|rs
operator|=
operator|&
name|ic
operator|->
name|ic_sup_rates
index|[
name|mode
index|]
expr_stmt|;
comment|/* add supported rates IE */
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_RATES
expr_stmt|;
name|nrates
operator|=
name|rs
operator|->
name|rs_nrates
expr_stmt|;
if|if
condition|(
name|nrates
operator|>
name|IEEE80211_RATE_SIZE
condition|)
name|nrates
operator|=
name|IEEE80211_RATE_SIZE
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|nrates
expr_stmt|;
name|memcpy
argument_list|(
name|frm
argument_list|,
name|rs
operator|->
name|rs_rates
argument_list|,
name|nrates
argument_list|)
expr_stmt|;
name|frm
operator|+=
name|nrates
expr_stmt|;
comment|/* add supported xrates IE */
if|if
condition|(
name|rs
operator|->
name|rs_nrates
operator|>
name|IEEE80211_RATE_SIZE
condition|)
block|{
name|nrates
operator|=
name|rs
operator|->
name|rs_nrates
operator|-
name|IEEE80211_RATE_SIZE
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_XRATES
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
operator|(
name|uint8_t
operator|)
name|nrates
expr_stmt|;
name|memcpy
argument_list|(
name|frm
argument_list|,
name|rs
operator|->
name|rs_rates
operator|+
name|IEEE80211_RATE_SIZE
argument_list|,
name|nrates
argument_list|)
expr_stmt|;
name|frm
operator|+=
name|nrates
expr_stmt|;
block|}
comment|/* setup length of probe request */
name|tx
operator|->
name|len
operator|=
name|htole16
argument_list|(
name|frm
operator|-
operator|(
name|uint8_t
operator|*
operator|)
name|wh
argument_list|)
expr_stmt|;
name|c
operator|=
name|ic
operator|->
name|ic_curchan
expr_stmt|;
name|chan
operator|=
operator|(
expr|struct
name|iwn_scan_chan
operator|*
operator|)
name|frm
expr_stmt|;
name|chan
operator|->
name|chan
operator|=
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|chan
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|->
name|ic_flags
operator|&
name|IEEE80211_CHAN_PASSIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|chan
operator|->
name|flags
operator||=
name|IWN_CHAN_ACTIVE
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|ss_nssid
operator|>
literal|0
condition|)
name|chan
operator|->
name|flags
operator||=
name|IWN_CHAN_DIRECT
expr_stmt|;
block|}
name|chan
operator|->
name|dsp_gain
operator|=
literal|0x6e
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|chan
operator|->
name|rf_gain
operator|=
literal|0x3b
expr_stmt|;
name|chan
operator|->
name|active
operator|=
name|htole16
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|chan
operator|->
name|passive
operator|=
name|htole16
argument_list|(
literal|110
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chan
operator|->
name|rf_gain
operator|=
literal|0x28
expr_stmt|;
name|chan
operator|->
name|active
operator|=
name|htole16
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|chan
operator|->
name|passive
operator|=
name|htole16
argument_list|(
literal|120
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_STATE
argument_list|,
literal|"%s: chan %u flags 0x%x rf_gain 0x%x "
literal|"dsp_gain 0x%x active 0x%x passive 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|chan
argument_list|,
name|chan
operator|->
name|flags
argument_list|,
name|chan
operator|->
name|rf_gain
argument_list|,
name|chan
operator|->
name|dsp_gain
argument_list|,
name|chan
operator|->
name|active
argument_list|,
name|chan
operator|->
name|passive
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|nchan
operator|++
expr_stmt|;
name|chan
operator|++
expr_stmt|;
name|frm
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_scan_chan
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|len
operator|=
name|htole16
argument_list|(
name|frm
operator|-
operator|(
name|uint8_t
operator|*
operator|)
name|hdr
argument_list|)
expr_stmt|;
name|pktlen
operator|=
name|frm
operator|-
operator|(
name|uint8_t
operator|*
operator|)
name|cmd
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|cmd
argument_list|,
name|pktlen
argument_list|,
name|iwn_dma_map_addr
argument_list|,
operator|&
name|physaddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not map scan command, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|data
operator|->
name|m
argument_list|)
expr_stmt|;
name|data
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
return|return
name|error
return|;
block|}
name|IWN_SET_DESC_NSEGS
argument_list|(
name|desc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|IWN_SET_DESC_SEG
argument_list|(
name|desc
argument_list|,
literal|0
argument_list|,
name|physaddr
argument_list|,
name|pktlen
argument_list|)
expr_stmt|;
name|sc
operator|->
name|shared
operator|->
name|len
index|[
name|ring
operator|->
name|qid
index|]
index|[
name|ring
operator|->
name|cur
index|]
operator|=
name|htole16
argument_list|(
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|cur
operator|<
name|IWN_TX_WINDOW
condition|)
name|sc
operator|->
name|shared
operator|->
name|len
index|[
name|ring
operator|->
name|qid
index|]
index|[
name|ring
operator|->
name|cur
operator|+
name|IWN_TX_RING_COUNT
index|]
operator|=
name|htole16
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|desc_dma
operator|.
name|tag
argument_list|,
name|ring
operator|->
name|desc_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* kick cmd ring */
name|ring
operator|->
name|cur
operator|=
operator|(
name|ring
operator|->
name|cur
operator|+
literal|1
operator|)
operator|%
name|IWN_TX_RING_COUNT
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_TX_WIDX
argument_list|,
name|ring
operator|->
name|qid
operator|<<
literal|8
operator||
name|ring
operator|->
name|cur
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* will be notified async. of failure/success */
block|}
end_function

begin_function
name|int
name|iwn_config
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|iwn_power
name|power
decl_stmt|;
name|struct
name|iwn_bluetooth
name|bluetooth
decl_stmt|;
name|struct
name|iwn_node_info
name|node
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* set power mode */
name|memset
argument_list|(
operator|&
name|power
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|power
argument_list|)
expr_stmt|;
name|power
operator|.
name|flags
operator|=
name|htole16
argument_list|(
name|IWN_POWER_CAM
operator||
literal|0x8
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"%s: set power mode\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_SET_POWER_MODE
argument_list|,
operator|&
name|power
argument_list|,
sizeof|sizeof
name|power
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not set power mode, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* configure bluetooth coexistence */
name|memset
argument_list|(
operator|&
name|bluetooth
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|bluetooth
argument_list|)
expr_stmt|;
name|bluetooth
operator|.
name|flags
operator|=
literal|3
expr_stmt|;
name|bluetooth
operator|.
name|lead
operator|=
literal|0xaa
expr_stmt|;
name|bluetooth
operator|.
name|kill
operator|=
literal|1
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"%s: config bluetooth coexistence\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_BLUETOOTH
argument_list|,
operator|&
name|bluetooth
argument_list|,
sizeof|sizeof
name|bluetooth
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not configure bluetooth coexistence, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* configure adapter */
name|memset
argument_list|(
operator|&
name|sc
operator|->
name|config
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_config
argument_list|)
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|sc
operator|->
name|config
operator|.
name|myaddr
argument_list|,
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|sc
operator|->
name|config
operator|.
name|wlap
argument_list|,
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set default channel */
name|sc
operator|->
name|config
operator|.
name|chan
operator|=
name|htole16
argument_list|(
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|flags
operator|=
name|htole32
argument_list|(
name|IWN_CONFIG_TSF
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
condition|)
name|sc
operator|->
name|config
operator|.
name|flags
operator||=
name|htole32
argument_list|(
name|IWN_CONFIG_AUTO
operator||
name|IWN_CONFIG_24GHZ
argument_list|)
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|filter
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|ic
operator|->
name|ic_opmode
condition|)
block|{
case|case
name|IEEE80211_M_STA
case|:
name|sc
operator|->
name|config
operator|.
name|mode
operator|=
name|IWN_MODE_STA
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|filter
operator||=
name|htole32
argument_list|(
name|IWN_FILTER_MULTICAST
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_IBSS
case|:
case|case
name|IEEE80211_M_AHDEMO
case|:
name|sc
operator|->
name|config
operator|.
name|mode
operator|=
name|IWN_MODE_IBSS
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_HOSTAP
case|:
name|sc
operator|->
name|config
operator|.
name|mode
operator|=
name|IWN_MODE_HOSTAP
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_MONITOR
case|:
name|sc
operator|->
name|config
operator|.
name|mode
operator|=
name|IWN_MODE_MONITOR
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|filter
operator||=
name|htole32
argument_list|(
name|IWN_FILTER_MULTICAST
operator||
name|IWN_FILTER_CTL
operator||
name|IWN_FILTER_PROMISC
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|sc
operator|->
name|config
operator|.
name|cck_mask
operator|=
literal|0x0f
expr_stmt|;
comment|/* not yet negotiated */
name|sc
operator|->
name|config
operator|.
name|ofdm_mask
operator|=
literal|0xff
expr_stmt|;
comment|/* not yet negotiated */
name|sc
operator|->
name|config
operator|.
name|ht_single_mask
operator|=
literal|0xff
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|ht_dual_mask
operator|=
literal|0xff
expr_stmt|;
name|sc
operator|->
name|config
operator|.
name|rxchain
operator|=
name|htole16
argument_list|(
literal|0x2800
operator||
operator|(
literal|7
operator|<<
name|IWN_RXCHAIN_VALID_S
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_STATE
argument_list|,
literal|"%s: config chan %d mode %d flags 0x%x cck 0x%x ofdm 0x%x "
literal|"ht_single 0x%x ht_dual 0x%x rxchain 0x%x "
literal|"myaddr %6D wlap %6D bssid %6D associd %d filter 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|le16toh
argument_list|(
name|sc
operator|->
name|config
operator|.
name|chan
argument_list|)
argument_list|,
name|sc
operator|->
name|config
operator|.
name|mode
argument_list|,
name|le32toh
argument_list|(
name|sc
operator|->
name|config
operator|.
name|flags
argument_list|)
argument_list|,
name|sc
operator|->
name|config
operator|.
name|cck_mask
argument_list|,
name|sc
operator|->
name|config
operator|.
name|ofdm_mask
argument_list|,
name|sc
operator|->
name|config
operator|.
name|ht_single_mask
argument_list|,
name|sc
operator|->
name|config
operator|.
name|ht_dual_mask
argument_list|,
name|le16toh
argument_list|(
name|sc
operator|->
name|config
operator|.
name|rxchain
argument_list|)
argument_list|,
name|sc
operator|->
name|config
operator|.
name|myaddr
argument_list|,
literal|":"
argument_list|,
name|sc
operator|->
name|config
operator|.
name|wlap
argument_list|,
literal|":"
argument_list|,
name|sc
operator|->
name|config
operator|.
name|bssid
argument_list|,
literal|":"
argument_list|,
name|le16toh
argument_list|(
name|sc
operator|->
name|config
operator|.
name|associd
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|sc
operator|->
name|config
operator|.
name|filter
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_CONFIGURE
argument_list|,
operator|&
name|sc
operator|->
name|config
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_config
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: configure command failed, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|sc
operator|->
name|sc_curchan
operator|=
name|ic
operator|->
name|ic_curchan
expr_stmt|;
comment|/* configuration has changed, set Tx power accordingly */
name|error
operator|=
name|iwn_set_txpower
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not set Tx power, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* add broadcast node */
name|memset
argument_list|(
operator|&
name|node
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|node
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|node
operator|.
name|macaddr
argument_list|,
name|ic
operator|->
name|ic_ifp
operator|->
name|if_broadcastaddr
argument_list|)
expr_stmt|;
name|node
operator|.
name|id
operator|=
name|IWN_ID_BROADCAST
expr_stmt|;
name|node
operator|.
name|rate
operator|=
name|iwn_plcp_signal
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"%s: add broadcast node\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_ADD_NODE
argument_list|,
operator|&
name|node
argument_list|,
sizeof|sizeof
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not add broadcast node, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|iwn_set_link_quality
argument_list|(
name|sc
argument_list|,
name|node
operator|.
name|id
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not setup MRR for node %d, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|node
operator|.
name|id
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|iwn_set_critical_temp
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not set critical temperature, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Do post-alive initialization of the NIC (after firmware upload).  */
end_comment

begin_function
name|void
name|iwn_post_alive
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|base
decl_stmt|;
name|uint16_t
name|offset
decl_stmt|;
name|int
name|qid
decl_stmt|;
name|iwn_mem_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* clear SRAM */
name|base
operator|=
name|iwn_mem_read
argument_list|(
name|sc
argument_list|,
name|IWN_SRAM_BASE
argument_list|)
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|0x380
init|;
name|offset
operator|<
literal|0x520
condition|;
name|offset
operator|+=
literal|4
control|)
block|{
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_MEM_WADDR
argument_list|,
name|base
operator|+
name|offset
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_MEM_WDATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* shared area is aligned on a 1K boundary */
name|iwn_mem_write
argument_list|(
name|sc
argument_list|,
name|IWN_SRAM_BASE
argument_list|,
name|sc
operator|->
name|shared_dma
operator|.
name|paddr
operator|>>
literal|10
argument_list|)
expr_stmt|;
name|iwn_mem_write
argument_list|(
name|sc
argument_list|,
name|IWN_SELECT_QCHAIN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|qid
operator|=
literal|0
init|;
name|qid
operator|<
name|IWN_NTXQUEUES
condition|;
name|qid
operator|++
control|)
block|{
name|iwn_mem_write
argument_list|(
name|sc
argument_list|,
name|IWN_QUEUE_RIDX
argument_list|(
name|qid
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_TX_WIDX
argument_list|,
name|qid
operator|<<
literal|8
operator||
literal|0
argument_list|)
expr_stmt|;
comment|/* set sched. window size */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_MEM_WADDR
argument_list|,
name|base
operator|+
name|IWN_QUEUE_OFFSET
argument_list|(
name|qid
argument_list|)
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_MEM_WDATA
argument_list|,
literal|64
argument_list|)
expr_stmt|;
comment|/* set sched. frame limit */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_MEM_WADDR
argument_list|,
name|base
operator|+
name|IWN_QUEUE_OFFSET
argument_list|(
name|qid
argument_list|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_MEM_WDATA
argument_list|,
literal|10
operator|<<
literal|16
argument_list|)
expr_stmt|;
block|}
comment|/* enable interrupts for all 16 queues */
name|iwn_mem_write
argument_list|(
name|sc
argument_list|,
name|IWN_QUEUE_INTR_MASK
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
comment|/* identify active Tx rings (0-7) */
name|iwn_mem_write
argument_list|(
name|sc
argument_list|,
name|IWN_TX_ACTIVE
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* mark Tx rings (4 EDCA + cmd + 2 HCCA) as active */
for|for
control|(
name|qid
operator|=
literal|0
init|;
name|qid
operator|<
literal|7
condition|;
name|qid
operator|++
control|)
block|{
name|iwn_mem_write
argument_list|(
name|sc
argument_list|,
name|IWN_TXQ_STATUS
argument_list|(
name|qid
argument_list|)
argument_list|,
name|IWN_TXQ_STATUS_ACTIVE
operator||
name|qid
operator|<<
literal|1
argument_list|)
expr_stmt|;
block|}
name|iwn_mem_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|iwn_stop_master
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|tmp
decl_stmt|;
name|int
name|ntries
decl_stmt|;
name|tmp
operator|=
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_RESET
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_RESET
argument_list|,
name|tmp
operator||
name|IWN_STOP_MASTER
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_GPIO_CTL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|&
name|IWN_GPIO_PWR_STATUS
operator|)
operator|==
name|IWN_GPIO_PWR_SLEEP
condition|)
return|return;
comment|/* already asleep */
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|100
condition|;
name|ntries
operator|++
control|)
block|{
if|if
condition|(
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_RESET
argument_list|)
operator|&
name|IWN_MASTER_DISABLED
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ntries
operator|==
literal|100
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: timeout waiting for master\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|iwn_reset
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|tmp
decl_stmt|;
name|int
name|ntries
decl_stmt|;
comment|/* clear any pending interrupts */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_INTR
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_CHICKEN
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_CHICKEN
argument_list|,
name|tmp
operator||
name|IWN_CHICKEN_DISLOS
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_GPIO_CTL
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_GPIO_CTL
argument_list|,
name|tmp
operator||
name|IWN_GPIO_INIT
argument_list|)
expr_stmt|;
comment|/* wait for clock stabilization */
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|1000
condition|;
name|ntries
operator|++
control|)
block|{
if|if
condition|(
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_GPIO_CTL
argument_list|)
operator|&
name|IWN_GPIO_CLOCK
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ntries
operator|==
literal|1000
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: timeout waiting for clock stabilization\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|ETIMEDOUT
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|iwn_hw_config
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|tmp
decl_stmt|,
name|hw
decl_stmt|;
comment|/* enable interrupts mitigation */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_INTR_MIT
argument_list|,
literal|512
operator|/
literal|32
argument_list|)
expr_stmt|;
comment|/* voodoo from the reference driver */
name|tmp
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|PCIR_REVID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|&
literal|0x80
operator|)
operator|&&
operator|(
name|tmp
operator|&
literal|0x7f
operator|)
operator|<
literal|8
condition|)
block|{
comment|/* enable "no snoop" field */
name|tmp
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|0xe8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tmp
operator|&=
operator|~
name|IWN_DIS_NOSNOOP
expr_stmt|;
comment|/* clear device specific PCI configuration register 0x41 */
name|pci_write_config
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|0xe8
argument_list|,
name|tmp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* disable L1 entry to work around a hardware bug */
name|tmp
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|0xf0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tmp
operator|&=
operator|~
name|IWN_ENA_L1
expr_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|0xf0
argument_list|,
name|tmp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hw
operator|=
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_HWCONFIG
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_HWCONFIG
argument_list|,
name|hw
operator||
literal|0x310
argument_list|)
expr_stmt|;
name|iwn_mem_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|iwn_mem_read
argument_list|(
name|sc
argument_list|,
name|IWN_MEM_POWER
argument_list|)
expr_stmt|;
name|iwn_mem_write
argument_list|(
name|sc
argument_list|,
name|IWN_MEM_POWER
argument_list|,
name|tmp
operator||
name|IWN_POWER_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|iwn_mem_read
argument_list|(
name|sc
argument_list|,
name|IWN_MEM_POWER
argument_list|)
expr_stmt|;
name|iwn_mem_write
argument_list|(
name|sc
argument_list|,
name|IWN_MEM_POWER
argument_list|,
name|tmp
operator|&
operator|~
name|IWN_POWER_RESET
argument_list|)
expr_stmt|;
name|iwn_mem_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|iwn_init_locked
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|uint32_t
name|tmp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|qid
decl_stmt|;
name|IWN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* load the firmware */
if|if
condition|(
name|sc
operator|->
name|fw_fp
operator|==
name|NULL
operator|&&
operator|(
name|error
operator|=
name|iwn_load_firmware
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not load firmware, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
name|error
operator|=
name|iwn_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not reset adapter, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
name|iwn_mem_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwn_mem_read
argument_list|(
name|sc
argument_list|,
name|IWN_CLOCK_CTL
argument_list|)
expr_stmt|;
name|iwn_mem_write
argument_list|(
name|sc
argument_list|,
name|IWN_CLOCK_CTL
argument_list|,
literal|0xa00
argument_list|)
expr_stmt|;
name|iwn_mem_read
argument_list|(
name|sc
argument_list|,
name|IWN_CLOCK_CTL
argument_list|)
expr_stmt|;
name|iwn_mem_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|iwn_mem_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|iwn_mem_read
argument_list|(
name|sc
argument_list|,
name|IWN_MEM_PCIDEV
argument_list|)
expr_stmt|;
name|iwn_mem_write
argument_list|(
name|sc
argument_list|,
name|IWN_MEM_PCIDEV
argument_list|,
name|tmp
operator||
literal|0x800
argument_list|)
expr_stmt|;
name|iwn_mem_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwn_mem_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|iwn_mem_read
argument_list|(
name|sc
argument_list|,
name|IWN_MEM_POWER
argument_list|)
expr_stmt|;
name|iwn_mem_write
argument_list|(
name|sc
argument_list|,
name|IWN_MEM_POWER
argument_list|,
name|tmp
operator|&
operator|~
literal|0x03000000
argument_list|)
expr_stmt|;
name|iwn_mem_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwn_hw_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* init Rx ring */
name|iwn_mem_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_RX_CONFIG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_RX_WIDX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Rx ring is aligned on a 256-byte boundary */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_RX_BASE
argument_list|,
name|sc
operator|->
name|rxq
operator|.
name|desc_dma
operator|.
name|paddr
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* shared area is aligned on a 16-byte boundary */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_RW_WIDX_PTR
argument_list|,
operator|(
name|sc
operator|->
name|shared_dma
operator|.
name|paddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|iwn_shared
argument_list|,
name|closed_count
argument_list|)
operator|)
operator|>>
literal|4
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_RX_CONFIG
argument_list|,
literal|0x80601000
argument_list|)
expr_stmt|;
name|iwn_mem_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_RX_WIDX
argument_list|,
operator|(
name|IWN_RX_RING_COUNT
operator|-
literal|1
operator|)
operator|&
operator|~
literal|7
argument_list|)
expr_stmt|;
name|iwn_mem_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwn_mem_write
argument_list|(
name|sc
argument_list|,
name|IWN_TX_ACTIVE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* set physical address of "keep warm" page */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_KW_BASE
argument_list|,
name|sc
operator|->
name|kw_dma
operator|.
name|paddr
operator|>>
literal|4
argument_list|)
expr_stmt|;
comment|/* init Tx rings */
for|for
control|(
name|qid
operator|=
literal|0
init|;
name|qid
operator|<
name|IWN_NTXQUEUES
condition|;
name|qid
operator|++
control|)
block|{
name|struct
name|iwn_tx_ring
modifier|*
name|txq
init|=
operator|&
name|sc
operator|->
name|txq
index|[
name|qid
index|]
decl_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_TX_BASE
argument_list|(
name|qid
argument_list|)
argument_list|,
name|txq
operator|->
name|desc_dma
operator|.
name|paddr
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_TX_CONFIG
argument_list|(
name|qid
argument_list|)
argument_list|,
literal|0x80000008
argument_list|)
expr_stmt|;
block|}
name|iwn_mem_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* clear "radio off" and "disable command" bits (reversed logic) */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_UCODE_CLR
argument_list|,
name|IWN_RADIO_OFF
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_UCODE_CLR
argument_list|,
name|IWN_DISABLE_CMD
argument_list|)
expr_stmt|;
comment|/* clear any pending interrupts */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_INTR
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* enable interrupts */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_MASK
argument_list|,
name|IWN_INTR_MASK
argument_list|)
expr_stmt|;
comment|/* not sure why/if this is necessary... */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_UCODE_CLR
argument_list|,
name|IWN_RADIO_OFF
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_UCODE_CLR
argument_list|,
name|IWN_RADIO_OFF
argument_list|)
expr_stmt|;
comment|/* check that the radio is not disabled by RF switch */
if|if
condition|(
operator|!
operator|(
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_GPIO_CTL
argument_list|)
operator|&
name|IWN_GPIO_RF_ENABLED
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"radio is disabled by hardware switch\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|error
operator|=
name|iwn_transfer_firmware
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not load firmware, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* firmware has notified us that it is alive.. */
name|iwn_post_alive
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* ..do post alive initialization */
name|sc
operator|->
name|rawtemp
operator|=
name|sc
operator|->
name|ucode_info
operator|.
name|temp
index|[
literal|3
index|]
operator|.
name|chan20MHz
expr_stmt|;
name|sc
operator|->
name|temp
operator|=
name|iwn_get_temperature
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"%s: temperature=%d\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|temp
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not configure device, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
block|}
end_function

begin_function
name|void
name|iwn_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwn_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|ieee80211_start_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|iwn_stop_locked
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|uint32_t
name|tmp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|IWN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_RESET
argument_list|,
name|IWN_NEVO_RESET
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|0
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_timer_to
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
comment|/* disable interrupts */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_INTR
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_INTR_STATUS
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* reset all Tx rings */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWN_NTXQUEUES
condition|;
name|i
operator|++
control|)
name|iwn_reset_tx_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* reset Rx ring */
name|iwn_reset_rx_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rxq
argument_list|)
expr_stmt|;
name|iwn_mem_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwn_mem_write
argument_list|(
name|sc
argument_list|,
name|IWN_MEM_CLOCK2
argument_list|,
literal|0x200
argument_list|)
expr_stmt|;
name|iwn_mem_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|iwn_stop_master
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_RESET
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_RESET
argument_list|,
name|tmp
operator||
name|IWN_SW_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|iwn_stop
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwn_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Callback from net80211 to start a scan.  */
end_comment

begin_function
specifier|static
name|void
name|iwn_scan_start
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* make the link LED blink while we're scanning */
name|iwn_set_led
argument_list|(
name|sc
argument_list|,
name|IWN_LED_LINK
argument_list|,
literal|20
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Callback from net80211 to terminate a scan.  */
end_comment

begin_function
specifier|static
name|void
name|iwn_scan_end
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
comment|/* ignore */
block|}
end_function

begin_comment
comment|/*  * Callback from net80211 to force a channel change.  */
end_comment

begin_function
specifier|static
name|void
name|iwn_set_channel
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|c
init|=
name|ic
operator|->
name|ic_curchan
decl_stmt|;
name|int
name|error
decl_stmt|;
name|vap
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
expr_stmt|;
comment|/* XXX */
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|sc
operator|->
name|sc_curchan
condition|)
block|{
name|sc
operator|->
name|sc_rxtap
operator|.
name|wr_chan_freq
operator|=
name|htole16
argument_list|(
name|c
operator|->
name|ic_freq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rxtap
operator|.
name|wr_chan_flags
operator|=
name|htole16
argument_list|(
name|c
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txtap
operator|.
name|wt_chan_freq
operator|=
name|htole16
argument_list|(
name|c
operator|->
name|ic_freq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txtap
operator|.
name|wt_chan_flags
operator|=
name|htole16
argument_list|(
name|c
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_STATE
argument_list|,
literal|"%s: set chan failed, cancel scan\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|//XXX Handle failed scan correctly
name|ieee80211_cancel_scan
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
block|}
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Callback from net80211 to start scanning of the current channel.  */
end_comment

begin_function
specifier|static
name|void
name|iwn_scan_curchan
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|unsigned
name|long
name|maxdwell
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ss
operator|->
name|ss_vap
decl_stmt|;
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|vap
operator|->
name|iv_ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_scan
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|ieee80211_cancel_scan
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Callback from net80211 to handle the minimum dwell time being met.  * The intent is to terminate the scan but we just let the firmware  * notify us when it's finished as we have no safe way to abort it.  */
end_comment

begin_function
specifier|static
name|void
name|iwn_scan_mindwell
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|)
block|{
comment|/* NB: don't try to abort scan; wait for firmware to finish */
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_hwreset
parameter_list|(
name|void
modifier|*
name|arg0
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|arg0
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|iwn_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ieee80211_notify_radio
argument_list|(
name|ic
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_radioon
parameter_list|(
name|void
modifier|*
name|arg0
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|arg0
decl_stmt|;
name|iwn_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_radiooff
parameter_list|(
name|void
modifier|*
name|arg0
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|arg0
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ieee80211_notify_radio
argument_list|(
name|ic
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iwn_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_bpfattach
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|bpfattach
argument_list|(
name|ifp
argument_list|,
name|DLT_IEEE802_11_RADIO
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_txtap
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rxtap_len
operator|=
sizeof|sizeof
name|sc
operator|->
name|sc_rxtap
expr_stmt|;
name|sc
operator|->
name|sc_rxtap
operator|.
name|wr_ihdr
operator|.
name|it_len
operator|=
name|htole16
argument_list|(
name|sc
operator|->
name|sc_rxtap_len
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rxtap
operator|.
name|wr_ihdr
operator|.
name|it_present
operator|=
name|htole32
argument_list|(
name|IWN_RX_RADIOTAP_PRESENT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txtap_len
operator|=
sizeof|sizeof
name|sc
operator|->
name|sc_txtap
expr_stmt|;
name|sc
operator|->
name|sc_txtap
operator|.
name|wt_ihdr
operator|.
name|it_len
operator|=
name|htole16
argument_list|(
name|sc
operator|->
name|sc_txtap_len
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txtap
operator|.
name|wt_ihdr
operator|.
name|it_present
operator|=
name|htole32
argument_list|(
name|IWN_TX_RADIOTAP_PRESENT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_sysctlattach
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
init|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|tree
init|=
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|IWN_DEBUG
name|sc
operator|->
name|sc_debug
operator|=
literal|0
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"debug"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|sc_debug
argument_list|,
literal|0
argument_list|,
literal|"control debugging printfs"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IWN_DEBUG
end_ifdef

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|iwn_intr_str
parameter_list|(
name|uint8_t
name|cmd
parameter_list|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
comment|/* Notifications */
case|case
name|IWN_UC_READY
case|:
return|return
literal|"UC_READY"
return|;
case|case
name|IWN_ADD_NODE_DONE
case|:
return|return
literal|"ADD_NODE_DONE"
return|;
case|case
name|IWN_TX_DONE
case|:
return|return
literal|"TX_DONE"
return|;
case|case
name|IWN_START_SCAN
case|:
return|return
literal|"START_SCAN"
return|;
case|case
name|IWN_STOP_SCAN
case|:
return|return
literal|"STOP_SCAN"
return|;
case|case
name|IWN_RX_STATISTICS
case|:
return|return
literal|"RX_STATS"
return|;
case|case
name|IWN_BEACON_STATISTICS
case|:
return|return
literal|"BEACON_STATS"
return|;
case|case
name|IWN_STATE_CHANGED
case|:
return|return
literal|"STATE_CHANGED"
return|;
case|case
name|IWN_BEACON_MISSED
case|:
return|return
literal|"BEACON_MISSED"
return|;
case|case
name|IWN_AMPDU_RX_START
case|:
return|return
literal|"AMPDU_RX_START"
return|;
case|case
name|IWN_AMPDU_RX_DONE
case|:
return|return
literal|"AMPDU_RX_DONE"
return|;
case|case
name|IWN_RX_DONE
case|:
return|return
literal|"RX_DONE"
return|;
comment|/* Command Notifications */
case|case
name|IWN_CMD_CONFIGURE
case|:
return|return
literal|"IWN_CMD_CONFIGURE"
return|;
case|case
name|IWN_CMD_ASSOCIATE
case|:
return|return
literal|"IWN_CMD_ASSOCIATE"
return|;
case|case
name|IWN_CMD_EDCA_PARAMS
case|:
return|return
literal|"IWN_CMD_EDCA_PARAMS"
return|;
case|case
name|IWN_CMD_TSF
case|:
return|return
literal|"IWN_CMD_TSF"
return|;
case|case
name|IWN_CMD_TX_LINK_QUALITY
case|:
return|return
literal|"IWN_CMD_TX_LINK_QUALITY"
return|;
case|case
name|IWN_CMD_SET_LED
case|:
return|return
literal|"IWN_CMD_SET_LED"
return|;
case|case
name|IWN_CMD_SET_POWER_MODE
case|:
return|return
literal|"IWN_CMD_SET_POWER_MODE"
return|;
case|case
name|IWN_CMD_SCAN
case|:
return|return
literal|"IWN_CMD_SCAN"
return|;
case|case
name|IWN_CMD_TXPOWER
case|:
return|return
literal|"IWN_CMD_TXPOWER"
return|;
case|case
name|IWN_CMD_BLUETOOTH
case|:
return|return
literal|"IWN_CMD_BLUETOOTH"
return|;
case|case
name|IWN_CMD_SET_CRITICAL_TEMP
case|:
return|return
literal|"IWN_CMD_SET_CRITICAL_TEMP"
return|;
case|case
name|IWN_SENSITIVITY
case|:
return|return
literal|"IWN_SENSITIVITY"
return|;
case|case
name|IWN_PHY_CALIB
case|:
return|return
literal|"IWN_PHY_CALIB"
return|;
block|}
return|return
literal|"UNKNOWN INTR NOTIF/CMD"
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IWN_DEBUG */
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|iwn_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|iwn_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|iwn_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|iwn_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|iwn_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|iwn_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|iwn_resume
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|iwn_driver
init|=
block|{
literal|"iwn"
block|,
name|iwn_methods
block|,
expr|sizeof
operator|(
expr|struct
name|iwn_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|iwn_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|iwn
argument_list|,
name|pci
argument_list|,
name|iwn_driver
argument_list|,
name|iwn_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|iwn
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|iwn
argument_list|,
name|firmware
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|iwn
argument_list|,
name|wlan
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|iwn
argument_list|,
name|wlan_amrr
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

