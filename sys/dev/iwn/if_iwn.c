begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2007-2009 Damien Bergamini<damien.bergamini@free.fr>  * Copyright (c) 2008 Benjamin Close<benjsc@FreeBSD.org>  * Copyright (c) 2008 Sam Leffler, Errno Consulting  * Copyright (c) 2011 Intel Corporation  * Copyright (c) 2013 Cedric GROSS<c.gross@kreiz-it.fr>  * Copyright (c) 2013 Adrian Chadd<adrian@FreeBSD.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/*  * Driver for Intel WiFi Link 4965 and 1000/5000/6000 Series 802.11 network  * adapters.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_wlan.h"
end_include

begin_include
include|#
directive|include
file|"opt_iwn.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/firmware.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_radiotap.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_regdomain.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_ratectl.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwn/if_iwnreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwn/if_iwnvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwn/if_iwn_devid.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwn/if_iwn_chip_cfg.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwn/if_iwn_debug.h>
end_include

begin_include
include|#
directive|include
file|<dev/iwn/if_iwn_ioctl.h>
end_include

begin_struct
struct|struct
name|iwn_ident
block|{
name|uint16_t
name|vendor
decl_stmt|;
name|uint16_t
name|device
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|iwn_ident
name|iwn_ident_table
index|[]
init|=
block|{
block|{
literal|0x8086
block|,
name|IWN_DID_6x05_1
block|,
literal|"Intel Centrino Advanced-N 6205"
block|}
block|,
block|{
literal|0x8086
block|,
name|IWN_DID_1000_1
block|,
literal|"Intel Centrino Wireless-N 1000"
block|}
block|,
block|{
literal|0x8086
block|,
name|IWN_DID_1000_2
block|,
literal|"Intel Centrino Wireless-N 1000"
block|}
block|,
block|{
literal|0x8086
block|,
name|IWN_DID_6x05_2
block|,
literal|"Intel Centrino Advanced-N 6205"
block|}
block|,
block|{
literal|0x8086
block|,
name|IWN_DID_6050_1
block|,
literal|"Intel Centrino Advanced-N + WiMAX 6250"
block|}
block|,
block|{
literal|0x8086
block|,
name|IWN_DID_6050_2
block|,
literal|"Intel Centrino Advanced-N + WiMAX 6250"
block|}
block|,
block|{
literal|0x8086
block|,
name|IWN_DID_x030_1
block|,
literal|"Intel Centrino Wireless-N 1030"
block|}
block|,
block|{
literal|0x8086
block|,
name|IWN_DID_x030_2
block|,
literal|"Intel Centrino Wireless-N 1030"
block|}
block|,
block|{
literal|0x8086
block|,
name|IWN_DID_x030_3
block|,
literal|"Intel Centrino Advanced-N 6230"
block|}
block|,
block|{
literal|0x8086
block|,
name|IWN_DID_x030_4
block|,
literal|"Intel Centrino Advanced-N 6230"
block|}
block|,
block|{
literal|0x8086
block|,
name|IWN_DID_6150_1
block|,
literal|"Intel Centrino Wireless-N + WiMAX 6150"
block|}
block|,
block|{
literal|0x8086
block|,
name|IWN_DID_6150_2
block|,
literal|"Intel Centrino Wireless-N + WiMAX 6150"
block|}
block|,
block|{
literal|0x8086
block|,
name|IWN_DID_2x00_1
block|,
literal|"Intel(R) Centrino(R) Wireless-N 2200 BGN"
block|}
block|,
block|{
literal|0x8086
block|,
name|IWN_DID_2x00_2
block|,
literal|"Intel(R) Centrino(R) Wireless-N 2200 BGN"
block|}
block|,
comment|/* XXX 2200D is IWN_SDID_2x00_4; there's no way to express this here! */
block|{
literal|0x8086
block|,
name|IWN_DID_2x30_1
block|,
literal|"Intel Centrino Wireless-N 2230"
block|}
block|,
block|{
literal|0x8086
block|,
name|IWN_DID_2x30_2
block|,
literal|"Intel Centrino Wireless-N 2230"
block|}
block|,
block|{
literal|0x8086
block|,
name|IWN_DID_130_1
block|,
literal|"Intel Centrino Wireless-N 130"
block|}
block|,
block|{
literal|0x8086
block|,
name|IWN_DID_130_2
block|,
literal|"Intel Centrino Wireless-N 130"
block|}
block|,
block|{
literal|0x8086
block|,
name|IWN_DID_100_1
block|,
literal|"Intel Centrino Wireless-N 100"
block|}
block|,
block|{
literal|0x8086
block|,
name|IWN_DID_100_2
block|,
literal|"Intel Centrino Wireless-N 100"
block|}
block|,
block|{
literal|0x8086
block|,
name|IWN_DID_105_1
block|,
literal|"Intel Centrino Wireless-N 105"
block|}
block|,
block|{
literal|0x8086
block|,
name|IWN_DID_105_2
block|,
literal|"Intel Centrino Wireless-N 105"
block|}
block|,
block|{
literal|0x8086
block|,
name|IWN_DID_135_1
block|,
literal|"Intel Centrino Wireless-N 135"
block|}
block|,
block|{
literal|0x8086
block|,
name|IWN_DID_135_2
block|,
literal|"Intel Centrino Wireless-N 135"
block|}
block|,
block|{
literal|0x8086
block|,
name|IWN_DID_4965_1
block|,
literal|"Intel Wireless WiFi Link 4965"
block|}
block|,
block|{
literal|0x8086
block|,
name|IWN_DID_6x00_1
block|,
literal|"Intel Centrino Ultimate-N 6300"
block|}
block|,
block|{
literal|0x8086
block|,
name|IWN_DID_6x00_2
block|,
literal|"Intel Centrino Advanced-N 6200"
block|}
block|,
block|{
literal|0x8086
block|,
name|IWN_DID_4965_2
block|,
literal|"Intel Wireless WiFi Link 4965"
block|}
block|,
block|{
literal|0x8086
block|,
name|IWN_DID_4965_3
block|,
literal|"Intel Wireless WiFi Link 4965"
block|}
block|,
block|{
literal|0x8086
block|,
name|IWN_DID_5x00_1
block|,
literal|"Intel WiFi Link 5100"
block|}
block|,
block|{
literal|0x8086
block|,
name|IWN_DID_4965_4
block|,
literal|"Intel Wireless WiFi Link 4965"
block|}
block|,
block|{
literal|0x8086
block|,
name|IWN_DID_5x00_3
block|,
literal|"Intel Ultimate N WiFi Link 5300"
block|}
block|,
block|{
literal|0x8086
block|,
name|IWN_DID_5x00_4
block|,
literal|"Intel Ultimate N WiFi Link 5300"
block|}
block|,
block|{
literal|0x8086
block|,
name|IWN_DID_5x00_2
block|,
literal|"Intel WiFi Link 5100"
block|}
block|,
block|{
literal|0x8086
block|,
name|IWN_DID_6x00_3
block|,
literal|"Intel Centrino Ultimate-N 6300"
block|}
block|,
block|{
literal|0x8086
block|,
name|IWN_DID_6x00_4
block|,
literal|"Intel Centrino Advanced-N 6200"
block|}
block|,
block|{
literal|0x8086
block|,
name|IWN_DID_5x50_1
block|,
literal|"Intel WiMAX/WiFi Link 5350"
block|}
block|,
block|{
literal|0x8086
block|,
name|IWN_DID_5x50_2
block|,
literal|"Intel WiMAX/WiFi Link 5350"
block|}
block|,
block|{
literal|0x8086
block|,
name|IWN_DID_5x50_3
block|,
literal|"Intel WiMAX/WiFi Link 5150"
block|}
block|,
block|{
literal|0x8086
block|,
name|IWN_DID_5x50_4
block|,
literal|"Intel WiMAX/WiFi Link 5150"
block|}
block|,
block|{
literal|0x8086
block|,
name|IWN_DID_6035_1
block|,
literal|"Intel Centrino Advanced 6235"
block|}
block|,
block|{
literal|0x8086
block|,
name|IWN_DID_6035_2
block|,
literal|"Intel Centrino Advanced 6235"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|iwn_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn4965_attach
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn5000_attach
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_config_specific
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_radiotap_attach
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_sysctlattach
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ieee80211vap
modifier|*
name|iwn_vap_create
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
specifier|const
name|char
index|[
name|IFNAMSIZ
index|]
parameter_list|,
name|int
parameter_list|,
name|enum
name|ieee80211_opmode
parameter_list|,
name|int
parameter_list|,
specifier|const
name|uint8_t
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_vap_delete
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_shutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_suspend
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_resume
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_nic_lock
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_eeprom_lock
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_init_otprom
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_read_prom_data
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_dma_map_addr
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_dma_segment_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_dma_contig_alloc
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_dma_info
modifier|*
parameter_list|,
name|void
modifier|*
modifier|*
parameter_list|,
name|bus_size_t
parameter_list|,
name|bus_size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_dma_contig_free
parameter_list|(
name|struct
name|iwn_dma_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_alloc_sched
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_free_sched
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_alloc_kw
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_free_kw
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_alloc_ict
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_free_ict
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_alloc_fwmem
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_free_fwmem
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_alloc_rx_ring
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_reset_rx_ring
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_free_rx_ring
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_alloc_tx_ring
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_tx_ring
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_reset_tx_ring
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_free_tx_ring
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_tx_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn5000_ict_reset
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_read_eeprom
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn4965_read_eeprom
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|IWN_DEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|iwn4965_print_power_group
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|iwn5000_read_eeprom
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|iwn_eeprom_channel_flags
parameter_list|(
name|struct
name|iwn_eeprom_chan
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_read_eeprom_band
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|struct
name|ieee80211_channel
type|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_read_eeprom_ht40
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|struct
name|ieee80211_channel
type|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_read_eeprom_channels
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|iwn_eeprom_chan
modifier|*
name|iwn_find_eeprom_channel
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_getradiocaps
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|struct
name|ieee80211_channel
type|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_setregdomain
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
name|struct
name|ieee80211_regdomain
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|ieee80211_channel
type|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_read_eeprom_enhinfo
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ieee80211_node
modifier|*
name|iwn_node_alloc
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_newassoc
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_newstate
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|enum
name|ieee80211_state
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_calib_timeout
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_rx_phy
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_rx_done
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_rx_compressed_ba
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn5000_rx_calib_results
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_rx_statistics
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn4965_tx_done
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn5000_tx_done
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_data
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_tx_done
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_ampdu_tx_done
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_cmd_done
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_notif_intr
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_wakeup_intr
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_rftoggle_task
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_fatal_intr
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn4965_update_sched
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|uint8_t
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn5000_update_sched
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|uint8_t
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_function_decl
specifier|static
name|void
name|iwn5000_reset_sched
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|iwn_tx_data
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_tx_data_raw
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
name|params
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_xmit_task
parameter_list|(
name|void
modifier|*
name|arg0
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_raw_xmit
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_transmit
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_scan_timeout
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_watchdog
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_ioctl
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_parent
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_cmd
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn4965_add_node
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_node_info
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn5000_add_node
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_node_info
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_set_link_quality
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_add_broadcast_node
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_updateedca
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_set_promisc
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_update_promisc
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_update_mcast
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_set_led
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_set_critical_temp
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_set_timing
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn4965_power_calibration
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn4965_set_txpower
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn5000_set_txpower
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn4965_get_rssi
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_stat
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn5000_get_rssi
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_rx_stat
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_get_noise
parameter_list|(
specifier|const
name|struct
name|iwn_rx_general_stats
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn4965_get_temperature
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn5000_get_temperature
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_init_sensitivity
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_collect_noise
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|iwn_rx_general_stats
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn4965_init_gains
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn5000_init_gains
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn4965_set_gains
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn5000_set_gains
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_tune_sensitivity
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|iwn_rx_stats
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_save_stats_counters
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
specifier|const
name|struct
name|iwn_stats
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_send_sensitivity
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_check_rx_recovery
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_stats
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_set_pslevel
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_send_btcoex
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_send_advanced_btcoex
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn5000_runtime_calib
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_check_bss_filter
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn4965_rxon_assoc
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn5000_rxon_assoc
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_send_rxon
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_config
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_scan
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|struct
name|ieee80211_scan_state
modifier|*
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_auth
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_run
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_ampdu_rx_start
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|struct
name|ieee80211_rx_ampdu
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_ampdu_rx_stop
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|struct
name|ieee80211_rx_ampdu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_addba_request
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_addba_response
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_ampdu_tx_start
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_ampdu_tx_stop
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn4965_ampdu_tx_start
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uint8_t
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn4965_ampdu_tx_stop
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uint8_t
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn5000_ampdu_tx_start
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uint8_t
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn5000_ampdu_tx_stop
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uint8_t
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn5000_query_calibration
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn5000_send_calibration
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn5000_send_wimax_coex
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn5000_crystal_calib
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn5000_temp_offset_calib
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn5000_temp_offset_calibv2
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn4965_post_alive
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn5000_post_alive
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn4965_load_bootcode
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn4965_load_firmware
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn5000_load_firmware_section
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn5000_load_firmware
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_read_firmware_leg
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_fw_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_read_firmware_tlv
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|,
name|struct
name|iwn_fw_info
modifier|*
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_read_firmware
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_unload_firmware
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_clock_wait
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_apm_init
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_apm_stop_master
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_apm_stop
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn4965_nic_config
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn5000_nic_config
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_hw_prepare
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_hw_init
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_hw_stop
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_panicked
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_init_locked
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iwn_init
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_stop_locked
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_stop
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_scan_start
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_scan_end
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_set_channel
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_scan_curchan
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
parameter_list|,
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_scan_mindwell
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|IWN_DEBUG
end_ifdef

begin_function_decl
specifier|static
name|char
modifier|*
name|iwn_get_csr_string
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iwn_debug_register
parameter_list|(
name|struct
name|iwn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|device_method_t
name|iwn_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|iwn_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|iwn_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|iwn_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|iwn_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|iwn_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|iwn_resume
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|iwn_driver
init|=
block|{
literal|"iwn"
block|,
name|iwn_methods
block|,
expr|sizeof
operator|(
expr|struct
name|iwn_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|iwn_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|iwn
argument_list|,
name|pci
argument_list|,
name|iwn_driver
argument_list|,
name|iwn_devclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|iwn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|iwn
argument_list|,
name|firmware
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|iwn
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|iwn
argument_list|,
name|wlan
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|iwn_cdev_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|iwn_cdev_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|iwn_cdev_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|iwn_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
literal|0
block|,
operator|.
name|d_open
operator|=
name|iwn_cdev_open
block|,
operator|.
name|d_close
operator|=
name|iwn_cdev_close
block|,
operator|.
name|d_ioctl
operator|=
name|iwn_cdev_ioctl
block|,
operator|.
name|d_name
operator|=
literal|"iwn"
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|iwn_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
specifier|const
name|struct
name|iwn_ident
modifier|*
name|ident
decl_stmt|;
for|for
control|(
name|ident
operator|=
name|iwn_ident_table
init|;
name|ident
operator|->
name|name
operator|!=
name|NULL
condition|;
name|ident
operator|++
control|)
block|{
if|if
condition|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|ident
operator|->
name|vendor
operator|&&
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|ident
operator|->
name|device
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|ident
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
block|}
return|return
name|ENXIO
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_is_3stream_device
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* XXX for now only 5300, until the 5350 can be tested */
if|if
condition|(
name|sc
operator|->
name|hw_type
operator|==
name|IWN_HW_REV_TYPE_5300
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|rid
decl_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
ifdef|#
directive|ifdef
name|IWN_DEBUG
name|error
operator|=
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
literal|"debug"
argument_list|,
operator|&
operator|(
name|sc
operator|->
name|sc_debug
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|sc
operator|->
name|sc_debug
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|sc
operator|->
name|sc_debug
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s: begin\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 	 * Get the offset of the PCI Express Capability Structure in PCI 	 * Configuration Space. 	 */
name|error
operator|=
name|pci_find_cap
argument_list|(
name|dev
argument_list|,
name|PCIY_EXPRESS
argument_list|,
operator|&
name|sc
operator|->
name|sc_cap_off
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"PCIe capability structure not found!\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Clear device-specific "PCI retry timeout" register (41h). */
name|pci_write_config
argument_list|(
name|dev
argument_list|,
literal|0x41
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Enable bus-mastering. */
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't map mem space\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
return|return
name|error
return|;
block|}
name|sc
operator|->
name|sc_st
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|mem
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_sh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|mem
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
name|rid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pci_alloc_msi
argument_list|(
name|dev
argument_list|,
operator|&
name|i
argument_list|)
operator|==
literal|0
condition|)
name|rid
operator|=
literal|1
expr_stmt|;
comment|/* Install interrupt handler. */
name|sc
operator|->
name|irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
operator||
operator|(
name|rid
operator|!=
literal|0
condition|?
literal|0
else|:
name|RF_SHAREABLE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't map interrupt\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|IWN_LOCK_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Read hardware revision and attach. */
name|sc
operator|->
name|hw_type
operator|=
operator|(
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_HW_REV
argument_list|)
operator|>>
name|IWN_HW_REV_TYPE_SHIFT
operator|)
operator|&
name|IWN_HW_REV_TYPE_MASK
expr_stmt|;
name|sc
operator|->
name|subdevice_id
operator|=
name|pci_get_subdevice
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * 4965 versus 5000 and later have different methods. 	 * Let's set those up first. 	 */
if|if
condition|(
name|sc
operator|->
name|hw_type
operator|==
name|IWN_HW_REV_TYPE_4965
condition|)
name|error
operator|=
name|iwn4965_attach
argument_list|(
name|sc
argument_list|,
name|pci_get_device
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|iwn5000_attach
argument_list|(
name|sc
argument_list|,
name|pci_get_device
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not attach device, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * Next, let's setup the various parameters of each NIC. 	 */
name|error
operator|=
name|iwn_config_specific
argument_list|(
name|sc
argument_list|,
name|pci_get_device
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not attach device, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_hw_prepare
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"hardware not ready, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Allocate DMA memory for firmware transfers. */
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_alloc_fwmem
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate memory for firmware, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Allocate "Keep Warm" page. */
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_alloc_kw
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate keep warm page, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Allocate ICT table for 5000 Series. */
if|if
condition|(
name|sc
operator|->
name|hw_type
operator|!=
name|IWN_HW_REV_TYPE_4965
operator|&&
operator|(
name|error
operator|=
name|iwn_alloc_ict
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate ICT table, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Allocate TX scheduler "rings". */
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_alloc_sched
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate TX scheduler rings, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Allocate TX rings (16 on 4965AGN, 20 on>=5000). */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|ntxqs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_alloc_tx_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|txq
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate TX ring %d, error %d\n"
argument_list|,
name|i
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* Allocate RX ring. */
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_alloc_rx_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rxq
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate RX ring, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Clear pending interrupts. */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_INT
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|ic
operator|=
operator|&
name|sc
operator|->
name|sc_ic
expr_stmt|;
name|ic
operator|->
name|ic_softc
operator|=
name|sc
expr_stmt|;
name|ic
operator|->
name|ic_name
operator|=
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_phytype
operator|=
name|IEEE80211_T_OFDM
expr_stmt|;
comment|/* not only, but not used */
name|ic
operator|->
name|ic_opmode
operator|=
name|IEEE80211_M_STA
expr_stmt|;
comment|/* default to BSS mode */
comment|/* Set device capabilities. */
name|ic
operator|->
name|ic_caps
operator|=
name|IEEE80211_C_STA
comment|/* station mode supported */
operator||
name|IEEE80211_C_MONITOR
comment|/* monitor mode supported */
if|#
directive|if
literal|0
expr|| IEEE80211_C_BGSCAN
comment|/* background scanning */
endif|#
directive|endif
operator||
name|IEEE80211_C_TXPMGT
comment|/* tx power management */
operator||
name|IEEE80211_C_SHSLOT
comment|/* short slot time supported */
operator||
name|IEEE80211_C_WPA
operator||
name|IEEE80211_C_SHPREAMBLE
comment|/* short preamble supported */
if|#
directive|if
literal|0
expr|| IEEE80211_C_IBSS
comment|/* ibss/adhoc mode */
endif|#
directive|endif
operator||
name|IEEE80211_C_WME
comment|/* WME */
operator||
name|IEEE80211_C_PMGT
comment|/* Station-side power mgmt */
expr_stmt|;
comment|/* Read MAC address, channels, etc from EEPROM. */
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_read_eeprom
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_macaddr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not read EEPROM, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Count the number of available chains. */
name|sc
operator|->
name|ntxchains
operator|=
operator|(
operator|(
name|sc
operator|->
name|txchainmask
operator|>>
literal|2
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|sc
operator|->
name|txchainmask
operator|>>
literal|1
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|sc
operator|->
name|txchainmask
operator|>>
literal|0
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
name|sc
operator|->
name|nrxchains
operator|=
operator|(
operator|(
name|sc
operator|->
name|rxchainmask
operator|>>
literal|2
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|sc
operator|->
name|rxchainmask
operator|>>
literal|1
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|sc
operator|->
name|rxchainmask
operator|>>
literal|0
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"MIMO %dT%dR, %.4s, address %6D\n"
argument_list|,
name|sc
operator|->
name|ntxchains
argument_list|,
name|sc
operator|->
name|nrxchains
argument_list|,
name|sc
operator|->
name|eeprom_domain
argument_list|,
name|ic
operator|->
name|ic_macaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWN_FLAG_HAS_11N
condition|)
block|{
name|ic
operator|->
name|ic_rxstream
operator|=
name|sc
operator|->
name|nrxchains
expr_stmt|;
name|ic
operator|->
name|ic_txstream
operator|=
name|sc
operator|->
name|ntxchains
expr_stmt|;
comment|/* 		 * Some of the 3 antenna devices (ie, the 4965) only supports 		 * 2x2 operation.  So correct the number of streams if 		 * it's not a 3-stream device. 		 */
if|if
condition|(
operator|!
name|iwn_is_3stream_device
argument_list|(
name|sc
argument_list|)
condition|)
block|{
if|if
condition|(
name|ic
operator|->
name|ic_rxstream
operator|>
literal|2
condition|)
name|ic
operator|->
name|ic_rxstream
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_txstream
operator|>
literal|2
condition|)
name|ic
operator|->
name|ic_txstream
operator|=
literal|2
expr_stmt|;
block|}
name|ic
operator|->
name|ic_htcaps
operator|=
name|IEEE80211_HTCAP_SMPS_OFF
comment|/* SMPS mode disabled */
operator||
name|IEEE80211_HTCAP_SHORTGI20
comment|/* short GI in 20MHz */
operator||
name|IEEE80211_HTCAP_CHWIDTH40
comment|/* 40MHz channel width*/
operator||
name|IEEE80211_HTCAP_SHORTGI40
comment|/* short GI in 40MHz */
ifdef|#
directive|ifdef
name|notyet
operator||
name|IEEE80211_HTCAP_GREENFIELD
if|#
directive|if
name|IWN_RBUF_SIZE
operator|==
literal|8192
operator||
name|IEEE80211_HTCAP_MAXAMSDU_7935
comment|/* max A-MSDU length */
else|#
directive|else
operator||
name|IEEE80211_HTCAP_MAXAMSDU_3839
comment|/* max A-MSDU length */
endif|#
directive|endif
endif|#
directive|endif
comment|/* s/w capabilities */
operator||
name|IEEE80211_HTC_HT
comment|/* HT operation */
operator||
name|IEEE80211_HTC_AMPDU
comment|/* tx A-MPDU */
ifdef|#
directive|ifdef
name|notyet
operator||
name|IEEE80211_HTC_AMSDU
comment|/* tx A-MSDU */
endif|#
directive|endif
expr_stmt|;
block|}
name|ieee80211_ifattach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_vap_create
operator|=
name|iwn_vap_create
expr_stmt|;
name|ic
operator|->
name|ic_ioctl
operator|=
name|iwn_ioctl
expr_stmt|;
name|ic
operator|->
name|ic_parent
operator|=
name|iwn_parent
expr_stmt|;
name|ic
operator|->
name|ic_vap_delete
operator|=
name|iwn_vap_delete
expr_stmt|;
name|ic
operator|->
name|ic_transmit
operator|=
name|iwn_transmit
expr_stmt|;
name|ic
operator|->
name|ic_raw_xmit
operator|=
name|iwn_raw_xmit
expr_stmt|;
name|ic
operator|->
name|ic_node_alloc
operator|=
name|iwn_node_alloc
expr_stmt|;
name|sc
operator|->
name|sc_ampdu_rx_start
operator|=
name|ic
operator|->
name|ic_ampdu_rx_start
expr_stmt|;
name|ic
operator|->
name|ic_ampdu_rx_start
operator|=
name|iwn_ampdu_rx_start
expr_stmt|;
name|sc
operator|->
name|sc_ampdu_rx_stop
operator|=
name|ic
operator|->
name|ic_ampdu_rx_stop
expr_stmt|;
name|ic
operator|->
name|ic_ampdu_rx_stop
operator|=
name|iwn_ampdu_rx_stop
expr_stmt|;
name|sc
operator|->
name|sc_addba_request
operator|=
name|ic
operator|->
name|ic_addba_request
expr_stmt|;
name|ic
operator|->
name|ic_addba_request
operator|=
name|iwn_addba_request
expr_stmt|;
name|sc
operator|->
name|sc_addba_response
operator|=
name|ic
operator|->
name|ic_addba_response
expr_stmt|;
name|ic
operator|->
name|ic_addba_response
operator|=
name|iwn_addba_response
expr_stmt|;
name|sc
operator|->
name|sc_addba_stop
operator|=
name|ic
operator|->
name|ic_addba_stop
expr_stmt|;
name|ic
operator|->
name|ic_addba_stop
operator|=
name|iwn_ampdu_tx_stop
expr_stmt|;
name|ic
operator|->
name|ic_newassoc
operator|=
name|iwn_newassoc
expr_stmt|;
name|ic
operator|->
name|ic_wme
operator|.
name|wme_update
operator|=
name|iwn_updateedca
expr_stmt|;
name|ic
operator|->
name|ic_update_promisc
operator|=
name|iwn_update_promisc
expr_stmt|;
name|ic
operator|->
name|ic_update_mcast
operator|=
name|iwn_update_mcast
expr_stmt|;
name|ic
operator|->
name|ic_scan_start
operator|=
name|iwn_scan_start
expr_stmt|;
name|ic
operator|->
name|ic_scan_end
operator|=
name|iwn_scan_end
expr_stmt|;
name|ic
operator|->
name|ic_set_channel
operator|=
name|iwn_set_channel
expr_stmt|;
name|ic
operator|->
name|ic_scan_curchan
operator|=
name|iwn_scan_curchan
expr_stmt|;
name|ic
operator|->
name|ic_scan_mindwell
operator|=
name|iwn_scan_mindwell
expr_stmt|;
name|ic
operator|->
name|ic_getradiocaps
operator|=
name|iwn_getradiocaps
expr_stmt|;
name|ic
operator|->
name|ic_setregdomain
operator|=
name|iwn_setregdomain
expr_stmt|;
name|iwn_radiotap_attach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|calib_to
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|scan_timeout
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|watchdog_to
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_rftoggle_task
argument_list|,
literal|0
argument_list|,
name|iwn_rftoggle_task
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_panic_task
argument_list|,
literal|0
argument_list|,
name|iwn_panicked
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_xmit_task
argument_list|,
literal|0
argument_list|,
name|iwn_xmit_task
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|mbufq_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_xmit_queue
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tq
operator|=
name|taskqueue_create
argument_list|(
literal|"iwn_taskq"
argument_list|,
name|M_WAITOK
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
name|error
operator|=
name|taskqueue_start_threads
argument_list|(
operator|&
name|sc
operator|->
name|sc_tq
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"iwn_taskq"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't start threads, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|iwn_sysctlattach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Hook our interrupt after all initialization is complete. 	 */
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|iwn_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't establish interrupt, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|#
directive|if
literal|0
block|device_printf(sc->sc_dev, "%s: rx_stats=%d, rx_stats_bt=%d\n", 	    __func__, 	    sizeof(struct iwn_stats), 	    sizeof(struct iwn_stats_bt));
endif|#
directive|endif
if|if
condition|(
name|bootverbose
condition|)
name|ieee80211_announce
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s: end\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Add debug ioctl right at the end */
name|sc
operator|->
name|sc_cdev
operator|=
name|make_dev
argument_list|(
operator|&
name|iwn_cdevsw
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"%s"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_cdev
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to create debug character device\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_cdev
operator|->
name|si_drv1
operator|=
name|sc
expr_stmt|;
block|}
return|return
literal|0
return|;
name|fail
label|:
name|iwn_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s: end in error\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Define specific configuration based on device id and subdevice id  * pid : PCI device id  */
end_comment

begin_function
specifier|static
name|int
name|iwn_config_specific
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|pid
parameter_list|)
block|{
switch|switch
condition|(
name|pid
condition|)
block|{
comment|/* 4965 series */
case|case
name|IWN_DID_4965_1
case|:
case|case
name|IWN_DID_4965_2
case|:
case|case
name|IWN_DID_4965_3
case|:
case|case
name|IWN_DID_4965_4
case|:
name|sc
operator|->
name|base_params
operator|=
operator|&
name|iwn4965_base_params
expr_stmt|;
name|sc
operator|->
name|limits
operator|=
operator|&
name|iwn4965_sensitivity_limits
expr_stmt|;
name|sc
operator|->
name|fwname
operator|=
literal|"iwn4965fw"
expr_stmt|;
comment|/* Override chains masks, ROM is known to be broken. */
name|sc
operator|->
name|txchainmask
operator|=
name|IWN_ANT_AB
expr_stmt|;
name|sc
operator|->
name|rxchainmask
operator|=
name|IWN_ANT_ABC
expr_stmt|;
comment|/* Enable normal btcoex */
name|sc
operator|->
name|sc_flags
operator||=
name|IWN_FLAG_BTCOEX
expr_stmt|;
break|break;
comment|/* 1000 Series */
case|case
name|IWN_DID_1000_1
case|:
case|case
name|IWN_DID_1000_2
case|:
switch|switch
condition|(
name|sc
operator|->
name|subdevice_id
condition|)
block|{
case|case
name|IWN_SDID_1000_1
case|:
case|case
name|IWN_SDID_1000_2
case|:
case|case
name|IWN_SDID_1000_3
case|:
case|case
name|IWN_SDID_1000_4
case|:
case|case
name|IWN_SDID_1000_5
case|:
case|case
name|IWN_SDID_1000_6
case|:
case|case
name|IWN_SDID_1000_7
case|:
case|case
name|IWN_SDID_1000_8
case|:
case|case
name|IWN_SDID_1000_9
case|:
case|case
name|IWN_SDID_1000_10
case|:
case|case
name|IWN_SDID_1000_11
case|:
case|case
name|IWN_SDID_1000_12
case|:
name|sc
operator|->
name|limits
operator|=
operator|&
name|iwn1000_sensitivity_limits
expr_stmt|;
name|sc
operator|->
name|base_params
operator|=
operator|&
name|iwn1000_base_params
expr_stmt|;
name|sc
operator|->
name|fwname
operator|=
literal|"iwn1000fw"
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"adapter type id : 0x%04x sub id :"
literal|"0x%04x rev %d not supported (subdevice)\n"
argument_list|,
name|pid
argument_list|,
name|sc
operator|->
name|subdevice_id
argument_list|,
name|sc
operator|->
name|hw_type
argument_list|)
expr_stmt|;
return|return
name|ENOTSUP
return|;
block|}
break|break;
comment|/* 6x00 Series */
case|case
name|IWN_DID_6x00_2
case|:
case|case
name|IWN_DID_6x00_4
case|:
case|case
name|IWN_DID_6x00_1
case|:
case|case
name|IWN_DID_6x00_3
case|:
name|sc
operator|->
name|fwname
operator|=
literal|"iwn6000fw"
expr_stmt|;
name|sc
operator|->
name|limits
operator|=
operator|&
name|iwn6000_sensitivity_limits
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|subdevice_id
condition|)
block|{
case|case
name|IWN_SDID_6x00_1
case|:
case|case
name|IWN_SDID_6x00_2
case|:
case|case
name|IWN_SDID_6x00_8
case|:
comment|//iwl6000_3agn_cfg
name|sc
operator|->
name|base_params
operator|=
operator|&
name|iwn_6000_base_params
expr_stmt|;
break|break;
case|case
name|IWN_SDID_6x00_3
case|:
case|case
name|IWN_SDID_6x00_6
case|:
case|case
name|IWN_SDID_6x00_9
case|:
comment|////iwl6000i_2agn
case|case
name|IWN_SDID_6x00_4
case|:
case|case
name|IWN_SDID_6x00_7
case|:
case|case
name|IWN_SDID_6x00_10
case|:
comment|//iwl6000i_2abg_cfg
case|case
name|IWN_SDID_6x00_5
case|:
comment|//iwl6000i_2bg_cfg
name|sc
operator|->
name|base_params
operator|=
operator|&
name|iwn_6000i_base_params
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|IWN_FLAG_INTERNAL_PA
expr_stmt|;
name|sc
operator|->
name|txchainmask
operator|=
name|IWN_ANT_BC
expr_stmt|;
name|sc
operator|->
name|rxchainmask
operator|=
name|IWN_ANT_BC
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"adapter type id : 0x%04x sub id :"
literal|"0x%04x rev %d not supported (subdevice)\n"
argument_list|,
name|pid
argument_list|,
name|sc
operator|->
name|subdevice_id
argument_list|,
name|sc
operator|->
name|hw_type
argument_list|)
expr_stmt|;
return|return
name|ENOTSUP
return|;
block|}
break|break;
comment|/* 6x05 Series */
case|case
name|IWN_DID_6x05_1
case|:
case|case
name|IWN_DID_6x05_2
case|:
switch|switch
condition|(
name|sc
operator|->
name|subdevice_id
condition|)
block|{
case|case
name|IWN_SDID_6x05_1
case|:
case|case
name|IWN_SDID_6x05_4
case|:
case|case
name|IWN_SDID_6x05_6
case|:
comment|//iwl6005_2agn_cfg
case|case
name|IWN_SDID_6x05_2
case|:
case|case
name|IWN_SDID_6x05_5
case|:
case|case
name|IWN_SDID_6x05_7
case|:
comment|//iwl6005_2abg_cfg
case|case
name|IWN_SDID_6x05_3
case|:
comment|//iwl6005_2bg_cfg
case|case
name|IWN_SDID_6x05_8
case|:
case|case
name|IWN_SDID_6x05_9
case|:
comment|//iwl6005_2agn_sff_cfg
case|case
name|IWN_SDID_6x05_10
case|:
comment|//iwl6005_2agn_d_cfg
case|case
name|IWN_SDID_6x05_11
case|:
comment|//iwl6005_2agn_mow1_cfg
case|case
name|IWN_SDID_6x05_12
case|:
comment|//iwl6005_2agn_mow2_cfg
name|sc
operator|->
name|fwname
operator|=
literal|"iwn6000g2afw"
expr_stmt|;
name|sc
operator|->
name|limits
operator|=
operator|&
name|iwn6000_sensitivity_limits
expr_stmt|;
name|sc
operator|->
name|base_params
operator|=
operator|&
name|iwn_6000g2_base_params
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"adapter type id : 0x%04x sub id :"
literal|"0x%04x rev %d not supported (subdevice)\n"
argument_list|,
name|pid
argument_list|,
name|sc
operator|->
name|subdevice_id
argument_list|,
name|sc
operator|->
name|hw_type
argument_list|)
expr_stmt|;
return|return
name|ENOTSUP
return|;
block|}
break|break;
comment|/* 6x35 Series */
case|case
name|IWN_DID_6035_1
case|:
case|case
name|IWN_DID_6035_2
case|:
switch|switch
condition|(
name|sc
operator|->
name|subdevice_id
condition|)
block|{
case|case
name|IWN_SDID_6035_1
case|:
case|case
name|IWN_SDID_6035_2
case|:
case|case
name|IWN_SDID_6035_3
case|:
case|case
name|IWN_SDID_6035_4
case|:
name|sc
operator|->
name|fwname
operator|=
literal|"iwn6000g2bfw"
expr_stmt|;
name|sc
operator|->
name|limits
operator|=
operator|&
name|iwn6235_sensitivity_limits
expr_stmt|;
name|sc
operator|->
name|base_params
operator|=
operator|&
name|iwn_6235_base_params
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"adapter type id : 0x%04x sub id :"
literal|"0x%04x rev %d not supported (subdevice)\n"
argument_list|,
name|pid
argument_list|,
name|sc
operator|->
name|subdevice_id
argument_list|,
name|sc
operator|->
name|hw_type
argument_list|)
expr_stmt|;
return|return
name|ENOTSUP
return|;
block|}
break|break;
comment|/* 6x50 WiFi/WiMax Series */
case|case
name|IWN_DID_6050_1
case|:
case|case
name|IWN_DID_6050_2
case|:
switch|switch
condition|(
name|sc
operator|->
name|subdevice_id
condition|)
block|{
case|case
name|IWN_SDID_6050_1
case|:
case|case
name|IWN_SDID_6050_3
case|:
case|case
name|IWN_SDID_6050_5
case|:
comment|//iwl6050_2agn_cfg
case|case
name|IWN_SDID_6050_2
case|:
case|case
name|IWN_SDID_6050_4
case|:
case|case
name|IWN_SDID_6050_6
case|:
comment|//iwl6050_2abg_cfg
name|sc
operator|->
name|fwname
operator|=
literal|"iwn6050fw"
expr_stmt|;
name|sc
operator|->
name|txchainmask
operator|=
name|IWN_ANT_AB
expr_stmt|;
name|sc
operator|->
name|rxchainmask
operator|=
name|IWN_ANT_AB
expr_stmt|;
name|sc
operator|->
name|limits
operator|=
operator|&
name|iwn6000_sensitivity_limits
expr_stmt|;
name|sc
operator|->
name|base_params
operator|=
operator|&
name|iwn_6050_base_params
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"adapter type id : 0x%04x sub id :"
literal|"0x%04x rev %d not supported (subdevice)\n"
argument_list|,
name|pid
argument_list|,
name|sc
operator|->
name|subdevice_id
argument_list|,
name|sc
operator|->
name|hw_type
argument_list|)
expr_stmt|;
return|return
name|ENOTSUP
return|;
block|}
break|break;
comment|/* 6150 WiFi/WiMax Series */
case|case
name|IWN_DID_6150_1
case|:
case|case
name|IWN_DID_6150_2
case|:
switch|switch
condition|(
name|sc
operator|->
name|subdevice_id
condition|)
block|{
case|case
name|IWN_SDID_6150_1
case|:
case|case
name|IWN_SDID_6150_3
case|:
case|case
name|IWN_SDID_6150_5
case|:
comment|// iwl6150_bgn_cfg
case|case
name|IWN_SDID_6150_2
case|:
case|case
name|IWN_SDID_6150_4
case|:
case|case
name|IWN_SDID_6150_6
case|:
comment|//iwl6150_bg_cfg
name|sc
operator|->
name|fwname
operator|=
literal|"iwn6050fw"
expr_stmt|;
name|sc
operator|->
name|limits
operator|=
operator|&
name|iwn6000_sensitivity_limits
expr_stmt|;
name|sc
operator|->
name|base_params
operator|=
operator|&
name|iwn_6150_base_params
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"adapter type id : 0x%04x sub id :"
literal|"0x%04x rev %d not supported (subdevice)\n"
argument_list|,
name|pid
argument_list|,
name|sc
operator|->
name|subdevice_id
argument_list|,
name|sc
operator|->
name|hw_type
argument_list|)
expr_stmt|;
return|return
name|ENOTSUP
return|;
block|}
break|break;
comment|/* 6030 Series and 1030 Series */
case|case
name|IWN_DID_x030_1
case|:
case|case
name|IWN_DID_x030_2
case|:
case|case
name|IWN_DID_x030_3
case|:
case|case
name|IWN_DID_x030_4
case|:
switch|switch
condition|(
name|sc
operator|->
name|subdevice_id
condition|)
block|{
case|case
name|IWN_SDID_x030_1
case|:
case|case
name|IWN_SDID_x030_3
case|:
case|case
name|IWN_SDID_x030_5
case|:
comment|// iwl1030_bgn_cfg
case|case
name|IWN_SDID_x030_2
case|:
case|case
name|IWN_SDID_x030_4
case|:
case|case
name|IWN_SDID_x030_6
case|:
comment|//iwl1030_bg_cfg
case|case
name|IWN_SDID_x030_7
case|:
case|case
name|IWN_SDID_x030_10
case|:
case|case
name|IWN_SDID_x030_14
case|:
comment|//iwl6030_2agn_cfg
case|case
name|IWN_SDID_x030_8
case|:
case|case
name|IWN_SDID_x030_11
case|:
case|case
name|IWN_SDID_x030_15
case|:
comment|// iwl6030_2bgn_cfg
case|case
name|IWN_SDID_x030_9
case|:
case|case
name|IWN_SDID_x030_12
case|:
case|case
name|IWN_SDID_x030_16
case|:
comment|// iwl6030_2abg_cfg
case|case
name|IWN_SDID_x030_13
case|:
comment|//iwl6030_2bg_cfg
name|sc
operator|->
name|fwname
operator|=
literal|"iwn6000g2bfw"
expr_stmt|;
name|sc
operator|->
name|limits
operator|=
operator|&
name|iwn6000_sensitivity_limits
expr_stmt|;
name|sc
operator|->
name|base_params
operator|=
operator|&
name|iwn_6000g2b_base_params
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"adapter type id : 0x%04x sub id :"
literal|"0x%04x rev %d not supported (subdevice)\n"
argument_list|,
name|pid
argument_list|,
name|sc
operator|->
name|subdevice_id
argument_list|,
name|sc
operator|->
name|hw_type
argument_list|)
expr_stmt|;
return|return
name|ENOTSUP
return|;
block|}
break|break;
comment|/* 130 Series WiFi */
comment|/* XXX: This series will need adjustment for rate.  * see rx_with_siso_diversity in linux kernel  */
case|case
name|IWN_DID_130_1
case|:
case|case
name|IWN_DID_130_2
case|:
switch|switch
condition|(
name|sc
operator|->
name|subdevice_id
condition|)
block|{
case|case
name|IWN_SDID_130_1
case|:
case|case
name|IWN_SDID_130_3
case|:
case|case
name|IWN_SDID_130_5
case|:
comment|//iwl130_bgn_cfg
case|case
name|IWN_SDID_130_2
case|:
case|case
name|IWN_SDID_130_4
case|:
case|case
name|IWN_SDID_130_6
case|:
comment|//iwl130_bg_cfg
name|sc
operator|->
name|fwname
operator|=
literal|"iwn6000g2bfw"
expr_stmt|;
name|sc
operator|->
name|limits
operator|=
operator|&
name|iwn6000_sensitivity_limits
expr_stmt|;
name|sc
operator|->
name|base_params
operator|=
operator|&
name|iwn_6000g2b_base_params
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"adapter type id : 0x%04x sub id :"
literal|"0x%04x rev %d not supported (subdevice)\n"
argument_list|,
name|pid
argument_list|,
name|sc
operator|->
name|subdevice_id
argument_list|,
name|sc
operator|->
name|hw_type
argument_list|)
expr_stmt|;
return|return
name|ENOTSUP
return|;
block|}
break|break;
comment|/* 100 Series WiFi */
case|case
name|IWN_DID_100_1
case|:
case|case
name|IWN_DID_100_2
case|:
switch|switch
condition|(
name|sc
operator|->
name|subdevice_id
condition|)
block|{
case|case
name|IWN_SDID_100_1
case|:
case|case
name|IWN_SDID_100_2
case|:
case|case
name|IWN_SDID_100_3
case|:
case|case
name|IWN_SDID_100_4
case|:
case|case
name|IWN_SDID_100_5
case|:
case|case
name|IWN_SDID_100_6
case|:
name|sc
operator|->
name|limits
operator|=
operator|&
name|iwn1000_sensitivity_limits
expr_stmt|;
name|sc
operator|->
name|base_params
operator|=
operator|&
name|iwn1000_base_params
expr_stmt|;
name|sc
operator|->
name|fwname
operator|=
literal|"iwn100fw"
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"adapter type id : 0x%04x sub id :"
literal|"0x%04x rev %d not supported (subdevice)\n"
argument_list|,
name|pid
argument_list|,
name|sc
operator|->
name|subdevice_id
argument_list|,
name|sc
operator|->
name|hw_type
argument_list|)
expr_stmt|;
return|return
name|ENOTSUP
return|;
block|}
break|break;
comment|/* 105 Series */
comment|/* XXX: This series will need adjustment for rate.  * see rx_with_siso_diversity in linux kernel  */
case|case
name|IWN_DID_105_1
case|:
case|case
name|IWN_DID_105_2
case|:
switch|switch
condition|(
name|sc
operator|->
name|subdevice_id
condition|)
block|{
case|case
name|IWN_SDID_105_1
case|:
case|case
name|IWN_SDID_105_2
case|:
case|case
name|IWN_SDID_105_3
case|:
comment|//iwl105_bgn_cfg
case|case
name|IWN_SDID_105_4
case|:
comment|//iwl105_bgn_d_cfg
name|sc
operator|->
name|limits
operator|=
operator|&
name|iwn2030_sensitivity_limits
expr_stmt|;
name|sc
operator|->
name|base_params
operator|=
operator|&
name|iwn2000_base_params
expr_stmt|;
name|sc
operator|->
name|fwname
operator|=
literal|"iwn105fw"
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"adapter type id : 0x%04x sub id :"
literal|"0x%04x rev %d not supported (subdevice)\n"
argument_list|,
name|pid
argument_list|,
name|sc
operator|->
name|subdevice_id
argument_list|,
name|sc
operator|->
name|hw_type
argument_list|)
expr_stmt|;
return|return
name|ENOTSUP
return|;
block|}
break|break;
comment|/* 135 Series */
comment|/* XXX: This series will need adjustment for rate.  * see rx_with_siso_diversity in linux kernel  */
case|case
name|IWN_DID_135_1
case|:
case|case
name|IWN_DID_135_2
case|:
switch|switch
condition|(
name|sc
operator|->
name|subdevice_id
condition|)
block|{
case|case
name|IWN_SDID_135_1
case|:
case|case
name|IWN_SDID_135_2
case|:
case|case
name|IWN_SDID_135_3
case|:
name|sc
operator|->
name|limits
operator|=
operator|&
name|iwn2030_sensitivity_limits
expr_stmt|;
name|sc
operator|->
name|base_params
operator|=
operator|&
name|iwn2030_base_params
expr_stmt|;
name|sc
operator|->
name|fwname
operator|=
literal|"iwn135fw"
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"adapter type id : 0x%04x sub id :"
literal|"0x%04x rev %d not supported (subdevice)\n"
argument_list|,
name|pid
argument_list|,
name|sc
operator|->
name|subdevice_id
argument_list|,
name|sc
operator|->
name|hw_type
argument_list|)
expr_stmt|;
return|return
name|ENOTSUP
return|;
block|}
break|break;
comment|/* 2x00 Series */
case|case
name|IWN_DID_2x00_1
case|:
case|case
name|IWN_DID_2x00_2
case|:
switch|switch
condition|(
name|sc
operator|->
name|subdevice_id
condition|)
block|{
case|case
name|IWN_SDID_2x00_1
case|:
case|case
name|IWN_SDID_2x00_2
case|:
case|case
name|IWN_SDID_2x00_3
case|:
comment|//iwl2000_2bgn_cfg
case|case
name|IWN_SDID_2x00_4
case|:
comment|//iwl2000_2bgn_d_cfg
name|sc
operator|->
name|limits
operator|=
operator|&
name|iwn2030_sensitivity_limits
expr_stmt|;
name|sc
operator|->
name|base_params
operator|=
operator|&
name|iwn2000_base_params
expr_stmt|;
name|sc
operator|->
name|fwname
operator|=
literal|"iwn2000fw"
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"adapter type id : 0x%04x sub id :"
literal|"0x%04x rev %d not supported (subdevice) \n"
argument_list|,
name|pid
argument_list|,
name|sc
operator|->
name|subdevice_id
argument_list|,
name|sc
operator|->
name|hw_type
argument_list|)
expr_stmt|;
return|return
name|ENOTSUP
return|;
block|}
break|break;
comment|/* 2x30 Series */
case|case
name|IWN_DID_2x30_1
case|:
case|case
name|IWN_DID_2x30_2
case|:
switch|switch
condition|(
name|sc
operator|->
name|subdevice_id
condition|)
block|{
case|case
name|IWN_SDID_2x30_1
case|:
case|case
name|IWN_SDID_2x30_3
case|:
case|case
name|IWN_SDID_2x30_5
case|:
comment|//iwl100_bgn_cfg
case|case
name|IWN_SDID_2x30_2
case|:
case|case
name|IWN_SDID_2x30_4
case|:
case|case
name|IWN_SDID_2x30_6
case|:
comment|//iwl100_bg_cfg
name|sc
operator|->
name|limits
operator|=
operator|&
name|iwn2030_sensitivity_limits
expr_stmt|;
name|sc
operator|->
name|base_params
operator|=
operator|&
name|iwn2030_base_params
expr_stmt|;
name|sc
operator|->
name|fwname
operator|=
literal|"iwn2030fw"
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"adapter type id : 0x%04x sub id :"
literal|"0x%04x rev %d not supported (subdevice)\n"
argument_list|,
name|pid
argument_list|,
name|sc
operator|->
name|subdevice_id
argument_list|,
name|sc
operator|->
name|hw_type
argument_list|)
expr_stmt|;
return|return
name|ENOTSUP
return|;
block|}
break|break;
comment|/* 5x00 Series */
case|case
name|IWN_DID_5x00_1
case|:
case|case
name|IWN_DID_5x00_2
case|:
case|case
name|IWN_DID_5x00_3
case|:
case|case
name|IWN_DID_5x00_4
case|:
name|sc
operator|->
name|limits
operator|=
operator|&
name|iwn5000_sensitivity_limits
expr_stmt|;
name|sc
operator|->
name|base_params
operator|=
operator|&
name|iwn5000_base_params
expr_stmt|;
name|sc
operator|->
name|fwname
operator|=
literal|"iwn5000fw"
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|subdevice_id
condition|)
block|{
case|case
name|IWN_SDID_5x00_1
case|:
case|case
name|IWN_SDID_5x00_2
case|:
case|case
name|IWN_SDID_5x00_3
case|:
case|case
name|IWN_SDID_5x00_4
case|:
case|case
name|IWN_SDID_5x00_9
case|:
case|case
name|IWN_SDID_5x00_10
case|:
case|case
name|IWN_SDID_5x00_11
case|:
case|case
name|IWN_SDID_5x00_12
case|:
case|case
name|IWN_SDID_5x00_17
case|:
case|case
name|IWN_SDID_5x00_18
case|:
case|case
name|IWN_SDID_5x00_19
case|:
case|case
name|IWN_SDID_5x00_20
case|:
comment|//iwl5100_agn_cfg
name|sc
operator|->
name|txchainmask
operator|=
name|IWN_ANT_B
expr_stmt|;
name|sc
operator|->
name|rxchainmask
operator|=
name|IWN_ANT_AB
expr_stmt|;
break|break;
case|case
name|IWN_SDID_5x00_5
case|:
case|case
name|IWN_SDID_5x00_6
case|:
case|case
name|IWN_SDID_5x00_13
case|:
case|case
name|IWN_SDID_5x00_14
case|:
case|case
name|IWN_SDID_5x00_21
case|:
case|case
name|IWN_SDID_5x00_22
case|:
comment|//iwl5100_bgn_cfg
name|sc
operator|->
name|txchainmask
operator|=
name|IWN_ANT_B
expr_stmt|;
name|sc
operator|->
name|rxchainmask
operator|=
name|IWN_ANT_AB
expr_stmt|;
break|break;
case|case
name|IWN_SDID_5x00_7
case|:
case|case
name|IWN_SDID_5x00_8
case|:
case|case
name|IWN_SDID_5x00_15
case|:
case|case
name|IWN_SDID_5x00_16
case|:
case|case
name|IWN_SDID_5x00_23
case|:
case|case
name|IWN_SDID_5x00_24
case|:
comment|//iwl5100_abg_cfg
name|sc
operator|->
name|txchainmask
operator|=
name|IWN_ANT_B
expr_stmt|;
name|sc
operator|->
name|rxchainmask
operator|=
name|IWN_ANT_AB
expr_stmt|;
break|break;
case|case
name|IWN_SDID_5x00_25
case|:
case|case
name|IWN_SDID_5x00_26
case|:
case|case
name|IWN_SDID_5x00_27
case|:
case|case
name|IWN_SDID_5x00_28
case|:
case|case
name|IWN_SDID_5x00_29
case|:
case|case
name|IWN_SDID_5x00_30
case|:
case|case
name|IWN_SDID_5x00_31
case|:
case|case
name|IWN_SDID_5x00_32
case|:
case|case
name|IWN_SDID_5x00_33
case|:
case|case
name|IWN_SDID_5x00_34
case|:
case|case
name|IWN_SDID_5x00_35
case|:
case|case
name|IWN_SDID_5x00_36
case|:
comment|//iwl5300_agn_cfg
name|sc
operator|->
name|txchainmask
operator|=
name|IWN_ANT_ABC
expr_stmt|;
name|sc
operator|->
name|rxchainmask
operator|=
name|IWN_ANT_ABC
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"adapter type id : 0x%04x sub id :"
literal|"0x%04x rev %d not supported (subdevice)\n"
argument_list|,
name|pid
argument_list|,
name|sc
operator|->
name|subdevice_id
argument_list|,
name|sc
operator|->
name|hw_type
argument_list|)
expr_stmt|;
return|return
name|ENOTSUP
return|;
block|}
break|break;
comment|/* 5x50 Series */
case|case
name|IWN_DID_5x50_1
case|:
case|case
name|IWN_DID_5x50_2
case|:
case|case
name|IWN_DID_5x50_3
case|:
case|case
name|IWN_DID_5x50_4
case|:
name|sc
operator|->
name|limits
operator|=
operator|&
name|iwn5000_sensitivity_limits
expr_stmt|;
name|sc
operator|->
name|base_params
operator|=
operator|&
name|iwn5000_base_params
expr_stmt|;
name|sc
operator|->
name|fwname
operator|=
literal|"iwn5000fw"
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|subdevice_id
condition|)
block|{
case|case
name|IWN_SDID_5x50_1
case|:
case|case
name|IWN_SDID_5x50_2
case|:
case|case
name|IWN_SDID_5x50_3
case|:
comment|//iwl5350_agn_cfg
name|sc
operator|->
name|limits
operator|=
operator|&
name|iwn5000_sensitivity_limits
expr_stmt|;
name|sc
operator|->
name|base_params
operator|=
operator|&
name|iwn5000_base_params
expr_stmt|;
name|sc
operator|->
name|fwname
operator|=
literal|"iwn5000fw"
expr_stmt|;
break|break;
case|case
name|IWN_SDID_5x50_4
case|:
case|case
name|IWN_SDID_5x50_5
case|:
case|case
name|IWN_SDID_5x50_8
case|:
case|case
name|IWN_SDID_5x50_9
case|:
case|case
name|IWN_SDID_5x50_10
case|:
case|case
name|IWN_SDID_5x50_11
case|:
comment|//iwl5150_agn_cfg
case|case
name|IWN_SDID_5x50_6
case|:
case|case
name|IWN_SDID_5x50_7
case|:
case|case
name|IWN_SDID_5x50_12
case|:
case|case
name|IWN_SDID_5x50_13
case|:
comment|//iwl5150_abg_cfg
name|sc
operator|->
name|limits
operator|=
operator|&
name|iwn5000_sensitivity_limits
expr_stmt|;
name|sc
operator|->
name|fwname
operator|=
literal|"iwn5150fw"
expr_stmt|;
name|sc
operator|->
name|base_params
operator|=
operator|&
name|iwn_5x50_base_params
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"adapter type id : 0x%04x sub id :"
literal|"0x%04x rev %d not supported (subdevice)\n"
argument_list|,
name|pid
argument_list|,
name|sc
operator|->
name|subdevice_id
argument_list|,
name|sc
operator|->
name|hw_type
argument_list|)
expr_stmt|;
return|return
name|ENOTSUP
return|;
block|}
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"adapter type id : 0x%04x sub id : 0x%04x"
literal|"rev 0x%08x not supported (device)\n"
argument_list|,
name|pid
argument_list|,
name|sc
operator|->
name|subdevice_id
argument_list|,
name|sc
operator|->
name|hw_type
argument_list|)
expr_stmt|;
return|return
name|ENOTSUP
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn4965_attach
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|pid
parameter_list|)
block|{
name|struct
name|iwn_ops
modifier|*
name|ops
init|=
operator|&
name|sc
operator|->
name|ops
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s begin\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ops
operator|->
name|load_firmware
operator|=
name|iwn4965_load_firmware
expr_stmt|;
name|ops
operator|->
name|read_eeprom
operator|=
name|iwn4965_read_eeprom
expr_stmt|;
name|ops
operator|->
name|post_alive
operator|=
name|iwn4965_post_alive
expr_stmt|;
name|ops
operator|->
name|nic_config
operator|=
name|iwn4965_nic_config
expr_stmt|;
name|ops
operator|->
name|update_sched
operator|=
name|iwn4965_update_sched
expr_stmt|;
name|ops
operator|->
name|get_temperature
operator|=
name|iwn4965_get_temperature
expr_stmt|;
name|ops
operator|->
name|get_rssi
operator|=
name|iwn4965_get_rssi
expr_stmt|;
name|ops
operator|->
name|set_txpower
operator|=
name|iwn4965_set_txpower
expr_stmt|;
name|ops
operator|->
name|init_gains
operator|=
name|iwn4965_init_gains
expr_stmt|;
name|ops
operator|->
name|set_gains
operator|=
name|iwn4965_set_gains
expr_stmt|;
name|ops
operator|->
name|rxon_assoc
operator|=
name|iwn4965_rxon_assoc
expr_stmt|;
name|ops
operator|->
name|add_node
operator|=
name|iwn4965_add_node
expr_stmt|;
name|ops
operator|->
name|tx_done
operator|=
name|iwn4965_tx_done
expr_stmt|;
name|ops
operator|->
name|ampdu_tx_start
operator|=
name|iwn4965_ampdu_tx_start
expr_stmt|;
name|ops
operator|->
name|ampdu_tx_stop
operator|=
name|iwn4965_ampdu_tx_stop
expr_stmt|;
name|sc
operator|->
name|ntxqs
operator|=
name|IWN4965_NTXQUEUES
expr_stmt|;
name|sc
operator|->
name|firstaggqueue
operator|=
name|IWN4965_FIRSTAGGQUEUE
expr_stmt|;
name|sc
operator|->
name|ndmachnls
operator|=
name|IWN4965_NDMACHNLS
expr_stmt|;
name|sc
operator|->
name|broadcast_id
operator|=
name|IWN4965_ID_BROADCAST
expr_stmt|;
name|sc
operator|->
name|rxonsz
operator|=
name|IWN4965_RXONSZ
expr_stmt|;
name|sc
operator|->
name|schedsz
operator|=
name|IWN4965_SCHEDSZ
expr_stmt|;
name|sc
operator|->
name|fw_text_maxsz
operator|=
name|IWN4965_FW_TEXT_MAXSZ
expr_stmt|;
name|sc
operator|->
name|fw_data_maxsz
operator|=
name|IWN4965_FW_DATA_MAXSZ
expr_stmt|;
name|sc
operator|->
name|fwsz
operator|=
name|IWN4965_FWSZ
expr_stmt|;
name|sc
operator|->
name|sched_txfact_addr
operator|=
name|IWN4965_SCHED_TXFACT
expr_stmt|;
name|sc
operator|->
name|limits
operator|=
operator|&
name|iwn4965_sensitivity_limits
expr_stmt|;
name|sc
operator|->
name|fwname
operator|=
literal|"iwn4965fw"
expr_stmt|;
comment|/* Override chains masks, ROM is known to be broken. */
name|sc
operator|->
name|txchainmask
operator|=
name|IWN_ANT_AB
expr_stmt|;
name|sc
operator|->
name|rxchainmask
operator|=
name|IWN_ANT_ABC
expr_stmt|;
comment|/* Enable normal btcoex */
name|sc
operator|->
name|sc_flags
operator||=
name|IWN_FLAG_BTCOEX
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"%s: end\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn5000_attach
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|pid
parameter_list|)
block|{
name|struct
name|iwn_ops
modifier|*
name|ops
init|=
operator|&
name|sc
operator|->
name|ops
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s begin\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ops
operator|->
name|load_firmware
operator|=
name|iwn5000_load_firmware
expr_stmt|;
name|ops
operator|->
name|read_eeprom
operator|=
name|iwn5000_read_eeprom
expr_stmt|;
name|ops
operator|->
name|post_alive
operator|=
name|iwn5000_post_alive
expr_stmt|;
name|ops
operator|->
name|nic_config
operator|=
name|iwn5000_nic_config
expr_stmt|;
name|ops
operator|->
name|update_sched
operator|=
name|iwn5000_update_sched
expr_stmt|;
name|ops
operator|->
name|get_temperature
operator|=
name|iwn5000_get_temperature
expr_stmt|;
name|ops
operator|->
name|get_rssi
operator|=
name|iwn5000_get_rssi
expr_stmt|;
name|ops
operator|->
name|set_txpower
operator|=
name|iwn5000_set_txpower
expr_stmt|;
name|ops
operator|->
name|init_gains
operator|=
name|iwn5000_init_gains
expr_stmt|;
name|ops
operator|->
name|set_gains
operator|=
name|iwn5000_set_gains
expr_stmt|;
name|ops
operator|->
name|rxon_assoc
operator|=
name|iwn5000_rxon_assoc
expr_stmt|;
name|ops
operator|->
name|add_node
operator|=
name|iwn5000_add_node
expr_stmt|;
name|ops
operator|->
name|tx_done
operator|=
name|iwn5000_tx_done
expr_stmt|;
name|ops
operator|->
name|ampdu_tx_start
operator|=
name|iwn5000_ampdu_tx_start
expr_stmt|;
name|ops
operator|->
name|ampdu_tx_stop
operator|=
name|iwn5000_ampdu_tx_stop
expr_stmt|;
name|sc
operator|->
name|ntxqs
operator|=
name|IWN5000_NTXQUEUES
expr_stmt|;
name|sc
operator|->
name|firstaggqueue
operator|=
name|IWN5000_FIRSTAGGQUEUE
expr_stmt|;
name|sc
operator|->
name|ndmachnls
operator|=
name|IWN5000_NDMACHNLS
expr_stmt|;
name|sc
operator|->
name|broadcast_id
operator|=
name|IWN5000_ID_BROADCAST
expr_stmt|;
name|sc
operator|->
name|rxonsz
operator|=
name|IWN5000_RXONSZ
expr_stmt|;
name|sc
operator|->
name|schedsz
operator|=
name|IWN5000_SCHEDSZ
expr_stmt|;
name|sc
operator|->
name|fw_text_maxsz
operator|=
name|IWN5000_FW_TEXT_MAXSZ
expr_stmt|;
name|sc
operator|->
name|fw_data_maxsz
operator|=
name|IWN5000_FW_DATA_MAXSZ
expr_stmt|;
name|sc
operator|->
name|fwsz
operator|=
name|IWN5000_FWSZ
expr_stmt|;
name|sc
operator|->
name|sched_txfact_addr
operator|=
name|IWN5000_SCHED_TXFACT
expr_stmt|;
name|sc
operator|->
name|reset_noise_gain
operator|=
name|IWN5000_PHY_CALIB_RESET_NOISE_GAIN
expr_stmt|;
name|sc
operator|->
name|noise_gain
operator|=
name|IWN5000_PHY_CALIB_NOISE_GAIN
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Attach the interface to 802.11 radiotap.  */
end_comment

begin_function
specifier|static
name|void
name|iwn_radiotap_attach
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s begin\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ieee80211_radiotap_attach
argument_list|(
operator|&
name|sc
operator|->
name|sc_ic
argument_list|,
operator|&
name|sc
operator|->
name|sc_txtap
operator|.
name|wt_ihdr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_txtap
argument_list|)
argument_list|,
name|IWN_TX_RADIOTAP_PRESENT
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxtap
operator|.
name|wr_ihdr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_rxtap
argument_list|)
argument_list|,
name|IWN_RX_RADIOTAP_PRESENT
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s end\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_sysctlattach
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|IWN_DEBUG
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
init|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|tree
init|=
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
decl_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"debug"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|sc_debug
argument_list|,
name|sc
operator|->
name|sc_debug
argument_list|,
literal|"control debugging printfs"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|struct
name|ieee80211vap
modifier|*
name|iwn_vap_create
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|char
name|name
index|[
name|IFNAMSIZ
index|]
parameter_list|,
name|int
name|unit
parameter_list|,
name|enum
name|ieee80211_opmode
name|opmode
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|uint8_t
name|bssid
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|struct
name|iwn_vap
modifier|*
name|ivp
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
condition|)
comment|/* only one at a time */
return|return
name|NULL
return|;
name|ivp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_vap
argument_list|)
argument_list|,
name|M_80211_VAP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|vap
operator|=
operator|&
name|ivp
operator|->
name|iv_vap
expr_stmt|;
name|ieee80211_vap_setup
argument_list|(
name|ic
argument_list|,
name|vap
argument_list|,
name|name
argument_list|,
name|unit
argument_list|,
name|opmode
argument_list|,
name|flags
argument_list|,
name|bssid
argument_list|)
expr_stmt|;
name|ivp
operator|->
name|ctx
operator|=
name|IWN_RXON_BSS_CTX
expr_stmt|;
name|vap
operator|->
name|iv_bmissthreshold
operator|=
literal|10
expr_stmt|;
comment|/* override default */
comment|/* Override with driver methods. */
name|ivp
operator|->
name|iv_newstate
operator|=
name|vap
operator|->
name|iv_newstate
expr_stmt|;
name|vap
operator|->
name|iv_newstate
operator|=
name|iwn_newstate
expr_stmt|;
name|sc
operator|->
name|ivap
index|[
name|IWN_RXON_BSS_CTX
index|]
operator|=
name|vap
expr_stmt|;
name|ieee80211_ratectl_init
argument_list|(
name|vap
argument_list|)
expr_stmt|;
comment|/* Complete setup. */
name|ieee80211_vap_attach
argument_list|(
name|vap
argument_list|,
name|iwn_media_change
argument_list|,
name|ieee80211_media_status
argument_list|,
name|mac
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_opmode
operator|=
name|opmode
expr_stmt|;
return|return
name|vap
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_vap_delete
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|iwn_vap
modifier|*
name|ivp
init|=
name|IWN_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|ieee80211_ratectl_deinit
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|ieee80211_vap_detach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ivp
argument_list|,
name|M_80211_VAP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_xmit_queue_drain
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|IWN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|mbufq_dequeue
argument_list|(
operator|&
name|sc
operator|->
name|sc_xmit_queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ni
operator|=
operator|(
expr|struct
name|ieee80211_node
operator|*
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_xmit_queue_enqueue
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|IWN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|mbufq_enqueue
argument_list|(
operator|&
name|sc
operator|->
name|sc_xmit_queue
argument_list|,
name|m
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|qid
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s begin\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ic
operator|.
name|ic_softc
operator|!=
name|NULL
condition|)
block|{
comment|/* Free the mbuf queue and node references */
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwn_xmit_queue_drain
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwn_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|taskqueue_drain_all
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|watchdog_to
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|scan_timeout
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|calib_to
argument_list|)
expr_stmt|;
name|ieee80211_ifdetach
argument_list|(
operator|&
name|sc
operator|->
name|sc_ic
argument_list|)
expr_stmt|;
block|}
comment|/* Uninstall interrupt handler. */
if|if
condition|(
name|sc
operator|->
name|irq
operator|!=
name|NULL
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|sc
operator|->
name|sc_ih
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rman_get_rid
argument_list|(
name|sc
operator|->
name|irq
argument_list|)
argument_list|,
name|sc
operator|->
name|irq
argument_list|)
expr_stmt|;
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
comment|/* Free DMA resources. */
name|iwn_free_rx_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rxq
argument_list|)
expr_stmt|;
for|for
control|(
name|qid
operator|=
literal|0
init|;
name|qid
operator|<
name|sc
operator|->
name|ntxqs
condition|;
name|qid
operator|++
control|)
name|iwn_free_tx_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|txq
index|[
name|qid
index|]
argument_list|)
expr_stmt|;
name|iwn_free_sched
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwn_free_kw
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ict
operator|!=
name|NULL
condition|)
name|iwn_free_ict
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwn_free_fwmem
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rman_get_rid
argument_list|(
name|sc
operator|->
name|mem
argument_list|)
argument_list|,
name|sc
operator|->
name|mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_cdev
condition|)
block|{
name|destroy_dev
argument_list|(
name|sc
operator|->
name|sc_cdev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_cdev
operator|=
name|NULL
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s: end\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|IWN_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|iwn_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|ieee80211_suspend_all
argument_list|(
operator|&
name|sc
operator|->
name|sc_ic
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* Clear device-specific "PCI retry timeout" register (41h). */
name|pci_write_config
argument_list|(
name|dev
argument_list|,
literal|0x41
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ieee80211_resume_all
argument_list|(
operator|&
name|sc
operator|->
name|sc_ic
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_nic_lock
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|ntries
decl_stmt|;
comment|/* Request exclusive access to NIC. */
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_GP_CNTRL
argument_list|,
name|IWN_GP_CNTRL_MAC_ACCESS_REQ
argument_list|)
expr_stmt|;
comment|/* Spin until we actually get the lock. */
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|1000
condition|;
name|ntries
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_GP_CNTRL
argument_list|)
operator|&
operator|(
name|IWN_GP_CNTRL_MAC_ACCESS_ENA
operator||
name|IWN_GP_CNTRL_SLEEP
operator|)
operator|)
operator|==
name|IWN_GP_CNTRL_MAC_ACCESS_ENA
condition|)
return|return
literal|0
return|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
return|return
name|ETIMEDOUT
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|iwn_nic_unlock
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|IWN_CLRBITS
argument_list|(
name|sc
argument_list|,
name|IWN_GP_CNTRL
argument_list|,
name|IWN_GP_CNTRL_MAC_ACCESS_REQ
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint32_t
name|iwn_prph_read
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|)
block|{
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_PRPH_RADDR
argument_list|,
name|IWN_PRPH_DWORD
operator||
name|addr
argument_list|)
expr_stmt|;
name|IWN_BARRIER_READ_WRITE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_PRPH_RDATA
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|iwn_prph_write
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|data
parameter_list|)
block|{
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_PRPH_WADDR
argument_list|,
name|IWN_PRPH_DWORD
operator||
name|addr
argument_list|)
expr_stmt|;
name|IWN_BARRIER_WRITE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_PRPH_WDATA
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|iwn_prph_setbits
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|mask
parameter_list|)
block|{
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|iwn_prph_read
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
operator||
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|iwn_prph_clrbits
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|mask
parameter_list|)
block|{
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|iwn_prph_read
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
operator|&
operator|~
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|iwn_prph_write_region_4
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
specifier|const
name|uint32_t
modifier|*
name|data
parameter_list|,
name|int
name|count
parameter_list|)
block|{
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|data
operator|++
operator|,
name|addr
operator|+=
literal|4
control|)
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
operator|*
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint32_t
name|iwn_mem_read
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|)
block|{
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_MEM_RADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|IWN_BARRIER_READ_WRITE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_MEM_RDATA
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|iwn_mem_write
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|data
parameter_list|)
block|{
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_MEM_WADDR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|IWN_BARRIER_WRITE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_MEM_WDATA
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|iwn_mem_write_2
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint16_t
name|data
parameter_list|)
block|{
name|uint32_t
name|tmp
decl_stmt|;
name|tmp
operator|=
name|iwn_mem_read
argument_list|(
name|sc
argument_list|,
name|addr
operator|&
operator|~
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|&
literal|3
condition|)
name|tmp
operator|=
operator|(
name|tmp
operator|&
literal|0x0000ffff
operator|)
operator||
name|data
operator|<<
literal|16
expr_stmt|;
else|else
name|tmp
operator|=
operator|(
name|tmp
operator|&
literal|0xffff0000
operator|)
operator||
name|data
expr_stmt|;
name|iwn_mem_write
argument_list|(
name|sc
argument_list|,
name|addr
operator|&
operator|~
literal|3
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|iwn_mem_read_region_4
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
modifier|*
name|data
parameter_list|,
name|int
name|count
parameter_list|)
block|{
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|addr
operator|+=
literal|4
control|)
operator|*
name|data
operator|++
operator|=
name|iwn_mem_read
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|iwn_mem_set_region_4
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|val
parameter_list|,
name|int
name|count
parameter_list|)
block|{
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
operator|,
name|addr
operator|+=
literal|4
control|)
name|iwn_mem_write
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_eeprom_lock
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ntries
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
comment|/* Request exclusive access to EEPROM. */
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_HW_IF_CONFIG
argument_list|,
name|IWN_HW_IF_CONFIG_EEPROM_LOCKED
argument_list|)
expr_stmt|;
comment|/* Spin until we actually get the lock. */
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|100
condition|;
name|ntries
operator|++
control|)
block|{
if|if
condition|(
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_HW_IF_CONFIG
argument_list|)
operator|&
name|IWN_HW_IF_CONFIG_EEPROM_LOCKED
condition|)
return|return
literal|0
return|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s end timeout\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|ETIMEDOUT
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|iwn_eeprom_unlock
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|IWN_CLRBITS
argument_list|(
name|sc
argument_list|,
name|IWN_HW_IF_CONFIG
argument_list|,
name|IWN_HW_IF_CONFIG_EEPROM_LOCKED
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize access by host to One Time Programmable ROM.  * NB: This kind of ROM can be found on 1000 or 6000 Series only.  */
end_comment

begin_function
specifier|static
name|int
name|iwn_init_otprom
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint16_t
name|prev
decl_stmt|,
name|base
decl_stmt|,
name|next
decl_stmt|;
name|int
name|count
decl_stmt|,
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s begin\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Wait for clock stabilization before accessing prph. */
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_clock_wait
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_nic_lock
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|iwn_prph_setbits
argument_list|(
name|sc
argument_list|,
name|IWN_APMG_PS
argument_list|,
name|IWN_APMG_PS_RESET_REQ
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|iwn_prph_clrbits
argument_list|(
name|sc
argument_list|,
name|IWN_APMG_PS
argument_list|,
name|IWN_APMG_PS_RESET_REQ
argument_list|)
expr_stmt|;
name|iwn_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Set auto clock gate disable bit for HW with OTP shadow RAM. */
if|if
condition|(
name|sc
operator|->
name|base_params
operator|->
name|shadow_ram_support
condition|)
block|{
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_DBG_LINK_PWR_MGMT
argument_list|,
name|IWN_RESET_LINK_PWR_MGMT_DIS
argument_list|)
expr_stmt|;
block|}
name|IWN_CLRBITS
argument_list|(
name|sc
argument_list|,
name|IWN_EEPROM_GP
argument_list|,
name|IWN_EEPROM_GP_IF_OWNER
argument_list|)
expr_stmt|;
comment|/* Clear ECC status. */
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_OTP_GP
argument_list|,
name|IWN_OTP_GP_ECC_CORR_STTS
operator||
name|IWN_OTP_GP_ECC_UNCORR_STTS
argument_list|)
expr_stmt|;
comment|/* 	 * Find the block before last block (contains the EEPROM image) 	 * for HW without OTP shadow RAM. 	 */
if|if
condition|(
operator|!
name|sc
operator|->
name|base_params
operator|->
name|shadow_ram_support
condition|)
block|{
comment|/* Switch to absolute addressing mode. */
name|IWN_CLRBITS
argument_list|(
name|sc
argument_list|,
name|IWN_OTP_GP
argument_list|,
name|IWN_OTP_GP_RELATIVE_ACCESS
argument_list|)
expr_stmt|;
name|base
operator|=
name|prev
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|sc
operator|->
name|base_params
operator|->
name|max_ll_items
condition|;
name|count
operator|++
control|)
block|{
name|error
operator|=
name|iwn_read_prom_data
argument_list|(
name|sc
argument_list|,
name|base
argument_list|,
operator|&
name|next
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
name|next
operator|==
literal|0
condition|)
comment|/* End of linked-list. */
break|break;
name|prev
operator|=
name|base
expr_stmt|;
name|base
operator|=
name|le16toh
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
operator|||
name|count
operator|==
name|sc
operator|->
name|base_params
operator|->
name|max_ll_items
condition|)
return|return
name|EIO
return|;
comment|/* Skip "next" word. */
name|sc
operator|->
name|prom_base
operator|=
name|prev
operator|+
literal|1
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s end\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_read_prom_data
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|uint8_t
modifier|*
name|out
init|=
name|data
decl_stmt|;
name|uint32_t
name|val
decl_stmt|,
name|tmp
decl_stmt|;
name|int
name|ntries
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s begin\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|sc
operator|->
name|prom_base
expr_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|-=
literal|2
operator|,
name|addr
operator|++
control|)
block|{
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_EEPROM
argument_list|,
name|addr
operator|<<
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|10
condition|;
name|ntries
operator|++
control|)
block|{
name|val
operator|=
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_EEPROM
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|IWN_EEPROM_READ_VALID
condition|)
break|break;
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ntries
operator|==
literal|10
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"timeout reading ROM at 0x%x\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|ETIMEDOUT
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWN_FLAG_HAS_OTPROM
condition|)
block|{
comment|/* OTPROM, check for ECC errors. */
name|tmp
operator|=
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_OTP_GP
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&
name|IWN_OTP_GP_ECC_UNCORR_STTS
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"OTPROM ECC error at 0x%x\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
if|if
condition|(
name|tmp
operator|&
name|IWN_OTP_GP_ECC_CORR_STTS
condition|)
block|{
comment|/* Correctable ECC error, clear bit. */
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_OTP_GP
argument_list|,
name|IWN_OTP_GP_ECC_CORR_STTS
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|out
operator|++
operator|=
name|val
operator|>>
literal|16
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
operator|*
name|out
operator|++
operator|=
name|val
operator|>>
literal|24
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s end\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_dma_map_addr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return;
name|KASSERT
argument_list|(
name|nsegs
operator|==
literal|1
argument_list|,
operator|(
literal|"too many DMA segments, %d should be 1"
operator|,
name|nsegs
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_dma_contig_alloc
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_dma_info
modifier|*
name|dma
parameter_list|,
name|void
modifier|*
modifier|*
name|kvap
parameter_list|,
name|bus_size_t
name|size
parameter_list|,
name|bus_size_t
name|alignment
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|dma
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
name|dma
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|alignment
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|size
argument_list|,
literal|1
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|dma
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|dma
operator|->
name|vaddr
argument_list|,
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_ZERO
operator||
name|BUS_DMA_COHERENT
argument_list|,
operator|&
name|dma
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|,
name|dma
operator|->
name|vaddr
argument_list|,
name|size
argument_list|,
name|iwn_dma_map_addr
argument_list|,
operator|&
name|dma
operator|->
name|paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|bus_dmamap_sync
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|kvap
operator|!=
name|NULL
condition|)
operator|*
name|kvap
operator|=
name|dma
operator|->
name|vaddr
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
name|iwn_dma_contig_free
argument_list|(
name|dma
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_dma_contig_free
parameter_list|(
name|struct
name|iwn_dma_info
modifier|*
name|dma
parameter_list|)
block|{
if|if
condition|(
name|dma
operator|->
name|vaddr
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|vaddr
argument_list|,
name|dma
operator|->
name|map
argument_list|)
expr_stmt|;
name|dma
operator|->
name|vaddr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|dma
operator|->
name|tag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|dma
operator|->
name|tag
argument_list|)
expr_stmt|;
name|dma
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_alloc_sched
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* TX scheduler rings must be aligned on a 1KB boundary. */
return|return
name|iwn_dma_contig_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sched_dma
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|sched
argument_list|,
name|sc
operator|->
name|schedsz
argument_list|,
literal|1024
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_free_sched
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|iwn_dma_contig_free
argument_list|(
operator|&
name|sc
operator|->
name|sched_dma
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_alloc_kw
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* "Keep Warm" page must be aligned on a 4KB boundary. */
return|return
name|iwn_dma_contig_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|kw_dma
argument_list|,
name|NULL
argument_list|,
literal|4096
argument_list|,
literal|4096
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_free_kw
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|iwn_dma_contig_free
argument_list|(
operator|&
name|sc
operator|->
name|kw_dma
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_alloc_ict
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* ICT table must be aligned on a 4KB boundary. */
return|return
name|iwn_dma_contig_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|ict_dma
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|ict
argument_list|,
name|IWN_ICT_SIZE
argument_list|,
literal|4096
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_free_ict
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|iwn_dma_contig_free
argument_list|(
operator|&
name|sc
operator|->
name|ict_dma
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_alloc_fwmem
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Must be aligned on a 16-byte boundary. */
return|return
name|iwn_dma_contig_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|fw_dma
argument_list|,
name|NULL
argument_list|,
name|sc
operator|->
name|fwsz
argument_list|,
literal|16
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_free_fwmem
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|iwn_dma_contig_free
argument_list|(
operator|&
name|sc
operator|->
name|fw_dma
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_alloc_rx_ring
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_rx_ring
modifier|*
name|ring
parameter_list|)
block|{
name|bus_size_t
name|size
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|ring
operator|->
name|cur
operator|=
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s begin\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Allocate RX descriptors (256-byte aligned). */
name|size
operator|=
name|IWN_RX_RING_COUNT
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_dma_contig_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|ring
operator|->
name|desc_dma
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ring
operator|->
name|desc
argument_list|,
name|size
argument_list|,
literal|256
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not allocate RX ring DMA memory, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Allocate RX status area (16-byte aligned). */
name|error
operator|=
name|iwn_dma_contig_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|ring
operator|->
name|stat_dma
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ring
operator|->
name|stat
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_rx_status
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not allocate RX status DMA memory, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Create RX buffer DMA tag. */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|IWN_RBUF_SIZE
argument_list|,
literal|1
argument_list|,
name|IWN_RBUF_SIZE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|ring
operator|->
name|data_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not create RX buf DMA tag, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * Allocate and map RX buffers. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWN_RX_RING_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|iwn_rx_data
modifier|*
name|data
init|=
operator|&
name|ring
operator|->
name|data
index|[
name|i
index|]
decl_stmt|;
name|bus_addr_t
name|paddr
decl_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not create RX buf DMA map, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|data
operator|->
name|m
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|IWN_RBUF_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|m
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not allocate RX mbuf\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|mtod
argument_list|(
name|data
operator|->
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|IWN_RBUF_SIZE
argument_list|,
name|iwn_dma_map_addr
argument_list|,
operator|&
name|paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|EFBIG
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: can't map mbuf, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
comment|/* Set physical address of RX buffer (256-byte aligned). */
name|ring
operator|->
name|desc
index|[
name|i
index|]
operator|=
name|htole32
argument_list|(
name|paddr
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|desc_dma
operator|.
name|tag
argument_list|,
name|ring
operator|->
name|desc_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s: end\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
name|iwn_free_rx_ring
argument_list|(
name|sc
argument_list|,
name|ring
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s: end in error\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_reset_rx_ring
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_rx_ring
modifier|*
name|ring
parameter_list|)
block|{
name|int
name|ntries
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->Doing %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|iwn_nic_lock
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
condition|)
block|{
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_RX_CONFIG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|1000
condition|;
name|ntries
operator|++
control|)
block|{
if|if
condition|(
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_FH_RX_STATUS
argument_list|)
operator|&
name|IWN_FH_RX_STATUS_IDLE
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|iwn_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|ring
operator|->
name|cur
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|last_rx_valid
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_free_rx_ring
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_rx_ring
modifier|*
name|ring
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->Doing %s \n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|iwn_dma_contig_free
argument_list|(
operator|&
name|ring
operator|->
name|desc_dma
argument_list|)
expr_stmt|;
name|iwn_dma_contig_free
argument_list|(
operator|&
name|ring
operator|->
name|stat_dma
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWN_RX_RING_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|iwn_rx_data
modifier|*
name|data
init|=
operator|&
name|ring
operator|->
name|data
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|data
operator|->
name|m
argument_list|)
expr_stmt|;
name|data
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|->
name|map
operator|!=
name|NULL
condition|)
name|bus_dmamap_destroy
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ring
operator|->
name|data_dmat
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|)
expr_stmt|;
name|ring
operator|->
name|data_dmat
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_alloc_tx_ring
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_tx_ring
modifier|*
name|ring
parameter_list|,
name|int
name|qid
parameter_list|)
block|{
name|bus_addr_t
name|paddr
decl_stmt|;
name|bus_size_t
name|size
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|ring
operator|->
name|qid
operator|=
name|qid
expr_stmt|;
name|ring
operator|->
name|queued
operator|=
literal|0
expr_stmt|;
name|ring
operator|->
name|cur
operator|=
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s begin\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Allocate TX descriptors (256-byte aligned). */
name|size
operator|=
name|IWN_TX_RING_COUNT
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_tx_desc
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_dma_contig_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|ring
operator|->
name|desc_dma
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ring
operator|->
name|desc
argument_list|,
name|size
argument_list|,
literal|256
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not allocate TX ring DMA memory, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|size
operator|=
name|IWN_TX_RING_COUNT
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_tx_cmd
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_dma_contig_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|ring
operator|->
name|cmd_dma
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ring
operator|->
name|cmd
argument_list|,
name|size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not allocate TX cmd DMA memory, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MCLBYTES
argument_list|,
name|IWN_MAX_SCATTER
operator|-
literal|1
argument_list|,
name|MCLBYTES
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|ring
operator|->
name|data_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not create TX buf DMA tag, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|paddr
operator|=
name|ring
operator|->
name|cmd_dma
operator|.
name|paddr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWN_TX_RING_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|iwn_tx_data
modifier|*
name|data
init|=
operator|&
name|ring
operator|->
name|data
index|[
name|i
index|]
decl_stmt|;
name|data
operator|->
name|cmd_paddr
operator|=
name|paddr
expr_stmt|;
name|data
operator|->
name|scratch_paddr
operator|=
name|paddr
operator|+
literal|12
expr_stmt|;
name|paddr
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_tx_cmd
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not create TX buf DMA map, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s end\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
name|iwn_free_tx_ring
argument_list|(
name|sc
argument_list|,
name|ring
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s end in error\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_reset_tx_ring
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_tx_ring
modifier|*
name|ring
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->doing %s \n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWN_TX_RING_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|iwn_tx_data
modifier|*
name|data
init|=
operator|&
name|ring
operator|->
name|data
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|data
operator|->
name|m
argument_list|)
expr_stmt|;
name|data
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|->
name|ni
operator|!=
name|NULL
condition|)
block|{
name|ieee80211_free_node
argument_list|(
name|data
operator|->
name|ni
argument_list|)
expr_stmt|;
name|data
operator|->
name|ni
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Clear TX descriptors. */
name|memset
argument_list|(
name|ring
operator|->
name|desc
argument_list|,
literal|0
argument_list|,
name|ring
operator|->
name|desc_dma
operator|.
name|size
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|desc_dma
operator|.
name|tag
argument_list|,
name|ring
operator|->
name|desc_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|qfullmsk
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|ring
operator|->
name|qid
operator|)
expr_stmt|;
name|ring
operator|->
name|queued
operator|=
literal|0
expr_stmt|;
name|ring
operator|->
name|cur
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_free_tx_ring
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_tx_ring
modifier|*
name|ring
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->Doing %s \n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|iwn_dma_contig_free
argument_list|(
operator|&
name|ring
operator|->
name|desc_dma
argument_list|)
expr_stmt|;
name|iwn_dma_contig_free
argument_list|(
operator|&
name|ring
operator|->
name|cmd_dma
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWN_TX_RING_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|iwn_tx_data
modifier|*
name|data
init|=
operator|&
name|ring
operator|->
name|data
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|data
operator|->
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|->
name|map
operator|!=
name|NULL
condition|)
name|bus_dmamap_destroy
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ring
operator|->
name|data_dmat
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|)
expr_stmt|;
name|ring
operator|->
name|data_dmat
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|iwn5000_ict_reset
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Disable interrupts. */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_INT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reset ICT table. */
name|memset
argument_list|(
name|sc
operator|->
name|ict
argument_list|,
literal|0
argument_list|,
name|IWN_ICT_SIZE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ict_cur
operator|=
literal|0
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|ict_dma
operator|.
name|tag
argument_list|,
name|sc
operator|->
name|ict_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Set physical address of ICT table (4KB aligned). */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"%s: enabling ICT\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_DRAM_INT_TBL
argument_list|,
name|IWN_DRAM_INT_TBL_ENABLE
operator||
name|IWN_DRAM_INT_TBL_WRAP_CHECK
operator||
name|sc
operator|->
name|ict_dma
operator|.
name|paddr
operator|>>
literal|12
argument_list|)
expr_stmt|;
comment|/* Enable periodic RX interrupt. */
name|sc
operator|->
name|int_mask
operator||=
name|IWN_INT_RX_PERIODIC
expr_stmt|;
comment|/* Switch to ICT interrupt mode in driver. */
name|sc
operator|->
name|sc_flags
operator||=
name|IWN_FLAG_USE_ICT
expr_stmt|;
comment|/* Re-enable interrupts. */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_INT
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_INT_MASK
argument_list|,
name|sc
operator|->
name|int_mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_read_eeprom
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|iwn_ops
modifier|*
name|ops
init|=
operator|&
name|sc
operator|->
name|ops
decl_stmt|;
name|uint16_t
name|val
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s begin\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Check whether adapter has an EEPROM or an OTPROM. */
if|if
condition|(
name|sc
operator|->
name|hw_type
operator|>=
name|IWN_HW_REV_TYPE_1000
operator|&&
operator|(
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_OTP_GP
argument_list|)
operator|&
name|IWN_OTP_GP_DEV_SEL_OTP
operator|)
condition|)
name|sc
operator|->
name|sc_flags
operator||=
name|IWN_FLAG_HAS_OTPROM
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"%s found\n"
argument_list|,
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWN_FLAG_HAS_OTPROM
operator|)
condition|?
literal|"OTPROM"
else|:
literal|"EEPROM"
argument_list|)
expr_stmt|;
comment|/* Adapter has to be powered on for EEPROM access to work. */
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_apm_init
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not power ON adapter, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
operator|(
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_EEPROM_GP
argument_list|)
operator|&
literal|0x7
operator|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: bad ROM signature\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_eeprom_lock
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not lock ROM, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWN_FLAG_HAS_OTPROM
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_init_otprom
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not initialize OTPROM, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
name|iwn_read_prom_data
argument_list|(
name|sc
argument_list|,
name|IWN_EEPROM_SKU_CAP
argument_list|,
operator|&
name|val
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"SKU capabilities=0x%04x\n"
argument_list|,
name|le16toh
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check if HT support is bonded out. */
if|if
condition|(
name|val
operator|&
name|htole16
argument_list|(
name|IWN_EEPROM_SKU_CAP_11N
argument_list|)
condition|)
name|sc
operator|->
name|sc_flags
operator||=
name|IWN_FLAG_HAS_11N
expr_stmt|;
name|iwn_read_prom_data
argument_list|(
name|sc
argument_list|,
name|IWN_EEPROM_RFCFG
argument_list|,
operator|&
name|val
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rfcfg
operator|=
name|le16toh
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"radio config=0x%04x\n"
argument_list|,
name|sc
operator|->
name|rfcfg
argument_list|)
expr_stmt|;
comment|/* Read Tx/Rx chains from ROM unless it's known to be broken. */
if|if
condition|(
name|sc
operator|->
name|txchainmask
operator|==
literal|0
condition|)
name|sc
operator|->
name|txchainmask
operator|=
name|IWN_RFCFG_TXANTMSK
argument_list|(
name|sc
operator|->
name|rfcfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rxchainmask
operator|==
literal|0
condition|)
name|sc
operator|->
name|rxchainmask
operator|=
name|IWN_RFCFG_RXANTMSK
argument_list|(
name|sc
operator|->
name|rfcfg
argument_list|)
expr_stmt|;
comment|/* Read MAC address. */
name|iwn_read_prom_data
argument_list|(
name|sc
argument_list|,
name|IWN_EEPROM_MAC
argument_list|,
name|macaddr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* Read adapter-specific information from EEPROM. */
name|ops
operator|->
name|read_eeprom
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwn_apm_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Power OFF adapter. */
name|iwn_eeprom_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s end\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn4965_read_eeprom
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|addr
decl_stmt|;
name|uint16_t
name|val
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s begin\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Read regulatory domain (4 ASCII characters). */
name|iwn_read_prom_data
argument_list|(
name|sc
argument_list|,
name|IWN4965_EEPROM_DOMAIN
argument_list|,
name|sc
operator|->
name|eeprom_domain
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Read the list of authorized channels (20MHz& 40MHz). */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWN_NBANDS
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|addr
operator|=
name|iwn4965_regulatory_bands
index|[
name|i
index|]
expr_stmt|;
name|iwn_read_eeprom_channels
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
comment|/* Read maximum allowed TX power for 2GHz and 5GHz bands. */
name|iwn_read_prom_data
argument_list|(
name|sc
argument_list|,
name|IWN4965_EEPROM_MAXPOW
argument_list|,
operator|&
name|val
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|maxpwr2GHz
operator|=
name|val
operator|&
literal|0xff
expr_stmt|;
name|sc
operator|->
name|maxpwr5GHz
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
comment|/* Check that EEPROM values are within valid range. */
if|if
condition|(
name|sc
operator|->
name|maxpwr5GHz
operator|<
literal|20
operator|||
name|sc
operator|->
name|maxpwr5GHz
operator|>
literal|50
condition|)
name|sc
operator|->
name|maxpwr5GHz
operator|=
literal|38
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|maxpwr2GHz
operator|<
literal|20
operator|||
name|sc
operator|->
name|maxpwr2GHz
operator|>
literal|50
condition|)
name|sc
operator|->
name|maxpwr2GHz
operator|=
literal|38
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"maxpwr 2GHz=%d 5GHz=%d\n"
argument_list|,
name|sc
operator|->
name|maxpwr2GHz
argument_list|,
name|sc
operator|->
name|maxpwr5GHz
argument_list|)
expr_stmt|;
comment|/* Read samples for each TX power group. */
name|iwn_read_prom_data
argument_list|(
name|sc
argument_list|,
name|IWN4965_EEPROM_BANDS
argument_list|,
name|sc
operator|->
name|bands
argument_list|,
sizeof|sizeof
name|sc
operator|->
name|bands
argument_list|)
expr_stmt|;
comment|/* Read voltage at which samples were taken. */
name|iwn_read_prom_data
argument_list|(
name|sc
argument_list|,
name|IWN4965_EEPROM_VOLTAGE
argument_list|,
operator|&
name|val
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|eeprom_voltage
operator|=
operator|(
name|int16_t
operator|)
name|le16toh
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"voltage=%d (in 0.3V)\n"
argument_list|,
name|sc
operator|->
name|eeprom_voltage
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IWN_DEBUG
comment|/* Print samples. */
if|if
condition|(
name|sc
operator|->
name|sc_debug
operator|&
name|IWN_DEBUG_ANY
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWN_NBANDS
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|iwn4965_print_power_group
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s end\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IWN_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|iwn4965_print_power_group
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|struct
name|iwn4965_eeprom_band
modifier|*
name|band
init|=
operator|&
name|sc
operator|->
name|bands
index|[
name|i
index|]
decl_stmt|;
name|struct
name|iwn4965_eeprom_chan_samples
modifier|*
name|chans
init|=
name|band
operator|->
name|chans
decl_stmt|;
name|int
name|j
decl_stmt|,
name|c
decl_stmt|;
name|printf
argument_list|(
literal|"===band %d===\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"chan lo=%d, chan hi=%d\n"
argument_list|,
name|band
operator|->
name|lo
argument_list|,
name|band
operator|->
name|hi
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"chan1 num=%d\n"
argument_list|,
name|chans
index|[
literal|0
index|]
operator|.
name|num
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|2
condition|;
name|c
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|IWN_NSAMPLES
condition|;
name|j
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"chain %d, sample %d: temp=%d gain=%d "
literal|"power=%d pa_det=%d\n"
argument_list|,
name|c
argument_list|,
name|j
argument_list|,
name|chans
index|[
literal|0
index|]
operator|.
name|samples
index|[
name|c
index|]
index|[
name|j
index|]
operator|.
name|temp
argument_list|,
name|chans
index|[
literal|0
index|]
operator|.
name|samples
index|[
name|c
index|]
index|[
name|j
index|]
operator|.
name|gain
argument_list|,
name|chans
index|[
literal|0
index|]
operator|.
name|samples
index|[
name|c
index|]
index|[
name|j
index|]
operator|.
name|power
argument_list|,
name|chans
index|[
literal|0
index|]
operator|.
name|samples
index|[
name|c
index|]
index|[
name|j
index|]
operator|.
name|pa_det
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"chan2 num=%d\n"
argument_list|,
name|chans
index|[
literal|1
index|]
operator|.
name|num
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|2
condition|;
name|c
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|IWN_NSAMPLES
condition|;
name|j
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"chain %d, sample %d: temp=%d gain=%d "
literal|"power=%d pa_det=%d\n"
argument_list|,
name|c
argument_list|,
name|j
argument_list|,
name|chans
index|[
literal|1
index|]
operator|.
name|samples
index|[
name|c
index|]
index|[
name|j
index|]
operator|.
name|temp
argument_list|,
name|chans
index|[
literal|1
index|]
operator|.
name|samples
index|[
name|c
index|]
index|[
name|j
index|]
operator|.
name|gain
argument_list|,
name|chans
index|[
literal|1
index|]
operator|.
name|samples
index|[
name|c
index|]
index|[
name|j
index|]
operator|.
name|power
argument_list|,
name|chans
index|[
literal|1
index|]
operator|.
name|samples
index|[
name|c
index|]
index|[
name|j
index|]
operator|.
name|pa_det
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|iwn5000_read_eeprom
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwn5000_eeprom_calib_hdr
name|hdr
decl_stmt|;
name|int32_t
name|volt
decl_stmt|;
name|uint32_t
name|base
decl_stmt|,
name|addr
decl_stmt|;
name|uint16_t
name|val
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s begin\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Read regulatory domain (4 ASCII characters). */
name|iwn_read_prom_data
argument_list|(
name|sc
argument_list|,
name|IWN5000_EEPROM_REG
argument_list|,
operator|&
name|val
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|base
operator|=
name|le16toh
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|iwn_read_prom_data
argument_list|(
name|sc
argument_list|,
name|base
operator|+
name|IWN5000_EEPROM_DOMAIN
argument_list|,
name|sc
operator|->
name|eeprom_domain
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Read the list of authorized channels (20MHz& 40MHz). */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWN_NBANDS
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|addr
operator|=
name|base
operator|+
name|sc
operator|->
name|base_params
operator|->
name|regulatory_bands
index|[
name|i
index|]
expr_stmt|;
name|iwn_read_eeprom_channels
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
comment|/* Read enhanced TX power information for 6000 Series. */
if|if
condition|(
name|sc
operator|->
name|base_params
operator|->
name|enhanced_TX_power
condition|)
name|iwn_read_eeprom_enhinfo
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwn_read_prom_data
argument_list|(
name|sc
argument_list|,
name|IWN5000_EEPROM_CAL
argument_list|,
operator|&
name|val
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|base
operator|=
name|le16toh
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|iwn_read_prom_data
argument_list|(
name|sc
argument_list|,
name|base
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
name|hdr
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s: calib version=%u pa type=%u voltage=%u\n"
argument_list|,
name|__func__
argument_list|,
name|hdr
operator|.
name|version
argument_list|,
name|hdr
operator|.
name|pa_type
argument_list|,
name|le16toh
argument_list|(
name|hdr
operator|.
name|volt
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|calib_ver
operator|=
name|hdr
operator|.
name|version
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|base_params
operator|->
name|calib_need
operator|&
name|IWN_FLG_NEED_PHY_CALIB_TEMP_OFFSETv2
condition|)
block|{
name|sc
operator|->
name|eeprom_voltage
operator|=
name|le16toh
argument_list|(
name|hdr
operator|.
name|volt
argument_list|)
expr_stmt|;
name|iwn_read_prom_data
argument_list|(
name|sc
argument_list|,
name|base
operator|+
name|IWN5000_EEPROM_TEMP
argument_list|,
operator|&
name|val
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|eeprom_temp_high
operator|=
name|le16toh
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|iwn_read_prom_data
argument_list|(
name|sc
argument_list|,
name|base
operator|+
name|IWN5000_EEPROM_VOLT
argument_list|,
operator|&
name|val
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|eeprom_temp
operator|=
name|le16toh
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|hw_type
operator|==
name|IWN_HW_REV_TYPE_5150
condition|)
block|{
comment|/* Compute temperature offset. */
name|iwn_read_prom_data
argument_list|(
name|sc
argument_list|,
name|base
operator|+
name|IWN5000_EEPROM_TEMP
argument_list|,
operator|&
name|val
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|eeprom_temp
operator|=
name|le16toh
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|iwn_read_prom_data
argument_list|(
name|sc
argument_list|,
name|base
operator|+
name|IWN5000_EEPROM_VOLT
argument_list|,
operator|&
name|val
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|volt
operator|=
name|le16toh
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|sc
operator|->
name|temp_off
operator|=
name|sc
operator|->
name|eeprom_temp
operator|-
operator|(
name|volt
operator|/
operator|-
literal|5
operator|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"temp=%d volt=%d offset=%dK\n"
argument_list|,
name|sc
operator|->
name|eeprom_temp
argument_list|,
name|volt
argument_list|,
name|sc
operator|->
name|temp_off
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Read crystal calibration. */
name|iwn_read_prom_data
argument_list|(
name|sc
argument_list|,
name|base
operator|+
name|IWN5000_EEPROM_CRYSTAL
argument_list|,
operator|&
name|sc
operator|->
name|eeprom_crystal
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"crystal calibration 0x%08x\n"
argument_list|,
name|le32toh
argument_list|(
name|sc
operator|->
name|eeprom_crystal
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s end\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Translate EEPROM flags to net80211.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|iwn_eeprom_channel_flags
parameter_list|(
name|struct
name|iwn_eeprom_chan
modifier|*
name|channel
parameter_list|)
block|{
name|uint32_t
name|nflags
decl_stmt|;
name|nflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|channel
operator|->
name|flags
operator|&
name|IWN_EEPROM_CHAN_ACTIVE
operator|)
operator|==
literal|0
condition|)
name|nflags
operator||=
name|IEEE80211_CHAN_PASSIVE
expr_stmt|;
if|if
condition|(
operator|(
name|channel
operator|->
name|flags
operator|&
name|IWN_EEPROM_CHAN_IBSS
operator|)
operator|==
literal|0
condition|)
name|nflags
operator||=
name|IEEE80211_CHAN_NOADHOC
expr_stmt|;
if|if
condition|(
name|channel
operator|->
name|flags
operator|&
name|IWN_EEPROM_CHAN_RADAR
condition|)
block|{
name|nflags
operator||=
name|IEEE80211_CHAN_DFS
expr_stmt|;
comment|/* XXX apparently IBSS may still be marked */
name|nflags
operator||=
name|IEEE80211_CHAN_NOADHOC
expr_stmt|;
block|}
return|return
name|nflags
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_read_eeprom_band
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|maxchans
parameter_list|,
name|int
modifier|*
name|nchans
parameter_list|,
name|struct
name|ieee80211_channel
name|chans
index|[]
parameter_list|)
block|{
name|struct
name|iwn_eeprom_chan
modifier|*
name|channels
init|=
name|sc
operator|->
name|eeprom_channels
index|[
name|n
index|]
decl_stmt|;
specifier|const
name|struct
name|iwn_chan_band
modifier|*
name|band
init|=
operator|&
name|iwn_bands
index|[
name|n
index|]
decl_stmt|;
name|uint8_t
name|bands
index|[
name|IEEE80211_MODE_BYTES
index|]
decl_stmt|;
name|uint8_t
name|chan
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|nflags
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s begin\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|bands
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|bands
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|setbit
argument_list|(
name|bands
argument_list|,
name|IEEE80211_MODE_11B
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|bands
argument_list|,
name|IEEE80211_MODE_11G
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWN_FLAG_HAS_11N
condition|)
name|setbit
argument_list|(
name|bands
argument_list|,
name|IEEE80211_MODE_11NG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setbit
argument_list|(
name|bands
argument_list|,
name|IEEE80211_MODE_11A
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWN_FLAG_HAS_11N
condition|)
name|setbit
argument_list|(
name|bands
argument_list|,
name|IEEE80211_MODE_11NA
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|band
operator|->
name|nchan
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|channels
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|IWN_EEPROM_CHAN_VALID
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"skip chan %d flags 0x%x maxpwr %d\n"
argument_list|,
name|band
operator|->
name|chan
index|[
name|i
index|]
argument_list|,
name|channels
index|[
name|i
index|]
operator|.
name|flags
argument_list|,
name|channels
index|[
name|i
index|]
operator|.
name|maxpwr
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|chan
operator|=
name|band
operator|->
name|chan
index|[
name|i
index|]
expr_stmt|;
name|nflags
operator|=
name|iwn_eeprom_channel_flags
argument_list|(
operator|&
name|channels
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|error
operator|=
name|ieee80211_add_channel
argument_list|(
name|chans
argument_list|,
name|maxchans
argument_list|,
name|nchans
argument_list|,
name|chan
argument_list|,
literal|0
argument_list|,
name|channels
index|[
name|i
index|]
operator|.
name|maxpwr
argument_list|,
name|nflags
argument_list|,
name|bands
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
comment|/* Save maximum allowed TX power for this channel. */
comment|/* XXX wrong */
name|sc
operator|->
name|maxpwr
index|[
name|chan
index|]
operator|=
name|channels
index|[
name|i
index|]
operator|.
name|maxpwr
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"add chan %d flags 0x%x maxpwr %d\n"
argument_list|,
name|chan
argument_list|,
name|channels
index|[
name|i
index|]
operator|.
name|flags
argument_list|,
name|channels
index|[
name|i
index|]
operator|.
name|maxpwr
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s end\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_read_eeprom_ht40
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|maxchans
parameter_list|,
name|int
modifier|*
name|nchans
parameter_list|,
name|struct
name|ieee80211_channel
name|chans
index|[]
parameter_list|)
block|{
name|struct
name|iwn_eeprom_chan
modifier|*
name|channels
init|=
name|sc
operator|->
name|eeprom_channels
index|[
name|n
index|]
decl_stmt|;
specifier|const
name|struct
name|iwn_chan_band
modifier|*
name|band
init|=
operator|&
name|iwn_bands
index|[
name|n
index|]
decl_stmt|;
name|uint8_t
name|chan
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|nflags
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s start\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWN_FLAG_HAS_11N
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s end no 11n\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|band
operator|->
name|nchan
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|channels
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|IWN_EEPROM_CHAN_VALID
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"skip chan %d flags 0x%x maxpwr %d\n"
argument_list|,
name|band
operator|->
name|chan
index|[
name|i
index|]
argument_list|,
name|channels
index|[
name|i
index|]
operator|.
name|flags
argument_list|,
name|channels
index|[
name|i
index|]
operator|.
name|maxpwr
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|chan
operator|=
name|band
operator|->
name|chan
index|[
name|i
index|]
expr_stmt|;
name|nflags
operator|=
name|iwn_eeprom_channel_flags
argument_list|(
operator|&
name|channels
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|nflags
operator||=
operator|(
name|n
operator|==
literal|5
condition|?
name|IEEE80211_CHAN_G
else|:
name|IEEE80211_CHAN_A
operator|)
expr_stmt|;
name|error
operator|=
name|ieee80211_add_channel_ht40
argument_list|(
name|chans
argument_list|,
name|maxchans
argument_list|,
name|nchans
argument_list|,
name|chan
argument_list|,
name|channels
index|[
name|i
index|]
operator|.
name|maxpwr
argument_list|,
name|nflags
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|EINVAL
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: no entry for channel %d\n"
argument_list|,
name|__func__
argument_list|,
name|chan
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|ENOENT
case|:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"%s: skip chan %d, extension channel not found\n"
argument_list|,
name|__func__
argument_list|,
name|chan
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|ENOBUFS
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: channel table is full!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"add ht40 chan %d flags 0x%x maxpwr %d\n"
argument_list|,
name|chan
argument_list|,
name|channels
index|[
name|i
index|]
operator|.
name|flags
argument_list|,
name|channels
index|[
name|i
index|]
operator|.
name|maxpwr
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
break|break;
block|}
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s end\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_read_eeprom_channels
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|n
parameter_list|,
name|uint32_t
name|addr
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|iwn_read_prom_data
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
operator|&
name|sc
operator|->
name|eeprom_channels
index|[
name|n
index|]
argument_list|,
name|iwn_bands
index|[
name|n
index|]
operator|.
name|nchan
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_eeprom_chan
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|5
condition|)
block|{
name|iwn_read_eeprom_band
argument_list|(
name|sc
argument_list|,
name|n
argument_list|,
name|IEEE80211_CHAN_MAX
argument_list|,
operator|&
name|ic
operator|->
name|ic_nchans
argument_list|,
name|ic
operator|->
name|ic_channels
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|iwn_read_eeprom_ht40
argument_list|(
name|sc
argument_list|,
name|n
argument_list|,
name|IEEE80211_CHAN_MAX
argument_list|,
operator|&
name|ic
operator|->
name|ic_nchans
argument_list|,
name|ic
operator|->
name|ic_channels
argument_list|)
expr_stmt|;
block|}
name|ieee80211_sort_channels
argument_list|(
name|ic
operator|->
name|ic_channels
argument_list|,
name|ic
operator|->
name|ic_nchans
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|iwn_eeprom_chan
modifier|*
name|iwn_find_eeprom_channel
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|)
block|{
name|int
name|band
decl_stmt|,
name|chan
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|band
operator|=
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|c
argument_list|)
condition|?
literal|6
else|:
literal|5
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40D
argument_list|(
name|c
argument_list|)
condition|)
name|chan
operator|=
name|c
operator|->
name|ic_extieee
expr_stmt|;
else|else
name|chan
operator|=
name|c
operator|->
name|ic_ieee
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iwn_bands
index|[
name|band
index|]
operator|.
name|nchan
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|iwn_bands
index|[
name|band
index|]
operator|.
name|chan
index|[
name|i
index|]
operator|==
name|chan
condition|)
return|return
operator|&
name|sc
operator|->
name|eeprom_channels
index|[
name|band
index|]
index|[
name|i
index|]
return|;
block|}
block|}
else|else
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|5
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iwn_bands
index|[
name|j
index|]
operator|.
name|nchan
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|iwn_bands
index|[
name|j
index|]
operator|.
name|chan
index|[
name|i
index|]
operator|==
name|c
operator|->
name|ic_ieee
operator|&&
operator|(
operator|(
name|j
operator|==
literal|0
operator|)
operator|^
name|IEEE80211_IS_CHAN_A
argument_list|(
name|c
argument_list|)
operator|)
operator|==
literal|1
condition|)
return|return
operator|&
name|sc
operator|->
name|eeprom_channels
index|[
name|j
index|]
index|[
name|i
index|]
return|;
block|}
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_getradiocaps
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|int
name|maxchans
parameter_list|,
name|int
modifier|*
name|nchans
parameter_list|,
name|struct
name|ieee80211_channel
name|chans
index|[]
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Parse the list of authorized channels. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
operator|&&
operator|*
name|nchans
operator|<
name|maxchans
condition|;
name|i
operator|++
control|)
name|iwn_read_eeprom_band
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|maxchans
argument_list|,
name|nchans
argument_list|,
name|chans
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|5
init|;
name|i
operator|<
name|IWN_NBANDS
operator|-
literal|1
operator|&&
operator|*
name|nchans
operator|<
name|maxchans
condition|;
name|i
operator|++
control|)
name|iwn_read_eeprom_ht40
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|maxchans
argument_list|,
name|nchans
argument_list|,
name|chans
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Enforce flags read from EEPROM.  */
end_comment

begin_function
specifier|static
name|int
name|iwn_setregdomain
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_regdomain
modifier|*
name|rd
parameter_list|,
name|int
name|nchan
parameter_list|,
name|struct
name|ieee80211_channel
name|chans
index|[]
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchan
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ieee80211_channel
modifier|*
name|c
init|=
operator|&
name|chans
index|[
name|i
index|]
decl_stmt|;
name|struct
name|iwn_eeprom_chan
modifier|*
name|channel
decl_stmt|;
name|channel
operator|=
name|iwn_find_eeprom_channel
argument_list|(
name|sc
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|==
name|NULL
condition|)
block|{
name|ic_printf
argument_list|(
name|ic
argument_list|,
literal|"%s: invalid channel %u freq %u/0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|c
operator|->
name|ic_ieee
argument_list|,
name|c
operator|->
name|ic_freq
argument_list|,
name|c
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|c
operator|->
name|ic_flags
operator||=
name|iwn_eeprom_channel_flags
argument_list|(
name|channel
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_read_eeprom_enhinfo
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwn_eeprom_enhinfo
name|enhinfo
index|[
literal|35
index|]
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|;
name|uint16_t
name|val
decl_stmt|,
name|base
decl_stmt|;
name|int8_t
name|maxpwr
decl_stmt|;
name|uint8_t
name|flags
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s begin\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|iwn_read_prom_data
argument_list|(
name|sc
argument_list|,
name|IWN5000_EEPROM_REG
argument_list|,
operator|&
name|val
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|base
operator|=
name|le16toh
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|iwn_read_prom_data
argument_list|(
name|sc
argument_list|,
name|base
operator|+
name|IWN6000_EEPROM_ENHINFO
argument_list|,
name|enhinfo
argument_list|,
sizeof|sizeof
name|enhinfo
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|enhinfo
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|flags
operator|=
name|enhinfo
index|[
name|i
index|]
operator|.
name|flags
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|IWN_ENHINFO_VALID
operator|)
condition|)
continue|continue;
comment|/* Skip invalid entries. */
name|maxpwr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|txchainmask
operator|&
name|IWN_ANT_A
condition|)
name|maxpwr
operator|=
name|MAX
argument_list|(
name|maxpwr
argument_list|,
name|enhinfo
index|[
name|i
index|]
operator|.
name|chain
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|txchainmask
operator|&
name|IWN_ANT_B
condition|)
name|maxpwr
operator|=
name|MAX
argument_list|(
name|maxpwr
argument_list|,
name|enhinfo
index|[
name|i
index|]
operator|.
name|chain
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|txchainmask
operator|&
name|IWN_ANT_C
condition|)
name|maxpwr
operator|=
name|MAX
argument_list|(
name|maxpwr
argument_list|,
name|enhinfo
index|[
name|i
index|]
operator|.
name|chain
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ntxchains
operator|==
literal|2
condition|)
name|maxpwr
operator|=
name|MAX
argument_list|(
name|maxpwr
argument_list|,
name|enhinfo
index|[
name|i
index|]
operator|.
name|mimo2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|ntxchains
operator|==
literal|3
condition|)
name|maxpwr
operator|=
name|MAX
argument_list|(
name|maxpwr
argument_list|,
name|enhinfo
index|[
name|i
index|]
operator|.
name|mimo3
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ic
operator|->
name|ic_nchans
condition|;
name|j
operator|++
control|)
block|{
name|c
operator|=
operator|&
name|ic
operator|->
name|ic_channels
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|IWN_ENHINFO_5GHZ
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|IEEE80211_IS_CHAN_A
argument_list|(
name|c
argument_list|)
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|IWN_ENHINFO_OFDM
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|IEEE80211_IS_CHAN_G
argument_list|(
name|c
argument_list|)
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
name|IEEE80211_IS_CHAN_B
argument_list|(
name|c
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|flags
operator|&
name|IWN_ENHINFO_HT40
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|c
argument_list|)
condition|)
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|c
argument_list|)
condition|)
continue|continue;
block|}
if|if
condition|(
name|enhinfo
index|[
name|i
index|]
operator|.
name|chan
operator|!=
literal|0
operator|&&
name|enhinfo
index|[
name|i
index|]
operator|.
name|chan
operator|!=
name|c
operator|->
name|ic_ieee
condition|)
continue|continue;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"channel %d(%x), maxpwr %d\n"
argument_list|,
name|c
operator|->
name|ic_ieee
argument_list|,
name|c
operator|->
name|ic_flags
argument_list|,
name|maxpwr
operator|/
literal|2
argument_list|)
expr_stmt|;
name|c
operator|->
name|ic_maxregpower
operator|=
name|maxpwr
operator|/
literal|2
expr_stmt|;
name|c
operator|->
name|ic_maxpower
operator|=
name|maxpwr
expr_stmt|;
block|}
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s end\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ieee80211_node
modifier|*
name|iwn_node_alloc
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|iwn_node
modifier|*
name|wn
decl_stmt|;
name|wn
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_node
argument_list|)
argument_list|,
name|M_80211_NODE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|wn
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|wn
operator|->
name|id
operator|=
name|IWN_ID_UNDEFINED
expr_stmt|;
return|return
operator|(
operator|&
name|wn
operator|->
name|ni
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|rate2plcp
parameter_list|(
name|int
name|rate
parameter_list|)
block|{
switch|switch
condition|(
name|rate
operator|&
literal|0xff
condition|)
block|{
case|case
literal|12
case|:
return|return
literal|0xd
return|;
case|case
literal|18
case|:
return|return
literal|0xf
return|;
case|case
literal|24
case|:
return|return
literal|0x5
return|;
case|case
literal|36
case|:
return|return
literal|0x7
return|;
case|case
literal|48
case|:
return|return
literal|0x9
return|;
case|case
literal|72
case|:
return|return
literal|0xb
return|;
case|case
literal|96
case|:
return|return
literal|0x1
return|;
case|case
literal|108
case|:
return|return
literal|0x3
return|;
case|case
literal|2
case|:
return|return
literal|10
return|;
case|case
literal|4
case|:
return|return
literal|20
return|;
case|case
literal|11
case|:
return|return
literal|55
return|;
case|case
literal|22
case|:
return|return
literal|110
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint8_t
name|plcp2rate
parameter_list|(
specifier|const
name|uint8_t
name|rate_plcp
parameter_list|)
block|{
switch|switch
condition|(
name|rate_plcp
condition|)
block|{
case|case
literal|0xd
case|:
return|return
literal|12
return|;
case|case
literal|0xf
case|:
return|return
literal|18
return|;
case|case
literal|0x5
case|:
return|return
literal|24
return|;
case|case
literal|0x7
case|:
return|return
literal|36
return|;
case|case
literal|0x9
case|:
return|return
literal|48
return|;
case|case
literal|0xb
case|:
return|return
literal|72
return|;
case|case
literal|0x1
case|:
return|return
literal|96
return|;
case|case
literal|0x3
case|:
return|return
literal|108
return|;
case|case
literal|10
case|:
return|return
literal|2
return|;
case|case
literal|20
case|:
return|return
literal|4
return|;
case|case
literal|55
case|:
return|return
literal|11
return|;
case|case
literal|110
case|:
return|return
literal|22
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_get_1stream_tx_antmask
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
name|IWN_LSB
argument_list|(
name|sc
operator|->
name|txchainmask
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_get_2stream_tx_antmask
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|tx
decl_stmt|;
comment|/* 	 * The '2 stream' setup is a bit .. odd. 	 * 	 * For NICs that support only 1 antenna, default to IWN_ANT_AB or 	 * the firmware panics (eg Intel 5100.) 	 * 	 * For NICs that support two antennas, we use ANT_AB. 	 * 	 * For NICs that support three antennas, we use the two that 	 * wasn't the default one. 	 * 	 * XXX TODO: if bluetooth (full concurrent) is enabled, restrict 	 * this to only one antenna. 	 */
comment|/* Default - transmit on the other antennas */
name|tx
operator|=
operator|(
name|sc
operator|->
name|txchainmask
operator|&
operator|~
name|IWN_LSB
argument_list|(
name|sc
operator|->
name|txchainmask
argument_list|)
operator|)
expr_stmt|;
comment|/* Now, if it's zero, set it to IWN_ANT_AB, so to not panic firmware */
if|if
condition|(
name|tx
operator|==
literal|0
condition|)
name|tx
operator|=
name|IWN_ANT_AB
expr_stmt|;
comment|/* 	 * If the NIC is a two-stream TX NIC, configure the TX mask to 	 * the default chainmask 	 */
elseif|else
if|if
condition|(
name|sc
operator|->
name|ntxchains
operator|==
literal|2
condition|)
name|tx
operator|=
name|sc
operator|->
name|txchainmask
expr_stmt|;
return|return
operator|(
name|tx
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate the required PLCP value from the given rate,  * to the given node.  *  * This will take the node configuration (eg 11n, rate table  * setup, etc) into consideration.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|iwn_rate_to_plcp
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|uint8_t
name|rate
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|uint32_t
name|plcp
init|=
literal|0
decl_stmt|;
name|int
name|ridx
decl_stmt|;
comment|/* 	 * If it's an MCS rate, let's set the plcp correctly 	 * and set the relevant flags based on the node config. 	 */
if|if
condition|(
name|rate
operator|&
name|IEEE80211_RATE_MCS
condition|)
block|{
comment|/* 		 * Set the initial PLCP value to be between 0->31 for 		 * MCS 0 -> MCS 31, then set the "I'm an MCS rate!" 		 * flag. 		 */
name|plcp
operator|=
name|IEEE80211_RV
argument_list|(
name|rate
argument_list|)
operator||
name|IWN_RFLAG_MCS
expr_stmt|;
comment|/* 		 * XXX the following should only occur if both 		 * the local configuration _and_ the remote node 		 * advertise these capabilities.  Thus this code 		 * may need fixing! 		 */
comment|/* 		 * Set the channel width and guard interval. 		 */
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
block|{
name|plcp
operator||=
name|IWN_RFLAG_HT40
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_htcap
operator|&
name|IEEE80211_HTCAP_SHORTGI40
condition|)
name|plcp
operator||=
name|IWN_RFLAG_SGI
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ni
operator|->
name|ni_htcap
operator|&
name|IEEE80211_HTCAP_SHORTGI20
condition|)
block|{
name|plcp
operator||=
name|IWN_RFLAG_SGI
expr_stmt|;
block|}
comment|/* 		 * Ensure the selected rate matches the link quality 		 * table entries being used. 		 */
if|if
condition|(
name|rate
operator|>
literal|0x8f
condition|)
name|plcp
operator||=
name|IWN_RFLAG_ANT
argument_list|(
name|sc
operator|->
name|txchainmask
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rate
operator|>
literal|0x87
condition|)
name|plcp
operator||=
name|IWN_RFLAG_ANT
argument_list|(
name|iwn_get_2stream_tx_antmask
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|plcp
operator||=
name|IWN_RFLAG_ANT
argument_list|(
name|iwn_get_1stream_tx_antmask
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Set the initial PLCP - fine for both 		 * OFDM and CCK rates. 		 */
name|plcp
operator|=
name|rate2plcp
argument_list|(
name|rate
argument_list|)
expr_stmt|;
comment|/* Set CCK flag if it's CCK */
comment|/* XXX It would be nice to have a method 		 * to map the ridx -> phy table entry 		 * so we could just query that, rather than 		 * this hack to check against IWN_RIDX_OFDM6. 		 */
name|ridx
operator|=
name|ieee80211_legacy_rate_lookup
argument_list|(
name|ic
operator|->
name|ic_rt
argument_list|,
name|rate
operator|&
name|IEEE80211_RATE_VAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ridx
operator|<
name|IWN_RIDX_OFDM6
operator|&&
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
name|plcp
operator||=
name|IWN_RFLAG_CCK
expr_stmt|;
comment|/* Set antenna configuration */
comment|/* XXX TODO: is this the right antenna to use for legacy? */
name|plcp
operator||=
name|IWN_RFLAG_ANT
argument_list|(
name|iwn_get_1stream_tx_antmask
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TXRATE
argument_list|,
literal|"%s: rate=0x%02x, plcp=0x%08x\n"
argument_list|,
name|__func__
argument_list|,
name|rate
argument_list|,
name|plcp
argument_list|)
expr_stmt|;
return|return
operator|(
name|htole32
argument_list|(
name|plcp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_newassoc
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|isnew
parameter_list|)
block|{
comment|/* Doesn't do anything at the moment */
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|ieee80211_media_change
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* NB: only the fixed rate can change and that doesn't need a reset */
return|return
operator|(
name|error
operator|==
name|ENETRESET
condition|?
literal|0
else|:
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_newstate
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|enum
name|ieee80211_state
name|nstate
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
name|struct
name|iwn_vap
modifier|*
name|ivp
init|=
name|IWN_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s begin\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_STATE
argument_list|,
literal|"%s: %s -> %s\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_state_name
index|[
name|vap
operator|->
name|iv_state
index|]
argument_list|,
name|ieee80211_state_name
index|[
name|nstate
index|]
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|calib_to
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rxon
operator|=
operator|&
name|sc
operator|->
name|rx_on
index|[
name|IWN_RXON_BSS_CTX
index|]
expr_stmt|;
switch|switch
condition|(
name|nstate
condition|)
block|{
case|case
name|IEEE80211_S_ASSOC
case|:
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|!=
name|IEEE80211_S_RUN
condition|)
break|break;
comment|/* FALLTHROUGH */
case|case
name|IEEE80211_S_AUTH
case|:
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_AUTH
condition|)
break|break;
comment|/* 		 * !AUTH -> AUTH transition requires state reset to handle 		 * reassociations correctly. 		 */
name|sc
operator|->
name|rxon
operator|->
name|associd
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rxon
operator|->
name|filter
operator|&=
operator|~
name|htole32
argument_list|(
name|IWN_FILTER_BSS
argument_list|)
expr_stmt|;
name|sc
operator|->
name|calib
operator|.
name|state
operator|=
name|IWN_CALIB_STATE_INIT
expr_stmt|;
comment|/* Wait until we hear a beacon before we transmit */
if|if
condition|(
name|IEEE80211_IS_CHAN_PASSIVE
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
condition|)
name|sc
operator|->
name|sc_beacon_wait
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_auth
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not move to auth state\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IEEE80211_S_RUN
case|:
comment|/* 		 * RUN -> RUN transition; Just restart the timers. 		 */
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_RUN
condition|)
block|{
name|sc
operator|->
name|calib_cnt
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* Wait until we hear a beacon before we transmit */
if|if
condition|(
name|IEEE80211_IS_CHAN_PASSIVE
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
condition|)
name|sc
operator|->
name|sc_beacon_wait
operator|=
literal|1
expr_stmt|;
comment|/* 		 * !RUN -> RUN requires setting the association id 		 * which is done with a firmware cmd.  We also defer 		 * starting the timers until that work is done. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_run
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not move to run state\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IEEE80211_S_INIT
case|:
name|sc
operator|->
name|calib
operator|.
name|state
operator|=
name|IWN_CALIB_STATE_INIT
expr_stmt|;
comment|/* 		 * Purge the xmit queue so we don't have old frames 		 * during a new association attempt. 		 */
name|sc
operator|->
name|sc_beacon_wait
operator|=
literal|0
expr_stmt|;
name|iwn_xmit_queue_drain
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s end in error\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s: end\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|ivp
operator|->
name|iv_newstate
argument_list|(
name|vap
argument_list|,
name|nstate
argument_list|,
name|arg
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_calib_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|IWN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Force automatic TX power calibration every 60 secs. */
if|if
condition|(
operator|++
name|sc
operator|->
name|calib_cnt
operator|>=
literal|120
condition|)
block|{
name|uint32_t
name|flags
init|=
literal|0
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s\n"
argument_list|,
literal|"sending request for statistics"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_GET_STATISTICS
argument_list|,
operator|&
name|flags
argument_list|,
sizeof|sizeof
name|flags
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|calib_cnt
operator|=
literal|0
expr_stmt|;
block|}
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|calib_to
argument_list|,
name|msecs_to_ticks
argument_list|(
literal|500
argument_list|)
argument_list|,
name|iwn_calib_timeout
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process an RX_PHY firmware notification.  This is usually immediately  * followed by an MPDU_RX_DONE notification.  */
end_comment

begin_function
specifier|static
name|void
name|iwn_rx_phy
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
name|desc
parameter_list|,
name|struct
name|iwn_rx_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|iwn_rx_stat
modifier|*
name|stat
init|=
operator|(
expr|struct
name|iwn_rx_stat
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s: received PHY stats\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rxq
operator|.
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
comment|/* Save RX statistics, they will be used on MPDU_RX_DONE. */
name|memcpy
argument_list|(
operator|&
name|sc
operator|->
name|last_rx_stat
argument_list|,
name|stat
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stat
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|last_rx_valid
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process an RX_DONE (4965AGN only) or MPDU_RX_DONE firmware notification.  * Each MPDU_RX_DONE notification must be preceded by an RX_PHY one.  */
end_comment

begin_function
specifier|static
name|void
name|iwn_rx_done
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
name|desc
parameter_list|,
name|struct
name|iwn_rx_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|iwn_ops
modifier|*
name|ops
init|=
operator|&
name|sc
operator|->
name|ops
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|iwn_rx_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|rxq
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m1
decl_stmt|;
name|struct
name|iwn_rx_stat
modifier|*
name|stat
decl_stmt|;
name|caddr_t
name|head
decl_stmt|;
name|bus_addr_t
name|paddr
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|int
name|error
decl_stmt|,
name|len
decl_stmt|,
name|rssi
decl_stmt|,
name|nf
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s begin\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|type
operator|==
name|IWN_MPDU_RX_DONE
condition|)
block|{
comment|/* Check for prior RX_PHY notification. */
if|if
condition|(
operator|!
name|sc
operator|->
name|last_rx_valid
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_ANY
argument_list|,
literal|"%s: missing RX_PHY\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|stat
operator|=
operator|&
name|sc
operator|->
name|last_rx_stat
expr_stmt|;
block|}
else|else
name|stat
operator|=
operator|(
expr|struct
name|iwn_rx_stat
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|->
name|cfg_phy_len
operator|>
name|IWN_STAT_MAXLEN
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: invalid RX statistic header, len %d\n"
argument_list|,
name|__func__
argument_list|,
name|stat
operator|->
name|cfg_phy_len
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|desc
operator|->
name|type
operator|==
name|IWN_MPDU_RX_DONE
condition|)
block|{
name|struct
name|iwn_rx_mpdu
modifier|*
name|mpdu
init|=
operator|(
expr|struct
name|iwn_rx_mpdu
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
decl_stmt|;
name|head
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|mpdu
operator|+
literal|1
argument_list|)
expr_stmt|;
name|len
operator|=
name|le16toh
argument_list|(
name|mpdu
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|head
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|stat
operator|+
literal|1
argument_list|)
operator|+
name|stat
operator|->
name|cfg_phy_len
expr_stmt|;
name|len
operator|=
name|le16toh
argument_list|(
name|stat
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
name|flags
operator|=
name|le32toh
argument_list|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|head
operator|+
name|len
operator|)
argument_list|)
expr_stmt|;
comment|/* Discard frames with a bad FCS early. */
if|if
condition|(
operator|(
name|flags
operator|&
name|IWN_RX_NOERROR
operator|)
operator|!=
name|IWN_RX_NOERROR
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RECV
argument_list|,
literal|"%s: RX flags error %x\n"
argument_list|,
name|__func__
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|counter_u64_add
argument_list|(
name|ic
operator|->
name|ic_ierrors
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Discard frames that are too short. */
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame_ack
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RECV
argument_list|,
literal|"%s: frame too short: %d\n"
argument_list|,
name|__func__
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|counter_u64_add
argument_list|(
name|ic
operator|->
name|ic_ierrors
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|m1
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|IWN_RBUF_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|m1
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_ANY
argument_list|,
literal|"%s: no mbuf to restock ring\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|counter_u64_add
argument_list|(
name|ic
operator|->
name|ic_ierrors
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|mtod
argument_list|(
name|m1
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|IWN_RBUF_SIZE
argument_list|,
name|iwn_dma_map_addr
argument_list|,
operator|&
name|paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|EFBIG
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: bus_dmamap_load failed, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m1
argument_list|)
expr_stmt|;
comment|/* Try to reload the old mbuf. */
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|mtod
argument_list|(
name|data
operator|->
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|IWN_RBUF_SIZE
argument_list|,
name|iwn_dma_map_addr
argument_list|,
operator|&
name|paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|EFBIG
condition|)
block|{
name|panic
argument_list|(
literal|"%s: could not load old RX mbuf"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
comment|/* Physical address may have changed. */
name|ring
operator|->
name|desc
index|[
name|ring
operator|->
name|cur
index|]
operator|=
name|htole32
argument_list|(
name|paddr
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|desc_dma
operator|.
name|tag
argument_list|,
name|ring
operator|->
name|desc_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|counter_u64_add
argument_list|(
name|ic
operator|->
name|ic_ierrors
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|m
operator|=
name|data
operator|->
name|m
expr_stmt|;
name|data
operator|->
name|m
operator|=
name|m1
expr_stmt|;
comment|/* Update RX descriptor. */
name|ring
operator|->
name|desc
index|[
name|ring
operator|->
name|cur
index|]
operator|=
name|htole32
argument_list|(
name|paddr
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|desc_dma
operator|.
name|tag
argument_list|,
name|ring
operator|->
name|desc_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Finalize mbuf. */
name|m
operator|->
name|m_data
operator|=
name|head
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
comment|/* Grab a reference to the source node. */
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame_min
argument_list|)
condition|)
name|ni
operator|=
name|ieee80211_find_rxnode
argument_list|(
name|ic
argument_list|,
operator|(
expr|struct
name|ieee80211_frame_min
operator|*
operator|)
name|wh
argument_list|)
expr_stmt|;
else|else
name|ni
operator|=
name|NULL
expr_stmt|;
name|nf
operator|=
operator|(
name|ni
operator|!=
name|NULL
operator|&&
name|ni
operator|->
name|ni_vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_RUN
operator|&&
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SCAN
operator|)
operator|==
literal|0
operator|)
condition|?
name|sc
operator|->
name|noise
else|:
operator|-
literal|95
expr_stmt|;
name|rssi
operator|=
name|ops
operator|->
name|get_rssi
argument_list|(
name|sc
argument_list|,
name|stat
argument_list|)
expr_stmt|;
if|if
condition|(
name|ieee80211_radiotap_active
argument_list|(
name|ic
argument_list|)
condition|)
block|{
name|struct
name|iwn_rx_radiotap_header
modifier|*
name|tap
init|=
operator|&
name|sc
operator|->
name|sc_rxtap
decl_stmt|;
name|uint32_t
name|rate
init|=
name|le32toh
argument_list|(
name|stat
operator|->
name|rate
argument_list|)
decl_stmt|;
name|tap
operator|->
name|wr_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|stat
operator|->
name|flags
operator|&
name|htole16
argument_list|(
name|IWN_STAT_FLAG_SHPREAMBLE
argument_list|)
condition|)
name|tap
operator|->
name|wr_flags
operator||=
name|IEEE80211_RADIOTAP_F_SHORTPRE
expr_stmt|;
name|tap
operator|->
name|wr_dbm_antsignal
operator|=
operator|(
name|int8_t
operator|)
name|rssi
expr_stmt|;
name|tap
operator|->
name|wr_dbm_antnoise
operator|=
operator|(
name|int8_t
operator|)
name|nf
expr_stmt|;
name|tap
operator|->
name|wr_tsft
operator|=
name|stat
operator|->
name|tstamp
expr_stmt|;
if|if
condition|(
name|rate
operator|&
name|IWN_RFLAG_MCS
condition|)
block|{
name|tap
operator|->
name|wr_rate
operator|=
name|rate
operator|&
name|IWN_RFLAG_RATE_MCS
expr_stmt|;
name|tap
operator|->
name|wr_rate
operator||=
name|IEEE80211_RATE_MCS
expr_stmt|;
block|}
else|else
name|tap
operator|->
name|wr_rate
operator|=
name|plcp2rate
argument_list|(
name|rate
operator|&
name|IWN_RFLAG_RATE
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If it's a beacon and we're waiting, then do the 	 * wakeup.  This should unblock raw_xmit/start. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_beacon_wait
condition|)
block|{
name|uint8_t
name|type
decl_stmt|,
name|subtype
decl_stmt|;
comment|/* NB: Re-assign wh */
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|type
operator|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
expr_stmt|;
name|subtype
operator|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
expr_stmt|;
comment|/* 		 * This assumes at this point we've received our own 		 * beacon. 		 */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"%s: beacon_wait, type=%d, subtype=%d\n"
argument_list|,
name|__func__
argument_list|,
name|type
argument_list|,
name|subtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|IEEE80211_FC0_TYPE_MGT
operator|&&
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_BEACON
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
operator||
name|IWN_DEBUG_XMIT
argument_list|,
literal|"%s: waking things up\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* queue taskqueue to transmit! */
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_xmit_task
argument_list|)
expr_stmt|;
block|}
block|}
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Send the frame to the 802.11 layer. */
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_HT
condition|)
name|m
operator|->
name|m_flags
operator||=
name|M_AMPDU
expr_stmt|;
operator|(
name|void
operator|)
name|ieee80211_input
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
name|rssi
operator|-
name|nf
argument_list|,
name|nf
argument_list|)
expr_stmt|;
comment|/* Node is no longer needed. */
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|ieee80211_input_all
argument_list|(
name|ic
argument_list|,
name|m
argument_list|,
name|rssi
operator|-
name|nf
argument_list|,
name|nf
argument_list|)
expr_stmt|;
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s: end\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process an incoming Compressed BlockAck. */
end_comment

begin_function
specifier|static
name|void
name|iwn_rx_compressed_ba
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
name|desc
parameter_list|,
name|struct
name|iwn_rx_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ieee80211_ratectl_tx_status
modifier|*
name|txs
init|=
operator|&
name|sc
operator|->
name|sc_txs
decl_stmt|;
name|struct
name|iwn_ops
modifier|*
name|ops
init|=
operator|&
name|sc
operator|->
name|ops
decl_stmt|;
name|struct
name|iwn_node
modifier|*
name|wn
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|iwn_compressed_ba
modifier|*
name|ba
init|=
operator|(
expr|struct
name|iwn_compressed_ba
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
decl_stmt|;
name|struct
name|iwn_tx_ring
modifier|*
name|txq
decl_stmt|;
name|struct
name|iwn_tx_data
modifier|*
name|txdata
decl_stmt|;
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint64_t
name|bitmap
decl_stmt|;
name|uint16_t
name|ssn
decl_stmt|;
name|uint8_t
name|tid
decl_stmt|;
name|int
name|i
decl_stmt|,
name|lastidx
decl_stmt|,
name|qid
decl_stmt|,
modifier|*
name|res
decl_stmt|,
name|shift
decl_stmt|;
name|int
name|tx_ok
init|=
literal|0
decl_stmt|,
name|tx_err
init|=
literal|0
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
operator||
name|IWN_DEBUG_XMIT
argument_list|,
literal|"->%s begin\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rxq
operator|.
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|qid
operator|=
name|le16toh
argument_list|(
name|ba
operator|->
name|qid
argument_list|)
expr_stmt|;
name|txq
operator|=
operator|&
name|sc
operator|->
name|txq
index|[
name|ba
operator|->
name|qid
index|]
expr_stmt|;
name|tap
operator|=
name|sc
operator|->
name|qid2tap
index|[
name|ba
operator|->
name|qid
index|]
expr_stmt|;
name|tid
operator|=
name|tap
operator|->
name|txa_tid
expr_stmt|;
name|wn
operator|=
operator|(
name|void
operator|*
operator|)
name|tap
operator|->
name|txa_ni
expr_stmt|;
name|res
operator|=
name|NULL
expr_stmt|;
name|ssn
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|IEEE80211_AMPDU_RUNNING
argument_list|(
name|tap
argument_list|)
condition|)
block|{
name|res
operator|=
name|tap
operator|->
name|txa_private
expr_stmt|;
name|ssn
operator|=
name|tap
operator|->
name|txa_start
operator|&
literal|0xfff
expr_stmt|;
block|}
for|for
control|(
name|lastidx
operator|=
name|le16toh
argument_list|(
name|ba
operator|->
name|ssn
argument_list|)
operator|&
literal|0xff
init|;
name|txq
operator|->
name|read
operator|!=
name|lastidx
condition|;
control|)
block|{
name|txdata
operator|=
operator|&
name|txq
operator|->
name|data
index|[
name|txq
operator|->
name|read
index|]
expr_stmt|;
comment|/* Unmap and free mbuf. */
name|bus_dmamap_sync
argument_list|(
name|txq
operator|->
name|data_dmat
argument_list|,
name|txdata
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|txq
operator|->
name|data_dmat
argument_list|,
name|txdata
operator|->
name|map
argument_list|)
expr_stmt|;
name|m
operator|=
name|txdata
operator|->
name|m
operator|,
name|txdata
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|ni
operator|=
name|txdata
operator|->
name|ni
operator|,
name|txdata
operator|->
name|ni
operator|=
name|NULL
expr_stmt|;
name|KASSERT
argument_list|(
name|ni
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no node"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no mbuf"
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_XMIT
argument_list|,
literal|"%s: freeing m=%p\n"
argument_list|,
name|__func__
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|ieee80211_tx_complete
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|txq
operator|->
name|queued
operator|--
expr_stmt|;
name|txq
operator|->
name|read
operator|=
operator|(
name|txq
operator|->
name|read
operator|+
literal|1
operator|)
operator|%
name|IWN_TX_RING_COUNT
expr_stmt|;
block|}
if|if
condition|(
name|txq
operator|->
name|queued
operator|==
literal|0
operator|&&
name|res
operator|!=
name|NULL
condition|)
block|{
name|iwn_nic_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ops
operator|->
name|ampdu_tx_stop
argument_list|(
name|sc
argument_list|,
name|qid
argument_list|,
name|tid
argument_list|,
name|ssn
argument_list|)
expr_stmt|;
name|iwn_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|qid2tap
index|[
name|qid
index|]
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|res
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|wn
operator|->
name|agg
index|[
name|tid
index|]
operator|.
name|bitmap
operator|==
literal|0
condition|)
return|return;
name|shift
operator|=
name|wn
operator|->
name|agg
index|[
name|tid
index|]
operator|.
name|startidx
operator|-
operator|(
operator|(
name|le16toh
argument_list|(
name|ba
operator|->
name|seq
argument_list|)
operator|>>
literal|4
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
if|if
condition|(
name|shift
operator|<
literal|0
condition|)
name|shift
operator|+=
literal|0x100
expr_stmt|;
if|if
condition|(
name|wn
operator|->
name|agg
index|[
name|tid
index|]
operator|.
name|nframes
operator|>
operator|(
literal|64
operator|-
name|shift
operator|)
condition|)
return|return;
comment|/* 	 * Walk the bitmap and calculate how many successful and failed 	 * attempts are made. 	 * 	 * Yes, the rate control code doesn't know these are A-MPDU 	 * subframes and that it's okay to fail some of these. 	 */
name|ni
operator|=
name|tap
operator|->
name|txa_ni
expr_stmt|;
name|bitmap
operator|=
operator|(
name|le64toh
argument_list|(
name|ba
operator|->
name|bitmap
argument_list|)
operator|>>
name|shift
operator|)
operator|&
name|wn
operator|->
name|agg
index|[
name|tid
index|]
operator|.
name|bitmap
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|bitmap
condition|;
name|i
operator|++
control|)
block|{
name|txs
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* XXX TODO */
if|if
condition|(
operator|(
name|bitmap
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|tx_err
operator|++
expr_stmt|;
name|txs
operator|->
name|status
operator|=
name|IEEE80211_RATECTL_TX_FAIL_UNSPECIFIED
expr_stmt|;
block|}
else|else
block|{
name|tx_ok
operator|++
expr_stmt|;
name|txs
operator|->
name|status
operator|=
name|IEEE80211_RATECTL_TX_SUCCESS
expr_stmt|;
block|}
name|ieee80211_ratectl_tx_complete
argument_list|(
name|ni
argument_list|,
name|txs
argument_list|)
expr_stmt|;
name|bitmap
operator|>>=
literal|1
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
operator||
name|IWN_DEBUG_XMIT
argument_list|,
literal|"->%s: end; %d ok; %d err\n"
argument_list|,
name|__func__
argument_list|,
name|tx_ok
argument_list|,
name|tx_err
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a CALIBRATION_RESULT notification sent by the initialization  * firmware on response to a CMD_CALIB_CONFIG command (5000 only).  */
end_comment

begin_function
specifier|static
name|void
name|iwn5000_rx_calib_results
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
name|desc
parameter_list|,
name|struct
name|iwn_rx_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|iwn_phy_calib
modifier|*
name|calib
init|=
operator|(
expr|struct
name|iwn_phy_calib
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
decl_stmt|;
name|int
name|len
decl_stmt|,
name|idx
init|=
operator|-
literal|1
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s begin\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Runtime firmware should not send such a notification. */
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWN_FLAG_CALIB_DONE
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s received after clib done\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|len
operator|=
operator|(
name|le32toh
argument_list|(
name|desc
operator|->
name|len
argument_list|)
operator|&
literal|0x3fff
operator|)
operator|-
literal|4
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rxq
operator|.
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|calib
operator|->
name|code
condition|)
block|{
case|case
name|IWN5000_PHY_CALIB_DC
case|:
if|if
condition|(
name|sc
operator|->
name|base_params
operator|->
name|calib_need
operator|&
name|IWN_FLG_NEED_PHY_CALIB_DC
condition|)
name|idx
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|IWN5000_PHY_CALIB_LO
case|:
if|if
condition|(
name|sc
operator|->
name|base_params
operator|->
name|calib_need
operator|&
name|IWN_FLG_NEED_PHY_CALIB_LO
condition|)
name|idx
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IWN5000_PHY_CALIB_TX_IQ
case|:
if|if
condition|(
name|sc
operator|->
name|base_params
operator|->
name|calib_need
operator|&
name|IWN_FLG_NEED_PHY_CALIB_TX_IQ
condition|)
name|idx
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|IWN5000_PHY_CALIB_TX_IQ_PERIODIC
case|:
if|if
condition|(
name|sc
operator|->
name|base_params
operator|->
name|calib_need
operator|&
name|IWN_FLG_NEED_PHY_CALIB_TX_IQ_PERIODIC
condition|)
name|idx
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|IWN5000_PHY_CALIB_BASE_BAND
case|:
if|if
condition|(
name|sc
operator|->
name|base_params
operator|->
name|calib_need
operator|&
name|IWN_FLG_NEED_PHY_CALIB_BASE_BAND
condition|)
name|idx
operator|=
literal|4
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
condition|)
comment|/* Ignore other results. */
return|return;
comment|/* Save calibration result. */
if|if
condition|(
name|sc
operator|->
name|calibcmd
index|[
name|idx
index|]
operator|.
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sc
operator|->
name|calibcmd
index|[
name|idx
index|]
operator|.
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|calibcmd
index|[
name|idx
index|]
operator|.
name|buf
operator|=
name|malloc
argument_list|(
name|len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|calibcmd
index|[
name|idx
index|]
operator|.
name|buf
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"not enough memory for calibration result %d\n"
argument_list|,
name|calib
operator|->
name|code
argument_list|)
expr_stmt|;
return|return;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"saving calibration result idx=%d, code=%d len=%d\n"
argument_list|,
name|idx
argument_list|,
name|calib
operator|->
name|code
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sc
operator|->
name|calibcmd
index|[
name|idx
index|]
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|sc
operator|->
name|calibcmd
index|[
name|idx
index|]
operator|.
name|buf
argument_list|,
name|calib
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_stats_update
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_calib_state
modifier|*
name|calib
parameter_list|,
name|struct
name|iwn_stats
modifier|*
name|stats
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|iwn_stats_bt
modifier|*
name|stats_bt
decl_stmt|;
name|struct
name|iwn_stats
modifier|*
name|lstats
decl_stmt|;
comment|/* 	 * First - check whether the length is the bluetooth or normal. 	 * 	 * If it's normal - just copy it and bump out. 	 * Otherwise we have to convert things. 	 */
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_stats
argument_list|)
operator|+
literal|4
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|sc
operator|->
name|last_stat
argument_list|,
name|stats
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_stats
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|last_stat_valid
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* 	 * If it's not the bluetooth size - log, then just copy. 	 */
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_stats_bt
argument_list|)
operator|+
literal|4
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_STATS
argument_list|,
literal|"%s: size of rx statistics (%d) not an expected size!\n"
argument_list|,
name|__func__
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sc
operator|->
name|last_stat
argument_list|,
name|stats
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_stats
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|last_stat_valid
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* 	 * Ok. Time to copy. 	 */
name|stats_bt
operator|=
operator|(
expr|struct
name|iwn_stats_bt
operator|*
operator|)
name|stats
expr_stmt|;
name|lstats
operator|=
operator|&
name|sc
operator|->
name|last_stat
expr_stmt|;
comment|/* flags */
name|lstats
operator|->
name|flags
operator|=
name|stats_bt
operator|->
name|flags
expr_stmt|;
comment|/* rx_bt */
name|memcpy
argument_list|(
operator|&
name|lstats
operator|->
name|rx
operator|.
name|ofdm
argument_list|,
operator|&
name|stats_bt
operator|->
name|rx_bt
operator|.
name|ofdm
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_rx_phy_stats
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lstats
operator|->
name|rx
operator|.
name|cck
argument_list|,
operator|&
name|stats_bt
operator|->
name|rx_bt
operator|.
name|cck
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_rx_phy_stats
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lstats
operator|->
name|rx
operator|.
name|general
argument_list|,
operator|&
name|stats_bt
operator|->
name|rx_bt
operator|.
name|general_bt
operator|.
name|common
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_rx_general_stats
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lstats
operator|->
name|rx
operator|.
name|ht
argument_list|,
operator|&
name|stats_bt
operator|->
name|rx_bt
operator|.
name|ht
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_rx_ht_phy_stats
argument_list|)
argument_list|)
expr_stmt|;
comment|/* tx */
name|memcpy
argument_list|(
operator|&
name|lstats
operator|->
name|tx
argument_list|,
operator|&
name|stats_bt
operator|->
name|tx
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_tx_stats
argument_list|)
argument_list|)
expr_stmt|;
comment|/* general */
name|memcpy
argument_list|(
operator|&
name|lstats
operator|->
name|general
argument_list|,
operator|&
name|stats_bt
operator|->
name|general
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_general_stats
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX TODO: Squirrel away the extra bluetooth stats somewhere */
name|sc
operator|->
name|last_stat_valid
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process an RX_STATISTICS or BEACON_STATISTICS firmware notification.  * The latter is sent by the firmware after each received beacon.  */
end_comment

begin_function
specifier|static
name|void
name|iwn_rx_statistics
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
name|desc
parameter_list|,
name|struct
name|iwn_rx_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|iwn_ops
modifier|*
name|ops
init|=
operator|&
name|sc
operator|->
name|ops
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
name|struct
name|iwn_calib_state
modifier|*
name|calib
init|=
operator|&
name|sc
operator|->
name|calib
decl_stmt|;
name|struct
name|iwn_stats
modifier|*
name|stats
init|=
operator|(
expr|struct
name|iwn_stats
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
decl_stmt|;
name|struct
name|iwn_stats
modifier|*
name|lstats
decl_stmt|;
name|int
name|temp
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s begin\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Ignore statistics received during a scan. */
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|!=
name|IEEE80211_S_RUN
operator|||
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SCAN
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s received during calib\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rxq
operator|.
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
operator||
name|IWN_DEBUG_STATS
argument_list|,
literal|"%s: received statistics, cmd %d, len %d\n"
argument_list|,
name|__func__
argument_list|,
name|desc
operator|->
name|type
argument_list|,
name|le16toh
argument_list|(
name|desc
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|calib_cnt
operator|=
literal|0
expr_stmt|;
comment|/* Reset TX power calibration timeout. */
comment|/* 	 * Collect/track general statistics for reporting. 	 * 	 * This takes care of ensuring that the bluetooth sized message 	 * will be correctly converted to the legacy sized message. 	 */
name|iwn_stats_update
argument_list|(
name|sc
argument_list|,
name|calib
argument_list|,
name|stats
argument_list|,
name|le16toh
argument_list|(
name|desc
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * And now, let's take a reference of it to use! 	 */
name|lstats
operator|=
operator|&
name|sc
operator|->
name|last_stat
expr_stmt|;
comment|/* Test if temperature has changed. */
if|if
condition|(
name|lstats
operator|->
name|general
operator|.
name|temp
operator|!=
name|sc
operator|->
name|rawtemp
condition|)
block|{
comment|/* Convert "raw" temperature to degC. */
name|sc
operator|->
name|rawtemp
operator|=
name|stats
operator|->
name|general
operator|.
name|temp
expr_stmt|;
name|temp
operator|=
name|ops
operator|->
name|get_temperature
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s: temperature %d\n"
argument_list|,
name|__func__
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* Update TX power if need be (4965AGN only). */
if|if
condition|(
name|sc
operator|->
name|hw_type
operator|==
name|IWN_HW_REV_TYPE_4965
condition|)
name|iwn4965_power_calibration
argument_list|(
name|sc
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|desc
operator|->
name|type
operator|!=
name|IWN_BEACON_STATISTICS
condition|)
return|return;
comment|/* Reply to a statistics request. */
name|sc
operator|->
name|noise
operator|=
name|iwn_get_noise
argument_list|(
operator|&
name|lstats
operator|->
name|rx
operator|.
name|general
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s: noise %d\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|noise
argument_list|)
expr_stmt|;
comment|/* Test that RSSI and noise are present in stats report. */
if|if
condition|(
name|le32toh
argument_list|(
name|lstats
operator|->
name|rx
operator|.
name|general
operator|.
name|flags
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_ANY
argument_list|,
literal|"%s\n"
argument_list|,
literal|"received statistics without RSSI"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|calib
operator|->
name|state
operator|==
name|IWN_CALIB_STATE_ASSOC
condition|)
name|iwn_collect_noise
argument_list|(
name|sc
argument_list|,
operator|&
name|lstats
operator|->
name|rx
operator|.
name|general
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|calib
operator|->
name|state
operator|==
name|IWN_CALIB_STATE_RUN
condition|)
block|{
name|iwn_tune_sensitivity
argument_list|(
name|sc
argument_list|,
operator|&
name|lstats
operator|->
name|rx
argument_list|)
expr_stmt|;
comment|/* 		 * XXX TODO: Only run the RX recovery if we're associated! 		 */
name|iwn_check_rx_recovery
argument_list|(
name|sc
argument_list|,
name|lstats
argument_list|)
expr_stmt|;
name|iwn_save_stats_counters
argument_list|(
name|sc
argument_list|,
name|lstats
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s: end\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Save the relevant statistic counters for the next calibration  * pass.  */
end_comment

begin_function
specifier|static
name|void
name|iwn_save_stats_counters
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|iwn_stats
modifier|*
name|rs
parameter_list|)
block|{
name|struct
name|iwn_calib_state
modifier|*
name|calib
init|=
operator|&
name|sc
operator|->
name|calib
decl_stmt|;
comment|/* Save counters values for next call. */
name|calib
operator|->
name|bad_plcp_cck
operator|=
name|le32toh
argument_list|(
name|rs
operator|->
name|rx
operator|.
name|cck
operator|.
name|bad_plcp
argument_list|)
expr_stmt|;
name|calib
operator|->
name|fa_cck
operator|=
name|le32toh
argument_list|(
name|rs
operator|->
name|rx
operator|.
name|cck
operator|.
name|fa
argument_list|)
expr_stmt|;
name|calib
operator|->
name|bad_plcp_ht
operator|=
name|le32toh
argument_list|(
name|rs
operator|->
name|rx
operator|.
name|ht
operator|.
name|bad_plcp
argument_list|)
expr_stmt|;
name|calib
operator|->
name|bad_plcp_ofdm
operator|=
name|le32toh
argument_list|(
name|rs
operator|->
name|rx
operator|.
name|ofdm
operator|.
name|bad_plcp
argument_list|)
expr_stmt|;
name|calib
operator|->
name|fa_ofdm
operator|=
name|le32toh
argument_list|(
name|rs
operator|->
name|rx
operator|.
name|ofdm
operator|.
name|fa
argument_list|)
expr_stmt|;
comment|/* Last time we received these tick values */
name|sc
operator|->
name|last_calib_ticks
operator|=
name|ticks
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a TX_DONE firmware notification.  Unfortunately, the 4965AGN  * and 5000 adapters have different incompatible TX status formats.  */
end_comment

begin_function
specifier|static
name|void
name|iwn4965_tx_done
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
name|desc
parameter_list|,
name|struct
name|iwn_rx_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|iwn4965_tx_stat
modifier|*
name|stat
init|=
operator|(
expr|struct
name|iwn4965_tx_stat
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
decl_stmt|;
name|struct
name|iwn_tx_ring
modifier|*
name|ring
decl_stmt|;
name|int
name|qid
decl_stmt|;
name|qid
operator|=
name|desc
operator|->
name|qid
operator|&
literal|0xf
expr_stmt|;
name|ring
operator|=
operator|&
name|sc
operator|->
name|txq
index|[
name|qid
index|]
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_XMIT
argument_list|,
literal|"%s: "
literal|"qid %d idx %d RTS retries %d ACK retries %d nkill %d rate %x duration %d status %x\n"
argument_list|,
name|__func__
argument_list|,
name|desc
operator|->
name|qid
argument_list|,
name|desc
operator|->
name|idx
argument_list|,
name|stat
operator|->
name|rtsfailcnt
argument_list|,
name|stat
operator|->
name|ackfailcnt
argument_list|,
name|stat
operator|->
name|btkillcnt
argument_list|,
name|stat
operator|->
name|rate
argument_list|,
name|le16toh
argument_list|(
name|stat
operator|->
name|duration
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|stat
operator|->
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|qid
operator|>=
name|sc
operator|->
name|firstaggqueue
condition|)
block|{
name|iwn_ampdu_tx_done
argument_list|(
name|sc
argument_list|,
name|qid
argument_list|,
name|desc
operator|->
name|idx
argument_list|,
name|stat
operator|->
name|nframes
argument_list|,
name|stat
operator|->
name|rtsfailcnt
argument_list|,
name|stat
operator|->
name|ackfailcnt
argument_list|,
operator|&
name|stat
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|iwn_tx_done
argument_list|(
name|sc
argument_list|,
name|desc
argument_list|,
name|stat
operator|->
name|rtsfailcnt
argument_list|,
name|stat
operator|->
name|ackfailcnt
argument_list|,
name|le32toh
argument_list|(
name|stat
operator|->
name|status
argument_list|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|iwn5000_tx_done
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
name|desc
parameter_list|,
name|struct
name|iwn_rx_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|iwn5000_tx_stat
modifier|*
name|stat
init|=
operator|(
expr|struct
name|iwn5000_tx_stat
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
decl_stmt|;
name|struct
name|iwn_tx_ring
modifier|*
name|ring
decl_stmt|;
name|int
name|qid
decl_stmt|;
name|qid
operator|=
name|desc
operator|->
name|qid
operator|&
literal|0xf
expr_stmt|;
name|ring
operator|=
operator|&
name|sc
operator|->
name|txq
index|[
name|qid
index|]
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_XMIT
argument_list|,
literal|"%s: "
literal|"qid %d idx %d RTS retries %d ACK retries %d nkill %d rate %x duration %d status %x\n"
argument_list|,
name|__func__
argument_list|,
name|desc
operator|->
name|qid
argument_list|,
name|desc
operator|->
name|idx
argument_list|,
name|stat
operator|->
name|rtsfailcnt
argument_list|,
name|stat
operator|->
name|ackfailcnt
argument_list|,
name|stat
operator|->
name|btkillcnt
argument_list|,
name|stat
operator|->
name|rate
argument_list|,
name|le16toh
argument_list|(
name|stat
operator|->
name|duration
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|stat
operator|->
name|status
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* Reset TX scheduler slot. */
name|iwn5000_reset_sched
argument_list|(
name|sc
argument_list|,
name|desc
operator|->
name|qid
operator|&
literal|0xf
argument_list|,
name|desc
operator|->
name|idx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|qid
operator|>=
name|sc
operator|->
name|firstaggqueue
condition|)
block|{
name|iwn_ampdu_tx_done
argument_list|(
name|sc
argument_list|,
name|qid
argument_list|,
name|desc
operator|->
name|idx
argument_list|,
name|stat
operator|->
name|nframes
argument_list|,
name|stat
operator|->
name|rtsfailcnt
argument_list|,
name|stat
operator|->
name|ackfailcnt
argument_list|,
operator|&
name|stat
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|iwn_tx_done
argument_list|(
name|sc
argument_list|,
name|desc
argument_list|,
name|stat
operator|->
name|rtsfailcnt
argument_list|,
name|stat
operator|->
name|ackfailcnt
argument_list|,
name|le16toh
argument_list|(
name|stat
operator|->
name|status
argument_list|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Adapter-independent backend for TX_DONE firmware notifications.  */
end_comment

begin_function
specifier|static
name|void
name|iwn_tx_done
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
name|desc
parameter_list|,
name|int
name|rtsfailcnt
parameter_list|,
name|int
name|ackfailcnt
parameter_list|,
name|uint8_t
name|status
parameter_list|)
block|{
name|struct
name|ieee80211_ratectl_tx_status
modifier|*
name|txs
init|=
operator|&
name|sc
operator|->
name|sc_txs
decl_stmt|;
name|struct
name|iwn_tx_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|txq
index|[
name|desc
operator|->
name|qid
operator|&
literal|0xf
index|]
decl_stmt|;
name|struct
name|iwn_tx_data
modifier|*
name|data
init|=
operator|&
name|ring
operator|->
name|data
index|[
name|desc
operator|->
name|idx
index|]
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|KASSERT
argument_list|(
name|data
operator|->
name|ni
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no node"
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s begin\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Unmap and free mbuf. */
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
name|m
operator|=
name|data
operator|->
name|m
operator|,
name|data
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|ni
operator|=
name|data
operator|->
name|ni
operator|,
name|data
operator|->
name|ni
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Update rate control statistics for the node. 	 */
name|txs
operator|->
name|flags
operator|=
name|IEEE80211_RATECTL_STATUS_SHORT_RETRY
operator||
name|IEEE80211_RATECTL_STATUS_LONG_RETRY
expr_stmt|;
name|txs
operator|->
name|short_retries
operator|=
name|rtsfailcnt
expr_stmt|;
name|txs
operator|->
name|long_retries
operator|=
name|ackfailcnt
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|IWN_TX_FAIL
operator|)
condition|)
name|txs
operator|->
name|status
operator|=
name|IEEE80211_RATECTL_TX_SUCCESS
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|IWN_TX_FAIL_SHORT_LIMIT
case|:
name|txs
operator|->
name|status
operator|=
name|IEEE80211_RATECTL_TX_FAIL_SHORT
expr_stmt|;
break|break;
case|case
name|IWN_TX_FAIL_LONG_LIMIT
case|:
name|txs
operator|->
name|status
operator|=
name|IEEE80211_RATECTL_TX_FAIL_LONG
expr_stmt|;
break|break;
case|case
name|IWN_TX_STATUS_FAIL_LIFE_EXPIRE
case|:
name|txs
operator|->
name|status
operator|=
name|IEEE80211_RATECTL_TX_FAIL_EXPIRED
expr_stmt|;
break|break;
default|default:
name|txs
operator|->
name|status
operator|=
name|IEEE80211_RATECTL_TX_FAIL_UNSPECIFIED
expr_stmt|;
break|break;
block|}
block|}
name|ieee80211_ratectl_tx_complete
argument_list|(
name|ni
argument_list|,
name|txs
argument_list|)
expr_stmt|;
comment|/* 	 * Channels marked for "radar" require traffic to be received 	 * to unlock before we can transmit.  Until traffic is seen 	 * any attempt to transmit is returned immediately with status 	 * set to IWN_TX_FAIL_TX_LOCKED.  Unfortunately this can easily 	 * happen on first authenticate after scanning.  To workaround 	 * this we ignore a failure of this sort in AUTH state so the 	 * 802.11 layer will fall back to using a timeout to wait for 	 * the AUTH reply.  This allows the firmware time to see 	 * traffic so a subsequent retry of AUTH succeeds.  It's 	 * unclear why the firmware does not maintain state for 	 * channels recently visited as this would allow immediate 	 * use of the channel after a scan (where we see traffic). 	 */
if|if
condition|(
name|status
operator|==
name|IWN_TX_FAIL_TX_LOCKED
operator|&&
name|ni
operator|->
name|ni_vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_AUTH
condition|)
name|ieee80211_tx_complete
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|ieee80211_tx_complete
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
operator|(
name|status
operator|&
name|IWN_TX_FAIL
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|--
name|ring
operator|->
name|queued
operator|<
name|IWN_TX_RING_LOMARK
condition|)
name|sc
operator|->
name|qfullmsk
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|ring
operator|->
name|qid
operator|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s: end\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a "command done" firmware notification.  This is where we wakeup  * processes waiting for a synchronous command completion.  */
end_comment

begin_function
specifier|static
name|void
name|iwn_cmd_done
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_rx_desc
modifier|*
name|desc
parameter_list|)
block|{
name|struct
name|iwn_tx_ring
modifier|*
name|ring
decl_stmt|;
name|struct
name|iwn_tx_data
modifier|*
name|data
decl_stmt|;
name|int
name|cmd_queue_num
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWN_FLAG_PAN_SUPPORT
condition|)
name|cmd_queue_num
operator|=
name|IWN_PAN_CMD_QUEUE
expr_stmt|;
else|else
name|cmd_queue_num
operator|=
name|IWN_CMD_QUEUE_NUM
expr_stmt|;
if|if
condition|(
operator|(
name|desc
operator|->
name|qid
operator|&
name|IWN_RX_DESC_QID_MSK
operator|)
operator|!=
name|cmd_queue_num
condition|)
return|return;
comment|/* Not a command ack. */
name|ring
operator|=
operator|&
name|sc
operator|->
name|txq
index|[
name|cmd_queue_num
index|]
expr_stmt|;
name|data
operator|=
operator|&
name|ring
operator|->
name|data
index|[
name|desc
operator|->
name|idx
index|]
expr_stmt|;
comment|/* If the command was mapped in an mbuf, free it. */
if|if
condition|(
name|data
operator|->
name|m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|data
operator|->
name|m
argument_list|)
expr_stmt|;
name|data
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
name|wakeup
argument_list|(
operator|&
name|ring
operator|->
name|desc
index|[
name|desc
operator|->
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_ampdu_tx_done
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qid
parameter_list|,
name|int
name|idx
parameter_list|,
name|int
name|nframes
parameter_list|,
name|int
name|rtsfailcnt
parameter_list|,
name|int
name|ackfailcnt
parameter_list|,
name|void
modifier|*
name|stat
parameter_list|)
block|{
name|struct
name|iwn_ops
modifier|*
name|ops
init|=
operator|&
name|sc
operator|->
name|ops
decl_stmt|;
name|struct
name|iwn_tx_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|txq
index|[
name|qid
index|]
decl_stmt|;
name|struct
name|ieee80211_ratectl_tx_status
modifier|*
name|txs
init|=
operator|&
name|sc
operator|->
name|sc_txs
decl_stmt|;
name|struct
name|iwn_tx_data
modifier|*
name|data
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|iwn_node
modifier|*
name|wn
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
name|uint64_t
name|bitmap
decl_stmt|;
name|uint32_t
modifier|*
name|status
init|=
name|stat
decl_stmt|;
name|uint16_t
modifier|*
name|aggstatus
init|=
name|stat
decl_stmt|;
name|uint16_t
name|ssn
decl_stmt|;
name|uint8_t
name|tid
decl_stmt|;
name|int
name|bit
decl_stmt|,
name|i
decl_stmt|,
name|lastidx
decl_stmt|,
modifier|*
name|res
decl_stmt|,
name|seqno
decl_stmt|,
name|shift
decl_stmt|,
name|start
decl_stmt|;
comment|/* XXX TODO: status is le16 field! Grr */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s begin\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_XMIT
argument_list|,
literal|"%s: nframes=%d, status=0x%08x\n"
argument_list|,
name|__func__
argument_list|,
name|nframes
argument_list|,
operator|*
name|status
argument_list|)
expr_stmt|;
name|tap
operator|=
name|sc
operator|->
name|qid2tap
index|[
name|qid
index|]
expr_stmt|;
name|tid
operator|=
name|tap
operator|->
name|txa_tid
expr_stmt|;
name|wn
operator|=
operator|(
name|void
operator|*
operator|)
name|tap
operator|->
name|txa_ni
expr_stmt|;
name|ni
operator|=
name|tap
operator|->
name|txa_ni
expr_stmt|;
comment|/* 	 * XXX TODO: ACK and RTS failures would be nice here! 	 */
comment|/* 	 * A-MPDU single frame status - if we failed to transmit it 	 * in A-MPDU, then it may be a permanent failure. 	 * 	 * XXX TODO: check what the Linux iwlwifi driver does here; 	 * there's some permanent and temporary failures that may be 	 * handled differently. 	 */
if|if
condition|(
name|nframes
operator|==
literal|1
condition|)
block|{
name|txs
operator|->
name|flags
operator|=
name|IEEE80211_RATECTL_STATUS_SHORT_RETRY
operator||
name|IEEE80211_RATECTL_STATUS_LONG_RETRY
expr_stmt|;
name|txs
operator|->
name|short_retries
operator|=
name|rtsfailcnt
expr_stmt|;
name|txs
operator|->
name|long_retries
operator|=
name|ackfailcnt
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|status
operator|&
literal|0xff
operator|)
operator|!=
literal|1
operator|&&
operator|(
operator|*
name|status
operator|&
literal|0xff
operator|)
operator|!=
literal|2
condition|)
block|{
ifdef|#
directive|ifdef
name|NOT_YET
name|printf
argument_list|(
literal|"ieee80211_send_bar()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 			 * If we completely fail a transmit, make sure a 			 * notification is pushed up to the rate control 			 * layer. 			 */
comment|/* XXX */
name|txs
operator|->
name|status
operator|=
name|IEEE80211_RATECTL_TX_FAIL_UNSPECIFIED
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * If nframes=1, then we won't be getting a BA for 			 * this frame.  Ensure that we correctly update the 			 * rate control code with how many retries were 			 * needed to send it. 			 */
name|txs
operator|->
name|status
operator|=
name|IEEE80211_RATECTL_TX_SUCCESS
expr_stmt|;
block|}
name|ieee80211_ratectl_tx_complete
argument_list|(
name|ni
argument_list|,
name|txs
argument_list|)
expr_stmt|;
block|}
name|bitmap
operator|=
literal|0
expr_stmt|;
name|start
operator|=
name|idx
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nframes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|le16toh
argument_list|(
name|aggstatus
index|[
name|i
operator|*
literal|2
index|]
argument_list|)
operator|&
literal|0xc
condition|)
continue|continue;
name|idx
operator|=
name|le16toh
argument_list|(
name|aggstatus
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
argument_list|)
operator|&
literal|0xff
expr_stmt|;
name|bit
operator|=
name|idx
operator|-
name|start
expr_stmt|;
name|shift
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bit
operator|>=
literal|64
condition|)
block|{
name|shift
operator|=
literal|0x100
operator|-
name|idx
operator|+
name|start
expr_stmt|;
name|bit
operator|=
literal|0
expr_stmt|;
name|start
operator|=
name|idx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bit
operator|<=
operator|-
literal|64
condition|)
name|bit
operator|=
literal|0x100
operator|-
name|start
operator|+
name|idx
expr_stmt|;
elseif|else
if|if
condition|(
name|bit
operator|<
literal|0
condition|)
block|{
name|shift
operator|=
name|start
operator|-
name|idx
expr_stmt|;
name|start
operator|=
name|idx
expr_stmt|;
name|bit
operator|=
literal|0
expr_stmt|;
block|}
name|bitmap
operator|=
name|bitmap
operator|<<
name|shift
expr_stmt|;
name|bitmap
operator||=
literal|1ULL
operator|<<
name|bit
expr_stmt|;
block|}
name|tap
operator|=
name|sc
operator|->
name|qid2tap
index|[
name|qid
index|]
expr_stmt|;
name|tid
operator|=
name|tap
operator|->
name|txa_tid
expr_stmt|;
name|wn
operator|=
operator|(
name|void
operator|*
operator|)
name|tap
operator|->
name|txa_ni
expr_stmt|;
name|wn
operator|->
name|agg
index|[
name|tid
index|]
operator|.
name|bitmap
operator|=
name|bitmap
expr_stmt|;
name|wn
operator|->
name|agg
index|[
name|tid
index|]
operator|.
name|startidx
operator|=
name|start
expr_stmt|;
name|wn
operator|->
name|agg
index|[
name|tid
index|]
operator|.
name|nframes
operator|=
name|nframes
expr_stmt|;
name|res
operator|=
name|NULL
expr_stmt|;
name|ssn
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|IEEE80211_AMPDU_RUNNING
argument_list|(
name|tap
argument_list|)
condition|)
block|{
name|res
operator|=
name|tap
operator|->
name|txa_private
expr_stmt|;
name|ssn
operator|=
name|tap
operator|->
name|txa_start
operator|&
literal|0xfff
expr_stmt|;
block|}
comment|/* This is going nframes DWORDS into the descriptor? */
name|seqno
operator|=
name|le32toh
argument_list|(
operator|*
operator|(
name|status
operator|+
name|nframes
operator|)
argument_list|)
operator|&
literal|0xfff
expr_stmt|;
for|for
control|(
name|lastidx
operator|=
operator|(
name|seqno
operator|&
literal|0xff
operator|)
init|;
name|ring
operator|->
name|read
operator|!=
name|lastidx
condition|;
control|)
block|{
name|data
operator|=
operator|&
name|ring
operator|->
name|data
index|[
name|ring
operator|->
name|read
index|]
expr_stmt|;
comment|/* Unmap and free mbuf. */
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|)
expr_stmt|;
name|m
operator|=
name|data
operator|->
name|m
operator|,
name|data
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|ni
operator|=
name|data
operator|->
name|ni
operator|,
name|data
operator|->
name|ni
operator|=
name|NULL
expr_stmt|;
name|KASSERT
argument_list|(
name|ni
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no node"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no mbuf"
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_XMIT
argument_list|,
literal|"%s: freeing m=%p\n"
argument_list|,
name|__func__
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|ieee80211_tx_complete
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ring
operator|->
name|queued
operator|--
expr_stmt|;
name|ring
operator|->
name|read
operator|=
operator|(
name|ring
operator|->
name|read
operator|+
literal|1
operator|)
operator|%
name|IWN_TX_RING_COUNT
expr_stmt|;
block|}
if|if
condition|(
name|ring
operator|->
name|queued
operator|==
literal|0
operator|&&
name|res
operator|!=
name|NULL
condition|)
block|{
name|iwn_nic_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ops
operator|->
name|ampdu_tx_stop
argument_list|(
name|sc
argument_list|,
name|qid
argument_list|,
name|tid
argument_list|,
name|ssn
argument_list|)
expr_stmt|;
name|iwn_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|qid2tap
index|[
name|qid
index|]
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|res
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|queued
operator|<
name|IWN_TX_RING_LOMARK
condition|)
name|sc
operator|->
name|qfullmsk
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|ring
operator|->
name|qid
operator|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s: end\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process an INT_FH_RX or INT_SW_RX interrupt.  */
end_comment

begin_function
specifier|static
name|void
name|iwn_notif_intr
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwn_ops
modifier|*
name|ops
init|=
operator|&
name|sc
operator|->
name|ops
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
name|uint16_t
name|hw
decl_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rxq
operator|.
name|stat_dma
operator|.
name|tag
argument_list|,
name|sc
operator|->
name|rxq
operator|.
name|stat_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|hw
operator|=
name|le16toh
argument_list|(
name|sc
operator|->
name|rxq
operator|.
name|stat
operator|->
name|closed_count
argument_list|)
operator|&
literal|0xfff
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|rxq
operator|.
name|cur
operator|!=
name|hw
condition|)
block|{
name|struct
name|iwn_rx_data
modifier|*
name|data
init|=
operator|&
name|sc
operator|->
name|rxq
operator|.
name|data
index|[
name|sc
operator|->
name|rxq
operator|.
name|cur
index|]
decl_stmt|;
name|struct
name|iwn_rx_desc
modifier|*
name|desc
decl_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rxq
operator|.
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|desc
operator|=
name|mtod
argument_list|(
name|data
operator|->
name|m
argument_list|,
expr|struct
name|iwn_rx_desc
operator|*
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RECV
argument_list|,
literal|"%s: cur=%d; qid %x idx %d flags %x type %d(%s) len %d\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|rxq
operator|.
name|cur
argument_list|,
name|desc
operator|->
name|qid
operator|&
literal|0xf
argument_list|,
name|desc
operator|->
name|idx
argument_list|,
name|desc
operator|->
name|flags
argument_list|,
name|desc
operator|->
name|type
argument_list|,
name|iwn_intr_str
argument_list|(
name|desc
operator|->
name|type
argument_list|)
argument_list|,
name|le16toh
argument_list|(
name|desc
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|desc
operator|->
name|qid
operator|&
name|IWN_UNSOLICITED_RX_NOTIF
operator|)
condition|)
comment|/* Reply to a command. */
name|iwn_cmd_done
argument_list|(
name|sc
argument_list|,
name|desc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|desc
operator|->
name|type
condition|)
block|{
case|case
name|IWN_RX_PHY
case|:
name|iwn_rx_phy
argument_list|(
name|sc
argument_list|,
name|desc
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|IWN_RX_DONE
case|:
comment|/* 4965AGN only. */
case|case
name|IWN_MPDU_RX_DONE
case|:
comment|/* An 802.11 frame has been received. */
name|iwn_rx_done
argument_list|(
name|sc
argument_list|,
name|desc
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|IWN_RX_COMPRESSED_BA
case|:
comment|/* A Compressed BlockAck has been received. */
name|iwn_rx_compressed_ba
argument_list|(
name|sc
argument_list|,
name|desc
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|IWN_TX_DONE
case|:
comment|/* An 802.11 frame has been transmitted. */
name|ops
operator|->
name|tx_done
argument_list|(
name|sc
argument_list|,
name|desc
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|IWN_RX_STATISTICS
case|:
case|case
name|IWN_BEACON_STATISTICS
case|:
name|iwn_rx_statistics
argument_list|(
name|sc
argument_list|,
name|desc
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|IWN_BEACON_MISSED
case|:
block|{
name|struct
name|iwn_beacon_missed
modifier|*
name|miss
init|=
operator|(
expr|struct
name|iwn_beacon_missed
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
decl_stmt|;
name|int
name|misses
decl_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rxq
operator|.
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|misses
operator|=
name|le32toh
argument_list|(
name|miss
operator|->
name|consecutive
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_STATE
argument_list|,
literal|"%s: beacons missed %d/%d\n"
argument_list|,
name|__func__
argument_list|,
name|misses
argument_list|,
name|le32toh
argument_list|(
name|miss
operator|->
name|total
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * If more than 5 consecutive beacons are missed, 			 * reinitialize the sensitivity state machine. 			 */
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_RUN
operator|&&
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SCAN
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|misses
operator|>
literal|5
condition|)
operator|(
name|void
operator|)
name|iwn_init_sensitivity
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|misses
operator|>=
name|vap
operator|->
name|iv_bmissthreshold
condition|)
block|{
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ieee80211_beacon_miss
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|IWN_UC_READY
case|:
block|{
name|struct
name|iwn_ucode_info
modifier|*
name|uc
init|=
operator|(
expr|struct
name|iwn_ucode_info
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
decl_stmt|;
comment|/* The microcontroller is ready. */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rxq
operator|.
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"microcode alive notification version=%d.%d "
literal|"subtype=%x alive=%x\n"
argument_list|,
name|uc
operator|->
name|major
argument_list|,
name|uc
operator|->
name|minor
argument_list|,
name|uc
operator|->
name|subtype
argument_list|,
name|le32toh
argument_list|(
name|uc
operator|->
name|valid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|le32toh
argument_list|(
name|uc
operator|->
name|valid
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"microcontroller initialization failed"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|uc
operator|->
name|subtype
operator|==
name|IWN_UCODE_INIT
condition|)
block|{
comment|/* Save microcontroller report. */
name|memcpy
argument_list|(
operator|&
name|sc
operator|->
name|ucode_info
argument_list|,
name|uc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|uc
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Save the address of the error log in SRAM. */
name|sc
operator|->
name|errptr
operator|=
name|le32toh
argument_list|(
name|uc
operator|->
name|errptr
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IWN_STATE_CHANGED
case|:
block|{
comment|/* 			 * State change allows hardware switch change to be 			 * noted. However, we handle this in iwn_intr as we 			 * get both the enable/disble intr. 			 */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rxq
operator|.
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IWN_DEBUG
name|uint32_t
modifier|*
name|status
init|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_INTR
operator||
name|IWN_DEBUG_STATE
argument_list|,
literal|"state changed to %x\n"
argument_list|,
name|le32toh
argument_list|(
operator|*
name|status
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
case|case
name|IWN_START_SCAN
case|:
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rxq
operator|.
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IWN_DEBUG
name|struct
name|iwn_start_scan
modifier|*
name|scan
init|=
operator|(
expr|struct
name|iwn_start_scan
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_ANY
argument_list|,
literal|"%s: scanning channel %d status %x\n"
argument_list|,
name|__func__
argument_list|,
name|scan
operator|->
name|chan
argument_list|,
name|le32toh
argument_list|(
name|scan
operator|->
name|status
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
case|case
name|IWN_STOP_SCAN
case|:
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rxq
operator|.
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IWN_DEBUG
name|struct
name|iwn_stop_scan
modifier|*
name|scan
init|=
operator|(
expr|struct
name|iwn_stop_scan
operator|*
operator|)
operator|(
name|desc
operator|+
literal|1
operator|)
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_STATE
operator||
name|IWN_DEBUG_SCAN
argument_list|,
literal|"scan finished nchan=%d status=%d chan=%d\n"
argument_list|,
name|scan
operator|->
name|nchan
argument_list|,
name|scan
operator|->
name|status
argument_list|,
name|scan
operator|->
name|chan
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_is_scanning
operator|=
literal|0
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|scan_timeout
argument_list|)
expr_stmt|;
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ieee80211_scan_next
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IWN5000_CALIBRATION_RESULT
case|:
name|iwn5000_rx_calib_results
argument_list|(
name|sc
argument_list|,
name|desc
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|IWN5000_CALIBRATION_DONE
case|:
name|sc
operator|->
name|sc_flags
operator||=
name|IWN_FLAG_CALIB_DONE
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|rxq
operator|.
name|cur
operator|=
operator|(
name|sc
operator|->
name|rxq
operator|.
name|cur
operator|+
literal|1
operator|)
operator|%
name|IWN_RX_RING_COUNT
expr_stmt|;
block|}
comment|/* Tell the firmware what we have processed. */
name|hw
operator|=
operator|(
name|hw
operator|==
literal|0
operator|)
condition|?
name|IWN_RX_RING_COUNT
operator|-
literal|1
else|:
name|hw
operator|-
literal|1
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_RX_WPTR
argument_list|,
name|hw
operator|&
operator|~
literal|7
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process an INT_WAKEUP interrupt raised when the microcontroller wakes up  * from power-down sleep mode.  */
end_comment

begin_function
specifier|static
name|void
name|iwn_wakeup_intr
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|qid
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"%s: ucode wakeup from power-down sleep\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Wakeup RX and TX rings. */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_RX_WPTR
argument_list|,
name|sc
operator|->
name|rxq
operator|.
name|cur
operator|&
operator|~
literal|7
argument_list|)
expr_stmt|;
for|for
control|(
name|qid
operator|=
literal|0
init|;
name|qid
operator|<
name|sc
operator|->
name|ntxqs
condition|;
name|qid
operator|++
control|)
block|{
name|struct
name|iwn_tx_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|txq
index|[
name|qid
index|]
decl_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_HBUS_TARG_WRPTR
argument_list|,
name|qid
operator|<<
literal|8
operator||
name|ring
operator|->
name|cur
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_rftoggle_task
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|uint32_t
name|tmp
decl_stmt|;
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_GP_CNTRL
argument_list|)
expr_stmt|;
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"RF switch: radio %s\n"
argument_list|,
operator|(
name|tmp
operator|&
name|IWN_GP_CNTRL_RFKILL
operator|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tmp
operator|&
name|IWN_GP_CNTRL_RFKILL
operator|)
condition|)
block|{
name|ieee80211_suspend_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* Enable interrupts to get RF toggle notification. */
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_INT
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_INT_MASK
argument_list|,
name|sc
operator|->
name|int_mask
argument_list|)
expr_stmt|;
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
name|ieee80211_resume_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dump the error log of the firmware when a firmware panic occurs.  Although  * we can't debug the firmware because it is neither open source nor free, it  * can help us to identify certain classes of problems.  */
end_comment

begin_function
specifier|static
name|void
name|iwn_fatal_intr
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwn_fw_dump
name|dump
decl_stmt|;
name|int
name|i
decl_stmt|;
name|IWN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Force a complete recalibration on next init. */
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|IWN_FLAG_CALIB_DONE
expr_stmt|;
comment|/* Check that the error log address is valid. */
if|if
condition|(
name|sc
operator|->
name|errptr
operator|<
name|IWN_FW_DATA_BASE
operator|||
name|sc
operator|->
name|errptr
operator|+
sizeof|sizeof
argument_list|(
name|dump
argument_list|)
operator|>
name|IWN_FW_DATA_BASE
operator|+
name|sc
operator|->
name|fw_data_maxsz
condition|)
block|{
name|printf
argument_list|(
literal|"%s: bad firmware error log address 0x%08x\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|errptr
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|iwn_nic_lock
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: could not read firmware error log\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Read firmware error log from SRAM. */
name|iwn_mem_read_region_4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|errptr
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|dump
argument_list|,
sizeof|sizeof
argument_list|(
name|dump
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|iwn_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump
operator|.
name|valid
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: firmware error log is empty\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"firmware error log:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  error type      = \"%s\" (0x%08X)\n"
argument_list|,
operator|(
name|dump
operator|.
name|id
operator|<
name|nitems
argument_list|(
name|iwn_fw_errmsg
argument_list|)
operator|)
condition|?
name|iwn_fw_errmsg
index|[
name|dump
operator|.
name|id
index|]
else|:
literal|"UNKNOWN"
argument_list|,
name|dump
operator|.
name|id
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  program counter = 0x%08X\n"
argument_list|,
name|dump
operator|.
name|pc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  source line     = 0x%08X\n"
argument_list|,
name|dump
operator|.
name|src_line
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  error data      = 0x%08X%08X\n"
argument_list|,
name|dump
operator|.
name|error_data
index|[
literal|0
index|]
argument_list|,
name|dump
operator|.
name|error_data
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  branch link     = 0x%08X%08X\n"
argument_list|,
name|dump
operator|.
name|branch_link
index|[
literal|0
index|]
argument_list|,
name|dump
operator|.
name|branch_link
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  interrupt link  = 0x%08X%08X\n"
argument_list|,
name|dump
operator|.
name|interrupt_link
index|[
literal|0
index|]
argument_list|,
name|dump
operator|.
name|interrupt_link
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  time            = %u\n"
argument_list|,
name|dump
operator|.
name|time
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Dump driver status (TX and RX rings) while we're here. */
name|printf
argument_list|(
literal|"driver status:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|ntxqs
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|iwn_tx_ring
modifier|*
name|ring
init|=
operator|&
name|sc
operator|->
name|txq
index|[
name|i
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"  tx ring %2d: qid=%-2d cur=%-3d queued=%-3d\n"
argument_list|,
name|i
argument_list|,
name|ring
operator|->
name|qid
argument_list|,
name|ring
operator|->
name|cur
argument_list|,
name|ring
operator|->
name|queued
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  rx ring: cur=%d\n"
argument_list|,
name|sc
operator|->
name|rxq
operator|.
name|cur
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|uint32_t
name|r1
decl_stmt|,
name|r2
decl_stmt|,
name|tmp
decl_stmt|;
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Disable interrupts. */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_INT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Read interrupts from ICT (fast) or from registers (slow). */
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWN_FLAG_USE_ICT
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|ict_dma
operator|.
name|tag
argument_list|,
name|sc
operator|->
name|ict_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|tmp
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|ict
index|[
name|sc
operator|->
name|ict_cur
index|]
operator|!=
literal|0
condition|)
block|{
name|tmp
operator||=
name|sc
operator|->
name|ict
index|[
name|sc
operator|->
name|ict_cur
index|]
expr_stmt|;
name|sc
operator|->
name|ict
index|[
name|sc
operator|->
name|ict_cur
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Acknowledge. */
name|sc
operator|->
name|ict_cur
operator|=
operator|(
name|sc
operator|->
name|ict_cur
operator|+
literal|1
operator|)
operator|%
name|IWN_ICT_COUNT
expr_stmt|;
block|}
name|tmp
operator|=
name|le32toh
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|0xffffffff
condition|)
comment|/* Shouldn't happen. */
name|tmp
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|tmp
operator|&
literal|0xc0000
condition|)
comment|/* Workaround a HW bug. */
name|tmp
operator||=
literal|0x8000
expr_stmt|;
name|r1
operator|=
operator|(
name|tmp
operator|&
literal|0xff00
operator|)
operator|<<
literal|16
operator||
operator|(
name|tmp
operator|&
literal|0xff
operator|)
expr_stmt|;
name|r2
operator|=
literal|0
expr_stmt|;
comment|/* Unused. */
block|}
else|else
block|{
name|r1
operator|=
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_INT
argument_list|)
expr_stmt|;
if|if
condition|(
name|r1
operator|==
literal|0xffffffff
operator|||
operator|(
name|r1
operator|&
literal|0xfffffff0
operator|)
operator|==
literal|0xa5a5a5a0
condition|)
block|{
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
comment|/* Hardware gone! */
block|}
name|r2
operator|=
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_FH_INT
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_INTR
argument_list|,
literal|"interrupt reg1=0x%08x reg2=0x%08x\n"
argument_list|,
name|r1
argument_list|,
name|r2
argument_list|)
expr_stmt|;
if|if
condition|(
name|r1
operator|==
literal|0
operator|&&
name|r2
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* Interrupt not for us. */
comment|/* Acknowledge interrupts. */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_INT
argument_list|,
name|r1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWN_FLAG_USE_ICT
operator|)
condition|)
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_INT
argument_list|,
name|r2
argument_list|)
expr_stmt|;
if|if
condition|(
name|r1
operator|&
name|IWN_INT_RF_TOGGLED
condition|)
block|{
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_rftoggle_task
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|r1
operator|&
name|IWN_INT_CT_REACHED
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: critical temperature reached!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r1
operator|&
operator|(
name|IWN_INT_SW_ERR
operator||
name|IWN_INT_HW_ERR
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: fatal firmware error\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IWN_DEBUG
name|iwn_debug_register
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Dump firmware error log and stop. */
name|iwn_fatal_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_panic_task
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|(
name|r1
operator|&
operator|(
name|IWN_INT_FH_RX
operator||
name|IWN_INT_SW_RX
operator||
name|IWN_INT_RX_PERIODIC
operator|)
operator|)
operator|||
operator|(
name|r2
operator|&
name|IWN_FH_INT_RX
operator|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWN_FLAG_USE_ICT
condition|)
block|{
if|if
condition|(
name|r1
operator|&
operator|(
name|IWN_INT_FH_RX
operator||
name|IWN_INT_SW_RX
operator|)
condition|)
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_INT
argument_list|,
name|IWN_FH_INT_RX
argument_list|)
expr_stmt|;
name|IWN_WRITE_1
argument_list|(
name|sc
argument_list|,
name|IWN_INT_PERIODIC
argument_list|,
name|IWN_INT_PERIODIC_DIS
argument_list|)
expr_stmt|;
name|iwn_notif_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|r1
operator|&
operator|(
name|IWN_INT_FH_RX
operator||
name|IWN_INT_SW_RX
operator|)
condition|)
block|{
name|IWN_WRITE_1
argument_list|(
name|sc
argument_list|,
name|IWN_INT_PERIODIC
argument_list|,
name|IWN_INT_PERIODIC_ENA
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|iwn_notif_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|r1
operator|&
name|IWN_INT_FH_TX
operator|)
operator|||
operator|(
name|r2
operator|&
name|IWN_FH_INT_TX
operator|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWN_FLAG_USE_ICT
condition|)
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_INT
argument_list|,
name|IWN_FH_INT_TX
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* FH DMA transfer completed. */
block|}
if|if
condition|(
name|r1
operator|&
name|IWN_INT_ALIVE
condition|)
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Firmware is alive. */
if|if
condition|(
name|r1
operator|&
name|IWN_INT_WAKEUP
condition|)
name|iwn_wakeup_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|done
label|:
comment|/* Re-enable interrupts. */
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWN_FLAG_RUNNING
condition|)
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_INT_MASK
argument_list|,
name|sc
operator|->
name|int_mask
argument_list|)
expr_stmt|;
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update TX scheduler ring when transmitting an 802.11 frame (4965AGN and  * 5000 adapters use a slightly different format).  */
end_comment

begin_function
specifier|static
name|void
name|iwn4965_update_sched
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qid
parameter_list|,
name|int
name|idx
parameter_list|,
name|uint8_t
name|id
parameter_list|,
name|uint16_t
name|len
parameter_list|)
block|{
name|uint16_t
modifier|*
name|w
init|=
operator|&
name|sc
operator|->
name|sched
index|[
name|qid
operator|*
name|IWN4965_SCHED_COUNT
operator|+
name|idx
index|]
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->Doing %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
operator|*
name|w
operator|=
name|htole16
argument_list|(
name|len
operator|+
literal|8
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sched_dma
operator|.
name|tag
argument_list|,
name|sc
operator|->
name|sched_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|<
name|IWN_SCHED_WINSZ
condition|)
block|{
operator|*
operator|(
name|w
operator|+
name|IWN_TX_RING_COUNT
operator|)
operator|=
operator|*
name|w
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sched_dma
operator|.
name|tag
argument_list|,
name|sc
operator|->
name|sched_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|iwn5000_update_sched
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qid
parameter_list|,
name|int
name|idx
parameter_list|,
name|uint8_t
name|id
parameter_list|,
name|uint16_t
name|len
parameter_list|)
block|{
name|uint16_t
modifier|*
name|w
init|=
operator|&
name|sc
operator|->
name|sched
index|[
name|qid
operator|*
name|IWN5000_SCHED_COUNT
operator|+
name|idx
index|]
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->Doing %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
operator|*
name|w
operator|=
name|htole16
argument_list|(
name|id
operator|<<
literal|12
operator||
operator|(
name|len
operator|+
literal|8
operator|)
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sched_dma
operator|.
name|tag
argument_list|,
name|sc
operator|->
name|sched_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|<
name|IWN_SCHED_WINSZ
condition|)
block|{
operator|*
operator|(
name|w
operator|+
name|IWN_TX_RING_COUNT
operator|)
operator|=
operator|*
name|w
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sched_dma
operator|.
name|tag
argument_list|,
name|sc
operator|->
name|sched_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_function
specifier|static
name|void
name|iwn5000_reset_sched
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qid
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|uint16_t
modifier|*
name|w
init|=
operator|&
name|sc
operator|->
name|sched
index|[
name|qid
operator|*
name|IWN5000_SCHED_COUNT
operator|+
name|idx
index|]
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->Doing %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
operator|*
name|w
operator|=
operator|(
operator|*
name|w
operator|&
name|htole16
argument_list|(
literal|0xf000
argument_list|)
operator|)
operator||
name|htole16
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sched_dma
operator|.
name|tag
argument_list|,
name|sc
operator|->
name|sched_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|<
name|IWN_SCHED_WINSZ
condition|)
block|{
operator|*
operator|(
name|w
operator|+
name|IWN_TX_RING_COUNT
operator|)
operator|=
operator|*
name|w
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sched_dma
operator|.
name|tag
argument_list|,
name|sc
operator|->
name|sched_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Check whether OFDM 11g protection will be enabled for the given rate.  *  * The original driver code only enabled protection for OFDM rates.  * It didn't check to see whether it was operating in 11a or 11bg mode.  */
end_comment

begin_function
specifier|static
name|int
name|iwn_check_rate_needs_protection
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|uint8_t
name|rate
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
comment|/* 	 * Not in 2GHz mode? Then there's no need to enable OFDM 	 * 11bg protection. 	 */
if|if
condition|(
operator|!
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * 11bg protection not enabled? Then don't use it. 	 */
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_USEPROT
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * If it's an 11n rate - no protection. 	 * We'll do it via a specific 11n check. 	 */
if|if
condition|(
name|rate
operator|&
name|IEEE80211_RATE_MCS
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Do a rate table lookup.  If the PHY is CCK, 	 * don't do protection. 	 */
if|if
condition|(
name|ieee80211_rate2phytype
argument_list|(
name|ic
operator|->
name|ic_rt
argument_list|,
name|rate
argument_list|)
operator|==
name|IEEE80211_T_CCK
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Yup, enable protection. 	 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * return a value between 0 and IWN_MAX_TX_RETRIES-1 as an index into  * the link quality table that reflects this particular entry.  */
end_comment

begin_function
specifier|static
name|int
name|iwn_tx_rate_to_linkq_offset
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|uint8_t
name|rate
parameter_list|)
block|{
name|struct
name|ieee80211_rateset
modifier|*
name|rs
decl_stmt|;
name|int
name|is_11n
decl_stmt|;
name|int
name|nr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint8_t
name|cmp_rate
decl_stmt|;
comment|/* 	 * Figure out if we're using 11n or not here. 	 */
if|if
condition|(
name|IEEE80211_IS_CHAN_HT
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
operator|&&
name|ni
operator|->
name|ni_htrates
operator|.
name|rs_nrates
operator|>
literal|0
condition|)
name|is_11n
operator|=
literal|1
expr_stmt|;
else|else
name|is_11n
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Use the correct rate table. 	 */
if|if
condition|(
name|is_11n
condition|)
block|{
name|rs
operator|=
operator|(
expr|struct
name|ieee80211_rateset
operator|*
operator|)
operator|&
name|ni
operator|->
name|ni_htrates
expr_stmt|;
name|nr
operator|=
name|ni
operator|->
name|ni_htrates
operator|.
name|rs_nrates
expr_stmt|;
block|}
else|else
block|{
name|rs
operator|=
operator|&
name|ni
operator|->
name|ni_rates
expr_stmt|;
name|nr
operator|=
name|rs
operator|->
name|rs_nrates
expr_stmt|;
block|}
comment|/* 	 * Find the relevant link quality entry in the table. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr
operator|&&
name|i
operator|<
name|IWN_MAX_TX_RETRIES
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * The link quality table index starts at 0 == highest 		 * rate, so we walk the rate table backwards. 		 */
name|cmp_rate
operator|=
name|rs
operator|->
name|rs_rates
index|[
operator|(
name|nr
operator|-
literal|1
operator|)
operator|-
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rate
operator|&
name|IEEE80211_RATE_MCS
condition|)
name|cmp_rate
operator||=
name|IEEE80211_RATE_MCS
expr_stmt|;
if|#
directive|if
literal|0
block|DPRINTF(sc, IWN_DEBUG_XMIT, "%s: idx %d: nr=%d, rate=0x%02x, rateentry=0x%02x\n", 		    __func__, 		    i, 		    nr, 		    rate, 		    cmp_rate);
endif|#
directive|endif
if|if
condition|(
name|cmp_rate
operator|==
name|rate
condition|)
return|return
operator|(
name|i
operator|)
return|;
block|}
comment|/* Failed? Start at the end */
return|return
operator|(
name|IWN_MAX_TX_RETRIES
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_tx_data
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|iwn_ops
modifier|*
name|ops
init|=
operator|&
name|sc
operator|->
name|ops
decl_stmt|;
specifier|const
name|struct
name|ieee80211_txparam
modifier|*
name|tp
init|=
name|ni
operator|->
name|ni_txparms
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|iwn_node
modifier|*
name|wn
init|=
operator|(
name|void
operator|*
operator|)
name|ni
decl_stmt|;
name|struct
name|iwn_tx_ring
modifier|*
name|ring
decl_stmt|;
name|struct
name|iwn_tx_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|iwn_tx_data
modifier|*
name|data
decl_stmt|;
name|struct
name|iwn_tx_cmd
modifier|*
name|cmd
decl_stmt|;
name|struct
name|iwn_cmd_data
modifier|*
name|tx
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|struct
name|ieee80211_key
modifier|*
name|k
init|=
name|NULL
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m1
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|uint16_t
name|qos
decl_stmt|;
name|u_int
name|hdrlen
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|seg
decl_stmt|,
name|segs
index|[
name|IWN_MAX_SCATTER
index|]
decl_stmt|;
name|uint8_t
name|tid
decl_stmt|,
name|type
decl_stmt|;
name|int
name|ac
decl_stmt|,
name|i
decl_stmt|,
name|totlen
decl_stmt|,
name|error
decl_stmt|,
name|pad
decl_stmt|,
name|nsegs
init|=
literal|0
decl_stmt|,
name|rate
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s begin\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|IWN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|hdrlen
operator|=
name|ieee80211_anyhdrsize
argument_list|(
name|wh
argument_list|)
expr_stmt|;
name|type
operator|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
expr_stmt|;
comment|/* Select EDCA Access Category and TX ring for this frame. */
if|if
condition|(
name|IEEE80211_QOS_HAS_SEQ
argument_list|(
name|wh
argument_list|)
condition|)
block|{
name|qos
operator|=
operator|(
operator|(
specifier|const
expr|struct
name|ieee80211_qosframe
operator|*
operator|)
name|wh
operator|)
operator|->
name|i_qos
index|[
literal|0
index|]
expr_stmt|;
name|tid
operator|=
name|qos
operator|&
name|IEEE80211_QOS_TID
expr_stmt|;
block|}
else|else
block|{
name|qos
operator|=
literal|0
expr_stmt|;
name|tid
operator|=
literal|0
expr_stmt|;
block|}
name|ac
operator|=
name|M_WME_GETAC
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * XXX TODO: Group addressed frames aren't aggregated and must 	 * go to the normal non-aggregation queue, and have a NONQOS TID 	 * assigned from net80211. 	 */
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_AMPDU_MPDU
condition|)
block|{
name|uint16_t
name|seqno
decl_stmt|;
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
init|=
operator|&
name|ni
operator|->
name|ni_tx_ampdu
index|[
name|ac
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|IEEE80211_AMPDU_RUNNING
argument_list|(
name|tap
argument_list|)
condition|)
block|{
return|return
name|EINVAL
return|;
block|}
comment|/* 		 * Queue this frame to the hardware ring that we've 		 * negotiated AMPDU TX on. 		 * 		 * Note that the sequence number must match the TX slot 		 * being used! 		 */
name|ac
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|tap
operator|->
name|txa_private
expr_stmt|;
name|seqno
operator|=
name|ni
operator|->
name|ni_txseqs
index|[
name|tid
index|]
expr_stmt|;
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|wh
operator|->
name|i_seq
operator|=
name|htole16
argument_list|(
name|seqno
operator|<<
name|IEEE80211_SEQ_SEQ_SHIFT
argument_list|)
expr_stmt|;
name|ring
operator|=
operator|&
name|sc
operator|->
name|txq
index|[
name|ac
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|seqno
operator|%
literal|256
operator|)
operator|!=
name|ring
operator|->
name|cur
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: m=%p: seqno (%d) (%d) != ring index (%d) !\n"
argument_list|,
name|__func__
argument_list|,
name|m
argument_list|,
name|seqno
argument_list|,
name|seqno
operator|%
literal|256
argument_list|,
name|ring
operator|->
name|cur
argument_list|)
expr_stmt|;
block|}
name|ni
operator|->
name|ni_txseqs
index|[
name|tid
index|]
operator|++
expr_stmt|;
block|}
name|ring
operator|=
operator|&
name|sc
operator|->
name|txq
index|[
name|ac
index|]
expr_stmt|;
name|desc
operator|=
operator|&
name|ring
operator|->
name|desc
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|data
operator|=
operator|&
name|ring
operator|->
name|data
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
comment|/* Choose a TX rate index. */
if|if
condition|(
name|type
operator|==
name|IEEE80211_FC0_TYPE_MGT
operator|||
name|type
operator|==
name|IEEE80211_FC0_TYPE_CTL
operator|||
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EAPOL
operator|)
operator|!=
literal|0
condition|)
name|rate
operator|=
name|tp
operator|->
name|mgmtrate
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
condition|)
name|rate
operator|=
name|tp
operator|->
name|mcastrate
expr_stmt|;
elseif|else
if|if
condition|(
name|tp
operator|->
name|ucastrate
operator|!=
name|IEEE80211_FIXED_RATE_NONE
condition|)
name|rate
operator|=
name|tp
operator|->
name|ucastrate
expr_stmt|;
else|else
block|{
comment|/* XXX pass pktlen */
operator|(
name|void
operator|)
name|ieee80211_ratectl_rate
argument_list|(
name|ni
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rate
operator|=
name|ni
operator|->
name|ni_txrate
expr_stmt|;
block|}
comment|/* Encrypt the frame if need be. */
if|if
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_PROTECTED
condition|)
block|{
comment|/* Retrieve key for TX. */
name|k
operator|=
name|ieee80211_crypto_encap
argument_list|(
name|ni
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|NULL
condition|)
block|{
return|return
name|ENOBUFS
return|;
block|}
comment|/* 802.11 header may have moved. */
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
block|}
name|totlen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|ieee80211_radiotap_active_vap
argument_list|(
name|vap
argument_list|)
condition|)
block|{
name|struct
name|iwn_tx_radiotap_header
modifier|*
name|tap
init|=
operator|&
name|sc
operator|->
name|sc_txtap
decl_stmt|;
name|tap
operator|->
name|wt_flags
operator|=
literal|0
expr_stmt|;
name|tap
operator|->
name|wt_rate
operator|=
name|rate
expr_stmt|;
if|if
condition|(
name|k
operator|!=
name|NULL
condition|)
name|tap
operator|->
name|wt_flags
operator||=
name|IEEE80211_RADIOTAP_F_WEP
expr_stmt|;
name|ieee80211_radiotap_tx
argument_list|(
name|vap
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* Prepare TX firmware command. */
name|cmd
operator|=
operator|&
name|ring
operator|->
name|cmd
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|cmd
operator|->
name|code
operator|=
name|IWN_CMD_TX_DATA
expr_stmt|;
name|cmd
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|qid
operator|=
name|ring
operator|->
name|qid
expr_stmt|;
name|cmd
operator|->
name|idx
operator|=
name|ring
operator|->
name|cur
expr_stmt|;
name|tx
operator|=
operator|(
expr|struct
name|iwn_cmd_data
operator|*
operator|)
name|cmd
operator|->
name|data
expr_stmt|;
comment|/* NB: No need to clear tx, all fields are reinitialized here. */
name|tx
operator|->
name|scratch
operator|=
literal|0
expr_stmt|;
comment|/* clear "scratch" area */
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
condition|)
block|{
comment|/* Unicast frame, check if an ACK is expected. */
if|if
condition|(
operator|!
name|qos
operator|||
operator|(
name|qos
operator|&
name|IEEE80211_QOS_ACKPOLICY
operator|)
operator|!=
name|IEEE80211_QOS_ACKPOLICY_NOACK
condition|)
name|flags
operator||=
name|IWN_TX_NEED_ACK
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
operator|(
name|IEEE80211_FC0_TYPE_MASK
operator||
name|IEEE80211_FC0_SUBTYPE_MASK
operator|)
operator|)
operator|==
operator|(
name|IEEE80211_FC0_TYPE_CTL
operator||
name|IEEE80211_FC0_SUBTYPE_BAR
operator|)
condition|)
name|flags
operator||=
name|IWN_TX_IMM_BA
expr_stmt|;
comment|/* Cannot happen yet. */
if|if
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_MORE_FRAG
condition|)
name|flags
operator||=
name|IWN_TX_MORE_FRAG
expr_stmt|;
comment|/* Cannot happen yet. */
comment|/* Check if frame must be protected using RTS/CTS or CTS-to-self. */
if|if
condition|(
operator|!
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
condition|)
block|{
comment|/* NB: Group frames are sent using CCK in 802.11b/g. */
if|if
condition|(
name|totlen
operator|+
name|IEEE80211_CRC_LEN
operator|>
name|vap
operator|->
name|iv_rtsthreshold
condition|)
block|{
name|flags
operator||=
name|IWN_TX_NEED_RTS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iwn_check_rate_needs_protection
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|,
name|rate
argument_list|)
condition|)
block|{
if|if
condition|(
name|ic
operator|->
name|ic_protmode
operator|==
name|IEEE80211_PROT_CTSONLY
condition|)
name|flags
operator||=
name|IWN_TX_NEED_CTS
expr_stmt|;
elseif|else
if|if
condition|(
name|ic
operator|->
name|ic_protmode
operator|==
name|IEEE80211_PROT_RTSCTS
condition|)
name|flags
operator||=
name|IWN_TX_NEED_RTS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|rate
operator|&
name|IEEE80211_RATE_MCS
operator|)
operator|&&
operator|(
name|ic
operator|->
name|ic_htprotmode
operator|==
name|IEEE80211_PROT_RTSCTS
operator|)
condition|)
block|{
name|flags
operator||=
name|IWN_TX_NEED_RTS
expr_stmt|;
block|}
comment|/* XXX HT protection? */
if|if
condition|(
name|flags
operator|&
operator|(
name|IWN_TX_NEED_RTS
operator||
name|IWN_TX_NEED_CTS
operator|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|hw_type
operator|!=
name|IWN_HW_REV_TYPE_4965
condition|)
block|{
comment|/* 5000 autoselects RTS/CTS or CTS-to-self. */
name|flags
operator|&=
operator|~
operator|(
name|IWN_TX_NEED_RTS
operator||
name|IWN_TX_NEED_CTS
operator|)
expr_stmt|;
name|flags
operator||=
name|IWN_TX_NEED_PROTECTION
expr_stmt|;
block|}
else|else
name|flags
operator||=
name|IWN_TX_FULL_TXOP
expr_stmt|;
block|}
block|}
if|if
condition|(
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
operator|||
name|type
operator|!=
name|IEEE80211_FC0_TYPE_DATA
condition|)
name|tx
operator|->
name|id
operator|=
name|sc
operator|->
name|broadcast_id
expr_stmt|;
else|else
name|tx
operator|->
name|id
operator|=
name|wn
operator|->
name|id
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|IEEE80211_FC0_TYPE_MGT
condition|)
block|{
name|uint8_t
name|subtype
init|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
decl_stmt|;
comment|/* Tell HW to set timestamp in probe responses. */
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_PROBE_RESP
condition|)
name|flags
operator||=
name|IWN_TX_INSERT_TSTAMP
expr_stmt|;
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_ASSOC_REQ
operator|||
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_REASSOC_REQ
condition|)
name|tx
operator|->
name|timeout
operator|=
name|htole16
argument_list|(
literal|3
argument_list|)
expr_stmt|;
else|else
name|tx
operator|->
name|timeout
operator|=
name|htole16
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
name|tx
operator|->
name|timeout
operator|=
name|htole16
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdrlen
operator|&
literal|3
condition|)
block|{
comment|/* First segment length must be a multiple of 4. */
name|flags
operator||=
name|IWN_TX_NEED_PADDING
expr_stmt|;
name|pad
operator|=
literal|4
operator|-
operator|(
name|hdrlen
operator|&
literal|3
operator|)
expr_stmt|;
block|}
else|else
name|pad
operator|=
literal|0
expr_stmt|;
name|tx
operator|->
name|len
operator|=
name|htole16
argument_list|(
name|totlen
argument_list|)
expr_stmt|;
name|tx
operator|->
name|tid
operator|=
name|tid
expr_stmt|;
name|tx
operator|->
name|rts_ntries
operator|=
literal|60
expr_stmt|;
name|tx
operator|->
name|data_ntries
operator|=
literal|15
expr_stmt|;
name|tx
operator|->
name|lifetime
operator|=
name|htole32
argument_list|(
name|IWN_LIFETIME_INFINITE
argument_list|)
expr_stmt|;
name|tx
operator|->
name|rate
operator|=
name|iwn_rate_to_plcp
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|rate
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx
operator|->
name|id
operator|==
name|sc
operator|->
name|broadcast_id
condition|)
block|{
comment|/* Group or management frame. */
name|tx
operator|->
name|linkq
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|tx
operator|->
name|linkq
operator|=
name|iwn_tx_rate_to_linkq_offset
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|rate
argument_list|)
expr_stmt|;
name|flags
operator||=
name|IWN_TX_LINKQ
expr_stmt|;
comment|/* enable MRR */
block|}
comment|/* Set physical address of "scratch area". */
name|tx
operator|->
name|loaddr
operator|=
name|htole32
argument_list|(
name|IWN_LOADDR
argument_list|(
name|data
operator|->
name|scratch_paddr
argument_list|)
argument_list|)
expr_stmt|;
name|tx
operator|->
name|hiaddr
operator|=
name|IWN_HIADDR
argument_list|(
name|data
operator|->
name|scratch_paddr
argument_list|)
expr_stmt|;
comment|/* Copy 802.11 header in TX command. */
name|memcpy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|tx
operator|+
literal|1
operator|)
argument_list|,
name|wh
argument_list|,
name|hdrlen
argument_list|)
expr_stmt|;
comment|/* Trim 802.11 header. */
name|m_adj
argument_list|(
name|m
argument_list|,
name|hdrlen
argument_list|)
expr_stmt|;
name|tx
operator|->
name|security
operator|=
literal|0
expr_stmt|;
name|tx
operator|->
name|flags
operator|=
name|htole32
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|m
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|!=
name|EFBIG
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: can't map mbuf (error %d)\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Too many DMA segments, linearize mbuf. */
name|m1
operator|=
name|m_collapse
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|,
name|IWN_MAX_SCATTER
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|m1
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not defrag mbuf\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|m
operator|=
name|m1
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|m
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: can't map mbuf (error %d)\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
name|data
operator|->
name|m
operator|=
name|m
expr_stmt|;
name|data
operator|->
name|ni
operator|=
name|ni
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_XMIT
argument_list|,
literal|"%s: qid %d idx %d len %d nsegs %d flags 0x%08x rate 0x%04x plcp 0x%08x\n"
argument_list|,
name|__func__
argument_list|,
name|ring
operator|->
name|qid
argument_list|,
name|ring
operator|->
name|cur
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|nsegs
argument_list|,
name|flags
argument_list|,
name|rate
argument_list|,
name|tx
operator|->
name|rate
argument_list|)
expr_stmt|;
comment|/* Fill TX descriptor. */
name|desc
operator|->
name|nsegs
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|!=
literal|0
condition|)
name|desc
operator|->
name|nsegs
operator|+=
name|nsegs
expr_stmt|;
comment|/* First DMA segment is used by the TX command. */
name|desc
operator|->
name|segs
index|[
literal|0
index|]
operator|.
name|addr
operator|=
name|htole32
argument_list|(
name|IWN_LOADDR
argument_list|(
name|data
operator|->
name|cmd_paddr
argument_list|)
argument_list|)
expr_stmt|;
name|desc
operator|->
name|segs
index|[
literal|0
index|]
operator|.
name|len
operator|=
name|htole16
argument_list|(
name|IWN_HIADDR
argument_list|(
name|data
operator|->
name|cmd_paddr
argument_list|)
operator||
operator|(
literal|4
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|tx
argument_list|)
operator|+
name|hdrlen
operator|+
name|pad
operator|)
operator|<<
literal|4
argument_list|)
expr_stmt|;
comment|/* Other DMA segments are for data payload. */
name|seg
operator|=
operator|&
name|segs
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
name|desc
operator|->
name|segs
index|[
name|i
index|]
operator|.
name|addr
operator|=
name|htole32
argument_list|(
name|IWN_LOADDR
argument_list|(
name|seg
operator|->
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|desc
operator|->
name|segs
index|[
name|i
index|]
operator|.
name|len
operator|=
name|htole16
argument_list|(
name|IWN_HIADDR
argument_list|(
name|seg
operator|->
name|ds_addr
argument_list|)
operator||
name|seg
operator|->
name|ds_len
operator|<<
literal|4
argument_list|)
expr_stmt|;
name|seg
operator|++
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|cmd_dma
operator|.
name|tag
argument_list|,
name|ring
operator|->
name|cmd_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|desc_dma
operator|.
name|tag
argument_list|,
name|ring
operator|->
name|desc_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Update TX scheduler. */
if|if
condition|(
name|ring
operator|->
name|qid
operator|>=
name|sc
operator|->
name|firstaggqueue
condition|)
name|ops
operator|->
name|update_sched
argument_list|(
name|sc
argument_list|,
name|ring
operator|->
name|qid
argument_list|,
name|ring
operator|->
name|cur
argument_list|,
name|tx
operator|->
name|id
argument_list|,
name|totlen
argument_list|)
expr_stmt|;
comment|/* Kick TX ring. */
name|ring
operator|->
name|cur
operator|=
operator|(
name|ring
operator|->
name|cur
operator|+
literal|1
operator|)
operator|%
name|IWN_TX_RING_COUNT
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_HBUS_TARG_WRPTR
argument_list|,
name|ring
operator|->
name|qid
operator|<<
literal|8
operator||
name|ring
operator|->
name|cur
argument_list|)
expr_stmt|;
comment|/* Mark TX ring as full if we reach a certain threshold. */
if|if
condition|(
operator|++
name|ring
operator|->
name|queued
operator|>
name|IWN_TX_RING_HIMARK
condition|)
name|sc
operator|->
name|qfullmsk
operator||=
literal|1
operator|<<
name|ring
operator|->
name|qid
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s: end\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_tx_data_raw
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|iwn_ops
modifier|*
name|ops
init|=
operator|&
name|sc
operator|->
name|ops
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|iwn_tx_cmd
modifier|*
name|cmd
decl_stmt|;
name|struct
name|iwn_cmd_data
modifier|*
name|tx
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|struct
name|iwn_tx_ring
modifier|*
name|ring
decl_stmt|;
name|struct
name|iwn_tx_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|iwn_tx_data
modifier|*
name|data
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m1
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|seg
decl_stmt|,
name|segs
index|[
name|IWN_MAX_SCATTER
index|]
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|u_int
name|hdrlen
decl_stmt|;
name|int
name|ac
decl_stmt|,
name|totlen
decl_stmt|,
name|error
decl_stmt|,
name|pad
decl_stmt|,
name|nsegs
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|rate
decl_stmt|;
name|uint8_t
name|type
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s begin\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|IWN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|hdrlen
operator|=
name|ieee80211_anyhdrsize
argument_list|(
name|wh
argument_list|)
expr_stmt|;
name|type
operator|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
expr_stmt|;
name|ac
operator|=
name|params
operator|->
name|ibp_pri
operator|&
literal|3
expr_stmt|;
name|ring
operator|=
operator|&
name|sc
operator|->
name|txq
index|[
name|ac
index|]
expr_stmt|;
name|desc
operator|=
operator|&
name|ring
operator|->
name|desc
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|data
operator|=
operator|&
name|ring
operator|->
name|data
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
comment|/* Choose a TX rate. */
name|rate
operator|=
name|params
operator|->
name|ibp_rate0
expr_stmt|;
name|totlen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* Prepare TX firmware command. */
name|cmd
operator|=
operator|&
name|ring
operator|->
name|cmd
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|cmd
operator|->
name|code
operator|=
name|IWN_CMD_TX_DATA
expr_stmt|;
name|cmd
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|qid
operator|=
name|ring
operator|->
name|qid
expr_stmt|;
name|cmd
operator|->
name|idx
operator|=
name|ring
operator|->
name|cur
expr_stmt|;
name|tx
operator|=
operator|(
expr|struct
name|iwn_cmd_data
operator|*
operator|)
name|cmd
operator|->
name|data
expr_stmt|;
comment|/* NB: No need to clear tx, all fields are reinitialized here. */
name|tx
operator|->
name|scratch
operator|=
literal|0
expr_stmt|;
comment|/* clear "scratch" area */
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_NOACK
operator|)
operator|==
literal|0
condition|)
name|flags
operator||=
name|IWN_TX_NEED_ACK
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_RTS
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|hw_type
operator|!=
name|IWN_HW_REV_TYPE_4965
condition|)
block|{
comment|/* 5000 autoselects RTS/CTS or CTS-to-self. */
name|flags
operator|&=
operator|~
name|IWN_TX_NEED_RTS
expr_stmt|;
name|flags
operator||=
name|IWN_TX_NEED_PROTECTION
expr_stmt|;
block|}
else|else
name|flags
operator||=
name|IWN_TX_NEED_RTS
operator||
name|IWN_TX_FULL_TXOP
expr_stmt|;
block|}
if|if
condition|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_CTS
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|hw_type
operator|!=
name|IWN_HW_REV_TYPE_4965
condition|)
block|{
comment|/* 5000 autoselects RTS/CTS or CTS-to-self. */
name|flags
operator|&=
operator|~
name|IWN_TX_NEED_CTS
expr_stmt|;
name|flags
operator||=
name|IWN_TX_NEED_PROTECTION
expr_stmt|;
block|}
else|else
name|flags
operator||=
name|IWN_TX_NEED_CTS
operator||
name|IWN_TX_FULL_TXOP
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|IEEE80211_FC0_TYPE_MGT
condition|)
block|{
name|uint8_t
name|subtype
init|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
decl_stmt|;
comment|/* Tell HW to set timestamp in probe responses. */
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_PROBE_RESP
condition|)
name|flags
operator||=
name|IWN_TX_INSERT_TSTAMP
expr_stmt|;
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_ASSOC_REQ
operator|||
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_REASSOC_REQ
condition|)
name|tx
operator|->
name|timeout
operator|=
name|htole16
argument_list|(
literal|3
argument_list|)
expr_stmt|;
else|else
name|tx
operator|->
name|timeout
operator|=
name|htole16
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
name|tx
operator|->
name|timeout
operator|=
name|htole16
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdrlen
operator|&
literal|3
condition|)
block|{
comment|/* First segment length must be a multiple of 4. */
name|flags
operator||=
name|IWN_TX_NEED_PADDING
expr_stmt|;
name|pad
operator|=
literal|4
operator|-
operator|(
name|hdrlen
operator|&
literal|3
operator|)
expr_stmt|;
block|}
else|else
name|pad
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ieee80211_radiotap_active_vap
argument_list|(
name|vap
argument_list|)
condition|)
block|{
name|struct
name|iwn_tx_radiotap_header
modifier|*
name|tap
init|=
operator|&
name|sc
operator|->
name|sc_txtap
decl_stmt|;
name|tap
operator|->
name|wt_flags
operator|=
literal|0
expr_stmt|;
name|tap
operator|->
name|wt_rate
operator|=
name|rate
expr_stmt|;
name|ieee80211_radiotap_tx
argument_list|(
name|vap
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|tx
operator|->
name|len
operator|=
name|htole16
argument_list|(
name|totlen
argument_list|)
expr_stmt|;
name|tx
operator|->
name|tid
operator|=
literal|0
expr_stmt|;
name|tx
operator|->
name|id
operator|=
name|sc
operator|->
name|broadcast_id
expr_stmt|;
name|tx
operator|->
name|rts_ntries
operator|=
name|params
operator|->
name|ibp_try1
expr_stmt|;
name|tx
operator|->
name|data_ntries
operator|=
name|params
operator|->
name|ibp_try0
expr_stmt|;
name|tx
operator|->
name|lifetime
operator|=
name|htole32
argument_list|(
name|IWN_LIFETIME_INFINITE
argument_list|)
expr_stmt|;
name|tx
operator|->
name|rate
operator|=
name|iwn_rate_to_plcp
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|rate
argument_list|)
expr_stmt|;
comment|/* Group or management frame. */
name|tx
operator|->
name|linkq
operator|=
literal|0
expr_stmt|;
comment|/* Set physical address of "scratch area". */
name|tx
operator|->
name|loaddr
operator|=
name|htole32
argument_list|(
name|IWN_LOADDR
argument_list|(
name|data
operator|->
name|scratch_paddr
argument_list|)
argument_list|)
expr_stmt|;
name|tx
operator|->
name|hiaddr
operator|=
name|IWN_HIADDR
argument_list|(
name|data
operator|->
name|scratch_paddr
argument_list|)
expr_stmt|;
comment|/* Copy 802.11 header in TX command. */
name|memcpy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|tx
operator|+
literal|1
operator|)
argument_list|,
name|wh
argument_list|,
name|hdrlen
argument_list|)
expr_stmt|;
comment|/* Trim 802.11 header. */
name|m_adj
argument_list|(
name|m
argument_list|,
name|hdrlen
argument_list|)
expr_stmt|;
name|tx
operator|->
name|security
operator|=
literal|0
expr_stmt|;
name|tx
operator|->
name|flags
operator|=
name|htole32
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|m
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|!=
name|EFBIG
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: can't map mbuf (error %d)\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Too many DMA segments, linearize mbuf. */
name|m1
operator|=
name|m_collapse
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|,
name|IWN_MAX_SCATTER
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|m1
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not defrag mbuf\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|m
operator|=
name|m1
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|m
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: can't map mbuf (error %d)\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
name|data
operator|->
name|m
operator|=
name|m
expr_stmt|;
name|data
operator|->
name|ni
operator|=
name|ni
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_XMIT
argument_list|,
literal|"%s: qid %d idx %d len %d nsegs %d\n"
argument_list|,
name|__func__
argument_list|,
name|ring
operator|->
name|qid
argument_list|,
name|ring
operator|->
name|cur
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
comment|/* Fill TX descriptor. */
name|desc
operator|->
name|nsegs
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|!=
literal|0
condition|)
name|desc
operator|->
name|nsegs
operator|+=
name|nsegs
expr_stmt|;
comment|/* First DMA segment is used by the TX command. */
name|desc
operator|->
name|segs
index|[
literal|0
index|]
operator|.
name|addr
operator|=
name|htole32
argument_list|(
name|IWN_LOADDR
argument_list|(
name|data
operator|->
name|cmd_paddr
argument_list|)
argument_list|)
expr_stmt|;
name|desc
operator|->
name|segs
index|[
literal|0
index|]
operator|.
name|len
operator|=
name|htole16
argument_list|(
name|IWN_HIADDR
argument_list|(
name|data
operator|->
name|cmd_paddr
argument_list|)
operator||
operator|(
literal|4
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|tx
argument_list|)
operator|+
name|hdrlen
operator|+
name|pad
operator|)
operator|<<
literal|4
argument_list|)
expr_stmt|;
comment|/* Other DMA segments are for data payload. */
name|seg
operator|=
operator|&
name|segs
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
name|desc
operator|->
name|segs
index|[
name|i
index|]
operator|.
name|addr
operator|=
name|htole32
argument_list|(
name|IWN_LOADDR
argument_list|(
name|seg
operator|->
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|desc
operator|->
name|segs
index|[
name|i
index|]
operator|.
name|len
operator|=
name|htole16
argument_list|(
name|IWN_HIADDR
argument_list|(
name|seg
operator|->
name|ds_addr
argument_list|)
operator||
name|seg
operator|->
name|ds_len
operator|<<
literal|4
argument_list|)
expr_stmt|;
name|seg
operator|++
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|cmd_dma
operator|.
name|tag
argument_list|,
name|ring
operator|->
name|cmd_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|desc_dma
operator|.
name|tag
argument_list|,
name|ring
operator|->
name|desc_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Update TX scheduler. */
if|if
condition|(
name|ring
operator|->
name|qid
operator|>=
name|sc
operator|->
name|firstaggqueue
condition|)
name|ops
operator|->
name|update_sched
argument_list|(
name|sc
argument_list|,
name|ring
operator|->
name|qid
argument_list|,
name|ring
operator|->
name|cur
argument_list|,
name|tx
operator|->
name|id
argument_list|,
name|totlen
argument_list|)
expr_stmt|;
comment|/* Kick TX ring. */
name|ring
operator|->
name|cur
operator|=
operator|(
name|ring
operator|->
name|cur
operator|+
literal|1
operator|)
operator|%
name|IWN_TX_RING_COUNT
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_HBUS_TARG_WRPTR
argument_list|,
name|ring
operator|->
name|qid
operator|<<
literal|8
operator||
name|ring
operator|->
name|cur
argument_list|)
expr_stmt|;
comment|/* Mark TX ring as full if we reach a certain threshold. */
if|if
condition|(
operator|++
name|ring
operator|->
name|queued
operator|>
name|IWN_TX_RING_HIMARK
condition|)
name|sc
operator|->
name|qfullmsk
operator||=
literal|1
operator|<<
name|ring
operator|->
name|qid
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s: end\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_xmit_task
parameter_list|(
name|void
modifier|*
name|arg0
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|arg0
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|ieee80211_bpf_params
name|p
decl_stmt|;
name|int
name|have_p
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_XMIT
argument_list|,
literal|"%s: called\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Dequeue frames, attempt to transmit, 	 * then disable beaconwait when we're done. 	 */
while|while
condition|(
operator|(
name|m
operator|=
name|mbufq_dequeue
argument_list|(
operator|&
name|sc
operator|->
name|sc_xmit_queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|have_p
operator|=
literal|0
expr_stmt|;
name|ni
operator|=
operator|(
expr|struct
name|ieee80211_node
operator|*
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
comment|/* Get xmit params if appropriate */
if|if
condition|(
name|ieee80211_get_xmit_params
argument_list|(
name|m
argument_list|,
operator|&
name|p
argument_list|)
operator|==
literal|0
condition|)
name|have_p
operator|=
literal|1
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_XMIT
argument_list|,
literal|"%s: m=%p, have_p=%d\n"
argument_list|,
name|__func__
argument_list|,
name|m
argument_list|,
name|have_p
argument_list|)
expr_stmt|;
comment|/* If we have xmit params, use them */
if|if
condition|(
name|have_p
condition|)
name|error
operator|=
name|iwn_tx_data_raw
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|ni
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|iwn_tx_data
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_inc_counter
argument_list|(
name|ni
operator|->
name|ni_vap
operator|->
name|iv_ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|sc_beacon_wait
operator|=
literal|0
expr_stmt|;
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * raw frame xmit - free node/reference if failed.  */
end_comment

begin_function
specifier|static
name|int
name|iwn_raw_xmit
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_XMIT
operator||
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s begin\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWN_FLAG_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
block|}
comment|/* queue frame if we have to */
if|if
condition|(
name|sc
operator|->
name|sc_beacon_wait
condition|)
block|{
if|if
condition|(
name|iwn_xmit_queue_enqueue
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/* Queued, so just return OK */
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|params
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Legacy path; interpret frame contents to decide 		 * precisely how to send the frame. 		 */
name|error
operator|=
name|iwn_tx_data
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|ni
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Caller supplied explicit parameters to use in 		 * sending the frame. 		 */
name|error
operator|=
name|iwn_tx_data_raw
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|ni
argument_list|,
name|params
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|5
expr_stmt|;
else|else
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
operator||
name|IWN_DEBUG_XMIT
argument_list|,
literal|"->%s: end\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * transmit - don't free mbuf if failed; don't free node ref if failed.  */
end_comment

begin_function
specifier|static
name|int
name|iwn_transmit
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ni
operator|=
operator|(
expr|struct
name|ieee80211_node
operator|*
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWN_FLAG_RUNNING
operator|)
operator|==
literal|0
operator|||
name|sc
operator|->
name|sc_beacon_wait
condition|)
block|{
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|qfullmsk
condition|)
block|{
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|error
operator|=
name|iwn_tx_data
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|5
expr_stmt|;
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_scan_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|ic_printf
argument_list|(
name|ic
argument_list|,
literal|"scan timeout\n"
argument_list|)
expr_stmt|;
name|ieee80211_restart_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_watchdog
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|IWN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWN_FLAG_RUNNING
argument_list|,
operator|(
literal|"not running"
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->Doing %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_tx_timer
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|--
name|sc
operator|->
name|sc_tx_timer
operator|==
literal|0
condition|)
block|{
name|ic_printf
argument_list|(
name|ic
argument_list|,
literal|"device timeout\n"
argument_list|)
expr_stmt|;
name|ieee80211_restart_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|watchdog_to
argument_list|,
name|hz
argument_list|,
name|iwn_watchdog
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_cdev_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|type
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_cdev_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|type
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_cdev_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|unsigned
name|long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
name|struct
name|iwn_ioctl_data
modifier|*
name|d
decl_stmt|;
name|rc
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCGIWNSTATS
case|:
name|d
operator|=
operator|(
expr|struct
name|iwn_ioctl_data
operator|*
operator|)
name|data
expr_stmt|;
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX validate permissions/memory/etc? */
name|rc
operator|=
name|copyout
argument_list|(
operator|&
name|sc
operator|->
name|last_stat
argument_list|,
name|d
operator|->
name|dst_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_stats
argument_list|)
argument_list|)
expr_stmt|;
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCZIWNSTATS
case|:
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sc
operator|->
name|last_stat
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_stats
argument_list|)
argument_list|)
expr_stmt|;
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|rc
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_ioctl
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_parent
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_nrunning
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|iwn_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|error
condition|)
block|{
case|case
literal|0
case|:
name|ieee80211_start_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAGAIN
case|:
comment|/* radio is disabled via RFkill switch */
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_rftoggle_task
argument_list|)
expr_stmt|;
break|break;
default|default:
name|vap
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|!=
name|NULL
condition|)
name|ieee80211_stop
argument_list|(
name|vap
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
name|iwn_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send a command to the firmware.  */
end_comment

begin_function
specifier|static
name|int
name|iwn_cmd
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|code
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|async
parameter_list|)
block|{
name|struct
name|iwn_tx_ring
modifier|*
name|ring
decl_stmt|;
name|struct
name|iwn_tx_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|iwn_tx_data
modifier|*
name|data
decl_stmt|;
name|struct
name|iwn_tx_cmd
modifier|*
name|cmd
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|bus_addr_t
name|paddr
decl_stmt|;
name|int
name|totlen
decl_stmt|,
name|error
decl_stmt|;
name|int
name|cmd_queue_num
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s begin\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|async
operator|==
literal|0
condition|)
name|IWN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWN_FLAG_PAN_SUPPORT
condition|)
name|cmd_queue_num
operator|=
name|IWN_PAN_CMD_QUEUE
expr_stmt|;
else|else
name|cmd_queue_num
operator|=
name|IWN_CMD_QUEUE_NUM
expr_stmt|;
name|ring
operator|=
operator|&
name|sc
operator|->
name|txq
index|[
name|cmd_queue_num
index|]
expr_stmt|;
name|desc
operator|=
operator|&
name|ring
operator|->
name|desc
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|data
operator|=
operator|&
name|ring
operator|->
name|data
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|totlen
operator|=
literal|4
operator|+
name|size
expr_stmt|;
if|if
condition|(
name|size
operator|>
sizeof|sizeof
name|cmd
operator|->
name|data
condition|)
block|{
comment|/* Command is too large to fit in a descriptor. */
if|if
condition|(
name|totlen
operator|>
name|MCLBYTES
condition|)
return|return
name|EINVAL
return|;
name|m
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|MJUMPAGESIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|cmd
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|iwn_tx_cmd
operator|*
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|cmd
argument_list|,
name|totlen
argument_list|,
name|iwn_dma_map_addr
argument_list|,
operator|&
name|paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|data
operator|->
name|m
operator|=
name|m
expr_stmt|;
block|}
else|else
block|{
name|cmd
operator|=
operator|&
name|ring
operator|->
name|cmd
index|[
name|ring
operator|->
name|cur
index|]
expr_stmt|;
name|paddr
operator|=
name|data
operator|->
name|cmd_paddr
expr_stmt|;
block|}
name|cmd
operator|->
name|code
operator|=
name|code
expr_stmt|;
name|cmd
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|qid
operator|=
name|ring
operator|->
name|qid
expr_stmt|;
name|cmd
operator|->
name|idx
operator|=
name|ring
operator|->
name|cur
expr_stmt|;
name|memcpy
argument_list|(
name|cmd
operator|->
name|data
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|desc
operator|->
name|nsegs
operator|=
literal|1
expr_stmt|;
name|desc
operator|->
name|segs
index|[
literal|0
index|]
operator|.
name|addr
operator|=
name|htole32
argument_list|(
name|IWN_LOADDR
argument_list|(
name|paddr
argument_list|)
argument_list|)
expr_stmt|;
name|desc
operator|->
name|segs
index|[
literal|0
index|]
operator|.
name|len
operator|=
name|htole16
argument_list|(
name|IWN_HIADDR
argument_list|(
name|paddr
argument_list|)
operator||
name|totlen
operator|<<
literal|4
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CMD
argument_list|,
literal|"%s: %s (0x%x) flags %d qid %d idx %d\n"
argument_list|,
name|__func__
argument_list|,
name|iwn_intr_str
argument_list|(
name|cmd
operator|->
name|code
argument_list|)
argument_list|,
name|cmd
operator|->
name|code
argument_list|,
name|cmd
operator|->
name|flags
argument_list|,
name|cmd
operator|->
name|qid
argument_list|,
name|cmd
operator|->
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
sizeof|sizeof
name|cmd
operator|->
name|data
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|data_dmat
argument_list|,
name|data
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|cmd_dma
operator|.
name|tag
argument_list|,
name|ring
operator|->
name|cmd_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|desc_dma
operator|.
name|tag
argument_list|,
name|ring
operator|->
name|desc_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Kick command ring. */
name|ring
operator|->
name|cur
operator|=
operator|(
name|ring
operator|->
name|cur
operator|+
literal|1
operator|)
operator|%
name|IWN_TX_RING_COUNT
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_HBUS_TARG_WRPTR
argument_list|,
name|ring
operator|->
name|qid
operator|<<
literal|8
operator||
name|ring
operator|->
name|cur
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s: end\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|async
condition|?
literal|0
else|:
name|msleep
argument_list|(
name|desc
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|PCATCH
argument_list|,
literal|"iwncmd"
argument_list|,
name|hz
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn4965_add_node
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_node_info
modifier|*
name|node
parameter_list|,
name|int
name|async
parameter_list|)
block|{
name|struct
name|iwn4965_node_info
name|hnode
decl_stmt|;
name|caddr_t
name|src
decl_stmt|,
name|dst
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->Doing %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 	 * We use the node structure for 5000 Series internally (it is 	 * a superset of the one for 4965AGN). We thus copy the common 	 * fields before sending the command. 	 */
name|src
operator|=
operator|(
name|caddr_t
operator|)
name|node
expr_stmt|;
name|dst
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|hnode
expr_stmt|;
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
literal|48
argument_list|)
expr_stmt|;
comment|/* Skip TSC, RX MIC and TX MIC fields from ``src''. */
name|memcpy
argument_list|(
name|dst
operator|+
literal|48
argument_list|,
name|src
operator|+
literal|72
argument_list|,
literal|20
argument_list|)
expr_stmt|;
return|return
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_ADD_NODE
argument_list|,
operator|&
name|hnode
argument_list|,
sizeof|sizeof
name|hnode
argument_list|,
name|async
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn5000_add_node
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_node_info
modifier|*
name|node
parameter_list|,
name|int
name|async
parameter_list|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->Doing %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Direct mapping. */
return|return
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_ADD_NODE
argument_list|,
name|node
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|node
argument_list|)
argument_list|,
name|async
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_set_link_quality
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|iwn_node
modifier|*
name|wn
init|=
operator|(
name|void
operator|*
operator|)
name|ni
decl_stmt|;
name|struct
name|ieee80211_rateset
modifier|*
name|rs
decl_stmt|;
name|struct
name|iwn_cmd_link_quality
name|linkq
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rate
decl_stmt|,
name|txrate
decl_stmt|;
name|int
name|is_11n
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s begin\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|linkq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|linkq
argument_list|)
expr_stmt|;
name|linkq
operator|.
name|id
operator|=
name|wn
operator|->
name|id
expr_stmt|;
name|linkq
operator|.
name|antmsk_1stream
operator|=
name|iwn_get_1stream_tx_antmask
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|linkq
operator|.
name|antmsk_2stream
operator|=
name|iwn_get_2stream_tx_antmask
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|linkq
operator|.
name|ampdu_max
operator|=
literal|32
expr_stmt|;
comment|/* XXX negotiated? */
name|linkq
operator|.
name|ampdu_threshold
operator|=
literal|3
expr_stmt|;
name|linkq
operator|.
name|ampdu_limit
operator|=
name|htole16
argument_list|(
literal|4000
argument_list|)
expr_stmt|;
comment|/* 4ms */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_XMIT
argument_list|,
literal|"%s: 1stream antenna=0x%02x, 2stream antenna=0x%02x, ntxstreams=%d\n"
argument_list|,
name|__func__
argument_list|,
name|linkq
operator|.
name|antmsk_1stream
argument_list|,
name|linkq
operator|.
name|antmsk_2stream
argument_list|,
name|sc
operator|->
name|ntxchains
argument_list|)
expr_stmt|;
comment|/* 	 * Are we using 11n rates? Ensure the channel is 	 * 11n _and_ we have some 11n rates, or don't 	 * try. 	 */
if|if
condition|(
name|IEEE80211_IS_CHAN_HT
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
operator|&&
name|ni
operator|->
name|ni_htrates
operator|.
name|rs_nrates
operator|>
literal|0
condition|)
block|{
name|rs
operator|=
operator|(
expr|struct
name|ieee80211_rateset
operator|*
operator|)
operator|&
name|ni
operator|->
name|ni_htrates
expr_stmt|;
name|is_11n
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|rs
operator|=
operator|&
name|ni
operator|->
name|ni_rates
expr_stmt|;
name|is_11n
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Start at highest available bit-rate. */
comment|/* 	 * XXX this is all very dirty! 	 */
if|if
condition|(
name|is_11n
condition|)
name|txrate
operator|=
name|ni
operator|->
name|ni_htrates
operator|.
name|rs_nrates
operator|-
literal|1
expr_stmt|;
else|else
name|txrate
operator|=
name|rs
operator|->
name|rs_nrates
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWN_MAX_TX_RETRIES
condition|;
name|i
operator|++
control|)
block|{
name|uint32_t
name|plcp
decl_stmt|;
comment|/* 		 * XXX TODO: ensure the last two slots are the two lowest 		 * rate entries, just for now. 		 */
if|if
condition|(
name|i
operator|==
literal|14
operator|||
name|i
operator|==
literal|15
condition|)
name|txrate
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|is_11n
condition|)
name|rate
operator|=
name|IEEE80211_RATE_MCS
operator||
name|rs
operator|->
name|rs_rates
index|[
name|txrate
index|]
expr_stmt|;
else|else
name|rate
operator|=
name|IEEE80211_RV
argument_list|(
name|rs
operator|->
name|rs_rates
index|[
name|txrate
index|]
argument_list|)
expr_stmt|;
comment|/* Do rate -> PLCP config mapping */
name|plcp
operator|=
name|iwn_rate_to_plcp
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|rate
argument_list|)
expr_stmt|;
name|linkq
operator|.
name|retry
index|[
name|i
index|]
operator|=
name|plcp
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_XMIT
argument_list|,
literal|"%s: i=%d, txrate=%d, rate=0x%02x, plcp=0x%08x\n"
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|,
name|txrate
argument_list|,
name|rate
argument_list|,
name|le32toh
argument_list|(
name|plcp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * The mimo field is an index into the table which 		 * indicates the first index where it and subsequent entries 		 * will not be using MIMO. 		 * 		 * Since we're filling linkq from 0..15 and we're filling 		 * from the highest MCS rates to the lowest rates, if we 		 * _are_ doing a dual-stream rate, set mimo to idx+1 (ie, 		 * the next entry.)  That way if the next entry is a non-MIMO 		 * entry, we're already pointing at it. 		 */
if|if
condition|(
operator|(
name|le32toh
argument_list|(
name|plcp
argument_list|)
operator|&
name|IWN_RFLAG_MCS
operator|)
operator|&&
name|IEEE80211_RV
argument_list|(
name|le32toh
argument_list|(
name|plcp
argument_list|)
argument_list|)
operator|>
literal|7
condition|)
name|linkq
operator|.
name|mimo
operator|=
name|i
operator|+
literal|1
expr_stmt|;
comment|/* Next retry at immediate lower bit-rate. */
if|if
condition|(
name|txrate
operator|>
literal|0
condition|)
name|txrate
operator|--
expr_stmt|;
block|}
comment|/* 	 * If we reached the end of the list and indeed we hit 	 * all MIMO rates (eg 5300 doing MCS23-15) then yes, 	 * set mimo to 15.  Setting it to 16 panics the firmware. 	 */
if|if
condition|(
name|linkq
operator|.
name|mimo
operator|>
literal|15
condition|)
name|linkq
operator|.
name|mimo
operator|=
literal|15
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_XMIT
argument_list|,
literal|"%s: mimo = %d\n"
argument_list|,
name|__func__
argument_list|,
name|linkq
operator|.
name|mimo
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s: end\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_LINK_QUALITY
argument_list|,
operator|&
name|linkq
argument_list|,
sizeof|sizeof
name|linkq
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Broadcast node is used to send group-addressed and management frames.  */
end_comment

begin_function
specifier|static
name|int
name|iwn_add_broadcast_node
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|async
parameter_list|)
block|{
name|struct
name|iwn_ops
modifier|*
name|ops
init|=
operator|&
name|sc
operator|->
name|ops
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|iwn_node_info
name|node
decl_stmt|;
name|struct
name|iwn_cmd_link_quality
name|linkq
decl_stmt|;
name|uint8_t
name|txant
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s begin\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rxon
operator|=
operator|&
name|sc
operator|->
name|rx_on
index|[
name|IWN_RXON_BSS_CTX
index|]
expr_stmt|;
name|memset
argument_list|(
operator|&
name|node
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|node
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|node
operator|.
name|macaddr
argument_list|,
name|ieee80211broadcastaddr
argument_list|)
expr_stmt|;
name|node
operator|.
name|id
operator|=
name|sc
operator|->
name|broadcast_id
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"%s: adding broadcast node\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ops
operator|->
name|add_node
argument_list|(
name|sc
argument_list|,
operator|&
name|node
argument_list|,
name|async
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/* Use the first valid TX antenna. */
name|txant
operator|=
name|IWN_LSB
argument_list|(
name|sc
operator|->
name|txchainmask
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|linkq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|linkq
argument_list|)
expr_stmt|;
name|linkq
operator|.
name|id
operator|=
name|sc
operator|->
name|broadcast_id
expr_stmt|;
name|linkq
operator|.
name|antmsk_1stream
operator|=
name|iwn_get_1stream_tx_antmask
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|linkq
operator|.
name|antmsk_2stream
operator|=
name|iwn_get_2stream_tx_antmask
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|linkq
operator|.
name|ampdu_max
operator|=
literal|64
expr_stmt|;
name|linkq
operator|.
name|ampdu_threshold
operator|=
literal|3
expr_stmt|;
name|linkq
operator|.
name|ampdu_limit
operator|=
name|htole16
argument_list|(
literal|4000
argument_list|)
expr_stmt|;
comment|/* 4ms */
comment|/* Use lowest mandatory bit-rate. */
comment|/* XXX rate table lookup? */
if|if
condition|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
condition|)
name|linkq
operator|.
name|retry
index|[
literal|0
index|]
operator|=
name|htole32
argument_list|(
literal|0xd
argument_list|)
expr_stmt|;
else|else
name|linkq
operator|.
name|retry
index|[
literal|0
index|]
operator|=
name|htole32
argument_list|(
literal|10
operator||
name|IWN_RFLAG_CCK
argument_list|)
expr_stmt|;
name|linkq
operator|.
name|retry
index|[
literal|0
index|]
operator||=
name|htole32
argument_list|(
name|IWN_RFLAG_ANT
argument_list|(
name|txant
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Use same bit-rate for all TX retries. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|IWN_MAX_TX_RETRIES
condition|;
name|i
operator|++
control|)
block|{
name|linkq
operator|.
name|retry
index|[
name|i
index|]
operator|=
name|linkq
operator|.
name|retry
index|[
literal|0
index|]
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s: end\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_LINK_QUALITY
argument_list|,
operator|&
name|linkq
argument_list|,
sizeof|sizeof
name|linkq
argument_list|,
name|async
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_updateedca
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
define|#
directive|define
name|IWN_EXP2
parameter_list|(
name|x
parameter_list|)
value|((1<< (x)) - 1)
comment|/* CWmin = 2^ECWmin - 1 */
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|struct
name|iwn_edca_params
name|cmd
decl_stmt|;
name|int
name|aci
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s begin\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|flags
operator|=
name|htole32
argument_list|(
name|IWN_EDCA_UPDATE
argument_list|)
expr_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
for|for
control|(
name|aci
operator|=
literal|0
init|;
name|aci
operator|<
name|WME_NUM_AC
condition|;
name|aci
operator|++
control|)
block|{
specifier|const
name|struct
name|wmeParams
modifier|*
name|ac
init|=
operator|&
name|ic
operator|->
name|ic_wme
operator|.
name|wme_chanParams
operator|.
name|cap_wmeParams
index|[
name|aci
index|]
decl_stmt|;
name|cmd
operator|.
name|ac
index|[
name|aci
index|]
operator|.
name|aifsn
operator|=
name|ac
operator|->
name|wmep_aifsn
expr_stmt|;
name|cmd
operator|.
name|ac
index|[
name|aci
index|]
operator|.
name|cwmin
operator|=
name|htole16
argument_list|(
name|IWN_EXP2
argument_list|(
name|ac
operator|->
name|wmep_logcwmin
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|ac
index|[
name|aci
index|]
operator|.
name|cwmax
operator|=
name|htole16
argument_list|(
name|IWN_EXP2
argument_list|(
name|ac
operator|->
name|wmep_logcwmax
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|ac
index|[
name|aci
index|]
operator|.
name|txoplimit
operator|=
name|htole16
argument_list|(
name|IEEE80211_TXOP_TO_US
argument_list|(
name|ac
operator|->
name|wmep_txopLimit
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_EDCA_PARAMS
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
name|cmd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s: end\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
undef|#
directive|undef
name|IWN_EXP2
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_set_promisc
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|uint32_t
name|promisc_filter
decl_stmt|;
name|promisc_filter
operator|=
name|IWN_FILTER_CTL
operator||
name|IWN_FILTER_PROMISC
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_promisc
operator|>
literal|0
operator|||
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_MONITOR
condition|)
name|sc
operator|->
name|rxon
operator|->
name|filter
operator||=
name|htole32
argument_list|(
name|promisc_filter
argument_list|)
expr_stmt|;
else|else
name|sc
operator|->
name|rxon
operator|->
name|filter
operator|&=
operator|~
name|htole32
argument_list|(
name|promisc_filter
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_update_promisc
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_MONITOR
condition|)
return|return;
comment|/* nothing to do */
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWN_FLAG_RUNNING
operator|)
condition|)
block|{
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|iwn_set_promisc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_send_rxon
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not send RXON, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_update_mcast
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
comment|/* Ignore */
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_set_led
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|which
parameter_list|,
name|uint8_t
name|off
parameter_list|,
name|uint8_t
name|on
parameter_list|)
block|{
name|struct
name|iwn_cmd_led
name|led
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->Doing %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX don't set LEDs during scan? */
block|if (sc->sc_is_scanning) 		return;
endif|#
directive|endif
comment|/* Clear microcode LED ownership. */
name|IWN_CLRBITS
argument_list|(
name|sc
argument_list|,
name|IWN_LED
argument_list|,
name|IWN_LED_BSM_CTRL
argument_list|)
expr_stmt|;
name|led
operator|.
name|which
operator|=
name|which
expr_stmt|;
name|led
operator|.
name|unit
operator|=
name|htole32
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/* on/off in unit of 100ms */
name|led
operator|.
name|off
operator|=
name|off
expr_stmt|;
name|led
operator|.
name|on
operator|=
name|on
expr_stmt|;
operator|(
name|void
operator|)
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_SET_LED
argument_list|,
operator|&
name|led
argument_list|,
sizeof|sizeof
name|led
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the critical temperature at which the firmware will stop the radio  * and notify us.  */
end_comment

begin_function
specifier|static
name|int
name|iwn_set_critical_temp
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwn_critical_temp
name|crit
decl_stmt|;
name|int32_t
name|temp
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->Doing %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_UCODE_GP1_CLR
argument_list|,
name|IWN_UCODE_GP1_CTEMP_STOP_RF
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hw_type
operator|==
name|IWN_HW_REV_TYPE_5150
condition|)
name|temp
operator|=
operator|(
name|IWN_CTOK
argument_list|(
literal|110
argument_list|)
operator|-
name|sc
operator|->
name|temp_off
operator|)
operator|*
operator|-
literal|5
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|hw_type
operator|==
name|IWN_HW_REV_TYPE_4965
condition|)
name|temp
operator|=
name|IWN_CTOK
argument_list|(
literal|110
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
literal|110
expr_stmt|;
name|memset
argument_list|(
operator|&
name|crit
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|crit
argument_list|)
expr_stmt|;
name|crit
operator|.
name|tempR
operator|=
name|htole32
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"setting critical temp to %d\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
return|return
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_SET_CRITICAL_TEMP
argument_list|,
operator|&
name|crit
argument_list|,
sizeof|sizeof
name|crit
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_set_timing
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|iwn_cmd_timing
name|cmd
decl_stmt|;
name|uint64_t
name|val
decl_stmt|,
name|mod
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->Doing %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|cmd
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|cmd
operator|.
name|tstamp
argument_list|,
name|ni
operator|->
name|ni_tstamp
operator|.
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|bintval
operator|=
name|htole16
argument_list|(
name|ni
operator|->
name|ni_intval
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|lintval
operator|=
name|htole16
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* Compute remaining time until next beacon. */
name|val
operator|=
operator|(
name|uint64_t
operator|)
name|ni
operator|->
name|ni_intval
operator|*
name|IEEE80211_DUR_TU
expr_stmt|;
name|mod
operator|=
name|le64toh
argument_list|(
name|cmd
operator|.
name|tstamp
argument_list|)
operator|%
name|val
expr_stmt|;
name|cmd
operator|.
name|binitval
operator|=
name|htole32
argument_list|(
call|(
name|uint32_t
call|)
argument_list|(
name|val
operator|-
name|mod
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"timing bintval=%u tstamp=%ju, init=%u\n"
argument_list|,
name|ni
operator|->
name|ni_intval
argument_list|,
name|le64toh
argument_list|(
name|cmd
operator|.
name|tstamp
argument_list|)
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|val
operator|-
name|mod
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_TIMING
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
name|cmd
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn4965_power_calibration
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|temp
parameter_list|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->Doing %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Adjust TX power if need be (delta>= 3 degC). */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s: temperature %d->%d\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|temp
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|temp
operator|-
name|sc
operator|->
name|temp
argument_list|)
operator|>=
literal|3
condition|)
block|{
comment|/* Record temperature of last calibration. */
name|sc
operator|->
name|temp
operator|=
name|temp
expr_stmt|;
operator|(
name|void
operator|)
name|iwn4965_set_txpower
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Set TX power for current channel (each rate has its own power settings).  * This function takes into account the regulatory information from EEPROM,  * the current temperature and the current voltage.  */
end_comment

begin_function
specifier|static
name|int
name|iwn4965_set_txpower
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|async
parameter_list|)
block|{
comment|/* Fixed-point arithmetic division using a n-bit fractional part. */
define|#
directive|define
name|fdivround
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|n
parameter_list|)
define|\
value|((((1<< n) * (a)) / (b) + (1<< n) / 2) / (1<< n))
comment|/* Linear interpolation. */
define|#
directive|define
name|interpolate
parameter_list|(
name|x
parameter_list|,
name|x1
parameter_list|,
name|y1
parameter_list|,
name|x2
parameter_list|,
name|y2
parameter_list|,
name|n
parameter_list|)
define|\
value|((y1) + fdivround(((int)(x) - (x1)) * ((y2) - (y1)), (x2) - (x1), n))
specifier|static
specifier|const
name|int
name|tdiv
index|[
name|IWN_NATTEN_GROUPS
index|]
init|=
block|{
literal|9
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|6
block|}
decl_stmt|;
name|struct
name|iwn_ucode_info
modifier|*
name|uc
init|=
operator|&
name|sc
operator|->
name|ucode_info
decl_stmt|;
name|struct
name|iwn4965_cmd_txpower
name|cmd
decl_stmt|;
name|struct
name|iwn4965_eeprom_chan_samples
modifier|*
name|chans
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|rf_gain
decl_stmt|,
modifier|*
name|dsp_gain
decl_stmt|;
name|int32_t
name|vdiff
decl_stmt|,
name|tdiff
decl_stmt|;
name|int
name|i
decl_stmt|,
name|is_chan_5ghz
decl_stmt|,
name|c
decl_stmt|,
name|grp
decl_stmt|,
name|maxpwr
decl_stmt|;
name|uint8_t
name|chan
decl_stmt|;
name|sc
operator|->
name|rxon
operator|=
operator|&
name|sc
operator|->
name|rx_on
index|[
name|IWN_RXON_BSS_CTX
index|]
expr_stmt|;
comment|/* Retrieve current channel from last RXON. */
name|chan
operator|=
name|sc
operator|->
name|rxon
operator|->
name|chan
expr_stmt|;
name|is_chan_5ghz
operator|=
operator|(
name|sc
operator|->
name|rxon
operator|->
name|flags
operator|&
name|htole32
argument_list|(
name|IWN_RXON_24GHZ
argument_list|)
operator|)
operator|==
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"setting TX power for channel %d\n"
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|band
operator|=
name|is_chan_5ghz
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|cmd
operator|.
name|chan
operator|=
name|chan
expr_stmt|;
if|if
condition|(
name|is_chan_5ghz
condition|)
block|{
name|maxpwr
operator|=
name|sc
operator|->
name|maxpwr5GHz
expr_stmt|;
name|rf_gain
operator|=
name|iwn4965_rf_gain_5ghz
expr_stmt|;
name|dsp_gain
operator|=
name|iwn4965_dsp_gain_5ghz
expr_stmt|;
block|}
else|else
block|{
name|maxpwr
operator|=
name|sc
operator|->
name|maxpwr2GHz
expr_stmt|;
name|rf_gain
operator|=
name|iwn4965_rf_gain_2ghz
expr_stmt|;
name|dsp_gain
operator|=
name|iwn4965_dsp_gain_2ghz
expr_stmt|;
block|}
comment|/* Compute voltage compensation. */
name|vdiff
operator|=
operator|(
operator|(
name|int32_t
operator|)
name|le32toh
argument_list|(
name|uc
operator|->
name|volt
argument_list|)
operator|-
name|sc
operator|->
name|eeprom_voltage
operator|)
operator|/
literal|7
expr_stmt|;
if|if
condition|(
name|vdiff
operator|>
literal|0
condition|)
name|vdiff
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|vdiff
argument_list|)
operator|>
literal|2
condition|)
name|vdiff
operator|=
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
operator||
name|IWN_DEBUG_TXPOW
argument_list|,
literal|"%s: voltage compensation=%d (UCODE=%d, EEPROM=%d)\n"
argument_list|,
name|__func__
argument_list|,
name|vdiff
argument_list|,
name|le32toh
argument_list|(
name|uc
operator|->
name|volt
argument_list|)
argument_list|,
name|sc
operator|->
name|eeprom_voltage
argument_list|)
expr_stmt|;
comment|/* Get channel attenuation group. */
if|if
condition|(
name|chan
operator|<=
literal|20
condition|)
comment|/* 1-20 */
name|grp
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|chan
operator|<=
literal|43
condition|)
comment|/* 34-43 */
name|grp
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|chan
operator|<=
literal|70
condition|)
comment|/* 44-70 */
name|grp
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|chan
operator|<=
literal|124
condition|)
comment|/* 71-124 */
name|grp
operator|=
literal|2
expr_stmt|;
else|else
comment|/* 125-200 */
name|grp
operator|=
literal|3
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
operator||
name|IWN_DEBUG_TXPOW
argument_list|,
literal|"%s: chan %d, attenuation group=%d\n"
argument_list|,
name|__func__
argument_list|,
name|chan
argument_list|,
name|grp
argument_list|)
expr_stmt|;
comment|/* Get channel sub-band. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IWN_NBANDS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|bands
index|[
name|i
index|]
operator|.
name|lo
operator|!=
literal|0
operator|&&
name|sc
operator|->
name|bands
index|[
name|i
index|]
operator|.
name|lo
operator|<=
name|chan
operator|&&
name|chan
operator|<=
name|sc
operator|->
name|bands
index|[
name|i
index|]
operator|.
name|hi
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|IWN_NBANDS
condition|)
comment|/* Can't happen in real-life. */
return|return
name|EINVAL
return|;
name|chans
operator|=
name|sc
operator|->
name|bands
index|[
name|i
index|]
operator|.
name|chans
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
operator||
name|IWN_DEBUG_TXPOW
argument_list|,
literal|"%s: chan %d sub-band=%d\n"
argument_list|,
name|__func__
argument_list|,
name|chan
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|2
condition|;
name|c
operator|++
control|)
block|{
name|uint8_t
name|power
decl_stmt|,
name|gain
decl_stmt|,
name|temp
decl_stmt|;
name|int
name|maxchpwr
decl_stmt|,
name|pwr
decl_stmt|,
name|ridx
decl_stmt|,
name|idx
decl_stmt|;
name|power
operator|=
name|interpolate
argument_list|(
name|chan
argument_list|,
name|chans
index|[
literal|0
index|]
operator|.
name|num
argument_list|,
name|chans
index|[
literal|0
index|]
operator|.
name|samples
index|[
name|c
index|]
index|[
literal|1
index|]
operator|.
name|power
argument_list|,
name|chans
index|[
literal|1
index|]
operator|.
name|num
argument_list|,
name|chans
index|[
literal|1
index|]
operator|.
name|samples
index|[
name|c
index|]
index|[
literal|1
index|]
operator|.
name|power
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gain
operator|=
name|interpolate
argument_list|(
name|chan
argument_list|,
name|chans
index|[
literal|0
index|]
operator|.
name|num
argument_list|,
name|chans
index|[
literal|0
index|]
operator|.
name|samples
index|[
name|c
index|]
index|[
literal|1
index|]
operator|.
name|gain
argument_list|,
name|chans
index|[
literal|1
index|]
operator|.
name|num
argument_list|,
name|chans
index|[
literal|1
index|]
operator|.
name|samples
index|[
name|c
index|]
index|[
literal|1
index|]
operator|.
name|gain
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|temp
operator|=
name|interpolate
argument_list|(
name|chan
argument_list|,
name|chans
index|[
literal|0
index|]
operator|.
name|num
argument_list|,
name|chans
index|[
literal|0
index|]
operator|.
name|samples
index|[
name|c
index|]
index|[
literal|1
index|]
operator|.
name|temp
argument_list|,
name|chans
index|[
literal|1
index|]
operator|.
name|num
argument_list|,
name|chans
index|[
literal|1
index|]
operator|.
name|samples
index|[
name|c
index|]
index|[
literal|1
index|]
operator|.
name|temp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
operator||
name|IWN_DEBUG_TXPOW
argument_list|,
literal|"%s: Tx chain %d: power=%d gain=%d temp=%d\n"
argument_list|,
name|__func__
argument_list|,
name|c
argument_list|,
name|power
argument_list|,
name|gain
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* Compute temperature compensation. */
name|tdiff
operator|=
operator|(
operator|(
name|sc
operator|->
name|temp
operator|-
name|temp
operator|)
operator|*
literal|2
operator|)
operator|/
name|tdiv
index|[
name|grp
index|]
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
operator||
name|IWN_DEBUG_TXPOW
argument_list|,
literal|"%s: temperature compensation=%d (current=%d, EEPROM=%d)\n"
argument_list|,
name|__func__
argument_list|,
name|tdiff
argument_list|,
name|sc
operator|->
name|temp
argument_list|,
name|temp
argument_list|)
expr_stmt|;
for|for
control|(
name|ridx
operator|=
literal|0
init|;
name|ridx
operator|<=
name|IWN_RIDX_MAX
condition|;
name|ridx
operator|++
control|)
block|{
comment|/* Convert dBm to half-dBm. */
name|maxchpwr
operator|=
name|sc
operator|->
name|maxpwr
index|[
name|chan
index|]
operator|*
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|ridx
operator|/
literal|8
operator|)
operator|&
literal|1
condition|)
name|maxchpwr
operator|-=
literal|6
expr_stmt|;
comment|/* MIMO 2T: -3dB */
name|pwr
operator|=
name|maxpwr
expr_stmt|;
comment|/* Adjust TX power based on rate. */
if|if
condition|(
operator|(
name|ridx
operator|%
literal|8
operator|)
operator|==
literal|5
condition|)
name|pwr
operator|-=
literal|15
expr_stmt|;
comment|/* OFDM48: -7.5dB */
elseif|else
if|if
condition|(
operator|(
name|ridx
operator|%
literal|8
operator|)
operator|==
literal|6
condition|)
name|pwr
operator|-=
literal|17
expr_stmt|;
comment|/* OFDM54: -8.5dB */
elseif|else
if|if
condition|(
operator|(
name|ridx
operator|%
literal|8
operator|)
operator|==
literal|7
condition|)
name|pwr
operator|-=
literal|20
expr_stmt|;
comment|/* OFDM60: -10dB */
else|else
name|pwr
operator|-=
literal|10
expr_stmt|;
comment|/* Others: -5dB */
comment|/* Do not exceed channel max TX power. */
if|if
condition|(
name|pwr
operator|>
name|maxchpwr
condition|)
name|pwr
operator|=
name|maxchpwr
expr_stmt|;
name|idx
operator|=
name|gain
operator|-
operator|(
name|pwr
operator|-
name|power
operator|)
operator|-
name|tdiff
operator|-
name|vdiff
expr_stmt|;
if|if
condition|(
operator|(
name|ridx
operator|/
literal|8
operator|)
operator|&
literal|1
condition|)
comment|/* MIMO */
name|idx
operator|+=
operator|(
name|int32_t
operator|)
name|le32toh
argument_list|(
name|uc
operator|->
name|atten
index|[
name|grp
index|]
index|[
name|c
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|.
name|band
operator|==
literal|0
condition|)
name|idx
operator|+=
literal|9
expr_stmt|;
comment|/* 5GHz */
if|if
condition|(
name|ridx
operator|==
name|IWN_RIDX_MAX
condition|)
name|idx
operator|+=
literal|5
expr_stmt|;
comment|/* CCK */
comment|/* Make sure idx stays in a valid range. */
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
name|idx
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|idx
operator|>
name|IWN4965_MAX_PWR_INDEX
condition|)
name|idx
operator|=
name|IWN4965_MAX_PWR_INDEX
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
operator||
name|IWN_DEBUG_TXPOW
argument_list|,
literal|"%s: Tx chain %d, rate idx %d: power=%d\n"
argument_list|,
name|__func__
argument_list|,
name|c
argument_list|,
name|ridx
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|power
index|[
name|ridx
index|]
operator|.
name|rf_gain
index|[
name|c
index|]
operator|=
name|rf_gain
index|[
name|idx
index|]
expr_stmt|;
name|cmd
operator|.
name|power
index|[
name|ridx
index|]
operator|.
name|dsp_gain
index|[
name|c
index|]
operator|=
name|dsp_gain
index|[
name|idx
index|]
expr_stmt|;
block|}
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
operator||
name|IWN_DEBUG_TXPOW
argument_list|,
literal|"%s: set tx power for chan %d\n"
argument_list|,
name|__func__
argument_list|,
name|chan
argument_list|)
expr_stmt|;
return|return
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_TXPOWER
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
name|cmd
argument_list|,
name|async
argument_list|)
return|;
undef|#
directive|undef
name|interpolate
undef|#
directive|undef
name|fdivround
block|}
end_function

begin_function
specifier|static
name|int
name|iwn5000_set_txpower
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|async
parameter_list|)
block|{
name|struct
name|iwn5000_cmd_txpower
name|cmd
decl_stmt|;
name|int
name|cmdid
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->Doing %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 	 * TX power calibration is handled automatically by the firmware 	 * for 5000 Series. 	 */
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|global_limit
operator|=
literal|2
operator|*
name|IWN5000_TXPOWER_MAX_DBM
expr_stmt|;
comment|/* 16 dBm */
name|cmd
operator|.
name|flags
operator|=
name|IWN5000_TXPOWER_NO_CLOSED
expr_stmt|;
name|cmd
operator|.
name|srv_limit
operator|=
name|IWN5000_TXPOWER_AUTO
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
operator||
name|IWN_DEBUG_XMIT
argument_list|,
literal|"%s: setting TX power; rev=%d\n"
argument_list|,
name|__func__
argument_list|,
name|IWN_UCODE_API
argument_list|(
name|sc
operator|->
name|ucode_rev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IWN_UCODE_API
argument_list|(
name|sc
operator|->
name|ucode_rev
argument_list|)
operator|==
literal|1
condition|)
name|cmdid
operator|=
name|IWN_CMD_TXPOWER_DBM_V1
expr_stmt|;
else|else
name|cmdid
operator|=
name|IWN_CMD_TXPOWER_DBM
expr_stmt|;
return|return
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|cmdid
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
name|cmd
argument_list|,
name|async
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Retrieve the maximum RSSI (in dBm) among receivers.  */
end_comment

begin_function
specifier|static
name|int
name|iwn4965_get_rssi
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_rx_stat
modifier|*
name|stat
parameter_list|)
block|{
name|struct
name|iwn4965_rx_phystat
modifier|*
name|phy
init|=
operator|(
name|void
operator|*
operator|)
name|stat
operator|->
name|phybuf
decl_stmt|;
name|uint8_t
name|mask
decl_stmt|,
name|agc
decl_stmt|;
name|int
name|rssi
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->Doing %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|(
name|le16toh
argument_list|(
name|phy
operator|->
name|antenna
argument_list|)
operator|>>
literal|4
operator|)
operator|&
name|IWN_ANT_ABC
expr_stmt|;
name|agc
operator|=
operator|(
name|le16toh
argument_list|(
name|phy
operator|->
name|agc
argument_list|)
operator|>>
literal|7
operator|)
operator|&
literal|0x7f
expr_stmt|;
name|rssi
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IWN_ANT_A
condition|)
name|rssi
operator|=
name|MAX
argument_list|(
name|rssi
argument_list|,
name|phy
operator|->
name|rssi
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IWN_ANT_B
condition|)
name|rssi
operator|=
name|MAX
argument_list|(
name|rssi
argument_list|,
name|phy
operator|->
name|rssi
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IWN_ANT_C
condition|)
name|rssi
operator|=
name|MAX
argument_list|(
name|rssi
argument_list|,
name|phy
operator|->
name|rssi
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RECV
argument_list|,
literal|"%s: agc %d mask 0x%x rssi %d %d %d result %d\n"
argument_list|,
name|__func__
argument_list|,
name|agc
argument_list|,
name|mask
argument_list|,
name|phy
operator|->
name|rssi
index|[
literal|0
index|]
argument_list|,
name|phy
operator|->
name|rssi
index|[
literal|2
index|]
argument_list|,
name|phy
operator|->
name|rssi
index|[
literal|4
index|]
argument_list|,
name|rssi
operator|-
name|agc
operator|-
name|IWN_RSSI_TO_DBM
argument_list|)
expr_stmt|;
return|return
name|rssi
operator|-
name|agc
operator|-
name|IWN_RSSI_TO_DBM
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn5000_get_rssi
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_rx_stat
modifier|*
name|stat
parameter_list|)
block|{
name|struct
name|iwn5000_rx_phystat
modifier|*
name|phy
init|=
operator|(
name|void
operator|*
operator|)
name|stat
operator|->
name|phybuf
decl_stmt|;
name|uint8_t
name|agc
decl_stmt|;
name|int
name|rssi
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->Doing %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|agc
operator|=
operator|(
name|le32toh
argument_list|(
name|phy
operator|->
name|agc
argument_list|)
operator|>>
literal|9
operator|)
operator|&
literal|0x7f
expr_stmt|;
name|rssi
operator|=
name|MAX
argument_list|(
name|le16toh
argument_list|(
name|phy
operator|->
name|rssi
index|[
literal|0
index|]
argument_list|)
operator|&
literal|0xff
argument_list|,
name|le16toh
argument_list|(
name|phy
operator|->
name|rssi
index|[
literal|1
index|]
argument_list|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|rssi
operator|=
name|MAX
argument_list|(
name|le16toh
argument_list|(
name|phy
operator|->
name|rssi
index|[
literal|2
index|]
argument_list|)
operator|&
literal|0xff
argument_list|,
name|rssi
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RECV
argument_list|,
literal|"%s: agc %d rssi %d %d %d result %d\n"
argument_list|,
name|__func__
argument_list|,
name|agc
argument_list|,
name|phy
operator|->
name|rssi
index|[
literal|0
index|]
argument_list|,
name|phy
operator|->
name|rssi
index|[
literal|1
index|]
argument_list|,
name|phy
operator|->
name|rssi
index|[
literal|2
index|]
argument_list|,
name|rssi
operator|-
name|agc
operator|-
name|IWN_RSSI_TO_DBM
argument_list|)
expr_stmt|;
return|return
name|rssi
operator|-
name|agc
operator|-
name|IWN_RSSI_TO_DBM
return|;
block|}
end_function

begin_comment
comment|/*  * Retrieve the average noise (in dBm) among receivers.  */
end_comment

begin_function
specifier|static
name|int
name|iwn_get_noise
parameter_list|(
specifier|const
name|struct
name|iwn_rx_general_stats
modifier|*
name|stats
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|total
decl_stmt|,
name|nbant
decl_stmt|,
name|noise
decl_stmt|;
name|total
operator|=
name|nbant
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|noise
operator|=
name|le32toh
argument_list|(
name|stats
operator|->
name|noise
index|[
name|i
index|]
argument_list|)
operator|&
literal|0xff
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|total
operator|+=
name|noise
expr_stmt|;
name|nbant
operator|++
expr_stmt|;
block|}
comment|/* There should be at least one antenna but check anyway. */
return|return
operator|(
name|nbant
operator|==
literal|0
operator|)
condition|?
operator|-
literal|127
else|:
operator|(
name|total
operator|/
name|nbant
operator|)
operator|-
literal|107
return|;
block|}
end_function

begin_comment
comment|/*  * Compute temperature (in degC) from last received statistics.  */
end_comment

begin_function
specifier|static
name|int
name|iwn4965_get_temperature
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwn_ucode_info
modifier|*
name|uc
init|=
operator|&
name|sc
operator|->
name|ucode_info
decl_stmt|;
name|int32_t
name|r1
decl_stmt|,
name|r2
decl_stmt|,
name|r3
decl_stmt|,
name|r4
decl_stmt|,
name|temp
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->Doing %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|r1
operator|=
name|le32toh
argument_list|(
name|uc
operator|->
name|temp
index|[
literal|0
index|]
operator|.
name|chan20MHz
argument_list|)
expr_stmt|;
name|r2
operator|=
name|le32toh
argument_list|(
name|uc
operator|->
name|temp
index|[
literal|1
index|]
operator|.
name|chan20MHz
argument_list|)
expr_stmt|;
name|r3
operator|=
name|le32toh
argument_list|(
name|uc
operator|->
name|temp
index|[
literal|2
index|]
operator|.
name|chan20MHz
argument_list|)
expr_stmt|;
name|r4
operator|=
name|le32toh
argument_list|(
name|sc
operator|->
name|rawtemp
argument_list|)
expr_stmt|;
if|if
condition|(
name|r1
operator|==
name|r3
condition|)
comment|/* Prevents division by 0 (should not happen). */
return|return
literal|0
return|;
comment|/* Sign-extend 23-bit R4 value to 32-bit. */
name|r4
operator|=
operator|(
operator|(
name|r4
operator|&
literal|0xffffff
operator|)
operator|^
literal|0x800000
operator|)
operator|-
literal|0x800000
expr_stmt|;
comment|/* Compute temperature in Kelvin. */
name|temp
operator|=
operator|(
literal|259
operator|*
operator|(
name|r4
operator|-
name|r2
operator|)
operator|)
operator|/
operator|(
name|r3
operator|-
name|r1
operator|)
expr_stmt|;
name|temp
operator|=
operator|(
name|temp
operator|*
literal|97
operator|)
operator|/
literal|100
operator|+
literal|8
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_ANY
argument_list|,
literal|"temperature %dK/%dC\n"
argument_list|,
name|temp
argument_list|,
name|IWN_KTOC
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|IWN_KTOC
argument_list|(
name|temp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn5000_get_temperature
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int32_t
name|temp
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->Doing %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 	 * Temperature is not used by the driver for 5000 Series because 	 * TX power calibration is handled by firmware. 	 */
name|temp
operator|=
name|le32toh
argument_list|(
name|sc
operator|->
name|rawtemp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hw_type
operator|==
name|IWN_HW_REV_TYPE_5150
condition|)
block|{
name|temp
operator|=
operator|(
name|temp
operator|/
operator|-
literal|5
operator|)
operator|+
name|sc
operator|->
name|temp_off
expr_stmt|;
name|temp
operator|=
name|IWN_KTOC
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
return|return
name|temp
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize sensitivity calibration state machine.  */
end_comment

begin_function
specifier|static
name|int
name|iwn_init_sensitivity
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwn_ops
modifier|*
name|ops
init|=
operator|&
name|sc
operator|->
name|ops
decl_stmt|;
name|struct
name|iwn_calib_state
modifier|*
name|calib
init|=
operator|&
name|sc
operator|->
name|calib
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->Doing %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Reset calibration state machine. */
name|memset
argument_list|(
name|calib
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|calib
argument_list|)
argument_list|)
expr_stmt|;
name|calib
operator|->
name|state
operator|=
name|IWN_CALIB_STATE_INIT
expr_stmt|;
name|calib
operator|->
name|cck_state
operator|=
name|IWN_CCK_STATE_HIFA
expr_stmt|;
comment|/* Set initial correlation values. */
name|calib
operator|->
name|ofdm_x1
operator|=
name|sc
operator|->
name|limits
operator|->
name|min_ofdm_x1
expr_stmt|;
name|calib
operator|->
name|ofdm_mrc_x1
operator|=
name|sc
operator|->
name|limits
operator|->
name|min_ofdm_mrc_x1
expr_stmt|;
name|calib
operator|->
name|ofdm_x4
operator|=
name|sc
operator|->
name|limits
operator|->
name|min_ofdm_x4
expr_stmt|;
name|calib
operator|->
name|ofdm_mrc_x4
operator|=
name|sc
operator|->
name|limits
operator|->
name|min_ofdm_mrc_x4
expr_stmt|;
name|calib
operator|->
name|cck_x4
operator|=
literal|125
expr_stmt|;
name|calib
operator|->
name|cck_mrc_x4
operator|=
name|sc
operator|->
name|limits
operator|->
name|min_cck_mrc_x4
expr_stmt|;
name|calib
operator|->
name|energy_cck
operator|=
name|sc
operator|->
name|limits
operator|->
name|energy_cck
expr_stmt|;
comment|/* Write initial sensitivity. */
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_send_sensitivity
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/* Write initial gains. */
if|if
condition|(
operator|(
name|error
operator|=
name|ops
operator|->
name|init_gains
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/* Request statistics at each beacon interval. */
name|flags
operator|=
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s: sending request for statistics\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_GET_STATISTICS
argument_list|,
operator|&
name|flags
argument_list|,
sizeof|sizeof
name|flags
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Collect noise and RSSI statistics for the first 20 beacons received  * after association and use them to determine connected antennas and  * to set differential gains.  */
end_comment

begin_function
specifier|static
name|void
name|iwn_collect_noise
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|iwn_rx_general_stats
modifier|*
name|stats
parameter_list|)
block|{
name|struct
name|iwn_ops
modifier|*
name|ops
init|=
operator|&
name|sc
operator|->
name|ops
decl_stmt|;
name|struct
name|iwn_calib_state
modifier|*
name|calib
init|=
operator|&
name|sc
operator|->
name|calib
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s begin\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Accumulate RSSI and noise for all 3 antennas. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|calib
operator|->
name|rssi
index|[
name|i
index|]
operator|+=
name|le32toh
argument_list|(
name|stats
operator|->
name|rssi
index|[
name|i
index|]
argument_list|)
operator|&
literal|0xff
expr_stmt|;
name|calib
operator|->
name|noise
index|[
name|i
index|]
operator|+=
name|le32toh
argument_list|(
name|stats
operator|->
name|noise
index|[
name|i
index|]
argument_list|)
operator|&
literal|0xff
expr_stmt|;
block|}
comment|/* NB: We update differential gains only once after 20 beacons. */
if|if
condition|(
operator|++
name|calib
operator|->
name|nbeacons
operator|<
literal|20
condition|)
return|return;
comment|/* Determine highest average RSSI. */
name|val
operator|=
name|MAX
argument_list|(
name|calib
operator|->
name|rssi
index|[
literal|0
index|]
argument_list|,
name|calib
operator|->
name|rssi
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|val
operator|=
name|MAX
argument_list|(
name|calib
operator|->
name|rssi
index|[
literal|2
index|]
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Determine which antennas are connected. */
name|sc
operator|->
name|chainmask
operator|=
name|sc
operator|->
name|rxchainmask
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|val
operator|-
name|calib
operator|->
name|rssi
index|[
name|i
index|]
operator|>
literal|15
operator|*
literal|20
condition|)
name|sc
operator|->
name|chainmask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
operator||
name|IWN_DEBUG_XMIT
argument_list|,
literal|"%s: RX chains mask: theoretical=0x%x, actual=0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|rxchainmask
argument_list|,
name|sc
operator|->
name|chainmask
argument_list|)
expr_stmt|;
comment|/* If none of the TX antennas are connected, keep at least one. */
if|if
condition|(
operator|(
name|sc
operator|->
name|chainmask
operator|&
name|sc
operator|->
name|txchainmask
operator|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|chainmask
operator||=
name|IWN_LSB
argument_list|(
name|sc
operator|->
name|txchainmask
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ops
operator|->
name|set_gains
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|calib
operator|->
name|state
operator|=
name|IWN_CALIB_STATE_RUN
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* XXX Disable RX chains with no antennas connected. */
name|sc
operator|->
name|rxon
operator|->
name|rxchain
operator|=
name|htole16
argument_list|(
name|IWN_RXCHAIN_SEL
argument_list|(
name|sc
operator|->
name|chainmask
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_is_scanning
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: is_scanning set, before RXON\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_RXON
argument_list|,
name|sc
operator|->
name|rxon
argument_list|,
name|sc
operator|->
name|rxonsz
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Enable power-saving mode if requested by user. */
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_PMGTON
condition|)
operator|(
name|void
operator|)
name|iwn_set_pslevel
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s: end\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn4965_init_gains
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwn_phy_calib_gain
name|cmd
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->Doing %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|code
operator|=
name|IWN4965_PHY_CALIB_DIFF_GAIN
expr_stmt|;
comment|/* Differential gains initially set to 0 for all 3 antennas. */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s: setting initial differential gains\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_PHY_CALIB
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
name|cmd
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn5000_init_gains
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwn_phy_calib
name|cmd
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->Doing %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|code
operator|=
name|sc
operator|->
name|reset_noise_gain
expr_stmt|;
name|cmd
operator|.
name|ngroups
operator|=
literal|1
expr_stmt|;
name|cmd
operator|.
name|isvalid
operator|=
literal|1
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s: setting initial differential gains\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_PHY_CALIB
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
name|cmd
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn4965_set_gains
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwn_calib_state
modifier|*
name|calib
init|=
operator|&
name|sc
operator|->
name|calib
decl_stmt|;
name|struct
name|iwn_phy_calib_gain
name|cmd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|delta
decl_stmt|,
name|noise
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->Doing %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Get minimal noise among connected antennas. */
name|noise
operator|=
name|INT_MAX
expr_stmt|;
comment|/* NB: There's at least one antenna. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|chainmask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|noise
operator|=
name|MIN
argument_list|(
name|calib
operator|->
name|noise
index|[
name|i
index|]
argument_list|,
name|noise
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|code
operator|=
name|IWN4965_PHY_CALIB_DIFF_GAIN
expr_stmt|;
comment|/* Set differential gains for connected antennas. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|chainmask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
comment|/* Compute attenuation (in unit of 1.5dB). */
name|delta
operator|=
operator|(
name|noise
operator|-
operator|(
name|int32_t
operator|)
name|calib
operator|->
name|noise
index|[
name|i
index|]
operator|)
operator|/
literal|30
expr_stmt|;
comment|/* NB: delta<= 0 */
comment|/* Limit to [-4.5dB,0]. */
name|cmd
operator|.
name|gain
index|[
name|i
index|]
operator|=
name|MIN
argument_list|(
name|abs
argument_list|(
name|delta
argument_list|)
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
name|cmd
operator|.
name|gain
index|[
name|i
index|]
operator||=
literal|1
operator|<<
literal|2
expr_stmt|;
comment|/* sign bit */
block|}
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"setting differential gains Ant A/B/C: %x/%x/%x (%x)\n"
argument_list|,
name|cmd
operator|.
name|gain
index|[
literal|0
index|]
argument_list|,
name|cmd
operator|.
name|gain
index|[
literal|1
index|]
argument_list|,
name|cmd
operator|.
name|gain
index|[
literal|2
index|]
argument_list|,
name|sc
operator|->
name|chainmask
argument_list|)
expr_stmt|;
return|return
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_PHY_CALIB
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
name|cmd
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn5000_set_gains
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwn_calib_state
modifier|*
name|calib
init|=
operator|&
name|sc
operator|->
name|calib
decl_stmt|;
name|struct
name|iwn_phy_calib_gain
name|cmd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ant
decl_stmt|,
name|div
decl_stmt|,
name|delta
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->Doing %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* We collected 20 beacons and !=6050 need a 1.5 factor. */
name|div
operator|=
operator|(
name|sc
operator|->
name|hw_type
operator|==
name|IWN_HW_REV_TYPE_6050
operator|)
condition|?
literal|20
else|:
literal|30
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|code
operator|=
name|sc
operator|->
name|noise_gain
expr_stmt|;
name|cmd
operator|.
name|ngroups
operator|=
literal|1
expr_stmt|;
name|cmd
operator|.
name|isvalid
operator|=
literal|1
expr_stmt|;
comment|/* Get first available RX antenna as referential. */
name|ant
operator|=
name|IWN_LSB
argument_list|(
name|sc
operator|->
name|rxchainmask
argument_list|)
expr_stmt|;
comment|/* Set differential gains for other antennas. */
for|for
control|(
name|i
operator|=
name|ant
operator|+
literal|1
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|chainmask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
comment|/* The delta is relative to antenna "ant". */
name|delta
operator|=
operator|(
operator|(
name|int32_t
operator|)
name|calib
operator|->
name|noise
index|[
name|ant
index|]
operator|-
operator|(
name|int32_t
operator|)
name|calib
operator|->
name|noise
index|[
name|i
index|]
operator|)
operator|/
name|div
expr_stmt|;
comment|/* Limit to [-4.5dB,+4.5dB]. */
name|cmd
operator|.
name|gain
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|MIN
argument_list|(
name|abs
argument_list|(
name|delta
argument_list|)
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
name|cmd
operator|.
name|gain
index|[
name|i
operator|-
literal|1
index|]
operator||=
literal|1
operator|<<
literal|2
expr_stmt|;
comment|/* sign bit */
block|}
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
operator||
name|IWN_DEBUG_XMIT
argument_list|,
literal|"setting differential gains Ant B/C: %x/%x (%x)\n"
argument_list|,
name|cmd
operator|.
name|gain
index|[
literal|0
index|]
argument_list|,
name|cmd
operator|.
name|gain
index|[
literal|1
index|]
argument_list|,
name|sc
operator|->
name|chainmask
argument_list|)
expr_stmt|;
return|return
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_PHY_CALIB
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
name|cmd
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Tune RF RX sensitivity based on the number of false alarms detected  * during the last beacon period.  */
end_comment

begin_function
specifier|static
name|void
name|iwn_tune_sensitivity
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|iwn_rx_stats
modifier|*
name|stats
parameter_list|)
block|{
define|#
directive|define
name|inc
parameter_list|(
name|val
parameter_list|,
name|inc
parameter_list|,
name|max
parameter_list|)
define|\
value|if ((val)< (max)) {			\ 		if ((val)< (max) - (inc))	\ 			(val) += (inc);		\ 		else				\ 			(val) = (max);		\ 		needs_update = 1;		\ 	}
define|#
directive|define
name|dec
parameter_list|(
name|val
parameter_list|,
name|dec
parameter_list|,
name|min
parameter_list|)
define|\
value|if ((val)> (min)) {			\ 		if ((val)> (min) + (dec))	\ 			(val) -= (dec);		\ 		else				\ 			(val) = (min);		\ 		needs_update = 1;		\ 	}
specifier|const
name|struct
name|iwn_sensitivity_limits
modifier|*
name|limits
init|=
name|sc
operator|->
name|limits
decl_stmt|;
name|struct
name|iwn_calib_state
modifier|*
name|calib
init|=
operator|&
name|sc
operator|->
name|calib
decl_stmt|;
name|uint32_t
name|val
decl_stmt|,
name|rxena
decl_stmt|,
name|fa
decl_stmt|;
name|uint32_t
name|energy
index|[
literal|3
index|]
decl_stmt|,
name|energy_min
decl_stmt|;
name|uint8_t
name|noise
index|[
literal|3
index|]
decl_stmt|,
name|noise_ref
decl_stmt|;
name|int
name|i
decl_stmt|,
name|needs_update
init|=
literal|0
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s begin\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Check that we've been enabled long enough. */
if|if
condition|(
operator|(
name|rxena
operator|=
name|le32toh
argument_list|(
name|stats
operator|->
name|general
operator|.
name|load
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s end not so long\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Compute number of false alarms since last call for OFDM. */
name|fa
operator|=
name|le32toh
argument_list|(
name|stats
operator|->
name|ofdm
operator|.
name|bad_plcp
argument_list|)
operator|-
name|calib
operator|->
name|bad_plcp_ofdm
expr_stmt|;
name|fa
operator|+=
name|le32toh
argument_list|(
name|stats
operator|->
name|ofdm
operator|.
name|fa
argument_list|)
operator|-
name|calib
operator|->
name|fa_ofdm
expr_stmt|;
name|fa
operator|*=
literal|200
operator|*
name|IEEE80211_DUR_TU
expr_stmt|;
comment|/* 200TU */
if|if
condition|(
name|fa
operator|>
literal|50
operator|*
name|rxena
condition|)
block|{
comment|/* High false alarm count, decrease sensitivity. */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s: OFDM high false alarm count: %u\n"
argument_list|,
name|__func__
argument_list|,
name|fa
argument_list|)
expr_stmt|;
name|inc
argument_list|(
name|calib
operator|->
name|ofdm_x1
argument_list|,
literal|1
argument_list|,
name|limits
operator|->
name|max_ofdm_x1
argument_list|)
expr_stmt|;
name|inc
argument_list|(
name|calib
operator|->
name|ofdm_mrc_x1
argument_list|,
literal|1
argument_list|,
name|limits
operator|->
name|max_ofdm_mrc_x1
argument_list|)
expr_stmt|;
name|inc
argument_list|(
name|calib
operator|->
name|ofdm_x4
argument_list|,
literal|1
argument_list|,
name|limits
operator|->
name|max_ofdm_x4
argument_list|)
expr_stmt|;
name|inc
argument_list|(
name|calib
operator|->
name|ofdm_mrc_x4
argument_list|,
literal|1
argument_list|,
name|limits
operator|->
name|max_ofdm_mrc_x4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fa
operator|<
literal|5
operator|*
name|rxena
condition|)
block|{
comment|/* Low false alarm count, increase sensitivity. */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s: OFDM low false alarm count: %u\n"
argument_list|,
name|__func__
argument_list|,
name|fa
argument_list|)
expr_stmt|;
name|dec
argument_list|(
name|calib
operator|->
name|ofdm_x1
argument_list|,
literal|1
argument_list|,
name|limits
operator|->
name|min_ofdm_x1
argument_list|)
expr_stmt|;
name|dec
argument_list|(
name|calib
operator|->
name|ofdm_mrc_x1
argument_list|,
literal|1
argument_list|,
name|limits
operator|->
name|min_ofdm_mrc_x1
argument_list|)
expr_stmt|;
name|dec
argument_list|(
name|calib
operator|->
name|ofdm_x4
argument_list|,
literal|1
argument_list|,
name|limits
operator|->
name|min_ofdm_x4
argument_list|)
expr_stmt|;
name|dec
argument_list|(
name|calib
operator|->
name|ofdm_mrc_x4
argument_list|,
literal|1
argument_list|,
name|limits
operator|->
name|min_ofdm_mrc_x4
argument_list|)
expr_stmt|;
block|}
comment|/* Compute maximum noise among 3 receivers. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|noise
index|[
name|i
index|]
operator|=
operator|(
name|le32toh
argument_list|(
name|stats
operator|->
name|general
operator|.
name|noise
index|[
name|i
index|]
argument_list|)
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|val
operator|=
name|MAX
argument_list|(
name|noise
index|[
literal|0
index|]
argument_list|,
name|noise
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|val
operator|=
name|MAX
argument_list|(
name|noise
index|[
literal|2
index|]
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Insert it into our samples table. */
name|calib
operator|->
name|noise_samples
index|[
name|calib
operator|->
name|cur_noise_sample
index|]
operator|=
name|val
expr_stmt|;
name|calib
operator|->
name|cur_noise_sample
operator|=
operator|(
name|calib
operator|->
name|cur_noise_sample
operator|+
literal|1
operator|)
operator|%
literal|20
expr_stmt|;
comment|/* Compute maximum noise among last 20 samples. */
name|noise_ref
operator|=
name|calib
operator|->
name|noise_samples
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
name|noise_ref
operator|=
name|MAX
argument_list|(
name|noise_ref
argument_list|,
name|calib
operator|->
name|noise_samples
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Compute maximum energy among 3 receivers. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|energy
index|[
name|i
index|]
operator|=
name|le32toh
argument_list|(
name|stats
operator|->
name|general
operator|.
name|energy
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|val
operator|=
name|MIN
argument_list|(
name|energy
index|[
literal|0
index|]
argument_list|,
name|energy
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|val
operator|=
name|MIN
argument_list|(
name|energy
index|[
literal|2
index|]
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Insert it into our samples table. */
name|calib
operator|->
name|energy_samples
index|[
name|calib
operator|->
name|cur_energy_sample
index|]
operator|=
name|val
expr_stmt|;
name|calib
operator|->
name|cur_energy_sample
operator|=
operator|(
name|calib
operator|->
name|cur_energy_sample
operator|+
literal|1
operator|)
operator|%
literal|10
expr_stmt|;
comment|/* Compute minimum energy among last 10 samples. */
name|energy_min
operator|=
name|calib
operator|->
name|energy_samples
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
name|energy_min
operator|=
name|MAX
argument_list|(
name|energy_min
argument_list|,
name|calib
operator|->
name|energy_samples
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|energy_min
operator|+=
literal|6
expr_stmt|;
comment|/* Compute number of false alarms since last call for CCK. */
name|fa
operator|=
name|le32toh
argument_list|(
name|stats
operator|->
name|cck
operator|.
name|bad_plcp
argument_list|)
operator|-
name|calib
operator|->
name|bad_plcp_cck
expr_stmt|;
name|fa
operator|+=
name|le32toh
argument_list|(
name|stats
operator|->
name|cck
operator|.
name|fa
argument_list|)
operator|-
name|calib
operator|->
name|fa_cck
expr_stmt|;
name|fa
operator|*=
literal|200
operator|*
name|IEEE80211_DUR_TU
expr_stmt|;
comment|/* 200TU */
if|if
condition|(
name|fa
operator|>
literal|50
operator|*
name|rxena
condition|)
block|{
comment|/* High false alarm count, decrease sensitivity. */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s: CCK high false alarm count: %u\n"
argument_list|,
name|__func__
argument_list|,
name|fa
argument_list|)
expr_stmt|;
name|calib
operator|->
name|cck_state
operator|=
name|IWN_CCK_STATE_HIFA
expr_stmt|;
name|calib
operator|->
name|low_fa
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|calib
operator|->
name|cck_x4
operator|>
literal|160
condition|)
block|{
name|calib
operator|->
name|noise_ref
operator|=
name|noise_ref
expr_stmt|;
if|if
condition|(
name|calib
operator|->
name|energy_cck
operator|>
literal|2
condition|)
name|dec
argument_list|(
name|calib
operator|->
name|energy_cck
argument_list|,
literal|2
argument_list|,
name|energy_min
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|calib
operator|->
name|cck_x4
operator|<
literal|160
condition|)
block|{
name|calib
operator|->
name|cck_x4
operator|=
literal|161
expr_stmt|;
name|needs_update
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|inc
argument_list|(
name|calib
operator|->
name|cck_x4
argument_list|,
literal|3
argument_list|,
name|limits
operator|->
name|max_cck_x4
argument_list|)
expr_stmt|;
name|inc
argument_list|(
name|calib
operator|->
name|cck_mrc_x4
argument_list|,
literal|3
argument_list|,
name|limits
operator|->
name|max_cck_mrc_x4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fa
operator|<
literal|5
operator|*
name|rxena
condition|)
block|{
comment|/* Low false alarm count, increase sensitivity. */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s: CCK low false alarm count: %u\n"
argument_list|,
name|__func__
argument_list|,
name|fa
argument_list|)
expr_stmt|;
name|calib
operator|->
name|cck_state
operator|=
name|IWN_CCK_STATE_LOFA
expr_stmt|;
name|calib
operator|->
name|low_fa
operator|++
expr_stmt|;
if|if
condition|(
name|calib
operator|->
name|cck_state
operator|!=
name|IWN_CCK_STATE_INIT
operator|&&
operator|(
operator|(
operator|(
name|int32_t
operator|)
name|calib
operator|->
name|noise_ref
operator|-
operator|(
name|int32_t
operator|)
name|noise_ref
operator|)
operator|>
literal|2
operator|||
name|calib
operator|->
name|low_fa
operator|>
literal|100
operator|)
condition|)
block|{
name|inc
argument_list|(
name|calib
operator|->
name|energy_cck
argument_list|,
literal|2
argument_list|,
name|limits
operator|->
name|min_energy_cck
argument_list|)
expr_stmt|;
name|dec
argument_list|(
name|calib
operator|->
name|cck_x4
argument_list|,
literal|3
argument_list|,
name|limits
operator|->
name|min_cck_x4
argument_list|)
expr_stmt|;
name|dec
argument_list|(
name|calib
operator|->
name|cck_mrc_x4
argument_list|,
literal|3
argument_list|,
name|limits
operator|->
name|min_cck_mrc_x4
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Not worth to increase or decrease sensitivity. */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s: CCK normal false alarm count: %u\n"
argument_list|,
name|__func__
argument_list|,
name|fa
argument_list|)
expr_stmt|;
name|calib
operator|->
name|low_fa
operator|=
literal|0
expr_stmt|;
name|calib
operator|->
name|noise_ref
operator|=
name|noise_ref
expr_stmt|;
if|if
condition|(
name|calib
operator|->
name|cck_state
operator|==
name|IWN_CCK_STATE_HIFA
condition|)
block|{
comment|/* Previous interval had many false alarms. */
name|dec
argument_list|(
name|calib
operator|->
name|energy_cck
argument_list|,
literal|8
argument_list|,
name|energy_min
argument_list|)
expr_stmt|;
block|}
name|calib
operator|->
name|cck_state
operator|=
name|IWN_CCK_STATE_INIT
expr_stmt|;
block|}
if|if
condition|(
name|needs_update
condition|)
operator|(
name|void
operator|)
name|iwn_send_sensitivity
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s: end\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|dec
undef|#
directive|undef
name|inc
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_send_sensitivity
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwn_calib_state
modifier|*
name|calib
init|=
operator|&
name|sc
operator|->
name|calib
decl_stmt|;
name|struct
name|iwn_enhanced_sensitivity_cmd
name|cmd
decl_stmt|;
name|int
name|len
decl_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|cmd
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_sensitivity_cmd
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|which
operator|=
name|IWN_SENSITIVITY_WORKTBL
expr_stmt|;
comment|/* OFDM modulation. */
name|cmd
operator|.
name|corr_ofdm_x1
operator|=
name|htole16
argument_list|(
name|calib
operator|->
name|ofdm_x1
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|corr_ofdm_mrc_x1
operator|=
name|htole16
argument_list|(
name|calib
operator|->
name|ofdm_mrc_x1
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|corr_ofdm_x4
operator|=
name|htole16
argument_list|(
name|calib
operator|->
name|ofdm_x4
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|corr_ofdm_mrc_x4
operator|=
name|htole16
argument_list|(
name|calib
operator|->
name|ofdm_mrc_x4
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|energy_ofdm
operator|=
name|htole16
argument_list|(
name|sc
operator|->
name|limits
operator|->
name|energy_ofdm
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|energy_ofdm_th
operator|=
name|htole16
argument_list|(
literal|62
argument_list|)
expr_stmt|;
comment|/* CCK modulation. */
name|cmd
operator|.
name|corr_cck_x4
operator|=
name|htole16
argument_list|(
name|calib
operator|->
name|cck_x4
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|corr_cck_mrc_x4
operator|=
name|htole16
argument_list|(
name|calib
operator|->
name|cck_mrc_x4
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|energy_cck
operator|=
name|htole16
argument_list|(
name|calib
operator|->
name|energy_cck
argument_list|)
expr_stmt|;
comment|/* Barker modulation: use default values. */
name|cmd
operator|.
name|corr_barker
operator|=
name|htole16
argument_list|(
literal|190
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|corr_barker_mrc
operator|=
name|htole16
argument_list|(
name|sc
operator|->
name|limits
operator|->
name|barker_mrc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s: set sensitivity %d/%d/%d/%d/%d/%d/%d\n"
argument_list|,
name|__func__
argument_list|,
name|calib
operator|->
name|ofdm_x1
argument_list|,
name|calib
operator|->
name|ofdm_mrc_x1
argument_list|,
name|calib
operator|->
name|ofdm_x4
argument_list|,
name|calib
operator|->
name|ofdm_mrc_x4
argument_list|,
name|calib
operator|->
name|cck_x4
argument_list|,
name|calib
operator|->
name|cck_mrc_x4
argument_list|,
name|calib
operator|->
name|energy_cck
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWN_FLAG_ENH_SENS
operator|)
condition|)
goto|goto
name|send
goto|;
comment|/* Enhanced sensitivity settings. */
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_enhanced_sensitivity_cmd
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|ofdm_det_slope_mrc
operator|=
name|htole16
argument_list|(
literal|668
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|ofdm_det_icept_mrc
operator|=
name|htole16
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|ofdm_det_slope
operator|=
name|htole16
argument_list|(
literal|486
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|ofdm_det_icept
operator|=
name|htole16
argument_list|(
literal|37
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|cck_det_slope_mrc
operator|=
name|htole16
argument_list|(
literal|853
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|cck_det_icept_mrc
operator|=
name|htole16
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|cck_det_slope
operator|=
name|htole16
argument_list|(
literal|476
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|cck_det_icept
operator|=
name|htole16
argument_list|(
literal|99
argument_list|)
expr_stmt|;
name|send
label|:
return|return
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_SET_SENSITIVITY
argument_list|,
operator|&
name|cmd
argument_list|,
name|len
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look at the increase of PLCP errors over time; if it exceeds  * a programmed threshold then trigger an RF retune.  */
end_comment

begin_function
specifier|static
name|void
name|iwn_check_rx_recovery
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_stats
modifier|*
name|rs
parameter_list|)
block|{
name|int32_t
name|delta_ofdm
decl_stmt|,
name|delta_ht
decl_stmt|,
name|delta_cck
decl_stmt|;
name|struct
name|iwn_calib_state
modifier|*
name|calib
init|=
operator|&
name|sc
operator|->
name|calib
decl_stmt|;
name|int
name|delta_ticks
decl_stmt|,
name|cur_ticks
decl_stmt|;
name|int
name|delta_msec
decl_stmt|;
name|int
name|thresh
decl_stmt|;
comment|/* 	 * Calculate the difference between the current and 	 * previous statistics. 	 */
name|delta_cck
operator|=
name|le32toh
argument_list|(
name|rs
operator|->
name|rx
operator|.
name|cck
operator|.
name|bad_plcp
argument_list|)
operator|-
name|calib
operator|->
name|bad_plcp_cck
expr_stmt|;
name|delta_ofdm
operator|=
name|le32toh
argument_list|(
name|rs
operator|->
name|rx
operator|.
name|ofdm
operator|.
name|bad_plcp
argument_list|)
operator|-
name|calib
operator|->
name|bad_plcp_ofdm
expr_stmt|;
name|delta_ht
operator|=
name|le32toh
argument_list|(
name|rs
operator|->
name|rx
operator|.
name|ht
operator|.
name|bad_plcp
argument_list|)
operator|-
name|calib
operator|->
name|bad_plcp_ht
expr_stmt|;
comment|/* 	 * Calculate the delta in time between successive statistics 	 * messages.  Yes, it can roll over; so we make sure that 	 * this doesn't happen. 	 * 	 * XXX go figure out what to do about rollover 	 * XXX go figure out what to do if ticks rolls over to -ve instead! 	 * XXX go stab signed integer overflow undefined-ness in the face. 	 */
name|cur_ticks
operator|=
name|ticks
expr_stmt|;
name|delta_ticks
operator|=
name|cur_ticks
operator|-
name|sc
operator|->
name|last_calib_ticks
expr_stmt|;
comment|/* 	 * If any are negative, then the firmware likely reset; so just 	 * bail.  We'll pick this up next time. 	 */
if|if
condition|(
name|delta_cck
operator|<
literal|0
operator|||
name|delta_ofdm
operator|<
literal|0
operator|||
name|delta_ht
operator|<
literal|0
operator|||
name|delta_ticks
operator|<
literal|0
condition|)
return|return;
comment|/* 	 * delta_ticks is in ticks; we need to convert it up to milliseconds 	 * so we can do some useful math with it. 	 */
name|delta_msec
operator|=
name|ticks_to_msecs
argument_list|(
name|delta_ticks
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate what our threshold is given the current delta_msec. 	 */
name|thresh
operator|=
name|sc
operator|->
name|base_params
operator|->
name|plcp_err_threshold
operator|*
name|delta_msec
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_STATE
argument_list|,
literal|"%s: time delta: %d; cck=%d, ofdm=%d, ht=%d, total=%d, thresh=%d\n"
argument_list|,
name|__func__
argument_list|,
name|delta_msec
argument_list|,
name|delta_cck
argument_list|,
name|delta_ofdm
argument_list|,
name|delta_ht
argument_list|,
operator|(
name|delta_msec
operator|+
name|delta_cck
operator|+
name|delta_ofdm
operator|+
name|delta_ht
operator|)
argument_list|,
name|thresh
argument_list|)
expr_stmt|;
comment|/* 	 * If we need a retune, then schedule a single channel scan 	 * to a channel that isn't the currently active one! 	 * 	 * The math from linux iwlwifi: 	 * 	 * if ((delta * 100 / msecs)> threshold) 	 */
if|if
condition|(
name|thresh
operator|>
literal|0
operator|&&
operator|(
name|delta_cck
operator|+
name|delta_ofdm
operator|+
name|delta_ht
operator|)
operator|*
literal|100
operator|>
name|thresh
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_ANY
argument_list|,
literal|"%s: PLCP error threshold raw (%d) comparison (%d) "
literal|"over limit (%d); retune!\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|delta_cck
operator|+
name|delta_ofdm
operator|+
name|delta_ht
operator|)
argument_list|,
operator|(
name|delta_cck
operator|+
name|delta_ofdm
operator|+
name|delta_ht
operator|)
operator|*
literal|100
argument_list|,
name|thresh
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Set STA mode power saving level (between 0 and 5).  * Level 0 is CAM (Continuously Aware Mode), 5 is for maximum power saving.  */
end_comment

begin_function
specifier|static
name|int
name|iwn_set_pslevel
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|dtim
parameter_list|,
name|int
name|level
parameter_list|,
name|int
name|async
parameter_list|)
block|{
name|struct
name|iwn_pmgt_cmd
name|cmd
decl_stmt|;
specifier|const
name|struct
name|iwn_pmgt
modifier|*
name|pmgt
decl_stmt|;
name|uint32_t
name|max
decl_stmt|,
name|skip_dtim
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_PWRSAVE
argument_list|,
literal|"%s: dtim=%d, level=%d, async=%d\n"
argument_list|,
name|__func__
argument_list|,
name|dtim
argument_list|,
name|level
argument_list|,
name|async
argument_list|)
expr_stmt|;
comment|/* Select which PS parameters to use. */
if|if
condition|(
name|dtim
operator|<=
literal|2
condition|)
name|pmgt
operator|=
operator|&
name|iwn_pmgt
index|[
literal|0
index|]
index|[
name|level
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|dtim
operator|<=
literal|10
condition|)
name|pmgt
operator|=
operator|&
name|iwn_pmgt
index|[
literal|1
index|]
index|[
name|level
index|]
expr_stmt|;
else|else
name|pmgt
operator|=
operator|&
name|iwn_pmgt
index|[
literal|2
index|]
index|[
name|level
index|]
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|!=
literal|0
condition|)
comment|/* not CAM */
name|cmd
operator|.
name|flags
operator||=
name|htole16
argument_list|(
name|IWN_PS_ALLOW_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|==
literal|5
condition|)
name|cmd
operator|.
name|flags
operator||=
name|htole16
argument_list|(
name|IWN_PS_FAST_PD
argument_list|)
expr_stmt|;
comment|/* Retrieve PCIe Active State Power Management (ASPM). */
name|reg
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|sc
operator|->
name|sc_cap_off
operator|+
name|PCIER_LINK_CTL
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|reg
operator|&
name|PCIEM_LINK_CTL_ASPMC_L0S
operator|)
condition|)
comment|/* L0s Entry disabled. */
name|cmd
operator|.
name|flags
operator||=
name|htole16
argument_list|(
name|IWN_PS_PCI_PMGT
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|rxtimeout
operator|=
name|htole32
argument_list|(
name|pmgt
operator|->
name|rxtimeout
operator|*
literal|1024
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|txtimeout
operator|=
name|htole32
argument_list|(
name|pmgt
operator|->
name|txtimeout
operator|*
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtim
operator|==
literal|0
condition|)
block|{
name|dtim
operator|=
literal|1
expr_stmt|;
name|skip_dtim
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|skip_dtim
operator|=
name|pmgt
operator|->
name|skip_dtim
expr_stmt|;
if|if
condition|(
name|skip_dtim
operator|!=
literal|0
condition|)
block|{
name|cmd
operator|.
name|flags
operator||=
name|htole16
argument_list|(
name|IWN_PS_SLEEP_OVER_DTIM
argument_list|)
expr_stmt|;
name|max
operator|=
name|pmgt
operator|->
name|intval
index|[
literal|4
index|]
expr_stmt|;
if|if
condition|(
name|max
operator|==
operator|(
name|uint32_t
operator|)
operator|-
literal|1
condition|)
name|max
operator|=
name|dtim
operator|*
operator|(
name|skip_dtim
operator|+
literal|1
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|max
operator|>
name|dtim
condition|)
name|max
operator|=
name|rounddown
argument_list|(
name|max
argument_list|,
name|dtim
argument_list|)
expr_stmt|;
block|}
else|else
name|max
operator|=
name|dtim
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
name|cmd
operator|.
name|intval
index|[
name|i
index|]
operator|=
name|htole32
argument_list|(
name|MIN
argument_list|(
name|max
argument_list|,
name|pmgt
operator|->
name|intval
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"setting power saving level to %d\n"
argument_list|,
name|level
argument_list|)
expr_stmt|;
return|return
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_SET_POWER_MODE
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
name|cmd
argument_list|,
name|async
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_send_btcoex
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwn_bluetooth
name|cmd
decl_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|flags
operator|=
name|IWN_BT_COEX_CHAN_ANN
operator||
name|IWN_BT_COEX_BT_PRIO
expr_stmt|;
name|cmd
operator|.
name|lead_time
operator|=
name|IWN_BT_LEAD_TIME_DEF
expr_stmt|;
name|cmd
operator|.
name|max_kill
operator|=
name|IWN_BT_MAX_KILL_DEF
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"%s: configuring bluetooth coexistence\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_BT_COEX
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_send_advanced_btcoex
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|static
specifier|const
name|uint32_t
name|btcoex_3wire
index|[
literal|12
index|]
init|=
block|{
literal|0xaaaaaaaa
block|,
literal|0xaaaaaaaa
block|,
literal|0xaeaaaaaa
block|,
literal|0xaaaaaaaa
block|,
literal|0xcc00ff28
block|,
literal|0x0000aaaa
block|,
literal|0xcc00aaaa
block|,
literal|0x0000aaaa
block|,
literal|0xc0004000
block|,
literal|0x00004000
block|,
literal|0xf0005000
block|,
literal|0xf0005000
block|, 	}
decl_stmt|;
name|struct
name|iwn6000_btcoex_config
name|btconfig
decl_stmt|;
name|struct
name|iwn2000_btcoex_config
name|btconfig2k
decl_stmt|;
name|struct
name|iwn_btcoex_priotable
name|btprio
decl_stmt|;
name|struct
name|iwn_btcoex_prot
name|btprot
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|uint8_t
name|flags
decl_stmt|;
name|memset
argument_list|(
operator|&
name|btconfig
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|btconfig
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|btconfig2k
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|btconfig2k
argument_list|)
expr_stmt|;
name|flags
operator|=
name|IWN_BT_FLAG_COEX6000_MODE_3W
operator|<<
name|IWN_BT_FLAG_COEX6000_MODE_SHIFT
expr_stmt|;
comment|// Done as is in linux kernel 3.2
if|if
condition|(
name|sc
operator|->
name|base_params
operator|->
name|bt_sco_disable
condition|)
name|flags
operator|&=
operator|~
name|IWN_BT_FLAG_SYNC_2_BT_DISABLE
expr_stmt|;
else|else
name|flags
operator||=
name|IWN_BT_FLAG_SYNC_2_BT_DISABLE
expr_stmt|;
name|flags
operator||=
name|IWN_BT_FLAG_COEX6000_CHAN_INHIBITION
expr_stmt|;
comment|/* Default flags result is 145 as old value */
comment|/* 	 * Flags value has to be review. Values must change if we 	 * which to disable it 	 */
if|if
condition|(
name|sc
operator|->
name|base_params
operator|->
name|bt_session_2
condition|)
block|{
name|btconfig2k
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
name|btconfig2k
operator|.
name|max_kill
operator|=
literal|5
expr_stmt|;
name|btconfig2k
operator|.
name|bt3_t7_timer
operator|=
literal|1
expr_stmt|;
name|btconfig2k
operator|.
name|kill_ack
operator|=
name|htole32
argument_list|(
literal|0xffff0000
argument_list|)
expr_stmt|;
name|btconfig2k
operator|.
name|kill_cts
operator|=
name|htole32
argument_list|(
literal|0xffff0000
argument_list|)
expr_stmt|;
name|btconfig2k
operator|.
name|sample_time
operator|=
literal|2
expr_stmt|;
name|btconfig2k
operator|.
name|bt3_t2_timer
operator|=
literal|0xc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|12
condition|;
name|i
operator|++
control|)
name|btconfig2k
operator|.
name|lookup_table
index|[
name|i
index|]
operator|=
name|htole32
argument_list|(
name|btcoex_3wire
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|btconfig2k
operator|.
name|valid
operator|=
name|htole16
argument_list|(
literal|0xff
argument_list|)
expr_stmt|;
name|btconfig2k
operator|.
name|prio_boost
operator|=
name|htole32
argument_list|(
literal|0xf0
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"%s: configuring advanced bluetooth coexistence"
literal|" session 2, flags : 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_BT_COEX
argument_list|,
operator|&
name|btconfig2k
argument_list|,
sizeof|sizeof
argument_list|(
name|btconfig2k
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|btconfig
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
name|btconfig
operator|.
name|max_kill
operator|=
literal|5
expr_stmt|;
name|btconfig
operator|.
name|bt3_t7_timer
operator|=
literal|1
expr_stmt|;
name|btconfig
operator|.
name|kill_ack
operator|=
name|htole32
argument_list|(
literal|0xffff0000
argument_list|)
expr_stmt|;
name|btconfig
operator|.
name|kill_cts
operator|=
name|htole32
argument_list|(
literal|0xffff0000
argument_list|)
expr_stmt|;
name|btconfig
operator|.
name|sample_time
operator|=
literal|2
expr_stmt|;
name|btconfig
operator|.
name|bt3_t2_timer
operator|=
literal|0xc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|12
condition|;
name|i
operator|++
control|)
name|btconfig
operator|.
name|lookup_table
index|[
name|i
index|]
operator|=
name|htole32
argument_list|(
name|btcoex_3wire
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|btconfig
operator|.
name|valid
operator|=
name|htole16
argument_list|(
literal|0xff
argument_list|)
expr_stmt|;
name|btconfig
operator|.
name|prio_boost
operator|=
literal|0xf0
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"%s: configuring advanced bluetooth coexistence,"
literal|" flags : 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_BT_COEX
argument_list|,
operator|&
name|btconfig
argument_list|,
sizeof|sizeof
argument_list|(
name|btconfig
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|memset
argument_list|(
operator|&
name|btprio
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|btprio
argument_list|)
expr_stmt|;
name|btprio
operator|.
name|calib_init1
operator|=
literal|0x6
expr_stmt|;
name|btprio
operator|.
name|calib_init2
operator|=
literal|0x7
expr_stmt|;
name|btprio
operator|.
name|calib_periodic_low1
operator|=
literal|0x2
expr_stmt|;
name|btprio
operator|.
name|calib_periodic_low2
operator|=
literal|0x3
expr_stmt|;
name|btprio
operator|.
name|calib_periodic_high1
operator|=
literal|0x4
expr_stmt|;
name|btprio
operator|.
name|calib_periodic_high2
operator|=
literal|0x5
expr_stmt|;
name|btprio
operator|.
name|dtim
operator|=
literal|0x6
expr_stmt|;
name|btprio
operator|.
name|scan52
operator|=
literal|0x8
expr_stmt|;
name|btprio
operator|.
name|scan24
operator|=
literal|0xa
expr_stmt|;
name|error
operator|=
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_BT_COEX_PRIOTABLE
argument_list|,
operator|&
name|btprio
argument_list|,
sizeof|sizeof
argument_list|(
name|btprio
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/* Force BT state machine change. */
name|memset
argument_list|(
operator|&
name|btprot
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|btprot
argument_list|)
expr_stmt|;
name|btprot
operator|.
name|open
operator|=
literal|1
expr_stmt|;
name|btprot
operator|.
name|type
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_BT_COEX_PROT
argument_list|,
operator|&
name|btprot
argument_list|,
sizeof|sizeof
argument_list|(
name|btprot
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|btprot
operator|.
name|open
operator|=
literal|0
expr_stmt|;
return|return
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_BT_COEX_PROT
argument_list|,
operator|&
name|btprot
argument_list|,
sizeof|sizeof
argument_list|(
name|btprot
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn5000_runtime_calib
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwn5000_calib_config
name|cmd
decl_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|ucode
operator|.
name|once
operator|.
name|enable
operator|=
literal|0xffffffff
expr_stmt|;
name|cmd
operator|.
name|ucode
operator|.
name|once
operator|.
name|start
operator|=
name|IWN5000_CALIB_DC
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s: configuring runtime calibration\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN5000_CMD_CALIB_CONFIG
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|iwn_get_rxon_ht_flags
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|uint32_t
name|htflags
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|IEEE80211_IS_CHAN_HT
argument_list|(
name|c
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|htflags
operator||=
name|IWN_RXON_HT_PROTMODE
argument_list|(
name|ic
operator|->
name|ic_curhtprotmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|c
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|ic
operator|->
name|ic_curhtprotmode
condition|)
block|{
case|case
name|IEEE80211_HTINFO_OPMODE_HT20PR
case|:
name|htflags
operator||=
name|IWN_RXON_HT_MODEPURE40
expr_stmt|;
break|break;
default|default:
name|htflags
operator||=
name|IWN_RXON_HT_MODEMIXED
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40D
argument_list|(
name|c
argument_list|)
condition|)
name|htflags
operator||=
name|IWN_RXON_HT_HT40MINUS
expr_stmt|;
return|return
operator|(
name|htflags
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_check_bss_filter
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
operator|(
name|sc
operator|->
name|rxon
operator|->
name|filter
operator|&
name|htole32
argument_list|(
name|IWN_FILTER_BSS
argument_list|)
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn4965_rxon_assoc
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|async
parameter_list|)
block|{
name|struct
name|iwn4965_rxon_assoc
name|cmd
decl_stmt|;
name|struct
name|iwn_rxon
modifier|*
name|rxon
init|=
name|sc
operator|->
name|rxon
decl_stmt|;
name|cmd
operator|.
name|flags
operator|=
name|rxon
operator|->
name|flags
expr_stmt|;
name|cmd
operator|.
name|filter
operator|=
name|rxon
operator|->
name|filter
expr_stmt|;
name|cmd
operator|.
name|ofdm_mask
operator|=
name|rxon
operator|->
name|ofdm_mask
expr_stmt|;
name|cmd
operator|.
name|cck_mask
operator|=
name|rxon
operator|->
name|cck_mask
expr_stmt|;
name|cmd
operator|.
name|ht_single_mask
operator|=
name|rxon
operator|->
name|ht_single_mask
expr_stmt|;
name|cmd
operator|.
name|ht_dual_mask
operator|=
name|rxon
operator|->
name|ht_dual_mask
expr_stmt|;
name|cmd
operator|.
name|rxchain
operator|=
name|rxon
operator|->
name|rxchain
expr_stmt|;
name|cmd
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_RXON_ASSOC
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|,
name|async
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn5000_rxon_assoc
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|async
parameter_list|)
block|{
name|struct
name|iwn5000_rxon_assoc
name|cmd
decl_stmt|;
name|struct
name|iwn_rxon
modifier|*
name|rxon
init|=
name|sc
operator|->
name|rxon
decl_stmt|;
name|cmd
operator|.
name|flags
operator|=
name|rxon
operator|->
name|flags
expr_stmt|;
name|cmd
operator|.
name|filter
operator|=
name|rxon
operator|->
name|filter
expr_stmt|;
name|cmd
operator|.
name|ofdm_mask
operator|=
name|rxon
operator|->
name|ofdm_mask
expr_stmt|;
name|cmd
operator|.
name|cck_mask
operator|=
name|rxon
operator|->
name|cck_mask
expr_stmt|;
name|cmd
operator|.
name|reserved1
operator|=
literal|0
expr_stmt|;
name|cmd
operator|.
name|ht_single_mask
operator|=
name|rxon
operator|->
name|ht_single_mask
expr_stmt|;
name|cmd
operator|.
name|ht_dual_mask
operator|=
name|rxon
operator|->
name|ht_dual_mask
expr_stmt|;
name|cmd
operator|.
name|ht_triple_mask
operator|=
name|rxon
operator|->
name|ht_triple_mask
expr_stmt|;
name|cmd
operator|.
name|reserved2
operator|=
literal|0
expr_stmt|;
name|cmd
operator|.
name|rxchain
operator|=
name|rxon
operator|->
name|rxchain
expr_stmt|;
name|cmd
operator|.
name|acquisition
operator|=
name|rxon
operator|->
name|acquisition
expr_stmt|;
name|cmd
operator|.
name|reserved3
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_RXON_ASSOC
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|,
name|async
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_send_rxon
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|assoc
parameter_list|,
name|int
name|async
parameter_list|)
block|{
name|struct
name|iwn_ops
modifier|*
name|ops
init|=
operator|&
name|sc
operator|->
name|ops
decl_stmt|;
name|int
name|error
decl_stmt|;
name|IWN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|assoc
operator|&&
name|iwn_check_bss_filter
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|ops
operator|->
name|rxon_assoc
argument_list|(
name|sc
argument_list|,
name|async
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: RXON_ASSOC command failed, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|sc_is_scanning
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: is_scanning set, before RXON\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_RXON
argument_list|,
name|sc
operator|->
name|rxon
argument_list|,
name|sc
operator|->
name|rxonsz
argument_list|,
name|async
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: RXON command failed, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 		 * Reconfiguring RXON clears the firmware nodes table so 		 * we must add the broadcast node again. 		 */
if|if
condition|(
name|iwn_check_bss_filter
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|error
operator|=
name|iwn_add_broadcast_node
argument_list|(
name|sc
argument_list|,
name|async
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not add broadcast node, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* Configuration has changed, set TX power accordingly. */
if|if
condition|(
operator|(
name|error
operator|=
name|ops
operator|->
name|set_txpower
argument_list|(
name|sc
argument_list|,
name|async
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not set TX power, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_config
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|macaddr
decl_stmt|;
name|uint32_t
name|txmask
decl_stmt|;
name|uint16_t
name|rxchain
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s begin\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|base_params
operator|->
name|calib_need
operator|&
name|IWN_FLG_NEED_PHY_CALIB_TEMP_OFFSET
operator|)
operator|&&
operator|(
name|sc
operator|->
name|base_params
operator|->
name|calib_need
operator|&
name|IWN_FLG_NEED_PHY_CALIB_TEMP_OFFSETv2
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: temp_offset and temp_offsetv2 are"
literal|" exclusive each together. Review NIC config file. Conf"
literal|" :  0x%08x Flags :  0x%08x  \n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|base_params
operator|->
name|calib_need
argument_list|,
operator|(
name|IWN_FLG_NEED_PHY_CALIB_TEMP_OFFSET
operator||
name|IWN_FLG_NEED_PHY_CALIB_TEMP_OFFSETv2
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Compute temperature calib if needed. Will be send by send calib */
if|if
condition|(
name|sc
operator|->
name|base_params
operator|->
name|calib_need
operator|&
name|IWN_FLG_NEED_PHY_CALIB_TEMP_OFFSET
condition|)
block|{
name|error
operator|=
name|iwn5000_temp_offset_calib
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not set temperature offset\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|base_params
operator|->
name|calib_need
operator|&
name|IWN_FLG_NEED_PHY_CALIB_TEMP_OFFSETv2
condition|)
block|{
name|error
operator|=
name|iwn5000_temp_offset_calibv2
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not compute temperature offset v2\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|hw_type
operator|==
name|IWN_HW_REV_TYPE_6050
condition|)
block|{
comment|/* Configure runtime DC calibration. */
name|error
operator|=
name|iwn5000_runtime_calib
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not configure runtime calibration\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
comment|/* Configure valid TX chains for>=5000 Series. */
if|if
condition|(
name|sc
operator|->
name|hw_type
operator|!=
name|IWN_HW_REV_TYPE_4965
operator|&&
name|IWN_UCODE_API
argument_list|(
name|sc
operator|->
name|ucode_rev
argument_list|)
operator|>
literal|1
condition|)
block|{
name|txmask
operator|=
name|htole32
argument_list|(
name|sc
operator|->
name|txchainmask
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
operator||
name|IWN_DEBUG_XMIT
argument_list|,
literal|"%s: configuring valid TX chains 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|txmask
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN5000_CMD_TX_ANT_CONFIG
argument_list|,
operator|&
name|txmask
argument_list|,
sizeof|sizeof
name|txmask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not configure valid TX chains, "
literal|"error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
comment|/* Configure bluetooth coexistence. */
name|error
operator|=
literal|0
expr_stmt|;
comment|/* Configure bluetooth coexistence if needed. */
if|if
condition|(
name|sc
operator|->
name|base_params
operator|->
name|bt_mode
operator|==
name|IWN_BT_ADVANCED
condition|)
name|error
operator|=
name|iwn_send_advanced_btcoex
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|base_params
operator|->
name|bt_mode
operator|==
name|IWN_BT_SIMPLE
condition|)
name|error
operator|=
name|iwn_send_btcoex
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not configure bluetooth coexistence, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Set mode, channel, RX filter and enable RX. */
name|sc
operator|->
name|rxon
operator|=
operator|&
name|sc
operator|->
name|rx_on
index|[
name|IWN_RXON_BSS_CTX
index|]
expr_stmt|;
name|memset
argument_list|(
name|sc
operator|->
name|rxon
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iwn_rxon
argument_list|)
argument_list|)
expr_stmt|;
name|macaddr
operator|=
name|vap
condition|?
name|vap
operator|->
name|iv_myaddr
else|:
name|ic
operator|->
name|ic_macaddr
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|sc
operator|->
name|rxon
operator|->
name|myaddr
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|sc
operator|->
name|rxon
operator|->
name|wlap
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rxon
operator|->
name|chan
operator|=
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rxon
operator|->
name|flags
operator|=
name|htole32
argument_list|(
name|IWN_RXON_TSF
operator||
name|IWN_RXON_CTS_TO_SELF
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
condition|)
name|sc
operator|->
name|rxon
operator|->
name|flags
operator||=
name|htole32
argument_list|(
name|IWN_RXON_AUTO
operator||
name|IWN_RXON_24GHZ
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rxon
operator|->
name|filter
operator|=
name|htole32
argument_list|(
name|IWN_FILTER_MULTICAST
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ic
operator|->
name|ic_opmode
condition|)
block|{
case|case
name|IEEE80211_M_STA
case|:
name|sc
operator|->
name|rxon
operator|->
name|mode
operator|=
name|IWN_MODE_STA
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_MONITOR
case|:
name|sc
operator|->
name|rxon
operator|->
name|mode
operator|=
name|IWN_MODE_MONITOR
expr_stmt|;
break|break;
default|default:
comment|/* Should not get there. */
break|break;
block|}
name|iwn_set_promisc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rxon
operator|->
name|cck_mask
operator|=
literal|0x0f
expr_stmt|;
comment|/* not yet negotiated */
name|sc
operator|->
name|rxon
operator|->
name|ofdm_mask
operator|=
literal|0xff
expr_stmt|;
comment|/* not yet negotiated */
name|sc
operator|->
name|rxon
operator|->
name|ht_single_mask
operator|=
literal|0xff
expr_stmt|;
name|sc
operator|->
name|rxon
operator|->
name|ht_dual_mask
operator|=
literal|0xff
expr_stmt|;
name|sc
operator|->
name|rxon
operator|->
name|ht_triple_mask
operator|=
literal|0xff
expr_stmt|;
comment|/* 	 * In active association mode, ensure that 	 * all the receive chains are enabled. 	 * 	 * Since we're not yet doing SMPS, don't allow the 	 * number of idle RX chains to be less than the active 	 * number. 	 */
name|rxchain
operator|=
name|IWN_RXCHAIN_VALID
argument_list|(
name|sc
operator|->
name|rxchainmask
argument_list|)
operator||
name|IWN_RXCHAIN_MIMO_COUNT
argument_list|(
name|sc
operator|->
name|nrxchains
argument_list|)
operator||
name|IWN_RXCHAIN_IDLE_COUNT
argument_list|(
name|sc
operator|->
name|nrxchains
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rxon
operator|->
name|rxchain
operator|=
name|htole16
argument_list|(
name|rxchain
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
operator||
name|IWN_DEBUG_XMIT
argument_list|,
literal|"%s: rxchainmask=0x%x, nrxchains=%d\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|rxchainmask
argument_list|,
name|sc
operator|->
name|nrxchains
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rxon
operator|->
name|flags
operator||=
name|htole32
argument_list|(
name|iwn_get_rxon_ht_flags
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"%s: setting configuration; flags=0x%08x\n"
argument_list|,
name|__func__
argument_list|,
name|le32toh
argument_list|(
name|sc
operator|->
name|rxon
operator|->
name|flags
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_send_rxon
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not send RXON\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_set_critical_temp
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not set critical temperature\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Set power saving level to CAM during initialization. */
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_set_pslevel
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not set power saving level\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s: end\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|uint16_t
name|iwn_get_active_dwell_time
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|,
name|uint8_t
name|n_probes
parameter_list|)
block|{
comment|/* No channel? Default to 2GHz settings */
if|if
condition|(
name|c
operator|==
name|NULL
operator|||
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|c
argument_list|)
condition|)
block|{
return|return
operator|(
name|IWN_ACTIVE_DWELL_TIME_2GHZ
operator|+
name|IWN_ACTIVE_DWELL_FACTOR_2GHZ
operator|*
operator|(
name|n_probes
operator|+
literal|1
operator|)
operator|)
return|;
block|}
comment|/* 5GHz dwell time */
return|return
operator|(
name|IWN_ACTIVE_DWELL_TIME_5GHZ
operator|+
name|IWN_ACTIVE_DWELL_FACTOR_5GHZ
operator|*
operator|(
name|n_probes
operator|+
literal|1
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Limit the total dwell time to 85% of the beacon interval.  *  * Returns the dwell time in milliseconds.  */
end_comment

begin_function
specifier|static
name|uint16_t
name|iwn_limit_dwell
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|dwell_time
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|NULL
decl_stmt|;
name|int
name|bintval
init|=
literal|0
decl_stmt|;
comment|/* bintval is in TU (1.024mS) */
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
condition|)
block|{
name|vap
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
expr_stmt|;
name|bintval
operator|=
name|vap
operator|->
name|iv_bss
operator|->
name|ni_intval
expr_stmt|;
block|}
comment|/* 	 * If it's non-zero, we should calculate the minimum of 	 * it and the DWELL_BASE. 	 * 	 * XXX Yes, the math should take into account that bintval 	 * is 1.024mS, not 1mS.. 	 */
if|if
condition|(
name|bintval
operator|>
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_SCAN
argument_list|,
literal|"%s: bintval=%d\n"
argument_list|,
name|__func__
argument_list|,
name|bintval
argument_list|)
expr_stmt|;
return|return
operator|(
name|MIN
argument_list|(
name|IWN_PASSIVE_DWELL_BASE
argument_list|,
operator|(
operator|(
name|bintval
operator|*
literal|85
operator|)
operator|/
literal|100
operator|)
argument_list|)
operator|)
return|;
block|}
comment|/* No association context? Default */
return|return
operator|(
name|IWN_PASSIVE_DWELL_BASE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint16_t
name|iwn_get_passive_dwell_time
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|)
block|{
name|uint16_t
name|passive
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
operator|||
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|passive
operator|=
name|IWN_PASSIVE_DWELL_BASE
operator|+
name|IWN_PASSIVE_DWELL_TIME_2GHZ
expr_stmt|;
block|}
else|else
block|{
name|passive
operator|=
name|IWN_PASSIVE_DWELL_BASE
operator|+
name|IWN_PASSIVE_DWELL_TIME_5GHZ
expr_stmt|;
block|}
comment|/* Clamp to the beacon interval if we're associated */
return|return
operator|(
name|iwn_limit_dwell
argument_list|(
name|sc
argument_list|,
name|passive
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_scan
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|vap
operator|->
name|iv_bss
decl_stmt|;
name|struct
name|iwn_scan_hdr
modifier|*
name|hdr
decl_stmt|;
name|struct
name|iwn_cmd_data
modifier|*
name|tx
decl_stmt|;
name|struct
name|iwn_scan_essid
modifier|*
name|essid
decl_stmt|;
name|struct
name|iwn_scan_chan
modifier|*
name|chan
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|struct
name|ieee80211_rateset
modifier|*
name|rs
decl_stmt|;
name|uint8_t
modifier|*
name|buf
decl_stmt|,
modifier|*
name|frm
decl_stmt|;
name|uint16_t
name|rxchain
decl_stmt|;
name|uint8_t
name|txant
decl_stmt|;
name|int
name|buflen
decl_stmt|,
name|error
decl_stmt|;
name|int
name|is_active
decl_stmt|;
name|uint16_t
name|dwell_active
decl_stmt|,
name|dwell_passive
decl_stmt|;
name|uint32_t
name|extra
decl_stmt|,
name|scan_service_time
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s begin\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 	 * We are absolutely not allowed to send a scan command when another 	 * scan command is pending. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_is_scanning
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: called whilst scanning!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
comment|/* Assign the scan channel */
name|c
operator|=
name|ic
operator|->
name|ic_curchan
expr_stmt|;
name|sc
operator|->
name|rxon
operator|=
operator|&
name|sc
operator|->
name|rx_on
index|[
name|IWN_RXON_BSS_CTX
index|]
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|IWN_SCAN_MAXSZ
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not allocate buffer for scan command\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|hdr
operator|=
operator|(
expr|struct
name|iwn_scan_hdr
operator|*
operator|)
name|buf
expr_stmt|;
comment|/* 	 * Move to the next channel if no frames are received within 10ms 	 * after sending the probe request. 	 */
name|hdr
operator|->
name|quiet_time
operator|=
name|htole16
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* timeout in milliseconds */
name|hdr
operator|->
name|quiet_threshold
operator|=
name|htole16
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* min # of packets */
comment|/* 	 * Max needs to be greater than active and passive and quiet! 	 * It's also in microseconds! 	 */
name|hdr
operator|->
name|max_svc
operator|=
name|htole32
argument_list|(
literal|250
operator|*
literal|1024
argument_list|)
expr_stmt|;
comment|/* 	 * Reset scan: interval=100 	 * Normal scan: interval=becaon interval 	 * suspend_time: 100 (TU) 	 * 	 */
name|extra
operator|=
operator|(
literal|100
comment|/* suspend_time */
operator|/
literal|100
comment|/* beacon interval */
operator|)
operator|<<
literal|22
expr_stmt|;
comment|//scan_service_time = extra | ((100 /* susp */ % 100 /* int */) * 1024);
name|scan_service_time
operator|=
operator|(
literal|4
operator|<<
literal|22
operator|)
operator||
operator|(
literal|100
operator|*
literal|1024
operator|)
expr_stmt|;
comment|/* Hardcode for now! */
name|hdr
operator|->
name|pause_svc
operator|=
name|htole32
argument_list|(
name|scan_service_time
argument_list|)
expr_stmt|;
comment|/* Select antennas for scanning. */
name|rxchain
operator|=
name|IWN_RXCHAIN_VALID
argument_list|(
name|sc
operator|->
name|rxchainmask
argument_list|)
operator||
name|IWN_RXCHAIN_FORCE_MIMO_SEL
argument_list|(
name|sc
operator|->
name|rxchainmask
argument_list|)
operator||
name|IWN_RXCHAIN_DRIVER_FORCE
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_A
argument_list|(
name|c
argument_list|)
operator|&&
name|sc
operator|->
name|hw_type
operator|==
name|IWN_HW_REV_TYPE_4965
condition|)
block|{
comment|/* Ant A must be avoided in 5GHz because of an HW bug. */
name|rxchain
operator||=
name|IWN_RXCHAIN_FORCE_SEL
argument_list|(
name|IWN_ANT_B
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Use all available RX antennas. */
name|rxchain
operator||=
name|IWN_RXCHAIN_FORCE_SEL
argument_list|(
name|sc
operator|->
name|rxchainmask
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|rxchain
operator|=
name|htole16
argument_list|(
name|rxchain
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|filter
operator|=
name|htole32
argument_list|(
name|IWN_FILTER_MULTICAST
operator||
name|IWN_FILTER_BEACON
argument_list|)
expr_stmt|;
name|tx
operator|=
operator|(
expr|struct
name|iwn_cmd_data
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
expr_stmt|;
name|tx
operator|->
name|flags
operator|=
name|htole32
argument_list|(
name|IWN_TX_AUTO_SEQ
argument_list|)
expr_stmt|;
name|tx
operator|->
name|id
operator|=
name|sc
operator|->
name|broadcast_id
expr_stmt|;
name|tx
operator|->
name|lifetime
operator|=
name|htole32
argument_list|(
name|IWN_LIFETIME_INFINITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* Send probe requests at 6Mbps. */
name|tx
operator|->
name|rate
operator|=
name|htole32
argument_list|(
literal|0xd
argument_list|)
expr_stmt|;
name|rs
operator|=
operator|&
name|ic
operator|->
name|ic_sup_rates
index|[
name|IEEE80211_MODE_11A
index|]
expr_stmt|;
block|}
else|else
block|{
name|hdr
operator|->
name|flags
operator|=
name|htole32
argument_list|(
name|IWN_RXON_24GHZ
operator||
name|IWN_RXON_AUTO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hw_type
operator|==
name|IWN_HW_REV_TYPE_4965
operator|&&
name|sc
operator|->
name|rxon
operator|->
name|associd
operator|&&
name|sc
operator|->
name|rxon
operator|->
name|chan
operator|>
literal|14
condition|)
name|tx
operator|->
name|rate
operator|=
name|htole32
argument_list|(
literal|0xd
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Send probe requests at 1Mbps. */
name|tx
operator|->
name|rate
operator|=
name|htole32
argument_list|(
literal|10
operator||
name|IWN_RFLAG_CCK
argument_list|)
expr_stmt|;
block|}
name|rs
operator|=
operator|&
name|ic
operator|->
name|ic_sup_rates
index|[
name|IEEE80211_MODE_11G
index|]
expr_stmt|;
block|}
comment|/* Use the first valid TX antenna. */
name|txant
operator|=
name|IWN_LSB
argument_list|(
name|sc
operator|->
name|txchainmask
argument_list|)
expr_stmt|;
name|tx
operator|->
name|rate
operator||=
name|htole32
argument_list|(
name|IWN_RFLAG_ANT
argument_list|(
name|txant
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Only do active scanning if we're announcing a probe request 	 * for a given SSID (or more, if we ever add it to the driver.) 	 */
name|is_active
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If we're scanning for a specific SSID, add it to the command. 	 * 	 * XXX maybe look at adding support for scanning multiple SSIDs? 	 */
name|essid
operator|=
operator|(
expr|struct
name|iwn_scan_essid
operator|*
operator|)
operator|(
name|tx
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|ss
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ss
operator|->
name|ss_ssid
index|[
literal|0
index|]
operator|.
name|len
operator|!=
literal|0
condition|)
block|{
name|essid
index|[
literal|0
index|]
operator|.
name|id
operator|=
name|IEEE80211_ELEMID_SSID
expr_stmt|;
name|essid
index|[
literal|0
index|]
operator|.
name|len
operator|=
name|ss
operator|->
name|ss_ssid
index|[
literal|0
index|]
operator|.
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|essid
index|[
literal|0
index|]
operator|.
name|data
argument_list|,
name|ss
operator|->
name|ss_ssid
index|[
literal|0
index|]
operator|.
name|ssid
argument_list|,
name|ss
operator|->
name|ss_ssid
index|[
literal|0
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_SCAN
argument_list|,
literal|"%s: ssid_len=%d, ssid=%*s\n"
argument_list|,
name|__func__
argument_list|,
name|ss
operator|->
name|ss_ssid
index|[
literal|0
index|]
operator|.
name|len
argument_list|,
name|ss
operator|->
name|ss_ssid
index|[
literal|0
index|]
operator|.
name|len
argument_list|,
name|ss
operator|->
name|ss_ssid
index|[
literal|0
index|]
operator|.
name|ssid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|ss_nssid
operator|>
literal|0
condition|)
name|is_active
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Build a probe request frame.  Most of the following code is a 	 * copy& paste of what is done in net80211. 	 */
name|wh
operator|=
operator|(
expr|struct
name|ieee80211_frame
operator|*
operator|)
operator|(
name|essid
operator|+
literal|20
operator|)
expr_stmt|;
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|=
name|IEEE80211_FC0_VERSION_0
operator||
name|IEEE80211_FC0_TYPE_MGT
operator||
name|IEEE80211_FC0_SUBTYPE_PROBE_REQ
expr_stmt|;
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_DIR_NODS
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|vap
operator|->
name|iv_ifp
operator|->
name|if_broadcastaddr
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|IF_LLADDR
argument_list|(
name|vap
operator|->
name|iv_ifp
argument_list|)
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|vap
operator|->
name|iv_ifp
operator|->
name|if_broadcastaddr
argument_list|)
expr_stmt|;
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|wh
operator|->
name|i_dur
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* filled by HW */
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|wh
operator|->
name|i_seq
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* filled by HW */
name|frm
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|wh
operator|+
literal|1
operator|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_ssid
argument_list|(
name|frm
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_rates
argument_list|(
name|frm
argument_list|,
name|rs
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|rs_nrates
operator|>
name|IEEE80211_RATE_SIZE
condition|)
name|frm
operator|=
name|ieee80211_add_xrates
argument_list|(
name|frm
argument_list|,
name|rs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_htcaps
operator|&
name|IEEE80211_HTC_HT
condition|)
name|frm
operator|=
name|ieee80211_add_htcap
argument_list|(
name|frm
argument_list|,
name|ni
argument_list|)
expr_stmt|;
comment|/* Set length of probe request. */
name|tx
operator|->
name|len
operator|=
name|htole16
argument_list|(
name|frm
operator|-
operator|(
name|uint8_t
operator|*
operator|)
name|wh
argument_list|)
expr_stmt|;
comment|/* 	 * If active scanning is requested but a certain channel is 	 * marked passive, we can do active scanning if we detect 	 * transmissions. 	 * 	 * There is an issue with some firmware versions that triggers 	 * a sysassert on a "good CRC threshold" of zero (== disabled), 	 * on a radar channel even though this means that we should NOT 	 * send probes. 	 * 	 * The "good CRC threshold" is the number of frames that we 	 * need to receive during our dwell time on a channel before 	 * sending out probes -- setting this to a huge value will 	 * mean we never reach it, but at the same time work around 	 * the aforementioned issue. Thus use IWL_GOOD_CRC_TH_NEVER 	 * here instead of IWL_GOOD_CRC_TH_DISABLED. 	 * 	 * This was fixed in later versions along with some other 	 * scan changes, and the threshold behaves as a flag in those 	 * versions. 	 */
comment|/* 	 * If we're doing active scanning, set the crc_threshold 	 * to a suitable value.  This is different to active veruss 	 * passive scanning depending upon the channel flags; the 	 * firmware will obey that particular check for us. 	 */
if|if
condition|(
name|sc
operator|->
name|tlv_feature_flags
operator|&
name|IWN_UCODE_TLV_FLAGS_NEWSCAN
condition|)
name|hdr
operator|->
name|crc_threshold
operator|=
name|is_active
condition|?
name|IWN_GOOD_CRC_TH_DEFAULT
else|:
name|IWN_GOOD_CRC_TH_DISABLED
expr_stmt|;
else|else
name|hdr
operator|->
name|crc_threshold
operator|=
name|is_active
condition|?
name|IWN_GOOD_CRC_TH_DEFAULT
else|:
name|IWN_GOOD_CRC_TH_NEVER
expr_stmt|;
name|chan
operator|=
operator|(
expr|struct
name|iwn_scan_chan
operator|*
operator|)
name|frm
expr_stmt|;
name|chan
operator|->
name|chan
operator|=
name|htole16
argument_list|(
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|chan
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|ss_nssid
operator|>
literal|0
condition|)
name|chan
operator|->
name|flags
operator||=
name|htole32
argument_list|(
name|IWN_CHAN_NPBREQS
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|chan
operator|->
name|dsp_gain
operator|=
literal|0x6e
expr_stmt|;
comment|/* 	 * Set the passive/active flag depending upon the channel mode. 	 * XXX TODO: take the is_active flag into account as well? 	 */
if|if
condition|(
name|c
operator|->
name|ic_flags
operator|&
name|IEEE80211_CHAN_PASSIVE
condition|)
name|chan
operator|->
name|flags
operator||=
name|htole32
argument_list|(
name|IWN_CHAN_PASSIVE
argument_list|)
expr_stmt|;
else|else
name|chan
operator|->
name|flags
operator||=
name|htole32
argument_list|(
name|IWN_CHAN_ACTIVE
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate the active/passive dwell times. 	 */
name|dwell_active
operator|=
name|iwn_get_active_dwell_time
argument_list|(
name|sc
argument_list|,
name|c
argument_list|,
name|ss
operator|->
name|ss_nssid
argument_list|)
expr_stmt|;
name|dwell_passive
operator|=
name|iwn_get_passive_dwell_time
argument_list|(
name|sc
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* Make sure they're valid */
if|if
condition|(
name|dwell_passive
operator|<=
name|dwell_active
condition|)
name|dwell_passive
operator|=
name|dwell_active
operator|+
literal|1
expr_stmt|;
name|chan
operator|->
name|active
operator|=
name|htole16
argument_list|(
name|dwell_active
argument_list|)
expr_stmt|;
name|chan
operator|->
name|passive
operator|=
name|htole16
argument_list|(
name|dwell_passive
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|c
argument_list|)
condition|)
name|chan
operator|->
name|rf_gain
operator|=
literal|0x3b
expr_stmt|;
else|else
name|chan
operator|->
name|rf_gain
operator|=
literal|0x28
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_STATE
argument_list|,
literal|"%s: chan %u flags 0x%x rf_gain 0x%x "
literal|"dsp_gain 0x%x active %d passive %d scan_svc_time %d crc 0x%x "
literal|"isactive=%d numssid=%d\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|chan
argument_list|,
name|chan
operator|->
name|flags
argument_list|,
name|chan
operator|->
name|rf_gain
argument_list|,
name|chan
operator|->
name|dsp_gain
argument_list|,
name|dwell_active
argument_list|,
name|dwell_passive
argument_list|,
name|scan_service_time
argument_list|,
name|hdr
operator|->
name|crc_threshold
argument_list|,
name|is_active
argument_list|,
name|ss
operator|->
name|ss_nssid
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|nchan
operator|++
expr_stmt|;
name|chan
operator|++
expr_stmt|;
name|buflen
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|chan
operator|-
name|buf
expr_stmt|;
name|hdr
operator|->
name|len
operator|=
name|htole16
argument_list|(
name|buflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_is_scanning
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: called with is_scanning set!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_is_scanning
operator|=
literal|1
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_STATE
argument_list|,
literal|"sending scan command nchan=%d\n"
argument_list|,
name|hdr
operator|->
name|nchan
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_SCAN
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|scan_timeout
argument_list|,
literal|5
operator|*
name|hz
argument_list|,
name|iwn_scan_timeout
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s: end\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_auth
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|vap
operator|->
name|iv_bss
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s begin\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rxon
operator|=
operator|&
name|sc
operator|->
name|rx_on
index|[
name|IWN_RXON_BSS_CTX
index|]
expr_stmt|;
comment|/* Update adapter configuration. */
name|IEEE80211_ADDR_COPY
argument_list|(
name|sc
operator|->
name|rxon
operator|->
name|bssid
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rxon
operator|->
name|chan
operator|=
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rxon
operator|->
name|flags
operator|=
name|htole32
argument_list|(
name|IWN_RXON_TSF
operator||
name|IWN_RXON_CTS_TO_SELF
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
name|sc
operator|->
name|rxon
operator|->
name|flags
operator||=
name|htole32
argument_list|(
name|IWN_RXON_AUTO
operator||
name|IWN_RXON_24GHZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHSLOT
condition|)
name|sc
operator|->
name|rxon
operator|->
name|flags
operator||=
name|htole32
argument_list|(
name|IWN_RXON_SHSLOT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHPREAMBLE
condition|)
name|sc
operator|->
name|rxon
operator|->
name|flags
operator||=
name|htole32
argument_list|(
name|IWN_RXON_SHPREAMBLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_A
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
block|{
name|sc
operator|->
name|rxon
operator|->
name|cck_mask
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rxon
operator|->
name|ofdm_mask
operator|=
literal|0x15
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_B
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
block|{
name|sc
operator|->
name|rxon
operator|->
name|cck_mask
operator|=
literal|0x03
expr_stmt|;
name|sc
operator|->
name|rxon
operator|->
name|ofdm_mask
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Assume 802.11b/g. */
name|sc
operator|->
name|rxon
operator|->
name|cck_mask
operator|=
literal|0x03
expr_stmt|;
name|sc
operator|->
name|rxon
operator|->
name|ofdm_mask
operator|=
literal|0x15
expr_stmt|;
block|}
comment|/* try HT */
name|sc
operator|->
name|rxon
operator|->
name|flags
operator||=
name|htole32
argument_list|(
name|iwn_get_rxon_ht_flags
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_STATE
argument_list|,
literal|"rxon chan %d flags %x cck %x ofdm %x\n"
argument_list|,
name|sc
operator|->
name|rxon
operator|->
name|chan
argument_list|,
name|sc
operator|->
name|rxon
operator|->
name|flags
argument_list|,
name|sc
operator|->
name|rxon
operator|->
name|cck_mask
argument_list|,
name|sc
operator|->
name|rxon
operator|->
name|ofdm_mask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_send_rxon
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not send RXON\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s: end\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_run
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|iwn_ops
modifier|*
name|ops
init|=
operator|&
name|sc
operator|->
name|ops
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|vap
operator|->
name|iv_bss
decl_stmt|;
name|struct
name|iwn_node_info
name|node
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s begin\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rxon
operator|=
operator|&
name|sc
operator|->
name|rx_on
index|[
name|IWN_RXON_BSS_CTX
index|]
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_MONITOR
condition|)
block|{
comment|/* Link LED blinks while monitoring. */
name|iwn_set_led
argument_list|(
name|sc
argument_list|,
name|IWN_LED_LINK
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_set_timing
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not set timing, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Update adapter configuration. */
name|IEEE80211_ADDR_COPY
argument_list|(
name|sc
operator|->
name|rxon
operator|->
name|bssid
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rxon
operator|->
name|associd
operator|=
name|htole16
argument_list|(
name|IEEE80211_AID
argument_list|(
name|ni
operator|->
name|ni_associd
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rxon
operator|->
name|chan
operator|=
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rxon
operator|->
name|flags
operator|=
name|htole32
argument_list|(
name|IWN_RXON_TSF
operator||
name|IWN_RXON_CTS_TO_SELF
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
name|sc
operator|->
name|rxon
operator|->
name|flags
operator||=
name|htole32
argument_list|(
name|IWN_RXON_AUTO
operator||
name|IWN_RXON_24GHZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHSLOT
condition|)
name|sc
operator|->
name|rxon
operator|->
name|flags
operator||=
name|htole32
argument_list|(
name|IWN_RXON_SHSLOT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHPREAMBLE
condition|)
name|sc
operator|->
name|rxon
operator|->
name|flags
operator||=
name|htole32
argument_list|(
name|IWN_RXON_SHPREAMBLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_A
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
block|{
name|sc
operator|->
name|rxon
operator|->
name|cck_mask
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rxon
operator|->
name|ofdm_mask
operator|=
literal|0x15
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_B
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
block|{
name|sc
operator|->
name|rxon
operator|->
name|cck_mask
operator|=
literal|0x03
expr_stmt|;
name|sc
operator|->
name|rxon
operator|->
name|ofdm_mask
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Assume 802.11b/g. */
name|sc
operator|->
name|rxon
operator|->
name|cck_mask
operator|=
literal|0x0f
expr_stmt|;
name|sc
operator|->
name|rxon
operator|->
name|ofdm_mask
operator|=
literal|0x15
expr_stmt|;
block|}
comment|/* try HT */
name|sc
operator|->
name|rxon
operator|->
name|flags
operator||=
name|htole32
argument_list|(
name|iwn_get_rxon_ht_flags
argument_list|(
name|sc
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rxon
operator|->
name|filter
operator||=
name|htole32
argument_list|(
name|IWN_FILTER_BSS
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_STATE
argument_list|,
literal|"rxon chan %d flags %x, curhtprotmode=%d\n"
argument_list|,
name|sc
operator|->
name|rxon
operator|->
name|chan
argument_list|,
name|le32toh
argument_list|(
name|sc
operator|->
name|rxon
operator|->
name|flags
argument_list|)
argument_list|,
name|ic
operator|->
name|ic_curhtprotmode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_send_rxon
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not send RXON\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Fake a join to initialize the TX rate. */
operator|(
operator|(
expr|struct
name|iwn_node
operator|*
operator|)
name|ni
operator|)
operator|->
name|id
operator|=
name|IWN_ID_BSS
expr_stmt|;
name|iwn_newassoc
argument_list|(
name|ni
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Add BSS node. */
name|memset
argument_list|(
operator|&
name|node
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|node
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|node
operator|.
name|macaddr
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|)
expr_stmt|;
name|node
operator|.
name|id
operator|=
name|IWN_ID_BSS
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|ni
operator|->
name|ni_htcap
operator|&
name|IEEE80211_HTCAP_SMPS
condition|)
block|{
case|case
name|IEEE80211_HTCAP_SMPS_ENA
case|:
name|node
operator|.
name|htflags
operator||=
name|htole32
argument_list|(
name|IWN_SMPS_MIMO_DIS
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_HTCAP_SMPS_DYNAMIC
case|:
name|node
operator|.
name|htflags
operator||=
name|htole32
argument_list|(
name|IWN_SMPS_MIMO_PROT
argument_list|)
expr_stmt|;
break|break;
block|}
name|node
operator|.
name|htflags
operator||=
name|htole32
argument_list|(
name|IWN_AMDPU_SIZE_FACTOR
argument_list|(
literal|3
argument_list|)
operator||
name|IWN_AMDPU_DENSITY
argument_list|(
literal|5
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 4us */
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
name|node
operator|.
name|htflags
operator||=
name|htole32
argument_list|(
name|IWN_NODE_HT40
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_STATE
argument_list|,
literal|"%s: adding BSS node\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|ops
operator|->
name|add_node
argument_list|(
name|sc
argument_list|,
operator|&
name|node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not add BSS node, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_STATE
argument_list|,
literal|"%s: setting link quality for node %d\n"
argument_list|,
name|__func__
argument_list|,
name|node
operator|.
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_set_link_quality
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not setup link quality for node %d, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|node
operator|.
name|id
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_init_sensitivity
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not set sensitivity, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Start periodic calibration timer. */
name|sc
operator|->
name|calib
operator|.
name|state
operator|=
name|IWN_CALIB_STATE_ASSOC
expr_stmt|;
name|sc
operator|->
name|calib_cnt
operator|=
literal|0
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|calib_to
argument_list|,
name|msecs_to_ticks
argument_list|(
literal|500
argument_list|)
argument_list|,
name|iwn_calib_timeout
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* Link LED always on while associated. */
name|iwn_set_led
argument_list|(
name|sc
argument_list|,
name|IWN_LED_LINK
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s: end\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * This function is called by upper layer when an ADDBA request is received  * from another STA and before the ADDBA response is sent.  */
end_comment

begin_function
specifier|static
name|int
name|iwn_ampdu_rx_start
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_rx_ampdu
modifier|*
name|rap
parameter_list|,
name|int
name|baparamset
parameter_list|,
name|int
name|batimeout
parameter_list|,
name|int
name|baseqctl
parameter_list|)
block|{
define|#
directive|define
name|MS
parameter_list|(
name|_v
parameter_list|,
name|_f
parameter_list|)
value|(((_v)& _f)>> _f##_S)
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|ni
operator|->
name|ni_ic
operator|->
name|ic_softc
decl_stmt|;
name|struct
name|iwn_ops
modifier|*
name|ops
init|=
operator|&
name|sc
operator|->
name|ops
decl_stmt|;
name|struct
name|iwn_node
modifier|*
name|wn
init|=
operator|(
name|void
operator|*
operator|)
name|ni
decl_stmt|;
name|struct
name|iwn_node_info
name|node
decl_stmt|;
name|uint16_t
name|ssn
decl_stmt|;
name|uint8_t
name|tid
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->Doing %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|tid
operator|=
name|MS
argument_list|(
name|le16toh
argument_list|(
name|baparamset
argument_list|)
argument_list|,
name|IEEE80211_BAPS_TID
argument_list|)
expr_stmt|;
name|ssn
operator|=
name|MS
argument_list|(
name|le16toh
argument_list|(
name|baseqctl
argument_list|)
argument_list|,
name|IEEE80211_BASEQ_START
argument_list|)
expr_stmt|;
if|if
condition|(
name|wn
operator|->
name|id
operator|==
name|IWN_ID_UNDEFINED
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|memset
argument_list|(
operator|&
name|node
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|node
argument_list|)
expr_stmt|;
name|node
operator|.
name|id
operator|=
name|wn
operator|->
name|id
expr_stmt|;
name|node
operator|.
name|control
operator|=
name|IWN_NODE_UPDATE
expr_stmt|;
name|node
operator|.
name|flags
operator|=
name|IWN_FLAG_SET_ADDBA
expr_stmt|;
name|node
operator|.
name|addba_tid
operator|=
name|tid
expr_stmt|;
name|node
operator|.
name|addba_ssn
operator|=
name|htole16
argument_list|(
name|ssn
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RECV
argument_list|,
literal|"ADDBA RA=%d TID=%d SSN=%d\n"
argument_list|,
name|wn
operator|->
name|id
argument_list|,
name|tid
argument_list|,
name|ssn
argument_list|)
expr_stmt|;
name|error
operator|=
name|ops
operator|->
name|add_node
argument_list|(
name|sc
argument_list|,
operator|&
name|node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
return|return
name|sc
operator|->
name|sc_ampdu_rx_start
argument_list|(
name|ni
argument_list|,
name|rap
argument_list|,
name|baparamset
argument_list|,
name|batimeout
argument_list|,
name|baseqctl
argument_list|)
return|;
undef|#
directive|undef
name|MS
block|}
end_function

begin_comment
comment|/*  * This function is called by upper layer on teardown of an HT-immediate  * Block Ack agreement (eg. uppon receipt of a DELBA frame).  */
end_comment

begin_function
specifier|static
name|void
name|iwn_ampdu_rx_stop
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_rx_ampdu
modifier|*
name|rap
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|struct
name|iwn_ops
modifier|*
name|ops
init|=
operator|&
name|sc
operator|->
name|ops
decl_stmt|;
name|struct
name|iwn_node
modifier|*
name|wn
init|=
operator|(
name|void
operator|*
operator|)
name|ni
decl_stmt|;
name|struct
name|iwn_node_info
name|node
decl_stmt|;
name|uint8_t
name|tid
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->Doing %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|wn
operator|->
name|id
operator|==
name|IWN_ID_UNDEFINED
condition|)
goto|goto
name|end
goto|;
comment|/* XXX: tid as an argument */
for|for
control|(
name|tid
operator|=
literal|0
init|;
name|tid
operator|<
name|WME_NUM_TID
condition|;
name|tid
operator|++
control|)
block|{
if|if
condition|(
operator|&
name|ni
operator|->
name|ni_rx_ampdu
index|[
name|tid
index|]
operator|==
name|rap
condition|)
break|break;
block|}
name|memset
argument_list|(
operator|&
name|node
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|node
argument_list|)
expr_stmt|;
name|node
operator|.
name|id
operator|=
name|wn
operator|->
name|id
expr_stmt|;
name|node
operator|.
name|control
operator|=
name|IWN_NODE_UPDATE
expr_stmt|;
name|node
operator|.
name|flags
operator|=
name|IWN_FLAG_SET_DELBA
expr_stmt|;
name|node
operator|.
name|delba_tid
operator|=
name|tid
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RECV
argument_list|,
literal|"DELBA RA=%d TID=%d\n"
argument_list|,
name|wn
operator|->
name|id
argument_list|,
name|tid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ops
operator|->
name|add_node
argument_list|(
name|sc
argument_list|,
operator|&
name|node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|end
label|:
name|sc
operator|->
name|sc_ampdu_rx_stop
argument_list|(
name|ni
argument_list|,
name|rap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_addba_request
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|,
name|int
name|dialogtoken
parameter_list|,
name|int
name|baparamset
parameter_list|,
name|int
name|batimeout
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|ni
operator|->
name|ni_ic
operator|->
name|ic_softc
decl_stmt|;
name|int
name|qid
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->Doing %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
for|for
control|(
name|qid
operator|=
name|sc
operator|->
name|firstaggqueue
init|;
name|qid
operator|<
name|sc
operator|->
name|ntxqs
condition|;
name|qid
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|qid2tap
index|[
name|qid
index|]
operator|==
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|qid
operator|==
name|sc
operator|->
name|ntxqs
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_XMIT
argument_list|,
literal|"%s: not free aggregation queue\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|tap
operator|->
name|txa_private
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|tap
operator|->
name|txa_private
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: failed to alloc TX aggregation structure\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sc
operator|->
name|qid2tap
index|[
name|qid
index|]
operator|=
name|tap
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|tap
operator|->
name|txa_private
operator|=
name|qid
expr_stmt|;
return|return
name|sc
operator|->
name|sc_addba_request
argument_list|(
name|ni
argument_list|,
name|tap
argument_list|,
name|dialogtoken
argument_list|,
name|baparamset
argument_list|,
name|batimeout
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_addba_response
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|,
name|int
name|code
parameter_list|,
name|int
name|baparamset
parameter_list|,
name|int
name|batimeout
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|ni
operator|->
name|ni_ic
operator|->
name|ic_softc
decl_stmt|;
name|int
name|qid
init|=
operator|*
operator|(
name|int
operator|*
operator|)
name|tap
operator|->
name|txa_private
decl_stmt|;
name|uint8_t
name|tid
init|=
name|tap
operator|->
name|txa_tid
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->Doing %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|IEEE80211_STATUS_SUCCESS
condition|)
block|{
name|ni
operator|->
name|ni_txseqs
index|[
name|tid
index|]
operator|=
name|tap
operator|->
name|txa_start
operator|&
literal|0xfff
expr_stmt|;
name|ret
operator|=
name|iwn_ampdu_tx_start
argument_list|(
name|ni
operator|->
name|ni_ic
argument_list|,
name|ni
argument_list|,
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|1
condition|)
return|return
name|ret
return|;
block|}
else|else
block|{
name|sc
operator|->
name|qid2tap
index|[
name|qid
index|]
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|tap
operator|->
name|txa_private
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|tap
operator|->
name|txa_private
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|sc
operator|->
name|sc_addba_response
argument_list|(
name|ni
argument_list|,
name|tap
argument_list|,
name|code
argument_list|,
name|baparamset
argument_list|,
name|batimeout
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function is called by upper layer when an ADDBA response is received  * from another STA.  */
end_comment

begin_function
specifier|static
name|int
name|iwn_ampdu_tx_start
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|uint8_t
name|tid
parameter_list|)
block|{
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
init|=
operator|&
name|ni
operator|->
name|ni_tx_ampdu
index|[
name|tid
index|]
decl_stmt|;
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|ni
operator|->
name|ni_ic
operator|->
name|ic_softc
decl_stmt|;
name|struct
name|iwn_ops
modifier|*
name|ops
init|=
operator|&
name|sc
operator|->
name|ops
decl_stmt|;
name|struct
name|iwn_node
modifier|*
name|wn
init|=
operator|(
name|void
operator|*
operator|)
name|ni
decl_stmt|;
name|struct
name|iwn_node_info
name|node
decl_stmt|;
name|int
name|error
decl_stmt|,
name|qid
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->Doing %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|wn
operator|->
name|id
operator|==
name|IWN_ID_UNDEFINED
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Enable TX for the specified RA/TID. */
name|wn
operator|->
name|disable_tid
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|tid
operator|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|node
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|node
argument_list|)
expr_stmt|;
name|node
operator|.
name|id
operator|=
name|wn
operator|->
name|id
expr_stmt|;
name|node
operator|.
name|control
operator|=
name|IWN_NODE_UPDATE
expr_stmt|;
name|node
operator|.
name|flags
operator|=
name|IWN_FLAG_SET_DISABLE_TID
expr_stmt|;
name|node
operator|.
name|disable_tid
operator|=
name|htole16
argument_list|(
name|wn
operator|->
name|disable_tid
argument_list|)
expr_stmt|;
name|error
operator|=
name|ops
operator|->
name|add_node
argument_list|(
name|sc
argument_list|,
operator|&
name|node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_nic_lock
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|qid
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|tap
operator|->
name|txa_private
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_XMIT
argument_list|,
literal|"%s: ra=%d tid=%d ssn=%d qid=%d\n"
argument_list|,
name|__func__
argument_list|,
name|wn
operator|->
name|id
argument_list|,
name|tid
argument_list|,
name|tap
operator|->
name|txa_start
argument_list|,
name|qid
argument_list|)
expr_stmt|;
name|ops
operator|->
name|ampdu_tx_start
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|qid
argument_list|,
name|tid
argument_list|,
name|tap
operator|->
name|txa_start
operator|&
literal|0xfff
argument_list|)
expr_stmt|;
name|iwn_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwn_set_link_quality
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_ampdu_tx_stop
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|ni
operator|->
name|ni_ic
operator|->
name|ic_softc
decl_stmt|;
name|struct
name|iwn_ops
modifier|*
name|ops
init|=
operator|&
name|sc
operator|->
name|ops
decl_stmt|;
name|uint8_t
name|tid
init|=
name|tap
operator|->
name|txa_tid
decl_stmt|;
name|int
name|qid
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->Doing %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_addba_stop
argument_list|(
name|ni
argument_list|,
name|tap
argument_list|)
expr_stmt|;
if|if
condition|(
name|tap
operator|->
name|txa_private
operator|==
name|NULL
condition|)
return|return;
name|qid
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|tap
operator|->
name|txa_private
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|txq
index|[
name|qid
index|]
operator|.
name|queued
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|iwn_nic_lock
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|ops
operator|->
name|ampdu_tx_stop
argument_list|(
name|sc
argument_list|,
name|qid
argument_list|,
name|tid
argument_list|,
name|tap
operator|->
name|txa_start
operator|&
literal|0xfff
argument_list|)
expr_stmt|;
name|iwn_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|qid2tap
index|[
name|qid
index|]
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|tap
operator|->
name|txa_private
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|tap
operator|->
name|txa_private
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn4965_ampdu_tx_start
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|qid
parameter_list|,
name|uint8_t
name|tid
parameter_list|,
name|uint16_t
name|ssn
parameter_list|)
block|{
name|struct
name|iwn_node
modifier|*
name|wn
init|=
operator|(
name|void
operator|*
operator|)
name|ni
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->Doing %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Stop TX scheduler while we're changing its configuration. */
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN4965_SCHED_QUEUE_STATUS
argument_list|(
name|qid
argument_list|)
argument_list|,
name|IWN4965_TXQ_STATUS_CHGACT
argument_list|)
expr_stmt|;
comment|/* Assign RA/TID translation to the queue. */
name|iwn_mem_write_2
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sched_base
operator|+
name|IWN4965_SCHED_TRANS_TBL
argument_list|(
name|qid
argument_list|)
argument_list|,
name|wn
operator|->
name|id
operator|<<
literal|4
operator||
name|tid
argument_list|)
expr_stmt|;
comment|/* Enable chain-building mode for the queue. */
name|iwn_prph_setbits
argument_list|(
name|sc
argument_list|,
name|IWN4965_SCHED_QCHAIN_SEL
argument_list|,
literal|1
operator|<<
name|qid
argument_list|)
expr_stmt|;
comment|/* Set starting sequence number from the ADDBA request. */
name|sc
operator|->
name|txq
index|[
name|qid
index|]
operator|.
name|cur
operator|=
name|sc
operator|->
name|txq
index|[
name|qid
index|]
operator|.
name|read
operator|=
operator|(
name|ssn
operator|&
literal|0xff
operator|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_HBUS_TARG_WRPTR
argument_list|,
name|qid
operator|<<
literal|8
operator||
operator|(
name|ssn
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN4965_SCHED_QUEUE_RDPTR
argument_list|(
name|qid
argument_list|)
argument_list|,
name|ssn
argument_list|)
expr_stmt|;
comment|/* Set scheduler window size. */
name|iwn_mem_write
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sched_base
operator|+
name|IWN4965_SCHED_QUEUE_OFFSET
argument_list|(
name|qid
argument_list|)
argument_list|,
name|IWN_SCHED_WINSZ
argument_list|)
expr_stmt|;
comment|/* Set scheduler frame limit. */
name|iwn_mem_write
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sched_base
operator|+
name|IWN4965_SCHED_QUEUE_OFFSET
argument_list|(
name|qid
argument_list|)
operator|+
literal|4
argument_list|,
name|IWN_SCHED_LIMIT
operator|<<
literal|16
argument_list|)
expr_stmt|;
comment|/* Enable interrupts for the queue. */
name|iwn_prph_setbits
argument_list|(
name|sc
argument_list|,
name|IWN4965_SCHED_INTR_MASK
argument_list|,
literal|1
operator|<<
name|qid
argument_list|)
expr_stmt|;
comment|/* Mark the queue as active. */
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN4965_SCHED_QUEUE_STATUS
argument_list|(
name|qid
argument_list|)
argument_list|,
name|IWN4965_TXQ_STATUS_ACTIVE
operator||
name|IWN4965_TXQ_STATUS_AGGR_ENA
operator||
name|iwn_tid2fifo
index|[
name|tid
index|]
operator|<<
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn4965_ampdu_tx_stop
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qid
parameter_list|,
name|uint8_t
name|tid
parameter_list|,
name|uint16_t
name|ssn
parameter_list|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->Doing %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Stop TX scheduler while we're changing its configuration. */
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN4965_SCHED_QUEUE_STATUS
argument_list|(
name|qid
argument_list|)
argument_list|,
name|IWN4965_TXQ_STATUS_CHGACT
argument_list|)
expr_stmt|;
comment|/* Set starting sequence number from the ADDBA request. */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_HBUS_TARG_WRPTR
argument_list|,
name|qid
operator|<<
literal|8
operator||
operator|(
name|ssn
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN4965_SCHED_QUEUE_RDPTR
argument_list|(
name|qid
argument_list|)
argument_list|,
name|ssn
argument_list|)
expr_stmt|;
comment|/* Disable interrupts for the queue. */
name|iwn_prph_clrbits
argument_list|(
name|sc
argument_list|,
name|IWN4965_SCHED_INTR_MASK
argument_list|,
literal|1
operator|<<
name|qid
argument_list|)
expr_stmt|;
comment|/* Mark the queue as inactive. */
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN4965_SCHED_QUEUE_STATUS
argument_list|(
name|qid
argument_list|)
argument_list|,
name|IWN4965_TXQ_STATUS_INACTIVE
operator||
name|iwn_tid2fifo
index|[
name|tid
index|]
operator|<<
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn5000_ampdu_tx_start
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|qid
parameter_list|,
name|uint8_t
name|tid
parameter_list|,
name|uint16_t
name|ssn
parameter_list|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->Doing %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|struct
name|iwn_node
modifier|*
name|wn
init|=
operator|(
name|void
operator|*
operator|)
name|ni
decl_stmt|;
comment|/* Stop TX scheduler while we're changing its configuration. */
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN5000_SCHED_QUEUE_STATUS
argument_list|(
name|qid
argument_list|)
argument_list|,
name|IWN5000_TXQ_STATUS_CHGACT
argument_list|)
expr_stmt|;
comment|/* Assign RA/TID translation to the queue. */
name|iwn_mem_write_2
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sched_base
operator|+
name|IWN5000_SCHED_TRANS_TBL
argument_list|(
name|qid
argument_list|)
argument_list|,
name|wn
operator|->
name|id
operator|<<
literal|4
operator||
name|tid
argument_list|)
expr_stmt|;
comment|/* Enable chain-building mode for the queue. */
name|iwn_prph_setbits
argument_list|(
name|sc
argument_list|,
name|IWN5000_SCHED_QCHAIN_SEL
argument_list|,
literal|1
operator|<<
name|qid
argument_list|)
expr_stmt|;
comment|/* Enable aggregation for the queue. */
name|iwn_prph_setbits
argument_list|(
name|sc
argument_list|,
name|IWN5000_SCHED_AGGR_SEL
argument_list|,
literal|1
operator|<<
name|qid
argument_list|)
expr_stmt|;
comment|/* Set starting sequence number from the ADDBA request. */
name|sc
operator|->
name|txq
index|[
name|qid
index|]
operator|.
name|cur
operator|=
name|sc
operator|->
name|txq
index|[
name|qid
index|]
operator|.
name|read
operator|=
operator|(
name|ssn
operator|&
literal|0xff
operator|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_HBUS_TARG_WRPTR
argument_list|,
name|qid
operator|<<
literal|8
operator||
operator|(
name|ssn
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN5000_SCHED_QUEUE_RDPTR
argument_list|(
name|qid
argument_list|)
argument_list|,
name|ssn
argument_list|)
expr_stmt|;
comment|/* Set scheduler window size and frame limit. */
name|iwn_mem_write
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sched_base
operator|+
name|IWN5000_SCHED_QUEUE_OFFSET
argument_list|(
name|qid
argument_list|)
operator|+
literal|4
argument_list|,
name|IWN_SCHED_LIMIT
operator|<<
literal|16
operator||
name|IWN_SCHED_WINSZ
argument_list|)
expr_stmt|;
comment|/* Enable interrupts for the queue. */
name|iwn_prph_setbits
argument_list|(
name|sc
argument_list|,
name|IWN5000_SCHED_INTR_MASK
argument_list|,
literal|1
operator|<<
name|qid
argument_list|)
expr_stmt|;
comment|/* Mark the queue as active. */
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN5000_SCHED_QUEUE_STATUS
argument_list|(
name|qid
argument_list|)
argument_list|,
name|IWN5000_TXQ_STATUS_ACTIVE
operator||
name|iwn_tid2fifo
index|[
name|tid
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn5000_ampdu_tx_stop
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qid
parameter_list|,
name|uint8_t
name|tid
parameter_list|,
name|uint16_t
name|ssn
parameter_list|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->Doing %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Stop TX scheduler while we're changing its configuration. */
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN5000_SCHED_QUEUE_STATUS
argument_list|(
name|qid
argument_list|)
argument_list|,
name|IWN5000_TXQ_STATUS_CHGACT
argument_list|)
expr_stmt|;
comment|/* Disable aggregation for the queue. */
name|iwn_prph_clrbits
argument_list|(
name|sc
argument_list|,
name|IWN5000_SCHED_AGGR_SEL
argument_list|,
literal|1
operator|<<
name|qid
argument_list|)
expr_stmt|;
comment|/* Set starting sequence number from the ADDBA request. */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_HBUS_TARG_WRPTR
argument_list|,
name|qid
operator|<<
literal|8
operator||
operator|(
name|ssn
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN5000_SCHED_QUEUE_RDPTR
argument_list|(
name|qid
argument_list|)
argument_list|,
name|ssn
argument_list|)
expr_stmt|;
comment|/* Disable interrupts for the queue. */
name|iwn_prph_clrbits
argument_list|(
name|sc
argument_list|,
name|IWN5000_SCHED_INTR_MASK
argument_list|,
literal|1
operator|<<
name|qid
argument_list|)
expr_stmt|;
comment|/* Mark the queue as inactive. */
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN5000_SCHED_QUEUE_STATUS
argument_list|(
name|qid
argument_list|)
argument_list|,
name|IWN5000_TXQ_STATUS_INACTIVE
operator||
name|iwn_tid2fifo
index|[
name|tid
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Query calibration tables from the initialization firmware.  We do this  * only once at first boot.  Called from a process context.  */
end_comment

begin_function
specifier|static
name|int
name|iwn5000_query_calibration
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwn5000_calib_config
name|cmd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|ucode
operator|.
name|once
operator|.
name|enable
operator|=
name|htole32
argument_list|(
literal|0xffffffff
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|ucode
operator|.
name|once
operator|.
name|start
operator|=
name|htole32
argument_list|(
literal|0xffffffff
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|ucode
operator|.
name|once
operator|.
name|send
operator|=
name|htole32
argument_list|(
literal|0xffffffff
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|ucode
operator|.
name|flags
operator|=
name|htole32
argument_list|(
literal|0xffffffff
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"%s: sending calibration query\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN5000_CMD_CALIB_CONFIG
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
name|cmd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/* Wait at most two seconds for calibration to complete. */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWN_FLAG_CALIB_DONE
operator|)
condition|)
name|error
operator|=
name|msleep
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|PCATCH
argument_list|,
literal|"iwncal"
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Send calibration results to the runtime firmware.  These results were  * obtained on first boot from the initialization firmware.  */
end_comment

begin_function
specifier|static
name|int
name|iwn5000_send_calibration
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|idx
decl_stmt|,
name|error
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|IWN5000_PHY_CALIB_MAX_RESULT
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|base_params
operator|->
name|calib_need
operator|&
operator|(
literal|1
operator|<<
name|idx
operator|)
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"No need of calib %d\n"
argument_list|,
name|idx
argument_list|)
expr_stmt|;
continue|continue;
comment|/* no need for this calib */
block|}
if|if
condition|(
name|sc
operator|->
name|calibcmd
index|[
name|idx
index|]
operator|.
name|buf
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"Need calib idx : %d but no available data\n"
argument_list|,
name|idx
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"send calibration result idx=%d len=%d\n"
argument_list|,
name|idx
argument_list|,
name|sc
operator|->
name|calibcmd
index|[
name|idx
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_PHY_CALIB
argument_list|,
name|sc
operator|->
name|calibcmd
index|[
name|idx
index|]
operator|.
name|buf
argument_list|,
name|sc
operator|->
name|calibcmd
index|[
name|idx
index|]
operator|.
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not send calibration result, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn5000_send_wimax_coex
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwn5000_wimax_coex
name|wimax
decl_stmt|;
if|#
directive|if
literal|0
block|if (sc->hw_type == IWN_HW_REV_TYPE_6050) {
comment|/* Enable WiMAX coexistence for combo adapters. */
block|wimax.flags = 		    IWN_WIMAX_COEX_ASSOC_WA_UNMASK | 		    IWN_WIMAX_COEX_UNASSOC_WA_UNMASK | 		    IWN_WIMAX_COEX_STA_TABLE_VALID | 		    IWN_WIMAX_COEX_ENABLE; 		memcpy(wimax.events, iwn6050_wimax_events, 		    sizeof iwn6050_wimax_events); 	} else
endif|#
directive|endif
block|{
comment|/* Disable WiMAX coexistence. */
name|wimax
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|wimax
operator|.
name|events
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|wimax
operator|.
name|events
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"%s: Configuring WiMAX coexistence\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN5000_CMD_WIMAX_COEX
argument_list|,
operator|&
name|wimax
argument_list|,
sizeof|sizeof
name|wimax
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn5000_crystal_calib
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwn5000_phy_calib_crystal
name|cmd
decl_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|code
operator|=
name|IWN5000_PHY_CALIB_CRYSTAL
expr_stmt|;
name|cmd
operator|.
name|ngroups
operator|=
literal|1
expr_stmt|;
name|cmd
operator|.
name|isvalid
operator|=
literal|1
expr_stmt|;
name|cmd
operator|.
name|cap_pin
index|[
literal|0
index|]
operator|=
name|le32toh
argument_list|(
name|sc
operator|->
name|eeprom_crystal
argument_list|)
operator|&
literal|0xff
expr_stmt|;
name|cmd
operator|.
name|cap_pin
index|[
literal|1
index|]
operator|=
operator|(
name|le32toh
argument_list|(
name|sc
operator|->
name|eeprom_crystal
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"sending crystal calibration %d, %d\n"
argument_list|,
name|cmd
operator|.
name|cap_pin
index|[
literal|0
index|]
argument_list|,
name|cmd
operator|.
name|cap_pin
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_PHY_CALIB
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
name|cmd
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn5000_temp_offset_calib
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwn5000_phy_calib_temp_offset
name|cmd
decl_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|code
operator|=
name|IWN5000_PHY_CALIB_TEMP_OFFSET
expr_stmt|;
name|cmd
operator|.
name|ngroups
operator|=
literal|1
expr_stmt|;
name|cmd
operator|.
name|isvalid
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|eeprom_temp
operator|!=
literal|0
condition|)
name|cmd
operator|.
name|offset
operator|=
name|htole16
argument_list|(
name|sc
operator|->
name|eeprom_temp
argument_list|)
expr_stmt|;
else|else
name|cmd
operator|.
name|offset
operator|=
name|htole16
argument_list|(
name|IWN_DEFAULT_TEMP_OFFSET
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"setting radio sensor offset to %d\n"
argument_list|,
name|le16toh
argument_list|(
name|cmd
operator|.
name|offset
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_PHY_CALIB
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
name|cmd
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn5000_temp_offset_calibv2
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwn5000_phy_calib_temp_offsetv2
name|cmd
decl_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|code
operator|=
name|IWN5000_PHY_CALIB_TEMP_OFFSET
expr_stmt|;
name|cmd
operator|.
name|ngroups
operator|=
literal|1
expr_stmt|;
name|cmd
operator|.
name|isvalid
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|eeprom_temp
operator|!=
literal|0
condition|)
block|{
name|cmd
operator|.
name|offset_low
operator|=
name|htole16
argument_list|(
name|sc
operator|->
name|eeprom_temp
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|offset_high
operator|=
name|htole16
argument_list|(
name|sc
operator|->
name|eeprom_temp_high
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cmd
operator|.
name|offset_low
operator|=
name|htole16
argument_list|(
name|IWN_DEFAULT_TEMP_OFFSET
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|offset_high
operator|=
name|htole16
argument_list|(
name|IWN_DEFAULT_TEMP_OFFSET
argument_list|)
expr_stmt|;
block|}
name|cmd
operator|.
name|burnt_voltage_ref
operator|=
name|htole16
argument_list|(
name|sc
operator|->
name|eeprom_voltage
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_CALIBRATE
argument_list|,
literal|"setting radio sensor low offset to %d, high offset to %d, voltage to %d\n"
argument_list|,
name|le16toh
argument_list|(
name|cmd
operator|.
name|offset_low
argument_list|)
argument_list|,
name|le16toh
argument_list|(
name|cmd
operator|.
name|offset_high
argument_list|)
argument_list|,
name|le16toh
argument_list|(
name|cmd
operator|.
name|burnt_voltage_ref
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|iwn_cmd
argument_list|(
name|sc
argument_list|,
name|IWN_CMD_PHY_CALIB
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
name|cmd
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function is called after the runtime firmware notifies us of its  * readiness (called in a process context).  */
end_comment

begin_function
specifier|static
name|int
name|iwn4965_post_alive
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|qid
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_nic_lock
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->Doing %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Clear TX scheduler state in SRAM. */
name|sc
operator|->
name|sched_base
operator|=
name|iwn_prph_read
argument_list|(
name|sc
argument_list|,
name|IWN_SCHED_SRAM_ADDR
argument_list|)
expr_stmt|;
name|iwn_mem_set_region_4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sched_base
operator|+
name|IWN4965_SCHED_CTX_OFF
argument_list|,
literal|0
argument_list|,
name|IWN4965_SCHED_CTX_LEN
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set physical address of TX scheduler rings (1KB aligned). */
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN4965_SCHED_DRAM_ADDR
argument_list|,
name|sc
operator|->
name|sched_dma
operator|.
name|paddr
operator|>>
literal|10
argument_list|)
expr_stmt|;
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_FH_TX_CHICKEN
argument_list|,
name|IWN_FH_TX_CHICKEN_SCHED_RETRY
argument_list|)
expr_stmt|;
comment|/* Disable chain mode for all our 16 queues. */
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN4965_SCHED_QCHAIN_SEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|qid
operator|=
literal|0
init|;
name|qid
operator|<
name|IWN4965_NTXQUEUES
condition|;
name|qid
operator|++
control|)
block|{
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN4965_SCHED_QUEUE_RDPTR
argument_list|(
name|qid
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_HBUS_TARG_WRPTR
argument_list|,
name|qid
operator|<<
literal|8
operator||
literal|0
argument_list|)
expr_stmt|;
comment|/* Set scheduler window size. */
name|iwn_mem_write
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sched_base
operator|+
name|IWN4965_SCHED_QUEUE_OFFSET
argument_list|(
name|qid
argument_list|)
argument_list|,
name|IWN_SCHED_WINSZ
argument_list|)
expr_stmt|;
comment|/* Set scheduler frame limit. */
name|iwn_mem_write
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sched_base
operator|+
name|IWN4965_SCHED_QUEUE_OFFSET
argument_list|(
name|qid
argument_list|)
operator|+
literal|4
argument_list|,
name|IWN_SCHED_LIMIT
operator|<<
literal|16
argument_list|)
expr_stmt|;
block|}
comment|/* Enable interrupts for all our 16 queues. */
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN4965_SCHED_INTR_MASK
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
comment|/* Identify TX FIFO rings (0-7). */
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN4965_SCHED_TXFACT
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Mark TX rings (4 EDCA + cmd + 2 HCCA) as active. */
for|for
control|(
name|qid
operator|=
literal|0
init|;
name|qid
operator|<
literal|7
condition|;
name|qid
operator|++
control|)
block|{
specifier|static
name|uint8_t
name|qid2fifo
index|[]
init|=
block|{
literal|3
block|,
literal|2
block|,
literal|1
block|,
literal|0
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|}
decl_stmt|;
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN4965_SCHED_QUEUE_STATUS
argument_list|(
name|qid
argument_list|)
argument_list|,
name|IWN4965_TXQ_STATUS_ACTIVE
operator||
name|qid2fifo
index|[
name|qid
index|]
operator|<<
literal|1
argument_list|)
expr_stmt|;
block|}
name|iwn_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * This function is called after the initialization or runtime firmware  * notifies us of its readiness (called in a process context).  */
end_comment

begin_function
specifier|static
name|int
name|iwn5000_post_alive
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|qid
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s begin\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Switch to using ICT interrupt mode. */
name|iwn5000_ict_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_nic_lock
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s end in error\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Clear TX scheduler state in SRAM. */
name|sc
operator|->
name|sched_base
operator|=
name|iwn_prph_read
argument_list|(
name|sc
argument_list|,
name|IWN_SCHED_SRAM_ADDR
argument_list|)
expr_stmt|;
name|iwn_mem_set_region_4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sched_base
operator|+
name|IWN5000_SCHED_CTX_OFF
argument_list|,
literal|0
argument_list|,
name|IWN5000_SCHED_CTX_LEN
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set physical address of TX scheduler rings (1KB aligned). */
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN5000_SCHED_DRAM_ADDR
argument_list|,
name|sc
operator|->
name|sched_dma
operator|.
name|paddr
operator|>>
literal|10
argument_list|)
expr_stmt|;
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_FH_TX_CHICKEN
argument_list|,
name|IWN_FH_TX_CHICKEN_SCHED_RETRY
argument_list|)
expr_stmt|;
comment|/* Enable chain mode for all queues, except command queue. */
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWN_FLAG_PAN_SUPPORT
condition|)
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN5000_SCHED_QCHAIN_SEL
argument_list|,
literal|0xfffdf
argument_list|)
expr_stmt|;
else|else
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN5000_SCHED_QCHAIN_SEL
argument_list|,
literal|0xfffef
argument_list|)
expr_stmt|;
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN5000_SCHED_AGGR_SEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|qid
operator|=
literal|0
init|;
name|qid
operator|<
name|IWN5000_NTXQUEUES
condition|;
name|qid
operator|++
control|)
block|{
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN5000_SCHED_QUEUE_RDPTR
argument_list|(
name|qid
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_HBUS_TARG_WRPTR
argument_list|,
name|qid
operator|<<
literal|8
operator||
literal|0
argument_list|)
expr_stmt|;
name|iwn_mem_write
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sched_base
operator|+
name|IWN5000_SCHED_QUEUE_OFFSET
argument_list|(
name|qid
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set scheduler window size and frame limit. */
name|iwn_mem_write
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sched_base
operator|+
name|IWN5000_SCHED_QUEUE_OFFSET
argument_list|(
name|qid
argument_list|)
operator|+
literal|4
argument_list|,
name|IWN_SCHED_LIMIT
operator|<<
literal|16
operator||
name|IWN_SCHED_WINSZ
argument_list|)
expr_stmt|;
block|}
comment|/* Enable interrupts for all our 20 queues. */
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN5000_SCHED_INTR_MASK
argument_list|,
literal|0xfffff
argument_list|)
expr_stmt|;
comment|/* Identify TX FIFO rings (0-7). */
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN5000_SCHED_TXFACT
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Mark TX rings (4 EDCA + cmd + 2 HCCA) as active. */
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWN_FLAG_PAN_SUPPORT
condition|)
block|{
comment|/* Mark TX rings as active. */
for|for
control|(
name|qid
operator|=
literal|0
init|;
name|qid
operator|<
literal|11
condition|;
name|qid
operator|++
control|)
block|{
specifier|static
name|uint8_t
name|qid2fifo
index|[]
init|=
block|{
literal|3
block|,
literal|2
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|2
block|,
literal|5
block|,
literal|4
block|,
literal|7
block|,
literal|5
block|}
decl_stmt|;
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN5000_SCHED_QUEUE_STATUS
argument_list|(
name|qid
argument_list|)
argument_list|,
name|IWN5000_TXQ_STATUS_ACTIVE
operator||
name|qid2fifo
index|[
name|qid
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Mark TX rings (4 EDCA + cmd + 2 HCCA) as active. */
for|for
control|(
name|qid
operator|=
literal|0
init|;
name|qid
operator|<
literal|7
condition|;
name|qid
operator|++
control|)
block|{
specifier|static
name|uint8_t
name|qid2fifo
index|[]
init|=
block|{
literal|3
block|,
literal|2
block|,
literal|1
block|,
literal|0
block|,
literal|7
block|,
literal|5
block|,
literal|6
block|}
decl_stmt|;
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN5000_SCHED_QUEUE_STATUS
argument_list|(
name|qid
argument_list|)
argument_list|,
name|IWN5000_TXQ_STATUS_ACTIVE
operator||
name|qid2fifo
index|[
name|qid
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|iwn_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Configure WiMAX coexistence for combo adapters. */
name|error
operator|=
name|iwn5000_send_wimax_coex
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not configure WiMAX coexistence, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|hw_type
operator|!=
name|IWN_HW_REV_TYPE_5150
condition|)
block|{
comment|/* Perform crystal calibration. */
name|error
operator|=
name|iwn5000_crystal_calib
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: crystal calibration failed, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWN_FLAG_CALIB_DONE
operator|)
condition|)
block|{
comment|/* Query calibration from the initialization firmware. */
if|if
condition|(
operator|(
name|error
operator|=
name|iwn5000_query_calibration
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not query calibration, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 		 * We have the calibration results now, reboot with the 		 * runtime firmware (call ourselves recursively!) 		 */
name|iwn_hw_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_hw_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Send calibration results to runtime firmware. */
name|error
operator|=
name|iwn5000_send_calibration
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s: end\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * The firmware boot code is small and is intended to be copied directly into  * the NIC internal memory (no DMA transfer).  */
end_comment

begin_function
specifier|static
name|int
name|iwn4965_load_bootcode
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|ucode
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|ntries
decl_stmt|;
name|size
operator|/=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_nic_lock
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/* Copy microcode image into NIC memory. */
name|iwn_prph_write_region_4
argument_list|(
name|sc
argument_list|,
name|IWN_BSM_SRAM_BASE
argument_list|,
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|ucode
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN_BSM_WR_MEM_SRC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN_BSM_WR_MEM_DST
argument_list|,
name|IWN_FW_TEXT_BASE
argument_list|)
expr_stmt|;
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN_BSM_WR_DWCOUNT
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Start boot load now. */
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN_BSM_WR_CTRL
argument_list|,
name|IWN_BSM_WR_CTRL_START
argument_list|)
expr_stmt|;
comment|/* Wait for transfer to complete. */
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|1000
condition|;
name|ntries
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|iwn_prph_read
argument_list|(
name|sc
argument_list|,
name|IWN_BSM_WR_CTRL
argument_list|)
operator|&
name|IWN_BSM_WR_CTRL_START
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ntries
operator|==
literal|1000
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not load boot firmware\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|iwn_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|ETIMEDOUT
return|;
block|}
comment|/* Enable boot after power up. */
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN_BSM_WR_CTRL
argument_list|,
name|IWN_BSM_WR_CTRL_START_EN
argument_list|)
expr_stmt|;
name|iwn_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn4965_load_firmware
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwn_fw_info
modifier|*
name|fw
init|=
operator|&
name|sc
operator|->
name|fw
decl_stmt|;
name|struct
name|iwn_dma_info
modifier|*
name|dma
init|=
operator|&
name|sc
operator|->
name|fw_dma
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Copy initialization sections into pre-allocated DMA-safe memory. */
name|memcpy
argument_list|(
name|dma
operator|->
name|vaddr
argument_list|,
name|fw
operator|->
name|init
operator|.
name|data
argument_list|,
name|fw
operator|->
name|init
operator|.
name|datasz
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dma
operator|->
name|vaddr
operator|+
name|IWN4965_FW_DATA_MAXSZ
argument_list|,
name|fw
operator|->
name|init
operator|.
name|text
argument_list|,
name|fw
operator|->
name|init
operator|.
name|textsz
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Tell adapter where to find initialization sections. */
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_nic_lock
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN_BSM_DRAM_DATA_ADDR
argument_list|,
name|dma
operator|->
name|paddr
operator|>>
literal|4
argument_list|)
expr_stmt|;
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN_BSM_DRAM_DATA_SIZE
argument_list|,
name|fw
operator|->
name|init
operator|.
name|datasz
argument_list|)
expr_stmt|;
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN_BSM_DRAM_TEXT_ADDR
argument_list|,
operator|(
name|dma
operator|->
name|paddr
operator|+
name|IWN4965_FW_DATA_MAXSZ
operator|)
operator|>>
literal|4
argument_list|)
expr_stmt|;
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN_BSM_DRAM_TEXT_SIZE
argument_list|,
name|fw
operator|->
name|init
operator|.
name|textsz
argument_list|)
expr_stmt|;
name|iwn_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Load firmware boot code. */
name|error
operator|=
name|iwn4965_load_bootcode
argument_list|(
name|sc
argument_list|,
name|fw
operator|->
name|boot
operator|.
name|text
argument_list|,
name|fw
operator|->
name|boot
operator|.
name|textsz
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not load boot firmware\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Now press "execute". */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_RESET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Wait at most one second for first alive notification. */
if|if
condition|(
operator|(
name|error
operator|=
name|msleep
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|PCATCH
argument_list|,
literal|"iwninit"
argument_list|,
name|hz
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: timeout waiting for adapter to initialize, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Retrieve current temperature for initial TX power calibration. */
name|sc
operator|->
name|rawtemp
operator|=
name|sc
operator|->
name|ucode_info
operator|.
name|temp
index|[
literal|3
index|]
operator|.
name|chan20MHz
expr_stmt|;
name|sc
operator|->
name|temp
operator|=
name|iwn4965_get_temperature
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Copy runtime sections into pre-allocated DMA-safe memory. */
name|memcpy
argument_list|(
name|dma
operator|->
name|vaddr
argument_list|,
name|fw
operator|->
expr|main
operator|.
name|data
argument_list|,
name|fw
operator|->
expr|main
operator|.
name|datasz
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dma
operator|->
name|vaddr
operator|+
name|IWN4965_FW_DATA_MAXSZ
argument_list|,
name|fw
operator|->
expr|main
operator|.
name|text
argument_list|,
name|fw
operator|->
expr|main
operator|.
name|textsz
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Tell adapter where to find runtime sections. */
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_nic_lock
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN_BSM_DRAM_DATA_ADDR
argument_list|,
name|dma
operator|->
name|paddr
operator|>>
literal|4
argument_list|)
expr_stmt|;
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN_BSM_DRAM_DATA_SIZE
argument_list|,
name|fw
operator|->
expr|main
operator|.
name|datasz
argument_list|)
expr_stmt|;
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN_BSM_DRAM_TEXT_ADDR
argument_list|,
operator|(
name|dma
operator|->
name|paddr
operator|+
name|IWN4965_FW_DATA_MAXSZ
operator|)
operator|>>
literal|4
argument_list|)
expr_stmt|;
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN_BSM_DRAM_TEXT_SIZE
argument_list|,
name|IWN_FW_UPDATED
operator||
name|fw
operator|->
expr|main
operator|.
name|textsz
argument_list|)
expr_stmt|;
name|iwn_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn5000_load_firmware_section
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|dst
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|section
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|struct
name|iwn_dma_info
modifier|*
name|dma
init|=
operator|&
name|sc
operator|->
name|fw_dma
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->Doing %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Copy firmware section into pre-allocated DMA-safe memory. */
name|memcpy
argument_list|(
name|dma
operator|->
name|vaddr
argument_list|,
name|section
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|dma
operator|->
name|tag
argument_list|,
name|dma
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_nic_lock
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_TX_CONFIG
argument_list|(
name|IWN_SRVC_DMACHNL
argument_list|)
argument_list|,
name|IWN_FH_TX_CONFIG_DMA_PAUSE
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_SRAM_ADDR
argument_list|(
name|IWN_SRVC_DMACHNL
argument_list|)
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_TFBD_CTRL0
argument_list|(
name|IWN_SRVC_DMACHNL
argument_list|)
argument_list|,
name|IWN_LOADDR
argument_list|(
name|dma
operator|->
name|paddr
argument_list|)
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_TFBD_CTRL1
argument_list|(
name|IWN_SRVC_DMACHNL
argument_list|)
argument_list|,
name|IWN_HIADDR
argument_list|(
name|dma
operator|->
name|paddr
argument_list|)
operator|<<
literal|28
operator||
name|size
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_TXBUF_STATUS
argument_list|(
name|IWN_SRVC_DMACHNL
argument_list|)
argument_list|,
name|IWN_FH_TXBUF_STATUS_TBNUM
argument_list|(
literal|1
argument_list|)
operator||
name|IWN_FH_TXBUF_STATUS_TBIDX
argument_list|(
literal|1
argument_list|)
operator||
name|IWN_FH_TXBUF_STATUS_TFBD_VALID
argument_list|)
expr_stmt|;
comment|/* Kick Flow Handler to start DMA transfer. */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_TX_CONFIG
argument_list|(
name|IWN_SRVC_DMACHNL
argument_list|)
argument_list|,
name|IWN_FH_TX_CONFIG_DMA_ENA
operator||
name|IWN_FH_TX_CONFIG_CIRQ_HOST_ENDTFD
argument_list|)
expr_stmt|;
name|iwn_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Wait at most five seconds for FH DMA transfer to complete. */
return|return
name|msleep
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|PCATCH
argument_list|,
literal|"iwninit"
argument_list|,
literal|5
operator|*
name|hz
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn5000_load_firmware
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwn_fw_part
modifier|*
name|fw
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->Doing %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Load the initialization firmware on first boot only. */
name|fw
operator|=
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWN_FLAG_CALIB_DONE
operator|)
condition|?
operator|&
name|sc
operator|->
name|fw
operator|.
expr|main
else|:
operator|&
name|sc
operator|->
name|fw
operator|.
name|init
expr_stmt|;
name|error
operator|=
name|iwn5000_load_firmware_section
argument_list|(
name|sc
argument_list|,
name|IWN_FW_TEXT_BASE
argument_list|,
name|fw
operator|->
name|text
argument_list|,
name|fw
operator|->
name|textsz
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not load firmware %s section, error %d\n"
argument_list|,
name|__func__
argument_list|,
literal|".text"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|iwn5000_load_firmware_section
argument_list|(
name|sc
argument_list|,
name|IWN_FW_DATA_BASE
argument_list|,
name|fw
operator|->
name|data
argument_list|,
name|fw
operator|->
name|datasz
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not load firmware %s section, error %d\n"
argument_list|,
name|__func__
argument_list|,
literal|".data"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Now press "execute". */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_RESET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Extract text and data sections from a legacy firmware image.  */
end_comment

begin_function
specifier|static
name|int
name|iwn_read_firmware_leg
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_fw_info
modifier|*
name|fw
parameter_list|)
block|{
specifier|const
name|uint32_t
modifier|*
name|ptr
decl_stmt|;
name|size_t
name|hdrlen
init|=
literal|24
decl_stmt|;
name|uint32_t
name|rev
decl_stmt|;
name|ptr
operator|=
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|fw
operator|->
name|data
expr_stmt|;
name|rev
operator|=
name|le32toh
argument_list|(
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ucode_rev
operator|=
name|rev
expr_stmt|;
comment|/* Check firmware API version. */
if|if
condition|(
name|IWN_FW_API
argument_list|(
name|rev
argument_list|)
operator|<=
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: bad firmware, need API version>=2\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|IWN_FW_API
argument_list|(
name|rev
argument_list|)
operator|>=
literal|3
condition|)
block|{
comment|/* Skip build number (version 2 header). */
name|hdrlen
operator|+=
literal|4
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|fw
operator|->
name|size
operator|<
name|hdrlen
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: firmware too short: %zu bytes\n"
argument_list|,
name|__func__
argument_list|,
name|fw
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|fw
operator|->
expr|main
operator|.
name|textsz
operator|=
name|le32toh
argument_list|(
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
name|fw
operator|->
expr|main
operator|.
name|datasz
operator|=
name|le32toh
argument_list|(
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
name|fw
operator|->
name|init
operator|.
name|textsz
operator|=
name|le32toh
argument_list|(
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
name|fw
operator|->
name|init
operator|.
name|datasz
operator|=
name|le32toh
argument_list|(
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
name|fw
operator|->
name|boot
operator|.
name|textsz
operator|=
name|le32toh
argument_list|(
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
comment|/* Check that all firmware sections fit. */
if|if
condition|(
name|fw
operator|->
name|size
operator|<
name|hdrlen
operator|+
name|fw
operator|->
expr|main
operator|.
name|textsz
operator|+
name|fw
operator|->
expr|main
operator|.
name|datasz
operator|+
name|fw
operator|->
name|init
operator|.
name|textsz
operator|+
name|fw
operator|->
name|init
operator|.
name|datasz
operator|+
name|fw
operator|->
name|boot
operator|.
name|textsz
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: firmware too short: %zu bytes\n"
argument_list|,
name|__func__
argument_list|,
name|fw
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* Get pointers to firmware sections. */
name|fw
operator|->
expr|main
operator|.
name|text
operator|=
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|ptr
expr_stmt|;
name|fw
operator|->
expr|main
operator|.
name|data
operator|=
name|fw
operator|->
expr|main
operator|.
name|text
operator|+
name|fw
operator|->
expr|main
operator|.
name|textsz
expr_stmt|;
name|fw
operator|->
name|init
operator|.
name|text
operator|=
name|fw
operator|->
expr|main
operator|.
name|data
operator|+
name|fw
operator|->
expr|main
operator|.
name|datasz
expr_stmt|;
name|fw
operator|->
name|init
operator|.
name|data
operator|=
name|fw
operator|->
name|init
operator|.
name|text
operator|+
name|fw
operator|->
name|init
operator|.
name|textsz
expr_stmt|;
name|fw
operator|->
name|boot
operator|.
name|text
operator|=
name|fw
operator|->
name|init
operator|.
name|data
operator|+
name|fw
operator|->
name|init
operator|.
name|datasz
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Extract text and data sections from a TLV firmware image.  */
end_comment

begin_function
specifier|static
name|int
name|iwn_read_firmware_tlv
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|iwn_fw_info
modifier|*
name|fw
parameter_list|,
name|uint16_t
name|alt
parameter_list|)
block|{
specifier|const
name|struct
name|iwn_fw_tlv_hdr
modifier|*
name|hdr
decl_stmt|;
specifier|const
name|struct
name|iwn_fw_tlv
modifier|*
name|tlv
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|uint64_t
name|altmask
decl_stmt|;
name|uint32_t
name|len
decl_stmt|,
name|tmp
decl_stmt|;
if|if
condition|(
name|fw
operator|->
name|size
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: firmware too short: %zu bytes\n"
argument_list|,
name|__func__
argument_list|,
name|fw
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|hdr
operator|=
operator|(
specifier|const
expr|struct
name|iwn_fw_tlv_hdr
operator|*
operator|)
name|fw
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|signature
operator|!=
name|htole32
argument_list|(
name|IWN_FW_SIGNATURE
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: bad firmware signature 0x%08x\n"
argument_list|,
name|__func__
argument_list|,
name|le32toh
argument_list|(
name|hdr
operator|->
name|signature
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"FW: \"%.64s\", build 0x%x\n"
argument_list|,
name|hdr
operator|->
name|descr
argument_list|,
name|le32toh
argument_list|(
name|hdr
operator|->
name|build
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ucode_rev
operator|=
name|le32toh
argument_list|(
name|hdr
operator|->
name|rev
argument_list|)
expr_stmt|;
comment|/* 	 * Select the closest supported alternative that is less than 	 * or equal to the specified one. 	 */
name|altmask
operator|=
name|le64toh
argument_list|(
name|hdr
operator|->
name|altmask
argument_list|)
expr_stmt|;
while|while
condition|(
name|alt
operator|>
literal|0
operator|&&
operator|!
operator|(
name|altmask
operator|&
operator|(
literal|1ULL
operator|<<
name|alt
operator|)
operator|)
condition|)
name|alt
operator|--
expr_stmt|;
comment|/* Downgrade. */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"using alternative %d\n"
argument_list|,
name|alt
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
expr_stmt|;
name|end
operator|=
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
operator|(
name|fw
operator|->
name|data
operator|+
name|fw
operator|->
name|size
operator|)
expr_stmt|;
comment|/* Parse type-length-value fields. */
while|while
condition|(
name|ptr
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|tlv
argument_list|)
operator|<=
name|end
condition|)
block|{
name|tlv
operator|=
operator|(
specifier|const
expr|struct
name|iwn_fw_tlv
operator|*
operator|)
name|ptr
expr_stmt|;
name|len
operator|=
name|le32toh
argument_list|(
name|tlv
operator|->
name|len
argument_list|)
expr_stmt|;
name|ptr
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|tlv
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|+
name|len
operator|>
name|end
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: firmware too short: %zu bytes\n"
argument_list|,
name|__func__
argument_list|,
name|fw
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* Skip other alternatives. */
if|if
condition|(
name|tlv
operator|->
name|alt
operator|!=
literal|0
operator|&&
name|tlv
operator|->
name|alt
operator|!=
name|htole16
argument_list|(
name|alt
argument_list|)
condition|)
goto|goto
name|next
goto|;
switch|switch
condition|(
name|le16toh
argument_list|(
name|tlv
operator|->
name|type
argument_list|)
condition|)
block|{
case|case
name|IWN_FW_TLV_MAIN_TEXT
case|:
name|fw
operator|->
expr|main
operator|.
name|text
operator|=
name|ptr
expr_stmt|;
name|fw
operator|->
expr|main
operator|.
name|textsz
operator|=
name|len
expr_stmt|;
break|break;
case|case
name|IWN_FW_TLV_MAIN_DATA
case|:
name|fw
operator|->
expr|main
operator|.
name|data
operator|=
name|ptr
expr_stmt|;
name|fw
operator|->
expr|main
operator|.
name|datasz
operator|=
name|len
expr_stmt|;
break|break;
case|case
name|IWN_FW_TLV_INIT_TEXT
case|:
name|fw
operator|->
name|init
operator|.
name|text
operator|=
name|ptr
expr_stmt|;
name|fw
operator|->
name|init
operator|.
name|textsz
operator|=
name|len
expr_stmt|;
break|break;
case|case
name|IWN_FW_TLV_INIT_DATA
case|:
name|fw
operator|->
name|init
operator|.
name|data
operator|=
name|ptr
expr_stmt|;
name|fw
operator|->
name|init
operator|.
name|datasz
operator|=
name|len
expr_stmt|;
break|break;
case|case
name|IWN_FW_TLV_BOOT_TEXT
case|:
name|fw
operator|->
name|boot
operator|.
name|text
operator|=
name|ptr
expr_stmt|;
name|fw
operator|->
name|boot
operator|.
name|textsz
operator|=
name|len
expr_stmt|;
break|break;
case|case
name|IWN_FW_TLV_ENH_SENS
case|:
if|if
condition|(
operator|!
name|len
condition|)
name|sc
operator|->
name|sc_flags
operator||=
name|IWN_FLAG_ENH_SENS
expr_stmt|;
break|break;
case|case
name|IWN_FW_TLV_PHY_CALIB
case|:
name|tmp
operator|=
name|le32toh
argument_list|(
operator|*
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|<
literal|253
condition|)
block|{
name|sc
operator|->
name|reset_noise_gain
operator|=
name|tmp
expr_stmt|;
name|sc
operator|->
name|noise_gain
operator|=
name|tmp
operator|+
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|IWN_FW_TLV_PAN
case|:
name|sc
operator|->
name|sc_flags
operator||=
name|IWN_FLAG_PAN_SUPPORT
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"PAN Support found: %d\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|IWN_FW_TLV_FLAGS
case|:
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
break|break;
if|if
condition|(
name|len
operator|%
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
break|break;
name|sc
operator|->
name|tlv_feature_flags
operator|=
name|le32toh
argument_list|(
operator|*
name|ptr
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"%s: feature: 0x%08x\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|tlv_feature_flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|IWN_FW_TLV_PBREQ_MAXLEN
case|:
case|case
name|IWN_FW_TLV_RUNT_EVTLOG_PTR
case|:
case|case
name|IWN_FW_TLV_RUNT_EVTLOG_SIZE
case|:
case|case
name|IWN_FW_TLV_RUNT_ERRLOG_PTR
case|:
case|case
name|IWN_FW_TLV_INIT_EVTLOG_PTR
case|:
case|case
name|IWN_FW_TLV_INIT_EVTLOG_SIZE
case|:
case|case
name|IWN_FW_TLV_INIT_ERRLOG_PTR
case|:
case|case
name|IWN_FW_TLV_WOWLAN_INST
case|:
case|case
name|IWN_FW_TLV_WOWLAN_DATA
case|:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"TLV type %d recognized but not handled\n"
argument_list|,
name|le16toh
argument_list|(
name|tlv
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_RESET
argument_list|,
literal|"TLV type %d not handled\n"
argument_list|,
name|le16toh
argument_list|(
name|tlv
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|next
label|:
comment|/* TLV fields are 32-bit aligned. */
name|ptr
operator|+=
operator|(
name|len
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_read_firmware
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwn_fw_info
modifier|*
name|fw
init|=
operator|&
name|sc
operator|->
name|fw
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->Doing %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|fw
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fw
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read firmware image from filesystem. */
name|sc
operator|->
name|fw_fp
operator|=
name|firmware_get
argument_list|(
name|sc
operator|->
name|fwname
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|fw_fp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not read firmware %s\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|fwname
argument_list|)
expr_stmt|;
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|fw
operator|->
name|size
operator|=
name|sc
operator|->
name|fw_fp
operator|->
name|datasize
expr_stmt|;
name|fw
operator|->
name|data
operator|=
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|sc
operator|->
name|fw_fp
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|fw
operator|->
name|size
operator|<
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: firmware too short: %zu bytes\n"
argument_list|,
name|__func__
argument_list|,
name|fw
operator|->
name|size
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Retrieve text and data sections. */
if|if
condition|(
operator|*
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|fw
operator|->
name|data
operator|!=
literal|0
condition|)
comment|/* Legacy image. */
name|error
operator|=
name|iwn_read_firmware_leg
argument_list|(
name|sc
argument_list|,
name|fw
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|iwn_read_firmware_tlv
argument_list|(
name|sc
argument_list|,
name|fw
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not read firmware sections, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: ucode rev=0x%08x\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|ucode_rev
argument_list|)
expr_stmt|;
comment|/* Make sure text and data sections fit in hardware memory. */
if|if
condition|(
name|fw
operator|->
expr|main
operator|.
name|textsz
operator|>
name|sc
operator|->
name|fw_text_maxsz
operator|||
name|fw
operator|->
expr|main
operator|.
name|datasz
operator|>
name|sc
operator|->
name|fw_data_maxsz
operator|||
name|fw
operator|->
name|init
operator|.
name|textsz
operator|>
name|sc
operator|->
name|fw_text_maxsz
operator|||
name|fw
operator|->
name|init
operator|.
name|datasz
operator|>
name|sc
operator|->
name|fw_data_maxsz
operator|||
name|fw
operator|->
name|boot
operator|.
name|textsz
operator|>
name|IWN_FW_BOOT_TEXT_MAXSZ
operator|||
operator|(
name|fw
operator|->
name|boot
operator|.
name|textsz
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: firmware sections too large\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* We can proceed with loading the firmware. */
return|return
literal|0
return|;
name|fail
label|:
name|iwn_unload_firmware
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_unload_firmware
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|firmware_put
argument_list|(
name|sc
operator|->
name|fw_fp
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fw_fp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_clock_wait
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|ntries
decl_stmt|;
comment|/* Set "initialization complete" bit. */
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_GP_CNTRL
argument_list|,
name|IWN_GP_CNTRL_INIT_DONE
argument_list|)
expr_stmt|;
comment|/* Wait for clock stabilization. */
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|2500
condition|;
name|ntries
operator|++
control|)
block|{
if|if
condition|(
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_GP_CNTRL
argument_list|)
operator|&
name|IWN_GP_CNTRL_MAC_CLOCK_READY
condition|)
return|return
literal|0
return|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: timeout waiting for clock stabilization\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|ETIMEDOUT
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_apm_init
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->Doing %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Disable L0s exit timer (NMI bug workaround). */
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_GIO_CHICKEN
argument_list|,
name|IWN_GIO_CHICKEN_DIS_L0S_TIMER
argument_list|)
expr_stmt|;
comment|/* Don't wait for ICH L0s (ICH bug workaround). */
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_GIO_CHICKEN
argument_list|,
name|IWN_GIO_CHICKEN_L1A_NO_L0S_RX
argument_list|)
expr_stmt|;
comment|/* Set FH wait threshold to max (HW bug under stress workaround). */
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_DBG_HPET_MEM
argument_list|,
literal|0xffff0000
argument_list|)
expr_stmt|;
comment|/* Enable HAP INTA to move adapter from L1a to L0s. */
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_HW_IF_CONFIG
argument_list|,
name|IWN_HW_IF_CONFIG_HAP_WAKE_L1A
argument_list|)
expr_stmt|;
comment|/* Retrieve PCIe Active State Power Management (ASPM). */
name|reg
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|sc
operator|->
name|sc_cap_off
operator|+
name|PCIER_LINK_CTL
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Workaround for HW instability in PCIe L0->L0s->L1 transition. */
if|if
condition|(
name|reg
operator|&
name|PCIEM_LINK_CTL_ASPMC_L1
condition|)
comment|/* L1 Entry enabled. */
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_GIO
argument_list|,
name|IWN_GIO_L0S_ENA
argument_list|)
expr_stmt|;
else|else
name|IWN_CLRBITS
argument_list|(
name|sc
argument_list|,
name|IWN_GIO
argument_list|,
name|IWN_GIO_L0S_ENA
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|base_params
operator|->
name|pll_cfg_val
condition|)
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_ANA_PLL
argument_list|,
name|sc
operator|->
name|base_params
operator|->
name|pll_cfg_val
argument_list|)
expr_stmt|;
comment|/* Wait for clock stabilization before accessing prph. */
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_clock_wait
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_nic_lock
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
name|sc
operator|->
name|hw_type
operator|==
name|IWN_HW_REV_TYPE_4965
condition|)
block|{
comment|/* Enable DMA and BSM (Bootstrap State Machine). */
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN_APMG_CLK_EN
argument_list|,
name|IWN_APMG_CLK_CTRL_DMA_CLK_RQT
operator||
name|IWN_APMG_CLK_CTRL_BSM_CLK_RQT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Enable DMA. */
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN_APMG_CLK_EN
argument_list|,
name|IWN_APMG_CLK_CTRL_DMA_CLK_RQT
argument_list|)
expr_stmt|;
block|}
name|DELAY
argument_list|(
literal|20
argument_list|)
expr_stmt|;
comment|/* Disable L1-Active. */
name|iwn_prph_setbits
argument_list|(
name|sc
argument_list|,
name|IWN_APMG_PCI_STT
argument_list|,
name|IWN_APMG_PCI_STT_L1A_DIS
argument_list|)
expr_stmt|;
name|iwn_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_apm_stop_master
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|ntries
decl_stmt|;
comment|/* Stop busmaster DMA activity. */
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_RESET
argument_list|,
name|IWN_RESET_STOP_MASTER
argument_list|)
expr_stmt|;
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|100
condition|;
name|ntries
operator|++
control|)
block|{
if|if
condition|(
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_RESET
argument_list|)
operator|&
name|IWN_RESET_MASTER_DISABLED
condition|)
return|return;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: timeout waiting for master\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_apm_stop
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|iwn_apm_stop_master
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Reset the entire device. */
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_RESET
argument_list|,
name|IWN_RESET_SW
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* Clear "initialization complete" bit. */
name|IWN_CLRBITS
argument_list|(
name|sc
argument_list|,
name|IWN_GP_CNTRL
argument_list|,
name|IWN_GP_CNTRL_INIT_DONE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn4965_nic_config
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->Doing %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|IWN_RFCFG_TYPE
argument_list|(
name|sc
operator|->
name|rfcfg
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* 		 * I don't believe this to be correct but this is what the 		 * vendor driver is doing. Probably the bits should not be 		 * shifted in IWN_RFCFG_*. 		 */
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_HW_IF_CONFIG
argument_list|,
name|IWN_RFCFG_TYPE
argument_list|(
name|sc
operator|->
name|rfcfg
argument_list|)
operator||
name|IWN_RFCFG_STEP
argument_list|(
name|sc
operator|->
name|rfcfg
argument_list|)
operator||
name|IWN_RFCFG_DASH
argument_list|(
name|sc
operator|->
name|rfcfg
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_HW_IF_CONFIG
argument_list|,
name|IWN_HW_IF_CONFIG_RADIO_SI
operator||
name|IWN_HW_IF_CONFIG_MAC_SI
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn5000_nic_config
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|tmp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->Doing %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|IWN_RFCFG_TYPE
argument_list|(
name|sc
operator|->
name|rfcfg
argument_list|)
operator|<
literal|3
condition|)
block|{
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_HW_IF_CONFIG
argument_list|,
name|IWN_RFCFG_TYPE
argument_list|(
name|sc
operator|->
name|rfcfg
argument_list|)
operator||
name|IWN_RFCFG_STEP
argument_list|(
name|sc
operator|->
name|rfcfg
argument_list|)
operator||
name|IWN_RFCFG_DASH
argument_list|(
name|sc
operator|->
name|rfcfg
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_HW_IF_CONFIG
argument_list|,
name|IWN_HW_IF_CONFIG_RADIO_SI
operator||
name|IWN_HW_IF_CONFIG_MAC_SI
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_nic_lock
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|iwn_prph_setbits
argument_list|(
name|sc
argument_list|,
name|IWN_APMG_PS
argument_list|,
name|IWN_APMG_PS_EARLY_PWROFF_DIS
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hw_type
operator|==
name|IWN_HW_REV_TYPE_1000
condition|)
block|{
comment|/* 		 * Select first Switching Voltage Regulator (1.32V) to 		 * solve a stability issue related to noisy DC2DC line 		 * in the silicon of 1000 Series. 		 */
name|tmp
operator|=
name|iwn_prph_read
argument_list|(
name|sc
argument_list|,
name|IWN_APMG_DIGITAL_SVR
argument_list|)
expr_stmt|;
name|tmp
operator|&=
operator|~
name|IWN_APMG_DIGITAL_SVR_VOLTAGE_MASK
expr_stmt|;
name|tmp
operator||=
name|IWN_APMG_DIGITAL_SVR_VOLTAGE_1_32
expr_stmt|;
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN_APMG_DIGITAL_SVR
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
name|iwn_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWN_FLAG_INTERNAL_PA
condition|)
block|{
comment|/* Use internal power amplifier only. */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_GP_DRIVER
argument_list|,
name|IWN_GP_DRIVER_RADIO_2X2_IPA
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|base_params
operator|->
name|additional_nic_config
operator|&&
name|sc
operator|->
name|calib_ver
operator|>=
literal|6
condition|)
block|{
comment|/* Indicate that ROM calibration version is>=6. */
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_GP_DRIVER
argument_list|,
name|IWN_GP_DRIVER_CALIB_VER6
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|base_params
operator|->
name|additional_gp_drv_bit
condition|)
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_GP_DRIVER
argument_list|,
name|sc
operator|->
name|base_params
operator|->
name|additional_gp_drv_bit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Take NIC ownership over Intel Active Management Technology (AMT).  */
end_comment

begin_function
specifier|static
name|int
name|iwn_hw_prepare
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|ntries
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->Doing %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Check if hardware is ready. */
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_HW_IF_CONFIG
argument_list|,
name|IWN_HW_IF_CONFIG_NIC_READY
argument_list|)
expr_stmt|;
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|5
condition|;
name|ntries
operator|++
control|)
block|{
if|if
condition|(
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_HW_IF_CONFIG
argument_list|)
operator|&
name|IWN_HW_IF_CONFIG_NIC_READY
condition|)
return|return
literal|0
return|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
comment|/* Hardware not ready, force into ready state. */
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_HW_IF_CONFIG
argument_list|,
name|IWN_HW_IF_CONFIG_PREPARE
argument_list|)
expr_stmt|;
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|15000
condition|;
name|ntries
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_HW_IF_CONFIG
argument_list|)
operator|&
name|IWN_HW_IF_CONFIG_PREPARE_DONE
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ntries
operator|==
literal|15000
condition|)
return|return
name|ETIMEDOUT
return|;
comment|/* Hardware should be ready now. */
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_HW_IF_CONFIG
argument_list|,
name|IWN_HW_IF_CONFIG_NIC_READY
argument_list|)
expr_stmt|;
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|5
condition|;
name|ntries
operator|++
control|)
block|{
if|if
condition|(
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_HW_IF_CONFIG
argument_list|)
operator|&
name|IWN_HW_IF_CONFIG_NIC_READY
condition|)
return|return
literal|0
return|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
return|return
name|ETIMEDOUT
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_hw_init
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|iwn_ops
modifier|*
name|ops
init|=
operator|&
name|sc
operator|->
name|ops
decl_stmt|;
name|int
name|error
decl_stmt|,
name|chnl
decl_stmt|,
name|qid
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s begin\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Clear pending interrupts. */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_INT
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_apm_init
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not power ON adapter, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Select VMAIN power source. */
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_nic_lock
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|iwn_prph_clrbits
argument_list|(
name|sc
argument_list|,
name|IWN_APMG_PS
argument_list|,
name|IWN_APMG_PS_PWR_SRC_MASK
argument_list|)
expr_stmt|;
name|iwn_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Perform adapter-specific initialization. */
if|if
condition|(
operator|(
name|error
operator|=
name|ops
operator|->
name|nic_config
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/* Initialize RX ring. */
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_nic_lock
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_RX_CONFIG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_RX_WPTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set physical address of RX ring (256-byte aligned). */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_RX_BASE
argument_list|,
name|sc
operator|->
name|rxq
operator|.
name|desc_dma
operator|.
name|paddr
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* Set physical address of RX status (16-byte aligned). */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_STATUS_WPTR
argument_list|,
name|sc
operator|->
name|rxq
operator|.
name|stat_dma
operator|.
name|paddr
operator|>>
literal|4
argument_list|)
expr_stmt|;
comment|/* Enable RX. */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_RX_CONFIG
argument_list|,
name|IWN_FH_RX_CONFIG_ENA
operator||
name|IWN_FH_RX_CONFIG_IGN_RXF_EMPTY
operator||
comment|/* HW bug workaround */
name|IWN_FH_RX_CONFIG_IRQ_DST_HOST
operator||
name|IWN_FH_RX_CONFIG_SINGLE_FRAME
operator||
name|IWN_FH_RX_CONFIG_RB_TIMEOUT
argument_list|(
literal|0
argument_list|)
operator||
name|IWN_FH_RX_CONFIG_NRBD
argument_list|(
name|IWN_RX_RING_COUNT_LOG
argument_list|)
argument_list|)
expr_stmt|;
name|iwn_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_RX_WPTR
argument_list|,
operator|(
name|IWN_RX_RING_COUNT
operator|-
literal|1
operator|)
operator|&
operator|~
literal|7
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_nic_lock
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/* Initialize TX scheduler. */
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sched_txfact_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set physical address of "keep warm" page (16-byte aligned). */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_KW_ADDR
argument_list|,
name|sc
operator|->
name|kw_dma
operator|.
name|paddr
operator|>>
literal|4
argument_list|)
expr_stmt|;
comment|/* Initialize TX rings. */
for|for
control|(
name|qid
operator|=
literal|0
init|;
name|qid
operator|<
name|sc
operator|->
name|ntxqs
condition|;
name|qid
operator|++
control|)
block|{
name|struct
name|iwn_tx_ring
modifier|*
name|txq
init|=
operator|&
name|sc
operator|->
name|txq
index|[
name|qid
index|]
decl_stmt|;
comment|/* Set physical address of TX ring (256-byte aligned). */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_CBBC_QUEUE
argument_list|(
name|qid
argument_list|)
argument_list|,
name|txq
operator|->
name|desc_dma
operator|.
name|paddr
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
name|iwn_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Enable DMA channels. */
for|for
control|(
name|chnl
operator|=
literal|0
init|;
name|chnl
operator|<
name|sc
operator|->
name|ndmachnls
condition|;
name|chnl
operator|++
control|)
block|{
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_TX_CONFIG
argument_list|(
name|chnl
argument_list|)
argument_list|,
name|IWN_FH_TX_CONFIG_DMA_ENA
operator||
name|IWN_FH_TX_CONFIG_DMA_CREDIT_ENA
argument_list|)
expr_stmt|;
block|}
comment|/* Clear "radio off" and "commands blocked" bits. */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_UCODE_GP1_CLR
argument_list|,
name|IWN_UCODE_GP1_RFKILL
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_UCODE_GP1_CLR
argument_list|,
name|IWN_UCODE_GP1_CMD_BLOCKED
argument_list|)
expr_stmt|;
comment|/* Clear pending interrupts. */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_INT
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* Enable interrupt coalescing. */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_INT_COALESCING
argument_list|,
literal|512
operator|/
literal|8
argument_list|)
expr_stmt|;
comment|/* Enable interrupts. */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_INT_MASK
argument_list|,
name|sc
operator|->
name|int_mask
argument_list|)
expr_stmt|;
comment|/* _Really_ make sure "radio off" bit is cleared! */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_UCODE_GP1_CLR
argument_list|,
name|IWN_UCODE_GP1_RFKILL
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_UCODE_GP1_CLR
argument_list|,
name|IWN_UCODE_GP1_RFKILL
argument_list|)
expr_stmt|;
comment|/* Enable shadow registers. */
if|if
condition|(
name|sc
operator|->
name|base_params
operator|->
name|shadow_reg_enable
condition|)
name|IWN_SETBITS
argument_list|(
name|sc
argument_list|,
name|IWN_SHADOW_REG_CTRL
argument_list|,
literal|0x800fffff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ops
operator|->
name|load_firmware
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not load firmware, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Wait at most one second for firmware alive notification. */
if|if
condition|(
operator|(
name|error
operator|=
name|msleep
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|PCATCH
argument_list|,
literal|"iwninit"
argument_list|,
name|hz
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: timeout waiting for adapter to initialize, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Do post-firmware initialization. */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s: end\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|ops
operator|->
name|post_alive
argument_list|(
name|sc
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_hw_stop
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|chnl
decl_stmt|,
name|qid
decl_stmt|,
name|ntries
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->Doing %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_RESET
argument_list|,
name|IWN_RESET_NEVO
argument_list|)
expr_stmt|;
comment|/* Disable interrupts. */
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_INT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_INT
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_INT
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|IWN_FLAG_USE_ICT
expr_stmt|;
comment|/* Make sure we no longer hold the NIC lock. */
name|iwn_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Stop TX scheduler. */
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sched_txfact_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Stop all DMA channels. */
if|if
condition|(
name|iwn_nic_lock
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|chnl
operator|=
literal|0
init|;
name|chnl
operator|<
name|sc
operator|->
name|ndmachnls
condition|;
name|chnl
operator|++
control|)
block|{
name|IWN_WRITE
argument_list|(
name|sc
argument_list|,
name|IWN_FH_TX_CONFIG
argument_list|(
name|chnl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|ntries
operator|=
literal|0
init|;
name|ntries
operator|<
literal|200
condition|;
name|ntries
operator|++
control|)
block|{
if|if
condition|(
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_FH_TX_STATUS
argument_list|)
operator|&
name|IWN_FH_TX_STATUS_IDLE
argument_list|(
name|chnl
argument_list|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
block|}
name|iwn_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* Stop RX ring. */
name|iwn_reset_rx_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|rxq
argument_list|)
expr_stmt|;
comment|/* Reset all TX rings. */
for|for
control|(
name|qid
operator|=
literal|0
init|;
name|qid
operator|<
name|sc
operator|->
name|ntxqs
condition|;
name|qid
operator|++
control|)
name|iwn_reset_tx_ring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|txq
index|[
name|qid
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|iwn_nic_lock
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
condition|)
block|{
name|iwn_prph_write
argument_list|(
name|sc
argument_list|,
name|IWN_APMG_CLK_DIS
argument_list|,
name|IWN_APMG_CLK_CTRL_DMA_CLK_RQT
argument_list|)
expr_stmt|;
name|iwn_nic_unlock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
comment|/* Power OFF adapter. */
name|iwn_apm_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_panicked
parameter_list|(
name|void
modifier|*
name|arg0
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|arg0
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
if|#
directive|if
literal|0
block|int error;
endif|#
directive|endif
if|if
condition|(
name|vap
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: null vap\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: controller panicked, iv_state = %d; "
literal|"restarting\n"
argument_list|,
name|__func__
argument_list|,
name|vap
operator|->
name|iv_state
argument_list|)
expr_stmt|;
comment|/* 	 * This is not enough work. We need to also reinitialise 	 * the correct transmit state for aggregation enabled queues, 	 * which has a very specific requirement of 	 * ring index = 802.11 seqno % 256.  If we don't do this (which 	 * we definitely don't!) then the firmware will just panic again. 	 */
if|#
directive|if
literal|1
name|ieee80211_restart_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
else|#
directive|else
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwn_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_init_locked
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not init hardware\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|>=
name|IEEE80211_S_AUTH
operator|&&
operator|(
name|error
operator|=
name|iwn_auth
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not move to auth state\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|>=
name|IEEE80211_S_RUN
operator|&&
operator|(
name|error
operator|=
name|iwn_run
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not move to run state\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|unlock
label|:
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_init_locked
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s begin\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|IWN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWN_FLAG_RUNNING
condition|)
goto|goto
name|end
goto|;
name|sc
operator|->
name|sc_flags
operator||=
name|IWN_FLAG_RUNNING
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_hw_prepare
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: hardware not ready, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Initialize interrupt mask to default value. */
name|sc
operator|->
name|int_mask
operator|=
name|IWN_INT_MASK_DEF
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|IWN_FLAG_USE_ICT
expr_stmt|;
comment|/* Check that the radio is not disabled by hardware switch. */
if|if
condition|(
operator|!
operator|(
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|IWN_GP_CNTRL
argument_list|)
operator|&
name|IWN_GP_CNTRL_RFKILL
operator|)
condition|)
block|{
name|error
operator|=
name|EAGAIN
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Read firmware images from the filesystem. */
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_read_firmware
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not read firmware, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Initialize hardware and upload firmware. */
name|error
operator|=
name|iwn_hw_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwn_unload_firmware
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not initialize hardware, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Configure adapter now that it is ready. */
if|if
condition|(
operator|(
name|error
operator|=
name|iwn_config
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: could not configure device, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|watchdog_to
argument_list|,
name|hz
argument_list|,
name|iwn_watchdog
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|end
label|:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s: end\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|iwn_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->%s: end in error\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwn_init
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_stop_locked
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|IWN_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|IWN_FLAG_RUNNING
operator|)
condition|)
return|return;
name|sc
operator|->
name|sc_is_scanning
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|0
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|watchdog_to
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|scan_timeout
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|calib_to
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|IWN_FLAG_RUNNING
expr_stmt|;
comment|/* Power OFF hardware. */
name|iwn_hw_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iwn_stop
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|iwn_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Callback from net80211 to start a scan.  */
end_comment

begin_function
specifier|static
name|void
name|iwn_scan_start
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* make the link LED blink while we're scanning */
name|iwn_set_led
argument_list|(
name|sc
argument_list|,
name|IWN_LED_LINK
argument_list|,
literal|20
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Callback from net80211 to terminate a scan.  */
end_comment

begin_function
specifier|static
name|void
name|iwn_scan_end
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
decl_stmt|;
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_RUN
condition|)
block|{
comment|/* Set link LED to ON status if we are associated */
name|iwn_set_led
argument_list|(
name|sc
argument_list|,
name|IWN_LED_LINK
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Callback from net80211 to force a channel change.  */
end_comment

begin_function
specifier|static
name|void
name|iwn_set_channel
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|c
init|=
name|ic
operator|->
name|ic_curchan
decl_stmt|;
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_TRACE
argument_list|,
literal|"->Doing %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rxtap
operator|.
name|wr_chan_freq
operator|=
name|htole16
argument_list|(
name|c
operator|->
name|ic_freq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rxtap
operator|.
name|wr_chan_flags
operator|=
name|htole16
argument_list|(
name|c
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txtap
operator|.
name|wt_chan_freq
operator|=
name|htole16
argument_list|(
name|c
operator|->
name|ic_freq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txtap
operator|.
name|wt_chan_flags
operator|=
name|htole16
argument_list|(
name|c
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
comment|/* 	 * Only need to set the channel in Monitor mode. AP scanning and auth 	 * are already taken care of by their respective firmware commands. 	 */
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_MONITOR
condition|)
block|{
name|error
operator|=
name|iwn_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: error %d settting channel\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Callback from net80211 to start scanning of the current channel.  */
end_comment

begin_function
specifier|static
name|void
name|iwn_scan_curchan
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|unsigned
name|long
name|maxdwell
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ss
operator|->
name|ss_vap
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|iwn_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_softc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|IWN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|iwn_scan
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|,
name|ss
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
name|IWN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|ieee80211_cancel_scan
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Callback from net80211 to handle the minimum dwell time being met.  * The intent is to terminate the scan but we just let the firmware  * notify us when it's finished as we have no safe way to abort it.  */
end_comment

begin_function
specifier|static
name|void
name|iwn_scan_mindwell
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|)
block|{
comment|/* NB: don't try to abort scan; wait for firmware to finish */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IWN_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|IWN_DESC
parameter_list|(
name|x
parameter_list|)
value|case x:	return #x
end_define

begin_comment
comment|/*  * Translate CSR code to string  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|iwn_get_csr_string
parameter_list|(
name|int
name|csr
parameter_list|)
block|{
switch|switch
condition|(
name|csr
condition|)
block|{
name|IWN_DESC
argument_list|(
name|IWN_HW_IF_CONFIG
argument_list|)
expr_stmt|;
name|IWN_DESC
argument_list|(
name|IWN_INT_COALESCING
argument_list|)
expr_stmt|;
name|IWN_DESC
argument_list|(
name|IWN_INT
argument_list|)
expr_stmt|;
name|IWN_DESC
argument_list|(
name|IWN_INT_MASK
argument_list|)
expr_stmt|;
name|IWN_DESC
argument_list|(
name|IWN_FH_INT
argument_list|)
expr_stmt|;
name|IWN_DESC
argument_list|(
name|IWN_GPIO_IN
argument_list|)
expr_stmt|;
name|IWN_DESC
argument_list|(
name|IWN_RESET
argument_list|)
expr_stmt|;
name|IWN_DESC
argument_list|(
name|IWN_GP_CNTRL
argument_list|)
expr_stmt|;
name|IWN_DESC
argument_list|(
name|IWN_HW_REV
argument_list|)
expr_stmt|;
name|IWN_DESC
argument_list|(
name|IWN_EEPROM
argument_list|)
expr_stmt|;
name|IWN_DESC
argument_list|(
name|IWN_EEPROM_GP
argument_list|)
expr_stmt|;
name|IWN_DESC
argument_list|(
name|IWN_OTP_GP
argument_list|)
expr_stmt|;
name|IWN_DESC
argument_list|(
name|IWN_GIO
argument_list|)
expr_stmt|;
name|IWN_DESC
argument_list|(
name|IWN_GP_UCODE
argument_list|)
expr_stmt|;
name|IWN_DESC
argument_list|(
name|IWN_GP_DRIVER
argument_list|)
expr_stmt|;
name|IWN_DESC
argument_list|(
name|IWN_UCODE_GP1
argument_list|)
expr_stmt|;
name|IWN_DESC
argument_list|(
name|IWN_UCODE_GP2
argument_list|)
expr_stmt|;
name|IWN_DESC
argument_list|(
name|IWN_LED
argument_list|)
expr_stmt|;
name|IWN_DESC
argument_list|(
name|IWN_DRAM_INT_TBL
argument_list|)
expr_stmt|;
name|IWN_DESC
argument_list|(
name|IWN_GIO_CHICKEN
argument_list|)
expr_stmt|;
name|IWN_DESC
argument_list|(
name|IWN_ANA_PLL
argument_list|)
expr_stmt|;
name|IWN_DESC
argument_list|(
name|IWN_HW_REV_WA
argument_list|)
expr_stmt|;
name|IWN_DESC
argument_list|(
name|IWN_DBG_HPET_MEM
argument_list|)
expr_stmt|;
default|default:
return|return
literal|"UNKNOWN CSR"
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * This function print firmware register  */
end_comment

begin_function
specifier|static
name|void
name|iwn_debug_register
parameter_list|(
name|struct
name|iwn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|static
specifier|const
name|uint32_t
name|csr_tbl
index|[]
init|=
block|{
name|IWN_HW_IF_CONFIG
block|,
name|IWN_INT_COALESCING
block|,
name|IWN_INT
block|,
name|IWN_INT_MASK
block|,
name|IWN_FH_INT
block|,
name|IWN_GPIO_IN
block|,
name|IWN_RESET
block|,
name|IWN_GP_CNTRL
block|,
name|IWN_HW_REV
block|,
name|IWN_EEPROM
block|,
name|IWN_EEPROM_GP
block|,
name|IWN_OTP_GP
block|,
name|IWN_GIO
block|,
name|IWN_GP_UCODE
block|,
name|IWN_GP_DRIVER
block|,
name|IWN_UCODE_GP1
block|,
name|IWN_UCODE_GP2
block|,
name|IWN_LED
block|,
name|IWN_DRAM_INT_TBL
block|,
name|IWN_GIO_CHICKEN
block|,
name|IWN_ANA_PLL
block|,
name|IWN_HW_REV_WA
block|,
name|IWN_DBG_HPET_MEM
block|, 	}
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_REGISTER
argument_list|,
literal|"CSR values: (2nd byte of IWN_INT_COALESCING is IWN_INT_PERIODIC)%s"
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|csr_tbl
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_REGISTER
argument_list|,
literal|"  %10s: 0x%08x "
argument_list|,
name|iwn_get_csr_string
argument_list|(
name|csr_tbl
index|[
name|i
index|]
argument_list|)
argument_list|,
name|IWN_READ
argument_list|(
name|sc
argument_list|,
name|csr_tbl
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
literal|3
operator|==
literal|0
condition|)
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_REGISTER
argument_list|,
literal|"%s"
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|IWN_DEBUG_REGISTER
argument_list|,
literal|"%s"
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

