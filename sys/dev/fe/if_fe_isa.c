begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * All Rights Reserved, Copyright (C) Fujitsu Limited 1995  *  * This software may be used, modified, copied, distributed, and sold, in  * both source and binary form provided that the above copyright, these  * terms and the following disclaimer are retained.  The name of the author  * and/or the contributor may not be used to endorse or promote products  * derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND THE CONTRIBUTOR ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR THE CONTRIBUTOR BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION.  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_fe.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_ipx.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_mib.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/ic/mb86960.h>
end_include

begin_include
include|#
directive|include
file|<dev/fe/if_fereg.h>
end_include

begin_include
include|#
directive|include
file|<dev/fe/if_fevar.h>
end_include

begin_include
include|#
directive|include
file|<isa/isavar.h>
end_include

begin_comment
comment|/*  *	ISA specific code.  */
end_comment

begin_function_decl
specifier|static
name|int
name|fe_isa_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fe_isa_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|fe_isa_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|fe_isa_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|fe_isa_attach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|fe_isa_driver
init|=
block|{
literal|"fe"
block|,
name|fe_isa_methods
block|,
expr|sizeof
operator|(
expr|struct
name|fe_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|fe
argument_list|,
name|isa
argument_list|,
name|fe_isa_driver
argument_list|,
name|fe_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|fe_probe_ssi
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fe_probe_jli
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fe_probe_fmv
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fe_probe_lnx
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fe_probe_gwy
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fe_probe_ubn
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Determine if the device is present at a specified I/O address.  The  * main entry to the driver.  */
end_comment

begin_function
specifier|static
name|int
name|fe_isa_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Check isapnp ids */
if|if
condition|(
name|isa_get_vendorid
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Prepare for the softc struct.  */
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Probe for supported boards.  */
if|if
condition|(
operator|(
name|error
operator|=
name|fe_probe_ssi
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|end
goto|;
name|fe_release_resource
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|fe_probe_jli
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|end
goto|;
name|fe_release_resource
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|fe_probe_fmv
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|end
goto|;
name|fe_release_resource
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|fe_probe_lnx
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|end
goto|;
name|fe_release_resource
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|fe_probe_ubn
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|end
goto|;
name|fe_release_resource
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|fe_probe_gwy
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|end
goto|;
name|fe_release_resource
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|end
label|:
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|fe_alloc_irq
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fe_release_resource
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fe_isa_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|port_used
condition|)
name|fe_alloc_port
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|port_used
argument_list|)
expr_stmt|;
name|fe_alloc_irq
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|fe_attach
argument_list|(
name|dev
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Probe and initialization for Fujitsu FMV-180 series boards  */
end_comment

begin_function
specifier|static
name|void
name|fe_init_fmv
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Initialize ASIC.  */
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_FMV3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_FMV10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* "Refresh" hardware configuration.  FIXME.  */
block|fe_outb(sc, FE_FMV2, fe_inb(sc, FE_FMV2));
endif|#
directive|endif
comment|/* Turn the "master interrupt control" flag of ASIC on.  */
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_FMV3
argument_list|,
name|FE_FMV3_IRQENB
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fe_msel_fmv184
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_char
name|port
decl_stmt|;
comment|/* FMV-184 has a special "register" to switch between AUI/BNC. 	   Determine the value to write into the register, based on the 	   user-specified media selection.  */
name|port
operator|=
operator|(
name|IFM_SUBTYPE
argument_list|(
name|sc
operator|->
name|media
operator|.
name|ifm_media
argument_list|)
operator|==
name|IFM_10_2
operator|)
condition|?
literal|0x00
else|:
literal|0x01
expr_stmt|;
comment|/* The register is #5 on exntesion register bank... 	   (Details of the register layout is not yet discovered.)  */
name|fe_outb
argument_list|(
name|sc
argument_list|,
literal|0x1B
argument_list|,
literal|0x46
argument_list|)
expr_stmt|;
comment|/* ??? */
name|fe_outb
argument_list|(
name|sc
argument_list|,
literal|0x1E
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
comment|/* select ex-reg #4.  */
name|fe_outb
argument_list|(
name|sc
argument_list|,
literal|0x1F
argument_list|,
literal|0xC8
argument_list|)
expr_stmt|;
comment|/* ??? */
name|fe_outb
argument_list|(
name|sc
argument_list|,
literal|0x1E
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
comment|/* select ex-reg #5.  */
name|fe_outb
argument_list|(
name|sc
argument_list|,
literal|0x1F
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/* Switch the media.  */
name|fe_outb
argument_list|(
name|sc
argument_list|,
literal|0x1E
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
comment|/* select ex-reg #4.  */
name|fe_outb
argument_list|(
name|sc
argument_list|,
literal|0x1F
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* ??? */
name|fe_outb
argument_list|(
name|sc
argument_list|,
literal|0x1B
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* ??? */
comment|/* Make sure to select "external tranceiver" on MB86964.  */
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR13
argument_list|,
name|sc
operator|->
name|proto_bmpr13
operator||
name|FE_B13_PORT_AUI
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fe_probe_fmv
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|n
decl_stmt|;
name|u_long
name|iobase
decl_stmt|,
name|irq
decl_stmt|;
specifier|static
name|u_short
specifier|const
name|irqmap
index|[
literal|4
index|]
init|=
block|{
literal|3
block|,
literal|7
block|,
literal|10
block|,
literal|15
block|}
decl_stmt|;
specifier|static
name|struct
name|fe_simple_probe_struct
specifier|const
name|probe_table
index|[]
init|=
block|{
block|{
name|FE_DLCR2
block|,
literal|0x71
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR4
block|,
literal|0x08
block|,
literal|0x00
block|}
block|,
block|{
name|FE_FMV0
block|,
literal|0x78
block|,
literal|0x50
block|}
block|,
comment|/* ERRDY+PRRDY */
block|{
name|FE_FMV1
block|,
literal|0xB0
block|,
literal|0x00
block|}
block|,
comment|/* FMV-183/4 has 0x48 bits. */
block|{
name|FE_FMV3
block|,
literal|0x7F
block|,
literal|0x00
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
comment|/* Board subtypes; it lists known FMV-180 variants.  */
struct|struct
name|subtype
block|{
name|u_short
name|mcode
decl_stmt|;
name|u_short
name|mbitmap
decl_stmt|;
name|u_short
name|defmedia
decl_stmt|;
name|char
specifier|const
modifier|*
name|str
decl_stmt|;
block|}
struct|;
specifier|static
name|struct
name|subtype
specifier|const
name|typelist
index|[]
init|=
block|{
block|{
literal|0x0005
block|,
name|MB_HA
operator||
name|MB_HT
operator||
name|MB_H5
block|,
name|MB_HA
block|,
literal|"FMV-181"
block|}
block|,
block|{
literal|0x0105
block|,
name|MB_HA
operator||
name|MB_HT
operator||
name|MB_H5
block|,
name|MB_HA
block|,
literal|"FMV-181A"
block|}
block|,
block|{
literal|0x0003
block|,
name|MB_HM
block|,
name|MB_HM
block|,
literal|"FMV-182"
block|}
block|,
block|{
literal|0x0103
block|,
name|MB_HM
block|,
name|MB_HM
block|,
literal|"FMV-182A"
block|}
block|,
block|{
literal|0x0804
block|,
name|MB_HT
block|,
name|MB_HT
block|,
literal|"FMV-183"
block|}
block|,
block|{
literal|0x0C04
block|,
name|MB_HT
block|,
name|MB_HT
block|,
literal|"FMV-183 (on-board)"
block|}
block|,
block|{
literal|0x0803
block|,
name|MB_H2
operator||
name|MB_H5
block|,
name|MB_H2
block|,
literal|"FMV-184"
block|}
block|,
block|{
literal|0
block|,
name|MB_HA
block|,
name|MB_HA
block|,
literal|"unknown FMV-180 (?)"
block|}
block|, 	}
decl_stmt|;
name|struct
name|subtype
specifier|const
modifier|*
name|type
decl_stmt|;
comment|/* Media indicator and "Hardware revision ID"  */
name|u_short
name|mcode
decl_stmt|;
comment|/* See if the specified address is possible for FMV-180            series.  220, 240, 260, 280, 2A0, 2C0, 300, and 340 are            allowed for all boards, and 200, 2E0, 320, 360, 380, 3A0,            3C0, and 3E0 for PnP boards.  */
if|if
condition|(
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|,
operator|&
name|iobase
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
operator|(
name|iobase
operator|&
operator|~
literal|0x1E0
operator|)
operator|!=
literal|0x200
condition|)
return|return
name|ENXIO
return|;
comment|/* FMV-180 occupies 32 I/O addresses. */
if|if
condition|(
name|fe_alloc_port
argument_list|(
name|dev
argument_list|,
literal|32
argument_list|)
condition|)
return|return
name|ENXIO
return|;
comment|/* Setup an I/O address mapping table and some others.  */
name|fe_softc_defaults
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Simple probe.  */
if|if
condition|(
operator|!
name|fe_simple_probe
argument_list|(
name|sc
argument_list|,
name|probe_table
argument_list|)
condition|)
return|return
name|ENXIO
return|;
comment|/* Get our station address from EEPROM, and make sure it is            Fujitsu's.  */
name|fe_inblk
argument_list|(
name|sc
argument_list|,
name|FE_FMV4
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|valid_Ether_p
argument_list|(
name|sc
operator|->
name|sc_enaddr
argument_list|,
literal|0x00000E
argument_list|)
condition|)
return|return
name|ENXIO
return|;
comment|/* Find the supported media and "hardware revision" to know            the model identification.  */
name|mcode
operator|=
operator|(
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_FMV0
argument_list|)
operator|&
name|FE_FMV0_MEDIA
operator|)
operator||
operator|(
operator|(
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_FMV1
argument_list|)
operator|&
name|FE_FMV1_REV
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
comment|/* Determine the card type.  */
for|for
control|(
name|type
operator|=
name|typelist
init|;
name|type
operator|->
name|mcode
operator|!=
literal|0
condition|;
name|type
operator|++
control|)
block|{
if|if
condition|(
name|type
operator|->
name|mcode
operator|==
name|mcode
condition|)
break|break;
block|}
if|if
condition|(
name|type
operator|->
name|mcode
operator|==
literal|0
condition|)
block|{
comment|/* Unknown card type...  Hope the driver works.  */
name|sc
operator|->
name|stability
operator||=
name|UNSTABLE_TYPE
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unknown config: %x-%x-%x-%x\n"
argument_list|,
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_FMV0
argument_list|)
argument_list|,
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_FMV1
argument_list|)
argument_list|,
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_FMV2
argument_list|)
argument_list|,
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_FMV3
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Setup the board type and media information.  */
name|sc
operator|->
name|type
operator|=
name|FE_TYPE_FMV
expr_stmt|;
name|sc
operator|->
name|typestr
operator|=
name|type
operator|->
name|str
expr_stmt|;
name|sc
operator|->
name|mbitmap
operator|=
name|type
operator|->
name|mbitmap
expr_stmt|;
name|sc
operator|->
name|defmedia
operator|=
name|type
operator|->
name|defmedia
expr_stmt|;
name|sc
operator|->
name|msel
operator|=
name|fe_msel_965
expr_stmt|;
if|if
condition|(
name|type
operator|->
name|mbitmap
operator|==
operator|(
name|MB_H2
operator||
name|MB_H5
operator|)
condition|)
block|{
comment|/* FMV184 requires a special media selection procedure.  */
name|sc
operator|->
name|msel
operator|=
name|fe_msel_fmv184
expr_stmt|;
block|}
comment|/* 	 * An FMV-180 has been probed. 	 * Determine which IRQ to be used. 	 * 	 * In this version, we give a priority to the kernel config file. 	 * If the EEPROM and config don't match, say it to the user for 	 * an attention. 	 */
name|n
operator|=
operator|(
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_FMV2
argument_list|)
operator|&
name|FE_FMV2_IRS
operator|)
operator|>>
name|FE_FMV2_IRS_SHIFT
expr_stmt|;
name|irq
operator|=
literal|0
expr_stmt|;
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
operator|&
name|irq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
operator|==
name|NO_IRQ
condition|)
block|{
comment|/* Just use the probed value.  */
name|bus_set_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|irqmap
index|[
name|n
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|irq
operator|!=
name|irqmap
index|[
name|n
index|]
condition|)
block|{
comment|/* Don't match.  */
name|sc
operator|->
name|stability
operator||=
name|UNSTABLE_IRQ
expr_stmt|;
block|}
comment|/* We need an init hook to initialize ASIC before we start.  */
name|sc
operator|->
name|init
operator|=
name|fe_init_fmv
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Fujitsu MB86965 JLI mode probe routines.  *  * 86965 has a special operating mode called JLI (mode 0), under which  * the chip interfaces with ISA bus with a software-programmable  * configuration.  (The Fujitsu document calls the feature "Plug and  * play," but it is not compatible with the ISA-PnP spec. designed by  * Intel and Microsoft.)  Ethernet cards designed to use JLI are  * almost same, but there are two things which require board-specific  * probe routines: EEPROM layout and IRQ pin connection.  *  * JLI provides a handy way to access EEPROM which should contains the  * chip configuration information (such as I/O port address) as well  * as Ethernet station (MAC) address.  The chip configuration info. is  * stored on a fixed location.  However, the station address can be  * located anywhere in the EEPROM; it is up to the board designer to  * determine the location.  (The manual just says "somewhere in the  * EEPROM.")  The fe driver must somehow find out the correct  * location.  *  * Another problem resides in the IRQ pin connection.  JLI provides a  * user to choose an IRQ from up to four predefined IRQs.  The 86965  * chip has a register to select one out of the four possibilities.  * However, the selection is against the four IRQ pins on the chip.  * (So-called IRQ-A, -B, -C and -D.)  It is (again) up to the board  * designer to determine which pin to connect which IRQ line on the  * ISA bus.  We need a vendor (or model, for some vendor) specific IRQ  * mapping table.  *   * The routine fe_probe_jli() provides all probe and initialization  * processes which are common to all JLI implementation, and sub-probe  * routines supply board-specific actions.  *  * JLI sub-probe routine has the following template:  *  *	u_short const * func (struct fe_softc * sc, u_char const * eeprom);  *  * where eeprom is a pointer to an array of 32 byte data read from the  * config EEPROM on the board.  It retuns an IRQ mapping table for the  * board, when the corresponding implementation is detected.  It  * returns a NULL otherwise.  *   * Primary purpose of the functin is to analize the config EEPROM,  * determine if it matches with the pattern of that of supported card,  * and extract necessary information from it.  One of the information  * expected to be extracted from EEPROM is the Ethernet station (MAC)  * address, which must be set to the softc table of the interface by  * the board-specific routine.  */
end_comment

begin_comment
comment|/* JLI sub-probe for Allied-Telesyn/Allied-Telesis AT1700/RE2000 series.  */
end_comment

begin_function
specifier|static
name|u_short
specifier|const
modifier|*
name|fe_probe_jli_ati
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|,
name|u_char
specifier|const
modifier|*
name|eeprom
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|static
name|u_short
specifier|const
name|irqmaps_ati
index|[
literal|4
index|]
index|[
literal|4
index|]
init|=
block|{
block|{
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|9
block|}
block|,
block|{
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|15
block|}
block|,
block|{
literal|3
block|,
literal|11
block|,
literal|5
block|,
literal|15
block|}
block|,
block|{
literal|10
block|,
literal|11
block|,
literal|14
block|,
literal|15
block|}
block|, 	}
decl_stmt|;
comment|/* Make sure the EEPROM contains Allied-Telesis/Allied-Telesyn 	   bit pattern.  */
if|if
condition|(
name|eeprom
index|[
literal|1
index|]
operator|!=
literal|0x00
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|eeprom
index|[
name|i
index|]
operator|!=
literal|0xFF
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|14
init|;
name|i
operator|<
literal|24
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|eeprom
index|[
name|i
index|]
operator|!=
literal|0xFF
condition|)
return|return
name|NULL
return|;
comment|/* Get our station address from EEPROM, and make sure the            EEPROM contains ATI's address.  */
name|bcopy
argument_list|(
name|eeprom
operator|+
literal|8
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|valid_Ether_p
argument_list|(
name|sc
operator|->
name|sc_enaddr
argument_list|,
literal|0x0000F4
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* 	 * The following model identification codes are stolen 	 * from the NetBSD port of the fe driver.  My reviewers 	 * suggested minor revision. 	 */
comment|/* Determine the card type.  */
switch|switch
condition|(
name|eeprom
index|[
name|FE_ATI_EEP_MODEL
index|]
condition|)
block|{
case|case
name|FE_ATI_MODEL_AT1700T
case|:
name|sc
operator|->
name|typestr
operator|=
literal|"AT-1700T/RE2001"
expr_stmt|;
name|sc
operator|->
name|mbitmap
operator|=
name|MB_HT
expr_stmt|;
name|sc
operator|->
name|defmedia
operator|=
name|MB_HT
expr_stmt|;
break|break;
case|case
name|FE_ATI_MODEL_AT1700BT
case|:
name|sc
operator|->
name|typestr
operator|=
literal|"AT-1700BT/RE2003"
expr_stmt|;
name|sc
operator|->
name|mbitmap
operator|=
name|MB_HA
operator||
name|MB_HT
operator||
name|MB_H2
expr_stmt|;
break|break;
case|case
name|FE_ATI_MODEL_AT1700FT
case|:
name|sc
operator|->
name|typestr
operator|=
literal|"AT-1700FT/RE2009"
expr_stmt|;
name|sc
operator|->
name|mbitmap
operator|=
name|MB_HA
operator||
name|MB_HT
operator||
name|MB_HF
expr_stmt|;
break|break;
case|case
name|FE_ATI_MODEL_AT1700AT
case|:
name|sc
operator|->
name|typestr
operator|=
literal|"AT-1700AT/RE2005"
expr_stmt|;
name|sc
operator|->
name|mbitmap
operator|=
name|MB_HA
operator||
name|MB_HT
operator||
name|MB_H5
expr_stmt|;
break|break;
default|default:
name|sc
operator|->
name|typestr
operator|=
literal|"unknown AT-1700/RE2000"
expr_stmt|;
name|sc
operator|->
name|stability
operator||=
name|UNSTABLE_TYPE
operator||
name|UNSTABLE_IRQ
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|type
operator|=
name|FE_TYPE_JLI
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Should we extract default media from eeprom?  Linux driver 	   for AT1700 does it, although previous releases of FreeBSD 	   don't.  FIXME.  */
comment|/* Determine the default media selection from the config            EEPROM.  The byte at offset EEP_MEDIA is believed to            contain BMPR13 value to be set.  We just ignore STP bit or            squelch bit, since we don't support those.  (It is            intentional.)  */
block|switch (eeprom[FE_ATI_EEP_MEDIA]& FE_B13_PORT) { 	    case FE_B13_AUTO: 		sc->defmedia = MB_HA; 		break; 	    case FE_B13_TP: 		sc->defmedia = MB_HT; 		break; 	    case FE_B13_AUI: 		sc->defmedia = sc->mbitmap& (MB_H2|MB_H5|MB_H5);
comment|/*XXX*/
block|break; 	    default:	     		sc->defmedia = MB_HA; 		break; 	}
comment|/* Make sure the default media is compatible with the supported 	   ones.  */
block|if ((sc->defmedia& sc->mbitmap) == 0) { 		if (sc->defmedia == MB_HA) { 			sc->defmedia = MB_HT; 		} else { 			sc->defmedia = MB_HA; 		} 	}
endif|#
directive|endif
comment|/* 	 * Try to determine IRQ settings. 	 * Different models use different ranges of IRQs. 	 */
switch|switch
condition|(
operator|(
name|eeprom
index|[
name|FE_ATI_EEP_REVISION
index|]
operator|&
literal|0xf0
operator|)
operator||
operator|(
name|eeprom
index|[
name|FE_ATI_EEP_MAGIC
index|]
operator|&
literal|0x04
operator|)
condition|)
block|{
case|case
literal|0x30
case|:
case|case
literal|0x34
case|:
return|return
name|irqmaps_ati
index|[
literal|3
index|]
return|;
case|case
literal|0x10
case|:
case|case
literal|0x14
case|:
case|case
literal|0x50
case|:
case|case
literal|0x54
case|:
return|return
name|irqmaps_ati
index|[
literal|2
index|]
return|;
case|case
literal|0x44
case|:
case|case
literal|0x64
case|:
return|return
name|irqmaps_ati
index|[
literal|1
index|]
return|;
default|default:
return|return
name|irqmaps_ati
index|[
literal|0
index|]
return|;
block|}
block|}
end_function

begin_comment
comment|/* JLI sub-probe and msel hook for ICL Ethernet.  */
end_comment

begin_function
specifier|static
name|void
name|fe_msel_icl
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_char
name|d4
decl_stmt|;
comment|/* Switch between UTP and "external tranceiver" as always.  */
name|fe_msel_965
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* The board needs one more bit (on DLCR4) be set appropriately.  */
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|sc
operator|->
name|media
operator|.
name|ifm_media
argument_list|)
operator|==
name|IFM_10_5
condition|)
block|{
name|d4
operator|=
name|sc
operator|->
name|proto_dlcr4
operator||
name|FE_D4_CNTRL
expr_stmt|;
block|}
else|else
block|{
name|d4
operator|=
name|sc
operator|->
name|proto_dlcr4
operator|&
operator|~
name|FE_D4_CNTRL
expr_stmt|;
block|}
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR4
argument_list|,
name|d4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_short
specifier|const
modifier|*
name|fe_probe_jli_icl
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|,
name|u_char
specifier|const
modifier|*
name|eeprom
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_short
name|defmedia
decl_stmt|;
name|u_char
name|d6
decl_stmt|;
specifier|static
name|u_short
specifier|const
name|irqmap_icl
index|[
literal|4
index|]
init|=
block|{
literal|9
block|,
literal|10
block|,
literal|5
block|,
literal|15
block|}
decl_stmt|;
comment|/* Make sure the EEPROM contains ICL bit pattern.  */
for|for
control|(
name|i
operator|=
literal|24
init|;
name|i
operator|<
literal|39
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eeprom
index|[
name|i
index|]
operator|!=
literal|0x20
operator|&&
operator|(
name|eeprom
index|[
name|i
index|]
operator|&
literal|0xF0
operator|)
operator|!=
literal|0x30
condition|)
return|return
name|NULL
return|;
block|}
for|for
control|(
name|i
operator|=
literal|112
init|;
name|i
operator|<
literal|122
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eeprom
index|[
name|i
index|]
operator|!=
literal|0x20
operator|&&
operator|(
name|eeprom
index|[
name|i
index|]
operator|&
literal|0xF0
operator|)
operator|!=
literal|0x30
condition|)
return|return
name|NULL
return|;
block|}
comment|/* Make sure the EEPROM contains ICL's permanent station            address.  If it isn't, probably this board is not an            ICL's.  */
if|if
condition|(
operator|!
name|valid_Ether_p
argument_list|(
name|eeprom
operator|+
literal|122
argument_list|,
literal|0x00004B
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* Check if the "configured" Ethernet address in the EEPROM is 	   valid.  Use it if it is, or use the "permanent" address instead.  */
if|if
condition|(
name|valid_Ether_p
argument_list|(
name|eeprom
operator|+
literal|4
argument_list|,
literal|0x020000
argument_list|)
condition|)
block|{
comment|/* The configured address is valid.  Use it.  */
name|bcopy
argument_list|(
name|eeprom
operator|+
literal|4
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The configured address is invalid.  Use permanent.  */
name|bcopy
argument_list|(
name|eeprom
operator|+
literal|122
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
comment|/* Determine model and supported media.  */
switch|switch
condition|(
name|eeprom
index|[
literal|0x5E
index|]
condition|)
block|{
case|case
literal|0
case|:
name|sc
operator|->
name|typestr
operator|=
literal|"EtherTeam16i/COMBO"
expr_stmt|;
name|sc
operator|->
name|mbitmap
operator|=
name|MB_HA
operator||
name|MB_HT
operator||
name|MB_H5
operator||
name|MB_H2
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|sc
operator|->
name|typestr
operator|=
literal|"EtherTeam16i/TP"
expr_stmt|;
name|sc
operator|->
name|mbitmap
operator|=
name|MB_HT
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|sc
operator|->
name|typestr
operator|=
literal|"EtherTeam16i/ErgoPro"
expr_stmt|;
name|sc
operator|->
name|mbitmap
operator|=
name|MB_HA
operator||
name|MB_HT
operator||
name|MB_H5
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|sc
operator|->
name|typestr
operator|=
literal|"EtherTeam16i/DUO"
expr_stmt|;
name|sc
operator|->
name|mbitmap
operator|=
name|MB_HA
operator||
name|MB_HT
operator||
name|MB_H2
expr_stmt|;
break|break;
default|default:
name|sc
operator|->
name|typestr
operator|=
literal|"EtherTeam16i"
expr_stmt|;
name|sc
operator|->
name|stability
operator||=
name|UNSTABLE_TYPE
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"fe%d: unknown model code %02x for EtherTeam16i\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|eeprom
index|[
literal|0x5E
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|sc
operator|->
name|type
operator|=
name|FE_TYPE_JLI
expr_stmt|;
comment|/* I'm not sure the following msel hook is required by all            models or COMBO only...  FIXME.  */
name|sc
operator|->
name|msel
operator|=
name|fe_msel_icl
expr_stmt|;
comment|/* Make the configured media selection the default media.  */
switch|switch
condition|(
name|eeprom
index|[
literal|0x28
index|]
condition|)
block|{
case|case
literal|0
case|:
name|defmedia
operator|=
name|MB_HA
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|defmedia
operator|=
name|MB_H5
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|defmedia
operator|=
name|MB_HT
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|defmedia
operator|=
name|MB_H2
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"fe%d: unknown default media: %02x\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|eeprom
index|[
literal|0x28
index|]
argument_list|)
expr_stmt|;
block|}
name|defmedia
operator|=
name|MB_HA
expr_stmt|;
break|break;
block|}
comment|/* Make sure the default media is compatible with the 	   supported media.  */
if|if
condition|(
operator|(
name|defmedia
operator|&
name|sc
operator|->
name|mbitmap
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"fe%d: default media adjusted\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
block|}
name|defmedia
operator|=
name|sc
operator|->
name|mbitmap
expr_stmt|;
block|}
comment|/* Keep the determined default media.  */
name|sc
operator|->
name|defmedia
operator|=
name|defmedia
expr_stmt|;
comment|/* ICL has "fat" models.  We have to program 86965 to properly 	   reflect the hardware.  */
name|d6
operator|=
name|sc
operator|->
name|proto_dlcr6
operator|&
operator|~
operator|(
name|FE_D6_BUFSIZ
operator||
name|FE_D6_BBW
operator|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|eeprom
index|[
literal|0x61
index|]
operator|<<
literal|8
operator|)
operator||
name|eeprom
index|[
literal|0x60
index|]
condition|)
block|{
case|case
literal|0x2008
case|:
name|d6
operator||=
name|FE_D6_BUFSIZ_32KB
operator||
name|FE_D6_BBW_BYTE
expr_stmt|;
break|break;
case|case
literal|0x4010
case|:
name|d6
operator||=
name|FE_D6_BUFSIZ_64KB
operator||
name|FE_D6_BBW_WORD
expr_stmt|;
break|break;
default|default:
comment|/* We can't support it, since we don't know which bits 		   to set in DLCR6.  */
name|printf
argument_list|(
literal|"fe%d: unknown SRAM config for ICL\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|sc
operator|->
name|proto_dlcr6
operator|=
name|d6
expr_stmt|;
comment|/* Returns the IRQ table for the ICL board.  */
return|return
name|irqmap_icl
return|;
block|}
end_function

begin_comment
comment|/* JLI sub-probe for RATOC REX-5586/5587.  */
end_comment

begin_function
specifier|static
name|u_short
specifier|const
modifier|*
name|fe_probe_jli_rex
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|,
name|u_char
specifier|const
modifier|*
name|eeprom
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|static
name|u_short
specifier|const
name|irqmap_rex
index|[
literal|4
index|]
init|=
block|{
literal|3
block|,
literal|4
block|,
literal|5
block|,
name|NO_IRQ
block|}
decl_stmt|;
comment|/* Make sure the EEPROM contains RATOC's config pattern.  */
if|if
condition|(
name|eeprom
index|[
literal|1
index|]
operator|!=
name|eeprom
index|[
literal|0
index|]
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|8
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|eeprom
index|[
name|i
index|]
operator|!=
literal|0xFF
condition|)
return|return
name|NULL
return|;
comment|/* Get our station address from EEPROM.  Note that RATOC 	   stores it "byte-swapped" in each word.  (I don't know why.) 	   So, we just can't use bcopy().*/
name|sc
operator|->
name|sc_enaddr
index|[
literal|0
index|]
operator|=
name|eeprom
index|[
literal|3
index|]
expr_stmt|;
name|sc
operator|->
name|sc_enaddr
index|[
literal|1
index|]
operator|=
name|eeprom
index|[
literal|2
index|]
expr_stmt|;
name|sc
operator|->
name|sc_enaddr
index|[
literal|2
index|]
operator|=
name|eeprom
index|[
literal|5
index|]
expr_stmt|;
name|sc
operator|->
name|sc_enaddr
index|[
literal|3
index|]
operator|=
name|eeprom
index|[
literal|4
index|]
expr_stmt|;
name|sc
operator|->
name|sc_enaddr
index|[
literal|4
index|]
operator|=
name|eeprom
index|[
literal|7
index|]
expr_stmt|;
name|sc
operator|->
name|sc_enaddr
index|[
literal|5
index|]
operator|=
name|eeprom
index|[
literal|6
index|]
expr_stmt|;
comment|/* Make sure the EEPROM contains RATOC's station address.  */
if|if
condition|(
operator|!
name|valid_Ether_p
argument_list|(
name|sc
operator|->
name|sc_enaddr
argument_list|,
literal|0x00C0D0
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* I don't know any sub-model identification.  */
name|sc
operator|->
name|type
operator|=
name|FE_TYPE_JLI
expr_stmt|;
name|sc
operator|->
name|typestr
operator|=
literal|"REX-5586/5587"
expr_stmt|;
comment|/* Returns the IRQ for the RATOC board.  */
return|return
name|irqmap_rex
return|;
block|}
end_function

begin_comment
comment|/* JLI sub-probe for Unknown board.  */
end_comment

begin_function
specifier|static
name|u_short
specifier|const
modifier|*
name|fe_probe_jli_unk
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|,
name|u_char
specifier|const
modifier|*
name|eeprom
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|romsize
decl_stmt|;
specifier|static
name|u_short
specifier|const
name|irqmap
index|[
literal|4
index|]
init|=
block|{
name|NO_IRQ
block|,
name|NO_IRQ
block|,
name|NO_IRQ
block|,
name|NO_IRQ
block|}
decl_stmt|;
comment|/* The generic JLI probe considered this board has an 86965 	   in JLI mode, but any other board-specific routines could 	   not find the matching implementation.  So, we "guess" the 	   location by looking for a bit pattern which looks like a 	   MAC address.  */
comment|/* Determine how large the EEPROM is.  */
for|for
control|(
name|romsize
operator|=
name|JLI_EEPROM_SIZE
operator|/
literal|2
init|;
name|romsize
operator|>
literal|16
condition|;
name|romsize
operator|>>=
literal|1
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|romsize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eeprom
index|[
name|i
index|]
operator|!=
name|eeprom
index|[
name|i
operator|+
name|romsize
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|<
name|romsize
condition|)
break|break;
block|}
name|romsize
operator|<<=
literal|1
expr_stmt|;
comment|/* Look for a bit pattern which looks like a MAC address.  */
for|for
control|(
name|n
operator|=
literal|2
init|;
name|n
operator|<=
name|romsize
operator|-
name|ETHER_ADDR_LEN
condition|;
name|n
operator|+=
literal|2
control|)
block|{
if|if
condition|(
operator|!
name|valid_Ether_p
argument_list|(
name|eeprom
operator|+
name|n
argument_list|,
literal|0x000000
argument_list|)
condition|)
continue|continue;
block|}
comment|/* If no reasonable address was found, we can't go further.  */
if|if
condition|(
name|n
operator|>
name|romsize
operator|-
name|ETHER_ADDR_LEN
condition|)
return|return
name|NULL
return|;
comment|/* Extract our (guessed) station address.  */
name|bcopy
argument_list|(
name|eeprom
operator|+
name|n
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* We are not sure what type of board it is... */
name|sc
operator|->
name|type
operator|=
name|FE_TYPE_JLI
expr_stmt|;
name|sc
operator|->
name|typestr
operator|=
literal|"(unknown JLI)"
expr_stmt|;
name|sc
operator|->
name|stability
operator||=
name|UNSTABLE_TYPE
operator||
name|UNSTABLE_MAC
expr_stmt|;
comment|/* Returns the totally unknown IRQ mapping table.  */
return|return
name|irqmap
return|;
block|}
end_function

begin_comment
comment|/*  * Probe and initialization for all JLI implementations.  */
end_comment

begin_function
specifier|static
name|int
name|fe_probe_jli
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|error
decl_stmt|,
name|xirq
decl_stmt|;
name|u_long
name|iobase
decl_stmt|,
name|irq
decl_stmt|;
name|u_char
name|eeprom
index|[
name|JLI_EEPROM_SIZE
index|]
decl_stmt|;
name|u_short
specifier|const
modifier|*
name|irqmap
decl_stmt|;
specifier|static
name|u_short
specifier|const
name|baseaddr
index|[
literal|8
index|]
init|=
block|{
literal|0x260
block|,
literal|0x280
block|,
literal|0x2A0
block|,
literal|0x240
block|,
literal|0x340
block|,
literal|0x320
block|,
literal|0x380
block|,
literal|0x300
block|}
decl_stmt|;
specifier|static
name|struct
name|fe_simple_probe_struct
specifier|const
name|probe_table
index|[]
init|=
block|{
block|{
name|FE_DLCR1
block|,
literal|0x20
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR2
block|,
literal|0x50
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR4
block|,
literal|0x08
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR5
block|,
literal|0x80
block|,
literal|0x00
block|}
block|,
if|#
directive|if
literal|0
block|{ FE_BMPR16, 0x1B, 0x00 }, 		{ FE_BMPR17, 0x7F, 0x00 },
endif|#
directive|endif
block|{
literal|0
block|}
block|}
decl_stmt|;
comment|/* 	 * See if the specified address is possible for MB86965A JLI mode. 	 */
if|if
condition|(
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|,
operator|&
name|iobase
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|ENXIO
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|baseaddr
index|[
name|i
index|]
operator|==
name|iobase
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|8
condition|)
return|return
name|ENXIO
return|;
comment|/* 86965 JLI occupies 32 I/O addresses. */
if|if
condition|(
name|fe_alloc_port
argument_list|(
name|dev
argument_list|,
literal|32
argument_list|)
condition|)
return|return
name|ENXIO
return|;
comment|/* Fill the softc struct with reasonable default.  */
name|fe_softc_defaults
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * We should test if MB86965A is on the base address now. 	 * Unfortunately, it is very hard to probe it reliably, since 	 * we have no way to reset the chip under software control. 	 * On cold boot, we could check the "signature" bit patterns 	 * described in the Fujitsu document.  On warm boot, however, 	 * we can predict almost nothing about register values. 	 */
if|if
condition|(
operator|!
name|fe_simple_probe
argument_list|(
name|sc
argument_list|,
name|probe_table
argument_list|)
condition|)
return|return
name|ENXIO
return|;
comment|/* Check if our I/O address matches config info on 86965.  */
name|n
operator|=
operator|(
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR19
argument_list|)
operator|&
name|FE_B19_ADDR
operator|)
operator|>>
name|FE_B19_ADDR_SHIFT
expr_stmt|;
if|if
condition|(
name|baseaddr
index|[
name|n
index|]
operator|!=
name|iobase
condition|)
return|return
name|ENXIO
return|;
comment|/* 	 * We are now almost sure we have an MB86965 at the given 	 * address.  So, read EEPROM through it.  We have to write 	 * into LSI registers to read from EEPROM.  I want to avoid it 	 * at this stage, but I cannot test the presence of the chip 	 * any further without reading EEPROM.  FIXME. 	 */
name|fe_read_eeprom_jli
argument_list|(
name|sc
argument_list|,
name|eeprom
argument_list|)
expr_stmt|;
comment|/* Make sure that config info in EEPROM and 86965 agree.  */
if|if
condition|(
name|eeprom
index|[
name|FE_EEPROM_CONF
index|]
operator|!=
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR19
argument_list|)
condition|)
return|return
name|ENXIO
return|;
comment|/* Use 86965 media selection scheme, unless othewise            specified.  It is "AUTO always" and "select with BMPR13."            This behaviour covers most of the 86965 based board (as            minimum requirements.)  It is backward compatible with            previous versions, also.  */
name|sc
operator|->
name|mbitmap
operator|=
name|MB_HA
expr_stmt|;
name|sc
operator|->
name|defmedia
operator|=
name|MB_HA
expr_stmt|;
name|sc
operator|->
name|msel
operator|=
name|fe_msel_965
expr_stmt|;
comment|/* Perform board-specific probe, one by one.  Note that the            order of probe is important and should not be changed            arbitrarily.  */
if|if
condition|(
operator|(
name|irqmap
operator|=
name|fe_probe_jli_ati
argument_list|(
name|sc
argument_list|,
name|eeprom
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
operator|(
name|irqmap
operator|=
name|fe_probe_jli_rex
argument_list|(
name|sc
argument_list|,
name|eeprom
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
operator|(
name|irqmap
operator|=
name|fe_probe_jli_icl
argument_list|(
name|sc
argument_list|,
name|eeprom
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
operator|(
name|irqmap
operator|=
name|fe_probe_jli_unk
argument_list|(
name|sc
argument_list|,
name|eeprom
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
comment|/* Find the IRQ read from EEPROM.  */
name|n
operator|=
operator|(
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR19
argument_list|)
operator|&
name|FE_B19_IRQ
operator|)
operator|>>
name|FE_B19_IRQ_SHIFT
expr_stmt|;
name|xirq
operator|=
name|irqmap
index|[
name|n
index|]
expr_stmt|;
comment|/* Try to determine IRQ setting.  */
name|error
operator|=
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
operator|&
name|irq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|xirq
operator|==
name|NO_IRQ
condition|)
block|{
comment|/* The device must be configured with an explicit IRQ.  */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"IRQ auto-detection does not work\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
elseif|else
if|if
condition|(
name|error
operator|&&
name|xirq
operator|!=
name|NO_IRQ
condition|)
block|{
comment|/* Just use the probed IRQ value.  */
name|bus_set_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|xirq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|error
operator|&&
name|xirq
operator|==
name|NO_IRQ
condition|)
block|{
comment|/* No problem.  Go ahead.  */
block|}
elseif|else
if|if
condition|(
name|irq
operator|==
name|xirq
condition|)
block|{
comment|/* Good.  Go ahead.  */
block|}
else|else
block|{
comment|/* User must be warned in this case.  */
name|sc
operator|->
name|stability
operator||=
name|UNSTABLE_IRQ
expr_stmt|;
block|}
comment|/* Setup a hook, which resets te 86965 when the driver is being            initialized.  This may solve a nasty bug.  FIXME.  */
name|sc
operator|->
name|init
operator|=
name|fe_init_jli
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Probe for TDK LAK-AX031, which is an SSi 78Q8377A based board.  */
end_comment

begin_function
specifier|static
name|int
name|fe_probe_ssi
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_long
name|iobase
decl_stmt|,
name|irq
decl_stmt|;
name|u_char
name|eeprom
index|[
name|SSI_EEPROM_SIZE
index|]
decl_stmt|;
specifier|static
name|struct
name|fe_simple_probe_struct
name|probe_table
index|[]
init|=
block|{
block|{
name|FE_DLCR2
block|,
literal|0x08
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR4
block|,
literal|0x08
block|,
literal|0x00
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
comment|/* See if the specified I/O address is possible for 78Q8377A.  */
if|if
condition|(
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|,
operator|&
name|iobase
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
operator|(
name|iobase
operator|&
operator|~
literal|0x3F0
operator|)
operator|!=
literal|0x000
condition|)
return|return
name|ENXIO
return|;
comment|/* We have 16 registers.  */
if|if
condition|(
name|fe_alloc_port
argument_list|(
name|dev
argument_list|,
literal|16
argument_list|)
condition|)
return|return
name|ENXIO
return|;
comment|/* Fill the softc struct with default values.  */
name|fe_softc_defaults
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* See if the card is on its address.  */
if|if
condition|(
operator|!
name|fe_simple_probe
argument_list|(
name|sc
argument_list|,
name|probe_table
argument_list|)
condition|)
return|return
name|ENXIO
return|;
comment|/* We now have to read the config EEPROM.  We should be very            careful, since doing so destroys a register.  (Remember, we            are not yet sure we have a LAK-AX031 board here.)  Don't            remember to select BMPRs bofore reading EEPROM, since other            register bank may be selected before the probe() is called.  */
name|fe_read_eeprom_ssi
argument_list|(
name|sc
argument_list|,
name|eeprom
argument_list|)
expr_stmt|;
comment|/* Make sure the Ethernet (MAC) station address is of TDK's.  */
if|if
condition|(
operator|!
name|valid_Ether_p
argument_list|(
name|eeprom
operator|+
name|FE_SSI_EEP_ADDR
argument_list|,
literal|0x008098
argument_list|)
condition|)
return|return
name|ENXIO
return|;
name|bcopy
argument_list|(
name|eeprom
operator|+
name|FE_SSI_EEP_ADDR
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* This looks like a TDK-AX031 board.  It requires an explicit 	   IRQ setting in config, since we currently don't know how we 	   can find the IRQ value assigned by ISA PnP manager.  */
if|if
condition|(
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
operator|&
name|irq
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fe_irq_failure
argument_list|(
literal|"LAK-AX031"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|NO_IRQ
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/* Fill softc struct accordingly.  */
name|sc
operator|->
name|type
operator|=
name|FE_TYPE_SSI
expr_stmt|;
name|sc
operator|->
name|typestr
operator|=
literal|"LAK-AX031"
expr_stmt|;
name|sc
operator|->
name|mbitmap
operator|=
name|MB_HT
expr_stmt|;
name|sc
operator|->
name|defmedia
operator|=
name|MB_HT
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Probe and initialization for TDK/LANX LAC-AX012/013 boards.  */
end_comment

begin_function
specifier|static
name|int
name|fe_probe_lnx
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_long
name|iobase
decl_stmt|,
name|irq
decl_stmt|;
name|u_char
name|eeprom
index|[
name|LNX_EEPROM_SIZE
index|]
decl_stmt|;
specifier|static
name|struct
name|fe_simple_probe_struct
name|probe_table
index|[]
init|=
block|{
block|{
name|FE_DLCR2
block|,
literal|0x58
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR4
block|,
literal|0x08
block|,
literal|0x00
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
comment|/* See if the specified I/O address is possible for TDK/LANX boards. */
comment|/* 300, 320, 340, and 360 are allowed.  */
if|if
condition|(
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|,
operator|&
name|iobase
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
operator|(
name|iobase
operator|&
operator|~
literal|0x060
operator|)
operator|!=
literal|0x300
condition|)
return|return
name|ENXIO
return|;
comment|/* We have 32 registers.  */
if|if
condition|(
name|fe_alloc_port
argument_list|(
name|dev
argument_list|,
literal|32
argument_list|)
condition|)
return|return
name|ENXIO
return|;
comment|/* Fill the softc struct with default values.  */
name|fe_softc_defaults
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* See if the card is on its address.  */
if|if
condition|(
operator|!
name|fe_simple_probe
argument_list|(
name|sc
argument_list|,
name|probe_table
argument_list|)
condition|)
return|return
name|ENXIO
return|;
comment|/* We now have to read the config EEPROM.  We should be very            careful, since doing so destroys a register.  (Remember, we            are not yet sure we have a LAC-AX012/AX013 board here.)  */
name|fe_read_eeprom_lnx
argument_list|(
name|sc
argument_list|,
name|eeprom
argument_list|)
expr_stmt|;
comment|/* Make sure the Ethernet (MAC) station address is of TDK/LANX's.  */
if|if
condition|(
operator|!
name|valid_Ether_p
argument_list|(
name|eeprom
argument_list|,
literal|0x008098
argument_list|)
condition|)
return|return
name|ENXIO
return|;
name|bcopy
argument_list|(
name|eeprom
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* This looks like a TDK/LANX board.  It requires an 	   explicit IRQ setting in config.  Make sure we have one, 	   determining an appropriate value for the IRQ control 	   register.  */
name|irq
operator|=
literal|0
expr_stmt|;
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
operator|&
name|irq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|irq
condition|)
block|{
case|case
literal|3
case|:
name|sc
operator|->
name|priv_info
operator|=
literal|0x40
operator||
name|LNX_CLK_LO
operator||
name|LNX_SDA_HI
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|sc
operator|->
name|priv_info
operator|=
literal|0x20
operator||
name|LNX_CLK_LO
operator||
name|LNX_SDA_HI
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|sc
operator|->
name|priv_info
operator|=
literal|0x10
operator||
name|LNX_CLK_LO
operator||
name|LNX_SDA_HI
expr_stmt|;
break|break;
case|case
literal|9
case|:
name|sc
operator|->
name|priv_info
operator|=
literal|0x80
operator||
name|LNX_CLK_LO
operator||
name|LNX_SDA_HI
expr_stmt|;
break|break;
default|default:
name|fe_irq_failure
argument_list|(
literal|"LAC-AX012/AX013"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|irq
argument_list|,
literal|"3/4/5/9"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/* Fill softc struct accordingly.  */
name|sc
operator|->
name|type
operator|=
name|FE_TYPE_LNX
expr_stmt|;
name|sc
operator|->
name|typestr
operator|=
literal|"LAC-AX012/AX013"
expr_stmt|;
name|sc
operator|->
name|init
operator|=
name|fe_init_lnx
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Probe and initialization for Gateway Communications' old cards.  */
end_comment

begin_function
specifier|static
name|int
name|fe_probe_gwy
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_long
name|iobase
decl_stmt|,
name|irq
decl_stmt|;
specifier|static
name|struct
name|fe_simple_probe_struct
name|probe_table
index|[]
init|=
block|{
comment|/*	{ FE_DLCR2, 0x70, 0x00 }, */
block|{
name|FE_DLCR2
block|,
literal|0x58
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR4
block|,
literal|0x08
block|,
literal|0x00
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
comment|/* See if the specified I/O address is possible for Gateway boards.  */
if|if
condition|(
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|,
operator|&
name|iobase
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
operator|(
name|iobase
operator|&
operator|~
literal|0x1E0
operator|)
operator|!=
literal|0x200
condition|)
return|return
name|ENXIO
return|;
comment|/* That's all.  The card occupies 32 I/O addresses, as always.  */
if|if
condition|(
name|fe_alloc_port
argument_list|(
name|dev
argument_list|,
literal|32
argument_list|)
condition|)
return|return
name|ENXIO
return|;
comment|/* Setup an I/O address mapping table and some others.  */
name|fe_softc_defaults
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* See if the card is on its address.  */
if|if
condition|(
operator|!
name|fe_simple_probe
argument_list|(
name|sc
argument_list|,
name|probe_table
argument_list|)
condition|)
return|return
name|ENXIO
return|;
comment|/* Get our station address from EEPROM. */
name|fe_inblk
argument_list|(
name|sc
argument_list|,
literal|0x18
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* Make sure it is Gateway Communication's.  */
if|if
condition|(
operator|!
name|valid_Ether_p
argument_list|(
name|sc
operator|->
name|sc_enaddr
argument_list|,
literal|0x000061
argument_list|)
condition|)
return|return
name|ENXIO
return|;
comment|/* Gateway's board requires an explicit IRQ to work, since it 	   is not possible to probe the setting of jumpers.  */
if|if
condition|(
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
operator|&
name|irq
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fe_irq_failure
argument_list|(
literal|"Gateway Ethernet"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|NO_IRQ
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/* Fill softc struct accordingly.  */
name|sc
operator|->
name|type
operator|=
name|FE_TYPE_GWY
expr_stmt|;
name|sc
operator|->
name|typestr
operator|=
literal|"Gateway Ethernet (Fujitsu chipset)"
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Probe and initialization for Ungermann-Bass Network    K.K. "Access/PC" boards.  */
end_comment

begin_function
specifier|static
name|int
name|fe_probe_ubn
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_long
name|iobase
decl_stmt|,
name|irq
decl_stmt|;
if|#
directive|if
literal|0
block|u_char sum;
endif|#
directive|endif
specifier|static
name|struct
name|fe_simple_probe_struct
specifier|const
name|probe_table
index|[]
init|=
block|{
block|{
name|FE_DLCR2
block|,
literal|0x58
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR4
block|,
literal|0x08
block|,
literal|0x00
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
comment|/* See if the specified I/O address is possible for AccessPC/ISA.  */
if|if
condition|(
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|,
operator|&
name|iobase
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
operator|(
name|iobase
operator|&
operator|~
literal|0x0E0
operator|)
operator|!=
literal|0x300
condition|)
return|return
name|ENXIO
return|;
comment|/* We have 32 registers.  */
if|if
condition|(
name|fe_alloc_port
argument_list|(
name|dev
argument_list|,
literal|32
argument_list|)
condition|)
return|return
name|ENXIO
return|;
comment|/* Setup an I/O address mapping table and some others.  */
name|fe_softc_defaults
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Simple probe.  */
if|if
condition|(
operator|!
name|fe_simple_probe
argument_list|(
name|sc
argument_list|,
name|probe_table
argument_list|)
condition|)
return|return
name|ENXIO
return|;
comment|/* Get our station address form ID ROM and make sure it is UBN's.  */
name|fe_inblk
argument_list|(
name|sc
argument_list|,
literal|0x18
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|valid_Ether_p
argument_list|(
name|sc
operator|->
name|sc_enaddr
argument_list|,
literal|0x00DD01
argument_list|)
condition|)
return|return
name|ENXIO
return|;
if|#
directive|if
literal|0
comment|/* Calculate checksum.  */
block|sum = fe_inb(sc, 0x1e); 	for (i = 0; i< ETHER_ADDR_LEN; i++) { 		sum ^= sc->sc_enaddr[i]; 	} 	if (sum != 0) 		return ENXIO;
endif|#
directive|endif
comment|/* This looks like an AccessPC/ISA board.  It requires an 	   explicit IRQ setting in config.  Make sure we have one, 	   determining an appropriate value for the IRQ control 	   register.  */
name|irq
operator|=
literal|0
expr_stmt|;
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
operator|&
name|irq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|irq
condition|)
block|{
case|case
literal|3
case|:
name|sc
operator|->
name|priv_info
operator|=
literal|0x02
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|sc
operator|->
name|priv_info
operator|=
literal|0x04
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|sc
operator|->
name|priv_info
operator|=
literal|0x08
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|sc
operator|->
name|priv_info
operator|=
literal|0x10
expr_stmt|;
break|break;
default|default:
name|fe_irq_failure
argument_list|(
literal|"Access/PC"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|irq
argument_list|,
literal|"3/4/5/10"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/* Fill softc struct accordingly.  */
name|sc
operator|->
name|type
operator|=
name|FE_TYPE_UBN
expr_stmt|;
name|sc
operator|->
name|typestr
operator|=
literal|"Access/PC"
expr_stmt|;
name|sc
operator|->
name|init
operator|=
name|fe_init_ubn
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

