begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * All Rights Reserved, Copyright (C) Fujitsu Limited 1995  *  * This software may be used, modified, copied, distributed, and sold, in  * both source and binary form provided that the above copyright, these  * terms and the following disclaimer are retained.  The name of the author  * and/or the contributor may not be used to endorse or promote products  * derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND THE CONTRIBUTOR ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR THE CONTRIBUTOR BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION.  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_fe.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_ipx.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_mib.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/ic/mb86960.h>
end_include

begin_include
include|#
directive|include
file|<dev/fe/if_fereg.h>
end_include

begin_include
include|#
directive|include
file|<dev/fe/if_fevar.h>
end_include

begin_include
include|#
directive|include
file|<isa/isavar.h>
end_include

begin_comment
comment|/*  *	Cbus specific code.  */
end_comment

begin_function_decl
specifier|static
name|int
name|fe_isa_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fe_isa_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|fe_isa_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|fe_isa_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|fe_isa_attach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|fe_isa_driver
init|=
block|{
literal|"fe"
block|,
name|fe_isa_methods
block|,
expr|sizeof
operator|(
expr|struct
name|fe_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|fe
argument_list|,
name|isa
argument_list|,
name|fe_isa_driver
argument_list|,
name|fe_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|fe98_alloc_port
parameter_list|(
name|device_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fe_probe_re1000
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fe_probe_cnet9ne
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fe_probe_rex
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fe_probe_ssi
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fe_probe_jli
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fe_probe_lnx
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fe_probe_gwy
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fe_probe_ubn
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Determine if the device is present at a specified I/O address.  The  * main entry to the driver.  */
end_comment

begin_function
specifier|static
name|int
name|fe_isa_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Check isapnp ids */
if|if
condition|(
name|isa_get_vendorid
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Prepare for the softc struct.  */
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Probe for supported boards.  */
ifdef|#
directive|ifdef
name|PC98
if|if
condition|(
operator|(
name|error
operator|=
name|fe_probe_re1000
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|end
goto|;
name|fe_release_resource
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|fe_probe_cnet9ne
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|end
goto|;
name|fe_release_resource
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|fe_probe_rex
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|end
goto|;
name|fe_release_resource
argument_list|(
name|dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|error
operator|=
name|fe_probe_ssi
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|end
goto|;
name|fe_release_resource
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|fe_probe_jli
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|end
goto|;
name|fe_release_resource
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|fe_probe_lnx
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|end
goto|;
name|fe_release_resource
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|fe_probe_ubn
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|end
goto|;
name|fe_release_resource
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|fe_probe_gwy
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|end
goto|;
name|fe_release_resource
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|end
label|:
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|fe_alloc_irq
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fe_release_resource
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fe_isa_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|port_used
condition|)
name|fe98_alloc_port
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|type
argument_list|)
expr_stmt|;
name|fe_alloc_irq
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|fe_attach
argument_list|(
name|dev
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generic I/O address table */
end_comment

begin_decl_stmt
specifier|static
name|bus_addr_t
name|ioaddr_generic
index|[
name|MAXREGISTERS
index|]
init|=
block|{
literal|0x000
block|,
literal|0x001
block|,
literal|0x002
block|,
literal|0x003
block|,
literal|0x004
block|,
literal|0x005
block|,
literal|0x006
block|,
literal|0x007
block|,
literal|0x008
block|,
literal|0x009
block|,
literal|0x00a
block|,
literal|0x00b
block|,
literal|0x00c
block|,
literal|0x00d
block|,
literal|0x00e
block|,
literal|0x00f
block|,
literal|0x010
block|,
literal|0x011
block|,
literal|0x012
block|,
literal|0x013
block|,
literal|0x014
block|,
literal|0x015
block|,
literal|0x016
block|,
literal|0x017
block|,
literal|0x018
block|,
literal|0x019
block|,
literal|0x01a
block|,
literal|0x01b
block|,
literal|0x01c
block|,
literal|0x01d
block|,
literal|0x01e
block|,
literal|0x01f
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* I/O address table for RE1000/1000Plus */
end_comment

begin_decl_stmt
specifier|static
name|bus_addr_t
name|ioaddr_re1000
index|[
name|MAXREGISTERS
index|]
init|=
block|{
literal|0x0000
block|,
literal|0x0001
block|,
literal|0x0200
block|,
literal|0x0201
block|,
literal|0x0400
block|,
literal|0x0401
block|,
literal|0x0600
block|,
literal|0x0601
block|,
literal|0x0800
block|,
literal|0x0801
block|,
literal|0x0a00
block|,
literal|0x0a01
block|,
literal|0x0c00
block|,
literal|0x0c01
block|,
literal|0x0e00
block|,
literal|0x0e01
block|,
literal|0x1000
block|,
literal|0x1200
block|,
literal|0x1400
block|,
literal|0x1600
block|,
literal|0x1800
block|,
literal|0x1a00
block|,
literal|0x1c00
block|,
literal|0x1e00
block|,
literal|0x1001
block|,
literal|0x1201
block|,
literal|0x1401
block|,
literal|0x1601
block|,
literal|0x1801
block|,
literal|0x1a01
block|,
literal|0x1c01
block|,
literal|0x1e01
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* I/O address table for CNET9NE */
end_comment

begin_decl_stmt
specifier|static
name|bus_addr_t
name|ioaddr_cnet9ne
index|[
name|MAXREGISTERS
index|]
init|=
block|{
literal|0x000
block|,
literal|0x001
block|,
literal|0x002
block|,
literal|0x003
block|,
literal|0x004
block|,
literal|0x005
block|,
literal|0x006
block|,
literal|0x007
block|,
literal|0x008
block|,
literal|0x009
block|,
literal|0x00a
block|,
literal|0x00b
block|,
literal|0x00c
block|,
literal|0x00d
block|,
literal|0x00e
block|,
literal|0x00f
block|,
literal|0x400
block|,
literal|0x402
block|,
literal|0x404
block|,
literal|0x406
block|,
literal|0x408
block|,
literal|0x40a
block|,
literal|0x40c
block|,
literal|0x40e
block|,
literal|0x401
block|,
literal|0x403
block|,
literal|0x405
block|,
literal|0x407
block|,
literal|0x409
block|,
literal|0x40b
block|,
literal|0x40d
block|,
literal|0x40f
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* I/O address table for LAC-98 */
end_comment

begin_decl_stmt
specifier|static
name|bus_addr_t
name|ioaddr_lnx
index|[
name|MAXREGISTERS
index|]
init|=
block|{
literal|0x000
block|,
literal|0x002
block|,
literal|0x004
block|,
literal|0x006
block|,
literal|0x008
block|,
literal|0x00a
block|,
literal|0x00c
block|,
literal|0x00e
block|,
literal|0x100
block|,
literal|0x102
block|,
literal|0x104
block|,
literal|0x106
block|,
literal|0x108
block|,
literal|0x10a
block|,
literal|0x10c
block|,
literal|0x10e
block|,
literal|0x200
block|,
literal|0x202
block|,
literal|0x204
block|,
literal|0x206
block|,
literal|0x208
block|,
literal|0x20a
block|,
literal|0x20c
block|,
literal|0x20e
block|,
literal|0x300
block|,
literal|0x302
block|,
literal|0x304
block|,
literal|0x306
block|,
literal|0x308
block|,
literal|0x30a
block|,
literal|0x30c
block|,
literal|0x30e
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* I/O address table for Access/PC N98C+ */
end_comment

begin_decl_stmt
specifier|static
name|bus_addr_t
name|ioaddr_ubn
index|[
name|MAXREGISTERS
index|]
init|=
block|{
literal|0x000
block|,
literal|0x001
block|,
literal|0x002
block|,
literal|0x003
block|,
literal|0x004
block|,
literal|0x005
block|,
literal|0x006
block|,
literal|0x007
block|,
literal|0x008
block|,
literal|0x009
block|,
literal|0x00a
block|,
literal|0x00b
block|,
literal|0x00c
block|,
literal|0x00d
block|,
literal|0x00e
block|,
literal|0x00f
block|,
literal|0x200
block|,
literal|0x201
block|,
literal|0x202
block|,
literal|0x203
block|,
literal|0x204
block|,
literal|0x205
block|,
literal|0x206
block|,
literal|0x207
block|,
literal|0x208
block|,
literal|0x209
block|,
literal|0x20a
block|,
literal|0x20b
block|,
literal|0x20c
block|,
literal|0x20d
block|,
literal|0x20e
block|,
literal|0x20f
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* I/O address table for REX-9880 */
end_comment

begin_decl_stmt
specifier|static
name|bus_addr_t
name|ioaddr_rex
index|[
name|MAXREGISTERS
index|]
init|=
block|{
literal|0x000
block|,
literal|0x001
block|,
literal|0x002
block|,
literal|0x003
block|,
literal|0x004
block|,
literal|0x005
block|,
literal|0x006
block|,
literal|0x007
block|,
literal|0x008
block|,
literal|0x009
block|,
literal|0x00a
block|,
literal|0x00b
block|,
literal|0x00c
block|,
literal|0x00d
block|,
literal|0x00e
block|,
literal|0x00f
block|,
literal|0x100
block|,
literal|0x101
block|,
literal|0x102
block|,
literal|0x103
block|,
literal|0x104
block|,
literal|0x105
block|,
literal|0x106
block|,
literal|0x107
block|,
literal|0x108
block|,
literal|0x109
block|,
literal|0x10a
block|,
literal|0x10b
block|,
literal|0x10c
block|,
literal|0x10d
block|,
literal|0x10e
block|,
literal|0x10f
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|fe98_alloc_port
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|bus_addr_t
modifier|*
name|iat
decl_stmt|;
name|int
name|size
decl_stmt|,
name|rid
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|FE_TYPE_RE1000
case|:
name|iat
operator|=
name|ioaddr_re1000
expr_stmt|;
name|size
operator|=
name|MAXREGISTERS
expr_stmt|;
break|break;
case|case
name|FE_TYPE_CNET9NE
case|:
name|iat
operator|=
name|ioaddr_cnet9ne
expr_stmt|;
name|size
operator|=
name|MAXREGISTERS
expr_stmt|;
break|break;
case|case
name|FE_TYPE_SSI
case|:
name|iat
operator|=
name|ioaddr_generic
expr_stmt|;
name|size
operator|=
name|MAXREGISTERS
expr_stmt|;
break|break;
case|case
name|FE_TYPE_LNX
case|:
name|iat
operator|=
name|ioaddr_lnx
expr_stmt|;
name|size
operator|=
name|MAXREGISTERS
expr_stmt|;
break|break;
case|case
name|FE_TYPE_GWY
case|:
name|iat
operator|=
name|ioaddr_generic
expr_stmt|;
name|size
operator|=
name|MAXREGISTERS
expr_stmt|;
break|break;
case|case
name|FE_TYPE_UBN
case|:
name|iat
operator|=
name|ioaddr_ubn
expr_stmt|;
name|size
operator|=
name|MAXREGISTERS
expr_stmt|;
break|break;
case|case
name|FE_TYPE_REX
case|:
name|iat
operator|=
name|ioaddr_rex
expr_stmt|;
name|size
operator|=
name|MAXREGISTERS
expr_stmt|;
break|break;
default|default:
name|iat
operator|=
name|ioaddr_generic
expr_stmt|;
name|size
operator|=
name|MAXREGISTERS
expr_stmt|;
break|break;
block|}
name|rid
operator|=
literal|0
expr_stmt|;
name|res
operator|=
name|isa_alloc_resourcev
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|rid
argument_list|,
name|iat
argument_list|,
name|size
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
return|return
name|ENOENT
return|;
name|isa_load_resourcev
argument_list|(
name|res
argument_list|,
name|iat
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|sc
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|sc
operator|->
name|port_used
operator|=
name|size
expr_stmt|;
name|sc
operator|->
name|port_res
operator|=
name|res
expr_stmt|;
name|sc
operator|->
name|iot
operator|=
name|rman_get_bustag
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ioh
operator|=
name|rman_get_bushandle
argument_list|(
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Probe and initialization for Allied-Telesis RE1000 series.  */
end_comment

begin_function
specifier|static
name|void
name|fe_init_re1000
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Setup IRQ control register on the ASIC.  */
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_RE1000_IRQCONF
argument_list|,
name|sc
operator|->
name|priv_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fe_probe_re1000
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|u_long
name|iobase
decl_stmt|,
name|irq
decl_stmt|;
name|u_char
name|sum
decl_stmt|;
specifier|static
name|struct
name|fe_simple_probe_struct
name|probe_table
index|[]
init|=
block|{
block|{
name|FE_DLCR2
block|,
literal|0x58
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR4
block|,
literal|0x08
block|,
literal|0x00
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
comment|/* See if the specified I/O address is possible for RE1000.  */
comment|/* [01]D[02468ACE] are allowed.  */
if|if
condition|(
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|,
operator|&
name|iobase
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
operator|(
name|iobase
operator|&
operator|~
literal|0x10E
operator|)
operator|!=
literal|0xD0
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
name|fe98_alloc_port
argument_list|(
name|dev
argument_list|,
name|FE_TYPE_RE1000
argument_list|)
condition|)
return|return
name|ENXIO
return|;
comment|/* Fill the softc struct with default values.  */
name|fe_softc_defaults
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* See if the card is on its address.  */
if|if
condition|(
operator|!
name|fe_simple_probe
argument_list|(
name|sc
argument_list|,
name|probe_table
argument_list|)
condition|)
return|return
name|ENXIO
return|;
comment|/* Get our station address from EEPROM.  */
name|fe_inblk
argument_list|(
name|sc
argument_list|,
literal|0x18
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* Make sure it is Allied-Telesis's.  */
if|if
condition|(
operator|!
name|valid_Ether_p
argument_list|(
name|sc
operator|->
name|sc_enaddr
argument_list|,
literal|0x0000F4
argument_list|)
condition|)
return|return
name|ENXIO
return|;
if|#
directive|if
literal|1
comment|/* Calculate checksum.  */
name|sum
operator|=
name|fe_inb
argument_list|(
name|sc
argument_list|,
literal|0x1e
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
name|sum
operator|^=
name|sc
operator|->
name|sc_enaddr
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sum
operator|!=
literal|0
condition|)
return|return
name|ENXIO
return|;
endif|#
directive|endif
comment|/* Setup the board type.  */
name|sc
operator|->
name|typestr
operator|=
literal|"RE1000"
expr_stmt|;
comment|/* This looks like an RE1000 board.  It requires an 	   explicit IRQ setting in config.  Make sure we have one, 	   determining an appropriate value for the IRQ control 	   register.  */
name|irq
operator|=
literal|0
expr_stmt|;
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
operator|&
name|irq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|irq
condition|)
block|{
case|case
literal|3
case|:
name|n
operator|=
literal|0x10
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|n
operator|=
literal|0x20
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|n
operator|=
literal|0x40
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|n
operator|=
literal|0x80
expr_stmt|;
break|break;
default|default:
name|fe_irq_failure
argument_list|(
name|sc
operator|->
name|typestr
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|irq
argument_list|,
literal|"3/5/6/12"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|sc
operator|->
name|priv_info
operator|=
operator|(
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_RE1000_IRQCONF
argument_list|)
operator|&
literal|0x0f
operator|)
operator||
name|n
expr_stmt|;
comment|/* Setup hooks.  We need a special initialization procedure.  */
name|sc
operator|->
name|init
operator|=
name|fe_init_re1000
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* JLI sub-probe for Allied-Telesis RE1000Plus/ME1500 series.  */
end_comment

begin_function
specifier|static
name|u_short
specifier|const
modifier|*
name|fe_probe_jli_re1000p
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|,
name|u_char
specifier|const
modifier|*
name|eeprom
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|static
name|u_short
specifier|const
name|irqmaps_re1000p
index|[
literal|4
index|]
init|=
block|{
literal|3
block|,
literal|5
block|,
literal|6
block|,
literal|12
block|}
decl_stmt|;
comment|/* Make sure the EEPROM contains Allied-Telesis bit pattern.  */
if|if
condition|(
name|eeprom
index|[
literal|1
index|]
operator|!=
literal|0xFF
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|eeprom
index|[
name|i
index|]
operator|!=
literal|0xFF
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|14
init|;
name|i
operator|<
literal|24
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|eeprom
index|[
name|i
index|]
operator|!=
literal|0xFF
condition|)
return|return
name|NULL
return|;
comment|/* Get our station address from EEPROM, and make sure the            EEPROM contains Allied-Telesis's address.  */
name|bcopy
argument_list|(
name|eeprom
operator|+
literal|8
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|valid_Ether_p
argument_list|(
name|sc
operator|->
name|sc_enaddr
argument_list|,
literal|0x0000F4
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* I don't know any sub-model identification.  */
name|sc
operator|->
name|typestr
operator|=
literal|"RE1000Plus/ME1500"
expr_stmt|;
comment|/* Returns the IRQ table for the RE1000Plus.  */
return|return
name|irqmaps_re1000p
return|;
block|}
end_function

begin_comment
comment|/*  * Probe for Allied-Telesis RE1000Plus/ME1500 series.  */
end_comment

begin_function
specifier|static
name|int
name|fe_probe_jli
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|xirq
decl_stmt|,
name|error
decl_stmt|;
name|u_long
name|iobase
decl_stmt|,
name|irq
decl_stmt|;
name|u_char
name|eeprom
index|[
name|JLI_EEPROM_SIZE
index|]
decl_stmt|;
name|u_short
specifier|const
modifier|*
name|irqmap
decl_stmt|;
specifier|static
name|u_short
specifier|const
name|baseaddr
index|[
literal|8
index|]
init|=
block|{
literal|0x1D6
block|,
literal|0x1D8
block|,
literal|0x1DA
block|,
literal|0x1D4
block|,
literal|0x0D4
block|,
literal|0x0D2
block|,
literal|0x0D8
block|,
literal|0x0D0
block|}
decl_stmt|;
specifier|static
name|struct
name|fe_simple_probe_struct
specifier|const
name|probe_table
index|[]
init|=
block|{
comment|/*	{ FE_DLCR1,  0x20, 0x00 },	Doesn't work. */
block|{
name|FE_DLCR2
block|,
literal|0x50
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR4
block|,
literal|0x08
block|,
literal|0x00
block|}
block|,
comment|/*	{ FE_DLCR5,  0x80, 0x00 },	Doesn't work. */
if|#
directive|if
literal|0
block|{ FE_BMPR16, 0x1B, 0x00 }, 		{ FE_BMPR17, 0x7F, 0x00 },
endif|#
directive|endif
block|{
literal|0
block|}
block|}
decl_stmt|;
comment|/* 	 * See if the specified address is possible for MB86965A JLI mode. 	 */
if|if
condition|(
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|,
operator|&
name|iobase
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|ENXIO
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|baseaddr
index|[
name|i
index|]
operator|==
name|iobase
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|8
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
name|fe98_alloc_port
argument_list|(
name|dev
argument_list|,
name|FE_TYPE_RE1000
argument_list|)
condition|)
return|return
name|ENXIO
return|;
comment|/* Fill the softc struct with default values.  */
name|fe_softc_defaults
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * We should test if MB86965A is on the base address now. 	 * Unfortunately, it is very hard to probe it reliably, since 	 * we have no way to reset the chip under software control. 	 * On cold boot, we could check the "signature" bit patterns 	 * described in the Fujitsu document.  On warm boot, however, 	 * we can predict almost nothing about register values. 	 */
if|if
condition|(
operator|!
name|fe_simple_probe
argument_list|(
name|sc
argument_list|,
name|probe_table
argument_list|)
condition|)
return|return
name|ENXIO
return|;
comment|/* Check if our I/O address matches config info on 86965.  */
name|n
operator|=
operator|(
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR19
argument_list|)
operator|&
name|FE_B19_ADDR
operator|)
operator|>>
name|FE_B19_ADDR_SHIFT
expr_stmt|;
if|if
condition|(
name|baseaddr
index|[
name|n
index|]
operator|!=
name|iobase
condition|)
return|return
name|ENXIO
return|;
comment|/* 	 * We are now almost sure we have an MB86965 at the given 	 * address.  So, read EEPROM through it.  We have to write 	 * into LSI registers to read from EEPROM.  I want to avoid it 	 * at this stage, but I cannot test the presence of the chip 	 * any further without reading EEPROM.  FIXME. 	 */
name|fe_read_eeprom_jli
argument_list|(
name|sc
argument_list|,
name|eeprom
argument_list|)
expr_stmt|;
comment|/* Make sure that config info in EEPROM and 86965 agree.  */
if|if
condition|(
name|eeprom
index|[
name|FE_EEPROM_CONF
index|]
operator|!=
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR19
argument_list|)
condition|)
return|return
name|ENXIO
return|;
comment|/* Use 86965 media selection scheme, unless othewise            specified.  It is "AUTO always" and "select with BMPR13".            This behaviour covers most of the 86965 based board (as            minimum requirements.)  It is backward compatible with            previous versions, also.  */
name|sc
operator|->
name|mbitmap
operator|=
name|MB_HA
expr_stmt|;
name|sc
operator|->
name|defmedia
operator|=
name|MB_HA
expr_stmt|;
name|sc
operator|->
name|msel
operator|=
name|fe_msel_965
expr_stmt|;
comment|/* Perform board-specific probe.  */
if|if
condition|(
operator|(
name|irqmap
operator|=
name|fe_probe_jli_re1000p
argument_list|(
name|sc
argument_list|,
name|eeprom
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
comment|/* Find the IRQ read from EEPROM.  */
name|n
operator|=
operator|(
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR19
argument_list|)
operator|&
name|FE_B19_IRQ
operator|)
operator|>>
name|FE_B19_IRQ_SHIFT
expr_stmt|;
name|xirq
operator|=
name|irqmap
index|[
name|n
index|]
expr_stmt|;
comment|/* Try to determine IRQ setting.  */
name|error
operator|=
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
operator|&
name|irq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|xirq
operator|==
name|NO_IRQ
condition|)
block|{
comment|/* The device must be configured with an explicit IRQ.  */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"IRQ auto-detection does not work\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
elseif|else
if|if
condition|(
name|error
operator|&&
name|xirq
operator|!=
name|NO_IRQ
condition|)
block|{
comment|/* Just use the probed IRQ value.  */
name|bus_set_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|xirq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|error
operator|&&
name|xirq
operator|==
name|NO_IRQ
condition|)
block|{
comment|/* No problem.  Go ahead.  */
block|}
elseif|else
if|if
condition|(
name|irq
operator|==
name|xirq
condition|)
block|{
comment|/* Good.  Go ahead.  */
block|}
else|else
block|{
comment|/* User must be warned in this case.  */
name|sc
operator|->
name|stability
operator||=
name|UNSTABLE_IRQ
expr_stmt|;
block|}
comment|/* Setup a hook, which resets te 86965 when the driver is being            initialized.  This may solve a nasty bug.  FIXME.  */
name|sc
operator|->
name|init
operator|=
name|fe_init_jli
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Probe and initialization for Contec C-NET(9N)E series.  */
end_comment

begin_comment
comment|/* TODO: Should be in "if_fereg.h" */
end_comment

begin_define
define|#
directive|define
name|FE_CNET9NE_INTR
value|0x10
end_define

begin_comment
comment|/* Interrupt Mask? */
end_comment

begin_function
specifier|static
name|void
name|fe_init_cnet9ne
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Enable interrupt?  FIXME.  */
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_CNET9NE_INTR
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fe_probe_cnet9ne
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_long
name|iobase
decl_stmt|,
name|irq
decl_stmt|;
specifier|static
name|struct
name|fe_simple_probe_struct
name|probe_table
index|[]
init|=
block|{
block|{
name|FE_DLCR2
block|,
literal|0x58
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR4
block|,
literal|0x08
block|,
literal|0x00
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
comment|/* See if the specified I/O address is possible for C-NET(9N)E.  */
if|if
condition|(
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|,
operator|&
name|iobase
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
name|iobase
operator|!=
literal|0x73D0
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
name|fe98_alloc_port
argument_list|(
name|dev
argument_list|,
name|FE_TYPE_CNET9NE
argument_list|)
condition|)
return|return
name|ENXIO
return|;
comment|/* Fill the softc struct with default values.  */
name|fe_softc_defaults
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* See if the card is on its address.  */
if|if
condition|(
operator|!
name|fe_simple_probe
argument_list|(
name|sc
argument_list|,
name|probe_table
argument_list|)
condition|)
return|return
name|ENXIO
return|;
comment|/* Get our station address from EEPROM.  */
name|fe_inblk
argument_list|(
name|sc
argument_list|,
literal|0x18
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* Make sure it is Contec's.  */
if|if
condition|(
operator|!
name|valid_Ether_p
argument_list|(
name|sc
operator|->
name|sc_enaddr
argument_list|,
literal|0x00804C
argument_list|)
condition|)
return|return
name|ENXIO
return|;
comment|/* Determine the card type.  */
if|if
condition|(
name|sc
operator|->
name|sc_enaddr
index|[
literal|3
index|]
operator|==
literal|0x06
condition|)
block|{
name|sc
operator|->
name|typestr
operator|=
literal|"C-NET(9N)C"
expr_stmt|;
comment|/* We seems to need our own IDENT bits...  FIXME.  */
name|sc
operator|->
name|proto_dlcr7
operator|=
name|FE_D7_BYTSWP_LH
operator||
name|FE_D7_IDENT_NICE
expr_stmt|;
comment|/* C-NET(9N)C requires an explicit IRQ to work.  */
if|if
condition|(
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
operator|&
name|irq
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fe_irq_failure
argument_list|(
name|sc
operator|->
name|typestr
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|NO_IRQ
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
block|}
else|else
block|{
name|sc
operator|->
name|typestr
operator|=
literal|"C-NET(9N)E"
expr_stmt|;
comment|/* C-NET(9N)E works only IRQ5.  */
if|if
condition|(
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
operator|&
name|irq
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
name|irq
operator|!=
literal|5
condition|)
block|{
name|fe_irq_failure
argument_list|(
name|sc
operator|->
name|typestr
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|irq
argument_list|,
literal|"5"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/* We need an init hook to initialize ASIC before we start.  */
name|sc
operator|->
name|init
operator|=
name|fe_init_cnet9ne
expr_stmt|;
block|}
comment|/* C-NET(9N)E has 64KB SRAM.  */
name|sc
operator|->
name|proto_dlcr6
operator|=
name|FE_D6_BUFSIZ_64KB
operator||
name|FE_D6_TXBSIZ_2x4KB
operator||
name|FE_D6_BBW_WORD
operator||
name|FE_D6_SBW_WORD
operator||
name|FE_D6_SRAM
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Probe for Contec C-NET(98)P2 series.  * (Logitec LAN-98TP/LAN-98T25P - parhaps)  */
end_comment

begin_function
specifier|static
name|int
name|fe_probe_ssi
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_long
name|iobase
decl_stmt|,
name|irq
decl_stmt|;
name|u_char
name|eeprom
index|[
name|SSI_EEPROM_SIZE
index|]
decl_stmt|;
specifier|static
name|struct
name|fe_simple_probe_struct
name|probe_table
index|[]
init|=
block|{
block|{
name|FE_DLCR2
block|,
literal|0x08
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR4
block|,
literal|0x08
block|,
literal|0x00
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
specifier|static
name|u_short
specifier|const
name|irqmap
index|[]
init|=
block|{
comment|/*                        INT0          INT1    INT2       */
name|NO_IRQ
block|,
name|NO_IRQ
block|,
name|NO_IRQ
block|,
literal|3
block|,
name|NO_IRQ
block|,
literal|5
block|,
literal|6
block|,
name|NO_IRQ
block|,
name|NO_IRQ
block|,
literal|9
block|,
literal|10
block|,
name|NO_IRQ
block|,
literal|12
block|,
literal|13
block|,
name|NO_IRQ
block|,
name|NO_IRQ
block|,
comment|/*        INT3   INT41            INT5  INT6               */
block|}
decl_stmt|;
comment|/* See if the specified I/O address is possible for 78Q8377A.  */
comment|/* [0-D]3D0 are allowed.  */
if|if
condition|(
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|,
operator|&
name|iobase
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
operator|(
name|iobase
operator|&
literal|0xFFF
operator|)
operator|!=
literal|0x3D0
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
name|fe98_alloc_port
argument_list|(
name|dev
argument_list|,
name|FE_TYPE_SSI
argument_list|)
condition|)
return|return
name|ENXIO
return|;
comment|/* Fill the softc struct with default values.  */
name|fe_softc_defaults
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* See if the card is on its address.  */
if|if
condition|(
operator|!
name|fe_simple_probe
argument_list|(
name|sc
argument_list|,
name|probe_table
argument_list|)
condition|)
return|return
name|ENXIO
return|;
comment|/* We now have to read the config EEPROM.  We should be very            careful, since doing so destroys a register.  (Remember, we            are not yet sure we have a C-NET(98)P2 board here.)  Don't            remember to select BMPRs bofore reading EEPROM, since other            register bank may be selected before the probe() is called.  */
name|fe_read_eeprom_ssi
argument_list|(
name|sc
argument_list|,
name|eeprom
argument_list|)
expr_stmt|;
comment|/* Make sure the Ethernet (MAC) station address is of Contec's.  */
if|if
condition|(
operator|!
name|valid_Ether_p
argument_list|(
name|eeprom
operator|+
name|FE_SSI_EEP_ADDR
argument_list|,
literal|0x00804C
argument_list|)
condition|)
return|return
name|ENXIO
return|;
name|bcopy
argument_list|(
name|eeprom
operator|+
name|FE_SSI_EEP_ADDR
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* Setup the board type.  */
name|sc
operator|->
name|typestr
operator|=
literal|"C-NET(98)P2"
expr_stmt|;
comment|/* Get IRQ configuration from EEPROM.  */
name|irq
operator|=
name|irqmap
index|[
name|eeprom
index|[
name|FE_SSI_EEP_IRQ
index|]
index|]
expr_stmt|;
if|if
condition|(
name|irq
operator|==
name|NO_IRQ
condition|)
block|{
name|fe_irq_failure
argument_list|(
name|sc
operator|->
name|typestr
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|irq
argument_list|,
literal|"3/5/6/9/10/12/13"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|bus_set_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|irq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Get Duplex-mode configuration from EEPROM.  */
name|sc
operator|->
name|proto_dlcr4
operator||=
operator|(
name|eeprom
index|[
name|FE_SSI_EEP_DUPLEX
index|]
operator|&
name|FE_D4_DSC
operator|)
expr_stmt|;
comment|/* Fill softc struct accordingly.  */
name|sc
operator|->
name|mbitmap
operator|=
name|MB_HT
expr_stmt|;
name|sc
operator|->
name|defmedia
operator|=
name|MB_HT
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Probe for TDK LAC-98012/013/025/9N011 - parhaps.  */
end_comment

begin_function
specifier|static
name|int
name|fe_probe_lnx
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|FE_8BIT_SUPPORT
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"skip LAC-98012/013(only 16-bit cards are supported)\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
else|#
directive|else
name|struct
name|fe_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_long
name|iobase
decl_stmt|,
name|irq
decl_stmt|;
name|u_char
name|eeprom
index|[
name|LNX_EEPROM_SIZE
index|]
decl_stmt|;
specifier|static
name|struct
name|fe_simple_probe_struct
name|probe_table
index|[]
init|=
block|{
block|{
name|FE_DLCR2
block|,
literal|0x58
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR4
block|,
literal|0x08
block|,
literal|0x00
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
comment|/* See if the specified I/O address is possible for TDK/LANX boards. */
comment|/* 0D0, 4D0, 8D0, and CD0 are allowed.  */
if|if
condition|(
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|,
operator|&
name|iobase
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
operator|(
name|iobase
operator|&
operator|~
literal|0xC00
operator|)
operator|!=
literal|0xD0
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
name|fe98_alloc_port
argument_list|(
name|dev
argument_list|,
name|FE_TYPE_LNX
argument_list|)
condition|)
return|return
name|ENXIO
return|;
comment|/* Fill the softc struct with default values.  */
name|fe_softc_defaults
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* See if the card is on its address.  */
if|if
condition|(
operator|!
name|fe_simple_probe
argument_list|(
name|sc
argument_list|,
name|probe_table
argument_list|)
condition|)
return|return
name|ENXIO
return|;
comment|/* We now have to read the config EEPROM.  We should be very            careful, since doing so destroys a register.  (Remember, we            are not yet sure we have a LAC-98012/98013 board here.)  */
name|fe_read_eeprom_lnx
argument_list|(
name|sc
argument_list|,
name|eeprom
argument_list|)
expr_stmt|;
comment|/* Make sure the Ethernet (MAC) station address is of TDK/LANX's.  */
if|if
condition|(
operator|!
name|valid_Ether_p
argument_list|(
name|eeprom
argument_list|,
literal|0x008098
argument_list|)
condition|)
return|return
name|ENXIO
return|;
name|bcopy
argument_list|(
name|eeprom
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* Setup the board type.  */
name|sc
operator|->
name|typestr
operator|=
literal|"LAC-98012/98013"
expr_stmt|;
comment|/* This looks like a TDK/LANX board.  It requires an 	   explicit IRQ setting in config.  Make sure we have one, 	   determining an appropriate value for the IRQ control 	   register.  */
name|irq
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
operator|&
name|irq
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|ENXIO
return|;
switch|switch
condition|(
name|irq
condition|)
block|{
case|case
literal|3
case|:
name|sc
operator|->
name|priv_info
operator|=
literal|0x10
operator||
name|LNX_CLK_LO
operator||
name|LNX_SDA_HI
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|sc
operator|->
name|priv_info
operator|=
literal|0x20
operator||
name|LNX_CLK_LO
operator||
name|LNX_SDA_HI
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|sc
operator|->
name|priv_info
operator|=
literal|0x40
operator||
name|LNX_CLK_LO
operator||
name|LNX_SDA_HI
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|sc
operator|->
name|priv_info
operator|=
literal|0x80
operator||
name|LNX_CLK_LO
operator||
name|LNX_SDA_HI
expr_stmt|;
break|break;
default|default:
name|fe_irq_failure
argument_list|(
name|sc
operator|->
name|typestr
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|irq
argument_list|,
literal|"3/5/6/12"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/* LAC-98's system bus width is 8-bit.  */
name|sc
operator|->
name|proto_dlcr6
operator|=
name|FE_D6_BUFSIZ_32KB
operator||
name|FE_D6_TXBSIZ_2x2KB
operator||
name|FE_D6_BBW_BYTE
operator||
name|FE_D6_SBW_BYTE
operator||
name|FE_D6_SRAM_150ns
expr_stmt|;
comment|/* Setup hooks.  We need a special initialization procedure.  */
name|sc
operator|->
name|init
operator|=
name|fe_init_lnx
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* FE_8BIT_SUPPORT */
block|}
end_function

begin_comment
comment|/*  * Probe for Gateway Communications' old cards.  * (both as Generic MB86960 probe routine)  */
end_comment

begin_function
specifier|static
name|int
name|fe_probe_gwy
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|static
name|struct
name|fe_simple_probe_struct
name|probe_table
index|[]
init|=
block|{
comment|/*	{ FE_DLCR2, 0x70, 0x00 }, */
block|{
name|FE_DLCR2
block|,
literal|0x58
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR4
block|,
literal|0x08
block|,
literal|0x00
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
comment|/* 	 * XXX 	 * I'm not sure which address is possible, so accepts any. 	 */
if|if
condition|(
name|fe98_alloc_port
argument_list|(
name|dev
argument_list|,
name|FE_TYPE_GWY
argument_list|)
condition|)
return|return
name|ENXIO
return|;
comment|/* Fill the softc struct with default values.  */
name|fe_softc_defaults
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* See if the card is on its address.  */
if|if
condition|(
operator|!
name|fe_simple_probe
argument_list|(
name|sc
argument_list|,
name|probe_table
argument_list|)
condition|)
return|return
name|ENXIO
return|;
comment|/* Get our station address from EEPROM. */
name|fe_inblk
argument_list|(
name|sc
argument_list|,
literal|0x18
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|valid_Ether_p
argument_list|(
name|sc
operator|->
name|sc_enaddr
argument_list|,
literal|0x000000
argument_list|)
condition|)
return|return
name|ENXIO
return|;
comment|/* Determine the card type.  */
name|sc
operator|->
name|typestr
operator|=
literal|"Generic MB86960 Ethernet"
expr_stmt|;
if|if
condition|(
name|valid_Ether_p
argument_list|(
name|sc
operator|->
name|sc_enaddr
argument_list|,
literal|0x000061
argument_list|)
condition|)
name|sc
operator|->
name|typestr
operator|=
literal|"Gateway Ethernet (Fujitsu chipset)"
expr_stmt|;
comment|/* Gateway's board requires an explicit IRQ to work, since it 	   is not possible to probe the setting of jumpers.  */
if|if
condition|(
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fe_irq_failure
argument_list|(
name|sc
operator|->
name|typestr
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|NO_IRQ
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Probe for Ungermann-Bass Access/PC N98C+(Model 85152).  */
end_comment

begin_function
specifier|static
name|int
name|fe_probe_ubn
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_char
name|sum
decl_stmt|,
name|save7
decl_stmt|;
name|u_long
name|iobase
decl_stmt|,
name|irq
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
name|struct
name|fe_simple_probe_struct
specifier|const
name|probe_table
index|[]
init|=
block|{
block|{
name|FE_DLCR2
block|,
literal|0x58
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR4
block|,
literal|0x08
block|,
literal|0x00
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
comment|/* See if the specified I/O address is possible for Access/PC.  */
comment|/* [01][048C]D0 are allowed.  */
if|if
condition|(
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|,
operator|&
name|iobase
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
operator|(
name|iobase
operator|&
operator|~
literal|0x1C00
operator|)
operator|!=
literal|0xD0
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
name|fe98_alloc_port
argument_list|(
name|dev
argument_list|,
name|FE_TYPE_UBN
argument_list|)
condition|)
return|return
name|ENXIO
return|;
comment|/* Fill the softc struct with default values.  */
name|fe_softc_defaults
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Simple probe.  */
if|if
condition|(
operator|!
name|fe_simple_probe
argument_list|(
name|sc
argument_list|,
name|probe_table
argument_list|)
condition|)
return|return
name|ENXIO
return|;
comment|/* NOTE: Access/NOTE N98 sometimes freeze when reading station 	   address.  In case of using it togather with C-NET(9N)C, 	   this problem usually happens. 	   Writing DLCR7 prevents freezing, but I don't know why.  FIXME.  */
comment|/* Save the current value for the DLCR7 register we are about 	   to destroy.  */
name|save7
operator|=
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR7
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR7
argument_list|,
name|sc
operator|->
name|proto_dlcr7
operator||
name|FE_D7_RBS_BMPR
operator||
name|FE_D7_POWER_UP
argument_list|)
expr_stmt|;
comment|/* Get our station address form ID ROM and make sure it is UBN's.  */
name|fe_inblk
argument_list|(
name|sc
argument_list|,
literal|0x18
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|valid_Ether_p
argument_list|(
name|sc
operator|->
name|sc_enaddr
argument_list|,
literal|0x00DD01
argument_list|)
condition|)
goto|goto
name|fail_ubn
goto|;
if|#
directive|if
literal|1
comment|/* Calculate checksum.  */
name|sum
operator|=
name|fe_inb
argument_list|(
name|sc
argument_list|,
literal|0x1e
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
name|sum
operator|^=
name|sc
operator|->
name|sc_enaddr
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sum
operator|!=
literal|0
condition|)
goto|goto
name|fail_ubn
goto|;
endif|#
directive|endif
comment|/* Setup the board type.  */
name|sc
operator|->
name|typestr
operator|=
literal|"Access/PC"
expr_stmt|;
comment|/* This looks like an AccessPC/N98C+ board.  It requires an 	   explicit IRQ setting in config.  Make sure we have one, 	   determining an appropriate value for the IRQ control 	   register.  */
name|irq
operator|=
literal|0
expr_stmt|;
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
operator|&
name|irq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|irq
condition|)
block|{
case|case
literal|3
case|:
name|sc
operator|->
name|priv_info
operator|=
literal|0x01
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|sc
operator|->
name|priv_info
operator|=
literal|0x02
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|sc
operator|->
name|priv_info
operator|=
literal|0x04
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|sc
operator|->
name|priv_info
operator|=
literal|0x08
expr_stmt|;
break|break;
default|default:
name|fe_irq_failure
argument_list|(
name|sc
operator|->
name|typestr
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|irq
argument_list|,
literal|"3/5/6/12"
argument_list|)
expr_stmt|;
goto|goto
name|fail_ubn
goto|;
block|}
comment|/* Setup hooks.  We need a special initialization procedure.  */
name|sc
operator|->
name|init
operator|=
name|fe_init_ubn
expr_stmt|;
return|return
literal|0
return|;
name|fail_ubn
label|:
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR7
argument_list|,
name|save7
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
end_function

begin_comment
comment|/*  * REX boards(non-JLI type) support routine.  */
end_comment

begin_define
define|#
directive|define
name|REX_EEPROM_SIZE
value|32
end_define

begin_define
define|#
directive|define
name|REX_DAT
value|0x01
end_define

begin_function
specifier|static
name|void
name|fe_read_eeprom_rex
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_char
name|bit
decl_stmt|,
name|val
decl_stmt|;
name|u_char
name|save16
decl_stmt|;
name|save16
operator|=
name|fe_inb
argument_list|(
name|sc
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
comment|/* Issue a start condition.  */
name|val
operator|=
name|fe_inb
argument_list|(
name|sc
argument_list|,
literal|0x10
argument_list|)
operator|&
literal|0xf0
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
literal|0x10
argument_list|,
name|val
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fe_inb
argument_list|(
name|sc
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fe_inb
argument_list|(
name|sc
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fe_inb
argument_list|(
name|sc
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fe_inb
argument_list|(
name|sc
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
comment|/* Read bytes from EEPROM.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REX_EEPROM_SIZE
condition|;
name|i
operator|++
control|)
block|{
comment|/* Read a byte and store it into the buffer.  */
name|val
operator|=
literal|0x00
expr_stmt|;
for|for
control|(
name|bit
operator|=
literal|0x01
init|;
name|bit
operator|!=
literal|0x00
condition|;
name|bit
operator|<<=
literal|1
control|)
if|if
condition|(
name|fe_inb
argument_list|(
name|sc
argument_list|,
literal|0x10
argument_list|)
operator|&
name|REX_DAT
condition|)
name|val
operator||=
name|bit
expr_stmt|;
operator|*
name|data
operator|++
operator|=
name|val
expr_stmt|;
block|}
name|fe_outb
argument_list|(
name|sc
argument_list|,
literal|0x10
argument_list|,
name|save16
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* Report what we got.  */
if|if
condition|(
name|bootverbose
condition|)
block|{
name|data
operator|-=
name|REX_EEPROM_SIZE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REX_EEPROM_SIZE
condition|;
name|i
operator|+=
literal|16
control|)
block|{
name|printf
argument_list|(
literal|"fe%d: EEPROM(REX):%3x: %16D\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|i
argument_list|,
name|data
operator|+
name|i
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|fe_init_rex
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Setup IRQ control register on the ASIC.  */
name|fe_outb
argument_list|(
name|sc
argument_list|,
literal|0x10
argument_list|,
name|sc
operator|->
name|priv_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Probe for RATOC REX-9880/81/82/83 series.  */
end_comment

begin_function
specifier|static
name|int
name|fe_probe_rex
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_long
name|iobase
decl_stmt|,
name|irq
decl_stmt|;
name|u_char
name|eeprom
index|[
name|REX_EEPROM_SIZE
index|]
decl_stmt|;
specifier|static
name|struct
name|fe_simple_probe_struct
name|probe_table
index|[]
init|=
block|{
block|{
name|FE_DLCR2
block|,
literal|0x58
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR4
block|,
literal|0x08
block|,
literal|0x00
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
comment|/* See if the specified I/O address is possible for REX-9880.  */
comment|/* 6[46CE]D0 are allowed.  */
if|if
condition|(
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|,
operator|&
name|iobase
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
operator|(
name|iobase
operator|&
operator|~
literal|0xA00
operator|)
operator|!=
literal|0x64D0
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
name|fe98_alloc_port
argument_list|(
name|dev
argument_list|,
name|FE_TYPE_REX
argument_list|)
condition|)
return|return
name|ENXIO
return|;
comment|/* Fill the softc struct with default values.  */
name|fe_softc_defaults
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* See if the card is on its address.  */
if|if
condition|(
operator|!
name|fe_simple_probe
argument_list|(
name|sc
argument_list|,
name|probe_table
argument_list|)
condition|)
return|return
name|ENXIO
return|;
comment|/* We now have to read the config EEPROM.  We should be very            careful, since doing so destroys a register.  (Remember, we            are not yet sure we have a REX-9880 board here.)  */
name|fe_read_eeprom_rex
argument_list|(
name|sc
argument_list|,
name|eeprom
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|sc_enaddr
index|[
name|i
index|]
operator|=
name|eeprom
index|[
literal|7
operator|-
name|i
index|]
expr_stmt|;
comment|/* Make sure it is RATOC's.  */
if|if
condition|(
operator|!
name|valid_Ether_p
argument_list|(
name|sc
operator|->
name|sc_enaddr
argument_list|,
literal|0x00C0D0
argument_list|)
operator|&&
operator|!
name|valid_Ether_p
argument_list|(
name|sc
operator|->
name|sc_enaddr
argument_list|,
literal|0x00803D
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Setup the board type.  */
name|sc
operator|->
name|typestr
operator|=
literal|"REX-9880/9883"
expr_stmt|;
comment|/* This looks like a REX-9880 board.  It requires an 	   explicit IRQ setting in config.  Make sure we have one, 	   determining an appropriate value for the IRQ control 	   register.  */
name|irq
operator|=
literal|0
expr_stmt|;
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
operator|&
name|irq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|irq
condition|)
block|{
case|case
literal|3
case|:
name|sc
operator|->
name|priv_info
operator|=
literal|0x10
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|sc
operator|->
name|priv_info
operator|=
literal|0x20
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|sc
operator|->
name|priv_info
operator|=
literal|0x40
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|sc
operator|->
name|priv_info
operator|=
literal|0x80
expr_stmt|;
break|break;
default|default:
name|fe_irq_failure
argument_list|(
name|sc
operator|->
name|typestr
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|irq
argument_list|,
literal|"3/5/6/12"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/* Setup hooks.  We need a special initialization procedure.  */
name|sc
operator|->
name|init
operator|=
name|fe_init_rex
expr_stmt|;
comment|/* REX-9880 has 64KB SRAM.  */
name|sc
operator|->
name|proto_dlcr6
operator|=
name|FE_D6_BUFSIZ_64KB
operator||
name|FE_D6_TXBSIZ_2x4KB
operator||
name|FE_D6_BBW_WORD
operator||
name|FE_D6_SBW_WORD
operator||
name|FE_D6_SRAM
expr_stmt|;
if|#
directive|if
literal|1
name|sc
operator|->
name|proto_dlcr7
operator||=
name|FE_D7_EOPPOL
expr_stmt|;
comment|/* XXX */
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

end_unit

