begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * All Rights Reserved, Copyright (C) Fujitsu Limited 1995  *  * This software may be used, modified, copied, distributed, and sold, in  * both source and binary form provided that the above copyright, these  * terms and the following disclaimer are retained.  The name of the author  * and/or the contributor may not be used to endorse or promote products  * derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND THE CONTRIBUTOR ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR THE CONTRIBUTOR BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION.  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * $FreeBSD$  *  * Device driver for Fujitsu MB86960A/MB86965A based Ethernet cards.  * Contributed by M. Sekiguchi.<seki@sysrap.cs.fujitsu.co.jp>  *  * This version is intended to be a generic template for various  * MB86960A/MB86965A based Ethernet cards.  It currently supports  * Fujitsu FMV-180 series for ISA and Allied-Telesis AT1700/RE2000  * series for ISA, as well as Fujitsu MBH10302 PC card.  * There are some currently-  * unused hooks embedded, which are primarily intended to support  * other types of Ethernet cards, but the author is not sure whether  * they are useful.  *  * This version also includes some alignments to support RE1000,  * C-NET(98)P2 and so on. These cards are not for AT-compatibles,  * but for NEC PC-98 bus -- a proprietary bus architecture available  * only in Japan. Confusingly, it is different from the Microsoft's  * PC98 architecture. :-{  * Further work for PC-98 version will be available as a part of  * FreeBSD(98) project.  *  * This software is a derivative work of if_ed.c version 1.56 by David  * Greenman available as a part of FreeBSD 2.0 RELEASE source distribution.  *  * The following lines are retained from the original if_ed.c:  *  * Copyright (C) 1993, David Greenman. This software may be used, modified,  *   copied, distributed, and sold, in both source and binary form provided  *   that the above copyright and these terms are retained. Under no  *   circumstances is the author responsible for the proper functioning  *   of this software, nor does the author assume any responsibility  *   for damages incurred with its use.  */
end_comment

begin_comment
comment|/*  * TODO:  *  o   To support ISA PnP auto configuration for FMV-183/184.  *  o   To support REX-9886/87(PC-98 only).  *  o   To reconsider mbuf usage.  *  o   To reconsider transmission buffer usage, including  *      transmission buffer size (currently 4KB x 2) and pros-and-  *      cons of multiple frame transmission.  *  o   To test IPX codes.  *  o   To test new-bus frontend.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_mib.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/ic/mb86960.h>
end_include

begin_include
include|#
directive|include
file|<dev/fe/if_fereg.h>
end_include

begin_include
include|#
directive|include
file|<dev/fe/if_fevar.h>
end_include

begin_comment
comment|/*  * Transmit just one packet per a "send" command to 86960.  * This option is intended for performance test.  An EXPERIMENTAL option.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FE_SINGLE_TRANSMISSION
end_ifndef

begin_define
define|#
directive|define
name|FE_SINGLE_TRANSMISSION
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Maximum loops when interrupt.  * This option prevents an infinite loop due to hardware failure.  * (Some laptops make an infinite loop after PC-Card is ejected.)  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FE_MAX_LOOP
end_ifndef

begin_define
define|#
directive|define
name|FE_MAX_LOOP
value|0x800
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Device configuration flags.  */
end_comment

begin_comment
comment|/* DLCR6 settings.  */
end_comment

begin_define
define|#
directive|define
name|FE_FLAGS_DLCR6_VALUE
value|0x007F
end_define

begin_comment
comment|/* Force DLCR6 override.  */
end_comment

begin_define
define|#
directive|define
name|FE_FLAGS_OVERRIDE_DLCR6
value|0x0080
end_define

begin_decl_stmt
name|devclass_t
name|fe_devclass
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Special filter values.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|fe_filter
specifier|const
name|fe_filter_nothing
init|=
block|{
name|FE_FILTER_NOTHING
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|fe_filter
specifier|const
name|fe_filter_all
init|=
block|{
name|FE_FILTER_ALL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Standard driver entry points.  These can be static.  */
end_comment

begin_function_decl
specifier|static
name|void
name|fe_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|driver_intr_t
name|fe_intr
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|fe_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fe_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fe_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fe_medchange
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fe_medstat
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Local functions.  Order of declaration is confused.  FIXME.  */
end_comment

begin_function_decl
specifier|static
name|int
name|fe_get_packet
parameter_list|(
name|struct
name|fe_softc
modifier|*
parameter_list|,
name|u_short
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fe_tint
parameter_list|(
name|struct
name|fe_softc
modifier|*
parameter_list|,
name|u_char
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fe_rint
parameter_list|(
name|struct
name|fe_softc
modifier|*
parameter_list|,
name|u_char
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fe_xmit
parameter_list|(
name|struct
name|fe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fe_write_mbufs
parameter_list|(
name|struct
name|fe_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fe_setmode
parameter_list|(
name|struct
name|fe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fe_loadmar
parameter_list|(
name|struct
name|fe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DIAGNOSTIC
end_ifdef

begin_function_decl
specifier|static
name|void
name|fe_emptybuffer
parameter_list|(
name|struct
name|fe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Fe driver specific constants which relate to 86960/86965.  */
end_comment

begin_comment
comment|/* Interrupt masks  */
end_comment

begin_define
define|#
directive|define
name|FE_TMASK
value|( FE_D2_COLL16 | FE_D2_TXDONE )
end_define

begin_define
define|#
directive|define
name|FE_RMASK
value|( FE_D3_OVRFLO | FE_D3_CRCERR \ 		 | FE_D3_ALGERR | FE_D3_SRTPKT | FE_D3_PKTRDY )
end_define

begin_comment
comment|/* Maximum number of iterations for a receive interrupt.  */
end_comment

begin_define
define|#
directive|define
name|FE_MAX_RECV_COUNT
value|( ( 65536 - 2048 * 2 ) / 64 )
end_define

begin_comment
comment|/* 	 * Maximum size of SRAM is 65536, 	 * minimum size of transmission buffer in fe is 2x2KB, 	 * and minimum amount of received packet including headers 	 * added by the chip is 64 bytes. 	 * Hence FE_MAX_RECV_COUNT is the upper limit for number 	 * of packets in the receive buffer. 	 */
end_comment

begin_comment
comment|/*  * Miscellaneous definitions not directly related to hardware.  */
end_comment

begin_comment
comment|/* The following line must be delete when "net/if_media.h" support it.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|IFM_10_FL
end_ifndef

begin_define
define|#
directive|define
name|IFM_10_FL
comment|/* 13 */
value|IFM_10_5
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Mapping between media bitmap (in fe_softc.mbitmap) and ifm_media.  */
end_comment

begin_comment
unit|static int const bit2media [] = { 			IFM_HDX | IFM_ETHER | IFM_AUTO, 			IFM_HDX | IFM_ETHER | IFM_MANUAL, 			IFM_HDX | IFM_ETHER | IFM_10_T, 			IFM_HDX | IFM_ETHER | IFM_10_2, 			IFM_HDX | IFM_ETHER | IFM_10_5, 			IFM_HDX | IFM_ETHER | IFM_10_FL, 			IFM_FDX | IFM_ETHER | IFM_10_T,
comment|/* More can be come here... */
end_comment

begin_else
unit|0 };
else|#
directive|else
end_else

begin_comment
comment|/* Mapping between media bitmap (in fe_softc.mbitmap) and ifm_media.  */
end_comment

begin_decl_stmt
specifier|static
name|int
specifier|const
name|bit2media
index|[]
init|=
block|{
name|IFM_ETHER
operator||
name|IFM_AUTO
block|,
name|IFM_ETHER
operator||
name|IFM_MANUAL
block|,
name|IFM_ETHER
operator||
name|IFM_10_T
block|,
name|IFM_ETHER
operator||
name|IFM_10_2
block|,
name|IFM_ETHER
operator||
name|IFM_10_5
block|,
name|IFM_ETHER
operator||
name|IFM_10_FL
block|,
name|IFM_ETHER
operator||
name|IFM_10_T
block|,
comment|/* More can be come here... */
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Check for specific bits in specific registers have specific values.  * A common utility function called from various sub-probe routines.  */
end_comment

begin_function
name|int
name|fe_simple_probe
parameter_list|(
name|struct
name|fe_softc
specifier|const
modifier|*
name|sc
parameter_list|,
name|struct
name|fe_simple_probe_struct
specifier|const
modifier|*
name|sp
parameter_list|)
block|{
name|struct
name|fe_simple_probe_struct
specifier|const
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|sp
init|;
name|p
operator|->
name|mask
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|p
operator|->
name|port
argument_list|)
operator|&
name|p
operator|->
name|mask
operator|)
operator|!=
name|p
operator|->
name|bits
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Test if a given 6 byte value is a valid Ethernet station (MAC)    address.  "Vendor" is an expected vendor code (first three bytes,)    or a zero when nothing expected.  */
end_comment

begin_function
name|int
name|valid_Ether_p
parameter_list|(
name|u_char
specifier|const
modifier|*
name|addr
parameter_list|,
name|unsigned
name|vendor
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|FE_DEBUG
name|printf
argument_list|(
literal|"fe?: validating %6D against %06x\n"
argument_list|,
name|addr
argument_list|,
literal|":"
argument_list|,
name|vendor
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* All zero is not allowed as a vendor code.  */
if|if
condition|(
name|addr
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|addr
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|addr
index|[
literal|2
index|]
operator|==
literal|0
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|vendor
condition|)
block|{
case|case
literal|0x000000
case|:
comment|/* Legal Ethernet address (stored in ROM) must have 		   its Group and Local bits cleared.  */
if|if
condition|(
operator|(
name|addr
index|[
literal|0
index|]
operator|&
literal|0x03
operator|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|0x020000
case|:
comment|/* Same as above, but a local address is allowed in                    this context.  */
if|if
condition|(
operator|(
name|addr
index|[
literal|0
index|]
operator|&
literal|0x01
operator|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
break|break;
default|default:
comment|/* Make sure the vendor part matches if one is given.  */
if|if
condition|(
name|addr
index|[
literal|0
index|]
operator|!=
operator|(
operator|(
name|vendor
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
operator|)
operator|||
name|addr
index|[
literal|1
index|]
operator|!=
operator|(
operator|(
name|vendor
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
operator|)
operator|||
name|addr
index|[
literal|2
index|]
operator|!=
operator|(
operator|(
name|vendor
operator|)
operator|&
literal|0xFF
operator|)
condition|)
return|return
literal|0
return|;
break|break;
block|}
comment|/* Host part must not be all-zeros nor all-ones.  */
if|if
condition|(
name|addr
index|[
literal|3
index|]
operator|==
literal|0xFF
operator|&&
name|addr
index|[
literal|4
index|]
operator|==
literal|0xFF
operator|&&
name|addr
index|[
literal|5
index|]
operator|==
literal|0xFF
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|addr
index|[
literal|3
index|]
operator|==
literal|0x00
operator|&&
name|addr
index|[
literal|4
index|]
operator|==
literal|0x00
operator|&&
name|addr
index|[
literal|5
index|]
operator|==
literal|0x00
condition|)
return|return
literal|0
return|;
comment|/* Given addr looks like an Ethernet address.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Fill our softc struct with default value.  */
end_comment

begin_function
name|void
name|fe_softc_defaults
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Prepare for typical register prototypes.  We assume a            "typical" board has<32KB> of<fast> SRAM connected with a<byte-wide> data lines.  */
name|sc
operator|->
name|proto_dlcr4
operator|=
name|FE_D4_LBC_DISABLE
operator||
name|FE_D4_CNTRL
expr_stmt|;
name|sc
operator|->
name|proto_dlcr5
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|proto_dlcr6
operator|=
name|FE_D6_BUFSIZ_32KB
operator||
name|FE_D6_TXBSIZ_2x4KB
operator||
name|FE_D6_BBW_BYTE
operator||
name|FE_D6_SBW_WORD
operator||
name|FE_D6_SRAM_100ns
expr_stmt|;
name|sc
operator|->
name|proto_dlcr7
operator|=
name|FE_D7_BYTSWP_LH
expr_stmt|;
name|sc
operator|->
name|proto_bmpr13
operator|=
literal|0
expr_stmt|;
comment|/* Assume the probe process (to be done later) is stable.  */
name|sc
operator|->
name|stability
operator|=
literal|0
expr_stmt|;
comment|/* A typical board needs no hooks.  */
name|sc
operator|->
name|init
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|stop
operator|=
name|NULL
expr_stmt|;
comment|/* Assume the board has no software-controllable media selection.  */
name|sc
operator|->
name|mbitmap
operator|=
name|MB_HM
expr_stmt|;
name|sc
operator|->
name|defmedia
operator|=
name|MB_HM
expr_stmt|;
name|sc
operator|->
name|msel
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Common error reporting routine used in probe routines for    "soft configured IRQ"-type boards.  */
end_comment

begin_function
name|void
name|fe_irq_failure
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|irq
parameter_list|,
name|char
specifier|const
modifier|*
name|list
parameter_list|)
block|{
name|printf
argument_list|(
literal|"fe%d: %s board is detected, but %s IRQ was given\n"
argument_list|,
name|unit
argument_list|,
name|name
argument_list|,
operator|(
name|irq
operator|==
name|NO_IRQ
condition|?
literal|"no"
else|:
literal|"invalid"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"fe%d: specify an IRQ from %s in kernel config\n"
argument_list|,
name|unit
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Hardware (vendor) specific hooks.  */
end_comment

begin_comment
comment|/*  * Generic media selection scheme for MB86965 based boards.  */
end_comment

begin_function
name|void
name|fe_msel_965
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_char
name|b13
decl_stmt|;
comment|/* Find the appropriate bits for BMPR13 tranceiver control.  */
switch|switch
condition|(
name|IFM_SUBTYPE
argument_list|(
name|sc
operator|->
name|media
operator|.
name|ifm_media
argument_list|)
condition|)
block|{
case|case
name|IFM_AUTO
case|:
name|b13
operator|=
name|FE_B13_PORT_AUTO
operator||
name|FE_B13_TPTYPE_UTP
expr_stmt|;
break|break;
case|case
name|IFM_10_T
case|:
name|b13
operator|=
name|FE_B13_PORT_TP
operator||
name|FE_B13_TPTYPE_UTP
expr_stmt|;
break|break;
default|default:
name|b13
operator|=
name|FE_B13_PORT_AUI
expr_stmt|;
break|break;
block|}
comment|/* Write it into the register.  It takes effect immediately.  */
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR13
argument_list|,
name|sc
operator|->
name|proto_bmpr13
operator||
name|b13
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Fujitsu MB86965 JLI mode support routines.  */
end_comment

begin_comment
comment|/*  * Routines to read all bytes from the config EEPROM through MB86965A.  * It is a MicroWire (3-wire) serial EEPROM with 6-bit address.  * (93C06 or 93C46.)  */
end_comment

begin_function
specifier|static
name|void
name|fe_strobe_eeprom_jli
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|,
name|u_short
name|bmpr16
parameter_list|)
block|{
comment|/* 	 * We must guarantee 1us (or more) interval to access slow 	 * EEPROMs.  The following redundant code provides enough 	 * delay with ISA timing.  (Even if the bus clock is "tuned.") 	 * Some modification will be needed on faster busses. 	 */
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|bmpr16
argument_list|,
name|FE_B16_SELECT
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|bmpr16
argument_list|,
name|FE_B16_SELECT
operator||
name|FE_B16_CLOCK
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|bmpr16
argument_list|,
name|FE_B16_SELECT
operator||
name|FE_B16_CLOCK
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|bmpr16
argument_list|,
name|FE_B16_SELECT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fe_read_eeprom_jli
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|)
block|{
name|u_char
name|n
decl_stmt|,
name|val
decl_stmt|,
name|bit
decl_stmt|;
name|u_char
name|save16
decl_stmt|,
name|save17
decl_stmt|;
comment|/* Save the current value of the EEPROM interface registers.  */
name|save16
operator|=
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR16
argument_list|)
expr_stmt|;
name|save17
operator|=
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR17
argument_list|)
expr_stmt|;
comment|/* Read bytes from EEPROM; two bytes per an iteration.  */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|JLI_EEPROM_SIZE
operator|/
literal|2
condition|;
name|n
operator|++
control|)
block|{
comment|/* Reset the EEPROM interface.  */
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR16
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR17
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Start EEPROM access.  */
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR16
argument_list|,
name|FE_B16_SELECT
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR17
argument_list|,
name|FE_B17_DATA
argument_list|)
expr_stmt|;
name|fe_strobe_eeprom_jli
argument_list|(
name|sc
argument_list|,
name|FE_BMPR16
argument_list|)
expr_stmt|;
comment|/* Pass the iteration count as well as a READ command.  */
name|val
operator|=
literal|0x80
operator||
name|n
expr_stmt|;
for|for
control|(
name|bit
operator|=
literal|0x80
init|;
name|bit
operator|!=
literal|0x00
condition|;
name|bit
operator|>>=
literal|1
control|)
block|{
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR17
argument_list|,
operator|(
name|val
operator|&
name|bit
operator|)
condition|?
name|FE_B17_DATA
else|:
literal|0
argument_list|)
expr_stmt|;
name|fe_strobe_eeprom_jli
argument_list|(
name|sc
argument_list|,
name|FE_BMPR16
argument_list|)
expr_stmt|;
block|}
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR17
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Read a byte.  */
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bit
operator|=
literal|0x80
init|;
name|bit
operator|!=
literal|0x00
condition|;
name|bit
operator|>>=
literal|1
control|)
block|{
name|fe_strobe_eeprom_jli
argument_list|(
name|sc
argument_list|,
name|FE_BMPR16
argument_list|)
expr_stmt|;
if|if
condition|(
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR17
argument_list|)
operator|&
name|FE_B17_DATA
condition|)
name|val
operator||=
name|bit
expr_stmt|;
block|}
operator|*
name|data
operator|++
operator|=
name|val
expr_stmt|;
comment|/* Read one more byte.  */
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bit
operator|=
literal|0x80
init|;
name|bit
operator|!=
literal|0x00
condition|;
name|bit
operator|>>=
literal|1
control|)
block|{
name|fe_strobe_eeprom_jli
argument_list|(
name|sc
argument_list|,
name|FE_BMPR16
argument_list|)
expr_stmt|;
if|if
condition|(
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR17
argument_list|)
operator|&
name|FE_B17_DATA
condition|)
name|val
operator||=
name|bit
expr_stmt|;
block|}
operator|*
name|data
operator|++
operator|=
name|val
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* Reset the EEPROM interface, again.  */
block|fe_outb(sc, FE_BMPR16, 0x00); 	fe_outb(sc, FE_BMPR17, 0x00);
else|#
directive|else
comment|/* Make sure to restore the original value of EEPROM interface            registers, since we are not yet sure we have MB86965A on            the address.  */
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR17
argument_list|,
name|save17
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR16
argument_list|,
name|save16
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|1
comment|/* Report what we got.  */
if|if
condition|(
name|bootverbose
condition|)
block|{
name|int
name|i
decl_stmt|;
name|data
operator|-=
name|JLI_EEPROM_SIZE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|JLI_EEPROM_SIZE
condition|;
name|i
operator|+=
literal|16
control|)
block|{
name|printf
argument_list|(
literal|"fe%d: EEPROM(JLI):%3x: %16D\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|i
argument_list|,
name|data
operator|+
name|i
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|fe_init_jli
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* "Reset" by writing into a magic location.  */
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
literal|0x1E
argument_list|,
name|fe_inb
argument_list|(
name|sc
argument_list|,
literal|0x1E
argument_list|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|300
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * SSi 78Q8377A support routines.  */
end_comment

begin_comment
comment|/*  * Routines to read all bytes from the config EEPROM through 78Q8377A.  * It is a MicroWire (3-wire) serial EEPROM with 8-bit address.  (I.e.,  * 93C56 or 93C66.)  *  * As I don't have SSi manuals, (hmm, an old song again!) I'm not exactly  * sure the following code is correct...  It is just stolen from the  * C-NET(98)P2 support routine in FreeBSD(98).  */
end_comment

begin_function
name|void
name|fe_read_eeprom_ssi
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|)
block|{
name|u_char
name|val
decl_stmt|,
name|bit
decl_stmt|;
name|int
name|n
decl_stmt|;
name|u_char
name|save6
decl_stmt|,
name|save7
decl_stmt|,
name|save12
decl_stmt|;
comment|/* Save the current value for the DLCR registers we are about            to destroy.  */
name|save6
operator|=
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR6
argument_list|)
expr_stmt|;
name|save7
operator|=
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR7
argument_list|)
expr_stmt|;
comment|/* Put the 78Q8377A into a state that we can access the EEPROM.  */
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR6
argument_list|,
name|FE_D6_BBW_WORD
operator||
name|FE_D6_SBW_WORD
operator||
name|FE_D6_DLC_DISABLE
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR7
argument_list|,
name|FE_D7_BYTSWP_LH
operator||
name|FE_D7_RBS_BMPR
operator||
name|FE_D7_RDYPNS
operator||
name|FE_D7_POWER_UP
argument_list|)
expr_stmt|;
comment|/* Save the current value for the BMPR12 register, too.  */
name|save12
operator|=
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR12
argument_list|)
expr_stmt|;
comment|/* Read bytes from EEPROM; two bytes per an iteration.  */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|SSI_EEPROM_SIZE
operator|/
literal|2
condition|;
name|n
operator|++
control|)
block|{
comment|/* Start EEPROM access  */
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR12
argument_list|,
name|SSI_EEP
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR12
argument_list|,
name|SSI_EEP
operator||
name|SSI_CSL
argument_list|)
expr_stmt|;
comment|/* Send the following four bits to the EEPROM in the 		   specified order: a dummy bit, a start bit, and 		   command bits (10) for READ.  */
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR12
argument_list|,
name|SSI_EEP
operator||
name|SSI_CSL
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR12
argument_list|,
name|SSI_EEP
operator||
name|SSI_CSL
operator||
name|SSI_CLK
argument_list|)
expr_stmt|;
comment|/* 0 */
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR12
argument_list|,
name|SSI_EEP
operator||
name|SSI_CSL
operator||
name|SSI_DAT
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR12
argument_list|,
name|SSI_EEP
operator||
name|SSI_CSL
operator||
name|SSI_CLK
operator||
name|SSI_DAT
argument_list|)
expr_stmt|;
comment|/* 1 */
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR12
argument_list|,
name|SSI_EEP
operator||
name|SSI_CSL
operator||
name|SSI_DAT
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR12
argument_list|,
name|SSI_EEP
operator||
name|SSI_CSL
operator||
name|SSI_CLK
operator||
name|SSI_DAT
argument_list|)
expr_stmt|;
comment|/* 1 */
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR12
argument_list|,
name|SSI_EEP
operator||
name|SSI_CSL
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR12
argument_list|,
name|SSI_EEP
operator||
name|SSI_CSL
operator||
name|SSI_CLK
argument_list|)
expr_stmt|;
comment|/* 0 */
comment|/* Pass the iteration count to the chip.  */
for|for
control|(
name|bit
operator|=
literal|0x80
init|;
name|bit
operator|!=
literal|0x00
condition|;
name|bit
operator|>>=
literal|1
control|)
block|{
name|val
operator|=
operator|(
name|n
operator|&
name|bit
operator|)
condition|?
name|SSI_DAT
else|:
literal|0
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR12
argument_list|,
name|SSI_EEP
operator||
name|SSI_CSL
operator||
name|val
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR12
argument_list|,
name|SSI_EEP
operator||
name|SSI_CSL
operator||
name|SSI_CLK
operator||
name|val
argument_list|)
expr_stmt|;
block|}
comment|/* Read a byte.  */
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bit
operator|=
literal|0x80
init|;
name|bit
operator|!=
literal|0x00
condition|;
name|bit
operator|>>=
literal|1
control|)
block|{
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR12
argument_list|,
name|SSI_EEP
operator||
name|SSI_CSL
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR12
argument_list|,
name|SSI_EEP
operator||
name|SSI_CSL
operator||
name|SSI_CLK
argument_list|)
expr_stmt|;
if|if
condition|(
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR12
argument_list|)
operator|&
name|SSI_DIN
condition|)
name|val
operator||=
name|bit
expr_stmt|;
block|}
operator|*
name|data
operator|++
operator|=
name|val
expr_stmt|;
comment|/* Read one more byte.  */
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bit
operator|=
literal|0x80
init|;
name|bit
operator|!=
literal|0x00
condition|;
name|bit
operator|>>=
literal|1
control|)
block|{
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR12
argument_list|,
name|SSI_EEP
operator||
name|SSI_CSL
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR12
argument_list|,
name|SSI_EEP
operator||
name|SSI_CSL
operator||
name|SSI_CLK
argument_list|)
expr_stmt|;
if|if
condition|(
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR12
argument_list|)
operator|&
name|SSI_DIN
condition|)
name|val
operator||=
name|bit
expr_stmt|;
block|}
operator|*
name|data
operator|++
operator|=
name|val
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR12
argument_list|,
name|SSI_EEP
argument_list|)
expr_stmt|;
block|}
comment|/* Reset the EEPROM interface.  (For now.)  */
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR12
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Restore the saved register values, for the case that we            didn't have 78Q8377A at the given address.  */
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR12
argument_list|,
name|save12
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR7
argument_list|,
name|save7
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR6
argument_list|,
name|save6
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* Report what we got.  */
if|if
condition|(
name|bootverbose
condition|)
block|{
name|int
name|i
decl_stmt|;
name|data
operator|-=
name|SSI_EEPROM_SIZE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SSI_EEPROM_SIZE
condition|;
name|i
operator|+=
literal|16
control|)
block|{
name|printf
argument_list|(
literal|"fe%d: EEPROM(SSI):%3x: %16D\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|i
argument_list|,
name|data
operator|+
name|i
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * TDK/LANX boards support routines.  */
end_comment

begin_comment
comment|/* It is assumed that the CLK line is low and SDA is high (float) upon entry.  */
end_comment

begin_define
define|#
directive|define
name|LNX_PH
parameter_list|(
name|D
parameter_list|,
name|K
parameter_list|,
name|N
parameter_list|)
define|\
value|((LNX_SDA_##D | LNX_CLK_##K)<< N)
end_define

begin_define
define|#
directive|define
name|LNX_CYCLE
parameter_list|(
name|D1
parameter_list|,
name|D2
parameter_list|,
name|D3
parameter_list|,
name|D4
parameter_list|,
name|K1
parameter_list|,
name|K2
parameter_list|,
name|K3
parameter_list|,
name|K4
parameter_list|)
define|\
value|(LNX_PH(D1,K1,0)|LNX_PH(D2,K2,8)|LNX_PH(D3,K3,16)|LNX_PH(D4,K4,24))
end_define

begin_define
define|#
directive|define
name|LNX_CYCLE_START
value|LNX_CYCLE(HI,LO,LO,HI, HI,HI,LO,LO)
end_define

begin_define
define|#
directive|define
name|LNX_CYCLE_STOP
value|LNX_CYCLE(LO,LO,HI,HI, LO,HI,HI,LO)
end_define

begin_define
define|#
directive|define
name|LNX_CYCLE_HI
value|LNX_CYCLE(HI,HI,HI,HI, LO,HI,LO,LO)
end_define

begin_define
define|#
directive|define
name|LNX_CYCLE_LO
value|LNX_CYCLE(LO,LO,LO,HI, LO,HI,LO,LO)
end_define

begin_define
define|#
directive|define
name|LNX_CYCLE_INIT
value|LNX_CYCLE(LO,HI,HI,HI, LO,LO,LO,LO)
end_define

begin_function
specifier|static
name|void
name|fe_eeprom_cycle_lnx
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|,
name|u_short
name|reg20
parameter_list|,
name|u_long
name|cycle
parameter_list|)
block|{
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|reg20
argument_list|,
operator|(
name|cycle
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|15
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|reg20
argument_list|,
operator|(
name|cycle
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|15
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|reg20
argument_list|,
operator|(
name|cycle
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|15
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|reg20
argument_list|,
operator|(
name|cycle
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|15
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_char
name|fe_eeprom_receive_lnx
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|,
name|u_short
name|reg20
parameter_list|)
block|{
name|u_char
name|dat
decl_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|reg20
argument_list|,
name|LNX_CLK_HI
operator||
name|LNX_SDA_FL
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|15
argument_list|)
expr_stmt|;
name|dat
operator|=
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|reg20
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|reg20
argument_list|,
name|LNX_CLK_LO
operator||
name|LNX_SDA_FL
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|15
argument_list|)
expr_stmt|;
return|return
operator|(
name|dat
operator|&
name|LNX_SDA_IN
operator|)
return|;
block|}
end_function

begin_function
name|void
name|fe_read_eeprom_lnx
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_char
name|n
decl_stmt|,
name|bit
decl_stmt|,
name|val
decl_stmt|;
name|u_char
name|save20
decl_stmt|;
name|u_short
name|reg20
init|=
literal|0x14
decl_stmt|;
name|save20
operator|=
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|reg20
argument_list|)
expr_stmt|;
comment|/* NOTE: DELAY() timing constants are approximately three            times longer (slower) than the required minimum.  This is            to guarantee a reliable operation under some tough            conditions...  Fortunately, this routine is only called            during the boot phase, so the speed is less important than            stability.  */
if|#
directive|if
literal|1
comment|/* Reset the X24C01's internal state machine and put it into 	   the IDLE state.  We usually don't need this, but *if* 	   someone (e.g., probe routine of other driver) write some 	   garbage into the register at 0x14, synchronization will be 	   lost, and the normal EEPROM access protocol won't work. 	   Moreover, as there are no easy way to reset, we need a 	   _manoeuvre_ here.  (It even lacks a reset pin, so pushing 	   the RESET button on the PC doesn't help!)  */
name|fe_eeprom_cycle_lnx
argument_list|(
name|sc
argument_list|,
name|reg20
argument_list|,
name|LNX_CYCLE_INIT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
name|fe_eeprom_cycle_lnx
argument_list|(
name|sc
argument_list|,
name|reg20
argument_list|,
name|LNX_CYCLE_START
argument_list|)
expr_stmt|;
name|fe_eeprom_cycle_lnx
argument_list|(
name|sc
argument_list|,
name|reg20
argument_list|,
name|LNX_CYCLE_STOP
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Issue a start condition.  */
name|fe_eeprom_cycle_lnx
argument_list|(
name|sc
argument_list|,
name|reg20
argument_list|,
name|LNX_CYCLE_START
argument_list|)
expr_stmt|;
comment|/* Send seven bits of the starting address (zero, in this 	   case) and a command bit for READ.  */
name|val
operator|=
literal|0x01
expr_stmt|;
for|for
control|(
name|bit
operator|=
literal|0x80
init|;
name|bit
operator|!=
literal|0x00
condition|;
name|bit
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
name|val
operator|&
name|bit
condition|)
block|{
name|fe_eeprom_cycle_lnx
argument_list|(
name|sc
argument_list|,
name|reg20
argument_list|,
name|LNX_CYCLE_HI
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fe_eeprom_cycle_lnx
argument_list|(
name|sc
argument_list|,
name|reg20
argument_list|,
name|LNX_CYCLE_LO
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Receive an ACK bit.  */
if|if
condition|(
name|fe_eeprom_receive_lnx
argument_list|(
name|sc
argument_list|,
name|reg20
argument_list|)
condition|)
block|{
comment|/* ACK was not received.  EEPROM is not present (i.e., 		   this board was not a TDK/LANX) or not working 		   properly.  */
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"fe%d: no ACK received from EEPROM(LNX)\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
block|}
comment|/* Clear the given buffer to indicate we could not get                    any info. and return.  */
name|bzero
argument_list|(
name|data
argument_list|,
name|LNX_EEPROM_SIZE
argument_list|)
expr_stmt|;
goto|goto
name|RET
goto|;
block|}
comment|/* Read bytes from EEPROM.  */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|LNX_EEPROM_SIZE
condition|;
name|n
operator|++
control|)
block|{
comment|/* Read a byte and store it into the buffer.  */
name|val
operator|=
literal|0x00
expr_stmt|;
for|for
control|(
name|bit
operator|=
literal|0x80
init|;
name|bit
operator|!=
literal|0x00
condition|;
name|bit
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
name|fe_eeprom_receive_lnx
argument_list|(
name|sc
argument_list|,
name|reg20
argument_list|)
condition|)
name|val
operator||=
name|bit
expr_stmt|;
block|}
operator|*
name|data
operator|++
operator|=
name|val
expr_stmt|;
comment|/* Acknowledge if we have to read more.  */
if|if
condition|(
name|n
operator|<
name|LNX_EEPROM_SIZE
operator|-
literal|1
condition|)
block|{
name|fe_eeprom_cycle_lnx
argument_list|(
name|sc
argument_list|,
name|reg20
argument_list|,
name|LNX_CYCLE_LO
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Issue a STOP condition, de-activating the clock line. 	   It will be safer to keep the clock line low than to leave 	   it high.  */
name|fe_eeprom_cycle_lnx
argument_list|(
name|sc
argument_list|,
name|reg20
argument_list|,
name|LNX_CYCLE_STOP
argument_list|)
expr_stmt|;
name|RET
label|:
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|reg20
argument_list|,
name|save20
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* Report what we got.  */
if|if
condition|(
name|bootverbose
condition|)
block|{
name|data
operator|-=
name|LNX_EEPROM_SIZE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LNX_EEPROM_SIZE
condition|;
name|i
operator|+=
literal|16
control|)
block|{
name|printf
argument_list|(
literal|"fe%d: EEPROM(LNX):%3x: %16D\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|i
argument_list|,
name|data
operator|+
name|i
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|fe_init_lnx
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Reset the 86960.  Do we need this?  FIXME.  */
name|fe_outb
argument_list|(
name|sc
argument_list|,
literal|0x12
argument_list|,
literal|0x06
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
literal|0x12
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* Setup IRQ control register on the ASIC.  */
name|fe_outb
argument_list|(
name|sc
argument_list|,
literal|0x14
argument_list|,
name|sc
operator|->
name|priv_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Ungermann-Bass boards support routine.  */
end_comment

begin_function
name|void
name|fe_init_ubn
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Do we need this?  FIXME.  */
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR7
argument_list|,
name|sc
operator|->
name|proto_dlcr7
operator||
name|FE_D7_RBS_BMPR
operator||
name|FE_D7_POWER_UP
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
literal|0x18
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* Setup IRQ control register on the ASIC.  */
name|fe_outb
argument_list|(
name|sc
argument_list|,
literal|0x14
argument_list|,
name|sc
operator|->
name|priv_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Install interface into kernel networking data structures  */
end_comment

begin_function
name|int
name|fe_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|flags
init|=
name|device_get_flags
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|b
decl_stmt|,
name|error
decl_stmt|;
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|INTR_TYPE_NET
argument_list|,
name|fe_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|irq_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|fe_release_resource
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/* 	 * Initialize ifnet structure 	 */
name|sc
operator|->
name|sc_if
operator|.
name|if_softc
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_unit
operator|=
name|sc
operator|->
name|sc_unit
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_name
operator|=
literal|"fe"
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_start
operator|=
name|fe_start
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ioctl
operator|=
name|fe_ioctl
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_watchdog
operator|=
name|fe_watchdog
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_init
operator|=
name|fe_init
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_linkmib
operator|=
operator|&
name|sc
operator|->
name|mibdata
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_linkmiblen
operator|=
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|mibdata
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* I'm not sure... */
block|sc->mibdata.dot3Compliance = DOT3COMPLIANCE_COLLS;
endif|#
directive|endif
comment|/* 	 * Set fixed interface flags. 	 */
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
if|#
directive|if
literal|1
comment|/* 	 * Set maximum size of output queue, if it has not been set. 	 * It is done here as this driver may be started after the 	 * system initialization (i.e., the interface is PCMCIA.) 	 * 	 * I'm not sure this is really necessary, but, even if it is, 	 * it should be done somewhere else, e.g., in if_attach(), 	 * since it must be a common workaround for all network drivers. 	 * FIXME. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_if
operator|.
name|if_snd
operator|.
name|ifq_maxlen
operator|==
literal|0
condition|)
name|sc
operator|->
name|sc_if
operator|.
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|ifqmaxlen
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|FE_SINGLE_TRANSMISSION
comment|/* Override txb config to allocate minimum.  */
name|sc
operator|->
name|proto_dlcr6
operator|&=
operator|~
name|FE_D6_TXBSIZ
name|sc
operator|->
name|proto_dlcr6
operator||=
name|FE_D6_TXBSIZ_2x2KB
expr_stmt|;
endif|#
directive|endif
comment|/* Modify hardware config if it is requested.  */
if|if
condition|(
name|flags
operator|&
name|FE_FLAGS_OVERRIDE_DLCR6
condition|)
name|sc
operator|->
name|proto_dlcr6
operator|=
name|flags
operator|&
name|FE_FLAGS_DLCR6_VALUE
expr_stmt|;
comment|/* Find TX buffer size, based on the hardware dependent proto.  */
switch|switch
condition|(
name|sc
operator|->
name|proto_dlcr6
operator|&
name|FE_D6_TXBSIZ
condition|)
block|{
case|case
name|FE_D6_TXBSIZ_2x2KB
case|:
name|sc
operator|->
name|txb_size
operator|=
literal|2048
expr_stmt|;
break|break;
case|case
name|FE_D6_TXBSIZ_2x4KB
case|:
name|sc
operator|->
name|txb_size
operator|=
literal|4096
expr_stmt|;
break|break;
case|case
name|FE_D6_TXBSIZ_2x8KB
case|:
name|sc
operator|->
name|txb_size
operator|=
literal|8192
expr_stmt|;
break|break;
default|default:
comment|/* Oops, we can't work with single buffer configuration.  */
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"fe%d: strange TXBSIZ config; fixing\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|proto_dlcr6
operator|&=
operator|~
name|FE_D6_TXBSIZ
expr_stmt|;
name|sc
operator|->
name|proto_dlcr6
operator||=
name|FE_D6_TXBSIZ_2x2KB
expr_stmt|;
name|sc
operator|->
name|txb_size
operator|=
literal|2048
expr_stmt|;
break|break;
block|}
comment|/* Initialize the if_media interface.  */
name|ifmedia_init
argument_list|(
operator|&
name|sc
operator|->
name|media
argument_list|,
literal|0
argument_list|,
name|fe_medchange
argument_list|,
name|fe_medstat
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|bit2media
index|[
name|b
index|]
operator|!=
literal|0
condition|;
name|b
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|mbitmap
operator|&
operator|(
literal|1
operator|<<
name|b
operator|)
condition|)
block|{
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|media
argument_list|,
name|bit2media
index|[
name|b
index|]
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|b
operator|=
literal|0
init|;
name|bit2media
index|[
name|b
index|]
operator|!=
literal|0
condition|;
name|b
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|defmedia
operator|&
operator|(
literal|1
operator|<<
name|b
operator|)
condition|)
block|{
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|media
argument_list|,
name|bit2media
index|[
name|b
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|#
directive|if
literal|0
comment|/* Turned off; this is called later, when the interface UPs.  */
block|fe_medchange(sc);
endif|#
directive|endif
comment|/* Attach and stop the interface. */
name|ether_ifattach
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|,
name|ETHER_BPF_SUPPORTED
argument_list|)
expr_stmt|;
name|fe_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Print additional info when attached.  */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"address %6D, type %s%s\n"
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
literal|":"
argument_list|,
name|sc
operator|->
name|typestr
argument_list|,
operator|(
name|sc
operator|->
name|proto_dlcr4
operator|&
name|FE_D4_DSC
operator|)
condition|?
literal|", full duplex"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|int
name|buf
decl_stmt|,
name|txb
decl_stmt|,
name|bbw
decl_stmt|,
name|sbw
decl_stmt|,
name|ram
decl_stmt|;
name|buf
operator|=
name|txb
operator|=
name|bbw
operator|=
name|sbw
operator|=
name|ram
operator|=
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|proto_dlcr6
operator|&
name|FE_D6_BUFSIZ
condition|)
block|{
case|case
name|FE_D6_BUFSIZ_8KB
case|:
name|buf
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|FE_D6_BUFSIZ_16KB
case|:
name|buf
operator|=
literal|16
expr_stmt|;
break|break;
case|case
name|FE_D6_BUFSIZ_32KB
case|:
name|buf
operator|=
literal|32
expr_stmt|;
break|break;
case|case
name|FE_D6_BUFSIZ_64KB
case|:
name|buf
operator|=
literal|64
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|sc
operator|->
name|proto_dlcr6
operator|&
name|FE_D6_TXBSIZ
condition|)
block|{
case|case
name|FE_D6_TXBSIZ_2x2KB
case|:
name|txb
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|FE_D6_TXBSIZ_2x4KB
case|:
name|txb
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|FE_D6_TXBSIZ_2x8KB
case|:
name|txb
operator|=
literal|8
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|sc
operator|->
name|proto_dlcr6
operator|&
name|FE_D6_BBW
condition|)
block|{
case|case
name|FE_D6_BBW_BYTE
case|:
name|bbw
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|FE_D6_BBW_WORD
case|:
name|bbw
operator|=
literal|16
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|sc
operator|->
name|proto_dlcr6
operator|&
name|FE_D6_SBW
condition|)
block|{
case|case
name|FE_D6_SBW_BYTE
case|:
name|sbw
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|FE_D6_SBW_WORD
case|:
name|sbw
operator|=
literal|16
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|sc
operator|->
name|proto_dlcr6
operator|&
name|FE_D6_SRAM
condition|)
block|{
case|case
name|FE_D6_SRAM_100ns
case|:
name|ram
operator|=
literal|100
expr_stmt|;
break|break;
case|case
name|FE_D6_SRAM_150ns
case|:
name|ram
operator|=
literal|150
expr_stmt|;
break|break;
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"SRAM %dKB %dbit %dns, TXB %dKBx2, %dbit I/O\n"
argument_list|,
name|buf
argument_list|,
name|bbw
argument_list|,
name|ram
argument_list|,
name|txb
argument_list|,
name|sbw
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|stability
operator|&
name|UNSTABLE_IRQ
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"warning: IRQ number may be incorrect\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|stability
operator|&
name|UNSTABLE_MAC
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"warning: above MAC address may be incorrect\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|stability
operator|&
name|UNSTABLE_TYPE
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"warning: hardware type was not validated\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|fe_alloc_port
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|rid
operator|=
literal|0
expr_stmt|;
name|res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|rid
argument_list|,
literal|0ul
argument_list|,
operator|~
literal|0ul
argument_list|,
name|size
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
block|{
name|sc
operator|->
name|port_used
operator|=
name|size
expr_stmt|;
name|sc
operator|->
name|port_res
operator|=
name|res
expr_stmt|;
name|sc
operator|->
name|iot
operator|=
name|rman_get_bustag
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ioh
operator|=
name|rman_get_bushandle
argument_list|(
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fe_alloc_irq
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|rid
operator|=
literal|0
expr_stmt|;
name|res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
literal|0ul
argument_list|,
operator|~
literal|0ul
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
operator||
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
block|{
name|sc
operator|->
name|irq_res
operator|=
name|res
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_function
name|void
name|fe_release_resource
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|port_res
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|port_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|port_res
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|irq_res
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq_res
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Reset interface, after some (hardware) trouble is deteced.  */
end_comment

begin_function
specifier|static
name|void
name|fe_reset
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Record how many packets are lost by this accident.  */
name|sc
operator|->
name|sc_if
operator|.
name|if_oerrors
operator|+=
name|sc
operator|->
name|txb_sched
operator|+
name|sc
operator|->
name|txb_count
expr_stmt|;
name|sc
operator|->
name|mibdata
operator|.
name|dot3StatsInternalMacTransmitErrors
operator|++
expr_stmt|;
comment|/* Put the interface into known initial state.  */
name|fe_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_UP
condition|)
name|fe_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop everything on the interface.  *  * All buffered packets, both transmitting and receiving,  * if any, will be lost by stopping the interface.  */
end_comment

begin_function
name|void
name|fe_stop
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* Disable interrupts.  */
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR2
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR3
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Stop interface hardware.  */
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR6
argument_list|,
name|sc
operator|->
name|proto_dlcr6
operator||
name|FE_D6_DLC_DISABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* Clear all interrupt status.  */
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR0
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR1
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
comment|/* Put the chip in stand-by mode.  */
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR7
argument_list|,
name|sc
operator|->
name|proto_dlcr7
operator||
name|FE_D7_POWER_DOWN
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* Reset transmitter variables and interface flags.  */
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&=
operator|~
operator|(
name|IFF_OACTIVE
operator||
name|IFF_RUNNING
operator|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_timer
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|txb_free
operator|=
name|sc
operator|->
name|txb_size
expr_stmt|;
name|sc
operator|->
name|txb_count
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|txb_sched
operator|=
literal|0
expr_stmt|;
comment|/* MAR loading can be delayed.  */
name|sc
operator|->
name|filter_change
operator|=
literal|0
expr_stmt|;
comment|/* Call a device-specific hook.  */
if|if
condition|(
name|sc
operator|->
name|stop
condition|)
name|sc
operator|->
name|stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Device timeout/watchdog routine. Entered if the device neglects to  * generate an interrupt after a transmit has been started on it.  */
end_comment

begin_function
specifier|static
name|void
name|fe_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|fe_softc
operator|*
operator|)
name|ifp
decl_stmt|;
comment|/* A "debug" message.  */
name|printf
argument_list|(
literal|"fe%d: transmission timeout (%d+%d)%s\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|,
name|sc
operator|->
name|txb_sched
argument_list|,
name|sc
operator|->
name|txb_count
argument_list|,
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
condition|?
literal|""
else|:
literal|" when down"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_if
operator|.
name|if_opackets
operator|==
literal|0
operator|&&
name|sc
operator|->
name|sc_if
operator|.
name|if_ipackets
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"fe%d: wrong IRQ setting in config?\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
name|fe_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize device.  */
end_comment

begin_function
specifier|static
name|void
name|fe_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* We need an address. */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
operator|.
name|if_addrhead
argument_list|)
condition|)
block|{
comment|/* XXX unlikely */
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|printf
argument_list|(
literal|"fe%d: init() without any address\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* Start initializing 86960.  */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* Call a hook before we start initializing the chip.  */
if|if
condition|(
name|sc
operator|->
name|init
condition|)
name|sc
operator|->
name|init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure to disable the chip, also. 	 * This may also help re-programming the chip after 	 * hot insertion of PCMCIAs. 	 */
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR6
argument_list|,
name|sc
operator|->
name|proto_dlcr6
operator||
name|FE_D6_DLC_DISABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* Power up the chip and select register bank for DLCRs.  */
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR7
argument_list|,
name|sc
operator|->
name|proto_dlcr7
operator||
name|FE_D7_RBS_DLCR
operator||
name|FE_D7_POWER_UP
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* Feed the station address.  */
name|fe_outblk
argument_list|(
name|sc
argument_list|,
name|FE_DLCR8
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* Clear multicast address filter to receive nothing.  */
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR7
argument_list|,
name|sc
operator|->
name|proto_dlcr7
operator||
name|FE_D7_RBS_MAR
operator||
name|FE_D7_POWER_UP
argument_list|)
expr_stmt|;
name|fe_outblk
argument_list|(
name|sc
argument_list|,
name|FE_MAR8
argument_list|,
name|fe_filter_nothing
operator|.
name|data
argument_list|,
name|FE_FILTER_LEN
argument_list|)
expr_stmt|;
comment|/* Select the BMPR bank for runtime register access.  */
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR7
argument_list|,
name|sc
operator|->
name|proto_dlcr7
operator||
name|FE_D7_RBS_BMPR
operator||
name|FE_D7_POWER_UP
argument_list|)
expr_stmt|;
comment|/* Initialize registers.  */
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR0
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
comment|/* Clear all bits.  */
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR1
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
comment|/* ditto.  */
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR2
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR3
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR4
argument_list|,
name|sc
operator|->
name|proto_dlcr4
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR5
argument_list|,
name|sc
operator|->
name|proto_dlcr5
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR10
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR11
argument_list|,
name|FE_B11_CTRL_SKIP
operator||
name|FE_B11_MODE1
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR12
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR13
argument_list|,
name|sc
operator|->
name|proto_bmpr13
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR14
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR15
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Enable interrupts.  */
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR2
argument_list|,
name|FE_TMASK
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR3
argument_list|,
name|FE_RMASK
argument_list|)
expr_stmt|;
comment|/* Select requested media, just before enabling DLC.  */
if|if
condition|(
name|sc
operator|->
name|msel
condition|)
name|sc
operator|->
name|msel
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Enable transmitter and receiver.  */
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR6
argument_list|,
name|sc
operator|->
name|proto_dlcr6
operator||
name|FE_D6_DLC_ENABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
comment|/* 	 * Make sure to empty the receive buffer. 	 * 	 * This may be redundant, but *if* the receive buffer were full 	 * at this point, then the driver would hang.  I have experienced 	 * some strange hang-up just after UP.  I hope the following 	 * code solve the problem. 	 * 	 * I have changed the order of hardware initialization. 	 * I think the receive buffer cannot have any packets at this 	 * point in this version.  The following code *must* be 	 * redundant now.  FIXME. 	 * 	 * I've heard a rumore that on some PC card implementation of 	 * 8696x, the receive buffer can have some data at this point. 	 * The following message helps discovering the fact.  FIXME. 	 */
if|if
condition|(
operator|!
operator|(
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR5
argument_list|)
operator|&
name|FE_D5_BUFEMP
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"fe%d: receive buffer has some data after reset\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
name|fe_emptybuffer
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* Do we need this here?  Actually, no.  I must be paranoia.  */
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR0
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
comment|/* Clear all bits.  */
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR1
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
comment|/* ditto.  */
endif|#
directive|endif
comment|/* Set 'running' flag, because we are now running.   */
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
comment|/* 	 * At this point, the interface is running properly, 	 * except that it receives *no* packets.  we then call 	 * fe_setmode() to tell the chip what packets to be 	 * received, based on the if_flags and multicast group 	 * list.  It completes the initialization process. 	 */
name|fe_setmode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* ...and attempt to start output queued packets.  */
comment|/* TURNED OFF, because the semi-auto media prober wants to UP            the interface keeping it idle.  The upper layer will soon            start the interface anyway, and there are no significant            delay.  */
block|fe_start(&sc->sc_if);
endif|#
directive|endif
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine actually starts the transmission on the interface  */
end_comment

begin_function
specifier|static
name|void
name|fe_xmit
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* 	 * Set a timer just in case we never hear from the board again. 	 * We use longer timeout for multiple packet transmission. 	 * I'm not sure this timer value is appropriate.  FIXME. 	 */
name|sc
operator|->
name|sc_if
operator|.
name|if_timer
operator|=
literal|1
operator|+
name|sc
operator|->
name|txb_count
expr_stmt|;
comment|/* Update txb variables.  */
name|sc
operator|->
name|txb_sched
operator|=
name|sc
operator|->
name|txb_count
expr_stmt|;
name|sc
operator|->
name|txb_count
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|txb_free
operator|=
name|sc
operator|->
name|txb_size
expr_stmt|;
name|sc
operator|->
name|tx_excolls
operator|=
literal|0
expr_stmt|;
comment|/* Start transmitter, passing packets in TX buffer.  */
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR10
argument_list|,
name|sc
operator|->
name|txb_sched
operator||
name|FE_B10_START
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start output on interface.  * We make two assumptions here:  *  1) that the current priority is set to splimp _before_ this code  *     is called *and* is returned to the appropriate priority after  *     return  *  2) that the IFF_OACTIVE flag is checked before this code is called  *     (i.e. that the output part of the interface is idle)  */
end_comment

begin_function
specifier|static
name|void
name|fe_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
comment|/* Just a sanity check.  */
if|if
condition|(
operator|(
name|sc
operator|->
name|txb_count
operator|==
literal|0
operator|)
operator|!=
operator|(
name|sc
operator|->
name|txb_free
operator|==
name|sc
operator|->
name|txb_size
operator|)
condition|)
block|{
comment|/* 		 * Txb_count and txb_free co-works to manage the 		 * transmission buffer.  Txb_count keeps track of the 		 * used potion of the buffer, while txb_free does unused 		 * potion.  So, as long as the driver runs properly, 		 * txb_count is zero if and only if txb_free is same 		 * as txb_size (which represents whole buffer.) 		 */
name|printf
argument_list|(
literal|"fe%d: inconsistent txb variables (%d, %d)\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|sc
operator|->
name|txb_count
argument_list|,
name|sc
operator|->
name|txb_free
argument_list|)
expr_stmt|;
comment|/* 		 * So, what should I do, then? 		 * 		 * We now know txb_count and txb_free contradicts.  We 		 * cannot, however, tell which is wrong.  More 		 * over, we cannot peek 86960 transmission buffer or 		 * reset the transmission buffer.  (In fact, we can 		 * reset the entire interface.  I don't want to do it.) 		 * 		 * If txb_count is incorrect, leaving it as-is will cause 		 * sending of garbage after next interrupt.  We have to 		 * avoid it.  Hence, we reset the txb_count here.  If 		 * txb_free was incorrect, resetting txb_count just loose 		 * some packets.  We can live with it. 		 */
name|sc
operator|->
name|txb_count
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * First, see if there are buffered packets and an idle 	 * transmitter - should never happen at this point. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|txb_count
operator|>
literal|0
operator|)
operator|&&
operator|(
name|sc
operator|->
name|txb_sched
operator|==
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"fe%d: transmitter idle with %d buffered packets\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|sc
operator|->
name|txb_count
argument_list|)
expr_stmt|;
name|fe_xmit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Stop accepting more transmission packets temporarily, when 	 * a filter change request is delayed.  Updating the MARs on 	 * 86960 flushes the transmission buffer, so it is delayed 	 * until all buffered transmission packets have been sent 	 * out. 	 */
if|if
condition|(
name|sc
operator|->
name|filter_change
condition|)
block|{
comment|/* 		 * Filter change request is delayed only when the DLC is 		 * working.  DLC soon raise an interrupt after finishing 		 * the work. 		 */
goto|goto
name|indicate_active
goto|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * See if there is room to put another packet in the buffer. 		 * We *could* do better job by peeking the send queue to 		 * know the length of the next packet.  Current version just 		 * tests against the worst case (i.e., longest packet).  FIXME. 		 * 		 * When adding the packet-peek feature, don't forget adding a 		 * test on txb_count against QUEUEING_MAX. 		 * There is a little chance the packet count exceeds 		 * the limit.  Assume transmission buffer is 8KB (2x8KB 		 * configuration) and an application sends a bunch of small 		 * (i.e., minimum packet sized) packets rapidly.  An 8KB 		 * buffer can hold 130 blocks of 62 bytes long... 		 */
if|if
condition|(
name|sc
operator|->
name|txb_free
operator|<
name|ETHER_MAX_LEN
operator|-
name|ETHER_CRC_LEN
operator|+
name|FE_DATA_LEN_LEN
condition|)
block|{
comment|/* No room.  */
goto|goto
name|indicate_active
goto|;
block|}
if|#
directive|if
name|FE_SINGLE_TRANSMISSION
if|if
condition|(
name|sc
operator|->
name|txb_count
operator|>
literal|0
condition|)
block|{
comment|/* Just one packet per a transmission buffer.  */
goto|goto
name|indicate_active
goto|;
block|}
endif|#
directive|endif
comment|/* 		 * Get the next mbuf chain for a packet to send. 		 */
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
operator|.
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* No more packets to send.  */
goto|goto
name|indicate_inactive
goto|;
block|}
comment|/* 		 * Copy the mbuf chain into the transmission buffer. 		 * txb_* variables are updated as necessary. 		 */
name|fe_write_mbufs
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* Start transmitter if it's idle.  */
if|if
condition|(
operator|(
name|sc
operator|->
name|txb_count
operator|>
literal|0
operator|)
operator|&&
operator|(
name|sc
operator|->
name|txb_sched
operator|==
literal|0
operator|)
condition|)
name|fe_xmit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 		 * Tap off here if there is a bpf listener, 		 * and the device is *not* in promiscuous mode. 		 * (86960 receives self-generated packets if  		 * and only if it is in "receive everything" 		 * mode.) 		 */
if|if
condition|(
name|sc
operator|->
name|sc_if
operator|.
name|if_bpf
operator|&&
operator|!
operator|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
condition|)
name|bpf_mtap
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|indicate_inactive
label|:
comment|/* 	 * We are using the !OACTIVE flag to indicate to 	 * the outside world that we can accept an 	 * additional packet rather than that the 	 * transmitter is _actually_ active.  Indeed, the 	 * transmitter may be active, but if we haven't 	 * filled all the buffers with data then we still 	 * want to accept more. 	 */
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
return|return;
name|indicate_active
label|:
comment|/* 	 * The transmitter is active, and there are no room for 	 * more outgoing packets in the transmission buffer. 	 */
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Drop (skip) a packet from receive buffer in 86960 memory.  */
end_comment

begin_function
specifier|static
name|void
name|fe_droppacket
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 	 * 86960 manual says that we have to read 8 bytes from the buffer 	 * before skip the packets and that there must be more than 8 bytes 	 * remaining in the buffer when issue a skip command. 	 * Remember, we have already read 4 bytes before come here. 	 */
if|if
condition|(
name|len
operator|>
literal|12
condition|)
block|{
comment|/* Read 4 more bytes, and skip the rest of the packet.  */
if|if
condition|(
operator|(
name|sc
operator|->
name|proto_dlcr6
operator|&
name|FE_D6_SBW
operator|)
operator|==
name|FE_D6_SBW_BYTE
condition|)
block|{
operator|(
name|void
operator|)
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR8
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR8
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR8
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fe_inw
argument_list|(
name|sc
argument_list|,
name|FE_BMPR8
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fe_inw
argument_list|(
name|sc
argument_list|,
name|FE_BMPR8
argument_list|)
expr_stmt|;
block|}
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR14
argument_list|,
name|FE_B14_SKIP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We should not come here unless receiving RUNTs.  */
if|if
condition|(
operator|(
name|sc
operator|->
name|proto_dlcr6
operator|&
name|FE_D6_SBW
operator|)
operator|==
name|FE_D6_SBW_BYTE
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
literal|2
control|)
operator|(
name|void
operator|)
name|fe_inw
argument_list|(
name|sc
argument_list|,
name|FE_BMPR8
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DIAGNOSTIC
end_ifdef

begin_comment
comment|/*  * Empty receiving buffer.  */
end_comment

begin_function
specifier|static
name|void
name|fe_emptybuffer
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_char
name|saved_dlcr5
decl_stmt|;
ifdef|#
directive|ifdef
name|FE_DEBUG
name|printf
argument_list|(
literal|"fe%d: emptying receive buffer\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Stop receiving packets, temporarily. 	 */
name|saved_dlcr5
operator|=
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR5
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR5
argument_list|,
name|sc
operator|->
name|proto_dlcr5
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1300
argument_list|)
expr_stmt|;
comment|/* 	 * When we come here, the receive buffer management may 	 * have been broken.  So, we cannot use skip operation. 	 * Just discard everything in the buffer. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|proto_dlcr6
operator|&
name|FE_D6_SBW
operator|)
operator|==
name|FE_D6_SBW_BYTE
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|65536
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR5
argument_list|)
operator|&
name|FE_D5_BUFEMP
condition|)
break|break;
operator|(
name|void
operator|)
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR8
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|65536
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR5
argument_list|)
operator|&
name|FE_D5_BUFEMP
condition|)
break|break;
operator|(
name|void
operator|)
name|fe_inw
argument_list|(
name|sc
argument_list|,
name|FE_BMPR8
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Double check. 	 */
if|if
condition|(
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR5
argument_list|)
operator|&
name|FE_D5_BUFEMP
condition|)
block|{
name|printf
argument_list|(
literal|"fe%d: could not empty receive buffer\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
comment|/* Hmm.  What should I do if this happens?  FIXME.  */
block|}
comment|/* 	 * Restart receiving packets. 	 */
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR5
argument_list|,
name|saved_dlcr5
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Transmission interrupt handler  * The control flow of this function looks silly.  FIXME.  */
end_comment

begin_function
specifier|static
name|void
name|fe_tint
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|,
name|u_char
name|tstat
parameter_list|)
block|{
name|int
name|left
decl_stmt|;
name|int
name|col
decl_stmt|;
comment|/* 	 * Handle "excessive collision" interrupt. 	 */
if|if
condition|(
name|tstat
operator|&
name|FE_D0_COLL16
condition|)
block|{
comment|/* 		 * Find how many packets (including this collided one) 		 * are left unsent in transmission buffer. 		 */
name|left
operator|=
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR10
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"fe%d: excessive collision (%d/%d)\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|left
argument_list|,
name|sc
operator|->
name|txb_sched
argument_list|)
expr_stmt|;
comment|/* 		 * Clear the collision flag (in 86960) here 		 * to avoid confusing statistics. 		 */
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR0
argument_list|,
name|FE_D0_COLLID
argument_list|)
expr_stmt|;
comment|/* 		 * Restart transmitter, skipping the 		 * collided packet. 		 * 		 * We *must* skip the packet to keep network running 		 * properly.  Excessive collision error is an 		 * indication of the network overload.  If we 		 * tried sending the same packet after excessive 		 * collision, the network would be filled with 		 * out-of-time packets.  Packets belonging 		 * to reliable transport (such as TCP) are resent 		 * by some upper layer. 		 */
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR11
argument_list|,
name|FE_B11_CTRL_SKIP
operator||
name|FE_B11_MODE1
argument_list|)
expr_stmt|;
comment|/* Update statistics.  */
name|sc
operator|->
name|tx_excolls
operator|++
expr_stmt|;
block|}
comment|/* 	 * Handle "transmission complete" interrupt. 	 */
if|if
condition|(
name|tstat
operator|&
name|FE_D0_TXDONE
condition|)
block|{
comment|/* 		 * Add in total number of collisions on last 		 * transmission.  We also clear "collision occurred" flag 		 * here. 		 * 		 * 86960 has a design flaw on collision count on multiple 		 * packet transmission.  When we send two or more packets 		 * with one start command (that's what we do when the 		 * transmission queue is crowded), 86960 informs us number 		 * of collisions occurred on the last packet on the 		 * transmission only.  Number of collisions on previous 		 * packets are lost.  I have told that the fact is clearly 		 * stated in the Fujitsu document. 		 * 		 * I considered not to mind it seriously.  Collision 		 * count is not so important, anyway.  Any comments?  FIXME. 		 */
if|if
condition|(
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR0
argument_list|)
operator|&
name|FE_D0_COLLID
condition|)
block|{
comment|/* Clear collision flag.  */
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR0
argument_list|,
name|FE_D0_COLLID
argument_list|)
expr_stmt|;
comment|/* Extract collision count from 86960.  */
name|col
operator|=
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR4
argument_list|)
expr_stmt|;
name|col
operator|=
operator|(
name|col
operator|&
name|FE_D4_COL
operator|)
operator|>>
name|FE_D4_COL_SHIFT
expr_stmt|;
if|if
condition|(
name|col
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Status register indicates collisions, 				 * while the collision count is zero. 				 * This can happen after multiple packet 				 * transmission, indicating that one or more 				 * previous packet(s) had been collided. 				 * 				 * Since the accurate number of collisions 				 * has been lost, we just guess it as 1; 				 * Am I too optimistic?  FIXME. 				 */
name|col
operator|=
literal|1
expr_stmt|;
block|}
name|sc
operator|->
name|sc_if
operator|.
name|if_collisions
operator|+=
name|col
expr_stmt|;
if|if
condition|(
name|col
operator|==
literal|1
condition|)
name|sc
operator|->
name|mibdata
operator|.
name|dot3StatsSingleCollisionFrames
operator|++
expr_stmt|;
else|else
name|sc
operator|->
name|mibdata
operator|.
name|dot3StatsMultipleCollisionFrames
operator|++
expr_stmt|;
name|sc
operator|->
name|mibdata
operator|.
name|dot3StatsCollFrequencies
index|[
name|col
operator|-
literal|1
index|]
operator|++
expr_stmt|;
block|}
comment|/* 		 * Update transmission statistics. 		 * Be sure to reflect number of excessive collisions. 		 */
name|col
operator|=
name|sc
operator|->
name|tx_excolls
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_opackets
operator|+=
name|sc
operator|->
name|txb_sched
operator|-
name|col
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_oerrors
operator|+=
name|col
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_collisions
operator|+=
name|col
operator|*
literal|16
expr_stmt|;
name|sc
operator|->
name|mibdata
operator|.
name|dot3StatsExcessiveCollisions
operator|+=
name|col
expr_stmt|;
name|sc
operator|->
name|mibdata
operator|.
name|dot3StatsCollFrequencies
index|[
literal|15
index|]
operator|+=
name|col
expr_stmt|;
name|sc
operator|->
name|txb_sched
operator|=
literal|0
expr_stmt|;
comment|/* 		 * The transmitter is no more active. 		 * Reset output active flag and watchdog timer. 		 */
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_timer
operator|=
literal|0
expr_stmt|;
comment|/* 		 * If more data is ready to transmit in the buffer, start 		 * transmitting them.  Otherwise keep transmitter idle, 		 * even if more data is queued.  This gives receive 		 * process a slight priority. 		 */
if|if
condition|(
name|sc
operator|->
name|txb_count
operator|>
literal|0
condition|)
name|fe_xmit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Ethernet interface receiver interrupt.  */
end_comment

begin_function
specifier|static
name|void
name|fe_rint
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|,
name|u_char
name|rstat
parameter_list|)
block|{
name|u_short
name|len
decl_stmt|;
name|u_char
name|status
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Update statistics if this interrupt is caused by an error. 	 * Note that, when the system was not sufficiently fast, the 	 * receive interrupt might not be acknowledged immediately.  If 	 * one or more errornous frames were received before this routine 	 * was scheduled, they are ignored, and the following error stats 	 * give less than real values. 	 */
if|if
condition|(
name|rstat
operator|&
operator|(
name|FE_D1_OVRFLO
operator||
name|FE_D1_CRCERR
operator||
name|FE_D1_ALGERR
operator||
name|FE_D1_SRTPKT
operator|)
condition|)
block|{
if|if
condition|(
name|rstat
operator|&
name|FE_D1_OVRFLO
condition|)
name|sc
operator|->
name|mibdata
operator|.
name|dot3StatsInternalMacReceiveErrors
operator|++
expr_stmt|;
if|if
condition|(
name|rstat
operator|&
name|FE_D1_CRCERR
condition|)
name|sc
operator|->
name|mibdata
operator|.
name|dot3StatsFCSErrors
operator|++
expr_stmt|;
if|if
condition|(
name|rstat
operator|&
name|FE_D1_ALGERR
condition|)
name|sc
operator|->
name|mibdata
operator|.
name|dot3StatsAlignmentErrors
operator|++
expr_stmt|;
if|#
directive|if
literal|0
comment|/* The reference MAC receiver defined in 802.3 		   silently ignores short frames (RUNTs) without 		   notifying upper layer.  RFC 1650 (dot3 MIB) is 		   based on the 802.3, and it has no stats entry for 		   RUNTs...  */
block|if (rstat& FE_D1_SRTPKT) 			sc->mibdata.dot3StatsFrameTooShorts++;
comment|/* :-) */
endif|#
directive|endif
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
block|}
comment|/* 	 * MB86960 has a flag indicating "receive queue empty." 	 * We just loop, checking the flag, to pull out all received 	 * packets. 	 * 	 * We limit the number of iterations to avoid infinite-loop. 	 * The upper bound is set to unrealistic high value. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FE_MAX_RECV_COUNT
operator|*
literal|2
condition|;
name|i
operator|++
control|)
block|{
comment|/* Stop the iteration if 86960 indicates no packets.  */
if|if
condition|(
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR5
argument_list|)
operator|&
name|FE_D5_BUFEMP
condition|)
return|return;
comment|/* 		 * Extract a receive status byte. 		 * As our 86960 is in 16 bit bus access mode, we have to 		 * use inw() to get the status byte.  The significant 		 * value is returned in lower 8 bits. 		 */
if|if
condition|(
operator|(
name|sc
operator|->
name|proto_dlcr6
operator|&
name|FE_D6_SBW
operator|)
operator|==
name|FE_D6_SBW_BYTE
condition|)
block|{
name|status
operator|=
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR8
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
operator|(
name|u_char
operator|)
name|fe_inw
argument_list|(
name|sc
argument_list|,
name|FE_BMPR8
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Extract the packet length. 		 * It is a sum of a header (14 bytes) and a payload. 		 * CRC has been stripped off by the 86960. 		 */
if|if
condition|(
operator|(
name|sc
operator|->
name|proto_dlcr6
operator|&
name|FE_D6_SBW
operator|)
operator|==
name|FE_D6_SBW_BYTE
condition|)
block|{
name|len
operator|=
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR8
argument_list|)
expr_stmt|;
name|len
operator||=
operator|(
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR8
argument_list|)
operator|<<
literal|8
operator|)
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|fe_inw
argument_list|(
name|sc
argument_list|,
name|FE_BMPR8
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * AS our 86960 is programed to ignore errored frame, 		 * we must not see any error indication in the 		 * receive buffer.  So, any error condition is a 		 * serious error, e.g., out-of-sync of the receive 		 * buffer pointers. 		 */
if|if
condition|(
operator|(
name|status
operator|&
literal|0xF0
operator|)
operator|!=
literal|0x20
operator|||
name|len
operator|>
name|ETHER_MAX_LEN
operator|-
name|ETHER_CRC_LEN
operator|||
name|len
operator|<
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
condition|)
block|{
name|printf
argument_list|(
literal|"fe%d: RX buffer out-of-sync\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
name|sc
operator|->
name|mibdata
operator|.
name|dot3StatsInternalMacReceiveErrors
operator|++
expr_stmt|;
name|fe_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * Go get a packet. 		 */
if|if
condition|(
name|fe_get_packet
argument_list|(
name|sc
argument_list|,
name|len
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* 			 * Negative return from fe_get_packet() 			 * indicates no available mbuf.  We stop 			 * receiving packets, even if there are more 			 * in the buffer.  We hope we can get more 			 * mbuf next time. 			 */
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
name|sc
operator|->
name|mibdata
operator|.
name|dot3StatsMissedFrames
operator|++
expr_stmt|;
name|fe_droppacket
argument_list|(
name|sc
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Successfully received a packet.  Update stat.  */
name|sc
operator|->
name|sc_if
operator|.
name|if_ipackets
operator|++
expr_stmt|;
block|}
comment|/* Maximum number of frames has been received.  Something            strange is happening here... */
name|printf
argument_list|(
literal|"fe%d: unusual receive flood\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mibdata
operator|.
name|dot3StatsInternalMacReceiveErrors
operator|++
expr_stmt|;
name|fe_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Ethernet interface interrupt processor  */
end_comment

begin_function
specifier|static
name|void
name|fe_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|u_char
name|tstat
decl_stmt|,
name|rstat
decl_stmt|;
name|int
name|loop_count
init|=
name|FE_MAX_LOOP
decl_stmt|;
comment|/* Loop until there are no more new interrupt conditions.  */
while|while
condition|(
name|loop_count
operator|--
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Get interrupt conditions, masking unneeded flags. 		 */
name|tstat
operator|=
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR0
argument_list|)
operator|&
name|FE_TMASK
expr_stmt|;
name|rstat
operator|=
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR1
argument_list|)
operator|&
name|FE_RMASK
expr_stmt|;
if|if
condition|(
name|tstat
operator|==
literal|0
operator|&&
name|rstat
operator|==
literal|0
condition|)
return|return;
comment|/* 		 * Reset the conditions we are acknowledging. 		 */
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR0
argument_list|,
name|tstat
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR1
argument_list|,
name|rstat
argument_list|)
expr_stmt|;
comment|/* 		 * Handle transmitter interrupts. 		 */
if|if
condition|(
name|tstat
condition|)
name|fe_tint
argument_list|(
name|sc
argument_list|,
name|tstat
argument_list|)
expr_stmt|;
comment|/* 		 * Handle receiver interrupts 		 */
if|if
condition|(
name|rstat
condition|)
name|fe_rint
argument_list|(
name|sc
argument_list|,
name|rstat
argument_list|)
expr_stmt|;
comment|/* 		 * Update the multicast address filter if it is 		 * needed and possible.  We do it now, because 		 * we can make sure the transmission buffer is empty, 		 * and there is a good chance that the receive queue 		 * is empty.  It will minimize the possibility of 		 * packet loss. 		 */
if|if
condition|(
name|sc
operator|->
name|filter_change
operator|&&
name|sc
operator|->
name|txb_count
operator|==
literal|0
operator|&&
name|sc
operator|->
name|txb_sched
operator|==
literal|0
condition|)
block|{
name|fe_loadmar
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
block|}
comment|/* 		 * If it looks like the transmitter can take more data, 		 * attempt to start output on the interface. This is done 		 * after handling the receiver interrupt to give the 		 * receive operation priority. 		 * 		 * BTW, I'm not sure in what case the OACTIVE is on at 		 * this point.  Is the following test redundant? 		 * 		 * No.  This routine polls for both transmitter and 		 * receiver interrupts.  86960 can raise a receiver 		 * interrupt when the transmission buffer is full. 		 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_OACTIVE
operator|)
operator|==
literal|0
condition|)
name|fe_start
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"fe%d: too many loops\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process an ioctl request. This code needs some work - it looks  * pretty ugly.  */
end_comment

begin_function
specifier|static
name|int
name|fe_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
case|case
name|SIOCSIFMTU
case|:
comment|/* Just an ordinary action.  */
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
comment|/* 		 * Switch interface state between "running" and 		 * "stopped", reflecting the UP flag. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
name|fe_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|!=
literal|0
condition|)
name|fe_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Promiscuous and/or multicast flags may have changed, 		 * so reprogram the multicast filter and/or receive mode. 		 */
name|fe_setmode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Done.  */
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
comment|/* 		 * Multicast list has changed; set the hardware filter 		 * accordingly. 		 */
name|fe_setmode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
comment|/* Let if_media to handle these commands and to call 		   us back.  */
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|media
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Retrieve packet from receive buffer and send to the next level up via  * ether_input().  * Returns 0 if success, -1 if error (i.e., mbuf allocation failure).  */
end_comment

begin_function
specifier|static
name|int
name|fe_get_packet
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|,
name|u_short
name|len
parameter_list|)
block|{
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* 	 * NFS wants the data be aligned to the word (4 byte) 	 * boundary.  Ethernet header has 14 bytes.  There is a 	 * 2-byte gap. 	 */
define|#
directive|define
name|NFS_MAGIC_OFFSET
value|2
comment|/* 	 * This function assumes that an Ethernet packet fits in an 	 * mbuf (with a cluster attached when necessary.)  On FreeBSD 	 * 2.0 for x86, which is the primary target of this driver, an 	 * mbuf cluster has 4096 bytes, and we are happy.  On ancient 	 * BSDs, such as vanilla 4.3 for 386, a cluster size was 1024, 	 * however.  If the following #error message were printed upon 	 * compile, you need to rewrite this function. 	 */
if|#
directive|if
operator|(
name|MCLBYTES
operator|<
name|ETHER_MAX_LEN
operator|-
name|ETHER_CRC_LEN
operator|+
name|NFS_MAGIC_OFFSET
operator|)
error|#
directive|error
literal|"Too small MCLBYTES to use fe driver."
endif|#
directive|endif
comment|/* 	 * Our strategy has one more problem.  There is a policy on 	 * mbuf cluster allocation.  It says that we must have at 	 * least MINCLSIZE (208 bytes on FreeBSD 2.0 for x86) to 	 * allocate a cluster.  For a packet of a size between 	 * (MHLEN - 2) to (MINCLSIZE - 2), our code violates the rule... 	 * On the other hand, the current code is short, simple, 	 * and fast, however.  It does no harmful thing, just waists 	 * some memory.  Any comments?  FIXME. 	 */
comment|/* Allocate an mbuf with packet header info.  */
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Attach a cluster if this packet doesn't fit in a normal mbuf.  */
if|if
condition|(
name|len
operator|>
name|MHLEN
operator|-
name|NFS_MAGIC_OFFSET
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* Initialize packet header info.  */
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|&
name|sc
operator|->
name|sc_if
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
comment|/* Set the length of this packet.  */
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
comment|/* The following silliness is to make NFS happy */
name|m
operator|->
name|m_data
operator|+=
name|NFS_MAGIC_OFFSET
expr_stmt|;
comment|/* Get (actually just point to) the header part.  */
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
comment|/* Get a packet.  */
if|if
condition|(
operator|(
name|sc
operator|->
name|proto_dlcr6
operator|&
name|FE_D6_SBW
operator|)
operator|==
name|FE_D6_SBW_BYTE
condition|)
block|{
name|fe_insb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR8
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|eh
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fe_insw
argument_list|(
name|sc
argument_list|,
name|FE_BMPR8
argument_list|,
operator|(
name|u_int16_t
operator|*
operator|)
name|eh
argument_list|,
operator|(
name|len
operator|+
literal|1
operator|)
operator|>>
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Strip off the Ethernet header.  */
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
comment|/* Feed the packet to upper layer.  */
name|ether_input
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|,
name|eh
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Write an mbuf chain to the transmission buffer memory using 16 bit PIO.  * Returns number of bytes actually written, including length word.  *  * If an mbuf chain is too long for an Ethernet frame, it is not sent.  * Packets shorter than Ethernet minimum are legal, and we pad them  * before sending out.  An exception is "partial" packets which are  * shorter than mandatory Ethernet header.  */
end_comment

begin_function
specifier|static
name|void
name|fe_write_mbufs
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|u_short
name|length
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|;
name|u_char
modifier|*
name|data
decl_stmt|;
name|u_short
name|savebyte
decl_stmt|;
comment|/* WARNING: Architecture dependent!  */
define|#
directive|define
name|NO_PENDING_BYTE
value|0xFFFF
specifier|static
name|u_char
name|padding
index|[
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
operator|-
name|ETHER_HDR_LEN
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
comment|/* First, count up the total number of bytes to copy */
name|length
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|m
init|;
name|mp
operator|!=
name|NULL
condition|;
name|mp
operator|=
name|mp
operator|->
name|m_next
control|)
name|length
operator|+=
name|mp
operator|->
name|m_len
expr_stmt|;
comment|/* Check if this matches the one in the packet header.  */
if|if
condition|(
name|length
operator|!=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
block|{
name|printf
argument_list|(
literal|"fe%d: packet length mismatch? (%d/%d)\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|length
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* Just use the length value in the packet header.  */
name|length
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DIAGNOSTIC
comment|/* 	 * Should never send big packets.  If such a packet is passed, 	 * it should be a bug of upper layer.  We just ignore it. 	 * ... Partial (too short) packets, neither. 	 */
if|if
condition|(
name|length
operator|<
name|ETHER_HDR_LEN
operator|||
name|length
operator|>
name|ETHER_MAX_LEN
operator|-
name|ETHER_CRC_LEN
condition|)
block|{
name|printf
argument_list|(
literal|"fe%d: got an out-of-spec packet (%u bytes) to send\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
name|sc
operator|->
name|mibdata
operator|.
name|dot3StatsInternalMacTransmitErrors
operator|++
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* 	 * Put the length word for this frame. 	 * Does 86960 accept odd length?  -- Yes. 	 * Do we need to pad the length to minimum size by ourselves? 	 * -- Generally yes.  But for (or will be) the last 	 * packet in the transmission buffer, we can skip the 	 * padding process.  It may gain performance slightly.  FIXME. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|proto_dlcr6
operator|&
name|FE_D6_SBW
operator|)
operator|==
name|FE_D6_SBW_BYTE
condition|)
block|{
name|len
operator|=
name|max
argument_list|(
name|length
argument_list|,
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR8
argument_list|,
name|len
operator|&
literal|0x00ff
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR8
argument_list|,
operator|(
name|len
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fe_outw
argument_list|(
name|sc
argument_list|,
name|FE_BMPR8
argument_list|,
name|max
argument_list|(
name|length
argument_list|,
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Update buffer status now. 	 * Truncate the length up to an even number, since we use outw(). 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|proto_dlcr6
operator|&
name|FE_D6_SBW
operator|)
operator|!=
name|FE_D6_SBW_BYTE
condition|)
block|{
name|length
operator|=
operator|(
name|length
operator|+
literal|1
operator|)
operator|&
operator|~
literal|1
expr_stmt|;
block|}
name|sc
operator|->
name|txb_free
operator|-=
name|FE_DATA_LEN_LEN
operator|+
name|max
argument_list|(
name|length
argument_list|,
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
argument_list|)
expr_stmt|;
name|sc
operator|->
name|txb_count
operator|++
expr_stmt|;
comment|/* 	 * Transfer the data from mbuf chain to the transmission buffer. 	 * MB86960 seems to require that data be transferred as words, and 	 * only words.  So that we require some extra code to patch 	 * over odd-length mbufs. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|proto_dlcr6
operator|&
name|FE_D6_SBW
operator|)
operator|==
name|FE_D6_SBW_BYTE
condition|)
block|{
comment|/* 8-bit cards are easy.  */
for|for
control|(
name|mp
operator|=
name|m
init|;
name|mp
operator|!=
literal|0
condition|;
name|mp
operator|=
name|mp
operator|->
name|m_next
control|)
block|{
if|if
condition|(
name|mp
operator|->
name|m_len
condition|)
name|fe_outsb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR8
argument_list|,
name|mtod
argument_list|(
name|mp
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|mp
operator|->
name|m_len
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 16-bit cards are a pain.  */
name|savebyte
operator|=
name|NO_PENDING_BYTE
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|m
init|;
name|mp
operator|!=
literal|0
condition|;
name|mp
operator|=
name|mp
operator|->
name|m_next
control|)
block|{
comment|/* Ignore empty mbuf.  */
name|len
operator|=
name|mp
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
continue|continue;
comment|/* Find the actual data to send.  */
name|data
operator|=
name|mtod
argument_list|(
name|mp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
comment|/* Finish the last byte.  */
if|if
condition|(
name|savebyte
operator|!=
name|NO_PENDING_BYTE
condition|)
block|{
name|fe_outw
argument_list|(
name|sc
argument_list|,
name|FE_BMPR8
argument_list|,
name|savebyte
operator||
operator|(
operator|*
name|data
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|data
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
name|savebyte
operator|=
name|NO_PENDING_BYTE
expr_stmt|;
block|}
comment|/* output contiguous words */
if|if
condition|(
name|len
operator|>
literal|1
condition|)
block|{
name|fe_outsw
argument_list|(
name|sc
argument_list|,
name|FE_BMPR8
argument_list|,
operator|(
name|u_int16_t
operator|*
operator|)
name|data
argument_list|,
name|len
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|data
operator|+=
name|len
operator|&
operator|~
literal|1
expr_stmt|;
name|len
operator|&=
literal|1
expr_stmt|;
block|}
comment|/* Save a remaining byte, if there is one.  */
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|savebyte
operator|=
operator|*
name|data
expr_stmt|;
block|}
comment|/* Spit the last byte, if the length is odd.  */
if|if
condition|(
name|savebyte
operator|!=
name|NO_PENDING_BYTE
condition|)
name|fe_outw
argument_list|(
name|sc
argument_list|,
name|FE_BMPR8
argument_list|,
name|savebyte
argument_list|)
expr_stmt|;
block|}
comment|/* Pad to the Ethernet minimum length, if the packet is too short.  */
if|if
condition|(
name|length
operator|<
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|proto_dlcr6
operator|&
name|FE_D6_SBW
operator|)
operator|==
name|FE_D6_SBW_BYTE
condition|)
block|{
name|fe_outsb
argument_list|(
name|sc
argument_list|,
name|FE_BMPR8
argument_list|,
name|padding
argument_list|,
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
operator|-
name|length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fe_outsw
argument_list|(
name|sc
argument_list|,
name|FE_BMPR8
argument_list|,
operator|(
name|u_int16_t
operator|*
operator|)
name|padding
argument_list|,
operator|(
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
operator|-
name|length
operator|)
operator|>>
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Compute hash value for an Ethernet address  */
end_comment

begin_function
specifier|static
name|int
name|fe_hash
parameter_list|(
name|u_char
modifier|*
name|ep
parameter_list|)
block|{
define|#
directive|define
name|FE_HASH_MAGIC_NUMBER
value|0xEDB88320L
name|u_long
name|hash
init|=
literal|0xFFFFFFFFL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|u_char
name|b
decl_stmt|;
name|u_long
name|m
decl_stmt|;
for|for
control|(
name|i
operator|=
name|ETHER_ADDR_LEN
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
name|b
operator|=
operator|*
name|ep
operator|++
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|8
init|;
operator|--
name|j
operator|>=
literal|0
condition|;
control|)
block|{
name|m
operator|=
name|hash
expr_stmt|;
name|hash
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|^
name|b
operator|)
operator|&
literal|1
condition|)
name|hash
operator|^=
name|FE_HASH_MAGIC_NUMBER
expr_stmt|;
name|b
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
call|(
name|int
call|)
argument_list|(
name|hash
operator|>>
literal|26
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compute the multicast address filter from the  * list of multicast addresses we need to listen to.  */
end_comment

begin_function
specifier|static
name|struct
name|fe_filter
name|fe_mcaf
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|index
decl_stmt|;
name|struct
name|fe_filter
name|filter
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|filter
operator|=
name|fe_filter_nothing
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&sc->arpcom.ac_if.if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|index
operator|=
name|fe_hash
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FE_DEBUG
name|printf
argument_list|(
literal|"fe%d: hash(%6D) == %d\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|enm
operator|->
name|enm_addrlo
argument_list|,
literal|":"
argument_list|,
name|index
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|filter
operator|.
name|data
index|[
name|index
operator|>>
literal|3
index|]
operator||=
literal|1
operator|<<
operator|(
name|index
operator|&
literal|7
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|filter
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate a new "multicast packet filter" and put the 86960  * receiver in appropriate mode.  */
end_comment

begin_function
specifier|static
name|void
name|fe_setmode
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|flags
init|=
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
decl_stmt|;
comment|/* 	 * If the interface is not running, we postpone the update 	 * process for receive modes and multicast address filter 	 * until the interface is restarted.  It reduces some 	 * complicated job on maintaining chip states.  (Earlier versions 	 * of this driver had a bug on that point...) 	 * 	 * To complete the trick, fe_init() calls fe_setmode() after 	 * restarting the interface. 	 */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
return|return;
comment|/* 	 * Promiscuous mode is handled separately. 	 */
if|if
condition|(
name|flags
operator|&
name|IFF_PROMISC
condition|)
block|{
comment|/* 		 * Program 86960 to receive all packets on the segment 		 * including those directed to other stations. 		 * Multicast filter stored in MARs are ignored 		 * under this setting, so we don't need to update it. 		 * 		 * Promiscuous mode in FreeBSD 2 is used solely by 		 * BPF, and BPF only listens to valid (no error) packets. 		 * So, we ignore erroneous ones even in this mode. 		 * (Older versions of fe driver mistook the point.) 		 */
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR5
argument_list|,
name|sc
operator|->
name|proto_dlcr5
operator||
name|FE_D5_AFM0
operator||
name|FE_D5_AFM1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|filter_change
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* 	 * Turn the chip to the normal (non-promiscuous) mode. 	 */
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR5
argument_list|,
name|sc
operator|->
name|proto_dlcr5
operator||
name|FE_D5_AFM1
argument_list|)
expr_stmt|;
comment|/* 	 * Find the new multicast filter value. 	 */
if|if
condition|(
name|flags
operator|&
name|IFF_ALLMULTI
condition|)
name|sc
operator|->
name|filter
operator|=
name|fe_filter_all
expr_stmt|;
else|else
name|sc
operator|->
name|filter
operator|=
name|fe_mcaf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|filter_change
operator|=
literal|1
expr_stmt|;
comment|/* 	 * We have to update the multicast filter in the 86960, A.S.A.P. 	 * 	 * Note that the DLC (Data Link Control unit, i.e. transmitter 	 * and receiver) must be stopped when feeding the filter, and 	 * DLC trashes all packets in both transmission and receive 	 * buffers when stopped. 	 * 	 * To reduce the packet loss, we delay the filter update 	 * process until buffers are empty. 	 */
if|if
condition|(
name|sc
operator|->
name|txb_sched
operator|==
literal|0
operator|&&
name|sc
operator|->
name|txb_count
operator|==
literal|0
operator|&&
operator|!
operator|(
name|fe_inb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR1
argument_list|)
operator|&
name|FE_D1_PKTRDY
operator|)
condition|)
block|{
comment|/* 		 * Buffers are (apparently) empty.  Load 		 * the new filter value into MARs now. 		 */
name|fe_loadmar
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Buffers are not empty.  Mark that we have to update 		 * the MARs.  The new filter will be loaded by feintr() 		 * later. 		 */
block|}
block|}
end_function

begin_comment
comment|/*  * Load a new multicast address filter into MARs.  *  * The caller must have splimp'ed before fe_loadmar.  * This function starts the DLC upon return.  So it can be called only  * when the chip is working, i.e., from the driver's point of view, when  * a device is RUNNING.  (I mistook the point in previous versions.)  */
end_comment

begin_function
specifier|static
name|void
name|fe_loadmar
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Stop the DLC (transmitter and receiver).  */
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR6
argument_list|,
name|sc
operator|->
name|proto_dlcr6
operator||
name|FE_D6_DLC_DISABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* Select register bank 1 for MARs.  */
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR7
argument_list|,
name|sc
operator|->
name|proto_dlcr7
operator||
name|FE_D7_RBS_MAR
operator||
name|FE_D7_POWER_UP
argument_list|)
expr_stmt|;
comment|/* Copy filter value into the registers.  */
name|fe_outblk
argument_list|(
name|sc
argument_list|,
name|FE_MAR8
argument_list|,
name|sc
operator|->
name|filter
operator|.
name|data
argument_list|,
name|FE_FILTER_LEN
argument_list|)
expr_stmt|;
comment|/* Restore the bank selection for BMPRs (i.e., runtime registers).  */
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR7
argument_list|,
name|sc
operator|->
name|proto_dlcr7
operator||
name|FE_D7_RBS_BMPR
operator||
name|FE_D7_POWER_UP
argument_list|)
expr_stmt|;
comment|/* Restart the DLC.  */
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|fe_outb
argument_list|(
name|sc
argument_list|,
name|FE_DLCR6
argument_list|,
name|sc
operator|->
name|proto_dlcr6
operator||
name|FE_D6_DLC_ENABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* We have just updated the filter.  */
name|sc
operator|->
name|filter_change
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Change the media selection.  */
end_comment

begin_function
specifier|static
name|int
name|fe_medchange
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|fe_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
comment|/* If_media should not pass any request for a media which this 	   interface doesn't support.  */
name|int
name|b
decl_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|bit2media
index|[
name|b
index|]
operator|!=
literal|0
condition|;
name|b
operator|++
control|)
block|{
if|if
condition|(
name|bit2media
index|[
name|b
index|]
operator|==
name|sc
operator|->
name|media
operator|.
name|ifm_media
condition|)
break|break;
block|}
if|if
condition|(
operator|(
operator|(
literal|1
operator|<<
name|b
operator|)
operator|&
name|sc
operator|->
name|mbitmap
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"fe%d: got an unsupported media request (0x%x)\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|sc
operator|->
name|media
operator|.
name|ifm_media
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
endif|#
directive|endif
comment|/* We don't actually change media when the interface is down. 	   fe_init() will do the job, instead.  Should we also wait 	   until the transmission buffer being empty?  Changing the 	   media when we are sending a frame will cause two garbages 	   on wires, one on old media and another on new.  FIXME */
if|if
condition|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|msel
condition|)
name|sc
operator|->
name|msel
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* I don't know how I can support media status callback... FIXME.  */
end_comment

begin_function
specifier|static
name|void
name|fe_medstat
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
operator|(
name|void
operator|)
name|ifp
expr_stmt|;
operator|(
name|void
operator|)
name|ifmr
expr_stmt|;
block|}
end_function

end_unit

