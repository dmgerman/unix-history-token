begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************************  Copyright (c) 2007, Chelsio Inc. All rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:   1. Redistributions of source code must retain the above copyright notice,     this list of conditions and the following disclaimer.   2. Neither the name of the Chelsio Corporation nor the names of its     contributors may be used to endorse or promote products derived from     this software without specific prior written permission.   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_DEFINED
end_ifdef

begin_include
include|#
directive|include
file|<cxgb_include.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<dev/cxgb/cxgb_include.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|VLAN_NONE
value|0xfff
end_define

begin_define
define|#
directive|define
name|SDL
parameter_list|(
name|s
parameter_list|)
value|((struct sockaddr_dl *)s)
end_define

begin_define
define|#
directive|define
name|RT_ENADDR
parameter_list|(
name|rt
parameter_list|)
value|((char *)LLADDR(SDL((rt))))
end_define

begin_define
define|#
directive|define
name|rt_expire
value|rt_rmx.rmx_expire
end_define

begin_struct
struct|struct
name|llinfo_arp
block|{
name|struct
name|callout
name|la_timer
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|la_rt
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|la_hold
decl_stmt|;
comment|/* last packet until resolved/timeout */
name|u_short
name|la_preempt
decl_stmt|;
comment|/* countdown for pre-expiry arps */
name|u_short
name|la_asked
decl_stmt|;
comment|/* # requests sent */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Module locking notes:  There is a RW lock protecting the L2 table as a  * whole plus a spinlock per L2T entry.  Entry lookups and allocations happen  * under the protection of the table lock, individual entry changes happen  * while holding that entry's spinlock.  The table lock nests outside the  * entry locks.  Allocations of new entries take the table lock as writers so  * no other lookups can happen while allocating new entries.  Entry updates  * take the table lock as readers so multiple entries can be updated in  * parallel.  An L2T entry can be dropped by decrementing its reference count  * and therefore can happen in parallel with entry allocation but no entry  * can change state or increment its ref count during allocation as both of  * these perform lookups.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|int
name|vlan_prio
parameter_list|(
specifier|const
name|struct
name|l2t_entry
modifier|*
name|e
parameter_list|)
block|{
return|return
name|e
operator|->
name|vlan
operator|>>
literal|13
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|int
name|arp_hash
parameter_list|(
name|u32
name|key
parameter_list|,
name|int
name|ifindex
parameter_list|,
specifier|const
name|struct
name|l2t_data
modifier|*
name|d
parameter_list|)
block|{
return|return
name|jhash_2words
argument_list|(
name|key
argument_list|,
name|ifindex
argument_list|,
literal|0
argument_list|)
operator|&
operator|(
name|d
operator|->
name|nentries
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|neigh_replace
parameter_list|(
name|struct
name|l2t_entry
modifier|*
name|e
parameter_list|,
name|struct
name|rtentry
modifier|*
name|rt
parameter_list|)
block|{
name|RT_LOCK
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|RT_ADDREF
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|RT_UNLOCK
argument_list|(
name|rt
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|neigh
condition|)
block|{
name|RT_LOCK
argument_list|(
name|e
operator|->
name|neigh
argument_list|)
expr_stmt|;
name|RT_REMREF
argument_list|(
name|e
operator|->
name|neigh
argument_list|)
expr_stmt|;
name|RT_UNLOCK
argument_list|(
name|e
operator|->
name|neigh
argument_list|)
expr_stmt|;
block|}
name|e
operator|->
name|neigh
operator|=
name|rt
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set up an L2T entry and send any packets waiting in the arp queue.  The  * supplied mbuf is used for the CPL_L2T_WRITE_REQ.  Must be called with the  * entry locked.  */
end_comment

begin_function
specifier|static
name|int
name|setup_l2e_send_pending
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|l2t_entry
modifier|*
name|e
parameter_list|)
block|{
name|struct
name|cpl_l2t_write_req
modifier|*
name|req
decl_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* 	 * XXX MH_ALIGN 	 */
name|req
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|cpl_l2t_write_req
operator|*
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wr_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_FORWARD
argument_list|)
argument_list|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|req
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_L2T_WRITE_REQ
argument_list|,
name|e
operator|->
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|params
operator|=
name|htonl
argument_list|(
name|V_L2T_W_IDX
argument_list|(
name|e
operator|->
name|idx
argument_list|)
operator||
name|V_L2T_W_IFF
argument_list|(
name|e
operator|->
name|smt_idx
argument_list|)
operator||
name|V_L2T_W_VLAN
argument_list|(
name|e
operator|->
name|vlan
operator|&
name|EVL_VLID_MASK
argument_list|)
operator||
name|V_L2T_W_PRIO
argument_list|(
name|vlan_prio
argument_list|(
name|e
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|e
operator|->
name|dmac
argument_list|,
name|RT_ENADDR
argument_list|(
name|e
operator|->
name|neigh
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|e
operator|->
name|dmac
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|req
operator|->
name|dst_mac
argument_list|,
name|e
operator|->
name|dmac
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|dst_mac
argument_list|)
argument_list|)
expr_stmt|;
name|m_set_priority
argument_list|(
name|m
argument_list|,
name|CPL_PRIORITY_CONTROL
argument_list|)
expr_stmt|;
name|cxgb_ofld_send
argument_list|(
name|dev
argument_list|,
name|m
argument_list|)
expr_stmt|;
while|while
condition|(
name|e
operator|->
name|arpq_head
condition|)
block|{
name|m
operator|=
name|e
operator|->
name|arpq_head
expr_stmt|;
name|e
operator|->
name|arpq_head
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|cxgb_ofld_send
argument_list|(
name|dev
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|e
operator|->
name|arpq_tail
operator|=
name|NULL
expr_stmt|;
name|e
operator|->
name|state
operator|=
name|L2T_STATE_VALID
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Add a packet to the an L2T entry's queue of packets awaiting resolution.  * Must be called with the entry's lock held.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|arpq_enqueue
parameter_list|(
name|struct
name|l2t_entry
modifier|*
name|e
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|arpq_head
condition|)
name|e
operator|->
name|arpq_tail
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
else|else
name|e
operator|->
name|arpq_head
operator|=
name|m
expr_stmt|;
name|e
operator|->
name|arpq_tail
operator|=
name|m
expr_stmt|;
block|}
end_function

begin_function
name|int
name|t3_l2t_send_slow
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|l2t_entry
modifier|*
name|e
parameter_list|)
block|{
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
if|if
condition|(
operator|(
name|m0
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|rt
operator|=
name|e
operator|->
name|neigh
expr_stmt|;
name|again
label|:
switch|switch
condition|(
name|e
operator|->
name|state
condition|)
block|{
case|case
name|L2T_STATE_STALE
case|:
comment|/* entry is stale, kick off revalidation */
name|arpresolve
argument_list|(
name|rt
operator|->
name|rt_ifp
argument_list|,
name|rt
argument_list|,
name|m0
argument_list|,
name|rt
operator|->
name|rt_gateway
argument_list|,
name|RT_ENADDR
argument_list|(
name|rt
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|state
operator|==
name|L2T_STATE_STALE
condition|)
name|e
operator|->
name|state
operator|=
name|L2T_STATE_VALID
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
case|case
name|L2T_STATE_VALID
case|:
comment|/* fast-path, send the packet on */
return|return
name|cxgb_ofld_send
argument_list|(
name|dev
argument_list|,
name|m
argument_list|)
return|;
case|case
name|L2T_STATE_RESOLVING
case|:
name|mtx_lock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|state
operator|!=
name|L2T_STATE_RESOLVING
condition|)
block|{
comment|// ARP already completed
name|mtx_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|arpq_enqueue
argument_list|(
name|e
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m0
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* 		 * Only the first packet added to the arpq should kick off 		 * resolution.  However, because the m_gethdr below can fail, 		 * we allow each packet added to the arpq to retry resolution 		 * as a way of recovering from transient memory exhaustion. 		 * A better way would be to use a work request to retry L2T 		 * entries when there's no memory. 		 */
if|if
condition|(
name|arpresolve
argument_list|(
name|rt
operator|->
name|rt_ifp
argument_list|,
name|rt
argument_list|,
name|m0
argument_list|,
name|rt
operator|->
name|rt_gateway
argument_list|,
name|RT_ENADDR
argument_list|(
name|rt
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|arpq_head
condition|)
name|setup_l2e_send_pending
argument_list|(
name|dev
argument_list|,
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
else|else
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|t3_l2t_send_event
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|,
name|struct
name|l2t_entry
modifier|*
name|e
parameter_list|)
block|{
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
if|if
condition|(
operator|(
name|m0
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|rt
operator|=
name|e
operator|->
name|neigh
expr_stmt|;
name|again
label|:
switch|switch
condition|(
name|e
operator|->
name|state
condition|)
block|{
case|case
name|L2T_STATE_STALE
case|:
comment|/* entry is stale, kick off revalidation */
name|arpresolve
argument_list|(
name|rt
operator|->
name|rt_ifp
argument_list|,
name|rt
argument_list|,
name|m0
argument_list|,
name|rt
operator|->
name|rt_gateway
argument_list|,
name|RT_ENADDR
argument_list|(
name|rt
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|state
operator|==
name|L2T_STATE_STALE
condition|)
block|{
name|e
operator|->
name|state
operator|=
name|L2T_STATE_VALID
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return;
case|case
name|L2T_STATE_VALID
case|:
comment|/* fast-path, send the packet on */
return|return;
case|case
name|L2T_STATE_RESOLVING
case|:
name|mtx_lock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|state
operator|!=
name|L2T_STATE_RESOLVING
condition|)
block|{
comment|// ARP already completed
name|mtx_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m0
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
comment|/* 		 * Only the first packet added to the arpq should kick off 		 * resolution.  However, because the alloc_skb below can fail, 		 * we allow each packet added to the arpq to retry resolution 		 * as a way of recovering from transient memory exhaustion. 		 * A better way would be to use a work request to retry L2T 		 * entries when there's no memory. 		 */
name|arpresolve
argument_list|(
name|rt
operator|->
name|rt_ifp
argument_list|,
name|rt
argument_list|,
name|m0
argument_list|,
name|rt
operator|->
name|rt_gateway
argument_list|,
name|RT_ENADDR
argument_list|(
name|rt
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Allocate a free L2T entry.  Must be called with l2t_data.lock held.  */
end_comment

begin_function
specifier|static
name|struct
name|l2t_entry
modifier|*
name|alloc_l2e
parameter_list|(
name|struct
name|l2t_data
modifier|*
name|d
parameter_list|)
block|{
name|struct
name|l2t_entry
modifier|*
name|end
decl_stmt|,
modifier|*
name|e
decl_stmt|,
modifier|*
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|atomic_load_acq_int
argument_list|(
operator|&
name|d
operator|->
name|nfree
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* there's definitely a free entry */
for|for
control|(
name|e
operator|=
name|d
operator|->
name|rover
operator|,
name|end
operator|=
operator|&
name|d
operator|->
name|l2tab
index|[
name|d
operator|->
name|nentries
index|]
init|;
name|e
operator|!=
name|end
condition|;
operator|++
name|e
control|)
if|if
condition|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|e
operator|->
name|refcnt
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|found
goto|;
for|for
control|(
name|e
operator|=
operator|&
name|d
operator|->
name|l2tab
index|[
literal|1
index|]
init|;
name|atomic_load_acq_int
argument_list|(
operator|&
name|e
operator|->
name|refcnt
argument_list|)
condition|;
operator|++
name|e
control|)
empty_stmt|;
name|found
label|:
name|d
operator|->
name|rover
operator|=
name|e
operator|+
literal|1
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|d
operator|->
name|nfree
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * The entry we found may be an inactive entry that is 	 * presently in the hash table.  We need to remove it. 	 */
if|if
condition|(
name|e
operator|->
name|state
operator|!=
name|L2T_STATE_UNUSED
condition|)
block|{
name|int
name|hash
init|=
name|arp_hash
argument_list|(
name|e
operator|->
name|addr
argument_list|,
name|e
operator|->
name|ifindex
argument_list|,
name|d
argument_list|)
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|d
operator|->
name|l2tab
index|[
name|hash
index|]
operator|.
name|first
init|;
operator|*
name|p
condition|;
name|p
operator|=
operator|&
operator|(
operator|*
name|p
operator|)
operator|->
name|next
control|)
if|if
condition|(
operator|*
name|p
operator|==
name|e
condition|)
block|{
operator|*
name|p
operator|=
name|e
operator|->
name|next
expr_stmt|;
break|break;
block|}
name|e
operator|->
name|state
operator|=
name|L2T_STATE_UNUSED
expr_stmt|;
block|}
return|return
name|e
return|;
block|}
end_function

begin_comment
comment|/*  * Called when an L2T entry has no more users.  The entry is left in the hash  * table since it is likely to be reused but we also bump nfree to indicate  * that the entry can be reallocated for a different neighbor.  We also drop  * the existing neighbor reference in case the neighbor is going away and is  * waiting on our reference.  *  * Because entries can be reallocated to other neighbors once their ref count  * drops to 0 we need to take the entry's lock to avoid races with a new  * incarnation.  */
end_comment

begin_function
name|void
name|t3_l2e_free
parameter_list|(
name|struct
name|l2t_data
modifier|*
name|d
parameter_list|,
name|struct
name|l2t_entry
modifier|*
name|e
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|e
operator|->
name|refcnt
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* hasn't been recycled */
if|if
condition|(
name|e
operator|->
name|neigh
condition|)
block|{
name|RT_LOCK
argument_list|(
name|e
operator|->
name|neigh
argument_list|)
expr_stmt|;
name|RT_REMREF
argument_list|(
name|e
operator|->
name|neigh
argument_list|)
expr_stmt|;
name|RT_UNLOCK
argument_list|(
name|e
operator|->
name|neigh
argument_list|)
expr_stmt|;
name|e
operator|->
name|neigh
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|d
operator|->
name|nfree
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update an L2T entry that was previously used for the same next hop as neigh.  * Must be called with softirqs disabled.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|reuse_entry
parameter_list|(
name|struct
name|l2t_entry
modifier|*
name|e
parameter_list|,
name|struct
name|rtentry
modifier|*
name|neigh
parameter_list|)
block|{
name|struct
name|llinfo_arp
modifier|*
name|la
decl_stmt|;
name|la
operator|=
operator|(
expr|struct
name|llinfo_arp
operator|*
operator|)
name|neigh
operator|->
name|rt_llinfo
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* avoid race with t3_l2t_free */
if|if
condition|(
name|neigh
operator|!=
name|e
operator|->
name|neigh
condition|)
name|neigh_replace
argument_list|(
name|e
argument_list|,
name|neigh
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|e
operator|->
name|dmac
argument_list|,
name|RT_ENADDR
argument_list|(
name|neigh
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|e
operator|->
name|dmac
argument_list|)
argument_list|)
operator|||
operator|(
name|neigh
operator|->
name|rt_expire
operator|>
name|time_uptime
operator|)
condition|)
name|e
operator|->
name|state
operator|=
name|L2T_STATE_RESOLVING
expr_stmt|;
elseif|else
if|if
condition|(
name|la
operator|->
name|la_hold
operator|==
name|NULL
condition|)
name|e
operator|->
name|state
operator|=
name|L2T_STATE_VALID
expr_stmt|;
else|else
name|e
operator|->
name|state
operator|=
name|L2T_STATE_STALE
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|l2t_entry
modifier|*
name|t3_l2t_get
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|,
name|struct
name|rtentry
modifier|*
name|neigh
parameter_list|,
name|unsigned
name|int
name|smt_idx
parameter_list|)
block|{
name|struct
name|l2t_entry
modifier|*
name|e
decl_stmt|;
name|struct
name|l2t_data
modifier|*
name|d
init|=
name|L2DATA
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u32
name|addr
init|=
operator|*
operator|(
name|u32
operator|*
operator|)
name|rt_key
argument_list|(
name|neigh
argument_list|)
decl_stmt|;
name|int
name|ifidx
init|=
name|neigh
operator|->
name|rt_ifp
operator|->
name|if_index
decl_stmt|;
name|int
name|hash
init|=
name|arp_hash
argument_list|(
name|addr
argument_list|,
name|ifidx
argument_list|,
name|d
argument_list|)
decl_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|d
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|d
operator|->
name|l2tab
index|[
name|hash
index|]
operator|.
name|first
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
if|if
condition|(
name|e
operator|->
name|addr
operator|==
name|addr
operator|&&
name|e
operator|->
name|ifindex
operator|==
name|ifidx
operator|&&
name|e
operator|->
name|smt_idx
operator|==
name|smt_idx
condition|)
block|{
name|l2t_hold
argument_list|(
name|d
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|e
operator|->
name|refcnt
argument_list|)
operator|==
literal|1
condition|)
name|reuse_entry
argument_list|(
name|e
argument_list|,
name|neigh
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Need to allocate a new entry */
name|e
operator|=
name|alloc_l2e
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* avoid race with t3_l2t_free */
name|e
operator|->
name|next
operator|=
name|d
operator|->
name|l2tab
index|[
name|hash
index|]
operator|.
name|first
expr_stmt|;
name|d
operator|->
name|l2tab
index|[
name|hash
index|]
operator|.
name|first
operator|=
name|e
expr_stmt|;
name|e
operator|->
name|state
operator|=
name|L2T_STATE_RESOLVING
expr_stmt|;
name|e
operator|->
name|addr
operator|=
name|addr
expr_stmt|;
name|e
operator|->
name|ifindex
operator|=
name|ifidx
expr_stmt|;
name|e
operator|->
name|smt_idx
operator|=
name|smt_idx
expr_stmt|;
name|atomic_store_rel_int
argument_list|(
operator|&
name|e
operator|->
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|neigh_replace
argument_list|(
name|e
argument_list|,
name|neigh
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/*  		 * XXX need to add accessor function for vlan tag 		 */
if|if
condition|(
name|neigh
operator|->
name|rt_ifp
operator|->
name|if_vlantrunk
condition|)
name|e
operator|->
name|vlan
operator|=
name|VLAN_DEV_INFO
argument_list|(
name|neigh
operator|->
name|dev
argument_list|)
operator|->
name|vlan_id
expr_stmt|;
else|else
endif|#
directive|endif
name|e
operator|->
name|vlan
operator|=
name|VLAN_NONE
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|rw_wunlock
argument_list|(
operator|&
name|d
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
end_function

begin_comment
comment|/*  * Called when address resolution fails for an L2T entry to handle packets  * on the arpq head.  If a packet specifies a failure handler it is invoked,  * otherwise the packets is sent to the TOE.  *  * XXX: maybe we should abandon the latter behavior and just require a failure  * handler.  */
end_comment

begin_function
specifier|static
name|void
name|handle_failed_resolution
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|arpq
parameter_list|)
block|{
while|while
condition|(
name|arpq
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|arpq
decl_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|struct
name|l2t_mbuf_cb
modifier|*
name|cb
init|=
name|L2T_MBUF_CB
argument_list|(
name|m
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|arpq
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
name|cb
operator|->
name|arp_failure_handler
condition|)
name|cb
operator|->
name|arp_failure_handler
argument_list|(
name|dev
argument_list|,
name|m
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|cxgb_ofld_send
argument_list|(
name|dev
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NETEVENT
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|CONFIG_CHELSIO_T3_MODULE
argument_list|)
end_if

begin_comment
comment|/*  * Called when the host's ARP layer makes a change to some entry that is  * loaded into the HW L2 table.  */
end_comment

begin_function
name|void
name|t3_l2t_update
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|,
name|struct
name|rtentry
modifier|*
name|neigh
parameter_list|)
block|{
name|struct
name|l2t_entry
modifier|*
name|e
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|arpq
init|=
name|NULL
decl_stmt|;
name|struct
name|l2t_data
modifier|*
name|d
init|=
name|L2DATA
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u32
name|addr
init|=
operator|*
operator|(
name|u32
operator|*
operator|)
name|rt_key
argument_list|(
name|neigh
argument_list|)
decl_stmt|;
name|int
name|ifidx
init|=
name|neigh
operator|->
name|rt_ifp
operator|->
name|if_index
decl_stmt|;
name|int
name|hash
init|=
name|arp_hash
argument_list|(
name|addr
argument_list|,
name|ifidx
argument_list|,
name|d
argument_list|)
decl_stmt|;
name|struct
name|llinfo_arp
modifier|*
name|la
decl_stmt|;
name|rw_rlock
argument_list|(
operator|&
name|d
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|d
operator|->
name|l2tab
index|[
name|hash
index|]
operator|.
name|first
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
if|if
condition|(
name|e
operator|->
name|addr
operator|==
name|addr
operator|&&
name|e
operator|->
name|ifindex
operator|==
name|ifidx
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
goto|goto
name|found
goto|;
block|}
name|rw_runlock
argument_list|(
operator|&
name|d
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return;
name|found
label|:
name|rw_runlock
argument_list|(
operator|&
name|d
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|e
operator|->
name|refcnt
argument_list|)
condition|)
block|{
if|if
condition|(
name|neigh
operator|!=
name|e
operator|->
name|neigh
condition|)
name|neigh_replace
argument_list|(
name|e
argument_list|,
name|neigh
argument_list|)
expr_stmt|;
name|la
operator|=
operator|(
expr|struct
name|llinfo_arp
operator|*
operator|)
name|neigh
operator|->
name|rt_llinfo
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|state
operator|==
name|L2T_STATE_RESOLVING
condition|)
block|{
if|if
condition|(
name|la
operator|->
name|la_asked
operator|>=
literal|5
comment|/* arp_maxtries */
condition|)
block|{
name|arpq
operator|=
name|e
operator|->
name|arpq_head
expr_stmt|;
name|e
operator|->
name|arpq_head
operator|=
name|e
operator|->
name|arpq_tail
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|la
operator|->
name|la_hold
operator|==
name|NULL
condition|)
name|setup_l2e_send_pending
argument_list|(
name|dev
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|e
operator|->
name|state
operator|=
operator|(
name|la
operator|->
name|la_hold
operator|==
name|NULL
operator|)
condition|?
name|L2T_STATE_VALID
else|:
name|L2T_STATE_STALE
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|e
operator|->
name|dmac
argument_list|,
name|RT_ENADDR
argument_list|(
name|neigh
argument_list|)
argument_list|,
literal|6
argument_list|)
condition|)
name|setup_l2e_send_pending
argument_list|(
name|dev
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|arpq
condition|)
name|handle_failed_resolution
argument_list|(
name|dev
argument_list|,
name|arpq
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*  * Called from a kprobe, interrupts are off.  */
end_comment

begin_function
name|void
name|t3_l2t_update
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|,
name|struct
name|rtentry
modifier|*
name|neigh
parameter_list|)
block|{
name|struct
name|l2t_entry
modifier|*
name|e
decl_stmt|;
name|struct
name|l2t_data
modifier|*
name|d
init|=
name|L2DATA
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u32
name|addr
init|=
operator|*
operator|(
name|u32
operator|*
operator|)
name|rt_key
argument_list|(
name|neigh
argument_list|)
decl_stmt|;
name|int
name|ifidx
init|=
name|neigh
operator|->
name|dev
operator|->
name|ifindex
decl_stmt|;
name|int
name|hash
init|=
name|arp_hash
argument_list|(
name|addr
argument_list|,
name|ifidx
argument_list|,
name|d
argument_list|)
decl_stmt|;
name|rw_rlock
argument_list|(
operator|&
name|d
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|d
operator|->
name|l2tab
index|[
name|hash
index|]
operator|.
name|first
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|next
control|)
if|if
condition|(
name|e
operator|->
name|addr
operator|==
name|addr
operator|&&
name|e
operator|->
name|ifindex
operator|==
name|ifidx
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|e
operator|->
name|refcnt
argument_list|)
condition|)
block|{
if|if
condition|(
name|neigh
operator|!=
name|e
operator|->
name|neigh
condition|)
name|neigh_replace
argument_list|(
name|e
argument_list|,
name|neigh
argument_list|)
expr_stmt|;
name|e
operator|->
name|tdev
operator|=
name|dev
expr_stmt|;
name|mod_timer
argument_list|(
operator|&
name|e
operator|->
name|update_timer
argument_list|,
name|jiffies
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
break|break;
block|}
name|rw_runlock
argument_list|(
operator|&
name|d
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|update_timer_cb
parameter_list|(
name|unsigned
name|long
name|data
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|arpq
init|=
name|NULL
decl_stmt|;
name|struct
name|l2t_entry
modifier|*
name|e
init|=
operator|(
expr|struct
name|l2t_entry
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|neigh
init|=
name|e
operator|->
name|neigh
decl_stmt|;
name|struct
name|toedev
modifier|*
name|dev
init|=
name|e
operator|->
name|tdev
decl_stmt|;
name|barrier
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|atomic_load_acq_int
argument_list|(
operator|&
name|e
operator|->
name|refcnt
argument_list|)
condition|)
return|return;
name|rw_rlock
argument_list|(
operator|&
name|neigh
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|e
operator|->
name|refcnt
argument_list|)
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|state
operator|==
name|L2T_STATE_RESOLVING
condition|)
block|{
if|if
condition|(
name|neigh
operator|->
name|nud_state
operator|&
name|NUD_FAILED
condition|)
block|{
name|arpq
operator|=
name|e
operator|->
name|arpq_head
expr_stmt|;
name|e
operator|->
name|arpq_head
operator|=
name|e
operator|->
name|arpq_tail
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|neigh_is_connected
argument_list|(
name|neigh
argument_list|)
operator|&&
name|e
operator|->
name|arpq_head
condition|)
name|setup_l2e_send_pending
argument_list|(
name|dev
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|e
operator|->
name|state
operator|=
name|neigh_is_connected
argument_list|(
name|neigh
argument_list|)
condition|?
name|L2T_STATE_VALID
else|:
name|L2T_STATE_STALE
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|e
operator|->
name|dmac
argument_list|,
name|RT_ENADDR
argument_list|(
name|neigh
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|e
operator|->
name|dmac
argument_list|)
argument_list|)
condition|)
name|setup_l2e_send_pending
argument_list|(
name|dev
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
name|rw_runlock
argument_list|(
operator|&
name|neigh
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|arpq
condition|)
name|handle_failed_resolution
argument_list|(
name|dev
argument_list|,
name|arpq
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|struct
name|l2t_data
modifier|*
name|t3_init_l2t
parameter_list|(
name|unsigned
name|int
name|l2t_capacity
parameter_list|)
block|{
name|struct
name|l2t_data
modifier|*
name|d
decl_stmt|;
name|int
name|i
decl_stmt|,
name|size
init|=
sizeof|sizeof
argument_list|(
operator|*
name|d
argument_list|)
operator|+
name|l2t_capacity
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|l2t_entry
argument_list|)
decl_stmt|;
name|d
operator|=
name|cxgb_alloc_mem
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|NULL
return|;
name|d
operator|->
name|nentries
operator|=
name|l2t_capacity
expr_stmt|;
name|d
operator|->
name|rover
operator|=
operator|&
name|d
operator|->
name|l2tab
index|[
literal|1
index|]
expr_stmt|;
comment|/* entry 0 is not used */
name|atomic_store_rel_int
argument_list|(
operator|&
name|d
operator|->
name|nfree
argument_list|,
name|l2t_capacity
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rw_init
argument_list|(
operator|&
name|d
operator|->
name|lock
argument_list|,
literal|"L2T"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l2t_capacity
condition|;
operator|++
name|i
control|)
block|{
name|d
operator|->
name|l2tab
index|[
name|i
index|]
operator|.
name|idx
operator|=
name|i
expr_stmt|;
name|d
operator|->
name|l2tab
index|[
name|i
index|]
operator|.
name|state
operator|=
name|L2T_STATE_UNUSED
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|d
operator|->
name|l2tab
index|[
name|i
index|]
operator|.
name|lock
argument_list|,
literal|"L2TAB"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|atomic_store_rel_int
argument_list|(
operator|&
name|d
operator|->
name|l2tab
index|[
name|i
index|]
operator|.
name|refcnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NETEVENT
ifdef|#
directive|ifdef
name|CONFIG_CHELSIO_T3_MODULE
name|setup_timer
argument_list|(
operator|&
name|d
operator|->
name|l2tab
index|[
name|i
index|]
operator|.
name|update_timer
argument_list|,
name|update_timer_cb
argument_list|,
operator|(
name|unsigned
name|long
operator|)
operator|&
name|d
operator|->
name|l2tab
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
return|return
name|d
return|;
block|}
end_function

begin_function
name|void
name|t3_free_l2t
parameter_list|(
name|struct
name|l2t_data
modifier|*
name|d
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|NETEVENT
ifdef|#
directive|ifdef
name|CONFIG_CHELSIO_T3_MODULE
name|int
name|i
decl_stmt|;
comment|/* Stop all L2T timers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|nentries
condition|;
operator|++
name|i
control|)
name|del_timer_sync
argument_list|(
operator|&
name|d
operator|->
name|l2tab
index|[
name|i
index|]
operator|.
name|update_timer
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|cxgb_free_mem
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_PROC_FS
end_ifdef

begin_include
include|#
directive|include
file|<linux/module.h>
end_include

begin_include
include|#
directive|include
file|<linux/proc_fs.h>
end_include

begin_include
include|#
directive|include
file|<linux/seq_file.h>
end_include

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|l2t_get_idx
parameter_list|(
name|struct
name|seq_file
modifier|*
name|seq
parameter_list|,
name|loff_t
name|pos
parameter_list|)
block|{
name|struct
name|l2t_data
modifier|*
name|d
init|=
name|seq
operator|->
name|private
decl_stmt|;
return|return
name|pos
operator|>=
name|d
operator|->
name|nentries
condition|?
name|NULL
else|:
operator|&
name|d
operator|->
name|l2tab
index|[
name|pos
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|l2t_seq_start
parameter_list|(
name|struct
name|seq_file
modifier|*
name|seq
parameter_list|,
name|loff_t
modifier|*
name|pos
parameter_list|)
block|{
return|return
operator|*
name|pos
condition|?
name|l2t_get_idx
argument_list|(
name|seq
argument_list|,
operator|*
name|pos
argument_list|)
else|:
name|SEQ_START_TOKEN
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|l2t_seq_next
parameter_list|(
name|struct
name|seq_file
modifier|*
name|seq
parameter_list|,
name|void
modifier|*
name|v
parameter_list|,
name|loff_t
modifier|*
name|pos
parameter_list|)
block|{
name|v
operator|=
name|l2t_get_idx
argument_list|(
name|seq
argument_list|,
operator|*
name|pos
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
condition|)
operator|++
operator|*
name|pos
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|l2t_seq_stop
parameter_list|(
name|struct
name|seq_file
modifier|*
name|seq
parameter_list|,
name|void
modifier|*
name|v
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|char
name|l2e_state
parameter_list|(
specifier|const
name|struct
name|l2t_entry
modifier|*
name|e
parameter_list|)
block|{
switch|switch
condition|(
name|e
operator|->
name|state
condition|)
block|{
case|case
name|L2T_STATE_VALID
case|:
return|return
literal|'V'
return|;
comment|/* valid, fast-path entry */
case|case
name|L2T_STATE_STALE
case|:
return|return
literal|'S'
return|;
comment|/* needs revalidation, but usable */
case|case
name|L2T_STATE_RESOLVING
case|:
return|return
name|e
operator|->
name|arpq_head
condition|?
literal|'A'
else|:
literal|'R'
return|;
default|default:
return|return
literal|'U'
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|l2t_seq_show
parameter_list|(
name|struct
name|seq_file
modifier|*
name|seq
parameter_list|,
name|void
modifier|*
name|v
parameter_list|)
block|{
if|if
condition|(
name|v
operator|==
name|SEQ_START_TOKEN
condition|)
name|seq_puts
argument_list|(
name|seq
argument_list|,
literal|"Index IP address      Ethernet address   VLAN  "
literal|"Prio  State   Users SMTIDX  Port\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|char
name|ip
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|l2t_entry
modifier|*
name|e
init|=
name|v
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ip
argument_list|,
literal|"%u.%u.%u.%u"
argument_list|,
name|NIPQUAD
argument_list|(
name|e
operator|->
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|seq_printf
argument_list|(
name|seq
argument_list|,
literal|"%-5u %-15s %02x:%02x:%02x:%02x:%02x:%02x  %4d"
literal|"  %3u     %c   %7u   %4u %s\n"
argument_list|,
name|e
operator|->
name|idx
argument_list|,
name|ip
argument_list|,
name|e
operator|->
name|dmac
index|[
literal|0
index|]
argument_list|,
name|e
operator|->
name|dmac
index|[
literal|1
index|]
argument_list|,
name|e
operator|->
name|dmac
index|[
literal|2
index|]
argument_list|,
name|e
operator|->
name|dmac
index|[
literal|3
index|]
argument_list|,
name|e
operator|->
name|dmac
index|[
literal|4
index|]
argument_list|,
name|e
operator|->
name|dmac
index|[
literal|5
index|]
argument_list|,
name|e
operator|->
name|vlan
operator|&
name|EVL_VLID_MASK
argument_list|,
name|vlan_prio
argument_list|(
name|e
argument_list|)
argument_list|,
name|l2e_state
argument_list|(
name|e
argument_list|)
argument_list|,
name|atomic_load_acq_int
argument_list|(
operator|&
name|e
operator|->
name|refcnt
argument_list|)
argument_list|,
name|e
operator|->
name|smt_idx
argument_list|,
name|e
operator|->
name|neigh
condition|?
name|e
operator|->
name|neigh
operator|->
name|dev
operator|->
name|name
else|:
literal|""
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|e
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

