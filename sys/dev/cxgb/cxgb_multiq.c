begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************************  Copyright (c) 2007, Chelsio Inc. All rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:   1. Redistributions of source code must retain the above copyright notice,     this list of conditions and the following disclaimer.  2. Neither the name of the Chelsio Corporation nor the names of its     contributors may be used to endorse or promote products derived from     this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/pciio.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus_dma.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/firmware.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_crc32.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pci_private.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<cxgb_include.h>
end_include

begin_include
include|#
directive|include
file|<sys/mvec.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|txq_fills
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|multiq_tx_enable
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|coalesce_tx_enable
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|wakeup_tx_thread
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|sysctl_oid_list
name|sysctl__hw_cxgb_children
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sleep_ticks
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgb.sleep_ticks"
argument_list|,
operator|&
name|sleep_ticks
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_cxgb
argument_list|,
name|OID_AUTO
argument_list|,
name|sleep_ticks
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|sleep_ticks
argument_list|,
literal|0
argument_list|,
literal|"ticks to sleep between checking pcpu queues"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|cxgb_txq_buf_ring_size
init|=
name|TX_ETH_Q_SIZE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgb.txq_mr_size"
argument_list|,
operator|&
name|cxgb_txq_buf_ring_size
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_cxgb
argument_list|,
name|OID_AUTO
argument_list|,
name|txq_mr_size
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|cxgb_txq_buf_ring_size
argument_list|,
literal|0
argument_list|,
literal|"size of per-queue mbuf ring"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|cxgb_pcpu_start_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgb_tx
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|uint32_t
name|txmax
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|IFNET_MULTIQUEUE
end_ifdef

begin_function_decl
specifier|static
name|int
name|cxgb_pcpu_cookie_to_qidx
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|,
name|uint32_t
name|cookie
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|inline
name|int
name|cxgb_pcpu_enqueue_packet_
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|KASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null mbuf"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|->
name|m_type
operator|==
name|MT_DATA
argument_list|,
operator|(
literal|"bad mbuf type %d"
operator|,
name|m
operator|->
name|m_type
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qs
operator|->
name|qs_flags
operator|&
name|QS_EXITING
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
block|}
name|txq
operator|=
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
expr_stmt|;
name|err
operator|=
name|buf_ring_enqueue
argument_list|(
name|txq
operator|->
name|txq_mr
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|txq
operator|->
name|txq_drops
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wakeup_tx_thread
operator|&&
operator|!
name|err
operator|&&
operator|(
operator|(
name|txq
operator|->
name|flags
operator|&
name|TXQ_TRANSMITTING
operator|)
operator|==
literal|0
operator|)
condition|)
name|wakeup
argument_list|(
name|qs
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_dequeue_packet
parameter_list|(
name|struct
name|sge_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m_vec
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m0
decl_stmt|;
name|struct
name|sge_qset
modifier|*
name|qs
decl_stmt|;
name|int
name|count
decl_stmt|,
name|size
decl_stmt|,
name|coalesced
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
decl_stmt|;
ifdef|#
directive|ifdef
name|ALTQ
if|if
condition|(
name|ALTQ_IS_ENABLED
argument_list|(
name|txq
operator|->
name|txq_ifq
argument_list|)
condition|)
block|{
name|IFQ_DRV_DEQUEUE
argument_list|(
name|txq
operator|->
name|txq_ifq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|m_vec
index|[
literal|0
index|]
operator|=
name|m
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
name|mtx_assert
argument_list|(
operator|&
name|txq
operator|->
name|lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|coalesced
operator|=
name|count
operator|=
name|size
operator|=
literal|0
expr_stmt|;
name|qs
operator|=
name|txq_to_qset
argument_list|(
name|txq
argument_list|,
name|TXQ_ETH
argument_list|)
expr_stmt|;
if|if
condition|(
name|qs
operator|->
name|qs_flags
operator|&
name|QS_EXITING
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|txq
operator|->
name|immpkt
operator|!=
name|NULL
condition|)
block|{
name|m_vec
index|[
literal|0
index|]
operator|=
name|txq
operator|->
name|immpkt
expr_stmt|;
name|txq
operator|->
name|immpkt
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|sc
operator|=
name|qs
operator|->
name|port
operator|->
name|adapter
expr_stmt|;
name|m
operator|=
name|buf_ring_dequeue_sc
argument_list|(
name|txq
operator|->
name|txq_mr
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|count
operator|=
literal|1
expr_stmt|;
name|m_vec
index|[
literal|0
index|]
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
operator|>
literal|0
operator|||
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|TX_WR_SIZE_MAX
operator|||
name|m
operator|->
name|m_next
operator|!=
name|NULL
operator|||
operator|(
name|coalesce_tx_enable
operator|==
literal|0
operator|)
condition|)
block|{
return|return
operator|(
name|count
operator|)
return|;
block|}
name|size
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
for|for
control|(
name|m
operator|=
name|buf_ring_peek
argument_list|(
name|txq
operator|->
name|txq_mr
argument_list|)
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|buf_ring_peek
argument_list|(
name|txq
operator|->
name|txq_mr
argument_list|)
control|)
block|{
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
operator|>
literal|0
operator|||
name|size
operator|+
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|TX_WR_SIZE_MAX
operator|||
name|m
operator|->
name|m_next
operator|!=
name|NULL
condition|)
break|break;
name|m0
operator|=
name|buf_ring_dequeue_sc
argument_list|(
name|txq
operator|->
name|txq_mr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_BUFRING
if|if
condition|(
name|m0
operator|!=
name|m
condition|)
name|panic
argument_list|(
literal|"peek and dequeue don't match"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|size
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|m_vec
index|[
name|count
operator|++
index|]
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|count
operator|==
name|TX_WR_COUNT_MAX
condition|)
break|break;
name|coalesced
operator|++
expr_stmt|;
block|}
name|txq
operator|->
name|txq_coalesced
operator|+=
name|coalesced
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_pcpu_free
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
init|=
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|txq
operator|->
name|lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|mbufq_dequeue
argument_list|(
operator|&
name|txq
operator|->
name|sendq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|buf_ring_dequeue_sc
argument_list|(
name|txq
operator|->
name|txq_mr
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|t3_free_tx_desc_all
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|txq
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_pcpu_reclaim_tx
parameter_list|(
name|struct
name|sge_txq
modifier|*
name|txq
parameter_list|)
block|{
name|int
name|reclaimable
decl_stmt|;
name|struct
name|sge_qset
modifier|*
name|qs
init|=
name|txq_to_qset
argument_list|(
name|txq
argument_list|,
name|TXQ_ETH
argument_list|)
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|txq
operator|->
name|lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|reclaimable
operator|=
name|desc_reclaimable
argument_list|(
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|reclaimable
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|t3_free_tx_desc
argument_list|(
name|txq
argument_list|,
name|reclaimable
argument_list|)
expr_stmt|;
name|txq
operator|->
name|cleaned
operator|+=
name|reclaimable
expr_stmt|;
name|txq
operator|->
name|in_use
operator|-=
name|reclaimable
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
operator|&
name|qs
operator|->
name|txq_stopped
argument_list|,
name|TXQ_ETH
argument_list|)
condition|)
block|{
name|qs
operator|->
name|port
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|clrbit
argument_list|(
operator|&
name|qs
operator|->
name|txq_stopped
argument_list|,
name|TXQ_ETH
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|reclaimable
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_pcpu_start_
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|struct
name|mbuf
modifier|*
name|immpkt
parameter_list|,
name|int
name|tx_flush
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|err
decl_stmt|,
name|initerr
decl_stmt|,
name|flush
decl_stmt|,
name|reclaimed
decl_stmt|,
name|stopped
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
name|adapter_t
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|max_desc
decl_stmt|;
name|pi
operator|=
name|qs
operator|->
name|port
expr_stmt|;
name|initerr
operator|=
name|err
operator|=
name|i
operator|=
name|reclaimed
operator|=
literal|0
expr_stmt|;
name|sc
operator|=
name|pi
operator|->
name|adapter
expr_stmt|;
name|txq
operator|=
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|txq
operator|->
name|lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|retry
label|:
if|if
condition|(
operator|!
name|pi
operator|->
name|link_config
operator|.
name|link_ok
condition|)
name|initerr
operator|=
name|ENETDOWN
expr_stmt|;
elseif|else
if|if
condition|(
name|qs
operator|->
name|qs_flags
operator|&
name|QS_EXITING
condition|)
name|initerr
operator|=
name|ENETDOWN
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|pi
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
name|initerr
operator|=
name|ENETDOWN
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|pi
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
name|initerr
operator|=
name|ENETDOWN
expr_stmt|;
elseif|else
if|if
condition|(
name|immpkt
condition|)
block|{
if|if
condition|(
operator|!
name|buf_ring_empty
argument_list|(
name|txq
operator|->
name|txq_mr
argument_list|)
operator|||
name|ALTQ_IS_ENABLED
argument_list|(
operator|&
name|pi
operator|->
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|initerr
operator|=
name|cxgb_pcpu_enqueue_packet_
argument_list|(
name|qs
argument_list|,
name|immpkt
argument_list|)
expr_stmt|;
else|else
name|txq
operator|->
name|immpkt
operator|=
name|immpkt
expr_stmt|;
name|immpkt
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|initerr
condition|)
block|{
if|if
condition|(
name|immpkt
condition|)
name|m_freem
argument_list|(
name|immpkt
argument_list|)
expr_stmt|;
if|if
condition|(
name|initerr
operator|==
name|ENOBUFS
operator|&&
operator|!
name|tx_flush
condition|)
name|wakeup
argument_list|(
name|qs
argument_list|)
expr_stmt|;
return|return
operator|(
name|initerr
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|tx_flush
operator|&&
operator|(
name|desc_reclaimable
argument_list|(
name|txq
argument_list|)
operator|>
literal|0
operator|)
operator|)
operator|||
operator|(
name|desc_reclaimable
argument_list|(
name|txq
argument_list|)
operator|>
operator|(
name|TX_ETH_Q_SIZE
operator|>>
literal|3
operator|)
operator|)
condition|)
block|{
name|cxgb_pcpu_reclaim_tx
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
name|stopped
operator|=
name|isset
argument_list|(
operator|&
name|qs
operator|->
name|txq_stopped
argument_list|,
name|TXQ_ETH
argument_list|)
expr_stmt|;
name|flush
operator|=
operator|(
operator|(
operator|!
name|drbr_empty
argument_list|(
name|pi
operator|->
name|ifp
argument_list|,
name|txq
operator|->
name|txq_mr
argument_list|)
operator|&&
operator|!
name|stopped
operator|)
operator|||
name|txq
operator|->
name|immpkt
operator|)
expr_stmt|;
name|max_desc
operator|=
name|tx_flush
condition|?
name|TX_ETH_Q_SIZE
else|:
name|TX_START_MAX_DESC
expr_stmt|;
name|err
operator|=
name|flush
condition|?
name|cxgb_tx
argument_list|(
name|qs
argument_list|,
name|max_desc
argument_list|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|tx_flush
operator|&&
name|flush
operator|&&
name|err
operator|==
literal|0
operator|)
operator|&&
operator|!
name|drbr_empty
argument_list|(
name|pi
operator|->
name|ifp
argument_list|,
name|txq
operator|->
name|txq_mr
argument_list|)
condition|)
block|{
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
if|if
condition|(
operator|++
name|i
operator|>
literal|1
condition|)
block|{
name|thread_lock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|sched_prio
argument_list|(
name|td
argument_list|,
name|PRI_MIN_TIMESHARE
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|200
condition|)
block|{
name|device_printf
argument_list|(
name|qs
operator|->
name|port
operator|->
name|adapter
operator|->
name|dev
argument_list|,
literal|"exceeded max enqueue tries\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
goto|goto
name|retry
goto|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cxgb_pcpu_transmit
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|immpkt
parameter_list|)
block|{
name|uint32_t
name|cookie
decl_stmt|;
name|int
name|err
decl_stmt|,
name|qidx
decl_stmt|,
name|locked
decl_stmt|,
name|resid
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
decl_stmt|;
name|struct
name|sge_qset
modifier|*
name|qs
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
init|=
name|NULL
comment|/* gcc is dumb */
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
decl_stmt|;
name|pi
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|sc
operator|=
name|pi
operator|->
name|adapter
expr_stmt|;
name|qs
operator|=
name|NULL
expr_stmt|;
name|qidx
operator|=
name|resid
operator|=
name|err
operator|=
name|cookie
operator|=
name|locked
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|IFNET_MULTIQUEUE
if|if
condition|(
name|immpkt
operator|&&
operator|(
name|immpkt
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|!=
literal|0
operator|)
condition|)
block|{
name|cookie
operator|=
name|immpkt
operator|->
name|m_pkthdr
operator|.
name|flowid
expr_stmt|;
name|qidx
operator|=
name|cxgb_pcpu_cookie_to_qidx
argument_list|(
name|pi
argument_list|,
name|cookie
argument_list|)
expr_stmt|;
name|qs
operator|=
operator|&
name|pi
operator|->
name|adapter
operator|->
name|sge
operator|.
name|qs
index|[
name|qidx
index|]
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|qs
operator|=
operator|&
name|pi
operator|->
name|adapter
operator|->
name|sge
operator|.
name|qs
index|[
name|pi
operator|->
name|first_qset
index|]
expr_stmt|;
name|txq
operator|=
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|sc
operator|->
name|tunq_coalesce
operator|==
literal|0
operator|)
operator|||
operator|(
name|buf_ring_count
argument_list|(
name|txq
operator|->
name|txq_mr
argument_list|)
operator|>=
name|TX_WR_COUNT_MAX
operator|)
operator|||
operator|(
name|coalesce_tx_enable
operator|==
literal|0
operator|)
operator|)
operator|&&
name|mtx_trylock
argument_list|(
operator|&
name|txq
operator|->
name|lock
argument_list|)
condition|)
block|{
name|txq
operator|->
name|flags
operator||=
name|TXQ_TRANSMITTING
expr_stmt|;
name|err
operator|=
name|cxgb_pcpu_start_
argument_list|(
name|qs
argument_list|,
name|immpkt
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|txq
operator|->
name|flags
operator|&=
operator|~
name|TXQ_TRANSMITTING
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|txq
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|immpkt
condition|)
return|return
operator|(
name|cxgb_pcpu_enqueue_packet_
argument_list|(
name|qs
argument_list|,
name|immpkt
argument_list|)
operator|)
return|;
return|return
operator|(
operator|(
name|err
operator|==
name|EBUSY
operator|)
condition|?
literal|0
else|:
name|err
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cxgb_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|p
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|link_config
operator|.
name|link_ok
condition|)
return|return;
name|cxgb_pcpu_transmit
argument_list|(
name|ifp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_pcpu_start_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sge_qset
modifier|*
name|qs
init|=
name|arg
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
init|=
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
decl_stmt|;
name|int
name|idleticks
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|sleep_ticks
operator|=
name|max
argument_list|(
name|hz
operator|/
literal|1000
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|qs
operator|->
name|qs_flags
operator||=
name|QS_RUNNING
expr_stmt|;
name|thread_lock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|sched_bind
argument_list|(
name|td
argument_list|,
name|qs
operator|->
name|qs_cpuid
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|qs
operator|->
name|qs_cpuid
operator|*
literal|100000
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"bound to %d running on %d\n"
argument_list|,
name|qs
operator|->
name|qs_cpuid
argument_list|,
name|curcpu
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|qs
operator|->
name|qs_flags
operator|&
name|QS_EXITING
condition|)
break|break;
if|if
condition|(
operator|(
name|qs
operator|->
name|port
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|idleticks
operator|=
name|hz
expr_stmt|;
if|if
condition|(
operator|!
name|buf_ring_empty
argument_list|(
name|txq
operator|->
name|txq_mr
argument_list|)
operator|||
operator|!
name|mbufq_empty
argument_list|(
operator|&
name|txq
operator|->
name|sendq
argument_list|)
condition|)
name|cxgb_pcpu_free
argument_list|(
name|qs
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
else|else
name|idleticks
operator|=
name|sleep_ticks
expr_stmt|;
if|if
condition|(
name|mtx_trylock
argument_list|(
operator|&
name|txq
operator|->
name|lock
argument_list|)
condition|)
block|{
name|txq
operator|->
name|flags
operator||=
name|TXQ_TRANSMITTING
expr_stmt|;
name|err
operator|=
name|cxgb_pcpu_start_
argument_list|(
name|qs
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|txq
operator|->
name|flags
operator|&=
operator|~
name|TXQ_TRANSMITTING
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|txq
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
else|else
name|err
operator|=
name|EINPROGRESS
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
name|mtx_trylock
argument_list|(
operator|&
name|qs
operator|->
name|rspq
operator|.
name|lock
argument_list|)
condition|)
block|{
name|process_responses
argument_list|(
name|sc
argument_list|,
name|qs
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|refill_fl_service
argument_list|(
name|sc
argument_list|,
operator|&
name|qs
operator|->
name|fl
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|refill_fl_service
argument_list|(
name|sc
argument_list|,
operator|&
name|qs
operator|->
name|fl
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|A_SG_GTS
argument_list|,
name|V_RSPQ
argument_list|(
name|qs
operator|->
name|rspq
operator|.
name|cntxt_id
argument_list|)
operator||
name|V_NEWTIMER
argument_list|(
name|qs
operator|->
name|rspq
operator|.
name|next_holdoff
argument_list|)
operator||
name|V_NEWINDEX
argument_list|(
name|qs
operator|->
name|rspq
operator|.
name|cidx
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|qs
operator|->
name|rspq
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
operator|!
name|buf_ring_empty
argument_list|(
name|txq
operator|->
name|txq_mr
argument_list|)
operator|)
operator|&&
name|err
operator|==
literal|0
condition|)
block|{
if|#
directive|if
literal|0
block|if (cxgb_debug) 				printf("head=%p cons=%d prod=%d\n", 				    txq->sendq.head, txq->txq_mr.br_cons, 				    txq->txq_mr.br_prod);
endif|#
directive|endif
continue|continue;
block|}
name|done
label|:
name|tsleep
argument_list|(
name|qs
argument_list|,
literal|1
argument_list|,
literal|"cxgbidle"
argument_list|,
name|idleticks
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|qs
operator|->
name|port
operator|->
name|adapter
operator|->
name|dev
argument_list|,
literal|"exiting thread for cpu%d\n"
argument_list|,
name|qs
operator|->
name|qs_cpuid
argument_list|)
expr_stmt|;
name|cxgb_pcpu_free
argument_list|(
name|qs
argument_list|)
expr_stmt|;
name|t3_free_qset
argument_list|(
name|qs
operator|->
name|port
operator|->
name|adapter
argument_list|,
name|qs
argument_list|)
expr_stmt|;
name|qs
operator|->
name|qs_flags
operator|&=
operator|~
name|QS_RUNNING
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800002
name|kproc_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|kthread_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IFNET_MULTIQUEUE
end_ifdef

begin_function
specifier|static
name|int
name|cxgb_pcpu_cookie_to_qidx
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|,
name|uint32_t
name|cookie
parameter_list|)
block|{
name|int
name|qidx
decl_stmt|;
name|uint32_t
name|tmp
decl_stmt|;
if|if
condition|(
name|multiq_tx_enable
operator|==
literal|0
condition|)
return|return
operator|(
name|pi
operator|->
name|first_qset
operator|)
return|;
comment|/* 	 * Will probably need to be changed for 4-port XXX 	 */
name|tmp
operator|=
name|pi
operator|->
name|tx_chan
condition|?
name|cookie
else|:
name|cookie
operator|&
operator|(
operator|(
name|RSS_TABLE_SIZE
operator|>>
literal|1
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|" tmp=%d "
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|qidx
operator|=
operator|(
name|tmp
operator|&
operator|(
name|pi
operator|->
name|nqsets
operator|-
literal|1
operator|)
operator|)
operator|+
name|pi
operator|->
name|first_qset
expr_stmt|;
return|return
operator|(
name|qidx
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|cxgb_pcpu_startup_threads
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|nqsets
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|sc
operator|)
operator|->
name|params
operator|.
name|nports
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|adap2pinfo
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|IFNET_MULTIQUEUE
name|nqsets
operator|=
name|pi
operator|->
name|nqsets
expr_stmt|;
else|#
directive|else
name|nqsets
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nqsets
condition|;
operator|++
name|j
control|)
block|{
name|struct
name|sge_qset
modifier|*
name|qs
decl_stmt|;
name|qs
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
name|pi
operator|->
name|first_qset
operator|+
name|j
index|]
expr_stmt|;
name|qs
operator|->
name|port
operator|=
name|pi
expr_stmt|;
name|qs
operator|->
name|qs_cpuid
operator|=
operator|(
operator|(
name|pi
operator|->
name|first_qset
operator|+
name|j
operator|)
operator|%
name|mp_ncpus
operator|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"starting thread for %d\n"
argument_list|,
name|qs
operator|->
name|qs_cpuid
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|800002
name|kproc_create
argument_list|(
name|cxgb_pcpu_start_proc
argument_list|,
name|qs
argument_list|,
operator|&
name|p
argument_list|,
name|RFNOWAIT
argument_list|,
literal|0
argument_list|,
literal|"cxgbsp"
argument_list|)
expr_stmt|;
else|#
directive|else
name|kthread_create
argument_list|(
name|cxgb_pcpu_start_proc
argument_list|,
name|qs
argument_list|,
operator|&
name|p
argument_list|,
name|RFNOWAIT
argument_list|,
literal|0
argument_list|,
literal|"cxgbsp"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|cxgb_pcpu_shutdown_threads
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|nqsets
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|params
operator|.
name|nports
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
operator|&
name|sc
operator|->
name|port
index|[
name|i
index|]
decl_stmt|;
name|int
name|first
init|=
name|pi
operator|->
name|first_qset
decl_stmt|;
ifdef|#
directive|ifdef
name|IFNET_MULTIQUEUE
name|nqsets
operator|=
name|pi
operator|->
name|nqsets
expr_stmt|;
else|#
directive|else
name|nqsets
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nqsets
condition|;
name|j
operator|++
control|)
block|{
name|struct
name|sge_qset
modifier|*
name|qs
init|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
name|first
operator|+
name|j
index|]
decl_stmt|;
name|qs
operator|->
name|qs_flags
operator||=
name|QS_EXITING
expr_stmt|;
name|wakeup
argument_list|(
name|qs
argument_list|)
expr_stmt|;
name|tsleep
argument_list|(
operator|&
name|sc
argument_list|,
name|PRI_MIN_TIMESHARE
argument_list|,
literal|"cxgb unload 0"
argument_list|,
name|hz
operator|>>
literal|2
argument_list|)
expr_stmt|;
while|while
condition|(
name|qs
operator|->
name|qs_flags
operator|&
name|QS_RUNNING
condition|)
block|{
name|qs
operator|->
name|qs_flags
operator||=
name|QS_EXITING
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"qset thread %d still running - sleeping\n"
argument_list|,
name|first
operator|+
name|j
argument_list|)
expr_stmt|;
name|tsleep
argument_list|(
operator|&
name|sc
argument_list|,
name|PRI_MIN_TIMESHARE
argument_list|,
literal|"cxgb unload 1"
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|check_pkt_coalesce
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
name|txq
operator|=
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
expr_stmt|;
name|sc
operator|=
name|qs
operator|->
name|port
operator|->
name|adapter
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tunq_fill
index|[
name|qs
operator|->
name|idx
index|]
operator|&&
operator|(
name|txq
operator|->
name|in_use
operator|<
operator|(
name|txq
operator|->
name|size
operator|-
operator|(
name|txq
operator|->
name|size
operator|>>
literal|2
operator|)
operator|)
operator|)
condition|)
name|sc
operator|->
name|tunq_fill
index|[
name|qs
operator|->
name|idx
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|sc
operator|->
name|tunq_fill
index|[
name|qs
operator|->
name|idx
index|]
operator|&&
operator|(
name|txq
operator|->
name|in_use
operator|>
operator|(
name|txq
operator|->
name|size
operator|-
operator|(
name|txq
operator|->
name|size
operator|>>
literal|2
operator|)
operator|)
operator|)
condition|)
name|sc
operator|->
name|tunq_fill
index|[
name|qs
operator|->
name|idx
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_tx
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|uint32_t
name|txmax
parameter_list|)
block|{
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|qs
operator|->
name|port
operator|->
name|ifp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|err
decl_stmt|,
name|in_use_init
decl_stmt|,
name|count
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_vec
index|[
name|TX_WR_COUNT_MAX
index|]
decl_stmt|;
name|txq
operator|=
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
expr_stmt|;
name|ifp
operator|=
name|qs
operator|->
name|port
operator|->
name|ifp
expr_stmt|;
name|in_use_init
operator|=
name|txq
operator|->
name|in_use
expr_stmt|;
name|count
operator|=
name|err
operator|=
literal|0
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|txq
operator|->
name|lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|txq
operator|->
name|in_use
operator|-
name|in_use_init
operator|<
name|txmax
operator|)
operator|&&
operator|(
name|txq
operator|->
name|size
operator|>
name|txq
operator|->
name|in_use
operator|+
name|TX_MAX_DESC
operator|)
condition|)
block|{
name|check_pkt_coalesce
argument_list|(
name|qs
argument_list|)
expr_stmt|;
name|count
operator|=
name|cxgb_dequeue_packet
argument_list|(
name|txq
argument_list|,
name|m_vec
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m_vec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|t3_encap
argument_list|(
name|qs
argument_list|,
name|m_vec
argument_list|,
name|count
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|txq
operator|->
name|txq_enqueued
operator|+=
name|count
expr_stmt|;
block|}
if|if
condition|(
name|txq
operator|->
name|size
operator|<=
name|txq
operator|->
name|in_use
operator|+
name|TX_MAX_DESC
condition|)
block|{
name|txq_fills
operator|++
expr_stmt|;
name|setbit
argument_list|(
operator|&
name|qs
operator|->
name|txq_stopped
argument_list|,
name|TXQ_ETH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
name|ENOMEM
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 		 * Sub-optimal :-/ 		 */
name|printf
argument_list|(
literal|"ENOMEM!!!"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|m_freem
argument_list|(
name|m_vec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

end_unit

