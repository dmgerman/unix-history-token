begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************************  Copyright (c) 2007, Chelsio Inc. All rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:   1. Redistributions of source code must retain the above copyright notice,     this list of conditions and the following disclaimer.   2. Neither the name of the Chelsio Corporation nor the names of its     contributors may be used to endorse or promote products derived from     this software without specific prior written permission.   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus_dma.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_common.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_regs.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_sge_defs.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_t3_cpl.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_firmware_exports.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/cxgb_offload.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/sys/mvec.h>
end_include

begin_decl_stmt
name|uint32_t
name|collapse_free
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|mb_free_vec_free
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|collapse_mbufs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|recycle_enable
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * XXX GC  */
end_comment

begin_define
define|#
directive|define
name|NET_XMIT_CN
value|2
end_define

begin_define
define|#
directive|define
name|NET_XMIT_SUCCESS
value|0
end_define

begin_define
define|#
directive|define
name|USE_GTS
value|0
end_define

begin_define
define|#
directive|define
name|SGE_RX_SM_BUF_SIZE
value|1536
end_define

begin_define
define|#
directive|define
name|SGE_RX_DROP_THRES
value|16
end_define

begin_define
define|#
directive|define
name|SGE_RX_COPY_THRES
value|128
end_define

begin_comment
comment|/*  * Period of the Tx buffer reclaim timer.  This timer does not need to run  * frequently as Tx buffers are usually reclaimed by new Tx packets.  */
end_comment

begin_define
define|#
directive|define
name|TX_RECLAIM_PERIOD
value|(hz>> 1)
end_define

begin_comment
comment|/*   * work request size in bytes  */
end_comment

begin_define
define|#
directive|define
name|WR_LEN
value|(WR_FLITS * 8)
end_define

begin_comment
comment|/*   * Values for sge_txq.flags  */
end_comment

begin_enum
enum|enum
block|{
name|TXQ_RUNNING
init|=
literal|1
operator|<<
literal|0
block|,
comment|/* fetch engine is running */
name|TXQ_LAST_PKT_DB
init|=
literal|1
operator|<<
literal|1
block|,
comment|/* last packet rang the doorbell */
block|}
enum|;
end_enum

begin_struct
struct|struct
name|tx_desc
block|{
name|uint64_t
name|flit
index|[
name|TX_DESC_FLITS
index|]
decl_stmt|;
block|}
name|__packed
struct|;
end_struct

begin_struct
struct|struct
name|rx_desc
block|{
name|uint32_t
name|addr_lo
decl_stmt|;
name|uint32_t
name|len_gen
decl_stmt|;
name|uint32_t
name|gen2
decl_stmt|;
name|uint32_t
name|addr_hi
decl_stmt|;
block|}
name|__packed
struct|;
end_struct

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_struct
struct|struct
name|rsp_desc
block|{
comment|/* response queue descriptor */
name|struct
name|rss_header
name|rss_hdr
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|uint32_t
name|len_cq
decl_stmt|;
name|uint8_t
name|imm_data
index|[
literal|47
index|]
decl_stmt|;
name|uint8_t
name|intr_gen
decl_stmt|;
block|}
name|__packed
struct|;
end_struct

begin_define
define|#
directive|define
name|RX_SW_DESC_MAP_CREATED
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|TX_SW_DESC_MAP_CREATED
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|RX_SW_DESC_INUSE
value|(1<< 3)
end_define

begin_define
define|#
directive|define
name|TX_SW_DESC_MAPPED
value|(1<< 4)
end_define

begin_define
define|#
directive|define
name|RSPQ_NSOP_NEOP
value|G_RSPD_SOP_EOP(0)
end_define

begin_define
define|#
directive|define
name|RSPQ_EOP
value|G_RSPD_SOP_EOP(F_RSPD_EOP)
end_define

begin_define
define|#
directive|define
name|RSPQ_SOP
value|G_RSPD_SOP_EOP(F_RSPD_SOP)
end_define

begin_define
define|#
directive|define
name|RSPQ_SOP_EOP
value|G_RSPD_SOP_EOP(F_RSPD_SOP|F_RSPD_EOP)
end_define

begin_struct
struct|struct
name|tx_sw_desc
block|{
comment|/* SW state per Tx descriptor */
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|rx_sw_desc
block|{
comment|/* SW state per Rx descriptor */
name|void
modifier|*
name|cl
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|txq_state
block|{
name|unsigned
name|int
name|compl
decl_stmt|;
name|unsigned
name|int
name|gen
decl_stmt|;
name|unsigned
name|int
name|pidx
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|refill_fl_cb_arg
block|{
name|int
name|error
decl_stmt|;
name|bus_dma_segment_t
name|seg
decl_stmt|;
name|int
name|nseg
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Maps a number of flits to the number of Tx descriptors that can hold them.  * The formula is  *  * desc = 1 + (flits - 2) / (WR_FLITS - 1).  *  * HW allows up to 4 descriptors to be combined into a WR.  */
end_comment

begin_decl_stmt
specifier|static
name|uint8_t
name|flit_desc_map
index|[]
init|=
block|{
literal|0
block|,
if|#
directive|if
name|SGE_NUM_GENBITS
operator|==
literal|1
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
elif|#
directive|elif
name|SGE_NUM_GENBITS
operator|==
literal|2
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
else|#
directive|else
error|#
directive|error
literal|"SGE_NUM_GENBITS must be 1 or 2"
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lro_default
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cxgb_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|t3_free_qset
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_qset
modifier|*
name|q
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sge_timer_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sge_timer_reclaim
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|ncount
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|free_tx_desc
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_txq
modifier|*
name|q
parameter_list|,
name|int
name|n
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m_vec
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  *	reclaim_completed_tx - reclaims completed Tx descriptors  *	@adapter: the adapter  *	@q: the Tx queue to reclaim completed descriptors from  *  *	Reclaims Tx descriptors that the SGE has indicated it has processed,  *	and frees the associated buffers if possible.  Called with the Tx  *	queue's lock held.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|reclaim_completed_tx
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|struct
name|sge_txq
modifier|*
name|q
parameter_list|,
name|int
name|nbufs
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mvec
parameter_list|)
block|{
name|int
name|reclaimed
decl_stmt|,
name|reclaim
init|=
name|desc_reclaimable
argument_list|(
name|q
argument_list|)
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|q
operator|->
name|lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|reclaim
operator|>
literal|0
condition|)
block|{
name|n
operator|=
name|free_tx_desc
argument_list|(
name|adapter
argument_list|,
name|q
argument_list|,
name|min
argument_list|(
name|reclaim
argument_list|,
name|nbufs
argument_list|)
argument_list|,
name|mvec
argument_list|)
expr_stmt|;
name|reclaimed
operator|=
name|min
argument_list|(
name|reclaim
argument_list|,
name|nbufs
argument_list|)
expr_stmt|;
name|q
operator|->
name|cleaned
operator|+=
name|reclaimed
expr_stmt|;
name|q
operator|->
name|in_use
operator|-=
name|reclaimed
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	should_restart_tx - are there enough resources to restart a Tx queue?  *	@q: the Tx queue  *  *	Checks if there are enough descriptors to restart a suspended Tx queue.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|should_restart_tx
parameter_list|(
specifier|const
name|struct
name|sge_txq
modifier|*
name|q
parameter_list|)
block|{
name|unsigned
name|int
name|r
init|=
name|q
operator|->
name|processed
operator|-
name|q
operator|->
name|cleaned
decl_stmt|;
return|return
name|q
operator|->
name|in_use
operator|-
name|r
operator|<
operator|(
name|q
operator|->
name|size
operator|>>
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_sge_init - initialize SGE  *	@adap: the adapter  *	@p: the SGE parameters  *  *	Performs SGE initialization needed every time after a chip reset.  *	We do not initialize any of the queue sets here, instead the driver  *	top-level must request those individually.  We also do not enable DMA  *	here, that should be done after the queues have been set up.  */
end_comment

begin_function
name|void
name|t3_sge_init
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|struct
name|sge_params
modifier|*
name|p
parameter_list|)
block|{
name|u_int
name|ctrl
decl_stmt|,
name|ups
decl_stmt|;
name|ups
operator|=
literal|0
expr_stmt|;
comment|/* = ffs(pci_resource_len(adap->pdev, 2)>> 12); */
name|ctrl
operator|=
name|F_DROPPKT
operator||
name|V_PKTSHIFT
argument_list|(
literal|2
argument_list|)
operator||
name|F_FLMODE
operator||
name|F_AVOIDCQOVFL
operator||
name|F_CQCRDTCTRL
operator||
name|V_HOSTPAGESIZE
argument_list|(
name|PAGE_SHIFT
operator|-
literal|11
argument_list|)
operator||
name|F_BIGENDIANINGRESS
operator||
name|V_USERSPACESIZE
argument_list|(
name|ups
condition|?
name|ups
operator|-
literal|1
else|:
literal|0
argument_list|)
operator||
name|F_ISCSICOALESCING
expr_stmt|;
if|#
directive|if
name|SGE_NUM_GENBITS
operator|==
literal|1
name|ctrl
operator||=
name|F_EGRGENCTRL
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|adap
operator|->
name|params
operator|.
name|rev
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|adap
operator|->
name|flags
operator|&
operator|(
name|USING_MSIX
operator||
name|USING_MSI
operator|)
operator|)
condition|)
name|ctrl
operator||=
name|F_ONEINTMULTQ
operator||
name|F_OPTONEINTMULTQ
expr_stmt|;
name|ctrl
operator||=
name|F_CQCRDTCTRL
operator||
name|F_AVOIDCQOVFL
expr_stmt|;
block|}
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_CONTROL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_EGR_RCQ_DRB_THRSH
argument_list|,
name|V_HIRCQDRBTHRSH
argument_list|(
literal|512
argument_list|)
operator||
name|V_LORCQDRBTHRSH
argument_list|(
literal|512
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_TIMER_TICK
argument_list|,
name|core_ticks_per_usec
argument_list|(
name|adap
argument_list|)
operator|/
literal|10
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_CMDQ_CREDIT_TH
argument_list|,
name|V_THRESHOLD
argument_list|(
literal|32
argument_list|)
operator||
name|V_TIMEOUT
argument_list|(
literal|200
operator|*
name|core_ticks_per_usec
argument_list|(
name|adap
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_HI_DRB_HI_THRSH
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_HI_DRB_LO_THRSH
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_LO_DRB_HI_THRSH
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_LO_DRB_LO_THRSH
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_OCO_BASE
argument_list|,
name|V_BASE1
argument_list|(
literal|0xfff
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_DRB_PRI_THRESH
argument_list|,
literal|63
operator|*
literal|1024
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	sgl_len - calculates the size of an SGL of the given capacity  *	@n: the number of SGL entries  *  *	Calculates the number of flits needed for a scatter/gather list that  *	can hold the given number of entries.  */
end_comment

begin_function
specifier|static
name|__inline
name|unsigned
name|int
name|sgl_len
parameter_list|(
name|unsigned
name|int
name|n
parameter_list|)
block|{
return|return
operator|(
operator|(
literal|3
operator|*
name|n
operator|)
operator|/
literal|2
operator|+
operator|(
name|n
operator|&
literal|1
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	get_imm_packet - return the next ingress packet buffer from a response  *	@resp: the response descriptor containing the packet data  *  *	Return a packet containing the immediate data of the given response.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|get_imm_packet
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|rsp_desc
modifier|*
name|resp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|void
modifier|*
name|cl
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|uint32_t
name|flags
init|=
name|ntohl
argument_list|(
name|resp
operator|->
name|flags
argument_list|)
decl_stmt|;
name|uint8_t
name|sopeop
init|=
name|G_RSPD_SOP_EOP
argument_list|(
name|flags
argument_list|)
decl_stmt|;
comment|/* 	 * would be a firmware bug 	 */
if|if
condition|(
name|sopeop
operator|==
name|RSPQ_NSOP_NEOP
operator|||
name|sopeop
operator|==
name|RSPQ_SOP
condition|)
return|return;
name|len
operator|=
name|G_RSPD_LEN
argument_list|(
name|ntohl
argument_list|(
name|resp
operator|->
name|len_cq
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sopeop
condition|)
block|{
case|case
name|RSPQ_SOP_EOP
case|:
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|m
operator|->
name|m_data
argument_list|,
name|resp
operator|->
name|imm_data
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|RSPQ_EOP
case|:
name|memcpy
argument_list|(
name|cl
argument_list|,
name|resp
operator|->
name|imm_data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|m_iovappend
argument_list|(
name|m
argument_list|,
name|cl
argument_list|,
name|MSIZE
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|u_int
name|flits_to_desc
parameter_list|(
name|u_int
name|n
parameter_list|)
block|{
return|return
operator|(
name|flit_desc_map
index|[
name|n
index|]
operator|)
return|;
block|}
end_function

begin_function
name|void
name|t3_sge_err_intr_handler
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
name|unsigned
name|int
name|v
decl_stmt|,
name|status
decl_stmt|;
name|status
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_INT_CAUSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|F_RSPQCREDITOVERFOW
condition|)
name|CH_ALERT
argument_list|(
name|adapter
argument_list|,
literal|"SGE response queue credit overflow\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|F_RSPQDISABLED
condition|)
block|{
name|v
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_RSPQ_FL_STATUS
argument_list|)
expr_stmt|;
name|CH_ALERT
argument_list|(
name|adapter
argument_list|,
literal|"packet delivered to disabled response queue (0x%x)\n"
argument_list|,
operator|(
name|v
operator|>>
name|S_RSPQ0DISABLED
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_INT_CAUSE
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
operator|(
name|F_RSPQCREDITOVERFOW
operator||
name|F_RSPQDISABLED
operator|)
condition|)
name|t3_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t3_sge_prep
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|struct
name|sge_params
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* XXX Does ETHER_ALIGN need to be accounted for here? */
name|p
operator|->
name|max_pkt_size
operator|=
name|MJUM16BYTES
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|cpl_rx_data
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SGE_QSETS
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|qset_params
modifier|*
name|q
init|=
name|p
operator|->
name|qset
operator|+
name|i
decl_stmt|;
name|q
operator|->
name|polling
operator|=
name|adap
operator|->
name|params
operator|.
name|rev
operator|>
literal|0
expr_stmt|;
name|q
operator|->
name|coalesce_nsecs
operator|=
literal|5000
expr_stmt|;
name|q
operator|->
name|rspq_size
operator|=
name|RSPQ_Q_SIZE
expr_stmt|;
name|q
operator|->
name|fl_size
operator|=
name|FL_Q_SIZE
expr_stmt|;
name|q
operator|->
name|jumbo_size
operator|=
name|JUMBO_Q_SIZE
expr_stmt|;
name|q
operator|->
name|txq_size
index|[
name|TXQ_ETH
index|]
operator|=
name|TX_ETH_Q_SIZE
expr_stmt|;
name|q
operator|->
name|txq_size
index|[
name|TXQ_OFLD
index|]
operator|=
literal|1024
expr_stmt|;
name|q
operator|->
name|txq_size
index|[
name|TXQ_CTRL
index|]
operator|=
literal|256
expr_stmt|;
name|q
operator|->
name|cong_thres
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|t3_sge_alloc
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|)
block|{
comment|/* The parent tag. */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* maxsize */
name|BUS_SPACE_UNRESTRICTED
argument_list|,
comment|/* nsegments */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lock, lockarg */
operator|&
name|sc
operator|->
name|parent_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot allocate parent DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* 	 * DMA tag for normal sized RX frames 	 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_dmat
argument_list|,
name|MCLBYTES
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MCLBYTES
argument_list|,
literal|1
argument_list|,
name|MCLBYTES
argument_list|,
name|BUS_DMA_ALLOCNOW
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|rx_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot allocate RX DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/*  	 * DMA tag for jumbo sized RX frames. 	 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_dmat
argument_list|,
name|MJUMPAGESIZE
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MJUMPAGESIZE
argument_list|,
literal|1
argument_list|,
name|MJUMPAGESIZE
argument_list|,
name|BUS_DMA_ALLOCNOW
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|rx_jumbo_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot allocate RX jumbo DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/*  	 * DMA tag for TX frames. 	 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_dmat
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|TX_MAX_SIZE
argument_list|,
name|TX_MAX_SEGS
argument_list|,
name|TX_MAX_SIZE
argument_list|,
name|BUS_DMA_ALLOCNOW
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|tx_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot allocate TX DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t3_sge_free
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|tx_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|tx_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rx_jumbo_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|rx_jumbo_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rx_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|rx_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|parent_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|t3_update_qset_coalesce
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
specifier|const
name|struct
name|qset_params
modifier|*
name|p
parameter_list|)
block|{
name|qs
operator|->
name|rspq
operator|.
name|holdoff_tmr
operator|=
name|max
argument_list|(
name|p
operator|->
name|coalesce_nsecs
operator|/
literal|100
argument_list|,
literal|1U
argument_list|)
expr_stmt|;
name|qs
operator|->
name|rspq
operator|.
name|polling
operator|=
literal|0
comment|/* p->polling */
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|refill_fl_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|refill_fl_cb_arg
modifier|*
name|cb_arg
init|=
name|arg
decl_stmt|;
name|cb_arg
operator|->
name|error
operator|=
name|error
expr_stmt|;
name|cb_arg
operator|->
name|seg
operator|=
name|segs
index|[
literal|0
index|]
expr_stmt|;
name|cb_arg
operator|->
name|nseg
operator|=
name|nseg
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	refill_fl - refill an SGE free-buffer list  *	@sc: the controller softc  *	@q: the free-list to refill  *	@n: the number of new buffers to allocate  *  *	(Re)populate an SGE free-buffer list with up to @n new packet buffers.  *	The caller must assure that @n does not exceed the queue's capacity.  */
end_comment

begin_function
specifier|static
name|void
name|refill_fl
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_fl
modifier|*
name|q
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|struct
name|rx_sw_desc
modifier|*
name|sd
init|=
operator|&
name|q
operator|->
name|sdesc
index|[
name|q
operator|->
name|pidx
index|]
decl_stmt|;
name|struct
name|rx_desc
modifier|*
name|d
init|=
operator|&
name|q
operator|->
name|desc
index|[
name|q
operator|->
name|pidx
index|]
decl_stmt|;
name|struct
name|refill_fl_cb_arg
name|cb_arg
decl_stmt|;
name|void
modifier|*
name|cl
decl_stmt|;
name|int
name|err
decl_stmt|;
name|cb_arg
operator|.
name|error
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
comment|/* 		 * We only allocate a cluster, mbuf allocation happens after rx 		 */
if|if
condition|(
operator|(
name|cl
operator|=
name|m_cljget
argument_list|(
name|NULL
argument_list|,
name|M_DONTWAIT
argument_list|,
name|q
operator|->
name|buf_size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"Failed to allocate cluster\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|(
name|sd
operator|->
name|flags
operator|&
name|RX_SW_DESC_MAP_CREATED
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|bus_dmamap_create
argument_list|(
name|q
operator|->
name|entry_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|sd
operator|->
name|map
argument_list|)
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"bus_dmamap_create failed %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|q
operator|->
name|zone
argument_list|,
name|cl
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|sd
operator|->
name|flags
operator||=
name|RX_SW_DESC_MAP_CREATED
expr_stmt|;
block|}
name|err
operator|=
name|bus_dmamap_load
argument_list|(
name|q
operator|->
name|entry_tag
argument_list|,
name|sd
operator|->
name|map
argument_list|,
name|cl
argument_list|,
name|q
operator|->
name|buf_size
argument_list|,
name|refill_fl_cb
argument_list|,
operator|&
name|cb_arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|||
name|cb_arg
operator|.
name|error
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"failure in refill_fl %d\n"
argument_list|,
name|cb_arg
operator|.
name|error
argument_list|)
expr_stmt|;
comment|/* 			 * XXX free cluster 			 */
return|return;
block|}
name|sd
operator|->
name|flags
operator||=
name|RX_SW_DESC_INUSE
expr_stmt|;
name|sd
operator|->
name|cl
operator|=
name|cl
expr_stmt|;
name|d
operator|->
name|addr_lo
operator|=
name|htobe32
argument_list|(
name|cb_arg
operator|.
name|seg
operator|.
name|ds_addr
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|d
operator|->
name|addr_hi
operator|=
name|htobe32
argument_list|(
operator|(
operator|(
name|uint64_t
operator|)
name|cb_arg
operator|.
name|seg
operator|.
name|ds_addr
operator|>>
literal|32
operator|)
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|d
operator|->
name|len_gen
operator|=
name|htobe32
argument_list|(
name|V_FLD_GEN1
argument_list|(
name|q
operator|->
name|gen
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|gen2
operator|=
name|htobe32
argument_list|(
name|V_FLD_GEN2
argument_list|(
name|q
operator|->
name|gen
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
name|sd
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|q
operator|->
name|pidx
operator|==
name|q
operator|->
name|size
condition|)
block|{
name|q
operator|->
name|pidx
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|gen
operator|^=
literal|1
expr_stmt|;
name|sd
operator|=
name|q
operator|->
name|sdesc
expr_stmt|;
name|d
operator|=
name|q
operator|->
name|desc
expr_stmt|;
block|}
name|q
operator|->
name|credits
operator|++
expr_stmt|;
block|}
name|done
label|:
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|A_SG_KDOORBELL
argument_list|,
name|V_EGRCNTX
argument_list|(
name|q
operator|->
name|cntxt_id
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	free_rx_bufs - free the Rx buffers on an SGE free list  *	@sc: the controle softc  *	@q: the SGE free list to clean up  *  *	Release the buffers on an SGE free-buffer Rx queue.  HW fetching from  *	this queue should be stopped before calling this function.  */
end_comment

begin_function
specifier|static
name|void
name|free_rx_bufs
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_fl
modifier|*
name|q
parameter_list|)
block|{
name|u_int
name|cidx
init|=
name|q
operator|->
name|cidx
decl_stmt|;
while|while
condition|(
name|q
operator|->
name|credits
operator|--
condition|)
block|{
name|struct
name|rx_sw_desc
modifier|*
name|d
init|=
operator|&
name|q
operator|->
name|sdesc
index|[
name|cidx
index|]
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|RX_SW_DESC_INUSE
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|q
operator|->
name|entry_tag
argument_list|,
name|d
operator|->
name|map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|q
operator|->
name|entry_tag
argument_list|,
name|d
operator|->
name|map
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|q
operator|->
name|zone
argument_list|,
name|d
operator|->
name|cl
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|cl
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|++
name|cidx
operator|==
name|q
operator|->
name|size
condition|)
name|cidx
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|__refill_fl
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|struct
name|sge_fl
modifier|*
name|fl
parameter_list|)
block|{
name|refill_fl
argument_list|(
name|adap
argument_list|,
name|fl
argument_list|,
name|min
argument_list|(
literal|16U
argument_list|,
name|fl
operator|->
name|size
operator|-
name|fl
operator|->
name|credits
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	recycle_rx_buf - recycle a receive buffer  *	@adapter: the adapter  *	@q: the SGE free list  *	@idx: index of buffer to recycle  *  *	Recycles the specified buffer on the given free list by adding it at  *	the next available slot on the list.  */
end_comment

begin_function
specifier|static
name|void
name|recycle_rx_buf
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|struct
name|sge_fl
modifier|*
name|q
parameter_list|,
name|unsigned
name|int
name|idx
parameter_list|)
block|{
name|struct
name|rx_desc
modifier|*
name|from
init|=
operator|&
name|q
operator|->
name|desc
index|[
name|idx
index|]
decl_stmt|;
name|struct
name|rx_desc
modifier|*
name|to
init|=
operator|&
name|q
operator|->
name|desc
index|[
name|q
operator|->
name|pidx
index|]
decl_stmt|;
name|q
operator|->
name|sdesc
index|[
name|q
operator|->
name|pidx
index|]
operator|=
name|q
operator|->
name|sdesc
index|[
name|idx
index|]
expr_stmt|;
name|to
operator|->
name|addr_lo
operator|=
name|from
operator|->
name|addr_lo
expr_stmt|;
comment|// already big endian
name|to
operator|->
name|addr_hi
operator|=
name|from
operator|->
name|addr_hi
expr_stmt|;
comment|// likewise
name|wmb
argument_list|()
expr_stmt|;
name|to
operator|->
name|len_gen
operator|=
name|htobe32
argument_list|(
name|V_FLD_GEN1
argument_list|(
name|q
operator|->
name|gen
argument_list|)
argument_list|)
expr_stmt|;
name|to
operator|->
name|gen2
operator|=
name|htobe32
argument_list|(
name|V_FLD_GEN2
argument_list|(
name|q
operator|->
name|gen
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|credits
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|q
operator|->
name|pidx
operator|==
name|q
operator|->
name|size
condition|)
block|{
name|q
operator|->
name|pidx
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|gen
operator|^=
literal|1
expr_stmt|;
block|}
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_KDOORBELL
argument_list|,
name|V_EGRCNTX
argument_list|(
name|q
operator|->
name|cntxt_id
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|alloc_ring_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|uint32_t
modifier|*
name|addr
decl_stmt|;
name|addr
operator|=
name|arg
expr_stmt|;
operator|*
name|addr
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|alloc_ring
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|,
name|size_t
name|nelem
parameter_list|,
name|size_t
name|elem_size
parameter_list|,
name|size_t
name|sw_size
parameter_list|,
name|bus_addr_t
modifier|*
name|phys
parameter_list|,
name|void
modifier|*
name|desc
parameter_list|,
name|void
modifier|*
name|sdesc
parameter_list|,
name|bus_dma_tag_t
modifier|*
name|tag
parameter_list|,
name|bus_dmamap_t
modifier|*
name|map
parameter_list|,
name|bus_dma_tag_t
name|parent_entry_tag
parameter_list|,
name|bus_dma_tag_t
modifier|*
name|entry_tag
parameter_list|)
block|{
name|size_t
name|len
init|=
name|nelem
operator|*
name|elem_size
decl_stmt|;
name|void
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_dmat
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|tag
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot allocate descriptor tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|bus_dmamem_alloc
argument_list|(
operator|*
name|tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|p
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
name|map
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot allocate descriptor memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bus_dmamap_load
argument_list|(
operator|*
name|tag
argument_list|,
operator|*
name|map
argument_list|,
name|p
argument_list|,
name|len
argument_list|,
name|alloc_ring_cb
argument_list|,
name|phys
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
operator|(
name|void
operator|*
operator|*
operator|)
name|desc
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|sw_size
condition|)
block|{
name|len
operator|=
name|nelem
operator|*
name|sw_size
expr_stmt|;
name|s
operator|=
name|malloc
argument_list|(
name|len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
operator|(
name|void
operator|*
operator|*
operator|)
name|sdesc
operator|=
name|s
expr_stmt|;
block|}
if|if
condition|(
name|parent_entry_tag
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|err
operator|=
name|bus_dma_tag_create
argument_list|(
name|parent_entry_tag
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|TX_MAX_SIZE
argument_list|,
name|TX_MAX_SEGS
argument_list|,
name|TX_MAX_SIZE
argument_list|,
name|BUS_DMA_ALLOCNOW
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|entry_tag
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot allocate descriptor entry tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sge_slow_intr_handler
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|ncount
parameter_list|)
block|{
name|adapter_t
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|t3_slow_intr_handler
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sge_timer_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|adapter_t
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|sge_qset
modifier|*
name|qs
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|reclaim_eth
decl_stmt|,
name|reclaim_ofl
decl_stmt|,
name|refill_rx
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|params
operator|.
name|nports
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sc
operator|->
name|port
index|[
name|i
index|]
operator|.
name|nqsets
condition|;
name|j
operator|++
control|)
block|{
name|qs
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
name|i
operator|+
name|j
index|]
expr_stmt|;
name|txq
operator|=
operator|&
name|qs
operator|->
name|txq
index|[
literal|0
index|]
expr_stmt|;
name|reclaim_eth
operator|=
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|processed
operator|-
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|cleaned
expr_stmt|;
name|reclaim_ofl
operator|=
name|txq
index|[
name|TXQ_OFLD
index|]
operator|.
name|processed
operator|-
name|txq
index|[
name|TXQ_OFLD
index|]
operator|.
name|cleaned
expr_stmt|;
name|refill_rx
operator|=
operator|(
operator|(
name|qs
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|credits
operator|<
name|qs
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|size
operator|)
operator|||
operator|(
name|qs
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|credits
operator|<
name|qs
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|size
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|reclaim_eth
operator|||
name|reclaim_ofl
operator|||
name|refill_rx
condition|)
block|{
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|sc
operator|->
name|timer_reclaim_task
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|done
label|:
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sge_timer_ch
argument_list|,
name|TX_RECLAIM_PERIOD
argument_list|,
name|sge_timer_cb
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is meant to be a catch-all function to keep sge state private  * to sge.c  *  */
end_comment

begin_function
name|int
name|t3_sge_init_sw
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|)
block|{
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sge_timer_ch
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sge_timer_ch
argument_list|,
name|TX_RECLAIM_PERIOD
argument_list|,
name|sge_timer_cb
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|timer_reclaim_task
argument_list|,
literal|0
argument_list|,
name|sge_timer_reclaim
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|slow_intr_task
argument_list|,
literal|0
argument_list|,
name|sge_slow_intr_handler
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|t3_sge_deinit_sw
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|)
block|{
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sge_timer_ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tq
condition|)
block|{
name|taskqueue_drain
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|sc
operator|->
name|timer_reclaim_task
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|sc
operator|->
name|slow_intr_task
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	refill_rspq - replenish an SGE response queue  *	@adapter: the adapter  *	@q: the response queue to replenish  *	@credits: how many new responses to make available  *  *	Replenishes a response queue by making the supplied number of responses  *	available to HW.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|refill_rspq
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|sge_rspq
modifier|*
name|q
parameter_list|,
name|u_int
name|credits
parameter_list|)
block|{
comment|/* mbufs are allocated on demand when a rspq entry is processed. */
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|A_SG_RSPQ_CREDIT_RETURN
argument_list|,
name|V_RSPQ
argument_list|(
name|q
operator|->
name|cntxt_id
argument_list|)
operator||
name|V_CREDITS
argument_list|(
name|credits
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sge_timer_reclaim
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|ncount
parameter_list|)
block|{
name|adapter_t
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nqsets
init|=
literal|0
decl_stmt|;
name|struct
name|sge_qset
modifier|*
name|qs
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
name|struct
name|mtx
modifier|*
name|lock
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_vec
index|[
name|TX_CLEAN_MAX_DESC
index|]
decl_stmt|;
name|int
name|n
decl_stmt|,
name|reclaimable
decl_stmt|;
comment|/*  	 * XXX assuming these quantities are allowed to change during operation 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|params
operator|.
name|nports
condition|;
name|i
operator|++
control|)
name|nqsets
operator|+=
name|sc
operator|->
name|port
index|[
name|i
index|]
operator|.
name|nqsets
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nqsets
condition|;
name|i
operator|++
control|)
block|{
name|qs
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
name|i
index|]
expr_stmt|;
name|txq
operator|=
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
expr_stmt|;
name|reclaimable
operator|=
name|desc_reclaimable
argument_list|(
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|reclaimable
operator|>
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|txq
operator|->
name|lock
argument_list|)
expr_stmt|;
name|n
operator|=
name|reclaim_completed_tx
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|,
name|TX_CLEAN_MAX_DESC
argument_list|,
name|m_vec
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|txq
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|m_freem_vec
argument_list|(
name|m_vec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qs
operator|->
name|port
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_OACTIVE
operator|&&
name|txq
operator|->
name|size
operator|-
name|txq
operator|->
name|in_use
operator|>=
name|TX_START_MAX_DESC
condition|)
block|{
name|qs
operator|->
name|port
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|qs
operator|->
name|port
operator|->
name|tq
argument_list|,
operator|&
name|qs
operator|->
name|port
operator|->
name|start_task
argument_list|)
expr_stmt|;
block|}
block|}
name|txq
operator|=
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
expr_stmt|;
name|reclaimable
operator|=
name|desc_reclaimable
argument_list|(
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|reclaimable
operator|>
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|txq
operator|->
name|lock
argument_list|)
expr_stmt|;
name|n
operator|=
name|reclaim_completed_tx
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|,
name|TX_CLEAN_MAX_DESC
argument_list|,
name|m_vec
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|txq
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|m_freem_vec
argument_list|(
name|m_vec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|lock
operator|=
operator|(
name|sc
operator|->
name|flags
operator|&
name|USING_MSIX
operator|)
condition|?
operator|&
name|qs
operator|->
name|rspq
operator|.
name|lock
else|:
operator|&
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
literal|0
index|]
operator|.
name|rspq
operator|.
name|lock
expr_stmt|;
if|if
condition|(
name|mtx_trylock
argument_list|(
name|lock
argument_list|)
condition|)
block|{
comment|/* XXX currently assume that we are *NOT* polling */
name|uint32_t
name|status
init|=
name|t3_read_reg
argument_list|(
name|sc
argument_list|,
name|A_SG_RSPQ_FL_STATUS
argument_list|)
decl_stmt|;
if|if
condition|(
name|qs
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|credits
operator|<
name|qs
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|size
operator|-
literal|16
condition|)
name|__refill_fl
argument_list|(
name|sc
argument_list|,
operator|&
name|qs
operator|->
name|fl
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|qs
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|credits
operator|<
name|qs
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|size
operator|-
literal|16
condition|)
name|__refill_fl
argument_list|(
name|sc
argument_list|,
operator|&
name|qs
operator|->
name|fl
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
operator|(
literal|1
operator|<<
name|qs
operator|->
name|rspq
operator|.
name|cntxt_id
operator|)
condition|)
block|{
if|if
condition|(
name|qs
operator|->
name|rspq
operator|.
name|credits
condition|)
block|{
name|refill_rspq
argument_list|(
name|sc
argument_list|,
operator|&
name|qs
operator|->
name|rspq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|qs
operator|->
name|rspq
operator|.
name|credits
operator|--
expr_stmt|;
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|A_SG_RSPQ_FL_STATUS
argument_list|,
literal|1
operator|<<
name|qs
operator|->
name|rspq
operator|.
name|cntxt_id
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  *	init_qset_cntxt - initialize an SGE queue set context info  *	@qs: the queue set  *	@id: the queue set id  *  *	Initializes the TIDs and context ids for the queues of a queue set.  */
end_comment

begin_function
specifier|static
name|void
name|init_qset_cntxt
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|u_int
name|id
parameter_list|)
block|{
name|qs
operator|->
name|rspq
operator|.
name|cntxt_id
operator|=
name|id
expr_stmt|;
name|qs
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|cntxt_id
operator|=
literal|2
operator|*
name|id
expr_stmt|;
name|qs
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|cntxt_id
operator|=
literal|2
operator|*
name|id
operator|+
literal|1
expr_stmt|;
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|cntxt_id
operator|=
name|FW_TUNNEL_SGEEC_START
operator|+
name|id
expr_stmt|;
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|token
operator|=
name|FW_TUNNEL_TID_START
operator|+
name|id
expr_stmt|;
name|qs
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
operator|.
name|cntxt_id
operator|=
name|FW_OFLD_SGEEC_START
operator|+
name|id
expr_stmt|;
name|qs
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
operator|.
name|cntxt_id
operator|=
name|FW_CTRL_SGEEC_START
operator|+
name|id
expr_stmt|;
name|qs
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
operator|.
name|token
operator|=
name|FW_CTRL_TID_START
operator|+
name|id
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|txq_prod
parameter_list|(
name|struct
name|sge_txq
modifier|*
name|txq
parameter_list|,
name|unsigned
name|int
name|ndesc
parameter_list|,
name|struct
name|txq_state
modifier|*
name|txqs
parameter_list|)
block|{
name|txq
operator|->
name|in_use
operator|+=
name|ndesc
expr_stmt|;
comment|/* 	 * XXX we don't handle stopping of queue 	 * presumably start handles this when we bump against the end 	 */
name|txqs
operator|->
name|gen
operator|=
name|txq
operator|->
name|gen
expr_stmt|;
name|txq
operator|->
name|unacked
operator|+=
name|ndesc
expr_stmt|;
name|txqs
operator|->
name|compl
operator|=
operator|(
name|txq
operator|->
name|unacked
operator|&
literal|8
operator|)
operator|<<
operator|(
name|S_WR_COMPL
operator|-
literal|3
operator|)
expr_stmt|;
name|txq
operator|->
name|unacked
operator|&=
literal|7
expr_stmt|;
name|txqs
operator|->
name|pidx
operator|=
name|txq
operator|->
name|pidx
expr_stmt|;
name|txq
operator|->
name|pidx
operator|+=
name|ndesc
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|pidx
operator|>=
name|txq
operator|->
name|size
condition|)
block|{
name|txq
operator|->
name|pidx
operator|-=
name|txq
operator|->
name|size
expr_stmt|;
name|txq
operator|->
name|gen
operator|^=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	calc_tx_descs - calculate the number of Tx descriptors for a packet  *	@m: the packet mbufs  *      @nsegs: the number of segments   *  * 	Returns the number of Tx descriptors needed for the given Ethernet  * 	packet.  Ethernet packets require addition of WR and CPL headers.  */
end_comment

begin_function
specifier|static
name|__inline
name|unsigned
name|int
name|calc_tx_descs
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|nsegs
parameter_list|)
block|{
name|unsigned
name|int
name|flits
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<=
name|WR_LEN
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|cpl_tx_pkt
argument_list|)
condition|)
return|return
literal|1
return|;
name|flits
operator|=
name|sgl_len
argument_list|(
name|nsegs
argument_list|)
operator|+
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|TSO_SUPPORTED
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_TSO
operator|)
condition|)
name|flits
operator|++
expr_stmt|;
endif|#
directive|endif
return|return
name|flits_to_desc
argument_list|(
name|flits
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|busdma_map_mbufs
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|,
name|struct
name|sge_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|tx_sw_desc
modifier|*
name|stx
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
modifier|*
name|nsegs
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|int
name|err
decl_stmt|,
name|pktlen
decl_stmt|;
name|m0
operator|=
operator|*
name|m
expr_stmt|;
name|pktlen
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|err
operator|=
name|bus_dmamap_load_mvec_sg
argument_list|(
name|txq
operator|->
name|entry_tag
argument_list|,
name|stx
operator|->
name|map
argument_list|,
name|m0
argument_list|,
name|segs
argument_list|,
name|nsegs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|err
condition|)
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mtmp
init|=
name|m0
decl_stmt|;
while|while
condition|(
name|mtmp
condition|)
block|{
name|n
operator|++
expr_stmt|;
name|mtmp
operator|=
name|mtmp
operator|->
name|m_next
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"map_mbufs: bus_dmamap_load_mbuf_sg failed with %d - pkthdr.len==%d nmbufs=%d\n"
argument_list|,
name|err
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|err
operator|==
name|EFBIG
condition|)
block|{
comment|/* Too many segments, try to defrag */
name|m0
operator|=
name|m_defrag
argument_list|(
name|m0
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|m
argument_list|)
expr_stmt|;
operator|*
name|m
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
operator|*
name|m
operator|=
name|m0
expr_stmt|;
name|err
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|txq
operator|->
name|entry_tag
argument_list|,
name|stx
operator|->
name|map
argument_list|,
name|m0
argument_list|,
name|segs
argument_list|,
name|nsegs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
name|ENOMEM
condition|)
block|{
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|cxgb_debug
condition|)
name|printf
argument_list|(
literal|"map failure err=%d pktlen=%d\n"
argument_list|,
name|err
argument_list|,
name|pktlen
argument_list|)
expr_stmt|;
name|m_freem_vec
argument_list|(
name|m0
argument_list|)
expr_stmt|;
operator|*
name|m
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|bus_dmamap_sync
argument_list|(
name|txq
operator|->
name|entry_tag
argument_list|,
name|stx
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|stx
operator|->
name|flags
operator||=
name|TX_SW_DESC_MAPPED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	make_sgl - populate a scatter/gather list for a packet  *	@sgp: the SGL to populate  *	@segs: the packet dma segments  *	@nsegs: the number of segments  *  *	Generates a scatter/gather list for the buffers that make up a packet  *	and returns the SGL size in 8-byte words.  The caller must size the SGL  *	appropriately.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|make_sgl
parameter_list|(
name|struct
name|sg_ent
modifier|*
name|sgp
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|idx
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsegs
condition|;
name|i
operator|++
operator|,
name|idx
operator|^=
literal|1
control|)
block|{
if|if
condition|(
name|i
operator|&&
name|idx
operator|==
literal|0
condition|)
operator|++
name|sgp
expr_stmt|;
name|sgp
operator|->
name|len
index|[
name|idx
index|]
operator|=
name|htobe32
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
name|sgp
operator|->
name|addr
index|[
name|idx
index|]
operator|=
name|htobe64
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|idx
condition|)
name|sgp
operator|->
name|len
index|[
name|idx
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	check_ring_tx_db - check and potentially ring a Tx queue's doorbell  *	@adap: the adapter  *	@q: the Tx queue  *  *	Ring the doorbel if a Tx queue is asleep.  There is a natural race,  *	where the HW is going to sleep just after we checked, however,  *	then the interrupt handler will detect the outstanding TX packet  *	and ring the doorbell for us.  *  *	When GTS is disabled we unconditionally ring the doorbell.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|check_ring_tx_db
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|struct
name|sge_txq
modifier|*
name|q
parameter_list|)
block|{
if|#
directive|if
name|USE_GTS
name|clear_bit
argument_list|(
name|TXQ_LAST_PKT_DB
argument_list|,
operator|&
name|q
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|test_and_set_bit
argument_list|(
name|TXQ_RUNNING
argument_list|,
operator|&
name|q
operator|->
name|flags
argument_list|)
operator|==
literal|0
condition|)
block|{
name|set_bit
argument_list|(
name|TXQ_LAST_PKT_DB
argument_list|,
operator|&
name|q
operator|->
name|flags
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|T3_TRACE
name|T3_TRACE1
argument_list|(
name|adap
operator|->
name|tb
index|[
name|q
operator|->
name|cntxt_id
operator|&
literal|7
index|]
argument_list|,
literal|"doorbell Tx, cntxt %d"
argument_list|,
name|q
operator|->
name|cntxt_id
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_KDOORBELL
argument_list|,
name|F_SELEGRCNTX
operator||
name|V_EGRCNTX
argument_list|(
name|q
operator|->
name|cntxt_id
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|wmb
argument_list|()
expr_stmt|;
comment|/* write descriptors before telling HW */
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_KDOORBELL
argument_list|,
name|F_SELEGRCNTX
operator||
name|V_EGRCNTX
argument_list|(
name|q
operator|->
name|cntxt_id
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|wr_gen2
parameter_list|(
name|struct
name|tx_desc
modifier|*
name|d
parameter_list|,
name|unsigned
name|int
name|gen
parameter_list|)
block|{
if|#
directive|if
name|SGE_NUM_GENBITS
operator|==
literal|2
name|d
operator|->
name|flit
index|[
name|TX_DESC_FLITS
operator|-
literal|1
index|]
operator|=
name|htobe64
argument_list|(
name|gen
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/**  *	write_wr_hdr_sgl - write a WR header and, optionally, SGL  *	@ndesc: number of Tx descriptors spanned by the SGL  *	@txd: first Tx descriptor to be written  *	@txqs: txq state (generation and producer index)  *	@txq: the SGE Tx queue  *	@sgl: the SGL  *	@flits: number of flits to the start of the SGL in the first descriptor  *	@sgl_flits: the SGL size in flits  *	@wr_hi: top 32 bits of WR header based on WR type (big endian)  *	@wr_lo: low 32 bits of WR header based on WR type (big endian)  *  *	Write a work request header and an associated SGL.  If the SGL is  *	small enough to fit into one Tx descriptor it has already been written  *	and we just need to write the WR header.  Otherwise we distribute the  *	SGL across the number of descriptors it spans.  */
end_comment

begin_function
specifier|static
name|void
name|write_wr_hdr_sgl
parameter_list|(
name|unsigned
name|int
name|ndesc
parameter_list|,
name|struct
name|tx_desc
modifier|*
name|txd
parameter_list|,
name|struct
name|txq_state
modifier|*
name|txqs
parameter_list|,
specifier|const
name|struct
name|sge_txq
modifier|*
name|txq
parameter_list|,
specifier|const
name|struct
name|sg_ent
modifier|*
name|sgl
parameter_list|,
name|unsigned
name|int
name|flits
parameter_list|,
name|unsigned
name|int
name|sgl_flits
parameter_list|,
name|unsigned
name|int
name|wr_hi
parameter_list|,
name|unsigned
name|int
name|wr_lo
parameter_list|)
block|{
name|struct
name|work_request_hdr
modifier|*
name|wrp
init|=
operator|(
expr|struct
name|work_request_hdr
operator|*
operator|)
name|txd
decl_stmt|;
name|struct
name|tx_sw_desc
modifier|*
name|txsd
init|=
operator|&
name|txq
operator|->
name|sdesc
index|[
name|txqs
operator|->
name|pidx
index|]
decl_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
name|ndesc
operator|==
literal|1
argument_list|)
condition|)
block|{
name|wrp
operator|->
name|wr_hi
operator|=
name|htonl
argument_list|(
name|F_WR_SOP
operator||
name|F_WR_EOP
operator||
name|V_WR_DATATYPE
argument_list|(
literal|1
argument_list|)
operator||
name|V_WR_SGLSFLT
argument_list|(
name|flits
argument_list|)
argument_list|)
operator||
name|wr_hi
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
name|wrp
operator|->
name|wr_lo
operator|=
name|htonl
argument_list|(
name|V_WR_LEN
argument_list|(
name|flits
operator|+
name|sgl_flits
argument_list|)
operator||
name|V_WR_GEN
argument_list|(
name|txqs
operator|->
name|gen
argument_list|)
argument_list|)
operator||
name|wr_lo
expr_stmt|;
comment|/* XXX gen? */
name|wr_gen2
argument_list|(
name|txd
argument_list|,
name|txqs
operator|->
name|gen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|int
name|ogen
init|=
name|txqs
operator|->
name|gen
decl_stmt|;
specifier|const
name|uint64_t
modifier|*
name|fp
init|=
operator|(
specifier|const
name|uint64_t
operator|*
operator|)
name|sgl
decl_stmt|;
name|struct
name|work_request_hdr
modifier|*
name|wp
init|=
name|wrp
decl_stmt|;
name|wrp
operator|->
name|wr_hi
operator|=
name|htonl
argument_list|(
name|F_WR_SOP
operator||
name|V_WR_DATATYPE
argument_list|(
literal|1
argument_list|)
operator||
name|V_WR_SGLSFLT
argument_list|(
name|flits
argument_list|)
argument_list|)
operator||
name|wr_hi
expr_stmt|;
while|while
condition|(
name|sgl_flits
condition|)
block|{
name|unsigned
name|int
name|avail
init|=
name|WR_FLITS
operator|-
name|flits
decl_stmt|;
if|if
condition|(
name|avail
operator|>
name|sgl_flits
condition|)
name|avail
operator|=
name|sgl_flits
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|txd
operator|->
name|flit
index|[
name|flits
index|]
argument_list|,
name|fp
argument_list|,
name|avail
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|fp
argument_list|)
argument_list|)
expr_stmt|;
name|sgl_flits
operator|-=
name|avail
expr_stmt|;
name|ndesc
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|sgl_flits
condition|)
break|break;
name|fp
operator|+=
name|avail
expr_stmt|;
name|txd
operator|++
expr_stmt|;
name|txsd
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|txqs
operator|->
name|pidx
operator|==
name|txq
operator|->
name|size
condition|)
block|{
name|txqs
operator|->
name|pidx
operator|=
literal|0
expr_stmt|;
name|txqs
operator|->
name|gen
operator|^=
literal|1
expr_stmt|;
name|txd
operator|=
name|txq
operator|->
name|desc
expr_stmt|;
name|txsd
operator|=
name|txq
operator|->
name|sdesc
expr_stmt|;
block|}
comment|/* 			 * when the head of the mbuf chain 			 * is freed all clusters will be freed 			 * with it 			 */
name|txsd
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|wrp
operator|=
operator|(
expr|struct
name|work_request_hdr
operator|*
operator|)
name|txd
expr_stmt|;
name|wrp
operator|->
name|wr_hi
operator|=
name|htonl
argument_list|(
name|V_WR_DATATYPE
argument_list|(
literal|1
argument_list|)
operator||
name|V_WR_SGLSFLT
argument_list|(
literal|1
argument_list|)
argument_list|)
operator||
name|wr_hi
expr_stmt|;
name|wrp
operator|->
name|wr_lo
operator|=
name|htonl
argument_list|(
name|V_WR_LEN
argument_list|(
name|min
argument_list|(
name|WR_FLITS
argument_list|,
name|sgl_flits
operator|+
literal|1
argument_list|)
argument_list|)
operator||
name|V_WR_GEN
argument_list|(
name|txqs
operator|->
name|gen
argument_list|)
argument_list|)
operator||
name|wr_lo
expr_stmt|;
name|wr_gen2
argument_list|(
name|txd
argument_list|,
name|txqs
operator|->
name|gen
argument_list|)
expr_stmt|;
name|flits
operator|=
literal|1
expr_stmt|;
block|}
name|wrp
operator|->
name|wr_hi
operator||=
name|htonl
argument_list|(
name|F_WR_EOP
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
name|wp
operator|->
name|wr_lo
operator|=
name|htonl
argument_list|(
name|V_WR_LEN
argument_list|(
name|WR_FLITS
argument_list|)
operator||
name|V_WR_GEN
argument_list|(
name|ogen
argument_list|)
argument_list|)
operator||
name|wr_lo
expr_stmt|;
name|wr_gen2
argument_list|(
operator|(
expr|struct
name|tx_desc
operator|*
operator|)
name|wp
argument_list|,
name|ogen
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* sizeof(*eh) + sizeof(*vhdr) + sizeof(*ip) + sizeof(*tcp) */
end_comment

begin_define
define|#
directive|define
name|TCPPKTHDRSIZE
value|(ETHER_HDR_LEN + ETHER_VLAN_ENCAP_LEN + 20 + 20)
end_define

begin_function
name|int
name|t3_encap
parameter_list|(
name|struct
name|port_info
modifier|*
name|p
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|)
block|{
name|adapter_t
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|struct
name|sge_qset
modifier|*
name|qs
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
name|struct
name|tx_sw_desc
modifier|*
name|stx
decl_stmt|;
name|struct
name|txq_state
name|txqs
decl_stmt|;
name|unsigned
name|int
name|nsegs
decl_stmt|,
name|ndesc
decl_stmt|,
name|flits
decl_stmt|,
name|cntrl
decl_stmt|,
name|mlen
decl_stmt|;
name|int
name|err
decl_stmt|,
name|tso_info
init|=
literal|0
decl_stmt|;
name|struct
name|work_request_hdr
modifier|*
name|wrp
decl_stmt|;
name|struct
name|tx_sw_desc
modifier|*
name|txsd
decl_stmt|;
name|struct
name|sg_ent
modifier|*
name|sgp
decl_stmt|,
name|sgl
index|[
name|TX_MAX_SEGS
operator|/
literal|2
operator|+
literal|1
index|]
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
name|TX_MAX_SEGS
index|]
decl_stmt|;
name|uint32_t
name|wr_hi
decl_stmt|,
name|wr_lo
decl_stmt|,
name|sgl_flits
decl_stmt|;
name|struct
name|tx_desc
modifier|*
name|txd
decl_stmt|;
name|struct
name|cpl_tx_pkt
modifier|*
name|cpl
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"t3_encap "
argument_list|)
expr_stmt|;
name|m0
operator|=
operator|*
name|m
expr_stmt|;
name|sc
operator|=
name|p
operator|->
name|adapter
expr_stmt|;
name|qs
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
name|p
operator|->
name|first_qset
index|]
expr_stmt|;
name|txq
operator|=
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
expr_stmt|;
name|stx
operator|=
operator|&
name|txq
operator|->
name|sdesc
index|[
name|txq
operator|->
name|pidx
index|]
expr_stmt|;
name|txd
operator|=
operator|&
name|txq
operator|->
name|desc
index|[
name|txq
operator|->
name|pidx
index|]
expr_stmt|;
name|cpl
operator|=
operator|(
expr|struct
name|cpl_tx_pkt
operator|*
operator|)
name|txd
expr_stmt|;
name|mlen
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|cpl
operator|->
name|len
operator|=
name|htonl
argument_list|(
name|mlen
operator||
literal|0x80000000
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"mlen=%d\n"
argument_list|,
name|mlen
argument_list|)
expr_stmt|;
comment|/* 	 * XXX handle checksum, TSO, and VLAN here 	 *	  	 */
name|cntrl
operator|=
name|V_TXPKT_INTF
argument_list|(
name|p
operator|->
name|port
argument_list|)
expr_stmt|;
comment|/* 	 * XXX need to add VLAN support for 6.x 	 */
ifdef|#
directive|ifdef
name|VLAN_SUPPORTED
if|if
condition|(
name|m0
operator|->
name|m_flags
operator|&
name|M_VLANTAG
condition|)
name|cntrl
operator||=
name|F_TXPKT_VLAN_VLD
operator||
name|V_TXPKT_VLAN
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_TSO
operator|)
condition|)
name|tso_info
operator|=
name|V_LSO_MSS
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tso_info
condition|)
block|{
name|int
name|eth_type
decl_stmt|;
name|struct
name|cpl_tx_pkt_lso
modifier|*
name|hdr
init|=
operator|(
expr|struct
name|cpl_tx_pkt_lso
operator|*
operator|)
name|cpl
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|tcp
decl_stmt|;
name|uint8_t
modifier|*
name|pkthdr
decl_stmt|,
name|tmp
index|[
name|TCPPKTHDRSIZE
index|]
decl_stmt|;
comment|/* is this too large for the stack? */
name|txd
operator|->
name|flit
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|cntrl
operator||=
name|V_TXPKT_OPCODE
argument_list|(
name|CPL_TX_PKT_LSO
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|cntrl
operator|=
name|htonl
argument_list|(
name|cntrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|m0
operator|->
name|m_len
operator|<
name|TCPPKTHDRSIZE
argument_list|)
condition|)
block|{
name|pkthdr
operator|=
operator|&
name|tmp
index|[
literal|0
index|]
expr_stmt|;
name|m_copydata
argument_list|(
name|m0
argument_list|,
literal|0
argument_list|,
name|TCPPKTHDRSIZE
argument_list|,
name|pkthdr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pkthdr
operator|=
name|m0
operator|->
name|m_data
expr_stmt|;
block|}
if|if
condition|(
name|__predict_false
argument_list|(
name|m0
operator|->
name|m_flags
operator|&
name|M_VLANTAG
argument_list|)
condition|)
block|{
name|eth_type
operator|=
name|CPL_ETH_II_VLAN
expr_stmt|;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|pkthdr
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
operator|)
expr_stmt|;
block|}
else|else
block|{
name|eth_type
operator|=
name|CPL_ETH_II
expr_stmt|;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|pkthdr
operator|+
name|ETHER_HDR_LEN
operator|)
expr_stmt|;
block|}
name|tcp
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|ip
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
operator|)
expr_stmt|;
name|tso_info
operator||=
name|V_LSO_ETH_TYPE
argument_list|(
name|eth_type
argument_list|)
operator||
name|V_LSO_IPHDR_WORDS
argument_list|(
name|ip
operator|->
name|ip_hl
argument_list|)
operator||
name|V_LSO_TCPHDR_WORDS
argument_list|(
name|tcp
operator|->
name|th_off
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|lso_info
operator|=
name|htonl
argument_list|(
name|tso_info
argument_list|)
expr_stmt|;
name|flits
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|cntrl
operator||=
name|V_TXPKT_OPCODE
argument_list|(
name|CPL_TX_PKT
argument_list|)
expr_stmt|;
name|cpl
operator|->
name|cntrl
operator|=
name|htonl
argument_list|(
name|cntrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlen
operator|<=
name|WR_LEN
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|cpl
argument_list|)
condition|)
block|{
name|txq_prod
argument_list|(
name|txq
argument_list|,
literal|1
argument_list|,
operator|&
name|txqs
argument_list|)
expr_stmt|;
name|txq
operator|->
name|sdesc
index|[
name|txqs
operator|.
name|pidx
index|]
operator|.
name|m
operator|=
name|m0
expr_stmt|;
name|m_set_priority
argument_list|(
name|m0
argument_list|,
name|txqs
operator|.
name|pidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|->
name|m_len
operator|==
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
name|memcpy
argument_list|(
operator|&
name|txd
operator|->
name|flit
index|[
literal|2
index|]
argument_list|,
name|m0
operator|->
name|m_data
argument_list|,
name|mlen
argument_list|)
expr_stmt|;
else|else
name|m_copydata
argument_list|(
name|m0
argument_list|,
literal|0
argument_list|,
name|mlen
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|txd
operator|->
name|flit
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|flits
operator|=
operator|(
name|mlen
operator|+
literal|7
operator|)
operator|/
literal|8
operator|+
literal|2
expr_stmt|;
name|cpl
operator|->
name|wr
operator|.
name|wr_hi
operator|=
name|htonl
argument_list|(
name|V_WR_BCNTLFLT
argument_list|(
name|mlen
operator|&
literal|7
argument_list|)
operator||
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_TUNNEL_TX_PKT
argument_list|)
operator||
name|F_WR_SOP
operator||
name|F_WR_EOP
operator||
name|txqs
operator|.
name|compl
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
name|cpl
operator|->
name|wr
operator|.
name|wr_lo
operator|=
name|htonl
argument_list|(
name|V_WR_LEN
argument_list|(
name|flits
argument_list|)
operator||
name|V_WR_GEN
argument_list|(
name|txqs
operator|.
name|gen
argument_list|)
operator||
name|V_WR_TID
argument_list|(
name|txq
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|wr_gen2
argument_list|(
name|txd
argument_list|,
name|txqs
operator|.
name|gen
argument_list|)
expr_stmt|;
name|check_ring_tx_db
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|flits
operator|=
literal|2
expr_stmt|;
block|}
name|wrp
operator|=
operator|(
expr|struct
name|work_request_hdr
operator|*
operator|)
name|txd
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|busdma_map_mbufs
argument_list|(
name|m
argument_list|,
name|txq
argument_list|,
name|stx
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|err
operator|)
return|;
block|}
name|m0
operator|=
operator|*
name|m
expr_stmt|;
name|ndesc
operator|=
name|calc_tx_descs
argument_list|(
name|m0
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
name|sgp
operator|=
operator|(
name|ndesc
operator|==
literal|1
operator|)
condition|?
operator|(
expr|struct
name|sg_ent
operator|*
operator|)
operator|&
name|txd
operator|->
name|flit
index|[
name|flits
index|]
else|:
name|sgl
expr_stmt|;
name|make_sgl
argument_list|(
name|sgp
argument_list|,
name|segs
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
name|sgl_flits
operator|=
name|sgl_len
argument_list|(
name|nsegs
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"make_sgl success nsegs==%d ndesc==%d\n"
argument_list|,
name|nsegs
argument_list|,
name|ndesc
argument_list|)
expr_stmt|;
name|txq_prod
argument_list|(
name|txq
argument_list|,
name|ndesc
argument_list|,
operator|&
name|txqs
argument_list|)
expr_stmt|;
name|txsd
operator|=
operator|&
name|txq
operator|->
name|sdesc
index|[
name|txqs
operator|.
name|pidx
index|]
expr_stmt|;
name|wr_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_TUNNEL_TX_PKT
argument_list|)
operator||
name|txqs
operator|.
name|compl
argument_list|)
expr_stmt|;
name|wr_lo
operator|=
name|htonl
argument_list|(
name|V_WR_TID
argument_list|(
name|txq
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|txsd
operator|->
name|m
operator|=
name|m0
expr_stmt|;
name|m_set_priority
argument_list|(
name|m0
argument_list|,
name|txqs
operator|.
name|pidx
argument_list|)
expr_stmt|;
name|write_wr_hdr_sgl
argument_list|(
name|ndesc
argument_list|,
name|txd
argument_list|,
operator|&
name|txqs
argument_list|,
name|txq
argument_list|,
name|sgl
argument_list|,
name|flits
argument_list|,
name|sgl_flits
argument_list|,
name|wr_hi
argument_list|,
name|wr_lo
argument_list|)
expr_stmt|;
name|check_ring_tx_db
argument_list|(
name|p
operator|->
name|adapter
argument_list|,
name|txq
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	write_imm - write a packet into a Tx descriptor as immediate data  *	@d: the Tx descriptor to write  *	@m: the packet  *	@len: the length of packet data to write as immediate data  *	@gen: the generation bit value to write  *  *	Writes a packet as immediate data into a Tx descriptor.  The packet  *	contains a work request at its beginning.  We must write the packet  *	carefully so the SGE doesn't read accidentally before it's written in  *	its entirety.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|write_imm
parameter_list|(
name|struct
name|tx_desc
modifier|*
name|d
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|,
name|unsigned
name|int
name|gen
parameter_list|)
block|{
name|struct
name|work_request_hdr
modifier|*
name|from
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|work_request_hdr
operator|*
argument_list|)
decl_stmt|;
name|struct
name|work_request_hdr
modifier|*
name|to
init|=
operator|(
expr|struct
name|work_request_hdr
operator|*
operator|)
name|d
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|to
index|[
literal|1
index|]
argument_list|,
operator|&
name|from
index|[
literal|1
index|]
argument_list|,
name|len
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|to
operator|->
name|wr_hi
operator|=
name|from
operator|->
name|wr_hi
operator||
name|htonl
argument_list|(
name|F_WR_SOP
operator||
name|F_WR_EOP
operator||
name|V_WR_BCNTLFLT
argument_list|(
name|len
operator|&
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
name|to
operator|->
name|wr_lo
operator|=
name|from
operator|->
name|wr_lo
operator||
name|htonl
argument_list|(
name|V_WR_GEN
argument_list|(
name|gen
argument_list|)
operator||
name|V_WR_LEN
argument_list|(
operator|(
name|len
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|wr_gen2
argument_list|(
name|d
argument_list|,
name|gen
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	check_desc_avail - check descriptor availability on a send queue  *	@adap: the adapter  *	@q: the TX queue  *	@m: the packet needing the descriptors  *	@ndesc: the number of Tx descriptors needed  *	@qid: the Tx queue number in its queue set (TXQ_OFLD or TXQ_CTRL)  *  *	Checks if the requested number of Tx descriptors is available on an  *	SGE send queue.  If the queue is already suspended or not enough  *	descriptors are available the packet is queued for later transmission.  *	Must be called with the Tx queue locked.  *  *	Returns 0 if enough descriptors are available, 1 if there aren't  *	enough descriptors and the packet has been queued, and 2 if the caller  *	needs to retry because there weren't enough descriptors at the  *	beginning of the call but some freed up in the mean time.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|check_desc_avail
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|struct
name|sge_txq
modifier|*
name|q
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|unsigned
name|int
name|ndesc
parameter_list|,
name|unsigned
name|int
name|qid
parameter_list|)
block|{
comment|/*  	 * XXX We currently only use this for checking the control queue 	 * the control queue is only used for binding qsets which happens 	 * at init time so we are guaranteed enough descriptors 	 */
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
name|mbufq_empty
argument_list|(
operator|&
name|q
operator|->
name|sendq
argument_list|)
argument_list|)
condition|)
block|{
name|addq_exit
label|:
name|mbufq_tail
argument_list|(
operator|&
name|q
operator|->
name|sendq
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|__predict_false
argument_list|(
name|q
operator|->
name|size
operator|-
name|q
operator|->
name|in_use
operator|<
name|ndesc
argument_list|)
condition|)
block|{
name|struct
name|sge_qset
modifier|*
name|qs
init|=
name|txq_to_qset
argument_list|(
name|q
argument_list|,
name|qid
argument_list|)
decl_stmt|;
name|setbit
argument_list|(
operator|&
name|qs
operator|->
name|txq_stopped
argument_list|,
name|qid
argument_list|)
expr_stmt|;
name|smp_mb
argument_list|()
expr_stmt|;
if|if
condition|(
name|should_restart_tx
argument_list|(
name|q
argument_list|)
operator|&&
name|test_and_clear_bit
argument_list|(
name|qid
argument_list|,
operator|&
name|qs
operator|->
name|txq_stopped
argument_list|)
condition|)
return|return
literal|2
return|;
name|q
operator|->
name|stops
operator|++
expr_stmt|;
goto|goto
name|addq_exit
goto|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	reclaim_completed_tx_imm - reclaim completed control-queue Tx descs  *	@q: the SGE control Tx queue  *  *	This is a variant of reclaim_completed_tx() that is used for Tx queues  *	that send only immediate data (presently just the control queues) and  *	thus do not have any mbufs  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|reclaim_completed_tx_imm
parameter_list|(
name|struct
name|sge_txq
modifier|*
name|q
parameter_list|)
block|{
name|unsigned
name|int
name|reclaim
init|=
name|q
operator|->
name|processed
operator|-
name|q
operator|->
name|cleaned
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|q
operator|->
name|lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|q
operator|->
name|in_use
operator|-=
name|reclaim
expr_stmt|;
name|q
operator|->
name|cleaned
operator|+=
name|reclaim
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|immediate
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
return|return
name|m
operator|->
name|m_len
operator|<=
name|WR_LEN
operator|&&
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<=
name|WR_LEN
return|;
block|}
end_function

begin_comment
comment|/**  *	ctrl_xmit - send a packet through an SGE control Tx queue  *	@adap: the adapter  *	@q: the control queue  *	@m: the packet  *  *	Send a packet through an SGE control Tx queue.  Packets sent through  *	a control queue must fit entirely as immediate data in a single Tx  *	descriptor and have no page fragments.  */
end_comment

begin_function
specifier|static
name|int
name|ctrl_xmit
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|struct
name|sge_txq
modifier|*
name|q
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|struct
name|work_request_hdr
modifier|*
name|wrp
init|=
operator|(
expr|struct
name|work_request_hdr
operator|*
operator|)
name|m
operator|->
name|m_data
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
name|immediate
argument_list|(
name|m
argument_list|)
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|wrp
operator|->
name|wr_hi
operator||=
name|htonl
argument_list|(
name|F_WR_SOP
operator||
name|F_WR_EOP
argument_list|)
expr_stmt|;
name|wrp
operator|->
name|wr_lo
operator|=
name|htonl
argument_list|(
name|V_WR_TID
argument_list|(
name|q
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|q
operator|->
name|lock
argument_list|)
expr_stmt|;
name|again
label|:
name|reclaim_completed_tx_imm
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|ret
operator|=
name|check_desc_avail
argument_list|(
name|adap
argument_list|,
name|q
argument_list|,
name|m
argument_list|,
literal|1
argument_list|,
name|TXQ_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|ret
argument_list|)
condition|)
block|{
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|q
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
goto|goto
name|again
goto|;
block|}
name|write_imm
argument_list|(
operator|&
name|q
operator|->
name|desc
index|[
name|q
operator|->
name|pidx
index|]
argument_list|,
name|m
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|q
operator|->
name|gen
argument_list|)
expr_stmt|;
name|q
operator|->
name|in_use
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|q
operator|->
name|pidx
operator|>=
name|q
operator|->
name|size
condition|)
block|{
name|q
operator|->
name|pidx
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|gen
operator|^=
literal|1
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|q
operator|->
name|lock
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_KDOORBELL
argument_list|,
name|F_SELEGRCNTX
operator||
name|V_EGRCNTX
argument_list|(
name|q
operator|->
name|cntxt_id
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	restart_ctrlq - restart a suspended control queue  *	@qs: the queue set cotaining the control queue  *  *	Resumes transmission on a suspended Tx control queue.  */
end_comment

begin_function
specifier|static
name|void
name|restart_ctrlq
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sge_qset
modifier|*
name|qs
init|=
operator|(
expr|struct
name|sge_qset
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|q
init|=
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
decl_stmt|;
name|adapter_t
modifier|*
name|adap
init|=
name|qs
operator|->
name|port
operator|->
name|adapter
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|q
operator|->
name|lock
argument_list|)
expr_stmt|;
name|again
label|:
name|reclaim_completed_tx_imm
argument_list|(
name|q
argument_list|)
expr_stmt|;
while|while
condition|(
name|q
operator|->
name|in_use
operator|<
name|q
operator|->
name|size
operator|&&
operator|(
name|m
operator|=
name|mbufq_dequeue
argument_list|(
operator|&
name|q
operator|->
name|sendq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|write_imm
argument_list|(
operator|&
name|q
operator|->
name|desc
index|[
name|q
operator|->
name|pidx
index|]
argument_list|,
name|m
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|q
operator|->
name|gen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|q
operator|->
name|pidx
operator|>=
name|q
operator|->
name|size
condition|)
block|{
name|q
operator|->
name|pidx
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|gen
operator|^=
literal|1
expr_stmt|;
block|}
name|q
operator|->
name|in_use
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mbufq_empty
argument_list|(
operator|&
name|q
operator|->
name|sendq
argument_list|)
condition|)
block|{
name|setbit
argument_list|(
operator|&
name|qs
operator|->
name|txq_stopped
argument_list|,
name|TXQ_CTRL
argument_list|)
expr_stmt|;
name|smp_mb
argument_list|()
expr_stmt|;
if|if
condition|(
name|should_restart_tx
argument_list|(
name|q
argument_list|)
operator|&&
name|test_and_clear_bit
argument_list|(
name|TXQ_CTRL
argument_list|,
operator|&
name|qs
operator|->
name|txq_stopped
argument_list|)
condition|)
goto|goto
name|again
goto|;
name|q
operator|->
name|stops
operator|++
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|q
operator|->
name|lock
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_KDOORBELL
argument_list|,
name|F_SELEGRCNTX
operator||
name|V_EGRCNTX
argument_list|(
name|q
operator|->
name|cntxt_id
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send a management message through control queue 0  */
end_comment

begin_function
name|int
name|t3_mgmt_tx
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
return|return
name|ctrl_xmit
argument_list|(
name|adap
argument_list|,
operator|&
name|adap
operator|->
name|sge
operator|.
name|qs
index|[
literal|0
index|]
operator|.
name|txq
index|[
name|TXQ_CTRL
index|]
argument_list|,
name|m
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	free_qset - free the resources of an SGE queue set  *	@sc: the controller owning the queue set  *	@q: the queue set  *  *	Release the HW and SW resources associated with an SGE queue set, such  *	as HW contexts, packet buffers, and descriptor rings.  Traffic to the  *	queue set must be quiesced prior to calling this.  */
end_comment

begin_function
specifier|static
name|void
name|t3_free_qset
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_qset
modifier|*
name|q
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SGE_RXQ_PER_SET
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|desc
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
name|t3_sge_disable_fl
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|cntxt_id
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|desc_tag
argument_list|,
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|desc_map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|desc_tag
argument_list|,
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|desc
argument_list|,
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|desc_map
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|desc_tag
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|entry_tag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|sdesc
condition|)
block|{
name|free_rx_bufs
argument_list|(
name|sc
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|sdesc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SGE_TXQ_PER_SET
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|desc
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
name|t3_sge_enable_ecntxt
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|cntxt_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|desc_tag
argument_list|,
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|desc_map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|desc_tag
argument_list|,
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|desc
argument_list|,
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|desc_map
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|desc_tag
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|entry_tag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|sdesc
condition|)
block|{
name|free
argument_list|(
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|sdesc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
condition|)
block|{
name|mtx_destroy
argument_list|(
operator|&
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|q
operator|->
name|rspq
operator|.
name|desc
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
name|t3_sge_disable_rspcntxt
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|rspq
operator|.
name|cntxt_id
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|q
operator|->
name|rspq
operator|.
name|desc_tag
argument_list|,
name|q
operator|->
name|rspq
operator|.
name|desc_map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|q
operator|->
name|rspq
operator|.
name|desc_tag
argument_list|,
name|q
operator|->
name|rspq
operator|.
name|desc
argument_list|,
name|q
operator|->
name|rspq
operator|.
name|desc_map
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|q
operator|->
name|rspq
operator|.
name|desc_tag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|q
operator|->
name|rspq
operator|.
name|lock
argument_list|)
condition|)
name|mtx_destroy
argument_list|(
operator|&
name|q
operator|->
name|rspq
operator|.
name|lock
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|q
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|q
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t3_free_sge_resources - free SGE resources  *	@sc: the adapter softc  *  *	Frees resources used by the SGE queue sets.  */
end_comment

begin_function
name|void
name|t3_free_sge_resources
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SGE_QSETS
condition|;
operator|++
name|i
control|)
name|t3_free_qset
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t3_sge_start - enable SGE  *	@sc: the controller softc  *  *	Enables the SGE for DMAs.  This is the last step in starting packet  *	transfers.  */
end_comment

begin_function
name|void
name|t3_sge_start
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|)
block|{
name|t3_set_reg_field
argument_list|(
name|sc
argument_list|,
name|A_SG_CONTROL
argument_list|,
name|F_GLOBALENABLE
argument_list|,
name|F_GLOBALENABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t3_sge_stop - disable SGE operation  *	@sc: the adapter  *  *	Disables the DMA engine.  This can be called in emeregencies (e.g.,  *	from error interrupts) or from normal process context.  In the latter  *	case it also disables any pending queue restart tasklets.  Note that  *	if it is called in interrupt context it cannot disable the restart  *	tasklets as it cannot wait, however the tasklets will have no effect  *	since the doorbells are disabled and the driver will call this again  *	later from process context, at which time the tasklets will be stopped  *	if they are still running.  */
end_comment

begin_function
name|void
name|t3_sge_stop
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|t3_set_reg_field
argument_list|(
name|sc
argument_list|,
name|A_SG_CONTROL
argument_list|,
name|F_GLOBALENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SGE_QSETS
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|sge_qset
modifier|*
name|qs
init|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
name|i
index|]
decl_stmt|;
name|taskqueue_drain
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
operator|.
name|qresume_tsk
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
operator|.
name|qresume_tsk
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	free_tx_desc - reclaims Tx descriptors and their buffers  *	@adapter: the adapter  *	@q: the Tx queue to reclaim descriptors from  *	@n: the number of descriptors to reclaim  *  *	Reclaims Tx descriptors from an SGE Tx queue and frees the associated  *	Tx buffers.  Called with the Tx queue lock held.  */
end_comment

begin_function
name|int
name|free_tx_desc
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_txq
modifier|*
name|q
parameter_list|,
name|int
name|n
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m_vec
parameter_list|)
block|{
name|struct
name|tx_sw_desc
modifier|*
name|d
decl_stmt|;
name|unsigned
name|int
name|cidx
init|=
name|q
operator|->
name|cidx
decl_stmt|;
name|int
name|nbufs
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|T3_TRACE
name|T3_TRACE2
argument_list|(
name|sc
operator|->
name|tb
index|[
name|q
operator|->
name|cntxt_id
operator|&
literal|7
index|]
argument_list|,
literal|"reclaiming %u Tx descriptors at cidx %u"
argument_list|,
name|n
argument_list|,
name|cidx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|d
operator|=
operator|&
name|q
operator|->
name|sdesc
index|[
name|cidx
index|]
expr_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"cidx=%d d=%p\n"
argument_list|,
name|cidx
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|m
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|TX_SW_DESC_MAPPED
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|q
operator|->
name|entry_tag
argument_list|,
name|d
operator|->
name|map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|q
operator|->
name|entry_tag
argument_list|,
name|d
operator|->
name|map
argument_list|)
expr_stmt|;
name|d
operator|->
name|flags
operator|&=
operator|~
name|TX_SW_DESC_MAPPED
expr_stmt|;
block|}
if|if
condition|(
name|m_get_priority
argument_list|(
name|d
operator|->
name|m
argument_list|)
operator|==
name|cidx
condition|)
block|{
name|m_vec
index|[
name|nbufs
index|]
operator|=
name|d
operator|->
name|m
expr_stmt|;
name|d
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|nbufs
operator|++
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"pri=%d cidx=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|m_get_priority
argument_list|(
name|d
operator|->
name|m
argument_list|)
argument_list|,
name|cidx
argument_list|)
expr_stmt|;
block|}
block|}
operator|++
name|d
expr_stmt|;
if|if
condition|(
operator|++
name|cidx
operator|==
name|q
operator|->
name|size
condition|)
block|{
name|cidx
operator|=
literal|0
expr_stmt|;
name|d
operator|=
name|q
operator|->
name|sdesc
expr_stmt|;
block|}
block|}
name|q
operator|->
name|cidx
operator|=
name|cidx
expr_stmt|;
return|return
operator|(
name|nbufs
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	is_new_response - check if a response is newly written  *	@r: the response descriptor  *	@q: the response queue  *  *	Returns true if a response descriptor contains a yet unprocessed  *	response.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|is_new_response
parameter_list|(
specifier|const
name|struct
name|rsp_desc
modifier|*
name|r
parameter_list|,
specifier|const
name|struct
name|sge_rspq
modifier|*
name|q
parameter_list|)
block|{
return|return
operator|(
name|r
operator|->
name|intr_gen
operator|&
name|F_RSPD_GEN2
operator|)
operator|==
name|q
operator|->
name|gen
return|;
block|}
end_function

begin_define
define|#
directive|define
name|RSPD_GTS_MASK
value|(F_RSPD_TXQ0_GTS | F_RSPD_TXQ1_GTS)
end_define

begin_define
define|#
directive|define
name|RSPD_CTRL_MASK
value|(RSPD_GTS_MASK | \ 			V_RSPD_TXQ0_CR(M_RSPD_TXQ0_CR) | \ 			V_RSPD_TXQ1_CR(M_RSPD_TXQ1_CR) | \ 			V_RSPD_TXQ2_CR(M_RSPD_TXQ2_CR))
end_define

begin_comment
comment|/* How long to delay the next interrupt in case of memory shortage, in 0.1us. */
end_comment

begin_define
define|#
directive|define
name|NOMEM_INTR_DELAY
value|2500
end_define

begin_comment
comment|/**  *	write_ofld_wr - write an offload work request  *	@adap: the adapter  *	@m: the packet to send  *	@q: the Tx queue  *	@pidx: index of the first Tx descriptor to write  *	@gen: the generation value to use  *	@ndesc: number of descriptors the packet will occupy  *  *	Write an offload work request to send the supplied packet.  The packet  *	data already carry the work request with most fields populated.  */
end_comment

begin_function
specifier|static
name|void
name|write_ofld_wr
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sge_txq
modifier|*
name|q
parameter_list|,
name|unsigned
name|int
name|pidx
parameter_list|,
name|unsigned
name|int
name|gen
parameter_list|,
name|unsigned
name|int
name|ndesc
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|unsigned
name|int
name|nsegs
parameter_list|)
block|{
name|unsigned
name|int
name|sgl_flits
decl_stmt|,
name|flits
decl_stmt|;
name|struct
name|work_request_hdr
modifier|*
name|from
decl_stmt|;
name|struct
name|sg_ent
modifier|*
name|sgp
decl_stmt|,
name|sgl
index|[
name|TX_MAX_SEGS
operator|/
literal|2
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|tx_desc
modifier|*
name|d
init|=
operator|&
name|q
operator|->
name|desc
index|[
name|pidx
index|]
decl_stmt|;
name|struct
name|txq_state
name|txqs
decl_stmt|;
if|if
condition|(
name|immediate
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|q
operator|->
name|sdesc
index|[
name|pidx
index|]
operator|.
name|m
operator|=
name|NULL
expr_stmt|;
name|write_imm
argument_list|(
name|d
argument_list|,
name|m
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|gen
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Only TX_DATA builds SGLs */
name|from
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|work_request_hdr
operator|*
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|d
operator|->
name|flit
index|[
literal|1
index|]
argument_list|,
operator|&
name|from
index|[
literal|1
index|]
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|header
operator|-
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|flits
operator|=
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|header
operator|-
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|)
operator|/
literal|8
expr_stmt|;
name|sgp
operator|=
operator|(
name|ndesc
operator|==
literal|1
operator|)
condition|?
operator|(
expr|struct
name|sg_ent
operator|*
operator|)
operator|&
name|d
operator|->
name|flit
index|[
name|flits
index|]
else|:
name|sgl
expr_stmt|;
name|make_sgl
argument_list|(
name|sgp
argument_list|,
name|segs
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
name|sgl_flits
operator|=
name|sgl_len
argument_list|(
name|nsegs
argument_list|)
expr_stmt|;
name|txqs
operator|.
name|gen
operator|=
name|q
operator|->
name|gen
expr_stmt|;
name|txqs
operator|.
name|pidx
operator|=
name|q
operator|->
name|pidx
expr_stmt|;
name|txqs
operator|.
name|compl
operator|=
operator|(
name|q
operator|->
name|unacked
operator|&
literal|8
operator|)
operator|<<
operator|(
name|S_WR_COMPL
operator|-
literal|3
operator|)
expr_stmt|;
name|write_wr_hdr_sgl
argument_list|(
name|ndesc
argument_list|,
name|d
argument_list|,
operator|&
name|txqs
argument_list|,
name|q
argument_list|,
name|sgl
argument_list|,
name|flits
argument_list|,
name|sgl_flits
argument_list|,
name|from
operator|->
name|wr_hi
argument_list|,
name|from
operator|->
name|wr_lo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	calc_tx_descs_ofld - calculate # of Tx descriptors for an offload packet  *	@m: the packet  *  * 	Returns the number of Tx descriptors needed for the given offload  * 	packet.  These packets are already fully constructed.  */
end_comment

begin_function
specifier|static
name|__inline
name|unsigned
name|int
name|calc_tx_descs_ofld
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|unsigned
name|int
name|nsegs
parameter_list|)
block|{
name|unsigned
name|int
name|flits
decl_stmt|,
name|cnt
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<=
name|WR_LEN
condition|)
return|return
literal|1
return|;
comment|/* packet fits as immediate data */
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_IOVEC
condition|)
name|cnt
operator|=
name|mtomv
argument_list|(
name|m
argument_list|)
operator|->
name|mv_count
expr_stmt|;
name|flits
operator|=
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|header
operator|-
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|)
operator|/
literal|8
expr_stmt|;
comment|/* headers */
return|return
name|flits_to_desc
argument_list|(
name|flits
operator|+
name|sgl_len
argument_list|(
name|cnt
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	ofld_xmit - send a packet through an offload queue  *	@adap: the adapter  *	@q: the Tx offload queue  *	@m: the packet  *  *	Send an offload packet through an SGE offload queue.  */
end_comment

begin_function
specifier|static
name|int
name|ofld_xmit
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|struct
name|sge_txq
modifier|*
name|q
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|unsigned
name|int
name|pidx
decl_stmt|,
name|gen
decl_stmt|,
name|nsegs
decl_stmt|;
name|unsigned
name|int
name|ndesc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_vec
index|[
name|TX_CLEAN_MAX_DESC
index|]
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
name|TX_MAX_SEGS
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|cleaned
decl_stmt|;
name|struct
name|tx_sw_desc
modifier|*
name|stx
init|=
operator|&
name|q
operator|->
name|sdesc
index|[
name|q
operator|->
name|pidx
index|]
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|q
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|busdma_map_mbufs
argument_list|(
operator|&
name|m
argument_list|,
name|q
argument_list|,
name|stx
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|q
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|ndesc
operator|=
name|calc_tx_descs_ofld
argument_list|(
name|m
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
name|again
label|:
name|cleaned
operator|=
name|reclaim_completed_tx
argument_list|(
name|adap
argument_list|,
name|q
argument_list|,
name|TX_CLEAN_MAX_DESC
argument_list|,
name|m_vec
argument_list|)
expr_stmt|;
name|ret
operator|=
name|check_desc_avail
argument_list|(
name|adap
argument_list|,
name|q
argument_list|,
name|m
argument_list|,
name|ndesc
argument_list|,
name|TXQ_OFLD
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|ret
argument_list|)
condition|)
block|{
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
block|{
name|m_set_priority
argument_list|(
name|m
argument_list|,
name|ndesc
argument_list|)
expr_stmt|;
comment|/* save for restart */
name|mtx_unlock
argument_list|(
operator|&
name|q
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|NET_XMIT_CN
return|;
block|}
goto|goto
name|again
goto|;
block|}
name|gen
operator|=
name|q
operator|->
name|gen
expr_stmt|;
name|q
operator|->
name|in_use
operator|+=
name|ndesc
expr_stmt|;
name|pidx
operator|=
name|q
operator|->
name|pidx
expr_stmt|;
name|q
operator|->
name|pidx
operator|+=
name|ndesc
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|pidx
operator|>=
name|q
operator|->
name|size
condition|)
block|{
name|q
operator|->
name|pidx
operator|-=
name|q
operator|->
name|size
expr_stmt|;
name|q
operator|->
name|gen
operator|^=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|T3_TRACE
name|T3_TRACE5
argument_list|(
name|adap
operator|->
name|tb
index|[
name|q
operator|->
name|cntxt_id
operator|&
literal|7
index|]
argument_list|,
literal|"ofld_xmit: ndesc %u, pidx %u, len %u, main %u, frags %u"
argument_list|,
name|ndesc
argument_list|,
name|pidx
argument_list|,
name|skb
operator|->
name|len
argument_list|,
name|skb
operator|->
name|len
operator|-
name|skb
operator|->
name|data_len
argument_list|,
name|skb_shinfo
argument_list|(
name|skb
argument_list|)
operator|->
name|nr_frags
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mtx_unlock
argument_list|(
operator|&
name|q
operator|->
name|lock
argument_list|)
expr_stmt|;
name|write_ofld_wr
argument_list|(
name|adap
argument_list|,
name|m
argument_list|,
name|q
argument_list|,
name|pidx
argument_list|,
name|gen
argument_list|,
name|ndesc
argument_list|,
name|segs
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
name|check_ring_tx_db
argument_list|(
name|adap
argument_list|,
name|q
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cleaned
condition|;
name|i
operator|++
control|)
block|{
name|m_freem_vec
argument_list|(
name|m_vec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|NET_XMIT_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**  *	restart_offloadq - restart a suspended offload queue  *	@qs: the queue set cotaining the offload queue  *  *	Resumes transmission on a suspended Tx offload queue.  */
end_comment

begin_function
specifier|static
name|void
name|restart_offloadq
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sge_qset
modifier|*
name|qs
init|=
name|data
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|q
init|=
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
decl_stmt|;
name|adapter_t
modifier|*
name|adap
init|=
name|qs
operator|->
name|port
operator|->
name|adapter
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_vec
index|[
name|TX_CLEAN_MAX_DESC
index|]
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
name|TX_MAX_SEGS
index|]
decl_stmt|;
name|int
name|nsegs
decl_stmt|,
name|i
decl_stmt|,
name|cleaned
decl_stmt|;
name|struct
name|tx_sw_desc
modifier|*
name|stx
init|=
operator|&
name|q
operator|->
name|sdesc
index|[
name|q
operator|->
name|pidx
index|]
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|q
operator|->
name|lock
argument_list|)
expr_stmt|;
name|again
label|:
name|cleaned
operator|=
name|reclaim_completed_tx
argument_list|(
name|adap
argument_list|,
name|q
argument_list|,
name|TX_CLEAN_MAX_DESC
argument_list|,
name|m_vec
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|mbufq_peek
argument_list|(
operator|&
name|q
operator|->
name|sendq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|int
name|gen
decl_stmt|,
name|pidx
decl_stmt|;
name|unsigned
name|int
name|ndesc
init|=
name|m_get_priority
argument_list|(
name|m
argument_list|)
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|q
operator|->
name|size
operator|-
name|q
operator|->
name|in_use
operator|<
name|ndesc
argument_list|)
condition|)
block|{
name|setbit
argument_list|(
operator|&
name|qs
operator|->
name|txq_stopped
argument_list|,
name|TXQ_OFLD
argument_list|)
expr_stmt|;
name|smp_mb
argument_list|()
expr_stmt|;
if|if
condition|(
name|should_restart_tx
argument_list|(
name|q
argument_list|)
operator|&&
name|test_and_clear_bit
argument_list|(
name|TXQ_OFLD
argument_list|,
operator|&
name|qs
operator|->
name|txq_stopped
argument_list|)
condition|)
goto|goto
name|again
goto|;
name|q
operator|->
name|stops
operator|++
expr_stmt|;
break|break;
block|}
name|gen
operator|=
name|q
operator|->
name|gen
expr_stmt|;
name|q
operator|->
name|in_use
operator|+=
name|ndesc
expr_stmt|;
name|pidx
operator|=
name|q
operator|->
name|pidx
expr_stmt|;
name|q
operator|->
name|pidx
operator|+=
name|ndesc
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|pidx
operator|>=
name|q
operator|->
name|size
condition|)
block|{
name|q
operator|->
name|pidx
operator|-=
name|q
operator|->
name|size
expr_stmt|;
name|q
operator|->
name|gen
operator|^=
literal|1
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|mbufq_dequeue
argument_list|(
operator|&
name|q
operator|->
name|sendq
argument_list|)
expr_stmt|;
name|busdma_map_mbufs
argument_list|(
operator|&
name|m
argument_list|,
name|q
argument_list|,
name|stx
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|q
operator|->
name|lock
argument_list|)
expr_stmt|;
name|write_ofld_wr
argument_list|(
name|adap
argument_list|,
name|m
argument_list|,
name|q
argument_list|,
name|pidx
argument_list|,
name|gen
argument_list|,
name|ndesc
argument_list|,
name|segs
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|q
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|q
operator|->
name|lock
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_GTS
name|set_bit
argument_list|(
name|TXQ_RUNNING
argument_list|,
operator|&
name|q
operator|->
name|flags
argument_list|)
expr_stmt|;
name|set_bit
argument_list|(
name|TXQ_LAST_PKT_DB
argument_list|,
operator|&
name|q
operator|->
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_KDOORBELL
argument_list|,
name|F_SELEGRCNTX
operator||
name|V_EGRCNTX
argument_list|(
name|q
operator|->
name|cntxt_id
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cleaned
condition|;
name|i
operator|++
control|)
block|{
name|m_freem_vec
argument_list|(
name|m_vec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	queue_set - return the queue set a packet should use  *	@m: the packet  *  *	Maps a packet to the SGE queue set it should use.  The desired queue  *	set is carried in bits 1-3 in the packet's priority.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|queue_set
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
return|return
name|m_get_priority
argument_list|(
name|m
argument_list|)
operator|>>
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  *	is_ctrl_pkt - return whether an offload packet is a control packet  *	@m: the packet  *  *	Determines whether an offload packet should use an OFLD or a CTRL  *	Tx queue.  This is indicated by bit 0 in the packet's priority.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|is_ctrl_pkt
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
return|return
name|m_get_priority
argument_list|(
name|m
argument_list|)
operator|&
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_offload_tx - send an offload packet  *	@tdev: the offload device to send to  *	@m: the packet  *  *	Sends an offload packet.  We use the packet priority to select the  *	appropriate Tx queue as follows: bit 0 indicates whether the packet  *	should be sent as regular or control, bits 1-3 select the queue set.  */
end_comment

begin_function
name|int
name|t3_offload_tx
parameter_list|(
name|struct
name|toedev
modifier|*
name|tdev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|adapter_t
modifier|*
name|adap
init|=
name|tdev2adap
argument_list|(
name|tdev
argument_list|)
decl_stmt|;
name|struct
name|sge_qset
modifier|*
name|qs
init|=
operator|&
name|adap
operator|->
name|sge
operator|.
name|qs
index|[
name|queue_set
argument_list|(
name|m
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|is_ctrl_pkt
argument_list|(
name|m
argument_list|)
argument_list|)
condition|)
return|return
name|ctrl_xmit
argument_list|(
name|adap
argument_list|,
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
argument_list|,
name|m
argument_list|)
return|;
return|return
name|ofld_xmit
argument_list|(
name|adap
argument_list|,
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
argument_list|,
name|m
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	deliver_partial_bundle - deliver a (partial) bundle of Rx offload pkts  *	@tdev: the offload device that will be receiving the packets  *	@q: the SGE response queue that assembled the bundle  *	@m: the partial bundle  *	@n: the number of packets in the bundle  *  *	Delivers a (partial) bundle of Rx offload packets to an offload device.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|deliver_partial_bundle
parameter_list|(
name|struct
name|toedev
modifier|*
name|tdev
parameter_list|,
name|struct
name|sge_rspq
modifier|*
name|q
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mbufs
index|[]
parameter_list|,
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
name|n
condition|)
block|{
name|q
operator|->
name|offload_bundles
operator|++
expr_stmt|;
name|cxgb_ofld_recv
argument_list|(
name|tdev
argument_list|,
name|mbufs
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|rx_offload
parameter_list|(
name|struct
name|toedev
modifier|*
name|tdev
parameter_list|,
name|struct
name|sge_rspq
modifier|*
name|rq
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|mbuf
modifier|*
name|rx_gather
index|[]
parameter_list|,
name|unsigned
name|int
name|gather_idx
parameter_list|)
block|{
name|rq
operator|->
name|offload_pkts
operator|++
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|header
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
name|rx_gather
index|[
name|gather_idx
operator|++
index|]
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|gather_idx
operator|==
name|RX_BUNDLE_SIZE
condition|)
block|{
name|cxgb_ofld_recv
argument_list|(
name|tdev
argument_list|,
name|rx_gather
argument_list|,
name|RX_BUNDLE_SIZE
argument_list|)
expr_stmt|;
name|gather_idx
operator|=
literal|0
expr_stmt|;
name|rq
operator|->
name|offload_bundles
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|gather_idx
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|restart_tx
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|qs
operator|->
name|port
operator|->
name|adapter
decl_stmt|;
if|if
condition|(
name|isset
argument_list|(
operator|&
name|qs
operator|->
name|txq_stopped
argument_list|,
name|TXQ_OFLD
argument_list|)
operator|&&
name|should_restart_tx
argument_list|(
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
argument_list|)
operator|&&
name|test_and_clear_bit
argument_list|(
name|TXQ_OFLD
argument_list|,
operator|&
name|qs
operator|->
name|txq_stopped
argument_list|)
condition|)
block|{
name|qs
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
operator|.
name|restarts
operator|++
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
operator|.
name|qresume_tsk
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isset
argument_list|(
operator|&
name|qs
operator|->
name|txq_stopped
argument_list|,
name|TXQ_CTRL
argument_list|)
operator|&&
name|should_restart_tx
argument_list|(
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
argument_list|)
operator|&&
name|test_and_clear_bit
argument_list|(
name|TXQ_CTRL
argument_list|,
operator|&
name|qs
operator|->
name|txq_stopped
argument_list|)
condition|)
block|{
name|qs
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
operator|.
name|restarts
operator|++
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
operator|.
name|qresume_tsk
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	t3_sge_alloc_qset - initialize an SGE queue set  *	@sc: the controller softc  *	@id: the queue set id  *	@nports: how many Ethernet ports will be using this queue set  *	@irq_vec_idx: the IRQ vector index for response queue interrupts  *	@p: configuration parameters for this queue set  *	@ntxq: number of Tx queues for the queue set  *	@pi: port info for queue set  *  *	Allocate resources and initialize an SGE queue set.  A queue set  *	comprises a response queue, two Rx free-buffer queues, and up to 3  *	Tx queues.  The Tx queues are assigned roles in the order Ethernet  *	queue, offload queue, and control queue.  */
end_comment

begin_function
name|int
name|t3_sge_alloc_qset
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|,
name|u_int
name|id
parameter_list|,
name|int
name|nports
parameter_list|,
name|int
name|irq_vec_idx
parameter_list|,
specifier|const
name|struct
name|qset_params
modifier|*
name|p
parameter_list|,
name|int
name|ntxq
parameter_list|,
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|sge_qset
modifier|*
name|q
init|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
name|id
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|init_qset_cntxt
argument_list|(
name|q
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|alloc_ring
argument_list|(
name|sc
argument_list|,
name|p
operator|->
name|fl_size
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rx_desc
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rx_sw_desc
argument_list|)
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|phys_addr
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|desc
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|sdesc
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|desc_tag
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|desc_map
argument_list|,
name|sc
operator|->
name|rx_dmat
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|entry_tag
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"error %d from alloc ring fl0\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|(
name|ret
operator|=
name|alloc_ring
argument_list|(
name|sc
argument_list|,
name|p
operator|->
name|jumbo_size
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rx_desc
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rx_sw_desc
argument_list|)
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|phys_addr
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|desc
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|sdesc
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|desc_tag
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|desc_map
argument_list|,
name|sc
operator|->
name|rx_jumbo_dmat
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|entry_tag
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"error %d from alloc ring fl1\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|(
name|ret
operator|=
name|alloc_ring
argument_list|(
name|sc
argument_list|,
name|p
operator|->
name|rspq_size
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rsp_desc
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|q
operator|->
name|rspq
operator|.
name|phys_addr
argument_list|,
operator|&
name|q
operator|->
name|rspq
operator|.
name|desc
argument_list|,
name|NULL
argument_list|,
operator|&
name|q
operator|->
name|rspq
operator|.
name|desc_tag
argument_list|,
operator|&
name|q
operator|->
name|rspq
operator|.
name|desc_map
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"error %d from alloc ring rspq\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntxq
condition|;
operator|++
name|i
control|)
block|{
comment|/* 		 * The control queue always uses immediate data so does not 		 * need to keep track of any mbufs. 		 * XXX Placeholder for future TOE support. 		 */
name|size_t
name|sz
init|=
name|i
operator|==
name|TXQ_CTRL
condition|?
literal|0
else|:
sizeof|sizeof
argument_list|(
expr|struct
name|tx_sw_desc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|alloc_ring
argument_list|(
name|sc
argument_list|,
name|p
operator|->
name|txq_size
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tx_desc
argument_list|)
argument_list|,
name|sz
argument_list|,
operator|&
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|phys_addr
argument_list|,
operator|&
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|desc
argument_list|,
operator|&
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|sdesc
argument_list|,
operator|&
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|desc_tag
argument_list|,
operator|&
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|desc_map
argument_list|,
name|sc
operator|->
name|tx_dmat
argument_list|,
operator|&
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|entry_tag
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"error %d from alloc ring tx %i\n"
argument_list|,
name|ret
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|mbufq_init
argument_list|(
operator|&
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|sendq
argument_list|)
expr_stmt|;
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|gen
operator|=
literal|1
expr_stmt|;
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|size
operator|=
name|p
operator|->
name|txq_size
index|[
name|i
index|]
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|lock
argument_list|,
literal|"t3 txq lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
block|}
name|TASK_INIT
argument_list|(
operator|&
name|q
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
operator|.
name|qresume_tsk
argument_list|,
literal|0
argument_list|,
name|restart_offloadq
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|q
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
operator|.
name|qresume_tsk
argument_list|,
literal|0
argument_list|,
name|restart_ctrlq
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|q
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|gen
operator|=
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|gen
operator|=
literal|1
expr_stmt|;
name|q
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|size
operator|=
name|p
operator|->
name|fl_size
expr_stmt|;
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|size
operator|=
name|p
operator|->
name|jumbo_size
expr_stmt|;
name|q
operator|->
name|rspq
operator|.
name|gen
operator|=
literal|1
expr_stmt|;
name|q
operator|->
name|rspq
operator|.
name|size
operator|=
name|p
operator|->
name|rspq_size
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|q
operator|->
name|rspq
operator|.
name|lock
argument_list|,
literal|"t3 rspq lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|q
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|stop_thres
operator|=
name|nports
operator|*
name|flits_to_desc
argument_list|(
name|sgl_len
argument_list|(
name|TX_MAX_SEGS
operator|+
literal|1
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|q
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|buf_size
operator|=
name|MCLBYTES
expr_stmt|;
name|q
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|zone
operator|=
name|zone_clust
expr_stmt|;
name|q
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|EXT_CLUSTER
expr_stmt|;
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|buf_size
operator|=
name|MJUMPAGESIZE
expr_stmt|;
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|zone
operator|=
name|zone_jumbop
expr_stmt|;
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|EXT_JUMBOP
expr_stmt|;
name|q
operator|->
name|lro
operator|.
name|enabled
operator|=
name|lro_default
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|t3_sge_init_rspcntxt
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|rspq
operator|.
name|cntxt_id
argument_list|,
name|irq_vec_idx
argument_list|,
name|q
operator|->
name|rspq
operator|.
name|phys_addr
argument_list|,
name|q
operator|->
name|rspq
operator|.
name|size
argument_list|,
name|q
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|buf_size
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|printf
argument_list|(
literal|"error %d from t3_sge_init_rspcntxt\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
goto|goto
name|err_unlock
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SGE_RXQ_PER_SET
condition|;
operator|++
name|i
control|)
block|{
name|ret
operator|=
operator|-
name|t3_sge_init_flcntxt
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|cntxt_id
argument_list|,
literal|0
argument_list|,
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|phys_addr
argument_list|,
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|size
argument_list|,
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|buf_size
argument_list|,
name|p
operator|->
name|cong_thres
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|printf
argument_list|(
literal|"error %d from t3_sge_init_flcntxt for index i=%d\n"
argument_list|,
name|ret
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|err_unlock
goto|;
block|}
block|}
name|ret
operator|=
operator|-
name|t3_sge_init_ecntxt
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|cntxt_id
argument_list|,
name|USE_GTS
argument_list|,
name|SGE_CNTXT_ETH
argument_list|,
name|id
argument_list|,
name|q
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|phys_addr
argument_list|,
name|q
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|size
argument_list|,
name|q
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|token
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|printf
argument_list|(
literal|"error %d from t3_sge_init_ecntxt\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
goto|goto
name|err_unlock
goto|;
block|}
if|if
condition|(
name|ntxq
operator|>
literal|1
condition|)
block|{
name|ret
operator|=
operator|-
name|t3_sge_init_ecntxt
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
operator|.
name|cntxt_id
argument_list|,
name|USE_GTS
argument_list|,
name|SGE_CNTXT_OFLD
argument_list|,
name|id
argument_list|,
name|q
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
operator|.
name|phys_addr
argument_list|,
name|q
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
operator|.
name|size
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|printf
argument_list|(
literal|"error %d from t3_sge_init_ecntxt\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
goto|goto
name|err_unlock
goto|;
block|}
block|}
if|if
condition|(
name|ntxq
operator|>
literal|2
condition|)
block|{
name|ret
operator|=
operator|-
name|t3_sge_init_ecntxt
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
operator|.
name|cntxt_id
argument_list|,
literal|0
argument_list|,
name|SGE_CNTXT_CTRL
argument_list|,
name|id
argument_list|,
name|q
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
operator|.
name|phys_addr
argument_list|,
name|q
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
operator|.
name|size
argument_list|,
name|q
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
operator|.
name|token
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|printf
argument_list|(
literal|"error %d from t3_sge_init_ecntxt\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
goto|goto
name|err_unlock
goto|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
name|t3_update_qset_coalesce
argument_list|(
name|q
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|q
operator|->
name|port
operator|=
name|pi
expr_stmt|;
name|refill_fl
argument_list|(
name|sc
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
literal|0
index|]
argument_list|,
name|q
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
name|refill_fl
argument_list|(
name|sc
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
literal|1
index|]
argument_list|,
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
name|refill_rspq
argument_list|(
name|sc
argument_list|,
operator|&
name|q
operator|->
name|rspq
argument_list|,
name|q
operator|->
name|rspq
operator|.
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|A_SG_GTS
argument_list|,
name|V_RSPQ
argument_list|(
name|q
operator|->
name|rspq
operator|.
name|cntxt_id
argument_list|)
operator||
name|V_NEWTIMER
argument_list|(
name|q
operator|->
name|rspq
operator|.
name|holdoff_tmr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err_unlock
label|:
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
name|err
label|:
name|t3_free_qset
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
name|t3_rx_eth
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|,
name|struct
name|sge_rspq
modifier|*
name|rq
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|ethpad
parameter_list|)
block|{
name|struct
name|cpl_rx_pkt
modifier|*
name|cpl
init|=
operator|(
expr|struct
name|cpl_rx_pkt
operator|*
operator|)
operator|(
name|m
operator|->
name|m_data
operator|+
name|ethpad
operator|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|pi
operator|->
name|ifp
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"rx_eth m=%p m->m_data=%p p->iff=%d\n"
argument_list|,
name|m
argument_list|,
name|m
operator|->
name|m_data
argument_list|,
name|cpl
operator|->
name|iff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|pi
operator|->
name|adapter
operator|->
name|port
index|[
name|cpl
operator|->
name|iff
index|]
operator|!=
name|pi
condition|)
name|panic
argument_list|(
literal|"bad port index %d m->m_data=%p\n"
argument_list|,
name|cpl
operator|->
name|iff
argument_list|,
name|m
operator|->
name|m_data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
operator|)
operator|&&
operator|!
name|cpl
operator|->
name|fragment
operator|&&
name|cpl
operator|->
name|csum_valid
operator|&&
name|cpl
operator|->
name|csum
operator|==
literal|0xffff
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
operator|(
name|CSUM_IP_CHECKED
operator||
name|CSUM_IP_VALID
operator|)
expr_stmt|;
name|rspq_to_qset
argument_list|(
name|rq
argument_list|)
operator|->
name|port_stats
index|[
name|SGE_PSTAT_RX_CSUM_GOOD
index|]
operator|++
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
operator|(
name|CSUM_IP_CHECKED
operator||
name|CSUM_IP_VALID
operator||
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xffff
expr_stmt|;
block|}
comment|/*  	 * XXX need to add VLAN support for 6.x 	 */
ifdef|#
directive|ifdef
name|VLAN_SUPPORTED
if|if
condition|(
name|__predict_false
argument_list|(
name|cpl
operator|->
name|vlan_valid
argument_list|)
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|=
name|ntohs
argument_list|(
name|cpl
operator|->
name|vlan
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_VLANTAG
expr_stmt|;
block|}
endif|#
directive|endif
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|header
operator|=
name|m
operator|->
name|m_data
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|cpl
argument_list|)
operator|+
name|ethpad
expr_stmt|;
name|m_explode
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * adjust after conversion to mbuf chain 	 */
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cpl
argument_list|)
operator|+
name|ethpad
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	get_packet - return the next ingress packet buffer from a free list  *	@adap: the adapter that received the packet  *	@drop_thres: # of remaining buffers before we start dropping packets  *	@qs: the qset that the SGE free list holding the packet belongs to  *      @mh: the mbuf header, contains a pointer to the head and tail of the mbuf chain  *      @r: response descriptor   *  *	Get the next packet from a free list and complete setup of the  *	sk_buff.  If the packet is small we make a copy and recycle the  *	original buffer, otherwise we use the original buffer itself.  If a  *	positive drop threshold is supplied packets are dropped and their  *	buffers recycled if (a) the number of remaining buffers is under the  *	threshold and the packet is too big to copy, or (b) the packet should  *	be copied but there is no memory for the copy.  */
end_comment

begin_function
specifier|static
name|int
name|get_packet
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|drop_thres
parameter_list|,
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|rsp_desc
modifier|*
name|r
parameter_list|)
block|{
name|unsigned
name|int
name|len_cq
init|=
name|ntohl
argument_list|(
name|r
operator|->
name|len_cq
argument_list|)
decl_stmt|;
name|struct
name|sge_fl
modifier|*
name|fl
init|=
operator|(
name|len_cq
operator|&
name|F_RSPD_FLQ
operator|)
condition|?
operator|&
name|qs
operator|->
name|fl
index|[
literal|1
index|]
else|:
operator|&
name|qs
operator|->
name|fl
index|[
literal|0
index|]
decl_stmt|;
name|struct
name|rx_sw_desc
modifier|*
name|sd
init|=
operator|&
name|fl
operator|->
name|sdesc
index|[
name|fl
operator|->
name|cidx
index|]
decl_stmt|;
name|uint32_t
name|len
init|=
name|G_RSPD_LEN
argument_list|(
name|len_cq
argument_list|)
decl_stmt|;
name|uint32_t
name|flags
init|=
name|ntohl
argument_list|(
name|r
operator|->
name|flags
argument_list|)
decl_stmt|;
name|uint8_t
name|sopeop
init|=
name|G_RSPD_SOP_EOP
argument_list|(
name|flags
argument_list|)
decl_stmt|;
name|void
modifier|*
name|cl
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|prefetch
argument_list|(
name|sd
operator|->
name|cl
argument_list|)
expr_stmt|;
name|fl
operator|->
name|credits
operator|--
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|fl
operator|->
name|entry_tag
argument_list|,
name|sd
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|recycle_enable
operator|&&
name|len
operator|<=
name|SGE_RX_COPY_THRES
operator|&&
name|sopeop
operator|==
name|RSPQ_SOP_EOP
condition|)
block|{
name|cl
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cl
argument_list|,
name|sd
operator|->
name|cl
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|recycle_rx_buf
argument_list|(
name|adap
argument_list|,
name|fl
argument_list|,
name|fl
operator|->
name|cidx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cl
operator|=
name|sd
operator|->
name|cl
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|fl
operator|->
name|entry_tag
argument_list|,
name|sd
operator|->
name|map
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|sopeop
condition|)
block|{
case|case
name|RSPQ_SOP_EOP
case|:
name|DBG
argument_list|(
name|DBG_RX
argument_list|,
operator|(
literal|"get_packet: SOP-EOP m %p\n"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
operator|==
name|sd
operator|->
name|cl
condition|)
name|m_cljset
argument_list|(
name|m
argument_list|,
name|cl
argument_list|,
name|fl
operator|->
name|type
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
break|break;
case|case
name|RSPQ_NSOP_NEOP
case|:
name|DBG
argument_list|(
name|DBG_RX
argument_list|,
operator|(
literal|"get_packet: NO_SOP-NO_EOP m %p\n"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|RSPQ_SOP
case|:
name|DBG
argument_list|(
name|DBG_RX
argument_list|,
operator|(
literal|"get_packet: SOP m %p\n"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|m_iovinit
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|RSPQ_EOP
case|:
name|DBG
argument_list|(
name|DBG_RX
argument_list|,
operator|(
literal|"get_packet: EOP m %p\n"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|m_iovappend
argument_list|(
name|m
argument_list|,
name|cl
argument_list|,
name|fl
operator|->
name|buf_size
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
operator|++
name|fl
operator|->
name|cidx
operator|==
name|fl
operator|->
name|size
condition|)
name|fl
operator|->
name|cidx
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	handle_rsp_cntrl_info - handles control information in a response  *	@qs: the queue set corresponding to the response  *	@flags: the response control flags  *  *	Handles the control information of an SGE response, such as GTS  *	indications and completion credits for the queue set's Tx queues.  *	HW coalesces credits, we don't do any extra SW coalescing.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|handle_rsp_cntrl_info
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|unsigned
name|int
name|credits
decl_stmt|;
if|#
directive|if
name|USE_GTS
if|if
condition|(
name|flags
operator|&
name|F_RSPD_TXQ0_GTS
condition|)
name|clear_bit
argument_list|(
name|TXQ_RUNNING
argument_list|,
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|credits
operator|=
name|G_RSPD_TXQ0_CR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|credits
condition|)
block|{
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|processed
operator|+=
name|credits
expr_stmt|;
if|if
condition|(
name|desc_reclaimable
argument_list|(
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
argument_list|)
operator|>
name|TX_START_MAX_DESC
condition|)
name|taskqueue_enqueue
argument_list|(
name|qs
operator|->
name|port
operator|->
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|qs
operator|->
name|port
operator|->
name|adapter
operator|->
name|timer_reclaim_task
argument_list|)
expr_stmt|;
block|}
name|credits
operator|=
name|G_RSPD_TXQ2_CR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|credits
condition|)
name|qs
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
operator|.
name|processed
operator|+=
name|credits
expr_stmt|;
if|#
directive|if
name|USE_GTS
if|if
condition|(
name|flags
operator|&
name|F_RSPD_TXQ1_GTS
condition|)
name|clear_bit
argument_list|(
name|TXQ_RUNNING
argument_list|,
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
operator|.
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|credits
operator|=
name|G_RSPD_TXQ1_CR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|credits
condition|)
name|qs
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
operator|.
name|processed
operator|+=
name|credits
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_ring_db
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|unsigned
name|int
name|sleeping
parameter_list|)
block|{
empty_stmt|;
block|}
end_function

begin_comment
comment|/**  *	process_responses - process responses from an SGE response queue  *	@adap: the adapter  *	@qs: the queue set to which the response queue belongs  *	@budget: how many responses can be processed in this round  *  *	Process responses from an SGE response queue up to the supplied budget.  *	Responses include received packets as well as credits and other events  *	for the queues that belong to the response queue's queue set.  *	A negative budget is effectively unlimited.  *  *	Additionally choose the interrupt holdoff time for the next interrupt  *	on this queue.  If the system is under memory shortage use a fairly  *	long delay to help recovery.  */
end_comment

begin_function
specifier|static
name|int
name|process_responses
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|int
name|budget
parameter_list|)
block|{
name|struct
name|sge_rspq
modifier|*
name|rspq
init|=
operator|&
name|qs
operator|->
name|rspq
decl_stmt|;
name|struct
name|rsp_desc
modifier|*
name|r
init|=
operator|&
name|rspq
operator|->
name|desc
index|[
name|rspq
operator|->
name|cidx
index|]
decl_stmt|;
name|int
name|budget_left
init|=
name|budget
decl_stmt|;
name|unsigned
name|int
name|sleeping
init|=
literal|0
decl_stmt|;
name|int
name|lro
init|=
name|qs
operator|->
name|lro
operator|.
name|enabled
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|offload_mbufs
index|[
name|RX_BUNDLE_SIZE
index|]
decl_stmt|;
name|int
name|ngathered
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
specifier|static
name|int
name|last_holdoff
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|rspq
operator|->
name|holdoff_tmr
operator|!=
name|last_holdoff
condition|)
block|{
name|printf
argument_list|(
literal|"next_holdoff=%d\n"
argument_list|,
name|rspq
operator|->
name|holdoff_tmr
argument_list|)
expr_stmt|;
name|last_holdoff
operator|=
name|rspq
operator|->
name|holdoff_tmr
expr_stmt|;
block|}
endif|#
directive|endif
name|rspq
operator|->
name|next_holdoff
operator|=
name|rspq
operator|->
name|holdoff_tmr
expr_stmt|;
while|while
condition|(
name|__predict_true
argument_list|(
name|budget_left
operator|&&
name|is_new_response
argument_list|(
name|r
argument_list|,
name|rspq
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|eth
decl_stmt|,
name|eop
init|=
literal|0
decl_stmt|,
name|ethpad
init|=
literal|0
decl_stmt|;
name|uint32_t
name|flags
init|=
name|ntohl
argument_list|(
name|r
operator|->
name|flags
argument_list|)
decl_stmt|;
name|uint32_t
name|rss_csum
init|=
operator|*
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|r
decl_stmt|;
name|uint32_t
name|rss_hash
init|=
name|r
operator|->
name|rss_hdr
operator|.
name|rss_hash_val
decl_stmt|;
name|eth
operator|=
operator|(
name|r
operator|->
name|rss_hdr
operator|.
name|opcode
operator|==
name|CPL_RX_PKT
operator|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|flags
operator|&
name|F_RSPD_ASYNC_NOTIF
argument_list|)
condition|)
block|{
comment|/* XXX */
name|printf
argument_list|(
literal|"async notification\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|F_RSPD_IMM_DATA_VALID
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|cxgb_debug
condition|)
name|printf
argument_list|(
literal|"IMM DATA VALID\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rspq
operator|->
name|m
operator|==
name|NULL
condition|)
name|rspq
operator|->
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
else|else
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|rspq
operator|->
name|m
operator|==
name|NULL
operator|||
name|m
operator|==
name|NULL
condition|)
block|{
name|rspq
operator|->
name|next_holdoff
operator|=
name|NOMEM_INTR_DELAY
expr_stmt|;
name|budget_left
operator|--
expr_stmt|;
break|break;
block|}
name|get_imm_packet
argument_list|(
name|adap
argument_list|,
name|r
argument_list|,
name|rspq
operator|->
name|m
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|eop
operator|=
literal|1
expr_stmt|;
name|rspq
operator|->
name|imm_data
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|->
name|len_cq
condition|)
block|{
name|int
name|drop_thresh
init|=
name|eth
condition|?
name|SGE_RX_DROP_THRES
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|rspq
operator|->
name|m
operator|==
name|NULL
condition|)
name|rspq
operator|->
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|rspq
operator|->
name|m
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"failed to get mbuf for packet\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|ethpad
operator|=
literal|2
expr_stmt|;
name|eop
operator|=
name|get_packet
argument_list|(
name|adap
argument_list|,
name|drop_thresh
argument_list|,
name|qs
argument_list|,
name|rspq
operator|->
name|m
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
literal|"pure response\n"
argument_list|)
expr_stmt|;
name|rspq
operator|->
name|pure_rsps
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|RSPD_CTRL_MASK
condition|)
block|{
name|sleeping
operator||=
name|flags
operator|&
name|RSPD_GTS_MASK
expr_stmt|;
name|handle_rsp_cntrl_info
argument_list|(
name|qs
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|r
operator|++
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|++
name|rspq
operator|->
name|cidx
operator|==
name|rspq
operator|->
name|size
argument_list|)
condition|)
block|{
name|rspq
operator|->
name|cidx
operator|=
literal|0
expr_stmt|;
name|rspq
operator|->
name|gen
operator|^=
literal|1
expr_stmt|;
name|r
operator|=
name|rspq
operator|->
name|desc
expr_stmt|;
block|}
name|prefetch
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|rspq
operator|->
name|credits
operator|>=
operator|(
name|rspq
operator|->
name|size
operator|/
literal|4
operator|)
condition|)
block|{
name|refill_rspq
argument_list|(
name|adap
argument_list|,
name|rspq
argument_list|,
name|rspq
operator|->
name|credits
argument_list|)
expr_stmt|;
name|rspq
operator|->
name|credits
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|eop
condition|)
block|{
name|prefetch
argument_list|(
name|rspq
operator|->
name|m
operator|->
name|m_data
argument_list|)
expr_stmt|;
name|prefetch
argument_list|(
name|rspq
operator|->
name|m
operator|->
name|m_data
operator|+
name|L1_CACHE_BYTES
argument_list|)
expr_stmt|;
if|if
condition|(
name|eth
condition|)
block|{
name|t3_rx_eth_lro
argument_list|(
name|adap
argument_list|,
name|rspq
argument_list|,
name|rspq
operator|->
name|m
argument_list|,
name|ethpad
argument_list|,
name|rss_hash
argument_list|,
name|rss_csum
argument_list|,
name|lro
argument_list|)
expr_stmt|;
name|rspq
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|rspq
operator|->
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
name|rss_csum
expr_stmt|;
comment|/* 				 * XXX size mismatch 				 */
name|m_set_priority
argument_list|(
name|rspq
operator|->
name|m
argument_list|,
name|rss_hash
argument_list|)
expr_stmt|;
name|ngathered
operator|=
name|rx_offload
argument_list|(
operator|&
name|adap
operator|->
name|tdev
argument_list|,
name|rspq
argument_list|,
name|rspq
operator|->
name|m
argument_list|,
name|offload_mbufs
argument_list|,
name|ngathered
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|notyet
name|taskqueue_enqueue
argument_list|(
name|adap
operator|->
name|tq
argument_list|,
operator|&
name|adap
operator|->
name|timer_reclaim_task
argument_list|)
expr_stmt|;
else|#
directive|else
name|__refill_fl
argument_list|(
name|adap
argument_list|,
operator|&
name|qs
operator|->
name|fl
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|__refill_fl
argument_list|(
name|adap
argument_list|,
operator|&
name|qs
operator|->
name|fl
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
operator|--
name|budget_left
expr_stmt|;
block|}
name|deliver_partial_bundle
argument_list|(
operator|&
name|adap
operator|->
name|tdev
argument_list|,
name|rspq
argument_list|,
name|offload_mbufs
argument_list|,
name|ngathered
argument_list|)
expr_stmt|;
name|t3_lro_flush
argument_list|(
name|adap
argument_list|,
name|qs
argument_list|,
operator|&
name|qs
operator|->
name|lro
argument_list|)
expr_stmt|;
if|if
condition|(
name|sleeping
condition|)
name|check_ring_db
argument_list|(
name|adap
argument_list|,
name|qs
argument_list|,
name|sleeping
argument_list|)
expr_stmt|;
name|smp_mb
argument_list|()
expr_stmt|;
comment|/* commit Tx queue processed updates */
if|if
condition|(
name|__predict_false
argument_list|(
name|qs
operator|->
name|txq_stopped
operator|!=
literal|0
argument_list|)
condition|)
name|restart_tx
argument_list|(
name|qs
argument_list|)
expr_stmt|;
name|budget
operator|-=
name|budget_left
expr_stmt|;
return|return
operator|(
name|budget
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * A helper function that processes responses and issues GTS.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|process_responses_gts
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|struct
name|sge_rspq
modifier|*
name|rq
parameter_list|)
block|{
name|int
name|work
decl_stmt|;
specifier|static
name|int
name|last_holdoff
init|=
literal|0
decl_stmt|;
name|work
operator|=
name|process_responses
argument_list|(
name|adap
argument_list|,
name|rspq_to_qset
argument_list|(
name|rq
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cxgb_debug
operator|&&
operator|(
name|rq
operator|->
name|next_holdoff
operator|!=
name|last_holdoff
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"next_holdoff=%d\n"
argument_list|,
name|rq
operator|->
name|next_holdoff
argument_list|)
expr_stmt|;
name|last_holdoff
operator|=
name|rq
operator|->
name|next_holdoff
expr_stmt|;
block|}
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_GTS
argument_list|,
name|V_RSPQ
argument_list|(
name|rq
operator|->
name|cntxt_id
argument_list|)
operator||
name|V_NEWTIMER
argument_list|(
name|rq
operator|->
name|next_holdoff
argument_list|)
operator||
name|V_NEWINDEX
argument_list|(
name|rq
operator|->
name|cidx
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|work
return|;
block|}
end_function

begin_comment
comment|/*  * Interrupt handler for legacy INTx interrupts for T3B-based cards.  * Handles data events from SGE response queues as well as error and other  * async events as they all use the same interrupt pin.  We use one SGE  * response queue per port in this mode and protect all response queues with  * queue 0's lock.  */
end_comment

begin_function
name|void
name|t3b_intr
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|uint32_t
name|map
decl_stmt|;
name|adapter_t
modifier|*
name|adap
init|=
name|data
decl_stmt|;
name|struct
name|sge_rspq
modifier|*
name|q0
init|=
operator|&
name|adap
operator|->
name|sge
operator|.
name|qs
index|[
literal|0
index|]
operator|.
name|rspq
decl_stmt|;
name|struct
name|sge_rspq
modifier|*
name|q1
init|=
operator|&
name|adap
operator|->
name|sge
operator|.
name|qs
index|[
literal|1
index|]
operator|.
name|rspq
decl_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_PL_CLI
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|map
operator|=
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_DATA_INTR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|map
condition|)
return|return;
if|if
condition|(
name|__predict_false
argument_list|(
name|map
operator|&
name|F_ERRINTR
argument_list|)
condition|)
name|taskqueue_enqueue
argument_list|(
name|adap
operator|->
name|tq
argument_list|,
operator|&
name|adap
operator|->
name|slow_intr_task
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|q0
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
name|map
operator|&
literal|1
argument_list|)
condition|)
name|process_responses_gts
argument_list|(
name|adap
argument_list|,
name|q0
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|&
literal|2
condition|)
name|process_responses_gts
argument_list|(
name|adap
argument_list|,
name|q1
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|q0
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The MSI interrupt handler.  This needs to handle data events from SGE  * response queues as well as error and other async events as they all use  * the same MSI vector.  We use one SGE response queue per port in this mode  * and protect all response queues with queue 0's lock.  */
end_comment

begin_function
name|void
name|t3_intr_msi
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|adapter_t
modifier|*
name|adap
init|=
name|data
decl_stmt|;
name|struct
name|sge_rspq
modifier|*
name|q0
init|=
operator|&
name|adap
operator|->
name|sge
operator|.
name|qs
index|[
literal|0
index|]
operator|.
name|rspq
decl_stmt|;
name|struct
name|sge_rspq
modifier|*
name|q1
init|=
operator|&
name|adap
operator|->
name|sge
operator|.
name|qs
index|[
literal|1
index|]
operator|.
name|rspq
decl_stmt|;
name|int
name|new_packets
init|=
literal|0
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|q0
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|process_responses_gts
argument_list|(
name|adap
argument_list|,
name|q0
argument_list|)
condition|)
block|{
name|new_packets
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|adap
operator|->
name|params
operator|.
name|nports
operator|==
literal|2
operator|&&
name|process_responses_gts
argument_list|(
name|adap
argument_list|,
name|q1
argument_list|)
condition|)
block|{
name|new_packets
operator|=
literal|1
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|q0
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_packets
operator|==
literal|0
condition|)
name|taskqueue_enqueue
argument_list|(
name|adap
operator|->
name|tq
argument_list|,
operator|&
name|adap
operator|->
name|slow_intr_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t3_intr_msix
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|sge_qset
modifier|*
name|qs
init|=
name|data
decl_stmt|;
name|adapter_t
modifier|*
name|adap
init|=
name|qs
operator|->
name|port
operator|->
name|adapter
decl_stmt|;
name|struct
name|sge_rspq
modifier|*
name|rspq
init|=
operator|&
name|qs
operator|->
name|rspq
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|rspq
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|process_responses_gts
argument_list|(
name|adap
argument_list|,
name|rspq
argument_list|)
operator|==
literal|0
condition|)
name|rspq
operator|->
name|unhandled_irqs
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|rspq
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * broken by recent mbuf changes   */
end_comment

begin_function
specifier|static
name|int
name|t3_lro_enable
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|adapter_t
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|enabled
decl_stmt|,
name|err
decl_stmt|,
name|nqsets
init|=
literal|0
decl_stmt|;
ifndef|#
directive|ifndef
name|LRO_WORKING
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
name|sc
operator|=
name|arg1
expr_stmt|;
name|enabled
operator|=
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
literal|0
index|]
operator|.
name|lro
operator|.
name|enabled
expr_stmt|;
name|err
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|enabled
argument_list|,
name|arg2
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|enabled
operator|==
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
literal|0
index|]
operator|.
name|lro
operator|.
name|enabled
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|params
operator|.
name|nports
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sc
operator|->
name|port
index|[
name|i
index|]
operator|.
name|nqsets
condition|;
name|j
operator|++
control|)
name|nqsets
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nqsets
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
name|i
index|]
operator|.
name|lro
operator|.
name|enabled
operator|=
name|enabled
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|t3_set_coalesce_nsecs
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|adapter_t
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|qset_params
modifier|*
name|qsp
init|=
operator|&
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|qset
index|[
literal|0
index|]
decl_stmt|;
name|int
name|coalesce_nsecs
decl_stmt|;
name|struct
name|sge_qset
modifier|*
name|qs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|err
decl_stmt|,
name|nqsets
init|=
literal|0
decl_stmt|;
name|struct
name|mtx
modifier|*
name|lock
decl_stmt|;
name|coalesce_nsecs
operator|=
name|qsp
operator|->
name|coalesce_nsecs
expr_stmt|;
name|err
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|coalesce_nsecs
argument_list|,
name|arg2
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|coalesce_nsecs
operator|==
name|qsp
operator|->
name|coalesce_nsecs
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|params
operator|.
name|nports
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sc
operator|->
name|port
index|[
name|i
index|]
operator|.
name|nqsets
condition|;
name|j
operator|++
control|)
name|nqsets
operator|++
expr_stmt|;
name|coalesce_nsecs
operator|=
name|max
argument_list|(
literal|100
argument_list|,
name|coalesce_nsecs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nqsets
condition|;
name|i
operator|++
control|)
block|{
name|qs
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
name|i
index|]
expr_stmt|;
name|qsp
operator|=
operator|&
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|qset
index|[
name|i
index|]
expr_stmt|;
name|qsp
operator|->
name|coalesce_nsecs
operator|=
name|coalesce_nsecs
expr_stmt|;
name|lock
operator|=
operator|(
name|sc
operator|->
name|flags
operator|&
name|USING_MSIX
operator|)
condition|?
operator|&
name|qs
operator|->
name|rspq
operator|.
name|lock
else|:
operator|&
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
literal|0
index|]
operator|.
name|rspq
operator|.
name|lock
expr_stmt|;
name|mtx_lock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|t3_update_qset_coalesce
argument_list|(
name|qs
argument_list|,
name|qsp
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|A_SG_GTS
argument_list|,
name|V_RSPQ
argument_list|(
name|qs
operator|->
name|rspq
operator|.
name|cntxt_id
argument_list|)
operator||
name|V_NEWTIMER
argument_list|(
name|qs
operator|->
name|rspq
operator|.
name|holdoff_tmr
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|t3_add_sysctls
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|children
decl_stmt|;
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* random information */
name|SYSCTL_ADD_STRING
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"firmware_version"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|fw_version
argument_list|,
literal|0
argument_list|,
literal|"firmware version"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"enable_lro"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|t3_lro_enable
argument_list|,
literal|"I"
argument_list|,
literal|"enable large receive offload"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"intr_coal"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|t3_set_coalesce_nsecs
argument_list|,
literal|"I"
argument_list|,
literal|"interrupt coalescing timer (ns)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"enable_debug"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|cxgb_debug
argument_list|,
literal|0
argument_list|,
literal|"enable verbose debugging output"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"collapse_free"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|collapse_free
argument_list|,
literal|0
argument_list|,
literal|"frees during collapse"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mb_free_vec_free"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|mb_free_vec_free
argument_list|,
literal|0
argument_list|,
literal|"frees during mb_free_vec"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"collapse_mbufs"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|collapse_mbufs
argument_list|,
literal|0
argument_list|,
literal|"collapse mbuf chains into iovecs"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t3_get_desc - dump an SGE descriptor for debugging purposes  *	@qs: the queue set  *	@qnum: identifies the specific queue (0..2: Tx, 3:response, 4..5: Rx)  *	@idx: the descriptor index in the queue  *	@data: where to dump the descriptor contents  *  *	Dumps the contents of a HW descriptor of an SGE queue.  Returns the  *	size of the descriptor.  */
end_comment

begin_function
name|int
name|t3_get_desc
parameter_list|(
specifier|const
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|unsigned
name|int
name|qnum
parameter_list|,
name|unsigned
name|int
name|idx
parameter_list|,
name|unsigned
name|char
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|qnum
operator|>=
literal|6
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|qnum
operator|<
literal|3
condition|)
block|{
if|if
condition|(
operator|!
name|qs
operator|->
name|txq
index|[
name|qnum
index|]
operator|.
name|desc
operator|||
name|idx
operator|>=
name|qs
operator|->
name|txq
index|[
name|qnum
index|]
operator|.
name|size
condition|)
return|return
operator|-
name|EINVAL
return|;
name|memcpy
argument_list|(
name|data
argument_list|,
operator|&
name|qs
operator|->
name|txq
index|[
name|qnum
index|]
operator|.
name|desc
index|[
name|idx
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tx_desc
argument_list|)
argument_list|)
expr_stmt|;
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|tx_desc
argument_list|)
return|;
block|}
if|if
condition|(
name|qnum
operator|==
literal|3
condition|)
block|{
if|if
condition|(
operator|!
name|qs
operator|->
name|rspq
operator|.
name|desc
operator|||
name|idx
operator|>=
name|qs
operator|->
name|rspq
operator|.
name|size
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|memcpy
argument_list|(
name|data
argument_list|,
operator|&
name|qs
operator|->
name|rspq
operator|.
name|desc
index|[
name|idx
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rsp_desc
argument_list|)
argument_list|)
expr_stmt|;
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|rsp_desc
argument_list|)
return|;
block|}
name|qnum
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
operator|!
name|qs
operator|->
name|fl
index|[
name|qnum
index|]
operator|.
name|desc
operator|||
name|idx
operator|>=
name|qs
operator|->
name|fl
index|[
name|qnum
index|]
operator|.
name|size
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|memcpy
argument_list|(
name|data
argument_list|,
operator|&
name|qs
operator|->
name|fl
index|[
name|qnum
index|]
operator|.
name|desc
index|[
name|idx
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rx_desc
argument_list|)
argument_list|)
expr_stmt|;
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|rx_desc
argument_list|)
return|;
block|}
end_function

end_unit

