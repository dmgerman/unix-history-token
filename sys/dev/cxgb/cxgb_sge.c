begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************************  Copyright (c) 2007-2009, Chelsio Inc. All rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:   1. Redistributions of source code must retain the above copyright notice,     this list of conditions and the following disclaimer.   2. Neither the name of the Chelsio Corporation nor the names of its     contributors may be used to endorse or promote products derived from     this software without specific prior written permission.   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus_dma.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<cxgb_include.h>
end_include

begin_include
include|#
directive|include
file|<sys/mvec.h>
end_include

begin_decl_stmt
name|int
name|txq_fills
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|multiq_tx_enable
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|sysctl_oid_list
name|sysctl__hw_cxgb_children
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cxgb_txq_buf_ring_size
init|=
name|TX_ETH_Q_SIZE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgb.txq_mr_size"
argument_list|,
operator|&
name|cxgb_txq_buf_ring_size
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_cxgb
argument_list|,
name|OID_AUTO
argument_list|,
name|txq_mr_size
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|cxgb_txq_buf_ring_size
argument_list|,
literal|0
argument_list|,
literal|"size of per-queue mbuf ring"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|cxgb_tx_coalesce_force
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgb.tx_coalesce_force"
argument_list|,
operator|&
name|cxgb_tx_coalesce_force
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_cxgb
argument_list|,
name|OID_AUTO
argument_list|,
name|tx_coalesce_force
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|cxgb_tx_coalesce_force
argument_list|,
literal|0
argument_list|,
literal|"coalesce small packets into a single work request regardless of ring state"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|COALESCE_START_DEFAULT
value|TX_ETH_Q_SIZE>>1
end_define

begin_define
define|#
directive|define
name|COALESCE_START_MAX
value|(TX_ETH_Q_SIZE-(TX_ETH_Q_SIZE>>3))
end_define

begin_define
define|#
directive|define
name|COALESCE_STOP_DEFAULT
value|TX_ETH_Q_SIZE>>2
end_define

begin_define
define|#
directive|define
name|COALESCE_STOP_MIN
value|TX_ETH_Q_SIZE>>5
end_define

begin_define
define|#
directive|define
name|TX_RECLAIM_DEFAULT
value|TX_ETH_Q_SIZE>>5
end_define

begin_define
define|#
directive|define
name|TX_RECLAIM_MAX
value|TX_ETH_Q_SIZE>>2
end_define

begin_define
define|#
directive|define
name|TX_RECLAIM_MIN
value|TX_ETH_Q_SIZE>>6
end_define

begin_decl_stmt
specifier|static
name|int
name|cxgb_tx_coalesce_enable_start
init|=
name|COALESCE_START_DEFAULT
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgb.tx_coalesce_enable_start"
argument_list|,
operator|&
name|cxgb_tx_coalesce_enable_start
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_cxgb
argument_list|,
name|OID_AUTO
argument_list|,
name|tx_coalesce_enable_start
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|cxgb_tx_coalesce_enable_start
argument_list|,
literal|0
argument_list|,
literal|"coalesce enable threshold"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|cxgb_tx_coalesce_enable_stop
init|=
name|COALESCE_STOP_DEFAULT
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgb.tx_coalesce_enable_stop"
argument_list|,
operator|&
name|cxgb_tx_coalesce_enable_stop
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_cxgb
argument_list|,
name|OID_AUTO
argument_list|,
name|tx_coalesce_enable_stop
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|cxgb_tx_coalesce_enable_stop
argument_list|,
literal|0
argument_list|,
literal|"coalesce disable threshold"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|cxgb_tx_reclaim_threshold
init|=
name|TX_RECLAIM_DEFAULT
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgb.tx_reclaim_threshold"
argument_list|,
operator|&
name|cxgb_tx_reclaim_threshold
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_cxgb
argument_list|,
name|OID_AUTO
argument_list|,
name|tx_reclaim_threshold
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|cxgb_tx_reclaim_threshold
argument_list|,
literal|0
argument_list|,
literal|"tx cleaning minimum threshold"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * XXX don't re-enable this until TOE stops assuming  * we have an m_ext  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|recycle_enable
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|cxgb_use_16k_clusters
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nmbjumbop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nmbjumbo9
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nmbjumbo16
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|USE_GTS
value|0
end_define

begin_define
define|#
directive|define
name|SGE_RX_SM_BUF_SIZE
value|1536
end_define

begin_define
define|#
directive|define
name|SGE_RX_DROP_THRES
value|16
end_define

begin_define
define|#
directive|define
name|SGE_RX_COPY_THRES
value|128
end_define

begin_comment
comment|/*  * Period of the Tx buffer reclaim timer.  This timer does not need to run  * frequently as Tx buffers are usually reclaimed by new Tx packets.  */
end_comment

begin_define
define|#
directive|define
name|TX_RECLAIM_PERIOD
value|(hz>> 1)
end_define

begin_comment
comment|/*   * Values for sge_txq.flags  */
end_comment

begin_enum
enum|enum
block|{
name|TXQ_RUNNING
init|=
literal|1
operator|<<
literal|0
block|,
comment|/* fetch engine is running */
name|TXQ_LAST_PKT_DB
init|=
literal|1
operator|<<
literal|1
block|,
comment|/* last packet rang the doorbell */
block|}
enum|;
end_enum

begin_struct
struct|struct
name|tx_desc
block|{
name|uint64_t
name|flit
index|[
name|TX_DESC_FLITS
index|]
decl_stmt|;
block|}
name|__packed
struct|;
end_struct

begin_struct
struct|struct
name|rx_desc
block|{
name|uint32_t
name|addr_lo
decl_stmt|;
name|uint32_t
name|len_gen
decl_stmt|;
name|uint32_t
name|gen2
decl_stmt|;
name|uint32_t
name|addr_hi
decl_stmt|;
block|}
name|__packed
struct|;
end_struct

begin_struct
struct|struct
name|rsp_desc
block|{
comment|/* response queue descriptor */
name|struct
name|rss_header
name|rss_hdr
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|uint32_t
name|len_cq
decl_stmt|;
name|uint8_t
name|imm_data
index|[
literal|47
index|]
decl_stmt|;
name|uint8_t
name|intr_gen
decl_stmt|;
block|}
name|__packed
struct|;
end_struct

begin_define
define|#
directive|define
name|RX_SW_DESC_MAP_CREATED
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|TX_SW_DESC_MAP_CREATED
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|RX_SW_DESC_INUSE
value|(1<< 3)
end_define

begin_define
define|#
directive|define
name|TX_SW_DESC_MAPPED
value|(1<< 4)
end_define

begin_define
define|#
directive|define
name|RSPQ_NSOP_NEOP
value|G_RSPD_SOP_EOP(0)
end_define

begin_define
define|#
directive|define
name|RSPQ_EOP
value|G_RSPD_SOP_EOP(F_RSPD_EOP)
end_define

begin_define
define|#
directive|define
name|RSPQ_SOP
value|G_RSPD_SOP_EOP(F_RSPD_SOP)
end_define

begin_define
define|#
directive|define
name|RSPQ_SOP_EOP
value|G_RSPD_SOP_EOP(F_RSPD_SOP|F_RSPD_EOP)
end_define

begin_struct
struct|struct
name|tx_sw_desc
block|{
comment|/* SW state per Tx descriptor */
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|rx_sw_desc
block|{
comment|/* SW state per Rx descriptor */
name|caddr_t
name|rxsd_cl
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|txq_state
block|{
name|unsigned
name|int
name|compl
decl_stmt|;
name|unsigned
name|int
name|gen
decl_stmt|;
name|unsigned
name|int
name|pidx
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|refill_fl_cb_arg
block|{
name|int
name|error
decl_stmt|;
name|bus_dma_segment_t
name|seg
decl_stmt|;
name|int
name|nseg
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Maps a number of flits to the number of Tx descriptors that can hold them.  * The formula is  *  * desc = 1 + (flits - 2) / (WR_FLITS - 1).  *  * HW allows up to 4 descriptors to be combined into a WR.  */
end_comment

begin_decl_stmt
specifier|static
name|uint8_t
name|flit_desc_map
index|[]
init|=
block|{
literal|0
block|,
if|#
directive|if
name|SGE_NUM_GENBITS
operator|==
literal|1
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
elif|#
directive|elif
name|SGE_NUM_GENBITS
operator|==
literal|2
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
else|#
directive|else
error|#
directive|error
literal|"SGE_NUM_GENBITS must be 1 or 2"
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TXQ_LOCK_ASSERT
parameter_list|(
name|qs
parameter_list|)
value|mtx_assert(&(qs)->lock, MA_OWNED)
end_define

begin_define
define|#
directive|define
name|TXQ_TRYLOCK
parameter_list|(
name|qs
parameter_list|)
value|mtx_trylock(&(qs)->lock)
end_define

begin_define
define|#
directive|define
name|TXQ_LOCK
parameter_list|(
name|qs
parameter_list|)
value|mtx_lock(&(qs)->lock)
end_define

begin_define
define|#
directive|define
name|TXQ_UNLOCK
parameter_list|(
name|qs
parameter_list|)
value|mtx_unlock(&(qs)->lock)
end_define

begin_define
define|#
directive|define
name|TXQ_RING_EMPTY
parameter_list|(
name|qs
parameter_list|)
value|drbr_empty((qs)->port->ifp, (qs)->txq[TXQ_ETH].txq_mr)
end_define

begin_define
define|#
directive|define
name|TXQ_RING_NEEDS_ENQUEUE
parameter_list|(
name|qs
parameter_list|)
define|\
value|drbr_needs_enqueue((qs)->port->ifp, (qs)->txq[TXQ_ETH].txq_mr)
end_define

begin_define
define|#
directive|define
name|TXQ_RING_FLUSH
parameter_list|(
name|qs
parameter_list|)
value|drbr_flush((qs)->port->ifp, (qs)->txq[TXQ_ETH].txq_mr)
end_define

begin_define
define|#
directive|define
name|TXQ_RING_DEQUEUE_COND
parameter_list|(
name|qs
parameter_list|,
name|func
parameter_list|,
name|arg
parameter_list|)
define|\
value|drbr_dequeue_cond((qs)->port->ifp, (qs)->txq[TXQ_ETH].txq_mr, func, arg)
end_define

begin_define
define|#
directive|define
name|TXQ_RING_DEQUEUE
parameter_list|(
name|qs
parameter_list|)
define|\
value|drbr_dequeue((qs)->port->ifp, (qs)->txq[TXQ_ETH].txq_mr)
end_define

begin_decl_stmt
name|int
name|cxgb_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|sge_timer_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sge_timer_reclaim
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|ncount
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sge_txq_reclaim_handler
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|ncount
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgb_start_locked
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * XXX need to cope with bursty scheduling by looking at a wider  * window than we are now for determining the need for coalescing  *  */
end_comment

begin_function
specifier|static
name|__inline
name|uint64_t
name|check_pkt_coalesce
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
name|uint8_t
modifier|*
name|fill
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|cxgb_tx_coalesce_force
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|txq
operator|=
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
expr_stmt|;
name|sc
operator|=
name|qs
operator|->
name|port
operator|->
name|adapter
expr_stmt|;
name|fill
operator|=
operator|&
name|sc
operator|->
name|tunq_fill
index|[
name|qs
operator|->
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|cxgb_tx_coalesce_enable_start
operator|>
name|COALESCE_START_MAX
condition|)
name|cxgb_tx_coalesce_enable_start
operator|=
name|COALESCE_START_MAX
expr_stmt|;
if|if
condition|(
name|cxgb_tx_coalesce_enable_stop
operator|<
name|COALESCE_STOP_MIN
condition|)
name|cxgb_tx_coalesce_enable_start
operator|=
name|COALESCE_STOP_MIN
expr_stmt|;
comment|/* 	 * if the hardware transmit queue is more than 1/8 full 	 * we mark it as coalescing - we drop back from coalescing 	 * when we go below 1/32 full and there are no packets enqueued,  	 * this provides us with some degree of hysteresis 	 */
if|if
condition|(
operator|*
name|fill
operator|!=
literal|0
operator|&&
operator|(
name|txq
operator|->
name|in_use
operator|<=
name|cxgb_tx_coalesce_enable_stop
operator|)
operator|&&
name|TXQ_RING_EMPTY
argument_list|(
name|qs
argument_list|)
operator|&&
operator|(
name|qs
operator|->
name|coalescing
operator|==
literal|0
operator|)
condition|)
operator|*
name|fill
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|fill
operator|==
literal|0
operator|&&
operator|(
name|txq
operator|->
name|in_use
operator|>=
name|cxgb_tx_coalesce_enable_start
operator|)
condition|)
operator|*
name|fill
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|sc
operator|->
name|tunq_coalesce
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__LP64__
end_ifdef

begin_function
specifier|static
name|void
name|set_wr_hdr
parameter_list|(
name|struct
name|work_request_hdr
modifier|*
name|wrp
parameter_list|,
name|uint32_t
name|wr_hi
parameter_list|,
name|uint32_t
name|wr_lo
parameter_list|)
block|{
name|uint64_t
name|wr_hilo
decl_stmt|;
if|#
directive|if
name|_BYTE_ORDER
operator|==
name|_LITTLE_ENDIAN
name|wr_hilo
operator|=
name|wr_hi
expr_stmt|;
name|wr_hilo
operator||=
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|wr_lo
operator|)
operator|<<
literal|32
operator|)
expr_stmt|;
else|#
directive|else
name|wr_hilo
operator|=
name|wr_lo
expr_stmt|;
name|wr_hilo
operator||=
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|wr_hi
operator|)
operator|<<
literal|32
operator|)
expr_stmt|;
endif|#
directive|endif
name|wrp
operator|->
name|wrh_hilo
operator|=
name|wr_hilo
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|void
name|set_wr_hdr
parameter_list|(
name|struct
name|work_request_hdr
modifier|*
name|wrp
parameter_list|,
name|uint32_t
name|wr_hi
parameter_list|,
name|uint32_t
name|wr_lo
parameter_list|)
block|{
name|wrp
operator|->
name|wrh_hi
operator|=
name|wr_hi
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
name|wrp
operator|->
name|wrh_lo
operator|=
name|wr_lo
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|coalesce_info
block|{
name|int
name|count
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|coalesce_check
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|coalesce_info
modifier|*
name|ci
init|=
name|arg
decl_stmt|;
name|int
modifier|*
name|count
init|=
operator|&
name|ci
operator|->
name|count
decl_stmt|;
name|int
modifier|*
name|nbytes
init|=
operator|&
name|ci
operator|->
name|nbytes
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|nbytes
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
operator|*
name|nbytes
operator|+
name|m
operator|->
name|m_len
operator|<=
literal|10500
operator|)
operator|&&
operator|(
operator|*
name|count
operator|<
literal|7
operator|)
operator|&&
operator|(
name|m
operator|->
name|m_next
operator|==
name|NULL
operator|)
operator|)
condition|)
block|{
operator|*
name|count
operator|+=
literal|1
expr_stmt|;
operator|*
name|nbytes
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|cxgb_dequeue
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m_head
decl_stmt|,
modifier|*
name|m_tail
decl_stmt|;
name|struct
name|coalesce_info
name|ci
decl_stmt|;
if|if
condition|(
name|check_pkt_coalesce
argument_list|(
name|qs
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TXQ_RING_DEQUEUE
argument_list|(
name|qs
argument_list|)
return|;
name|m_head
operator|=
name|m_tail
operator|=
name|NULL
expr_stmt|;
name|ci
operator|.
name|count
operator|=
name|ci
operator|.
name|nbytes
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|m
operator|=
name|TXQ_RING_DEQUEUE_COND
argument_list|(
name|qs
argument_list|,
name|coalesce_check
argument_list|,
operator|&
name|ci
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_head
operator|==
name|NULL
condition|)
block|{
name|m_tail
operator|=
name|m_head
operator|=
name|m
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|m_tail
operator|->
name|m_nextpkt
operator|=
name|m
expr_stmt|;
name|m_tail
operator|=
name|m
expr_stmt|;
block|}
block|}
do|while
condition|(
name|m
operator|!=
name|NULL
condition|)
do|;
if|if
condition|(
name|ci
operator|.
name|count
operator|>
literal|7
condition|)
name|panic
argument_list|(
literal|"trying to coalesce %d packets in to one WR"
argument_list|,
name|ci
operator|.
name|count
argument_list|)
expr_stmt|;
return|return
operator|(
name|m_head
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	reclaim_completed_tx - reclaims completed Tx descriptors  *	@adapter: the adapter  *	@q: the Tx queue to reclaim completed descriptors from  *  *	Reclaims Tx descriptors that the SGE has indicated it has processed,  *	and frees the associated buffers if possible.  Called with the Tx  *	queue's lock held.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|reclaim_completed_tx
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|int
name|reclaim_min
parameter_list|,
name|int
name|queue
parameter_list|)
block|{
name|struct
name|sge_txq
modifier|*
name|q
init|=
operator|&
name|qs
operator|->
name|txq
index|[
name|queue
index|]
decl_stmt|;
name|int
name|reclaim
init|=
name|desc_reclaimable
argument_list|(
name|q
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|cxgb_tx_reclaim_threshold
operator|>
name|TX_RECLAIM_MAX
operator|)
operator|||
operator|(
name|cxgb_tx_reclaim_threshold
operator|<
name|TX_RECLAIM_MIN
operator|)
condition|)
name|cxgb_tx_reclaim_threshold
operator|=
name|TX_RECLAIM_DEFAULT
expr_stmt|;
if|if
condition|(
name|reclaim
operator|<
name|reclaim_min
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|mtx_assert
argument_list|(
operator|&
name|qs
operator|->
name|lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|reclaim
operator|>
literal|0
condition|)
block|{
name|t3_free_tx_desc
argument_list|(
name|qs
argument_list|,
name|reclaim
argument_list|,
name|queue
argument_list|)
expr_stmt|;
name|q
operator|->
name|cleaned
operator|+=
name|reclaim
expr_stmt|;
name|q
operator|->
name|in_use
operator|-=
name|reclaim
expr_stmt|;
block|}
if|if
condition|(
name|isset
argument_list|(
operator|&
name|qs
operator|->
name|txq_stopped
argument_list|,
name|TXQ_ETH
argument_list|)
condition|)
name|clrbit
argument_list|(
operator|&
name|qs
operator|->
name|txq_stopped
argument_list|,
name|TXQ_ETH
argument_list|)
expr_stmt|;
return|return
operator|(
name|reclaim
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	should_restart_tx - are there enough resources to restart a Tx queue?  *	@q: the Tx queue  *  *	Checks if there are enough descriptors to restart a suspended Tx queue.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|should_restart_tx
parameter_list|(
specifier|const
name|struct
name|sge_txq
modifier|*
name|q
parameter_list|)
block|{
name|unsigned
name|int
name|r
init|=
name|q
operator|->
name|processed
operator|-
name|q
operator|->
name|cleaned
decl_stmt|;
return|return
name|q
operator|->
name|in_use
operator|-
name|r
operator|<
operator|(
name|q
operator|->
name|size
operator|>>
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_sge_init - initialize SGE  *	@adap: the adapter  *	@p: the SGE parameters  *  *	Performs SGE initialization needed every time after a chip reset.  *	We do not initialize any of the queue sets here, instead the driver  *	top-level must request those individually.  We also do not enable DMA  *	here, that should be done after the queues have been set up.  */
end_comment

begin_function
name|void
name|t3_sge_init
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|struct
name|sge_params
modifier|*
name|p
parameter_list|)
block|{
name|u_int
name|ctrl
decl_stmt|,
name|ups
decl_stmt|;
name|ups
operator|=
literal|0
expr_stmt|;
comment|/* = ffs(pci_resource_len(adap->pdev, 2)>> 12); */
name|ctrl
operator|=
name|F_DROPPKT
operator||
name|V_PKTSHIFT
argument_list|(
literal|2
argument_list|)
operator||
name|F_FLMODE
operator||
name|F_AVOIDCQOVFL
operator||
name|F_CQCRDTCTRL
operator||
name|F_CONGMODE
operator||
name|F_TNLFLMODE
operator||
name|F_FATLPERREN
operator||
name|V_HOSTPAGESIZE
argument_list|(
name|PAGE_SHIFT
operator|-
literal|11
argument_list|)
operator||
name|F_BIGENDIANINGRESS
operator||
name|V_USERSPACESIZE
argument_list|(
name|ups
condition|?
name|ups
operator|-
literal|1
else|:
literal|0
argument_list|)
operator||
name|F_ISCSICOALESCING
expr_stmt|;
if|#
directive|if
name|SGE_NUM_GENBITS
operator|==
literal|1
name|ctrl
operator||=
name|F_EGRGENCTRL
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|adap
operator|->
name|params
operator|.
name|rev
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|adap
operator|->
name|flags
operator|&
operator|(
name|USING_MSIX
operator||
name|USING_MSI
operator|)
operator|)
condition|)
name|ctrl
operator||=
name|F_ONEINTMULTQ
operator||
name|F_OPTONEINTMULTQ
expr_stmt|;
block|}
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_CONTROL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_EGR_RCQ_DRB_THRSH
argument_list|,
name|V_HIRCQDRBTHRSH
argument_list|(
literal|512
argument_list|)
operator||
name|V_LORCQDRBTHRSH
argument_list|(
literal|512
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_TIMER_TICK
argument_list|,
name|core_ticks_per_usec
argument_list|(
name|adap
argument_list|)
operator|/
literal|10
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_CMDQ_CREDIT_TH
argument_list|,
name|V_THRESHOLD
argument_list|(
literal|32
argument_list|)
operator||
name|V_TIMEOUT
argument_list|(
literal|200
operator|*
name|core_ticks_per_usec
argument_list|(
name|adap
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_HI_DRB_HI_THRSH
argument_list|,
name|adap
operator|->
name|params
operator|.
name|rev
operator|<
name|T3_REV_C
condition|?
literal|1000
else|:
literal|500
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_HI_DRB_LO_THRSH
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_LO_DRB_HI_THRSH
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_LO_DRB_LO_THRSH
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_OCO_BASE
argument_list|,
name|V_BASE1
argument_list|(
literal|0xfff
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_DRB_PRI_THRESH
argument_list|,
literal|63
operator|*
literal|1024
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	sgl_len - calculates the size of an SGL of the given capacity  *	@n: the number of SGL entries  *  *	Calculates the number of flits needed for a scatter/gather list that  *	can hold the given number of entries.  */
end_comment

begin_function
specifier|static
name|__inline
name|unsigned
name|int
name|sgl_len
parameter_list|(
name|unsigned
name|int
name|n
parameter_list|)
block|{
return|return
operator|(
operator|(
literal|3
operator|*
name|n
operator|)
operator|/
literal|2
operator|+
operator|(
name|n
operator|&
literal|1
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	get_imm_packet - return the next ingress packet buffer from a response  *	@resp: the response descriptor containing the packet data  *  *	Return a packet containing the immediate data of the given response.  */
end_comment

begin_function
specifier|static
name|int
name|get_imm_packet
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|rsp_desc
modifier|*
name|resp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|IMMED_PKT_SIZE
expr_stmt|;
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|m_ext
operator|.
name|ext_type
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
argument_list|,
name|resp
operator|->
name|imm_data
argument_list|,
name|IMMED_PKT_SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u_int
name|flits_to_desc
parameter_list|(
name|u_int
name|n
parameter_list|)
block|{
return|return
operator|(
name|flit_desc_map
index|[
name|n
index|]
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SGE_PARERR
value|(F_CPPARITYERROR | F_OCPARITYERROR | F_RCPARITYERROR | \ 		    F_IRPARITYERROR | V_ITPARITYERROR(M_ITPARITYERROR) | \ 		    V_FLPARITYERROR(M_FLPARITYERROR) | F_LODRBPARITYERROR | \ 		    F_HIDRBPARITYERROR | F_LORCQPARITYERROR | \ 		    F_HIRCQPARITYERROR)
end_define

begin_define
define|#
directive|define
name|SGE_FRAMINGERR
value|(F_UC_REQ_FRAMINGERROR | F_R_REQ_FRAMINGERROR)
end_define

begin_define
define|#
directive|define
name|SGE_FATALERR
value|(SGE_PARERR | SGE_FRAMINGERR | F_RSPQCREDITOVERFOW | \ 		      F_RSPQDISABLED)
end_define

begin_comment
comment|/**  *	t3_sge_err_intr_handler - SGE async event interrupt handler  *	@adapter: the adapter  *  *	Interrupt handler for SGE asynchronous (non-data) events.  */
end_comment

begin_function
name|void
name|t3_sge_err_intr_handler
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
name|unsigned
name|int
name|v
decl_stmt|,
name|status
decl_stmt|;
name|status
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_INT_CAUSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|SGE_PARERR
condition|)
name|CH_ALERT
argument_list|(
name|adapter
argument_list|,
literal|"SGE parity error (0x%x)\n"
argument_list|,
name|status
operator|&
name|SGE_PARERR
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|SGE_FRAMINGERR
condition|)
name|CH_ALERT
argument_list|(
name|adapter
argument_list|,
literal|"SGE framing error (0x%x)\n"
argument_list|,
name|status
operator|&
name|SGE_FRAMINGERR
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|F_RSPQCREDITOVERFOW
condition|)
name|CH_ALERT
argument_list|(
name|adapter
argument_list|,
literal|"SGE response queue credit overflow\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|F_RSPQDISABLED
condition|)
block|{
name|v
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_RSPQ_FL_STATUS
argument_list|)
expr_stmt|;
name|CH_ALERT
argument_list|(
name|adapter
argument_list|,
literal|"packet delivered to disabled response queue (0x%x)\n"
argument_list|,
operator|(
name|v
operator|>>
name|S_RSPQ0DISABLED
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_INT_CAUSE
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|SGE_FATALERR
condition|)
name|t3_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t3_sge_prep
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|struct
name|sge_params
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|nqsets
decl_stmt|,
name|fl_q_size
decl_stmt|,
name|jumbo_q_size
decl_stmt|,
name|use_16k
decl_stmt|,
name|jumbo_buf_size
decl_stmt|;
name|nqsets
operator|=
name|min
argument_list|(
name|SGE_QSETS
operator|/
name|adap
operator|->
name|params
operator|.
name|nports
argument_list|,
name|mp_ncpus
argument_list|)
expr_stmt|;
name|nqsets
operator|*=
name|adap
operator|->
name|params
operator|.
name|nports
expr_stmt|;
name|fl_q_size
operator|=
name|min
argument_list|(
name|nmbclusters
operator|/
operator|(
literal|3
operator|*
name|nqsets
operator|)
argument_list|,
name|FL_Q_SIZE
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|powerof2
argument_list|(
name|fl_q_size
argument_list|)
condition|)
name|fl_q_size
operator|--
expr_stmt|;
name|use_16k
operator|=
name|cxgb_use_16k_clusters
operator|!=
operator|-
literal|1
condition|?
name|cxgb_use_16k_clusters
else|:
name|is_offload
argument_list|(
name|adap
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|700111
if|if
condition|(
name|use_16k
condition|)
block|{
name|jumbo_q_size
operator|=
name|min
argument_list|(
name|nmbjumbo16
operator|/
operator|(
literal|3
operator|*
name|nqsets
operator|)
argument_list|,
name|JUMBO_Q_SIZE
argument_list|)
expr_stmt|;
name|jumbo_buf_size
operator|=
name|MJUM16BYTES
expr_stmt|;
block|}
else|else
block|{
name|jumbo_q_size
operator|=
name|min
argument_list|(
name|nmbjumbo9
operator|/
operator|(
literal|3
operator|*
name|nqsets
operator|)
argument_list|,
name|JUMBO_Q_SIZE
argument_list|)
expr_stmt|;
name|jumbo_buf_size
operator|=
name|MJUM9BYTES
expr_stmt|;
block|}
else|#
directive|else
name|jumbo_q_size
operator|=
name|min
argument_list|(
name|nmbjumbop
operator|/
operator|(
literal|3
operator|*
name|nqsets
operator|)
argument_list|,
name|JUMBO_Q_SIZE
argument_list|)
expr_stmt|;
name|jumbo_buf_size
operator|=
name|MJUMPAGESIZE
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|!
name|powerof2
argument_list|(
name|jumbo_q_size
argument_list|)
condition|)
name|jumbo_q_size
operator|--
expr_stmt|;
if|if
condition|(
name|fl_q_size
operator|<
operator|(
name|FL_Q_SIZE
operator|/
literal|4
operator|)
operator|||
name|jumbo_q_size
operator|<
operator|(
name|JUMBO_Q_SIZE
operator|/
literal|2
operator|)
condition|)
name|device_printf
argument_list|(
name|adap
operator|->
name|dev
argument_list|,
literal|"Insufficient clusters and/or jumbo buffers.\n"
argument_list|)
expr_stmt|;
name|p
operator|->
name|max_pkt_size
operator|=
name|jumbo_buf_size
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|cpl_rx_data
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SGE_QSETS
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|qset_params
modifier|*
name|q
init|=
name|p
operator|->
name|qset
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|adap
operator|->
name|params
operator|.
name|nports
operator|>
literal|2
condition|)
block|{
name|q
operator|->
name|coalesce_usecs
operator|=
literal|50
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|q
operator|->
name|coalesce_usecs
operator|=
literal|10
expr_stmt|;
else|#
directive|else
name|q
operator|->
name|coalesce_usecs
operator|=
literal|5
expr_stmt|;
endif|#
directive|endif
block|}
name|q
operator|->
name|polling
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|rspq_size
operator|=
name|RSPQ_Q_SIZE
expr_stmt|;
name|q
operator|->
name|fl_size
operator|=
name|fl_q_size
expr_stmt|;
name|q
operator|->
name|jumbo_size
operator|=
name|jumbo_q_size
expr_stmt|;
name|q
operator|->
name|jumbo_buf_size
operator|=
name|jumbo_buf_size
expr_stmt|;
name|q
operator|->
name|txq_size
index|[
name|TXQ_ETH
index|]
operator|=
name|TX_ETH_Q_SIZE
expr_stmt|;
name|q
operator|->
name|txq_size
index|[
name|TXQ_OFLD
index|]
operator|=
name|is_offload
argument_list|(
name|adap
argument_list|)
condition|?
name|TX_OFLD_Q_SIZE
else|:
literal|16
expr_stmt|;
name|q
operator|->
name|txq_size
index|[
name|TXQ_CTRL
index|]
operator|=
name|TX_CTRL_Q_SIZE
expr_stmt|;
name|q
operator|->
name|cong_thres
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|t3_sge_alloc
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|)
block|{
comment|/* The parent tag. */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* maxsize */
name|BUS_SPACE_UNRESTRICTED
argument_list|,
comment|/* nsegments */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lock, lockarg */
operator|&
name|sc
operator|->
name|parent_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot allocate parent DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* 	 * DMA tag for normal sized RX frames 	 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_dmat
argument_list|,
name|MCLBYTES
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MCLBYTES
argument_list|,
literal|1
argument_list|,
name|MCLBYTES
argument_list|,
name|BUS_DMA_ALLOCNOW
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|rx_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot allocate RX DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/*  	 * DMA tag for jumbo sized RX frames. 	 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_dmat
argument_list|,
name|MJUM16BYTES
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MJUM16BYTES
argument_list|,
literal|1
argument_list|,
name|MJUM16BYTES
argument_list|,
name|BUS_DMA_ALLOCNOW
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|rx_jumbo_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot allocate RX jumbo DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/*  	 * DMA tag for TX frames. 	 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_dmat
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|TX_MAX_SIZE
argument_list|,
name|TX_MAX_SEGS
argument_list|,
name|TX_MAX_SIZE
argument_list|,
name|BUS_DMA_ALLOCNOW
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|tx_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot allocate TX DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t3_sge_free
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|tx_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|tx_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rx_jumbo_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|rx_jumbo_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rx_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|rx_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|parent_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|t3_update_qset_coalesce
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
specifier|const
name|struct
name|qset_params
modifier|*
name|p
parameter_list|)
block|{
name|qs
operator|->
name|rspq
operator|.
name|holdoff_tmr
operator|=
name|max
argument_list|(
name|p
operator|->
name|coalesce_usecs
operator|*
literal|10
argument_list|,
literal|1U
argument_list|)
expr_stmt|;
name|qs
operator|->
name|rspq
operator|.
name|polling
operator|=
literal|0
comment|/* p->polling */
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__amd64__
argument_list|)
end_if

begin_function
specifier|static
name|void
name|refill_fl_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|refill_fl_cb_arg
modifier|*
name|cb_arg
init|=
name|arg
decl_stmt|;
name|cb_arg
operator|->
name|error
operator|=
name|error
expr_stmt|;
name|cb_arg
operator|->
name|seg
operator|=
name|segs
index|[
literal|0
index|]
expr_stmt|;
name|cb_arg
operator|->
name|nseg
operator|=
name|nseg
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  *	refill_fl - refill an SGE free-buffer list  *	@sc: the controller softc  *	@q: the free-list to refill  *	@n: the number of new buffers to allocate  *  *	(Re)populate an SGE free-buffer list with up to @n new packet buffers.  *	The caller must assure that @n does not exceed the queue's capacity.  */
end_comment

begin_function
specifier|static
name|void
name|refill_fl
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_fl
modifier|*
name|q
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|struct
name|rx_sw_desc
modifier|*
name|sd
init|=
operator|&
name|q
operator|->
name|sdesc
index|[
name|q
operator|->
name|pidx
index|]
decl_stmt|;
name|struct
name|rx_desc
modifier|*
name|d
init|=
operator|&
name|q
operator|->
name|desc
index|[
name|q
operator|->
name|pidx
index|]
decl_stmt|;
name|struct
name|refill_fl_cb_arg
name|cb_arg
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|cl
decl_stmt|;
name|int
name|err
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
name|cb_arg
operator|.
name|error
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
comment|/* 		 * We only allocate a cluster, mbuf allocation happens after rx 		 */
if|if
condition|(
name|q
operator|->
name|zone
operator|==
name|zone_pack
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_getcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_NOINIT
argument_list|,
name|M_PKTHDR
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
name|cl
operator|=
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|cl
operator|=
name|m_cljget
argument_list|(
name|NULL
argument_list|,
name|M_NOWAIT
argument_list|,
name|q
operator|->
name|buf_size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|(
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_NOINIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|uma_zfree
argument_list|(
name|q
operator|->
name|zone
argument_list|,
name|cl
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|sd
operator|->
name|flags
operator|&
name|RX_SW_DESC_MAP_CREATED
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|bus_dmamap_create
argument_list|(
name|q
operator|->
name|entry_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|sd
operator|->
name|map
argument_list|)
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"bus_dmamap_create failed %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|q
operator|->
name|zone
argument_list|,
name|cl
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|sd
operator|->
name|flags
operator||=
name|RX_SW_DESC_MAP_CREATED
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__amd64__
argument_list|)
name|err
operator|=
name|bus_dmamap_load
argument_list|(
name|q
operator|->
name|entry_tag
argument_list|,
name|sd
operator|->
name|map
argument_list|,
name|cl
argument_list|,
name|q
operator|->
name|buf_size
argument_list|,
name|refill_fl_cb
argument_list|,
operator|&
name|cb_arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|||
name|cb_arg
operator|.
name|error
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|zone
operator|==
name|zone_pack
condition|)
name|uma_zfree
argument_list|(
name|q
operator|->
name|zone
argument_list|,
name|cl
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
else|#
directive|else
name|cb_arg
operator|.
name|seg
operator|.
name|ds_addr
operator|=
name|pmap_kextract
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|cl
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sd
operator|->
name|flags
operator||=
name|RX_SW_DESC_INUSE
expr_stmt|;
name|sd
operator|->
name|rxsd_cl
operator|=
name|cl
expr_stmt|;
name|sd
operator|->
name|m
operator|=
name|m
expr_stmt|;
name|d
operator|->
name|addr_lo
operator|=
name|htobe32
argument_list|(
name|cb_arg
operator|.
name|seg
operator|.
name|ds_addr
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|d
operator|->
name|addr_hi
operator|=
name|htobe32
argument_list|(
operator|(
operator|(
name|uint64_t
operator|)
name|cb_arg
operator|.
name|seg
operator|.
name|ds_addr
operator|>>
literal|32
operator|)
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|d
operator|->
name|len_gen
operator|=
name|htobe32
argument_list|(
name|V_FLD_GEN1
argument_list|(
name|q
operator|->
name|gen
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|gen2
operator|=
name|htobe32
argument_list|(
name|V_FLD_GEN2
argument_list|(
name|q
operator|->
name|gen
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
name|sd
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|q
operator|->
name|pidx
operator|==
name|q
operator|->
name|size
condition|)
block|{
name|q
operator|->
name|pidx
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|gen
operator|^=
literal|1
expr_stmt|;
name|sd
operator|=
name|q
operator|->
name|sdesc
expr_stmt|;
name|d
operator|=
name|q
operator|->
name|desc
expr_stmt|;
block|}
name|q
operator|->
name|credits
operator|++
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
name|count
condition|)
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|A_SG_KDOORBELL
argument_list|,
name|V_EGRCNTX
argument_list|(
name|q
operator|->
name|cntxt_id
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	free_rx_bufs - free the Rx buffers on an SGE free list  *	@sc: the controle softc  *	@q: the SGE free list to clean up  *  *	Release the buffers on an SGE free-buffer Rx queue.  HW fetching from  *	this queue should be stopped before calling this function.  */
end_comment

begin_function
specifier|static
name|void
name|free_rx_bufs
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_fl
modifier|*
name|q
parameter_list|)
block|{
name|u_int
name|cidx
init|=
name|q
operator|->
name|cidx
decl_stmt|;
while|while
condition|(
name|q
operator|->
name|credits
operator|--
condition|)
block|{
name|struct
name|rx_sw_desc
modifier|*
name|d
init|=
operator|&
name|q
operator|->
name|sdesc
index|[
name|cidx
index|]
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|RX_SW_DESC_INUSE
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|q
operator|->
name|entry_tag
argument_list|,
name|d
operator|->
name|map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|q
operator|->
name|entry_tag
argument_list|,
name|d
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|zone
operator|==
name|zone_pack
condition|)
block|{
name|m_init
argument_list|(
name|d
operator|->
name|m
argument_list|,
name|zone_pack
argument_list|,
name|MCLBYTES
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_EXT
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|zone_pack
argument_list|,
name|d
operator|->
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|m_init
argument_list|(
name|d
operator|->
name|m
argument_list|,
name|zone_mbuf
argument_list|,
name|MLEN
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|zone_mbuf
argument_list|,
name|d
operator|->
name|m
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|q
operator|->
name|zone
argument_list|,
name|d
operator|->
name|rxsd_cl
argument_list|)
expr_stmt|;
block|}
block|}
name|d
operator|->
name|rxsd_cl
operator|=
name|NULL
expr_stmt|;
name|d
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|++
name|cidx
operator|==
name|q
operator|->
name|size
condition|)
name|cidx
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|__refill_fl
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|struct
name|sge_fl
modifier|*
name|fl
parameter_list|)
block|{
name|refill_fl
argument_list|(
name|adap
argument_list|,
name|fl
argument_list|,
name|min
argument_list|(
literal|16U
argument_list|,
name|fl
operator|->
name|size
operator|-
name|fl
operator|->
name|credits
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|__refill_fl_lt
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|struct
name|sge_fl
modifier|*
name|fl
parameter_list|,
name|int
name|max
parameter_list|)
block|{
if|if
condition|(
operator|(
name|fl
operator|->
name|size
operator|-
name|fl
operator|->
name|credits
operator|)
operator|<
name|max
condition|)
name|refill_fl
argument_list|(
name|adap
argument_list|,
name|fl
argument_list|,
name|min
argument_list|(
name|max
argument_list|,
name|fl
operator|->
name|size
operator|-
name|fl
operator|->
name|credits
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	recycle_rx_buf - recycle a receive buffer  *	@adapter: the adapter  *	@q: the SGE free list  *	@idx: index of buffer to recycle  *  *	Recycles the specified buffer on the given free list by adding it at  *	the next available slot on the list.  */
end_comment

begin_function
specifier|static
name|void
name|recycle_rx_buf
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|struct
name|sge_fl
modifier|*
name|q
parameter_list|,
name|unsigned
name|int
name|idx
parameter_list|)
block|{
name|struct
name|rx_desc
modifier|*
name|from
init|=
operator|&
name|q
operator|->
name|desc
index|[
name|idx
index|]
decl_stmt|;
name|struct
name|rx_desc
modifier|*
name|to
init|=
operator|&
name|q
operator|->
name|desc
index|[
name|q
operator|->
name|pidx
index|]
decl_stmt|;
name|q
operator|->
name|sdesc
index|[
name|q
operator|->
name|pidx
index|]
operator|=
name|q
operator|->
name|sdesc
index|[
name|idx
index|]
expr_stmt|;
name|to
operator|->
name|addr_lo
operator|=
name|from
operator|->
name|addr_lo
expr_stmt|;
comment|// already big endian
name|to
operator|->
name|addr_hi
operator|=
name|from
operator|->
name|addr_hi
expr_stmt|;
comment|// likewise
name|wmb
argument_list|()
expr_stmt|;
comment|/* necessary ? */
name|to
operator|->
name|len_gen
operator|=
name|htobe32
argument_list|(
name|V_FLD_GEN1
argument_list|(
name|q
operator|->
name|gen
argument_list|)
argument_list|)
expr_stmt|;
name|to
operator|->
name|gen2
operator|=
name|htobe32
argument_list|(
name|V_FLD_GEN2
argument_list|(
name|q
operator|->
name|gen
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|credits
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|q
operator|->
name|pidx
operator|==
name|q
operator|->
name|size
condition|)
block|{
name|q
operator|->
name|pidx
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|gen
operator|^=
literal|1
expr_stmt|;
block|}
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_KDOORBELL
argument_list|,
name|V_EGRCNTX
argument_list|(
name|q
operator|->
name|cntxt_id
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|alloc_ring_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|uint32_t
modifier|*
name|addr
decl_stmt|;
name|addr
operator|=
name|arg
expr_stmt|;
operator|*
name|addr
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|alloc_ring
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|,
name|size_t
name|nelem
parameter_list|,
name|size_t
name|elem_size
parameter_list|,
name|size_t
name|sw_size
parameter_list|,
name|bus_addr_t
modifier|*
name|phys
parameter_list|,
name|void
modifier|*
name|desc
parameter_list|,
name|void
modifier|*
name|sdesc
parameter_list|,
name|bus_dma_tag_t
modifier|*
name|tag
parameter_list|,
name|bus_dmamap_t
modifier|*
name|map
parameter_list|,
name|bus_dma_tag_t
name|parent_entry_tag
parameter_list|,
name|bus_dma_tag_t
modifier|*
name|entry_tag
parameter_list|)
block|{
name|size_t
name|len
init|=
name|nelem
operator|*
name|elem_size
decl_stmt|;
name|void
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_dmat
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|tag
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot allocate descriptor tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|bus_dmamem_alloc
argument_list|(
operator|*
name|tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|p
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
name|map
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot allocate descriptor memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bus_dmamap_load
argument_list|(
operator|*
name|tag
argument_list|,
operator|*
name|map
argument_list|,
name|p
argument_list|,
name|len
argument_list|,
name|alloc_ring_cb
argument_list|,
name|phys
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
operator|(
name|void
operator|*
operator|*
operator|)
name|desc
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|sw_size
condition|)
block|{
name|len
operator|=
name|nelem
operator|*
name|sw_size
expr_stmt|;
name|s
operator|=
name|malloc
argument_list|(
name|len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
operator|*
operator|(
name|void
operator|*
operator|*
operator|)
name|sdesc
operator|=
name|s
expr_stmt|;
block|}
if|if
condition|(
name|parent_entry_tag
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|err
operator|=
name|bus_dma_tag_create
argument_list|(
name|parent_entry_tag
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|TX_MAX_SIZE
argument_list|,
name|TX_MAX_SEGS
argument_list|,
name|TX_MAX_SIZE
argument_list|,
name|BUS_DMA_ALLOCNOW
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|entry_tag
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot allocate descriptor entry tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sge_slow_intr_handler
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|ncount
parameter_list|)
block|{
name|adapter_t
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|t3_slow_intr_handler
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	sge_timer_cb - perform periodic maintenance of an SGE qset  *	@data: the SGE queue set to maintain  *  *	Runs periodically from a timer to perform maintenance of an SGE queue  *	set.  It performs two tasks:  *  *	a) Cleans up any completed Tx descriptors that may still be pending.  *	Normal descriptor cleanup happens when new packets are added to a Tx  *	queue so this timer is relatively infrequent and does any cleanup only  *	if the Tx queue has not seen any new packets in a while.  We make a  *	best effort attempt to reclaim descriptors, in that we don't wait  *	around if we cannot get a queue's lock (which most likely is because  *	someone else is queueing new packets and so will also handle the clean  *	up).  Since control queues use immediate data exclusively we don't  *	bother cleaning them up here.  *  *	b) Replenishes Rx queues that have run out due to memory shortage.  *	Normally new Rx buffers are added when existing ones are consumed but  *	when out of memory a queue can become empty.  We try to add only a few  *	buffers here, the queue will be replenished fully as these new buffers  *	are used up if memory shortage has subsided.  *	  *	c) Return coalesced response queue credits in case a response queue is  *	starved.  *  *	d) Ring doorbells for T304 tunnel queues since we have seen doorbell   *	fifo overflows and the FW doesn't implement any recovery scheme yet.  */
end_comment

begin_function
specifier|static
name|void
name|sge_timer_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|adapter_t
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|USING_MSIX
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|port_info
modifier|*
name|pi
decl_stmt|;
name|struct
name|sge_qset
modifier|*
name|qs
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|reclaim_ofl
decl_stmt|,
name|refill_rx
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|open_device_map
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|params
operator|.
name|nports
condition|;
name|i
operator|++
control|)
block|{
name|pi
operator|=
operator|&
name|sc
operator|->
name|port
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pi
operator|->
name|nqsets
condition|;
name|j
operator|++
control|)
block|{
name|qs
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
name|pi
operator|->
name|first_qset
operator|+
name|j
index|]
expr_stmt|;
name|txq
operator|=
operator|&
name|qs
operator|->
name|txq
index|[
literal|0
index|]
expr_stmt|;
name|reclaim_ofl
operator|=
name|txq
index|[
name|TXQ_OFLD
index|]
operator|.
name|processed
operator|-
name|txq
index|[
name|TXQ_OFLD
index|]
operator|.
name|cleaned
expr_stmt|;
name|refill_rx
operator|=
operator|(
operator|(
name|qs
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|credits
operator|<
name|qs
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|size
operator|)
operator|||
operator|(
name|qs
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|credits
operator|<
name|qs
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|size
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|reclaim_ofl
operator|||
name|refill_rx
condition|)
block|{
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|pi
operator|->
name|timer_reclaim_task
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|params
operator|.
name|nports
operator|>
literal|2
condition|)
block|{
name|int
name|i
decl_stmt|;
name|for_each_port
argument_list|(
argument|sc
argument_list|,
argument|i
argument_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
operator|&
name|sc
operator|->
name|port
index|[
name|i
index|]
decl_stmt|;
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|A_SG_KDOORBELL
argument_list|,
name|F_SELEGRCNTX
operator||
operator|(
name|FW_TUNNEL_SGEEC_START
operator|+
name|pi
operator|->
name|first_qset
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|USING_MSIX
operator|)
operator|==
literal|0
operator|||
name|sc
operator|->
name|params
operator|.
name|nports
operator|>
literal|2
operator|)
operator|&&
name|sc
operator|->
name|open_device_map
operator|!=
literal|0
condition|)
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sge_timer_ch
argument_list|,
name|TX_RECLAIM_PERIOD
argument_list|,
name|sge_timer_cb
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is meant to be a catch-all function to keep sge state private  * to sge.c  *  */
end_comment

begin_function
name|int
name|t3_sge_init_adapter
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|)
block|{
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sge_timer_ch
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sge_timer_ch
argument_list|,
name|TX_RECLAIM_PERIOD
argument_list|,
name|sge_timer_cb
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|slow_intr_task
argument_list|,
literal|0
argument_list|,
name|sge_slow_intr_handler
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t3_sge_reset_adapter
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|)
block|{
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sge_timer_ch
argument_list|,
name|TX_RECLAIM_PERIOD
argument_list|,
name|sge_timer_cb
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t3_sge_init_port
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
name|TASK_INIT
argument_list|(
operator|&
name|pi
operator|->
name|timer_reclaim_task
argument_list|,
literal|0
argument_list|,
name|sge_timer_reclaim
argument_list|,
name|pi
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	refill_rspq - replenish an SGE response queue  *	@adapter: the adapter  *	@q: the response queue to replenish  *	@credits: how many new responses to make available  *  *	Replenishes a response queue by making the supplied number of responses  *	available to HW.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|refill_rspq
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|sge_rspq
modifier|*
name|q
parameter_list|,
name|u_int
name|credits
parameter_list|)
block|{
comment|/* mbufs are allocated on demand when a rspq entry is processed. */
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|A_SG_RSPQ_CREDIT_RETURN
argument_list|,
name|V_RSPQ
argument_list|(
name|q
operator|->
name|cntxt_id
argument_list|)
operator||
name|V_CREDITS
argument_list|(
name|credits
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sge_txq_reclaim_handler
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|ncount
parameter_list|)
block|{
name|struct
name|sge_qset
modifier|*
name|qs
init|=
name|arg
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|reclaim_completed_tx
argument_list|(
name|qs
argument_list|,
literal|16
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sge_timer_reclaim
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|ncount
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|arg
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nqsets
init|=
name|pi
operator|->
name|nqsets
decl_stmt|;
name|adapter_t
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|sge_qset
modifier|*
name|qs
decl_stmt|;
name|struct
name|mtx
modifier|*
name|lock
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|USING_MSIX
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"can't call timer reclaim for msi-x"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nqsets
condition|;
name|i
operator|++
control|)
block|{
name|qs
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
name|pi
operator|->
name|first_qset
operator|+
name|i
index|]
expr_stmt|;
name|reclaim_completed_tx
argument_list|(
name|qs
argument_list|,
literal|16
argument_list|,
name|TXQ_OFLD
argument_list|)
expr_stmt|;
name|lock
operator|=
operator|(
name|sc
operator|->
name|flags
operator|&
name|USING_MSIX
operator|)
condition|?
operator|&
name|qs
operator|->
name|rspq
operator|.
name|lock
else|:
operator|&
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
literal|0
index|]
operator|.
name|rspq
operator|.
name|lock
expr_stmt|;
if|if
condition|(
name|mtx_trylock
argument_list|(
name|lock
argument_list|)
condition|)
block|{
comment|/* XXX currently assume that we are *NOT* polling */
name|uint32_t
name|status
init|=
name|t3_read_reg
argument_list|(
name|sc
argument_list|,
name|A_SG_RSPQ_FL_STATUS
argument_list|)
decl_stmt|;
if|if
condition|(
name|qs
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|credits
operator|<
name|qs
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|size
operator|-
literal|16
condition|)
name|__refill_fl
argument_list|(
name|sc
argument_list|,
operator|&
name|qs
operator|->
name|fl
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|qs
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|credits
operator|<
name|qs
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|size
operator|-
literal|16
condition|)
name|__refill_fl
argument_list|(
name|sc
argument_list|,
operator|&
name|qs
operator|->
name|fl
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
operator|(
literal|1
operator|<<
name|qs
operator|->
name|rspq
operator|.
name|cntxt_id
operator|)
condition|)
block|{
if|if
condition|(
name|qs
operator|->
name|rspq
operator|.
name|credits
condition|)
block|{
name|refill_rspq
argument_list|(
name|sc
argument_list|,
operator|&
name|qs
operator|->
name|rspq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|qs
operator|->
name|rspq
operator|.
name|credits
operator|--
expr_stmt|;
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|A_SG_RSPQ_FL_STATUS
argument_list|,
literal|1
operator|<<
name|qs
operator|->
name|rspq
operator|.
name|cntxt_id
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  *	init_qset_cntxt - initialize an SGE queue set context info  *	@qs: the queue set  *	@id: the queue set id  *  *	Initializes the TIDs and context ids for the queues of a queue set.  */
end_comment

begin_function
specifier|static
name|void
name|init_qset_cntxt
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|u_int
name|id
parameter_list|)
block|{
name|qs
operator|->
name|rspq
operator|.
name|cntxt_id
operator|=
name|id
expr_stmt|;
name|qs
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|cntxt_id
operator|=
literal|2
operator|*
name|id
expr_stmt|;
name|qs
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|cntxt_id
operator|=
literal|2
operator|*
name|id
operator|+
literal|1
expr_stmt|;
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|cntxt_id
operator|=
name|FW_TUNNEL_SGEEC_START
operator|+
name|id
expr_stmt|;
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|token
operator|=
name|FW_TUNNEL_TID_START
operator|+
name|id
expr_stmt|;
name|qs
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
operator|.
name|cntxt_id
operator|=
name|FW_OFLD_SGEEC_START
operator|+
name|id
expr_stmt|;
name|qs
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
operator|.
name|cntxt_id
operator|=
name|FW_CTRL_SGEEC_START
operator|+
name|id
expr_stmt|;
name|qs
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
operator|.
name|token
operator|=
name|FW_CTRL_TID_START
operator|+
name|id
expr_stmt|;
name|mbufq_init
argument_list|(
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|sendq
argument_list|)
expr_stmt|;
name|mbufq_init
argument_list|(
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
operator|.
name|sendq
argument_list|)
expr_stmt|;
name|mbufq_init
argument_list|(
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
operator|.
name|sendq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|txq_prod
parameter_list|(
name|struct
name|sge_txq
modifier|*
name|txq
parameter_list|,
name|unsigned
name|int
name|ndesc
parameter_list|,
name|struct
name|txq_state
modifier|*
name|txqs
parameter_list|)
block|{
name|txq
operator|->
name|in_use
operator|+=
name|ndesc
expr_stmt|;
comment|/* 	 * XXX we don't handle stopping of queue 	 * presumably start handles this when we bump against the end 	 */
name|txqs
operator|->
name|gen
operator|=
name|txq
operator|->
name|gen
expr_stmt|;
name|txq
operator|->
name|unacked
operator|+=
name|ndesc
expr_stmt|;
name|txqs
operator|->
name|compl
operator|=
operator|(
name|txq
operator|->
name|unacked
operator|&
literal|32
operator|)
operator|<<
operator|(
name|S_WR_COMPL
operator|-
literal|5
operator|)
expr_stmt|;
name|txq
operator|->
name|unacked
operator|&=
literal|31
expr_stmt|;
name|txqs
operator|->
name|pidx
operator|=
name|txq
operator|->
name|pidx
expr_stmt|;
name|txq
operator|->
name|pidx
operator|+=
name|ndesc
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
operator|(
operator|(
name|txqs
operator|->
name|pidx
operator|>
name|txq
operator|->
name|cidx
operator|)
operator|&&
operator|(
name|txq
operator|->
name|pidx
operator|<
name|txqs
operator|->
name|pidx
operator|)
operator|&&
operator|(
name|txq
operator|->
name|pidx
operator|>=
name|txq
operator|->
name|cidx
operator|)
operator|)
operator|||
operator|(
operator|(
name|txqs
operator|->
name|pidx
operator|<
name|txq
operator|->
name|cidx
operator|)
operator|&&
operator|(
name|txq
operator|->
name|pidx
operator|>=
name|txq
operator|->
name|cidx
operator|)
operator|)
operator|||
operator|(
operator|(
name|txqs
operator|->
name|pidx
operator|<
name|txq
operator|->
name|cidx
operator|)
operator|&&
operator|(
name|txq
operator|->
name|cidx
operator|<
name|txqs
operator|->
name|pidx
operator|)
operator|)
condition|)
name|panic
argument_list|(
literal|"txqs->pidx=%d txq->pidx=%d txq->cidx=%d"
argument_list|,
name|txqs
operator|->
name|pidx
argument_list|,
name|txq
operator|->
name|pidx
argument_list|,
name|txq
operator|->
name|cidx
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|txq
operator|->
name|pidx
operator|>=
name|txq
operator|->
name|size
condition|)
block|{
name|txq
operator|->
name|pidx
operator|-=
name|txq
operator|->
name|size
expr_stmt|;
name|txq
operator|->
name|gen
operator|^=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	calc_tx_descs - calculate the number of Tx descriptors for a packet  *	@m: the packet mbufs  *      @nsegs: the number of segments   *  * 	Returns the number of Tx descriptors needed for the given Ethernet  * 	packet.  Ethernet packets require addition of WR and CPL headers.  */
end_comment

begin_function
specifier|static
name|__inline
name|unsigned
name|int
name|calc_tx_descs
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|nsegs
parameter_list|)
block|{
name|unsigned
name|int
name|flits
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<=
name|PIO_LEN
condition|)
return|return
literal|1
return|;
name|flits
operator|=
name|sgl_len
argument_list|(
name|nsegs
argument_list|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
condition|)
name|flits
operator|++
expr_stmt|;
return|return
name|flits_to_desc
argument_list|(
name|flits
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|busdma_map_mbufs
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|,
name|struct
name|sge_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|tx_sw_desc
modifier|*
name|txsd
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
modifier|*
name|nsegs
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|int
name|err
decl_stmt|,
name|pktlen
decl_stmt|,
name|pass
init|=
literal|0
decl_stmt|;
name|bus_dma_tag_t
name|tag
init|=
name|txq
operator|->
name|entry_tag
decl_stmt|;
name|retry
label|:
name|err
operator|=
literal|0
expr_stmt|;
name|m0
operator|=
operator|*
name|m
expr_stmt|;
name|pktlen
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
if|if
condition|(
name|busdma_map_sg_collapse
argument_list|(
name|tag
argument_list|,
name|txsd
operator|->
name|map
argument_list|,
name|m
argument_list|,
name|segs
argument_list|,
name|nsegs
argument_list|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|done
goto|;
block|}
else|else
endif|#
directive|endif
name|err
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|tag
argument_list|,
name|txsd
operator|->
name|map
argument_list|,
name|m0
argument_list|,
name|segs
argument_list|,
name|nsegs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|err
operator|==
name|EFBIG
operator|&&
name|pass
operator|==
literal|0
condition|)
block|{
name|pass
operator|=
literal|1
expr_stmt|;
comment|/* Too many segments, try to defrag */
name|m0
operator|=
name|m_defrag
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|m
argument_list|)
expr_stmt|;
operator|*
name|m
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
operator|*
name|m
operator|=
name|m0
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
elseif|else
if|if
condition|(
name|err
operator|==
name|ENOMEM
condition|)
block|{
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|cxgb_debug
condition|)
name|printf
argument_list|(
literal|"map failure err=%d pktlen=%d\n"
argument_list|,
name|err
argument_list|,
name|pktlen
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
operator|*
name|m
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|done
label|:
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__amd64__
argument_list|)
name|bus_dmamap_sync
argument_list|(
name|tag
argument_list|,
name|txsd
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|txsd
operator|->
name|flags
operator||=
name|TX_SW_DESC_MAPPED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	make_sgl - populate a scatter/gather list for a packet  *	@sgp: the SGL to populate  *	@segs: the packet dma segments  *	@nsegs: the number of segments  *  *	Generates a scatter/gather list for the buffers that make up a packet  *	and returns the SGL size in 8-byte words.  The caller must size the SGL  *	appropriately.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|make_sgl
parameter_list|(
name|struct
name|sg_ent
modifier|*
name|sgp
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|idx
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * firmware doesn't like empty segments 		 */
if|if
condition|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|i
operator|&&
name|idx
operator|==
literal|0
condition|)
operator|++
name|sgp
expr_stmt|;
name|sgp
operator|->
name|len
index|[
name|idx
index|]
operator|=
name|htobe32
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
name|sgp
operator|->
name|addr
index|[
name|idx
index|]
operator|=
name|htobe64
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|idx
operator|^=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|idx
condition|)
block|{
name|sgp
operator|->
name|len
index|[
name|idx
index|]
operator|=
literal|0
expr_stmt|;
name|sgp
operator|->
name|addr
index|[
name|idx
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	check_ring_tx_db - check and potentially ring a Tx queue's doorbell  *	@adap: the adapter  *	@q: the Tx queue  *  *	Ring the doorbell if a Tx queue is asleep.  There is a natural race,  *	where the HW is going to sleep just after we checked, however,  *	then the interrupt handler will detect the outstanding TX packet  *	and ring the doorbell for us.  *  *	When GTS is disabled we unconditionally ring the doorbell.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|check_ring_tx_db
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|struct
name|sge_txq
modifier|*
name|q
parameter_list|)
block|{
if|#
directive|if
name|USE_GTS
name|clear_bit
argument_list|(
name|TXQ_LAST_PKT_DB
argument_list|,
operator|&
name|q
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|test_and_set_bit
argument_list|(
name|TXQ_RUNNING
argument_list|,
operator|&
name|q
operator|->
name|flags
argument_list|)
operator|==
literal|0
condition|)
block|{
name|set_bit
argument_list|(
name|TXQ_LAST_PKT_DB
argument_list|,
operator|&
name|q
operator|->
name|flags
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|T3_TRACE
name|T3_TRACE1
argument_list|(
name|adap
operator|->
name|tb
index|[
name|q
operator|->
name|cntxt_id
operator|&
literal|7
index|]
argument_list|,
literal|"doorbell Tx, cntxt %d"
argument_list|,
name|q
operator|->
name|cntxt_id
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_KDOORBELL
argument_list|,
name|F_SELEGRCNTX
operator||
name|V_EGRCNTX
argument_list|(
name|q
operator|->
name|cntxt_id
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|wmb
argument_list|()
expr_stmt|;
comment|/* write descriptors before telling HW */
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_KDOORBELL
argument_list|,
name|F_SELEGRCNTX
operator||
name|V_EGRCNTX
argument_list|(
name|q
operator|->
name|cntxt_id
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|wr_gen2
parameter_list|(
name|struct
name|tx_desc
modifier|*
name|d
parameter_list|,
name|unsigned
name|int
name|gen
parameter_list|)
block|{
if|#
directive|if
name|SGE_NUM_GENBITS
operator|==
literal|2
name|d
operator|->
name|flit
index|[
name|TX_DESC_FLITS
operator|-
literal|1
index|]
operator|=
name|htobe64
argument_list|(
name|gen
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/**  *	write_wr_hdr_sgl - write a WR header and, optionally, SGL  *	@ndesc: number of Tx descriptors spanned by the SGL  *	@txd: first Tx descriptor to be written  *	@txqs: txq state (generation and producer index)  *	@txq: the SGE Tx queue  *	@sgl: the SGL  *	@flits: number of flits to the start of the SGL in the first descriptor  *	@sgl_flits: the SGL size in flits  *	@wr_hi: top 32 bits of WR header based on WR type (big endian)  *	@wr_lo: low 32 bits of WR header based on WR type (big endian)  *  *	Write a work request header and an associated SGL.  If the SGL is  *	small enough to fit into one Tx descriptor it has already been written  *	and we just need to write the WR header.  Otherwise we distribute the  *	SGL across the number of descriptors it spans.  */
end_comment

begin_function
specifier|static
name|void
name|write_wr_hdr_sgl
parameter_list|(
name|unsigned
name|int
name|ndesc
parameter_list|,
name|struct
name|tx_desc
modifier|*
name|txd
parameter_list|,
name|struct
name|txq_state
modifier|*
name|txqs
parameter_list|,
specifier|const
name|struct
name|sge_txq
modifier|*
name|txq
parameter_list|,
specifier|const
name|struct
name|sg_ent
modifier|*
name|sgl
parameter_list|,
name|unsigned
name|int
name|flits
parameter_list|,
name|unsigned
name|int
name|sgl_flits
parameter_list|,
name|unsigned
name|int
name|wr_hi
parameter_list|,
name|unsigned
name|int
name|wr_lo
parameter_list|)
block|{
name|struct
name|work_request_hdr
modifier|*
name|wrp
init|=
operator|(
expr|struct
name|work_request_hdr
operator|*
operator|)
name|txd
decl_stmt|;
name|struct
name|tx_sw_desc
modifier|*
name|txsd
init|=
operator|&
name|txq
operator|->
name|sdesc
index|[
name|txqs
operator|->
name|pidx
index|]
decl_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
name|ndesc
operator|==
literal|1
argument_list|)
condition|)
block|{
name|set_wr_hdr
argument_list|(
name|wrp
argument_list|,
name|htonl
argument_list|(
name|F_WR_SOP
operator||
name|F_WR_EOP
operator||
name|V_WR_DATATYPE
argument_list|(
literal|1
argument_list|)
operator||
name|V_WR_SGLSFLT
argument_list|(
name|flits
argument_list|)
argument_list|)
operator||
name|wr_hi
argument_list|,
name|htonl
argument_list|(
name|V_WR_LEN
argument_list|(
name|flits
operator|+
name|sgl_flits
argument_list|)
operator||
name|V_WR_GEN
argument_list|(
name|txqs
operator|->
name|gen
argument_list|)
argument_list|)
operator||
name|wr_lo
argument_list|)
expr_stmt|;
comment|/* XXX gen? */
name|wr_gen2
argument_list|(
name|txd
argument_list|,
name|txqs
operator|->
name|gen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|int
name|ogen
init|=
name|txqs
operator|->
name|gen
decl_stmt|;
specifier|const
name|uint64_t
modifier|*
name|fp
init|=
operator|(
specifier|const
name|uint64_t
operator|*
operator|)
name|sgl
decl_stmt|;
name|struct
name|work_request_hdr
modifier|*
name|wp
init|=
name|wrp
decl_stmt|;
name|wrp
operator|->
name|wrh_hi
operator|=
name|htonl
argument_list|(
name|F_WR_SOP
operator||
name|V_WR_DATATYPE
argument_list|(
literal|1
argument_list|)
operator||
name|V_WR_SGLSFLT
argument_list|(
name|flits
argument_list|)
argument_list|)
operator||
name|wr_hi
expr_stmt|;
while|while
condition|(
name|sgl_flits
condition|)
block|{
name|unsigned
name|int
name|avail
init|=
name|WR_FLITS
operator|-
name|flits
decl_stmt|;
if|if
condition|(
name|avail
operator|>
name|sgl_flits
condition|)
name|avail
operator|=
name|sgl_flits
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|txd
operator|->
name|flit
index|[
name|flits
index|]
argument_list|,
name|fp
argument_list|,
name|avail
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|fp
argument_list|)
argument_list|)
expr_stmt|;
name|sgl_flits
operator|-=
name|avail
expr_stmt|;
name|ndesc
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|sgl_flits
condition|)
break|break;
name|fp
operator|+=
name|avail
expr_stmt|;
name|txd
operator|++
expr_stmt|;
name|txsd
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|txqs
operator|->
name|pidx
operator|==
name|txq
operator|->
name|size
condition|)
block|{
name|txqs
operator|->
name|pidx
operator|=
literal|0
expr_stmt|;
name|txqs
operator|->
name|gen
operator|^=
literal|1
expr_stmt|;
name|txd
operator|=
name|txq
operator|->
name|desc
expr_stmt|;
name|txsd
operator|=
name|txq
operator|->
name|sdesc
expr_stmt|;
block|}
comment|/* 			 * when the head of the mbuf chain 			 * is freed all clusters will be freed 			 * with it 			 */
name|wrp
operator|=
operator|(
expr|struct
name|work_request_hdr
operator|*
operator|)
name|txd
expr_stmt|;
name|wrp
operator|->
name|wrh_hi
operator|=
name|htonl
argument_list|(
name|V_WR_DATATYPE
argument_list|(
literal|1
argument_list|)
operator||
name|V_WR_SGLSFLT
argument_list|(
literal|1
argument_list|)
argument_list|)
operator||
name|wr_hi
expr_stmt|;
name|wrp
operator|->
name|wrh_lo
operator|=
name|htonl
argument_list|(
name|V_WR_LEN
argument_list|(
name|min
argument_list|(
name|WR_FLITS
argument_list|,
name|sgl_flits
operator|+
literal|1
argument_list|)
argument_list|)
operator||
name|V_WR_GEN
argument_list|(
name|txqs
operator|->
name|gen
argument_list|)
argument_list|)
operator||
name|wr_lo
expr_stmt|;
name|wr_gen2
argument_list|(
name|txd
argument_list|,
name|txqs
operator|->
name|gen
argument_list|)
expr_stmt|;
name|flits
operator|=
literal|1
expr_stmt|;
block|}
name|wrp
operator|->
name|wrh_hi
operator||=
name|htonl
argument_list|(
name|F_WR_EOP
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
name|wp
operator|->
name|wrh_lo
operator|=
name|htonl
argument_list|(
name|V_WR_LEN
argument_list|(
name|WR_FLITS
argument_list|)
operator||
name|V_WR_GEN
argument_list|(
name|ogen
argument_list|)
argument_list|)
operator||
name|wr_lo
expr_stmt|;
name|wr_gen2
argument_list|(
operator|(
expr|struct
name|tx_desc
operator|*
operator|)
name|wp
argument_list|,
name|ogen
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* sizeof(*eh) + sizeof(*ip) + sizeof(*tcp) */
end_comment

begin_define
define|#
directive|define
name|TCPPKTHDRSIZE
value|(ETHER_HDR_LEN + 20 + 20)
end_define

begin_define
define|#
directive|define
name|GET_VTAG
parameter_list|(
name|cntrl
parameter_list|,
name|m
parameter_list|)
define|\
value|do { \ 	if ((m)->m_flags& M_VLANTAG)					            \ 		cntrl |= F_TXPKT_VLAN_VLD | V_TXPKT_VLAN((m)->m_pkthdr.ether_vtag); \ } while (0)
end_define

begin_function
specifier|static
name|int
name|t3_encap
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|)
block|{
name|adapter_t
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
name|struct
name|txq_state
name|txqs
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
decl_stmt|;
name|unsigned
name|int
name|ndesc
decl_stmt|,
name|flits
decl_stmt|,
name|cntrl
decl_stmt|,
name|mlen
decl_stmt|;
name|int
name|err
decl_stmt|,
name|nsegs
decl_stmt|,
name|tso_info
init|=
literal|0
decl_stmt|;
name|struct
name|work_request_hdr
modifier|*
name|wrp
decl_stmt|;
name|struct
name|tx_sw_desc
modifier|*
name|txsd
decl_stmt|;
name|struct
name|sg_ent
modifier|*
name|sgp
decl_stmt|,
modifier|*
name|sgl
decl_stmt|;
name|uint32_t
name|wr_hi
decl_stmt|,
name|wr_lo
decl_stmt|,
name|sgl_flits
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
name|TX_MAX_SEGS
index|]
decl_stmt|;
name|struct
name|tx_desc
modifier|*
name|txd
decl_stmt|;
name|pi
operator|=
name|qs
operator|->
name|port
expr_stmt|;
name|sc
operator|=
name|pi
operator|->
name|adapter
expr_stmt|;
name|txq
operator|=
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
expr_stmt|;
name|txd
operator|=
operator|&
name|txq
operator|->
name|desc
index|[
name|txq
operator|->
name|pidx
index|]
expr_stmt|;
name|txsd
operator|=
operator|&
name|txq
operator|->
name|sdesc
index|[
name|txq
operator|->
name|pidx
index|]
expr_stmt|;
name|sgl
operator|=
name|txq
operator|->
name|txq_sgl
expr_stmt|;
name|prefetch
argument_list|(
name|txd
argument_list|)
expr_stmt|;
name|m0
operator|=
operator|*
name|m
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|qs
operator|->
name|lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|cntrl
operator|=
name|V_TXPKT_INTF
argument_list|(
name|pi
operator|->
name|txpkt_intf
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m0
operator|->
name|m_flags
operator|&
name|M_PKTHDR
argument_list|,
operator|(
literal|"not packet header\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|->
name|m_nextpkt
operator|==
name|NULL
operator|&&
name|m0
operator|->
name|m_next
operator|!=
name|NULL
operator|&&
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_TSO
operator|)
condition|)
name|tso_info
operator|=
name|V_LSO_MSS
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|->
name|m_nextpkt
operator|!=
name|NULL
condition|)
block|{
name|busdma_map_sg_vec
argument_list|(
name|txq
operator|->
name|entry_tag
argument_list|,
name|txsd
operator|->
name|map
argument_list|,
name|m0
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|)
expr_stmt|;
name|ndesc
operator|=
literal|1
expr_stmt|;
name|mlen
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|busdma_map_sg_collapse
argument_list|(
name|txq
operator|->
name|entry_tag
argument_list|,
name|txsd
operator|->
name|map
argument_list|,
operator|&
name|m0
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|cxgb_debug
condition|)
name|printf
argument_list|(
literal|"failed ... err=%d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|mlen
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|ndesc
operator|=
name|calc_tx_descs
argument_list|(
name|m0
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
block|}
name|txq_prod
argument_list|(
name|txq
argument_list|,
name|ndesc
argument_list|,
operator|&
name|txqs
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
operator|(
literal|"empty packet nsegs=%d"
operator|,
name|nsegs
operator|)
argument_list|)
expr_stmt|;
name|txsd
operator|->
name|m
operator|=
name|m0
expr_stmt|;
if|if
condition|(
name|m0
operator|->
name|m_nextpkt
operator|!=
name|NULL
condition|)
block|{
name|struct
name|cpl_tx_pkt_batch
modifier|*
name|cpl_batch
init|=
operator|(
expr|struct
name|cpl_tx_pkt_batch
operator|*
operator|)
name|txd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|fidx
decl_stmt|;
if|if
condition|(
name|nsegs
operator|>
literal|7
condition|)
name|panic
argument_list|(
literal|"trying to coalesce %d packets in to one WR"
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
name|txq
operator|->
name|txq_coalesced
operator|+=
name|nsegs
expr_stmt|;
name|wrp
operator|=
operator|(
expr|struct
name|work_request_hdr
operator|*
operator|)
name|txd
expr_stmt|;
name|flits
operator|=
name|nsegs
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|fidx
operator|=
literal|1
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsegs
condition|;
name|i
operator|++
operator|,
name|fidx
operator|+=
literal|2
control|)
block|{
name|struct
name|cpl_tx_pkt_batch_entry
modifier|*
name|cbe
decl_stmt|;
name|uint64_t
name|flit
decl_stmt|;
name|uint32_t
modifier|*
name|hflit
init|=
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|flit
decl_stmt|;
name|int
name|cflags
init|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
decl_stmt|;
name|cntrl
operator|=
name|V_TXPKT_INTF
argument_list|(
name|pi
operator|->
name|txpkt_intf
argument_list|)
expr_stmt|;
name|GET_VTAG
argument_list|(
name|cntrl
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|cntrl
operator||=
name|V_TXPKT_OPCODE
argument_list|(
name|CPL_TX_PKT
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
operator|(
name|cflags
operator|&
name|CSUM_IP
operator|)
argument_list|)
condition|)
name|cntrl
operator||=
name|F_TXPKT_IPCSUM_DIS
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
operator|(
name|cflags
operator|&
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator|)
operator|)
argument_list|)
condition|)
name|cntrl
operator||=
name|F_TXPKT_L4CSUM_DIS
expr_stmt|;
name|hflit
index|[
literal|0
index|]
operator|=
name|htonl
argument_list|(
name|cntrl
argument_list|)
expr_stmt|;
name|hflit
index|[
literal|1
index|]
operator|=
name|htonl
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
operator||
literal|0x80000000
argument_list|)
expr_stmt|;
name|flit
operator||=
name|htobe64
argument_list|(
literal|1
operator|<<
literal|24
argument_list|)
expr_stmt|;
name|cbe
operator|=
operator|&
name|cpl_batch
operator|->
name|pkt_entry
index|[
name|i
index|]
expr_stmt|;
name|cbe
operator|->
name|cntrl
operator|=
name|hflit
index|[
literal|0
index|]
expr_stmt|;
name|cbe
operator|->
name|len
operator|=
name|hflit
index|[
literal|1
index|]
expr_stmt|;
name|cbe
operator|->
name|addr
operator|=
name|htobe64
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
block|}
name|wr_hi
operator|=
name|htonl
argument_list|(
name|F_WR_SOP
operator||
name|F_WR_EOP
operator||
name|V_WR_DATATYPE
argument_list|(
literal|1
argument_list|)
operator||
name|V_WR_SGLSFLT
argument_list|(
name|flits
argument_list|)
argument_list|)
operator||
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_TUNNEL_TX_PKT
argument_list|)
operator||
name|txqs
operator|.
name|compl
argument_list|)
expr_stmt|;
name|wr_lo
operator|=
name|htonl
argument_list|(
name|V_WR_LEN
argument_list|(
name|flits
argument_list|)
operator||
name|V_WR_GEN
argument_list|(
name|txqs
operator|.
name|gen
argument_list|)
argument_list|)
operator||
name|htonl
argument_list|(
name|V_WR_TID
argument_list|(
name|txq
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|set_wr_hdr
argument_list|(
name|wrp
argument_list|,
name|wr_hi
argument_list|,
name|wr_lo
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
name|ETHER_BPF_MTAP
argument_list|(
name|pi
operator|->
name|ifp
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|wr_gen2
argument_list|(
name|txd
argument_list|,
name|txqs
operator|.
name|gen
argument_list|)
expr_stmt|;
name|check_ring_tx_db
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|tso_info
condition|)
block|{
name|int
name|eth_type
decl_stmt|;
name|struct
name|cpl_tx_pkt_lso
modifier|*
name|hdr
init|=
operator|(
expr|struct
name|cpl_tx_pkt_lso
operator|*
operator|)
name|txd
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|tcp
decl_stmt|;
name|txd
operator|->
name|flit
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|GET_VTAG
argument_list|(
name|cntrl
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|cntrl
operator||=
name|V_TXPKT_OPCODE
argument_list|(
name|CPL_TX_PKT_LSO
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|cntrl
operator|=
name|htonl
argument_list|(
name|cntrl
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|len
operator|=
name|htonl
argument_list|(
name|mlen
operator||
literal|0x80000000
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|mlen
operator|<
name|TCPPKTHDRSIZE
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"mbuf=%p,len=%d,tso_segsz=%d,csum_flags=%#x,flags=%#x"
argument_list|,
name|m0
argument_list|,
name|mlen
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
argument_list|,
name|m0
operator|->
name|m_flags
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"tx tso packet too small"
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure that ether, ip, tcp headers are all in m0 */
if|if
condition|(
name|__predict_false
argument_list|(
name|m0
operator|->
name|m_len
operator|<
name|TCPPKTHDRSIZE
argument_list|)
condition|)
block|{
name|m0
operator|=
name|m_pullup
argument_list|(
name|m0
argument_list|,
name|TCPPKTHDRSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|m0
operator|==
name|NULL
argument_list|)
condition|)
block|{
comment|/* XXX panic probably an overreaction */
name|panic
argument_list|(
literal|"couldn't fit header into mbuf"
argument_list|)
expr_stmt|;
block|}
block|}
name|eh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|ether_type
operator|==
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
condition|)
block|{
name|eth_type
operator|=
name|CPL_ETH_II_VLAN
expr_stmt|;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
operator|(
expr|struct
name|ether_vlan_header
operator|*
operator|)
name|eh
operator|+
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|eth_type
operator|=
name|CPL_ETH_II
expr_stmt|;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|eh
operator|+
literal|1
operator|)
expr_stmt|;
block|}
name|tcp
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
name|ip
operator|+
literal|1
operator|)
expr_stmt|;
name|tso_info
operator||=
name|V_LSO_ETH_TYPE
argument_list|(
name|eth_type
argument_list|)
operator||
name|V_LSO_IPHDR_WORDS
argument_list|(
name|ip
operator|->
name|ip_hl
argument_list|)
operator||
name|V_LSO_TCPHDR_WORDS
argument_list|(
name|tcp
operator|->
name|th_off
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|lso_info
operator|=
name|htonl
argument_list|(
name|tso_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|mlen
operator|<=
name|PIO_LEN
argument_list|)
condition|)
block|{
comment|/* 			 * pkt not undersized but fits in PIO_LEN 			 * Indicates a TSO bug at the higher levels. 			 */
name|txsd
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|m_copydata
argument_list|(
name|m0
argument_list|,
literal|0
argument_list|,
name|mlen
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|txd
operator|->
name|flit
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|flits
operator|=
operator|(
name|mlen
operator|+
literal|7
operator|)
operator|/
literal|8
operator|+
literal|3
expr_stmt|;
name|wr_hi
operator|=
name|htonl
argument_list|(
name|V_WR_BCNTLFLT
argument_list|(
name|mlen
operator|&
literal|7
argument_list|)
operator||
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_TUNNEL_TX_PKT
argument_list|)
operator||
name|F_WR_SOP
operator||
name|F_WR_EOP
operator||
name|txqs
operator|.
name|compl
argument_list|)
expr_stmt|;
name|wr_lo
operator|=
name|htonl
argument_list|(
name|V_WR_LEN
argument_list|(
name|flits
argument_list|)
operator||
name|V_WR_GEN
argument_list|(
name|txqs
operator|.
name|gen
argument_list|)
operator||
name|V_WR_TID
argument_list|(
name|txq
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|set_wr_hdr
argument_list|(
operator|&
name|hdr
operator|->
name|wr
argument_list|,
name|wr_hi
argument_list|,
name|wr_lo
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
name|ETHER_BPF_MTAP
argument_list|(
name|pi
operator|->
name|ifp
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|wr_gen2
argument_list|(
name|txd
argument_list|,
name|txqs
operator|.
name|gen
argument_list|)
expr_stmt|;
name|check_ring_tx_db
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|flits
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|struct
name|cpl_tx_pkt
modifier|*
name|cpl
init|=
operator|(
expr|struct
name|cpl_tx_pkt
operator|*
operator|)
name|txd
decl_stmt|;
name|GET_VTAG
argument_list|(
name|cntrl
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|cntrl
operator||=
name|V_TXPKT_OPCODE
argument_list|(
name|CPL_TX_PKT
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
operator|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_IP
operator|)
argument_list|)
condition|)
name|cntrl
operator||=
name|F_TXPKT_IPCSUM_DIS
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
operator|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator|)
operator|)
argument_list|)
condition|)
name|cntrl
operator||=
name|F_TXPKT_L4CSUM_DIS
expr_stmt|;
name|cpl
operator|->
name|cntrl
operator|=
name|htonl
argument_list|(
name|cntrl
argument_list|)
expr_stmt|;
name|cpl
operator|->
name|len
operator|=
name|htonl
argument_list|(
name|mlen
operator||
literal|0x80000000
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlen
operator|<=
name|PIO_LEN
condition|)
block|{
name|txsd
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|m_copydata
argument_list|(
name|m0
argument_list|,
literal|0
argument_list|,
name|mlen
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|txd
operator|->
name|flit
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|flits
operator|=
operator|(
name|mlen
operator|+
literal|7
operator|)
operator|/
literal|8
operator|+
literal|2
expr_stmt|;
name|wr_hi
operator|=
name|htonl
argument_list|(
name|V_WR_BCNTLFLT
argument_list|(
name|mlen
operator|&
literal|7
argument_list|)
operator||
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_TUNNEL_TX_PKT
argument_list|)
operator||
name|F_WR_SOP
operator||
name|F_WR_EOP
operator||
name|txqs
operator|.
name|compl
argument_list|)
expr_stmt|;
name|wr_lo
operator|=
name|htonl
argument_list|(
name|V_WR_LEN
argument_list|(
name|flits
argument_list|)
operator||
name|V_WR_GEN
argument_list|(
name|txqs
operator|.
name|gen
argument_list|)
operator||
name|V_WR_TID
argument_list|(
name|txq
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|set_wr_hdr
argument_list|(
operator|&
name|cpl
operator|->
name|wr
argument_list|,
name|wr_hi
argument_list|,
name|wr_lo
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
name|ETHER_BPF_MTAP
argument_list|(
name|pi
operator|->
name|ifp
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|wr_gen2
argument_list|(
name|txd
argument_list|,
name|txqs
operator|.
name|gen
argument_list|)
expr_stmt|;
name|check_ring_tx_db
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|flits
operator|=
literal|2
expr_stmt|;
block|}
name|wrp
operator|=
operator|(
expr|struct
name|work_request_hdr
operator|*
operator|)
name|txd
expr_stmt|;
name|sgp
operator|=
operator|(
name|ndesc
operator|==
literal|1
operator|)
condition|?
operator|(
expr|struct
name|sg_ent
operator|*
operator|)
operator|&
name|txd
operator|->
name|flit
index|[
name|flits
index|]
else|:
name|sgl
expr_stmt|;
name|make_sgl
argument_list|(
name|sgp
argument_list|,
name|segs
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
name|sgl_flits
operator|=
name|sgl_len
argument_list|(
name|nsegs
argument_list|)
expr_stmt|;
name|ETHER_BPF_MTAP
argument_list|(
name|pi
operator|->
name|ifp
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ndesc
operator|<=
literal|4
argument_list|,
operator|(
literal|"ndesc too large %d"
operator|,
name|ndesc
operator|)
argument_list|)
expr_stmt|;
name|wr_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_TUNNEL_TX_PKT
argument_list|)
operator||
name|txqs
operator|.
name|compl
argument_list|)
expr_stmt|;
name|wr_lo
operator|=
name|htonl
argument_list|(
name|V_WR_TID
argument_list|(
name|txq
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|write_wr_hdr_sgl
argument_list|(
name|ndesc
argument_list|,
name|txd
argument_list|,
operator|&
name|txqs
argument_list|,
name|txq
argument_list|,
name|sgl
argument_list|,
name|flits
argument_list|,
name|sgl_flits
argument_list|,
name|wr_hi
argument_list|,
name|wr_lo
argument_list|)
expr_stmt|;
name|check_ring_tx_db
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cxgb_tx_watchdog
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sge_qset
modifier|*
name|qs
init|=
name|arg
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
init|=
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
decl_stmt|;
if|if
condition|(
name|qs
operator|->
name|coalescing
operator|!=
literal|0
operator|&&
operator|(
name|txq
operator|->
name|in_use
operator|<=
name|cxgb_tx_coalesce_enable_stop
operator|)
operator|&&
name|TXQ_RING_EMPTY
argument_list|(
name|qs
argument_list|)
condition|)
name|qs
operator|->
name|coalescing
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|qs
operator|->
name|coalescing
operator|==
literal|0
operator|&&
operator|(
name|txq
operator|->
name|in_use
operator|>=
name|cxgb_tx_coalesce_enable_start
operator|)
condition|)
name|qs
operator|->
name|coalescing
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TXQ_TRYLOCK
argument_list|(
name|qs
argument_list|)
condition|)
block|{
name|qs
operator|->
name|qs_flags
operator||=
name|QS_FLUSHING
expr_stmt|;
name|cxgb_start_locked
argument_list|(
name|qs
argument_list|)
expr_stmt|;
name|qs
operator|->
name|qs_flags
operator|&=
operator|~
name|QS_FLUSHING
expr_stmt|;
name|TXQ_UNLOCK
argument_list|(
name|qs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qs
operator|->
name|port
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|callout_reset_on
argument_list|(
operator|&
name|txq
operator|->
name|txq_watchdog
argument_list|,
name|hz
operator|/
literal|4
argument_list|,
name|cxgb_tx_watchdog
argument_list|,
name|qs
argument_list|,
name|txq
operator|->
name|txq_watchdog
operator|.
name|c_cpu
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_tx_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sge_qset
modifier|*
name|qs
init|=
name|arg
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
init|=
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
decl_stmt|;
if|if
condition|(
name|qs
operator|->
name|coalescing
operator|==
literal|0
operator|&&
operator|(
name|txq
operator|->
name|in_use
operator|>=
operator|(
name|txq
operator|->
name|size
operator|>>
literal|3
operator|)
operator|)
condition|)
name|qs
operator|->
name|coalescing
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TXQ_TRYLOCK
argument_list|(
name|qs
argument_list|)
condition|)
block|{
name|qs
operator|->
name|qs_flags
operator||=
name|QS_TIMEOUT
expr_stmt|;
name|cxgb_start_locked
argument_list|(
name|qs
argument_list|)
expr_stmt|;
name|qs
operator|->
name|qs_flags
operator|&=
operator|~
name|QS_TIMEOUT
expr_stmt|;
name|TXQ_UNLOCK
argument_list|(
name|qs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_start_locked
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_head
init|=
name|NULL
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
init|=
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
decl_stmt|;
name|int
name|in_use_init
init|=
name|txq
operator|->
name|in_use
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|qs
operator|->
name|port
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|pi
operator|->
name|ifp
decl_stmt|;
if|if
condition|(
name|qs
operator|->
name|qs_flags
operator|&
operator|(
name|QS_FLUSHING
operator||
name|QS_TIMEOUT
operator|)
condition|)
name|reclaim_completed_tx
argument_list|(
name|qs
argument_list|,
literal|0
argument_list|,
name|TXQ_ETH
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pi
operator|->
name|link_config
operator|.
name|link_ok
condition|)
block|{
name|TXQ_RING_FLUSH
argument_list|(
name|qs
argument_list|)
expr_stmt|;
return|return;
block|}
name|TXQ_LOCK_ASSERT
argument_list|(
name|qs
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|txq
operator|->
name|in_use
operator|-
name|in_use_init
operator|<
name|TX_START_MAX_DESC
operator|)
operator|&&
operator|!
name|TXQ_RING_EMPTY
argument_list|(
name|qs
argument_list|)
operator|&&
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|&&
name|pi
operator|->
name|link_config
operator|.
name|link_ok
condition|)
block|{
name|reclaim_completed_tx
argument_list|(
name|qs
argument_list|,
name|cxgb_tx_reclaim_threshold
argument_list|,
name|TXQ_ETH
argument_list|)
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|size
operator|-
name|txq
operator|->
name|in_use
operator|<=
name|TX_MAX_DESC
condition|)
break|break;
if|if
condition|(
operator|(
name|m_head
operator|=
name|cxgb_dequeue
argument_list|(
name|qs
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
comment|/* 		 *  Encapsulation can modify our pointer, and or make it 		 *  NULL on failure.  In that event, we can't requeue. 		 */
if|if
condition|(
name|t3_encap
argument_list|(
name|qs
argument_list|,
operator|&
name|m_head
argument_list|)
operator|||
name|m_head
operator|==
name|NULL
condition|)
break|break;
name|m_head
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TXQ_RING_EMPTY
argument_list|(
name|qs
argument_list|)
operator|&&
name|callout_pending
argument_list|(
operator|&
name|txq
operator|->
name|txq_timer
argument_list|)
operator|==
literal|0
operator|&&
name|pi
operator|->
name|link_config
operator|.
name|link_ok
condition|)
name|callout_reset_on
argument_list|(
operator|&
name|txq
operator|->
name|txq_timer
argument_list|,
literal|1
argument_list|,
name|cxgb_tx_timeout
argument_list|,
name|qs
argument_list|,
name|txq
operator|->
name|txq_timer
operator|.
name|c_cpu
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_head
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m_head
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_transmit_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|qs
operator|->
name|port
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
init|=
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
decl_stmt|;
name|struct
name|buf_ring
modifier|*
name|br
init|=
name|txq
operator|->
name|txq_mr
decl_stmt|;
name|int
name|error
decl_stmt|,
name|avail
decl_stmt|;
name|avail
operator|=
name|txq
operator|->
name|size
operator|-
name|txq
operator|->
name|in_use
expr_stmt|;
name|TXQ_LOCK_ASSERT
argument_list|(
name|qs
argument_list|)
expr_stmt|;
comment|/* 	 * We can only do a direct transmit if the following are true: 	 * - we aren't coalescing (ring< 3/4 full) 	 * - the link is up -- checked in caller 	 * - there are no packets enqueued already 	 * - there is space in hardware transmit queue  	 */
if|if
condition|(
name|check_pkt_coalesce
argument_list|(
name|qs
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|TXQ_RING_NEEDS_ENQUEUE
argument_list|(
name|qs
argument_list|)
operator|&&
name|avail
operator|>
name|TX_MAX_DESC
condition|)
block|{
if|if
condition|(
name|t3_encap
argument_list|(
name|qs
argument_list|,
operator|&
name|m
argument_list|)
condition|)
block|{
if|if
condition|(
name|m
operator|!=
name|NULL
operator|&&
operator|(
name|error
operator|=
name|drbr_enqueue
argument_list|(
name|ifp
argument_list|,
name|br
argument_list|,
name|m
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
block|{
comment|/* 			 * We've bypassed the buf ring so we need to update 			 * the stats directly 			 */
name|txq
operator|->
name|txq_direct_packets
operator|++
expr_stmt|;
name|txq
operator|->
name|txq_direct_bytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|error
operator|=
name|drbr_enqueue
argument_list|(
name|ifp
argument_list|,
name|br
argument_list|,
name|m
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|reclaim_completed_tx
argument_list|(
name|qs
argument_list|,
name|cxgb_tx_reclaim_threshold
argument_list|,
name|TXQ_ETH
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TXQ_RING_EMPTY
argument_list|(
name|qs
argument_list|)
operator|&&
name|pi
operator|->
name|link_config
operator|.
name|link_ok
operator|&&
operator|(
operator|!
name|check_pkt_coalesce
argument_list|(
name|qs
argument_list|)
operator|||
operator|(
name|drbr_inuse
argument_list|(
name|ifp
argument_list|,
name|br
argument_list|)
operator|>=
literal|7
operator|)
operator|)
condition|)
name|cxgb_start_locked
argument_list|(
name|qs
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TXQ_RING_EMPTY
argument_list|(
name|qs
argument_list|)
operator|&&
operator|!
name|callout_pending
argument_list|(
operator|&
name|txq
operator|->
name|txq_timer
argument_list|)
condition|)
name|callout_reset_on
argument_list|(
operator|&
name|txq
operator|->
name|txq_timer
argument_list|,
literal|1
argument_list|,
name|cxgb_tx_timeout
argument_list|,
name|qs
argument_list|,
name|txq
operator|->
name|txq_timer
operator|.
name|c_cpu
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cxgb_transmit
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|sge_qset
modifier|*
name|qs
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|qidx
init|=
name|pi
operator|->
name|first_qset
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
operator|||
operator|(
operator|!
name|pi
operator|->
name|link_config
operator|.
name|link_ok
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_FLOWID
condition|)
name|qidx
operator|=
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|%
name|pi
operator|->
name|nqsets
operator|)
operator|+
name|pi
operator|->
name|first_qset
expr_stmt|;
name|qs
operator|=
operator|&
name|pi
operator|->
name|adapter
operator|->
name|sge
operator|.
name|qs
index|[
name|qidx
index|]
expr_stmt|;
if|if
condition|(
name|TXQ_TRYLOCK
argument_list|(
name|qs
argument_list|)
condition|)
block|{
comment|/* XXX running */
name|error
operator|=
name|cxgb_transmit_locked
argument_list|(
name|ifp
argument_list|,
name|qs
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|TXQ_UNLOCK
argument_list|(
name|qs
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|drbr_enqueue
argument_list|(
name|ifp
argument_list|,
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|txq_mr
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cxgb_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|sge_qset
modifier|*
name|qs
init|=
operator|&
name|pi
operator|->
name|adapter
operator|->
name|sge
operator|.
name|qs
index|[
name|pi
operator|->
name|first_qset
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|pi
operator|->
name|link_config
operator|.
name|link_ok
condition|)
return|return;
name|TXQ_LOCK
argument_list|(
name|qs
argument_list|)
expr_stmt|;
name|cxgb_start_locked
argument_list|(
name|qs
argument_list|)
expr_stmt|;
name|TXQ_UNLOCK
argument_list|(
name|qs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cxgb_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
comment|/* 	 * flush any enqueued mbufs in the buf_rings 	 * and in the transmit queues 	 * no-op for now 	 */
return|return;
block|}
end_function

begin_comment
comment|/**  *	write_imm - write a packet into a Tx descriptor as immediate data  *	@d: the Tx descriptor to write  *	@m: the packet  *	@len: the length of packet data to write as immediate data  *	@gen: the generation bit value to write  *  *	Writes a packet as immediate data into a Tx descriptor.  The packet  *	contains a work request at its beginning.  We must write the packet  *	carefully so the SGE doesn't read accidentally before it's written in  *	its entirety.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|write_imm
parameter_list|(
name|struct
name|tx_desc
modifier|*
name|d
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|,
name|unsigned
name|int
name|gen
parameter_list|)
block|{
name|struct
name|work_request_hdr
modifier|*
name|from
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|work_request_hdr
operator|*
argument_list|)
decl_stmt|;
name|struct
name|work_request_hdr
modifier|*
name|to
init|=
operator|(
expr|struct
name|work_request_hdr
operator|*
operator|)
name|d
decl_stmt|;
name|uint32_t
name|wr_hi
decl_stmt|,
name|wr_lo
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|WR_LEN
condition|)
name|panic
argument_list|(
literal|"len too big %d\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|from
argument_list|)
condition|)
name|panic
argument_list|(
literal|"len too small %d"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|to
index|[
literal|1
index|]
argument_list|,
operator|&
name|from
index|[
literal|1
index|]
argument_list|,
name|len
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|wr_hi
operator|=
name|from
operator|->
name|wrh_hi
operator||
name|htonl
argument_list|(
name|F_WR_SOP
operator||
name|F_WR_EOP
operator||
name|V_WR_BCNTLFLT
argument_list|(
name|len
operator|&
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|wr_lo
operator|=
name|from
operator|->
name|wrh_lo
operator||
name|htonl
argument_list|(
name|V_WR_GEN
argument_list|(
name|gen
argument_list|)
operator||
name|V_WR_LEN
argument_list|(
operator|(
name|len
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|set_wr_hdr
argument_list|(
name|to
argument_list|,
name|wr_hi
argument_list|,
name|wr_lo
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
name|wr_gen2
argument_list|(
name|d
argument_list|,
name|gen
argument_list|)
expr_stmt|;
comment|/* 	 * This check is a hack we should really fix the logic so 	 * that this can't happen 	 */
if|if
condition|(
name|m
operator|->
name|m_type
operator|!=
name|MT_DONTFREE
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	check_desc_avail - check descriptor availability on a send queue  *	@adap: the adapter  *	@q: the TX queue  *	@m: the packet needing the descriptors  *	@ndesc: the number of Tx descriptors needed  *	@qid: the Tx queue number in its queue set (TXQ_OFLD or TXQ_CTRL)  *  *	Checks if the requested number of Tx descriptors is available on an  *	SGE send queue.  If the queue is already suspended or not enough  *	descriptors are available the packet is queued for later transmission.  *	Must be called with the Tx queue locked.  *  *	Returns 0 if enough descriptors are available, 1 if there aren't  *	enough descriptors and the packet has been queued, and 2 if the caller  *	needs to retry because there weren't enough descriptors at the  *	beginning of the call but some freed up in the mean time.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|check_desc_avail
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|struct
name|sge_txq
modifier|*
name|q
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|unsigned
name|int
name|ndesc
parameter_list|,
name|unsigned
name|int
name|qid
parameter_list|)
block|{
comment|/*  	 * XXX We currently only use this for checking the control queue 	 * the control queue is only used for binding qsets which happens 	 * at init time so we are guaranteed enough descriptors 	 */
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
name|mbufq_empty
argument_list|(
operator|&
name|q
operator|->
name|sendq
argument_list|)
argument_list|)
condition|)
block|{
name|addq_exit
label|:
name|mbufq_tail
argument_list|(
operator|&
name|q
operator|->
name|sendq
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|__predict_false
argument_list|(
name|q
operator|->
name|size
operator|-
name|q
operator|->
name|in_use
operator|<
name|ndesc
argument_list|)
condition|)
block|{
name|struct
name|sge_qset
modifier|*
name|qs
init|=
name|txq_to_qset
argument_list|(
name|q
argument_list|,
name|qid
argument_list|)
decl_stmt|;
name|setbit
argument_list|(
operator|&
name|qs
operator|->
name|txq_stopped
argument_list|,
name|qid
argument_list|)
expr_stmt|;
if|if
condition|(
name|should_restart_tx
argument_list|(
name|q
argument_list|)
operator|&&
name|test_and_clear_bit
argument_list|(
name|qid
argument_list|,
operator|&
name|qs
operator|->
name|txq_stopped
argument_list|)
condition|)
return|return
literal|2
return|;
name|q
operator|->
name|stops
operator|++
expr_stmt|;
goto|goto
name|addq_exit
goto|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	reclaim_completed_tx_imm - reclaim completed control-queue Tx descs  *	@q: the SGE control Tx queue  *  *	This is a variant of reclaim_completed_tx() that is used for Tx queues  *	that send only immediate data (presently just the control queues) and  *	thus do not have any mbufs  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|reclaim_completed_tx_imm
parameter_list|(
name|struct
name|sge_txq
modifier|*
name|q
parameter_list|)
block|{
name|unsigned
name|int
name|reclaim
init|=
name|q
operator|->
name|processed
operator|-
name|q
operator|->
name|cleaned
decl_stmt|;
name|q
operator|->
name|in_use
operator|-=
name|reclaim
expr_stmt|;
name|q
operator|->
name|cleaned
operator|+=
name|reclaim
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|immediate
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
return|return
name|m
operator|->
name|m_len
operator|<=
name|WR_LEN
operator|&&
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<=
name|WR_LEN
return|;
block|}
end_function

begin_comment
comment|/**  *	ctrl_xmit - send a packet through an SGE control Tx queue  *	@adap: the adapter  *	@q: the control queue  *	@m: the packet  *  *	Send a packet through an SGE control Tx queue.  Packets sent through  *	a control queue must fit entirely as immediate data in a single Tx  *	descriptor and have no page fragments.  */
end_comment

begin_function
specifier|static
name|int
name|ctrl_xmit
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|struct
name|work_request_hdr
modifier|*
name|wrp
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|work_request_hdr
operator|*
argument_list|)
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|q
init|=
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
name|immediate
argument_list|(
name|m
argument_list|)
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|wrp
operator|->
name|wrh_hi
operator||=
name|htonl
argument_list|(
name|F_WR_SOP
operator||
name|F_WR_EOP
argument_list|)
expr_stmt|;
name|wrp
operator|->
name|wrh_lo
operator|=
name|htonl
argument_list|(
name|V_WR_TID
argument_list|(
name|q
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|TXQ_LOCK
argument_list|(
name|qs
argument_list|)
expr_stmt|;
name|again
label|:
name|reclaim_completed_tx_imm
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|ret
operator|=
name|check_desc_avail
argument_list|(
name|adap
argument_list|,
name|q
argument_list|,
name|m
argument_list|,
literal|1
argument_list|,
name|TXQ_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|ret
argument_list|)
condition|)
block|{
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
block|{
name|TXQ_UNLOCK
argument_list|(
name|qs
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
goto|goto
name|again
goto|;
block|}
name|write_imm
argument_list|(
operator|&
name|q
operator|->
name|desc
index|[
name|q
operator|->
name|pidx
index|]
argument_list|,
name|m
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|q
operator|->
name|gen
argument_list|)
expr_stmt|;
name|q
operator|->
name|in_use
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|q
operator|->
name|pidx
operator|>=
name|q
operator|->
name|size
condition|)
block|{
name|q
operator|->
name|pidx
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|gen
operator|^=
literal|1
expr_stmt|;
block|}
name|TXQ_UNLOCK
argument_list|(
name|qs
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_KDOORBELL
argument_list|,
name|F_SELEGRCNTX
operator||
name|V_EGRCNTX
argument_list|(
name|q
operator|->
name|cntxt_id
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	restart_ctrlq - restart a suspended control queue  *	@qs: the queue set cotaining the control queue  *  *	Resumes transmission on a suspended Tx control queue.  */
end_comment

begin_function
specifier|static
name|void
name|restart_ctrlq
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sge_qset
modifier|*
name|qs
init|=
operator|(
expr|struct
name|sge_qset
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|q
init|=
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
decl_stmt|;
name|adapter_t
modifier|*
name|adap
init|=
name|qs
operator|->
name|port
operator|->
name|adapter
decl_stmt|;
name|TXQ_LOCK
argument_list|(
name|qs
argument_list|)
expr_stmt|;
name|again
label|:
name|reclaim_completed_tx_imm
argument_list|(
name|q
argument_list|)
expr_stmt|;
while|while
condition|(
name|q
operator|->
name|in_use
operator|<
name|q
operator|->
name|size
operator|&&
operator|(
name|m
operator|=
name|mbufq_dequeue
argument_list|(
operator|&
name|q
operator|->
name|sendq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|write_imm
argument_list|(
operator|&
name|q
operator|->
name|desc
index|[
name|q
operator|->
name|pidx
index|]
argument_list|,
name|m
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|q
operator|->
name|gen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|q
operator|->
name|pidx
operator|>=
name|q
operator|->
name|size
condition|)
block|{
name|q
operator|->
name|pidx
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|gen
operator|^=
literal|1
expr_stmt|;
block|}
name|q
operator|->
name|in_use
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mbufq_empty
argument_list|(
operator|&
name|q
operator|->
name|sendq
argument_list|)
condition|)
block|{
name|setbit
argument_list|(
operator|&
name|qs
operator|->
name|txq_stopped
argument_list|,
name|TXQ_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|should_restart_tx
argument_list|(
name|q
argument_list|)
operator|&&
name|test_and_clear_bit
argument_list|(
name|TXQ_CTRL
argument_list|,
operator|&
name|qs
operator|->
name|txq_stopped
argument_list|)
condition|)
goto|goto
name|again
goto|;
name|q
operator|->
name|stops
operator|++
expr_stmt|;
block|}
name|TXQ_UNLOCK
argument_list|(
name|qs
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_KDOORBELL
argument_list|,
name|F_SELEGRCNTX
operator||
name|V_EGRCNTX
argument_list|(
name|q
operator|->
name|cntxt_id
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send a management message through control queue 0  */
end_comment

begin_function
name|int
name|t3_mgmt_tx
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
return|return
name|ctrl_xmit
argument_list|(
name|adap
argument_list|,
operator|&
name|adap
operator|->
name|sge
operator|.
name|qs
index|[
literal|0
index|]
argument_list|,
name|m
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	free_qset - free the resources of an SGE queue set  *	@sc: the controller owning the queue set  *	@q: the queue set  *  *	Release the HW and SW resources associated with an SGE queue set, such  *	as HW contexts, packet buffers, and descriptor rings.  Traffic to the  *	queue set must be quiesced prior to calling this.  */
end_comment

begin_function
specifier|static
name|void
name|t3_free_qset
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_qset
modifier|*
name|q
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|reclaim_completed_tx
argument_list|(
name|q
argument_list|,
literal|0
argument_list|,
name|TXQ_ETH
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|txq_mr
operator|!=
name|NULL
condition|)
name|buf_ring_free
argument_list|(
name|q
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|txq_mr
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|txq_ifq
operator|!=
name|NULL
condition|)
block|{
name|ifq_delete
argument_list|(
name|q
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|txq_ifq
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|q
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|txq_ifq
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SGE_RXQ_PER_SET
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|desc
condition|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
name|t3_sge_disable_fl
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|cntxt_id
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|desc_tag
argument_list|,
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|desc_map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|desc_tag
argument_list|,
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|desc
argument_list|,
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|desc_map
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|desc_tag
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|entry_tag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|sdesc
condition|)
block|{
name|free_rx_bufs
argument_list|(
name|sc
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|sdesc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|q
operator|->
name|lock
argument_list|)
expr_stmt|;
name|MTX_DESTROY
argument_list|(
operator|&
name|q
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SGE_TXQ_PER_SET
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|desc
condition|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
name|t3_sge_enable_ecntxt
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|cntxt_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|desc_tag
argument_list|,
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|desc_map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|desc_tag
argument_list|,
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|desc
argument_list|,
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|desc_map
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|desc_tag
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|entry_tag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|sdesc
condition|)
block|{
name|free
argument_list|(
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|sdesc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|q
operator|->
name|rspq
operator|.
name|desc
condition|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
name|t3_sge_disable_rspcntxt
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|rspq
operator|.
name|cntxt_id
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|q
operator|->
name|rspq
operator|.
name|desc_tag
argument_list|,
name|q
operator|->
name|rspq
operator|.
name|desc_map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|q
operator|->
name|rspq
operator|.
name|desc_tag
argument_list|,
name|q
operator|->
name|rspq
operator|.
name|desc
argument_list|,
name|q
operator|->
name|rspq
operator|.
name|desc_map
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|q
operator|->
name|rspq
operator|.
name|desc_tag
argument_list|)
expr_stmt|;
name|MTX_DESTROY
argument_list|(
operator|&
name|q
operator|->
name|rspq
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INET
name|tcp_lro_free
argument_list|(
operator|&
name|q
operator|->
name|lro
operator|.
name|ctrl
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bzero
argument_list|(
name|q
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|q
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t3_free_sge_resources - free SGE resources  *	@sc: the adapter softc  *  *	Frees resources used by the SGE queue sets.  */
end_comment

begin_function
name|void
name|t3_free_sge_resources
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|nqsets
decl_stmt|;
for|for
control|(
name|nqsets
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|sc
operator|)
operator|->
name|params
operator|.
name|nports
condition|;
name|i
operator|++
control|)
name|nqsets
operator|+=
name|sc
operator|->
name|port
index|[
name|i
index|]
operator|.
name|nqsets
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nqsets
condition|;
operator|++
name|i
control|)
block|{
name|TXQ_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|t3_free_qset
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	t3_sge_start - enable SGE  *	@sc: the controller softc  *  *	Enables the SGE for DMAs.  This is the last step in starting packet  *	transfers.  */
end_comment

begin_function
name|void
name|t3_sge_start
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|)
block|{
name|t3_set_reg_field
argument_list|(
name|sc
argument_list|,
name|A_SG_CONTROL
argument_list|,
name|F_GLOBALENABLE
argument_list|,
name|F_GLOBALENABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t3_sge_stop - disable SGE operation  *	@sc: the adapter  *  *	Disables the DMA engine.  This can be called in emeregencies (e.g.,  *	from error interrupts) or from normal process context.  In the latter  *	case it also disables any pending queue restart tasklets.  Note that  *	if it is called in interrupt context it cannot disable the restart  *	tasklets as it cannot wait, however the tasklets will have no effect  *	since the doorbells are disabled and the driver will call this again  *	later from process context, at which time the tasklets will be stopped  *	if they are still running.  */
end_comment

begin_function
name|void
name|t3_sge_stop
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|nqsets
decl_stmt|;
name|t3_set_reg_field
argument_list|(
name|sc
argument_list|,
name|A_SG_CONTROL
argument_list|,
name|F_GLOBALENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tq
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|nqsets
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|sc
operator|)
operator|->
name|params
operator|.
name|nports
condition|;
name|i
operator|++
control|)
name|nqsets
operator|+=
name|sc
operator|->
name|port
index|[
name|i
index|]
operator|.
name|nqsets
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* 	 *  	 * XXX 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nqsets
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|sge_qset
modifier|*
name|qs
init|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
name|i
index|]
decl_stmt|;
name|taskqueue_drain
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
operator|.
name|qresume_task
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
operator|.
name|qresume_task
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/**  *	t3_free_tx_desc - reclaims Tx descriptors and their buffers  *	@adapter: the adapter  *	@q: the Tx queue to reclaim descriptors from  *	@reclaimable: the number of descriptors to reclaim  *      @m_vec_size: maximum number of buffers to reclaim  *      @desc_reclaimed: returns the number of descriptors reclaimed  *  *	Reclaims Tx descriptors from an SGE Tx queue and frees the associated  *	Tx buffers.  Called with the Tx queue lock held.  *  *      Returns number of buffers of reclaimed     */
end_comment

begin_function
name|void
name|t3_free_tx_desc
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|int
name|reclaimable
parameter_list|,
name|int
name|queue
parameter_list|)
block|{
name|struct
name|tx_sw_desc
modifier|*
name|txsd
decl_stmt|;
name|unsigned
name|int
name|cidx
decl_stmt|,
name|mask
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|q
init|=
operator|&
name|qs
operator|->
name|txq
index|[
name|queue
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|T3_TRACE
name|T3_TRACE2
argument_list|(
name|sc
operator|->
name|tb
index|[
name|q
operator|->
name|cntxt_id
operator|&
literal|7
index|]
argument_list|,
literal|"reclaiming %u Tx descriptors at cidx %u"
argument_list|,
name|reclaimable
argument_list|,
name|cidx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cidx
operator|=
name|q
operator|->
name|cidx
expr_stmt|;
name|mask
operator|=
name|q
operator|->
name|size
operator|-
literal|1
expr_stmt|;
name|txsd
operator|=
operator|&
name|q
operator|->
name|sdesc
index|[
name|cidx
index|]
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|qs
operator|->
name|lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
while|while
condition|(
name|reclaimable
operator|--
condition|)
block|{
name|prefetch
argument_list|(
name|q
operator|->
name|sdesc
index|[
operator|(
name|cidx
operator|+
literal|1
operator|)
operator|&
name|mask
index|]
operator|.
name|m
argument_list|)
expr_stmt|;
name|prefetch
argument_list|(
name|q
operator|->
name|sdesc
index|[
operator|(
name|cidx
operator|+
literal|2
operator|)
operator|&
name|mask
index|]
operator|.
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|txsd
operator|->
name|m
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|txsd
operator|->
name|flags
operator|&
name|TX_SW_DESC_MAPPED
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|q
operator|->
name|entry_tag
argument_list|,
name|txsd
operator|->
name|map
argument_list|)
expr_stmt|;
name|txsd
operator|->
name|flags
operator|&=
operator|~
name|TX_SW_DESC_MAPPED
expr_stmt|;
block|}
name|m_freem_list
argument_list|(
name|txsd
operator|->
name|m
argument_list|)
expr_stmt|;
name|txsd
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|q
operator|->
name|txq_skipped
operator|++
expr_stmt|;
operator|++
name|txsd
expr_stmt|;
if|if
condition|(
operator|++
name|cidx
operator|==
name|q
operator|->
name|size
condition|)
block|{
name|cidx
operator|=
literal|0
expr_stmt|;
name|txsd
operator|=
name|q
operator|->
name|sdesc
expr_stmt|;
block|}
block|}
name|q
operator|->
name|cidx
operator|=
name|cidx
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	is_new_response - check if a response is newly written  *	@r: the response descriptor  *	@q: the response queue  *  *	Returns true if a response descriptor contains a yet unprocessed  *	response.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|is_new_response
parameter_list|(
specifier|const
name|struct
name|rsp_desc
modifier|*
name|r
parameter_list|,
specifier|const
name|struct
name|sge_rspq
modifier|*
name|q
parameter_list|)
block|{
return|return
operator|(
name|r
operator|->
name|intr_gen
operator|&
name|F_RSPD_GEN2
operator|)
operator|==
name|q
operator|->
name|gen
return|;
block|}
end_function

begin_define
define|#
directive|define
name|RSPD_GTS_MASK
value|(F_RSPD_TXQ0_GTS | F_RSPD_TXQ1_GTS)
end_define

begin_define
define|#
directive|define
name|RSPD_CTRL_MASK
value|(RSPD_GTS_MASK | \ 			V_RSPD_TXQ0_CR(M_RSPD_TXQ0_CR) | \ 			V_RSPD_TXQ1_CR(M_RSPD_TXQ1_CR) | \ 			V_RSPD_TXQ2_CR(M_RSPD_TXQ2_CR))
end_define

begin_comment
comment|/* How long to delay the next interrupt in case of memory shortage, in 0.1us. */
end_comment

begin_define
define|#
directive|define
name|NOMEM_INTR_DELAY
value|2500
end_define

begin_comment
comment|/**  *	write_ofld_wr - write an offload work request  *	@adap: the adapter  *	@m: the packet to send  *	@q: the Tx queue  *	@pidx: index of the first Tx descriptor to write  *	@gen: the generation value to use  *	@ndesc: number of descriptors the packet will occupy  *  *	Write an offload work request to send the supplied packet.  The packet  *	data already carry the work request with most fields populated.  */
end_comment

begin_function
specifier|static
name|void
name|write_ofld_wr
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sge_txq
modifier|*
name|q
parameter_list|,
name|unsigned
name|int
name|pidx
parameter_list|,
name|unsigned
name|int
name|gen
parameter_list|,
name|unsigned
name|int
name|ndesc
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|unsigned
name|int
name|nsegs
parameter_list|)
block|{
name|unsigned
name|int
name|sgl_flits
decl_stmt|,
name|flits
decl_stmt|;
name|struct
name|work_request_hdr
modifier|*
name|from
decl_stmt|;
name|struct
name|sg_ent
modifier|*
name|sgp
decl_stmt|,
name|sgl
index|[
name|TX_MAX_SEGS
operator|/
literal|2
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|tx_desc
modifier|*
name|d
init|=
operator|&
name|q
operator|->
name|desc
index|[
name|pidx
index|]
decl_stmt|;
name|struct
name|txq_state
name|txqs
decl_stmt|;
if|if
condition|(
name|immediate
argument_list|(
name|m
argument_list|)
operator|&&
name|nsegs
operator|==
literal|0
condition|)
block|{
name|write_imm
argument_list|(
name|d
argument_list|,
name|m
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|gen
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Only TX_DATA builds SGLs */
name|from
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|work_request_hdr
operator|*
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|d
operator|->
name|flit
index|[
literal|1
index|]
argument_list|,
operator|&
name|from
index|[
literal|1
index|]
argument_list|,
name|m
operator|->
name|m_len
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|flits
operator|=
name|m
operator|->
name|m_len
operator|/
literal|8
expr_stmt|;
name|sgp
operator|=
operator|(
name|ndesc
operator|==
literal|1
operator|)
condition|?
operator|(
expr|struct
name|sg_ent
operator|*
operator|)
operator|&
name|d
operator|->
name|flit
index|[
name|flits
index|]
else|:
name|sgl
expr_stmt|;
name|make_sgl
argument_list|(
name|sgp
argument_list|,
name|segs
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
name|sgl_flits
operator|=
name|sgl_len
argument_list|(
name|nsegs
argument_list|)
expr_stmt|;
name|txqs
operator|.
name|gen
operator|=
name|gen
expr_stmt|;
name|txqs
operator|.
name|pidx
operator|=
name|pidx
expr_stmt|;
name|txqs
operator|.
name|compl
operator|=
literal|0
expr_stmt|;
name|write_wr_hdr_sgl
argument_list|(
name|ndesc
argument_list|,
name|d
argument_list|,
operator|&
name|txqs
argument_list|,
name|q
argument_list|,
name|sgl
argument_list|,
name|flits
argument_list|,
name|sgl_flits
argument_list|,
name|from
operator|->
name|wrh_hi
argument_list|,
name|from
operator|->
name|wrh_lo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	calc_tx_descs_ofld - calculate # of Tx descriptors for an offload packet  *	@m: the packet  *  * 	Returns the number of Tx descriptors needed for the given offload  * 	packet.  These packets are already fully constructed.  */
end_comment

begin_function
specifier|static
name|__inline
name|unsigned
name|int
name|calc_tx_descs_ofld
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|unsigned
name|int
name|nsegs
parameter_list|)
block|{
name|unsigned
name|int
name|flits
decl_stmt|,
name|cnt
init|=
literal|0
decl_stmt|;
name|int
name|ndescs
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<=
name|WR_LEN
operator|&&
name|nsegs
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* packet fits as immediate data */
comment|/* 	 * This needs to be re-visited for TOE 	 */
name|cnt
operator|=
name|nsegs
expr_stmt|;
comment|/* headers */
name|flits
operator|=
name|m
operator|->
name|m_len
operator|/
literal|8
expr_stmt|;
name|ndescs
operator|=
name|flits_to_desc
argument_list|(
name|flits
operator|+
name|sgl_len
argument_list|(
name|cnt
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ndescs
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	ofld_xmit - send a packet through an offload queue  *	@adap: the adapter  *	@q: the Tx offload queue  *	@m: the packet  *  *	Send an offload packet through an SGE offload queue.  */
end_comment

begin_function
specifier|static
name|int
name|ofld_xmit
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|nsegs
decl_stmt|;
name|unsigned
name|int
name|ndesc
decl_stmt|;
name|unsigned
name|int
name|pidx
decl_stmt|,
name|gen
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|q
init|=
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
name|TX_MAX_SEGS
index|]
decl_stmt|,
modifier|*
name|vsegs
decl_stmt|;
name|struct
name|tx_sw_desc
modifier|*
name|stx
decl_stmt|;
name|nsegs
operator|=
name|m_get_sgllen
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vsegs
operator|=
name|m_get_sgl
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ndesc
operator|=
name|calc_tx_descs_ofld
argument_list|(
name|m
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
name|busdma_map_sgl
argument_list|(
name|vsegs
argument_list|,
name|segs
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
name|stx
operator|=
operator|&
name|q
operator|->
name|sdesc
index|[
name|q
operator|->
name|pidx
index|]
expr_stmt|;
name|TXQ_LOCK
argument_list|(
name|qs
argument_list|)
expr_stmt|;
name|again
label|:
name|reclaim_completed_tx
argument_list|(
name|qs
argument_list|,
literal|16
argument_list|,
name|TXQ_OFLD
argument_list|)
expr_stmt|;
name|ret
operator|=
name|check_desc_avail
argument_list|(
name|adap
argument_list|,
name|q
argument_list|,
name|m
argument_list|,
name|ndesc
argument_list|,
name|TXQ_OFLD
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|ret
argument_list|)
condition|)
block|{
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"no ofld desc avail\n"
argument_list|)
expr_stmt|;
name|m_set_priority
argument_list|(
name|m
argument_list|,
name|ndesc
argument_list|)
expr_stmt|;
comment|/* save for restart */
name|TXQ_UNLOCK
argument_list|(
name|qs
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINTR
operator|)
return|;
block|}
goto|goto
name|again
goto|;
block|}
name|gen
operator|=
name|q
operator|->
name|gen
expr_stmt|;
name|q
operator|->
name|in_use
operator|+=
name|ndesc
expr_stmt|;
name|pidx
operator|=
name|q
operator|->
name|pidx
expr_stmt|;
name|q
operator|->
name|pidx
operator|+=
name|ndesc
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|pidx
operator|>=
name|q
operator|->
name|size
condition|)
block|{
name|q
operator|->
name|pidx
operator|-=
name|q
operator|->
name|size
expr_stmt|;
name|q
operator|->
name|gen
operator|^=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|T3_TRACE
name|T3_TRACE5
argument_list|(
name|adap
operator|->
name|tb
index|[
name|q
operator|->
name|cntxt_id
operator|&
literal|7
index|]
argument_list|,
literal|"ofld_xmit: ndesc %u, pidx %u, len %u, main %u, frags %u"
argument_list|,
name|ndesc
argument_list|,
name|pidx
argument_list|,
name|skb
operator|->
name|len
argument_list|,
name|skb
operator|->
name|len
operator|-
name|skb
operator|->
name|data_len
argument_list|,
name|skb_shinfo
argument_list|(
name|skb
argument_list|)
operator|->
name|nr_frags
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TXQ_UNLOCK
argument_list|(
name|qs
argument_list|)
expr_stmt|;
name|write_ofld_wr
argument_list|(
name|adap
argument_list|,
name|m
argument_list|,
name|q
argument_list|,
name|pidx
argument_list|,
name|gen
argument_list|,
name|ndesc
argument_list|,
name|segs
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
name|check_ring_tx_db
argument_list|(
name|adap
argument_list|,
name|q
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	restart_offloadq - restart a suspended offload queue  *	@qs: the queue set cotaining the offload queue  *  *	Resumes transmission on a suspended Tx offload queue.  */
end_comment

begin_function
specifier|static
name|void
name|restart_offloadq
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sge_qset
modifier|*
name|qs
init|=
name|data
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|q
init|=
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
decl_stmt|;
name|adapter_t
modifier|*
name|adap
init|=
name|qs
operator|->
name|port
operator|->
name|adapter
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
name|TX_MAX_SEGS
index|]
decl_stmt|;
name|struct
name|tx_sw_desc
modifier|*
name|stx
init|=
operator|&
name|q
operator|->
name|sdesc
index|[
name|q
operator|->
name|pidx
index|]
decl_stmt|;
name|int
name|nsegs
decl_stmt|,
name|cleaned
decl_stmt|;
name|TXQ_LOCK
argument_list|(
name|qs
argument_list|)
expr_stmt|;
name|again
label|:
name|cleaned
operator|=
name|reclaim_completed_tx
argument_list|(
name|qs
argument_list|,
literal|16
argument_list|,
name|TXQ_OFLD
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|mbufq_peek
argument_list|(
operator|&
name|q
operator|->
name|sendq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|int
name|gen
decl_stmt|,
name|pidx
decl_stmt|;
name|unsigned
name|int
name|ndesc
init|=
name|m_get_priority
argument_list|(
name|m
argument_list|)
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|q
operator|->
name|size
operator|-
name|q
operator|->
name|in_use
operator|<
name|ndesc
argument_list|)
condition|)
block|{
name|setbit
argument_list|(
operator|&
name|qs
operator|->
name|txq_stopped
argument_list|,
name|TXQ_OFLD
argument_list|)
expr_stmt|;
if|if
condition|(
name|should_restart_tx
argument_list|(
name|q
argument_list|)
operator|&&
name|test_and_clear_bit
argument_list|(
name|TXQ_OFLD
argument_list|,
operator|&
name|qs
operator|->
name|txq_stopped
argument_list|)
condition|)
goto|goto
name|again
goto|;
name|q
operator|->
name|stops
operator|++
expr_stmt|;
break|break;
block|}
name|gen
operator|=
name|q
operator|->
name|gen
expr_stmt|;
name|q
operator|->
name|in_use
operator|+=
name|ndesc
expr_stmt|;
name|pidx
operator|=
name|q
operator|->
name|pidx
expr_stmt|;
name|q
operator|->
name|pidx
operator|+=
name|ndesc
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|pidx
operator|>=
name|q
operator|->
name|size
condition|)
block|{
name|q
operator|->
name|pidx
operator|-=
name|q
operator|->
name|size
expr_stmt|;
name|q
operator|->
name|gen
operator|^=
literal|1
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|mbufq_dequeue
argument_list|(
operator|&
name|q
operator|->
name|sendq
argument_list|)
expr_stmt|;
name|busdma_map_mbufs
argument_list|(
operator|&
name|m
argument_list|,
name|q
argument_list|,
name|stx
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|)
expr_stmt|;
name|TXQ_UNLOCK
argument_list|(
name|qs
argument_list|)
expr_stmt|;
name|write_ofld_wr
argument_list|(
name|adap
argument_list|,
name|m
argument_list|,
name|q
argument_list|,
name|pidx
argument_list|,
name|gen
argument_list|,
name|ndesc
argument_list|,
name|segs
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
name|TXQ_LOCK
argument_list|(
name|qs
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|USE_GTS
name|set_bit
argument_list|(
name|TXQ_RUNNING
argument_list|,
operator|&
name|q
operator|->
name|flags
argument_list|)
expr_stmt|;
name|set_bit
argument_list|(
name|TXQ_LAST_PKT_DB
argument_list|,
operator|&
name|q
operator|->
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TXQ_UNLOCK
argument_list|(
name|qs
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_KDOORBELL
argument_list|,
name|F_SELEGRCNTX
operator||
name|V_EGRCNTX
argument_list|(
name|q
operator|->
name|cntxt_id
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	queue_set - return the queue set a packet should use  *	@m: the packet  *  *	Maps a packet to the SGE queue set it should use.  The desired queue  *	set is carried in bits 1-3 in the packet's priority.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|queue_set
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
return|return
name|m_get_priority
argument_list|(
name|m
argument_list|)
operator|>>
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  *	is_ctrl_pkt - return whether an offload packet is a control packet  *	@m: the packet  *  *	Determines whether an offload packet should use an OFLD or a CTRL  *	Tx queue.  This is indicated by bit 0 in the packet's priority.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|is_ctrl_pkt
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
return|return
name|m_get_priority
argument_list|(
name|m
argument_list|)
operator|&
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_offload_tx - send an offload packet  *	@tdev: the offload device to send to  *	@m: the packet  *  *	Sends an offload packet.  We use the packet priority to select the  *	appropriate Tx queue as follows: bit 0 indicates whether the packet  *	should be sent as regular or control, bits 1-3 select the queue set.  */
end_comment

begin_function
name|int
name|t3_offload_tx
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|tdev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|adapter_t
modifier|*
name|adap
init|=
name|tdev2adap
argument_list|(
name|tdev
argument_list|)
decl_stmt|;
name|struct
name|sge_qset
modifier|*
name|qs
init|=
operator|&
name|adap
operator|->
name|sge
operator|.
name|qs
index|[
name|queue_set
argument_list|(
name|m
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|is_ctrl_pkt
argument_list|(
name|m
argument_list|)
argument_list|)
condition|)
return|return
name|ctrl_xmit
argument_list|(
name|adap
argument_list|,
name|qs
argument_list|,
name|m
argument_list|)
return|;
return|return
name|ofld_xmit
argument_list|(
name|adap
argument_list|,
name|qs
argument_list|,
name|m
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	deliver_partial_bundle - deliver a (partial) bundle of Rx offload pkts  *	@tdev: the offload device that will be receiving the packets  *	@q: the SGE response queue that assembled the bundle  *	@m: the partial bundle  *	@n: the number of packets in the bundle  *  *	Delivers a (partial) bundle of Rx offload packets to an offload device.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|deliver_partial_bundle
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|tdev
parameter_list|,
name|struct
name|sge_rspq
modifier|*
name|q
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mbufs
index|[]
parameter_list|,
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
name|n
condition|)
block|{
name|q
operator|->
name|offload_bundles
operator|++
expr_stmt|;
name|cxgb_ofld_recv
argument_list|(
name|tdev
argument_list|,
name|mbufs
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|rx_offload
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|tdev
parameter_list|,
name|struct
name|sge_rspq
modifier|*
name|rq
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|mbuf
modifier|*
name|rx_gather
index|[]
parameter_list|,
name|unsigned
name|int
name|gather_idx
parameter_list|)
block|{
name|rq
operator|->
name|offload_pkts
operator|++
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|header
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
name|rx_gather
index|[
name|gather_idx
operator|++
index|]
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|gather_idx
operator|==
name|RX_BUNDLE_SIZE
condition|)
block|{
name|cxgb_ofld_recv
argument_list|(
name|tdev
argument_list|,
name|rx_gather
argument_list|,
name|RX_BUNDLE_SIZE
argument_list|)
expr_stmt|;
name|gather_idx
operator|=
literal|0
expr_stmt|;
name|rq
operator|->
name|offload_bundles
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|gather_idx
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|restart_tx
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|qs
operator|->
name|port
operator|->
name|adapter
decl_stmt|;
if|if
condition|(
name|isset
argument_list|(
operator|&
name|qs
operator|->
name|txq_stopped
argument_list|,
name|TXQ_OFLD
argument_list|)
operator|&&
name|should_restart_tx
argument_list|(
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
argument_list|)
operator|&&
name|test_and_clear_bit
argument_list|(
name|TXQ_OFLD
argument_list|,
operator|&
name|qs
operator|->
name|txq_stopped
argument_list|)
condition|)
block|{
name|qs
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
operator|.
name|restarts
operator|++
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"restarting TXQ_OFLD\n"
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
operator|.
name|qresume_task
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|"stopped=0x%x restart=%d processed=%d cleaned=%d in_use=%d\n"
argument_list|,
name|qs
operator|->
name|txq_stopped
argument_list|,
name|should_restart_tx
argument_list|(
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
argument_list|)
argument_list|,
name|qs
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
operator|.
name|processed
argument_list|,
name|qs
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
operator|.
name|cleaned
argument_list|,
name|qs
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
operator|.
name|in_use
argument_list|)
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
operator|&
name|qs
operator|->
name|txq_stopped
argument_list|,
name|TXQ_CTRL
argument_list|)
operator|&&
name|should_restart_tx
argument_list|(
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
argument_list|)
operator|&&
name|test_and_clear_bit
argument_list|(
name|TXQ_CTRL
argument_list|,
operator|&
name|qs
operator|->
name|txq_stopped
argument_list|)
condition|)
block|{
name|qs
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
operator|.
name|restarts
operator|++
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"restarting TXQ_CTRL\n"
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
operator|.
name|qresume_task
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	t3_sge_alloc_qset - initialize an SGE queue set  *	@sc: the controller softc  *	@id: the queue set id  *	@nports: how many Ethernet ports will be using this queue set  *	@irq_vec_idx: the IRQ vector index for response queue interrupts  *	@p: configuration parameters for this queue set  *	@ntxq: number of Tx queues for the queue set  *	@pi: port info for queue set  *  *	Allocate resources and initialize an SGE queue set.  A queue set  *	comprises a response queue, two Rx free-buffer queues, and up to 3  *	Tx queues.  The Tx queues are assigned roles in the order Ethernet  *	queue, offload queue, and control queue.  */
end_comment

begin_function
name|int
name|t3_sge_alloc_qset
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|,
name|u_int
name|id
parameter_list|,
name|int
name|nports
parameter_list|,
name|int
name|irq_vec_idx
parameter_list|,
specifier|const
name|struct
name|qset_params
modifier|*
name|p
parameter_list|,
name|int
name|ntxq
parameter_list|,
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|sge_qset
modifier|*
name|q
init|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
name|id
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|MTX_INIT
argument_list|(
operator|&
name|q
operator|->
name|lock
argument_list|,
name|q
operator|->
name|namebuf
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|q
operator|->
name|port
operator|=
name|pi
expr_stmt|;
if|if
condition|(
operator|(
name|q
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|txq_mr
operator|=
name|buf_ring_alloc
argument_list|(
name|cxgb_txq_buf_ring_size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|,
operator|&
name|q
operator|->
name|lock
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to allocate mbuf ring\n"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|(
name|q
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|txq_ifq
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ifaltq
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to allocate ifq\n"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|ifq_init
argument_list|(
name|q
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|txq_ifq
argument_list|,
name|pi
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|q
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|txq_timer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|q
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|txq_watchdog
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|q
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|txq_timer
operator|.
name|c_cpu
operator|=
name|id
operator|%
name|mp_ncpus
expr_stmt|;
name|q
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|txq_watchdog
operator|.
name|c_cpu
operator|=
name|id
operator|%
name|mp_ncpus
expr_stmt|;
name|init_qset_cntxt
argument_list|(
name|q
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|q
operator|->
name|idx
operator|=
name|id
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|alloc_ring
argument_list|(
name|sc
argument_list|,
name|p
operator|->
name|fl_size
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rx_desc
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rx_sw_desc
argument_list|)
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|phys_addr
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|desc
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|sdesc
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|desc_tag
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|desc_map
argument_list|,
name|sc
operator|->
name|rx_dmat
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|entry_tag
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"error %d from alloc ring fl0\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|(
name|ret
operator|=
name|alloc_ring
argument_list|(
name|sc
argument_list|,
name|p
operator|->
name|jumbo_size
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rx_desc
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rx_sw_desc
argument_list|)
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|phys_addr
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|desc
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|sdesc
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|desc_tag
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|desc_map
argument_list|,
name|sc
operator|->
name|rx_jumbo_dmat
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|entry_tag
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"error %d from alloc ring fl1\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|(
name|ret
operator|=
name|alloc_ring
argument_list|(
name|sc
argument_list|,
name|p
operator|->
name|rspq_size
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rsp_desc
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|q
operator|->
name|rspq
operator|.
name|phys_addr
argument_list|,
operator|&
name|q
operator|->
name|rspq
operator|.
name|desc
argument_list|,
name|NULL
argument_list|,
operator|&
name|q
operator|->
name|rspq
operator|.
name|desc_tag
argument_list|,
operator|&
name|q
operator|->
name|rspq
operator|.
name|desc_map
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"error %d from alloc ring rspq\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntxq
condition|;
operator|++
name|i
control|)
block|{
name|size_t
name|sz
init|=
name|i
operator|==
name|TXQ_CTRL
condition|?
literal|0
else|:
sizeof|sizeof
argument_list|(
expr|struct
name|tx_sw_desc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|alloc_ring
argument_list|(
name|sc
argument_list|,
name|p
operator|->
name|txq_size
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tx_desc
argument_list|)
argument_list|,
name|sz
argument_list|,
operator|&
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|phys_addr
argument_list|,
operator|&
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|desc
argument_list|,
operator|&
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|sdesc
argument_list|,
operator|&
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|desc_tag
argument_list|,
operator|&
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|desc_map
argument_list|,
name|sc
operator|->
name|tx_dmat
argument_list|,
operator|&
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|entry_tag
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"error %d from alloc ring tx %i\n"
argument_list|,
name|ret
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|mbufq_init
argument_list|(
operator|&
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|sendq
argument_list|)
expr_stmt|;
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|gen
operator|=
literal|1
expr_stmt|;
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|size
operator|=
name|p
operator|->
name|txq_size
index|[
name|i
index|]
expr_stmt|;
block|}
name|TASK_INIT
argument_list|(
operator|&
name|q
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
operator|.
name|qresume_task
argument_list|,
literal|0
argument_list|,
name|restart_offloadq
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|q
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
operator|.
name|qresume_task
argument_list|,
literal|0
argument_list|,
name|restart_ctrlq
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|q
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|qreclaim_task
argument_list|,
literal|0
argument_list|,
name|sge_txq_reclaim_handler
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|q
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
operator|.
name|qreclaim_task
argument_list|,
literal|0
argument_list|,
name|sge_txq_reclaim_handler
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|q
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|gen
operator|=
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|gen
operator|=
literal|1
expr_stmt|;
name|q
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|size
operator|=
name|p
operator|->
name|fl_size
expr_stmt|;
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|size
operator|=
name|p
operator|->
name|jumbo_size
expr_stmt|;
name|q
operator|->
name|rspq
operator|.
name|gen
operator|=
literal|1
expr_stmt|;
name|q
operator|->
name|rspq
operator|.
name|cidx
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|rspq
operator|.
name|size
operator|=
name|p
operator|->
name|rspq_size
expr_stmt|;
name|q
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|stop_thres
operator|=
name|nports
operator|*
name|flits_to_desc
argument_list|(
name|sgl_len
argument_list|(
name|TX_MAX_SEGS
operator|+
literal|1
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|q
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|buf_size
operator|=
name|MCLBYTES
expr_stmt|;
name|q
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|zone
operator|=
name|zone_pack
expr_stmt|;
name|q
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|EXT_PACKET
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|jumbo_buf_size
operator|==
name|MJUM16BYTES
condition|)
block|{
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|zone
operator|=
name|zone_jumbo16
expr_stmt|;
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|EXT_JUMBO16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|jumbo_buf_size
operator|==
name|MJUM9BYTES
condition|)
block|{
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|zone
operator|=
name|zone_jumbo9
expr_stmt|;
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|EXT_JUMBO9
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|jumbo_buf_size
operator|==
name|MJUMPAGESIZE
condition|)
block|{
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|zone
operator|=
name|zone_jumbop
expr_stmt|;
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|EXT_JUMBOP
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
literal|0
argument_list|,
operator|(
literal|"can't deal with jumbo_buf_size %d."
operator|,
name|p
operator|->
name|jumbo_buf_size
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EDOOFUS
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|buf_size
operator|=
name|p
operator|->
name|jumbo_buf_size
expr_stmt|;
comment|/* Allocate and setup the lro_ctrl structure */
name|q
operator|->
name|lro
operator|.
name|enabled
operator|=
operator|!
operator|!
operator|(
name|pi
operator|->
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_LRO
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
name|ret
operator|=
name|tcp_lro_init
argument_list|(
operator|&
name|q
operator|->
name|lro
operator|.
name|ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|printf
argument_list|(
literal|"error %d from tcp_lro_init\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
endif|#
directive|endif
name|q
operator|->
name|lro
operator|.
name|ctrl
operator|.
name|ifp
operator|=
name|pi
operator|->
name|ifp
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|t3_sge_init_rspcntxt
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|rspq
operator|.
name|cntxt_id
argument_list|,
name|irq_vec_idx
argument_list|,
name|q
operator|->
name|rspq
operator|.
name|phys_addr
argument_list|,
name|q
operator|->
name|rspq
operator|.
name|size
argument_list|,
name|q
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|buf_size
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|printf
argument_list|(
literal|"error %d from t3_sge_init_rspcntxt\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
goto|goto
name|err_unlock
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SGE_RXQ_PER_SET
condition|;
operator|++
name|i
control|)
block|{
name|ret
operator|=
operator|-
name|t3_sge_init_flcntxt
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|cntxt_id
argument_list|,
literal|0
argument_list|,
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|phys_addr
argument_list|,
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|size
argument_list|,
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|buf_size
argument_list|,
name|p
operator|->
name|cong_thres
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|printf
argument_list|(
literal|"error %d from t3_sge_init_flcntxt for index i=%d\n"
argument_list|,
name|ret
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|err_unlock
goto|;
block|}
block|}
name|ret
operator|=
operator|-
name|t3_sge_init_ecntxt
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|cntxt_id
argument_list|,
name|USE_GTS
argument_list|,
name|SGE_CNTXT_ETH
argument_list|,
name|id
argument_list|,
name|q
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|phys_addr
argument_list|,
name|q
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|size
argument_list|,
name|q
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|token
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|printf
argument_list|(
literal|"error %d from t3_sge_init_ecntxt\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
goto|goto
name|err_unlock
goto|;
block|}
if|if
condition|(
name|ntxq
operator|>
literal|1
condition|)
block|{
name|ret
operator|=
operator|-
name|t3_sge_init_ecntxt
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
operator|.
name|cntxt_id
argument_list|,
name|USE_GTS
argument_list|,
name|SGE_CNTXT_OFLD
argument_list|,
name|id
argument_list|,
name|q
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
operator|.
name|phys_addr
argument_list|,
name|q
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
operator|.
name|size
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|printf
argument_list|(
literal|"error %d from t3_sge_init_ecntxt\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
goto|goto
name|err_unlock
goto|;
block|}
block|}
if|if
condition|(
name|ntxq
operator|>
literal|2
condition|)
block|{
name|ret
operator|=
operator|-
name|t3_sge_init_ecntxt
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
operator|.
name|cntxt_id
argument_list|,
literal|0
argument_list|,
name|SGE_CNTXT_CTRL
argument_list|,
name|id
argument_list|,
name|q
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
operator|.
name|phys_addr
argument_list|,
name|q
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
operator|.
name|size
argument_list|,
name|q
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
operator|.
name|token
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|printf
argument_list|(
literal|"error %d from t3_sge_init_ecntxt\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
goto|goto
name|err_unlock
goto|;
block|}
block|}
name|snprintf
argument_list|(
name|q
operator|->
name|rspq
operator|.
name|lockbuf
argument_list|,
name|RSPQ_NAME_LEN
argument_list|,
literal|"t3 rspq lock %d:%d"
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|irq_vec_idx
argument_list|)
expr_stmt|;
name|MTX_INIT
argument_list|(
operator|&
name|q
operator|->
name|rspq
operator|.
name|lock
argument_list|,
name|q
operator|->
name|rspq
operator|.
name|lockbuf
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
name|t3_update_qset_coalesce
argument_list|(
name|q
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|q
operator|->
name|port
operator|=
name|pi
expr_stmt|;
name|refill_fl
argument_list|(
name|sc
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
literal|0
index|]
argument_list|,
name|q
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
name|refill_fl
argument_list|(
name|sc
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
literal|1
index|]
argument_list|,
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
name|refill_rspq
argument_list|(
name|sc
argument_list|,
operator|&
name|q
operator|->
name|rspq
argument_list|,
name|q
operator|->
name|rspq
operator|.
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|A_SG_GTS
argument_list|,
name|V_RSPQ
argument_list|(
name|q
operator|->
name|rspq
operator|.
name|cntxt_id
argument_list|)
operator||
name|V_NEWTIMER
argument_list|(
name|q
operator|->
name|rspq
operator|.
name|holdoff_tmr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err_unlock
label|:
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
name|err
label|:
name|TXQ_LOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|t3_free_qset
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove CPL_RX_PKT headers from the mbuf and reduce it to a regular mbuf with  * ethernet data.  Hardware assistance with various checksums and any vlan tag  * will also be taken into account here.  */
end_comment

begin_function
name|void
name|t3_rx_eth
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|struct
name|sge_rspq
modifier|*
name|rq
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|ethpad
parameter_list|)
block|{
name|struct
name|cpl_rx_pkt
modifier|*
name|cpl
init|=
operator|(
expr|struct
name|cpl_rx_pkt
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|ethpad
operator|)
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
operator|&
name|adap
operator|->
name|port
index|[
name|adap
operator|->
name|rxpkt_map
index|[
name|cpl
operator|->
name|iff
index|]
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|pi
operator|->
name|ifp
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"rx_eth m=%p m->m_data=%p p->iff=%d\n"
argument_list|,
name|m
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
argument_list|,
name|cpl
operator|->
name|iff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
operator|)
operator|&&
operator|!
name|cpl
operator|->
name|fragment
operator|&&
name|cpl
operator|->
name|csum_valid
operator|&&
name|cpl
operator|->
name|csum
operator|==
literal|0xffff
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
operator|(
name|CSUM_IP_CHECKED
operator||
name|CSUM_IP_VALID
operator|)
expr_stmt|;
name|rspq_to_qset
argument_list|(
name|rq
argument_list|)
operator|->
name|port_stats
index|[
name|SGE_PSTAT_RX_CSUM_GOOD
index|]
operator|++
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
operator|(
name|CSUM_IP_CHECKED
operator||
name|CSUM_IP_VALID
operator||
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xffff
expr_stmt|;
block|}
if|if
condition|(
name|cpl
operator|->
name|vlan_valid
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|=
name|ntohs
argument_list|(
name|cpl
operator|->
name|vlan
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_VLANTAG
expr_stmt|;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|header
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|cpl
argument_list|)
operator|+
name|ethpad
expr_stmt|;
comment|/* 	 * adjust after conversion to mbuf chain 	 */
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|cpl
argument_list|)
operator|+
name|ethpad
operator|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|cpl
argument_list|)
operator|+
name|ethpad
operator|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|cpl
argument_list|)
operator|+
name|ethpad
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	get_packet - return the next ingress packet buffer from a free list  *	@adap: the adapter that received the packet  *	@drop_thres: # of remaining buffers before we start dropping packets  *	@qs: the qset that the SGE free list holding the packet belongs to  *      @mh: the mbuf header, contains a pointer to the head and tail of the mbuf chain  *      @r: response descriptor   *  *	Get the next packet from a free list and complete setup of the  *	sk_buff.  If the packet is small we make a copy and recycle the  *	original buffer, otherwise we use the original buffer itself.  If a  *	positive drop threshold is supplied packets are dropped and their  *	buffers recycled if (a) the number of remaining buffers is under the  *	threshold and the packet is too big to copy, or (b) the packet should  *	be copied but there is no memory for the copy.  */
end_comment

begin_function
specifier|static
name|int
name|get_packet
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|drop_thres
parameter_list|,
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|struct
name|t3_mbuf_hdr
modifier|*
name|mh
parameter_list|,
name|struct
name|rsp_desc
modifier|*
name|r
parameter_list|)
block|{
name|unsigned
name|int
name|len_cq
init|=
name|ntohl
argument_list|(
name|r
operator|->
name|len_cq
argument_list|)
decl_stmt|;
name|struct
name|sge_fl
modifier|*
name|fl
init|=
operator|(
name|len_cq
operator|&
name|F_RSPD_FLQ
operator|)
condition|?
operator|&
name|qs
operator|->
name|fl
index|[
literal|1
index|]
else|:
operator|&
name|qs
operator|->
name|fl
index|[
literal|0
index|]
decl_stmt|;
name|int
name|mask
decl_stmt|,
name|cidx
init|=
name|fl
operator|->
name|cidx
decl_stmt|;
name|struct
name|rx_sw_desc
modifier|*
name|sd
init|=
operator|&
name|fl
operator|->
name|sdesc
index|[
name|cidx
index|]
decl_stmt|;
name|uint32_t
name|len
init|=
name|G_RSPD_LEN
argument_list|(
name|len_cq
argument_list|)
decl_stmt|;
name|uint32_t
name|flags
init|=
name|M_EXT
decl_stmt|;
name|uint8_t
name|sopeop
init|=
name|G_RSPD_SOP_EOP
argument_list|(
name|ntohl
argument_list|(
name|r
operator|->
name|flags
argument_list|)
argument_list|)
decl_stmt|;
name|caddr_t
name|cl
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|mask
operator|=
name|fl
operator|->
name|size
operator|-
literal|1
expr_stmt|;
name|prefetch
argument_list|(
name|fl
operator|->
name|sdesc
index|[
operator|(
name|cidx
operator|+
literal|1
operator|)
operator|&
name|mask
index|]
operator|.
name|m
argument_list|)
expr_stmt|;
name|prefetch
argument_list|(
name|fl
operator|->
name|sdesc
index|[
operator|(
name|cidx
operator|+
literal|2
operator|)
operator|&
name|mask
index|]
operator|.
name|m
argument_list|)
expr_stmt|;
name|prefetch
argument_list|(
name|fl
operator|->
name|sdesc
index|[
operator|(
name|cidx
operator|+
literal|1
operator|)
operator|&
name|mask
index|]
operator|.
name|rxsd_cl
argument_list|)
expr_stmt|;
name|prefetch
argument_list|(
name|fl
operator|->
name|sdesc
index|[
operator|(
name|cidx
operator|+
literal|2
operator|)
operator|&
name|mask
index|]
operator|.
name|rxsd_cl
argument_list|)
expr_stmt|;
name|fl
operator|->
name|credits
operator|--
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|fl
operator|->
name|entry_tag
argument_list|,
name|sd
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|recycle_enable
operator|&&
name|len
operator|<=
name|SGE_RX_COPY_THRES
operator|&&
name|sopeop
operator|==
name|RSPQ_SOP_EOP
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|skip_recycle
goto|;
name|cl
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cl
argument_list|,
name|sd
operator|->
name|rxsd_cl
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|recycle_rx_buf
argument_list|(
name|adap
argument_list|,
name|fl
argument_list|,
name|fl
operator|->
name|cidx
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_flags
operator|=
literal|0
expr_stmt|;
name|mh
operator|->
name|mh_head
operator|=
name|mh
operator|->
name|mh_tail
operator|=
name|m
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
else|else
block|{
name|skip_recycle
label|:
name|bus_dmamap_unload
argument_list|(
name|fl
operator|->
name|entry_tag
argument_list|,
name|sd
operator|->
name|map
argument_list|)
expr_stmt|;
name|cl
operator|=
name|sd
operator|->
name|rxsd_cl
expr_stmt|;
name|m
operator|=
name|sd
operator|->
name|m
expr_stmt|;
if|if
condition|(
operator|(
name|sopeop
operator|==
name|RSPQ_SOP_EOP
operator|)
operator|||
operator|(
name|sopeop
operator|==
name|RSPQ_SOP
operator|)
condition|)
name|flags
operator||=
name|M_PKTHDR
expr_stmt|;
name|m_init
argument_list|(
name|m
argument_list|,
name|fl
operator|->
name|zone
argument_list|,
name|fl
operator|->
name|buf_size
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|fl
operator|->
name|zone
operator|==
name|zone_pack
condition|)
block|{
comment|/* 			 * restore clobbered data pointer 			 */
name|m
operator|->
name|m_data
operator|=
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
expr_stmt|;
block|}
else|else
block|{
name|m_cljset
argument_list|(
name|m
argument_list|,
name|cl
argument_list|,
name|fl
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
block|}
switch|switch
condition|(
name|sopeop
condition|)
block|{
case|case
name|RSPQ_SOP_EOP
case|:
name|ret
operator|=
literal|1
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|RSPQ_SOP
case|:
name|mh
operator|->
name|mh_head
operator|=
name|mh
operator|->
name|mh_tail
operator|=
name|m
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
break|break;
case|case
name|RSPQ_EOP
case|:
name|ret
operator|=
literal|1
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|RSPQ_NSOP_NEOP
case|:
if|if
condition|(
name|mh
operator|->
name|mh_tail
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"discarding intermediate descriptor entry\n"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
name|mh
operator|->
name|mh_tail
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|mh
operator|->
name|mh_tail
operator|=
name|m
expr_stmt|;
name|mh
operator|->
name|mh_head
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|len
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cxgb_debug
condition|)
name|printf
argument_list|(
literal|"len=%d pktlen=%d\n"
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
operator|++
name|fl
operator|->
name|cidx
operator|==
name|fl
operator|->
name|size
condition|)
name|fl
operator|->
name|cidx
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	handle_rsp_cntrl_info - handles control information in a response  *	@qs: the queue set corresponding to the response  *	@flags: the response control flags  *  *	Handles the control information of an SGE response, such as GTS  *	indications and completion credits for the queue set's Tx queues.  *	HW coalesces credits, we don't do any extra SW coalescing.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|handle_rsp_cntrl_info
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|unsigned
name|int
name|credits
decl_stmt|;
if|#
directive|if
name|USE_GTS
if|if
condition|(
name|flags
operator|&
name|F_RSPD_TXQ0_GTS
condition|)
name|clear_bit
argument_list|(
name|TXQ_RUNNING
argument_list|,
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|credits
operator|=
name|G_RSPD_TXQ0_CR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|credits
condition|)
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|processed
operator|+=
name|credits
expr_stmt|;
name|credits
operator|=
name|G_RSPD_TXQ2_CR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|credits
condition|)
name|qs
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
operator|.
name|processed
operator|+=
name|credits
expr_stmt|;
if|#
directive|if
name|USE_GTS
if|if
condition|(
name|flags
operator|&
name|F_RSPD_TXQ1_GTS
condition|)
name|clear_bit
argument_list|(
name|TXQ_RUNNING
argument_list|,
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
operator|.
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|credits
operator|=
name|G_RSPD_TXQ1_CR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|credits
condition|)
name|qs
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
operator|.
name|processed
operator|+=
name|credits
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_ring_db
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|unsigned
name|int
name|sleeping
parameter_list|)
block|{
empty_stmt|;
block|}
end_function

begin_comment
comment|/**  *	process_responses - process responses from an SGE response queue  *	@adap: the adapter  *	@qs: the queue set to which the response queue belongs  *	@budget: how many responses can be processed in this round  *  *	Process responses from an SGE response queue up to the supplied budget.  *	Responses include received packets as well as credits and other events  *	for the queues that belong to the response queue's queue set.  *	A negative budget is effectively unlimited.  *  *	Additionally choose the interrupt holdoff time for the next interrupt  *	on this queue.  If the system is under memory shortage use a fairly  *	long delay to help recovery.  */
end_comment

begin_function
specifier|static
name|int
name|process_responses
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|int
name|budget
parameter_list|)
block|{
name|struct
name|sge_rspq
modifier|*
name|rspq
init|=
operator|&
name|qs
operator|->
name|rspq
decl_stmt|;
name|struct
name|rsp_desc
modifier|*
name|r
init|=
operator|&
name|rspq
operator|->
name|desc
index|[
name|rspq
operator|->
name|cidx
index|]
decl_stmt|;
name|int
name|budget_left
init|=
name|budget
decl_stmt|;
name|unsigned
name|int
name|sleeping
init|=
literal|0
decl_stmt|;
name|int
name|lro_enabled
init|=
name|qs
operator|->
name|lro
operator|.
name|enabled
decl_stmt|;
name|int
name|skip_lro
decl_stmt|;
name|struct
name|lro_ctrl
modifier|*
name|lro_ctrl
init|=
operator|&
name|qs
operator|->
name|lro
operator|.
name|ctrl
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|offload_mbufs
index|[
name|RX_BUNDLE_SIZE
index|]
decl_stmt|;
name|int
name|ngathered
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
specifier|static
name|int
name|last_holdoff
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cxgb_debug
operator|&&
name|rspq
operator|->
name|holdoff_tmr
operator|!=
name|last_holdoff
condition|)
block|{
name|printf
argument_list|(
literal|"next_holdoff=%d\n"
argument_list|,
name|rspq
operator|->
name|holdoff_tmr
argument_list|)
expr_stmt|;
name|last_holdoff
operator|=
name|rspq
operator|->
name|holdoff_tmr
expr_stmt|;
block|}
endif|#
directive|endif
name|rspq
operator|->
name|next_holdoff
operator|=
name|rspq
operator|->
name|holdoff_tmr
expr_stmt|;
while|while
condition|(
name|__predict_true
argument_list|(
name|budget_left
operator|&&
name|is_new_response
argument_list|(
name|r
argument_list|,
name|rspq
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|eth
decl_stmt|,
name|eop
init|=
literal|0
decl_stmt|,
name|ethpad
init|=
literal|0
decl_stmt|;
name|uint32_t
name|flags
init|=
name|ntohl
argument_list|(
name|r
operator|->
name|flags
argument_list|)
decl_stmt|;
name|uint32_t
name|rss_csum
init|=
operator|*
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|r
decl_stmt|;
name|uint32_t
name|rss_hash
init|=
name|be32toh
argument_list|(
name|r
operator|->
name|rss_hdr
operator|.
name|rss_hash_val
argument_list|)
decl_stmt|;
name|eth
operator|=
operator|(
name|r
operator|->
name|rss_hdr
operator|.
name|opcode
operator|==
name|CPL_RX_PKT
operator|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|flags
operator|&
name|F_RSPD_ASYNC_NOTIF
argument_list|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|cxgb_debug
condition|)
name|printf
argument_list|(
literal|"async notification\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rspq
operator|->
name|rspq_mh
operator|.
name|mh_head
operator|==
name|NULL
condition|)
block|{
name|rspq
operator|->
name|rspq_mh
operator|.
name|mh_head
operator|=
name|m_gethdr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|m
operator|=
name|rspq
operator|->
name|rspq_mh
operator|.
name|mh_head
expr_stmt|;
block|}
else|else
block|{
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|no_mem
goto|;
name|memcpy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
argument_list|,
name|r
argument_list|,
name|AN_PKT_SIZE
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|AN_PKT_SIZE
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
operator|=
name|CPL_ASYNC_NOTIF
expr_stmt|;
name|rss_csum
operator|=
name|htonl
argument_list|(
name|CPL_ASYNC_NOTIF
operator|<<
literal|24
argument_list|)
expr_stmt|;
name|eop
operator|=
literal|1
expr_stmt|;
name|rspq
operator|->
name|async_notif
operator|++
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|F_RSPD_IMM_DATA_VALID
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"IMM DATA VALID opcode=0x%x rspq->cidx=%d\n"
argument_list|,
name|r
operator|->
name|rss_hdr
operator|.
name|opcode
argument_list|,
name|rspq
operator|->
name|cidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|rspq
operator|->
name|rspq_mh
operator|.
name|mh_head
operator|==
name|NULL
condition|)
name|rspq
operator|->
name|rspq_mh
operator|.
name|mh_head
operator|=
name|m_gethdr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
else|else
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|rspq
operator|->
name|rspq_mh
operator|.
name|mh_head
operator|==
name|NULL
operator|&&
name|m
operator|==
name|NULL
condition|)
block|{
name|no_mem
label|:
name|rspq
operator|->
name|next_holdoff
operator|=
name|NOMEM_INTR_DELAY
expr_stmt|;
name|budget_left
operator|--
expr_stmt|;
break|break;
block|}
name|get_imm_packet
argument_list|(
name|adap
argument_list|,
name|r
argument_list|,
name|rspq
operator|->
name|rspq_mh
operator|.
name|mh_head
argument_list|)
expr_stmt|;
name|eop
operator|=
literal|1
expr_stmt|;
name|rspq
operator|->
name|imm_data
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|->
name|len_cq
condition|)
block|{
name|int
name|drop_thresh
init|=
name|eth
condition|?
name|SGE_RX_DROP_THRES
else|:
literal|0
decl_stmt|;
name|eop
operator|=
name|get_packet
argument_list|(
name|adap
argument_list|,
name|drop_thresh
argument_list|,
name|qs
argument_list|,
operator|&
name|rspq
operator|->
name|rspq_mh
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|eop
condition|)
block|{
name|rspq
operator|->
name|rspq_mh
operator|.
name|mh_head
operator|->
name|m_flags
operator||=
name|M_FLOWID
expr_stmt|;
name|rspq
operator|->
name|rspq_mh
operator|.
name|mh_head
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
name|rss_hash
expr_stmt|;
block|}
name|ethpad
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|rspq
operator|->
name|pure_rsps
operator|++
expr_stmt|;
block|}
name|skip
label|:
if|if
condition|(
name|flags
operator|&
name|RSPD_CTRL_MASK
condition|)
block|{
name|sleeping
operator||=
name|flags
operator|&
name|RSPD_GTS_MASK
expr_stmt|;
name|handle_rsp_cntrl_info
argument_list|(
name|qs
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|r
operator|++
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|++
name|rspq
operator|->
name|cidx
operator|==
name|rspq
operator|->
name|size
argument_list|)
condition|)
block|{
name|rspq
operator|->
name|cidx
operator|=
literal|0
expr_stmt|;
name|rspq
operator|->
name|gen
operator|^=
literal|1
expr_stmt|;
name|r
operator|=
name|rspq
operator|->
name|desc
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|rspq
operator|->
name|credits
operator|>=
operator|(
name|rspq
operator|->
name|size
operator|/
literal|4
operator|)
condition|)
block|{
name|refill_rspq
argument_list|(
name|adap
argument_list|,
name|rspq
argument_list|,
name|rspq
operator|->
name|credits
argument_list|)
expr_stmt|;
name|rspq
operator|->
name|credits
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|eth
operator|&&
name|eop
condition|)
block|{
name|rspq
operator|->
name|rspq_mh
operator|.
name|mh_head
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
name|rss_csum
expr_stmt|;
comment|/* 			 * XXX size mismatch 			 */
name|m_set_priority
argument_list|(
name|rspq
operator|->
name|rspq_mh
operator|.
name|mh_head
argument_list|,
name|rss_hash
argument_list|)
expr_stmt|;
name|ngathered
operator|=
name|rx_offload
argument_list|(
operator|&
name|adap
operator|->
name|tdev
argument_list|,
name|rspq
argument_list|,
name|rspq
operator|->
name|rspq_mh
operator|.
name|mh_head
argument_list|,
name|offload_mbufs
argument_list|,
name|ngathered
argument_list|)
expr_stmt|;
name|rspq
operator|->
name|rspq_mh
operator|.
name|mh_head
operator|=
name|NULL
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"received offload packet\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eth
operator|&&
name|eop
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|rspq
operator|->
name|rspq_mh
operator|.
name|mh_head
decl_stmt|;
name|t3_rx_eth
argument_list|(
name|adap
argument_list|,
name|rspq
argument_list|,
name|m
argument_list|,
name|ethpad
argument_list|)
expr_stmt|;
comment|/* 			 * The T304 sends incoming packets on any qset.  If LRO 			 * is also enabled, we could end up sending packet up 			 * lro_ctrl->ifp's input.  That is incorrect. 			 * 			 * The mbuf's rcvif was derived from the cpl header and 			 * is accurate.  Skip LRO and just use that. 			 */
name|skip_lro
operator|=
name|__predict_false
argument_list|(
name|qs
operator|->
name|port
operator|->
name|ifp
operator|!=
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|)
expr_stmt|;
if|if
condition|(
name|lro_enabled
operator|&&
name|lro_ctrl
operator|->
name|lro_cnt
operator|&&
operator|!
name|skip_lro
ifdef|#
directive|ifdef
name|INET
operator|&&
operator|(
name|tcp_lro_rx
argument_list|(
name|lro_ctrl
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|)
endif|#
directive|endif
condition|)
block|{
comment|/* successfully queue'd for LRO */
block|}
else|else
block|{
comment|/* 				 * LRO not enabled, packet unsuitable for LRO, 				 * or unable to queue.  Pass it up right now in 				 * either case. 				 */
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
decl_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|rspq
operator|->
name|rspq_mh
operator|.
name|mh_head
operator|=
name|NULL
expr_stmt|;
block|}
name|__refill_fl_lt
argument_list|(
name|adap
argument_list|,
operator|&
name|qs
operator|->
name|fl
index|[
literal|0
index|]
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|__refill_fl_lt
argument_list|(
name|adap
argument_list|,
operator|&
name|qs
operator|->
name|fl
index|[
literal|1
index|]
argument_list|,
literal|32
argument_list|)
expr_stmt|;
operator|--
name|budget_left
expr_stmt|;
block|}
name|deliver_partial_bundle
argument_list|(
operator|&
name|adap
operator|->
name|tdev
argument_list|,
name|rspq
argument_list|,
name|offload_mbufs
argument_list|,
name|ngathered
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
comment|/* Flush LRO */
while|while
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|lro_ctrl
operator|->
name|lro_active
argument_list|)
condition|)
block|{
name|struct
name|lro_entry
modifier|*
name|queued
init|=
name|SLIST_FIRST
argument_list|(
operator|&
name|lro_ctrl
operator|->
name|lro_active
argument_list|)
decl_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|lro_ctrl
operator|->
name|lro_active
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|tcp_lro_flush
argument_list|(
name|lro_ctrl
argument_list|,
name|queued
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|sleeping
condition|)
name|check_ring_db
argument_list|(
name|adap
argument_list|,
name|qs
argument_list|,
name|sleeping
argument_list|)
expr_stmt|;
name|mb
argument_list|()
expr_stmt|;
comment|/* commit Tx queue processed updates */
if|if
condition|(
name|__predict_false
argument_list|(
name|qs
operator|->
name|txq_stopped
operator|>
literal|1
argument_list|)
condition|)
name|restart_tx
argument_list|(
name|qs
argument_list|)
expr_stmt|;
name|__refill_fl_lt
argument_list|(
name|adap
argument_list|,
operator|&
name|qs
operator|->
name|fl
index|[
literal|0
index|]
argument_list|,
literal|512
argument_list|)
expr_stmt|;
name|__refill_fl_lt
argument_list|(
name|adap
argument_list|,
operator|&
name|qs
operator|->
name|fl
index|[
literal|1
index|]
argument_list|,
literal|512
argument_list|)
expr_stmt|;
name|budget
operator|-=
name|budget_left
expr_stmt|;
return|return
operator|(
name|budget
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * A helper function that processes responses and issues GTS.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|process_responses_gts
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|struct
name|sge_rspq
modifier|*
name|rq
parameter_list|)
block|{
name|int
name|work
decl_stmt|;
specifier|static
name|int
name|last_holdoff
init|=
literal|0
decl_stmt|;
name|work
operator|=
name|process_responses
argument_list|(
name|adap
argument_list|,
name|rspq_to_qset
argument_list|(
name|rq
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cxgb_debug
operator|&&
operator|(
name|rq
operator|->
name|next_holdoff
operator|!=
name|last_holdoff
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"next_holdoff=%d\n"
argument_list|,
name|rq
operator|->
name|next_holdoff
argument_list|)
expr_stmt|;
name|last_holdoff
operator|=
name|rq
operator|->
name|next_holdoff
expr_stmt|;
block|}
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_GTS
argument_list|,
name|V_RSPQ
argument_list|(
name|rq
operator|->
name|cntxt_id
argument_list|)
operator||
name|V_NEWTIMER
argument_list|(
name|rq
operator|->
name|next_holdoff
argument_list|)
operator||
name|V_NEWINDEX
argument_list|(
name|rq
operator|->
name|cidx
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|work
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Interrupt handler for legacy INTx interrupts for T3B-based cards.  * Handles data events from SGE response queues as well as error and other  * async events as they all use the same interrupt pin.  We use one SGE  * response queue per port in this mode and protect all response queues with  * queue 0's lock.  */
end_comment

begin_function
name|void
name|t3b_intr
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|,
name|map
decl_stmt|;
name|adapter_t
modifier|*
name|adap
init|=
name|data
decl_stmt|;
name|struct
name|sge_rspq
modifier|*
name|q0
init|=
operator|&
name|adap
operator|->
name|sge
operator|.
name|qs
index|[
literal|0
index|]
operator|.
name|rspq
decl_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_PL_CLI
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|map
operator|=
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_DATA_INTR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|map
condition|)
return|return;
if|if
condition|(
name|__predict_false
argument_list|(
name|map
operator|&
name|F_ERRINTR
argument_list|)
condition|)
name|taskqueue_enqueue
argument_list|(
name|adap
operator|->
name|tq
argument_list|,
operator|&
name|adap
operator|->
name|slow_intr_task
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|q0
operator|->
name|lock
argument_list|)
expr_stmt|;
name|for_each_port
argument_list|(
argument|adap
argument_list|,
argument|i
argument_list|)
if|if
condition|(
name|map
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|process_responses_gts
argument_list|(
name|adap
argument_list|,
operator|&
name|adap
operator|->
name|sge
operator|.
name|qs
index|[
name|i
index|]
operator|.
name|rspq
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|q0
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The MSI interrupt handler.  This needs to handle data events from SGE  * response queues as well as error and other async events as they all use  * the same MSI vector.  We use one SGE response queue per port in this mode  * and protect all response queues with queue 0's lock.  */
end_comment

begin_function
name|void
name|t3_intr_msi
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|adapter_t
modifier|*
name|adap
init|=
name|data
decl_stmt|;
name|struct
name|sge_rspq
modifier|*
name|q0
init|=
operator|&
name|adap
operator|->
name|sge
operator|.
name|qs
index|[
literal|0
index|]
operator|.
name|rspq
decl_stmt|;
name|int
name|i
decl_stmt|,
name|new_packets
init|=
literal|0
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|q0
operator|->
name|lock
argument_list|)
expr_stmt|;
name|for_each_port
argument_list|(
argument|adap
argument_list|,
argument|i
argument_list|)
if|if
condition|(
name|process_responses_gts
argument_list|(
name|adap
argument_list|,
operator|&
name|adap
operator|->
name|sge
operator|.
name|qs
index|[
name|i
index|]
operator|.
name|rspq
argument_list|)
condition|)
name|new_packets
operator|=
literal|1
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|q0
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_packets
operator|==
literal|0
condition|)
name|taskqueue_enqueue
argument_list|(
name|adap
operator|->
name|tq
argument_list|,
operator|&
name|adap
operator|->
name|slow_intr_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t3_intr_msix
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|sge_qset
modifier|*
name|qs
init|=
name|data
decl_stmt|;
name|adapter_t
modifier|*
name|adap
init|=
name|qs
operator|->
name|port
operator|->
name|adapter
decl_stmt|;
name|struct
name|sge_rspq
modifier|*
name|rspq
init|=
operator|&
name|qs
operator|->
name|rspq
decl_stmt|;
if|if
condition|(
name|process_responses_gts
argument_list|(
name|adap
argument_list|,
name|rspq
argument_list|)
operator|==
literal|0
condition|)
name|rspq
operator|->
name|unhandled_irqs
operator|++
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|QDUMP_SBUF_SIZE
value|32 * 400
end_define

begin_function
specifier|static
name|int
name|t3_dump_rspq
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|sge_rspq
modifier|*
name|rspq
decl_stmt|;
name|struct
name|sge_qset
modifier|*
name|qs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|err
decl_stmt|,
name|dump_end
decl_stmt|,
name|idx
decl_stmt|;
specifier|static
name|int
name|multiplier
init|=
literal|1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|struct
name|rsp_desc
modifier|*
name|rspd
decl_stmt|;
name|uint32_t
name|data
index|[
literal|4
index|]
decl_stmt|;
name|rspq
operator|=
name|arg1
expr_stmt|;
name|qs
operator|=
name|rspq_to_qset
argument_list|(
name|rspq
argument_list|)
expr_stmt|;
if|if
condition|(
name|rspq
operator|->
name|rspq_dump_count
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|rspq
operator|->
name|rspq_dump_count
operator|>
name|RSPQ_Q_SIZE
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"dump count is too large %d\n"
argument_list|,
name|rspq
operator|->
name|rspq_dump_count
argument_list|)
expr_stmt|;
name|rspq
operator|->
name|rspq_dump_count
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|rspq
operator|->
name|rspq_dump_start
operator|>
operator|(
name|RSPQ_Q_SIZE
operator|-
literal|1
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"dump start of %d is greater than queue size\n"
argument_list|,
name|rspq
operator|->
name|rspq_dump_start
argument_list|)
expr_stmt|;
name|rspq
operator|->
name|rspq_dump_start
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|err
operator|=
name|t3_sge_read_rspq
argument_list|(
name|qs
operator|->
name|port
operator|->
name|adapter
argument_list|,
name|rspq
operator|->
name|cntxt_id
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|retry_sbufops
label|:
name|sb
operator|=
name|sbuf_new
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|QDUMP_SBUF_SIZE
operator|*
name|multiplier
argument_list|,
name|SBUF_FIXEDLEN
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" \n index=%u size=%u MSI-X/RspQ=%u intr enable=%u intr armed=%u\n"
argument_list|,
operator|(
name|data
index|[
literal|0
index|]
operator|&
literal|0xffff
operator|)
argument_list|,
name|data
index|[
literal|0
index|]
operator|>>
literal|16
argument_list|,
operator|(
operator|(
name|data
index|[
literal|2
index|]
operator|>>
literal|20
operator|)
operator|&
literal|0x3f
operator|)
argument_list|,
operator|(
operator|(
name|data
index|[
literal|2
index|]
operator|>>
literal|26
operator|)
operator|&
literal|1
operator|)
argument_list|,
operator|(
operator|(
name|data
index|[
literal|2
index|]
operator|>>
literal|27
operator|)
operator|&
literal|1
operator|)
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" generation=%u CQ mode=%u FL threshold=%u\n"
argument_list|,
operator|(
operator|(
name|data
index|[
literal|2
index|]
operator|>>
literal|28
operator|)
operator|&
literal|1
operator|)
argument_list|,
operator|(
operator|(
name|data
index|[
literal|2
index|]
operator|>>
literal|31
operator|)
operator|&
literal|1
operator|)
argument_list|,
name|data
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" start=%d -> end=%d\n"
argument_list|,
name|rspq
operator|->
name|rspq_dump_start
argument_list|,
operator|(
name|rspq
operator|->
name|rspq_dump_start
operator|+
name|rspq
operator|->
name|rspq_dump_count
operator|)
operator|&
operator|(
name|RSPQ_Q_SIZE
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|dump_end
operator|=
name|rspq
operator|->
name|rspq_dump_start
operator|+
name|rspq
operator|->
name|rspq_dump_count
expr_stmt|;
for|for
control|(
name|i
operator|=
name|rspq
operator|->
name|rspq_dump_start
init|;
name|i
operator|<
name|dump_end
condition|;
name|i
operator|++
control|)
block|{
name|idx
operator|=
name|i
operator|&
operator|(
name|RSPQ_Q_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|rspd
operator|=
operator|&
name|rspq
operator|->
name|desc
index|[
name|idx
index|]
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\tidx=%04d opcode=%02x cpu_idx=%x hash_type=%x cq_idx=%x\n"
argument_list|,
name|idx
argument_list|,
name|rspd
operator|->
name|rss_hdr
operator|.
name|opcode
argument_list|,
name|rspd
operator|->
name|rss_hdr
operator|.
name|cpu_idx
argument_list|,
name|rspd
operator|->
name|rss_hdr
operator|.
name|hash_type
argument_list|,
name|be16toh
argument_list|(
name|rspd
operator|->
name|rss_hdr
operator|.
name|cq_idx
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\trss_hash_val=%x flags=%08x len_cq=%x intr_gen=%x\n"
argument_list|,
name|rspd
operator|->
name|rss_hdr
operator|.
name|rss_hash_val
argument_list|,
name|be32toh
argument_list|(
name|rspd
operator|->
name|flags
argument_list|)
argument_list|,
name|be32toh
argument_list|(
name|rspd
operator|->
name|len_cq
argument_list|)
argument_list|,
name|rspd
operator|->
name|intr_gen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sbuf_overflowed
argument_list|(
name|sb
argument_list|)
condition|)
block|{
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|multiplier
operator|++
expr_stmt|;
goto|goto
name|retry_sbufops
goto|;
block|}
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|err
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|sbuf_data
argument_list|(
name|sb
argument_list|)
argument_list|,
name|sbuf_len
argument_list|(
name|sb
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|t3_dump_txq_eth
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
name|struct
name|sge_qset
modifier|*
name|qs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|err
decl_stmt|,
name|dump_end
decl_stmt|;
specifier|static
name|int
name|multiplier
init|=
literal|1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|struct
name|tx_desc
modifier|*
name|txd
decl_stmt|;
name|uint32_t
modifier|*
name|WR
decl_stmt|,
name|wr_hi
decl_stmt|,
name|wr_lo
decl_stmt|,
name|gen
decl_stmt|;
name|uint32_t
name|data
index|[
literal|4
index|]
decl_stmt|;
name|txq
operator|=
name|arg1
expr_stmt|;
name|qs
operator|=
name|txq_to_qset
argument_list|(
name|txq
argument_list|,
name|TXQ_ETH
argument_list|)
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|txq_dump_count
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|txq
operator|->
name|txq_dump_count
operator|>
name|TX_ETH_Q_SIZE
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"dump count is too large %d\n"
argument_list|,
name|txq
operator|->
name|txq_dump_count
argument_list|)
expr_stmt|;
name|txq
operator|->
name|txq_dump_count
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|txq
operator|->
name|txq_dump_start
operator|>
operator|(
name|TX_ETH_Q_SIZE
operator|-
literal|1
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"dump start of %d is greater than queue size\n"
argument_list|,
name|txq
operator|->
name|txq_dump_start
argument_list|)
expr_stmt|;
name|txq
operator|->
name|txq_dump_start
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|err
operator|=
name|t3_sge_read_ecntxt
argument_list|(
name|qs
operator|->
name|port
operator|->
name|adapter
argument_list|,
name|qs
operator|->
name|rspq
operator|.
name|cntxt_id
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|retry_sbufops
label|:
name|sb
operator|=
name|sbuf_new
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|QDUMP_SBUF_SIZE
operator|*
name|multiplier
argument_list|,
name|SBUF_FIXEDLEN
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" \n credits=%u GTS=%u index=%u size=%u rspq#=%u cmdq#=%u\n"
argument_list|,
operator|(
name|data
index|[
literal|0
index|]
operator|&
literal|0x7fff
operator|)
argument_list|,
operator|(
operator|(
name|data
index|[
literal|0
index|]
operator|>>
literal|15
operator|)
operator|&
literal|1
operator|)
argument_list|,
operator|(
name|data
index|[
literal|0
index|]
operator|>>
literal|16
operator|)
argument_list|,
operator|(
name|data
index|[
literal|1
index|]
operator|&
literal|0xffff
operator|)
argument_list|,
operator|(
operator|(
name|data
index|[
literal|3
index|]
operator|>>
literal|4
operator|)
operator|&
literal|7
operator|)
argument_list|,
operator|(
operator|(
name|data
index|[
literal|3
index|]
operator|>>
literal|7
operator|)
operator|&
literal|1
operator|)
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" TUN=%u TOE=%u generation%u uP token=%u valid=%u\n"
argument_list|,
operator|(
operator|(
name|data
index|[
literal|3
index|]
operator|>>
literal|8
operator|)
operator|&
literal|1
operator|)
argument_list|,
operator|(
operator|(
name|data
index|[
literal|3
index|]
operator|>>
literal|9
operator|)
operator|&
literal|1
operator|)
argument_list|,
operator|(
operator|(
name|data
index|[
literal|3
index|]
operator|>>
literal|10
operator|)
operator|&
literal|1
operator|)
argument_list|,
operator|(
operator|(
name|data
index|[
literal|3
index|]
operator|>>
literal|11
operator|)
operator|&
literal|0xfffff
operator|)
argument_list|,
operator|(
operator|(
name|data
index|[
literal|3
index|]
operator|>>
literal|31
operator|)
operator|&
literal|1
operator|)
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" qid=%d start=%d -> end=%d\n"
argument_list|,
name|qs
operator|->
name|idx
argument_list|,
name|txq
operator|->
name|txq_dump_start
argument_list|,
operator|(
name|txq
operator|->
name|txq_dump_start
operator|+
name|txq
operator|->
name|txq_dump_count
operator|)
operator|&
operator|(
name|TX_ETH_Q_SIZE
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|dump_end
operator|=
name|txq
operator|->
name|txq_dump_start
operator|+
name|txq
operator|->
name|txq_dump_count
expr_stmt|;
for|for
control|(
name|i
operator|=
name|txq
operator|->
name|txq_dump_start
init|;
name|i
operator|<
name|dump_end
condition|;
name|i
operator|++
control|)
block|{
name|txd
operator|=
operator|&
name|txq
operator|->
name|desc
index|[
name|i
operator|&
operator|(
name|TX_ETH_Q_SIZE
operator|-
literal|1
operator|)
index|]
expr_stmt|;
name|WR
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|txd
operator|->
name|flit
expr_stmt|;
name|wr_hi
operator|=
name|ntohl
argument_list|(
name|WR
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|wr_lo
operator|=
name|ntohl
argument_list|(
name|WR
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|gen
operator|=
name|G_WR_GEN
argument_list|(
name|wr_lo
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" wr_hi %08x wr_lo %08x gen %d\n"
argument_list|,
name|wr_hi
argument_list|,
name|wr_lo
argument_list|,
name|gen
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|2
init|;
name|j
operator|<
literal|30
condition|;
name|j
operator|+=
literal|4
control|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\t%08x %08x %08x %08x \n"
argument_list|,
name|WR
index|[
name|j
index|]
argument_list|,
name|WR
index|[
name|j
operator|+
literal|1
index|]
argument_list|,
name|WR
index|[
name|j
operator|+
literal|2
index|]
argument_list|,
name|WR
index|[
name|j
operator|+
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sbuf_overflowed
argument_list|(
name|sb
argument_list|)
condition|)
block|{
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|multiplier
operator|++
expr_stmt|;
goto|goto
name|retry_sbufops
goto|;
block|}
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|err
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|sbuf_data
argument_list|(
name|sb
argument_list|)
argument_list|,
name|sbuf_len
argument_list|(
name|sb
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|t3_dump_txq_ctrl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
name|struct
name|sge_qset
modifier|*
name|qs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|err
decl_stmt|,
name|dump_end
decl_stmt|;
specifier|static
name|int
name|multiplier
init|=
literal|1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|struct
name|tx_desc
modifier|*
name|txd
decl_stmt|;
name|uint32_t
modifier|*
name|WR
decl_stmt|,
name|wr_hi
decl_stmt|,
name|wr_lo
decl_stmt|,
name|gen
decl_stmt|;
name|txq
operator|=
name|arg1
expr_stmt|;
name|qs
operator|=
name|txq_to_qset
argument_list|(
name|txq
argument_list|,
name|TXQ_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|txq_dump_count
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|txq
operator|->
name|txq_dump_count
operator|>
literal|256
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"dump count is too large %d\n"
argument_list|,
name|txq
operator|->
name|txq_dump_count
argument_list|)
expr_stmt|;
name|txq
operator|->
name|txq_dump_count
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|txq
operator|->
name|txq_dump_start
operator|>
literal|255
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"dump start of %d is greater than queue size\n"
argument_list|,
name|txq
operator|->
name|txq_dump_start
argument_list|)
expr_stmt|;
name|txq
operator|->
name|txq_dump_start
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|retry_sbufops
label|:
name|sb
operator|=
name|sbuf_new
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|QDUMP_SBUF_SIZE
operator|*
name|multiplier
argument_list|,
name|SBUF_FIXEDLEN
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" qid=%d start=%d -> end=%d\n"
argument_list|,
name|qs
operator|->
name|idx
argument_list|,
name|txq
operator|->
name|txq_dump_start
argument_list|,
operator|(
name|txq
operator|->
name|txq_dump_start
operator|+
name|txq
operator|->
name|txq_dump_count
operator|)
operator|&
literal|255
argument_list|)
expr_stmt|;
name|dump_end
operator|=
name|txq
operator|->
name|txq_dump_start
operator|+
name|txq
operator|->
name|txq_dump_count
expr_stmt|;
for|for
control|(
name|i
operator|=
name|txq
operator|->
name|txq_dump_start
init|;
name|i
operator|<
name|dump_end
condition|;
name|i
operator|++
control|)
block|{
name|txd
operator|=
operator|&
name|txq
operator|->
name|desc
index|[
name|i
operator|&
operator|(
literal|255
operator|)
index|]
expr_stmt|;
name|WR
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|txd
operator|->
name|flit
expr_stmt|;
name|wr_hi
operator|=
name|ntohl
argument_list|(
name|WR
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|wr_lo
operator|=
name|ntohl
argument_list|(
name|WR
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|gen
operator|=
name|G_WR_GEN
argument_list|(
name|wr_lo
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" wr_hi %08x wr_lo %08x gen %d\n"
argument_list|,
name|wr_hi
argument_list|,
name|wr_lo
argument_list|,
name|gen
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|2
init|;
name|j
operator|<
literal|30
condition|;
name|j
operator|+=
literal|4
control|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\t%08x %08x %08x %08x \n"
argument_list|,
name|WR
index|[
name|j
index|]
argument_list|,
name|WR
index|[
name|j
operator|+
literal|1
index|]
argument_list|,
name|WR
index|[
name|j
operator|+
literal|2
index|]
argument_list|,
name|WR
index|[
name|j
operator|+
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sbuf_overflowed
argument_list|(
name|sb
argument_list|)
condition|)
block|{
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|multiplier
operator|++
expr_stmt|;
goto|goto
name|retry_sbufops
goto|;
block|}
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|err
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|sbuf_data
argument_list|(
name|sb
argument_list|)
argument_list|,
name|sbuf_len
argument_list|(
name|sb
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|t3_set_coalesce_usecs
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|adapter_t
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|qset_params
modifier|*
name|qsp
init|=
operator|&
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|qset
index|[
literal|0
index|]
decl_stmt|;
name|int
name|coalesce_usecs
decl_stmt|;
name|struct
name|sge_qset
modifier|*
name|qs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|err
decl_stmt|,
name|nqsets
init|=
literal|0
decl_stmt|;
name|struct
name|mtx
modifier|*
name|lock
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|coalesce_usecs
operator|=
name|qsp
operator|->
name|coalesce_usecs
expr_stmt|;
name|err
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|coalesce_usecs
argument_list|,
name|arg2
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|coalesce_usecs
operator|==
name|qsp
operator|->
name|coalesce_usecs
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|params
operator|.
name|nports
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sc
operator|->
name|port
index|[
name|i
index|]
operator|.
name|nqsets
condition|;
name|j
operator|++
control|)
name|nqsets
operator|++
expr_stmt|;
name|coalesce_usecs
operator|=
name|max
argument_list|(
literal|1
argument_list|,
name|coalesce_usecs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nqsets
condition|;
name|i
operator|++
control|)
block|{
name|qs
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
name|i
index|]
expr_stmt|;
name|qsp
operator|=
operator|&
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|qset
index|[
name|i
index|]
expr_stmt|;
name|qsp
operator|->
name|coalesce_usecs
operator|=
name|coalesce_usecs
expr_stmt|;
name|lock
operator|=
operator|(
name|sc
operator|->
name|flags
operator|&
name|USING_MSIX
operator|)
condition|?
operator|&
name|qs
operator|->
name|rspq
operator|.
name|lock
else|:
operator|&
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
literal|0
index|]
operator|.
name|rspq
operator|.
name|lock
expr_stmt|;
name|mtx_lock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|t3_update_qset_coalesce
argument_list|(
name|qs
argument_list|,
name|qsp
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|A_SG_GTS
argument_list|,
name|V_RSPQ
argument_list|(
name|qs
operator|->
name|rspq
operator|.
name|cntxt_id
argument_list|)
operator||
name|V_NEWTIMER
argument_list|(
name|qs
operator|->
name|rspq
operator|.
name|holdoff_tmr
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|t3_add_attach_sysctls
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|children
decl_stmt|;
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* random information */
name|SYSCTL_ADD_STRING
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"firmware_version"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|fw_version
argument_list|,
literal|0
argument_list|,
literal|"firmware version"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"hw_revision"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|params
operator|.
name|rev
argument_list|,
literal|0
argument_list|,
literal|"chip model"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_STRING
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"port_types"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|port_types
argument_list|,
literal|0
argument_list|,
literal|"type of ports"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"enable_debug"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|cxgb_debug
argument_list|,
literal|0
argument_list|,
literal|"enable verbose debugging output"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tunq_coalesce"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|tunq_coalesce
argument_list|,
literal|"#tunneled packets freed"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txq_overrun"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq_fills
argument_list|,
literal|0
argument_list|,
literal|"#times txq overrun"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|rspq_name
init|=
literal|"rspq"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|txq_names
index|[]
init|=
block|{
literal|"txq_eth"
block|,
literal|"txq_ofld"
block|,
literal|"txq_ctrl"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|sysctl_handle_macstat
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|p
init|=
name|arg1
decl_stmt|;
name|uint64_t
modifier|*
name|parg
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|parg
operator|=
operator|(
name|uint64_t
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|p
operator|->
name|mac
operator|.
name|stats
operator|+
name|arg2
operator|)
expr_stmt|;
name|PORT_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|t3_mac_update_stats
argument_list|(
operator|&
name|p
operator|->
name|mac
argument_list|)
expr_stmt|;
name|PORT_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|sysctl_handle_quad
argument_list|(
name|oidp
argument_list|,
name|parg
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|t3_add_configured_sysctls
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|children
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"intr_coal"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|t3_set_coalesce_usecs
argument_list|,
literal|"I"
argument_list|,
literal|"interrupt coalescing timer (us)"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|params
operator|.
name|nports
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
operator|&
name|sc
operator|->
name|port
index|[
name|i
index|]
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|poid
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|poidlist
decl_stmt|;
name|struct
name|mac_stats
modifier|*
name|mstats
init|=
operator|&
name|pi
operator|->
name|mac
operator|.
name|stats
decl_stmt|;
name|snprintf
argument_list|(
name|pi
operator|->
name|namebuf
argument_list|,
name|PORT_NAME_LEN
argument_list|,
literal|"port%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|poid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
name|pi
operator|->
name|namebuf
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"port statistics"
argument_list|)
expr_stmt|;
name|poidlist
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|poid
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|poidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"nqsets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pi
operator|->
name|nqsets
argument_list|,
literal|0
argument_list|,
literal|"#queue sets"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pi
operator|->
name|nqsets
condition|;
name|j
operator|++
control|)
block|{
name|struct
name|sge_qset
modifier|*
name|qs
init|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
name|pi
operator|->
name|first_qset
operator|+
name|j
index|]
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|qspoid
decl_stmt|,
modifier|*
name|rspqpoid
decl_stmt|,
modifier|*
name|txqpoid
decl_stmt|,
modifier|*
name|ctrlqpoid
decl_stmt|,
modifier|*
name|lropoid
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|qspoidlist
decl_stmt|,
modifier|*
name|rspqpoidlist
decl_stmt|,
modifier|*
name|txqpoidlist
decl_stmt|,
modifier|*
name|ctrlqpoidlist
decl_stmt|,
modifier|*
name|lropoidlist
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
init|=
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|qs
operator|->
name|namebuf
argument_list|,
name|QS_NAME_LEN
argument_list|,
literal|"qs%d"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|qspoid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|poidlist
argument_list|,
name|OID_AUTO
argument_list|,
name|qs
operator|->
name|namebuf
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"qset statistics"
argument_list|)
expr_stmt|;
name|qspoidlist
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|qspoid
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|qspoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fl0_empty"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|qs
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|empty
argument_list|,
literal|0
argument_list|,
literal|"freelist #0 empty"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|qspoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fl1_empty"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|qs
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|empty
argument_list|,
literal|0
argument_list|,
literal|"freelist #1 empty"
argument_list|)
expr_stmt|;
name|rspqpoid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|qspoidlist
argument_list|,
name|OID_AUTO
argument_list|,
name|rspq_name
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"rspq statistics"
argument_list|)
expr_stmt|;
name|rspqpoidlist
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|rspqpoid
argument_list|)
expr_stmt|;
name|txqpoid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|qspoidlist
argument_list|,
name|OID_AUTO
argument_list|,
name|txq_names
index|[
literal|0
index|]
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"txq statistics"
argument_list|)
expr_stmt|;
name|txqpoidlist
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|txqpoid
argument_list|)
expr_stmt|;
name|ctrlqpoid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|qspoidlist
argument_list|,
name|OID_AUTO
argument_list|,
name|txq_names
index|[
literal|2
index|]
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"ctrlq statistics"
argument_list|)
expr_stmt|;
name|ctrlqpoidlist
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|ctrlqpoid
argument_list|)
expr_stmt|;
name|lropoid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|qspoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lro_stats"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"LRO statistics"
argument_list|)
expr_stmt|;
name|lropoidlist
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|lropoid
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|rspqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"size"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|qs
operator|->
name|rspq
operator|.
name|size
argument_list|,
literal|0
argument_list|,
literal|"#entries in response queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|rspqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cidx"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|qs
operator|->
name|rspq
operator|.
name|cidx
argument_list|,
literal|0
argument_list|,
literal|"consumer index"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|rspqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"credits"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|qs
operator|->
name|rspq
operator|.
name|credits
argument_list|,
literal|0
argument_list|,
literal|"#credits"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_XLONG
argument_list|(
name|ctx
argument_list|,
name|rspqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"phys_addr"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|qs
operator|->
name|rspq
operator|.
name|phys_addr
argument_list|,
literal|"physical_address_of the queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|rspqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dump_start"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|qs
operator|->
name|rspq
operator|.
name|rspq_dump_start
argument_list|,
literal|0
argument_list|,
literal|"start rspq dump entry"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|rspqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dump_count"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|qs
operator|->
name|rspq
operator|.
name|rspq_dump_count
argument_list|,
literal|0
argument_list|,
literal|"#rspq entries to dump"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|rspqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"qdump"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|qs
operator|->
name|rspq
argument_list|,
literal|0
argument_list|,
name|t3_dump_rspq
argument_list|,
literal|"A"
argument_list|,
literal|"dump of the response queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|txqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dropped"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|txq_mr
operator|->
name|br_drops
argument_list|,
literal|"#tunneled packets dropped"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|txqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"sendqlen"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|sendq
operator|.
name|qlen
argument_list|,
literal|0
argument_list|,
literal|"#tunneled packets waiting to be sent"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|SYSCTL_ADD_UINT(ctx, txqpoidlist, OID_AUTO, "queue_pidx", 			    CTLFLAG_RD, (uint32_t *)(uintptr_t)&qs->txq[TXQ_ETH].txq_mr.br_prod, 			    0, "#tunneled packets queue producer index"); 			SYSCTL_ADD_UINT(ctx, txqpoidlist, OID_AUTO, "queue_cidx", 			    CTLFLAG_RD, (uint32_t *)(uintptr_t)&qs->txq[TXQ_ETH].txq_mr.br_cons, 			    0, "#tunneled packets queue consumer index");
endif|#
directive|endif
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|txqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"processed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|processed
argument_list|,
literal|0
argument_list|,
literal|"#tunneled packets processed by the card"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|txqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cleaned"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|cleaned
argument_list|,
literal|0
argument_list|,
literal|"#tunneled packets cleaned"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|txqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"in_use"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|in_use
argument_list|,
literal|0
argument_list|,
literal|"#tunneled packet slots in use"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|txqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"frees"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|txq_frees
argument_list|,
literal|"#tunneled packets freed"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|txqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"skipped"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|txq_skipped
argument_list|,
literal|0
argument_list|,
literal|"#tunneled packet descriptors skipped"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx
argument_list|,
name|txqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"coalesced"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|txq_coalesced
argument_list|,
literal|"#tunneled packets coalesced"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|txqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"enqueued"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|txq_enqueued
argument_list|,
literal|0
argument_list|,
literal|"#tunneled packets enqueued to hardware"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|txqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stopped_flags"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|qs
operator|->
name|txq_stopped
argument_list|,
literal|0
argument_list|,
literal|"tx queues stopped"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_XLONG
argument_list|(
name|ctx
argument_list|,
name|txqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"phys_addr"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|phys_addr
argument_list|,
literal|"physical_address_of the queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|txqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"qgen"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|gen
argument_list|,
literal|0
argument_list|,
literal|"txq generation"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|txqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"hw_cidx"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|cidx
argument_list|,
literal|0
argument_list|,
literal|"hardware queue cidx"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|txqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"hw_pidx"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|pidx
argument_list|,
literal|0
argument_list|,
literal|"hardware queue pidx"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|txqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dump_start"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|txq_dump_start
argument_list|,
literal|0
argument_list|,
literal|"txq start idx for dump"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|txqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dump_count"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|txq_dump_count
argument_list|,
literal|0
argument_list|,
literal|"txq #entries to dump"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|txqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"qdump"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
argument_list|,
literal|0
argument_list|,
name|t3_dump_txq_eth
argument_list|,
literal|"A"
argument_list|,
literal|"dump of the transmit queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|ctrlqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dump_start"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
operator|.
name|txq_dump_start
argument_list|,
literal|0
argument_list|,
literal|"ctrlq start idx for dump"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|ctrlqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dump_count"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
operator|.
name|txq_dump_count
argument_list|,
literal|0
argument_list|,
literal|"ctrl #entries to dump"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|ctrlqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"qdump"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
argument_list|,
literal|0
argument_list|,
name|t3_dump_txq_ctrl
argument_list|,
literal|"A"
argument_list|,
literal|"dump of the transmit queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|lropoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lro_queued"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|qs
operator|->
name|lro
operator|.
name|ctrl
operator|.
name|lro_queued
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|lropoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lro_flushed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|qs
operator|->
name|lro
operator|.
name|ctrl
operator|.
name|lro_flushed
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|lropoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lro_bad_csum"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|qs
operator|->
name|lro
operator|.
name|ctrl
operator|.
name|lro_bad_csum
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|lropoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lro_cnt"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|qs
operator|->
name|lro
operator|.
name|ctrl
operator|.
name|lro_cnt
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Now add a node for mac stats. */
name|poid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|poidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mac_stats"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"MAC statistics"
argument_list|)
expr_stmt|;
name|poidlist
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|poid
argument_list|)
expr_stmt|;
comment|/* 		 * We (ab)use the length argument (arg2) to pass on the offset 		 * of the data that we are interested in.  This is only required 		 * for the quad counters that are updated from the hardware (we 		 * make sure that we return the latest value). 		 * sysctl_handle_macstat first updates *all* the counters from 		 * the hardware, and then returns the latest value of the 		 * requested counter.  Best would be to update only the 		 * requested counter from hardware, but t3_mac_update_stats() 		 * hides all the register details and we don't want to dive into 		 * all that here. 		 */
define|#
directive|define
name|CXGB_SYSCTL_ADD_QUAD
parameter_list|(
name|a
parameter_list|)
value|SYSCTL_ADD_OID(ctx, poidlist, OID_AUTO, #a, \     (CTLTYPE_QUAD | CTLFLAG_RD), pi, offsetof(struct mac_stats, a), \     sysctl_handle_macstat, "QU", 0)
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|tx_octets
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|tx_octets_bad
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|tx_frames
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|tx_mcast_frames
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|tx_bcast_frames
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|tx_pause
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|tx_deferred
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|tx_late_collisions
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|tx_total_collisions
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|tx_excess_collisions
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|tx_underrun
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|tx_len_errs
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|tx_mac_internal_errs
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|tx_excess_deferral
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|tx_fcs_errs
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|tx_frames_64
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|tx_frames_65_127
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|tx_frames_128_255
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|tx_frames_256_511
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|tx_frames_512_1023
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|tx_frames_1024_1518
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|tx_frames_1519_max
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|rx_octets
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|rx_octets_bad
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|rx_frames
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|rx_mcast_frames
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|rx_bcast_frames
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|rx_pause
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|rx_fcs_errs
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|rx_align_errs
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|rx_symbol_errs
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|rx_data_errs
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|rx_sequence_errs
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|rx_runt
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|rx_jabber
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|rx_short
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|rx_too_long
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|rx_mac_internal_errs
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|rx_cong_drops
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|rx_frames_64
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|rx_frames_65_127
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|rx_frames_128_255
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|rx_frames_256_511
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|rx_frames_512_1023
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|rx_frames_1024_1518
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_QUAD
argument_list|(
name|rx_frames_1519_max
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|CXGB_SYSCTL_ADD_QUAD
define|#
directive|define
name|CXGB_SYSCTL_ADD_ULONG
parameter_list|(
name|a
parameter_list|)
value|SYSCTL_ADD_ULONG(ctx, poidlist, OID_AUTO, #a, \     CTLFLAG_RD,&mstats->a, 0)
name|CXGB_SYSCTL_ADD_ULONG
argument_list|(
name|tx_fifo_parity_err
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_ULONG
argument_list|(
name|rx_fifo_parity_err
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_ULONG
argument_list|(
name|tx_fifo_urun
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_ULONG
argument_list|(
name|rx_fifo_ovfl
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_ULONG
argument_list|(
name|serdes_signal_loss
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_ULONG
argument_list|(
name|xaui_pcs_ctc_err
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_ULONG
argument_list|(
name|xaui_pcs_align_change
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_ULONG
argument_list|(
name|num_toggled
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_ULONG
argument_list|(
name|num_resets
argument_list|)
expr_stmt|;
name|CXGB_SYSCTL_ADD_ULONG
argument_list|(
name|link_faults
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|CXGB_SYSCTL_ADD_ULONG
block|}
block|}
end_function

begin_comment
comment|/**  *	t3_get_desc - dump an SGE descriptor for debugging purposes  *	@qs: the queue set  *	@qnum: identifies the specific queue (0..2: Tx, 3:response, 4..5: Rx)  *	@idx: the descriptor index in the queue  *	@data: where to dump the descriptor contents  *  *	Dumps the contents of a HW descriptor of an SGE queue.  Returns the  *	size of the descriptor.  */
end_comment

begin_function
name|int
name|t3_get_desc
parameter_list|(
specifier|const
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|unsigned
name|int
name|qnum
parameter_list|,
name|unsigned
name|int
name|idx
parameter_list|,
name|unsigned
name|char
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|qnum
operator|>=
literal|6
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|qnum
operator|<
literal|3
condition|)
block|{
if|if
condition|(
operator|!
name|qs
operator|->
name|txq
index|[
name|qnum
index|]
operator|.
name|desc
operator|||
name|idx
operator|>=
name|qs
operator|->
name|txq
index|[
name|qnum
index|]
operator|.
name|size
condition|)
return|return
operator|-
name|EINVAL
return|;
name|memcpy
argument_list|(
name|data
argument_list|,
operator|&
name|qs
operator|->
name|txq
index|[
name|qnum
index|]
operator|.
name|desc
index|[
name|idx
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tx_desc
argument_list|)
argument_list|)
expr_stmt|;
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|tx_desc
argument_list|)
return|;
block|}
if|if
condition|(
name|qnum
operator|==
literal|3
condition|)
block|{
if|if
condition|(
operator|!
name|qs
operator|->
name|rspq
operator|.
name|desc
operator|||
name|idx
operator|>=
name|qs
operator|->
name|rspq
operator|.
name|size
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|memcpy
argument_list|(
name|data
argument_list|,
operator|&
name|qs
operator|->
name|rspq
operator|.
name|desc
index|[
name|idx
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rsp_desc
argument_list|)
argument_list|)
expr_stmt|;
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|rsp_desc
argument_list|)
return|;
block|}
name|qnum
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
operator|!
name|qs
operator|->
name|fl
index|[
name|qnum
index|]
operator|.
name|desc
operator|||
name|idx
operator|>=
name|qs
operator|->
name|fl
index|[
name|qnum
index|]
operator|.
name|size
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|memcpy
argument_list|(
name|data
argument_list|,
operator|&
name|qs
operator|->
name|fl
index|[
name|qnum
index|]
operator|.
name|desc
index|[
name|idx
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rx_desc
argument_list|)
argument_list|)
expr_stmt|;
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|rx_desc
argument_list|)
return|;
block|}
end_function

end_unit

