begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************************  Copyright (c) 2007, Chelsio Inc. All rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:   1. Redistributions of source code must retain the above copyright notice,     this list of conditions and the following disclaimer.   2. Neither the name of the Chelsio Corporation nor the names of its     contributors may be used to endorse or promote products derived from     this software without specific prior written permission.   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus_dma.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_DEFINED
end_ifdef

begin_include
include|#
directive|include
file|<cxgb_include.h>
end_include

begin_include
include|#
directive|include
file|<sys/mvec.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<dev/cxgb/cxgb_include.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/sys/mvec.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|txq_fills
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bogus_imm
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|recycle_enable
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|cxgb_txq_buf_ring_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cxgb_cached_allocations
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cxgb_cached
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cxgb_ext_freed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|cxgb_use_16k_clusters
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|USE_GTS
value|0
end_define

begin_define
define|#
directive|define
name|SGE_RX_SM_BUF_SIZE
value|1536
end_define

begin_define
define|#
directive|define
name|SGE_RX_DROP_THRES
value|16
end_define

begin_define
define|#
directive|define
name|SGE_RX_COPY_THRES
value|128
end_define

begin_comment
comment|/*  * Period of the Tx buffer reclaim timer.  This timer does not need to run  * frequently as Tx buffers are usually reclaimed by new Tx packets.  */
end_comment

begin_define
define|#
directive|define
name|TX_RECLAIM_PERIOD
value|(hz>> 1)
end_define

begin_comment
comment|/*   * work request size in bytes  */
end_comment

begin_define
define|#
directive|define
name|WR_LEN
value|(WR_FLITS * 8)
end_define

begin_comment
comment|/*   * Values for sge_txq.flags  */
end_comment

begin_enum
enum|enum
block|{
name|TXQ_RUNNING
init|=
literal|1
operator|<<
literal|0
block|,
comment|/* fetch engine is running */
name|TXQ_LAST_PKT_DB
init|=
literal|1
operator|<<
literal|1
block|,
comment|/* last packet rang the doorbell */
block|}
enum|;
end_enum

begin_struct
struct|struct
name|tx_desc
block|{
name|uint64_t
name|flit
index|[
name|TX_DESC_FLITS
index|]
decl_stmt|;
block|}
name|__packed
struct|;
end_struct

begin_struct
struct|struct
name|rx_desc
block|{
name|uint32_t
name|addr_lo
decl_stmt|;
name|uint32_t
name|len_gen
decl_stmt|;
name|uint32_t
name|gen2
decl_stmt|;
name|uint32_t
name|addr_hi
decl_stmt|;
block|}
name|__packed
struct|;
end_struct

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_struct
struct|struct
name|rsp_desc
block|{
comment|/* response queue descriptor */
name|struct
name|rss_header
name|rss_hdr
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|uint32_t
name|len_cq
decl_stmt|;
name|uint8_t
name|imm_data
index|[
literal|47
index|]
decl_stmt|;
name|uint8_t
name|intr_gen
decl_stmt|;
block|}
name|__packed
struct|;
end_struct

begin_define
define|#
directive|define
name|RX_SW_DESC_MAP_CREATED
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|TX_SW_DESC_MAP_CREATED
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|RX_SW_DESC_INUSE
value|(1<< 3)
end_define

begin_define
define|#
directive|define
name|TX_SW_DESC_MAPPED
value|(1<< 4)
end_define

begin_define
define|#
directive|define
name|RSPQ_NSOP_NEOP
value|G_RSPD_SOP_EOP(0)
end_define

begin_define
define|#
directive|define
name|RSPQ_EOP
value|G_RSPD_SOP_EOP(F_RSPD_EOP)
end_define

begin_define
define|#
directive|define
name|RSPQ_SOP
value|G_RSPD_SOP_EOP(F_RSPD_SOP)
end_define

begin_define
define|#
directive|define
name|RSPQ_SOP_EOP
value|G_RSPD_SOP_EOP(F_RSPD_SOP|F_RSPD_EOP)
end_define

begin_struct
struct|struct
name|tx_sw_desc
block|{
comment|/* SW state per Tx descriptor */
name|struct
name|mbuf_iovec
name|mi
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|rx_sw_desc
block|{
comment|/* SW state per Rx descriptor */
name|caddr_t
name|rxsd_cl
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|txq_state
block|{
name|unsigned
name|int
name|compl
decl_stmt|;
name|unsigned
name|int
name|gen
decl_stmt|;
name|unsigned
name|int
name|pidx
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|refill_fl_cb_arg
block|{
name|int
name|error
decl_stmt|;
name|bus_dma_segment_t
name|seg
decl_stmt|;
name|int
name|nseg
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Maps a number of flits to the number of Tx descriptors that can hold them.  * The formula is  *  * desc = 1 + (flits - 2) / (WR_FLITS - 1).  *  * HW allows up to 4 descriptors to be combined into a WR.  */
end_comment

begin_decl_stmt
specifier|static
name|uint8_t
name|flit_desc_map
index|[]
init|=
block|{
literal|0
block|,
if|#
directive|if
name|SGE_NUM_GENBITS
operator|==
literal|1
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
elif|#
directive|elif
name|SGE_NUM_GENBITS
operator|==
literal|2
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
else|#
directive|else
error|#
directive|error
literal|"SGE_NUM_GENBITS must be 1 or 2"
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lro_default
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cxgb_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|sge_timer_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sge_timer_reclaim
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|ncount
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sge_txq_reclaim_handler
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|ncount
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  *	reclaim_completed_tx - reclaims completed Tx descriptors  *	@adapter: the adapter  *	@q: the Tx queue to reclaim completed descriptors from  *  *	Reclaims Tx descriptors that the SGE has indicated it has processed,  *	and frees the associated buffers if possible.  Called with the Tx  *	queue's lock held.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|reclaim_completed_tx_
parameter_list|(
name|struct
name|sge_txq
modifier|*
name|q
parameter_list|,
name|int
name|reclaim_min
parameter_list|)
block|{
name|int
name|reclaim
init|=
name|desc_reclaimable
argument_list|(
name|q
argument_list|)
decl_stmt|;
if|if
condition|(
name|reclaim
operator|<
name|reclaim_min
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|mtx_assert
argument_list|(
operator|&
name|q
operator|->
name|lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|reclaim
operator|>
literal|0
condition|)
block|{
name|t3_free_tx_desc
argument_list|(
name|q
argument_list|,
name|reclaim
argument_list|)
expr_stmt|;
name|q
operator|->
name|cleaned
operator|+=
name|reclaim
expr_stmt|;
name|q
operator|->
name|in_use
operator|-=
name|reclaim
expr_stmt|;
block|}
return|return
operator|(
name|reclaim
operator|)
return|;
block|}
end_function

begin_function
name|int
name|reclaim_completed_tx
parameter_list|(
name|struct
name|sge_txq
modifier|*
name|q
parameter_list|,
name|int
name|reclaim_min
parameter_list|)
block|{
return|return
name|reclaim_completed_tx_
argument_list|(
name|q
argument_list|,
name|reclaim_min
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	should_restart_tx - are there enough resources to restart a Tx queue?  *	@q: the Tx queue  *  *	Checks if there are enough descriptors to restart a suspended Tx queue.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|should_restart_tx
parameter_list|(
specifier|const
name|struct
name|sge_txq
modifier|*
name|q
parameter_list|)
block|{
name|unsigned
name|int
name|r
init|=
name|q
operator|->
name|processed
operator|-
name|q
operator|->
name|cleaned
decl_stmt|;
return|return
name|q
operator|->
name|in_use
operator|-
name|r
operator|<
operator|(
name|q
operator|->
name|size
operator|>>
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_sge_init - initialize SGE  *	@adap: the adapter  *	@p: the SGE parameters  *  *	Performs SGE initialization needed every time after a chip reset.  *	We do not initialize any of the queue sets here, instead the driver  *	top-level must request those individually.  We also do not enable DMA  *	here, that should be done after the queues have been set up.  */
end_comment

begin_function
name|void
name|t3_sge_init
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|struct
name|sge_params
modifier|*
name|p
parameter_list|)
block|{
name|u_int
name|ctrl
decl_stmt|,
name|ups
decl_stmt|;
name|ups
operator|=
literal|0
expr_stmt|;
comment|/* = ffs(pci_resource_len(adap->pdev, 2)>> 12); */
name|ctrl
operator|=
name|F_DROPPKT
operator||
name|V_PKTSHIFT
argument_list|(
literal|2
argument_list|)
operator||
name|F_FLMODE
operator||
name|F_AVOIDCQOVFL
operator||
name|F_CQCRDTCTRL
operator||
name|V_HOSTPAGESIZE
argument_list|(
name|PAGE_SHIFT
operator|-
literal|11
argument_list|)
operator||
name|F_BIGENDIANINGRESS
operator||
name|V_USERSPACESIZE
argument_list|(
name|ups
condition|?
name|ups
operator|-
literal|1
else|:
literal|0
argument_list|)
operator||
name|F_ISCSICOALESCING
expr_stmt|;
if|#
directive|if
name|SGE_NUM_GENBITS
operator|==
literal|1
name|ctrl
operator||=
name|F_EGRGENCTRL
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|adap
operator|->
name|params
operator|.
name|rev
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|adap
operator|->
name|flags
operator|&
operator|(
name|USING_MSIX
operator||
name|USING_MSI
operator|)
operator|)
condition|)
name|ctrl
operator||=
name|F_ONEINTMULTQ
operator||
name|F_OPTONEINTMULTQ
expr_stmt|;
name|ctrl
operator||=
name|F_CQCRDTCTRL
operator||
name|F_AVOIDCQOVFL
expr_stmt|;
block|}
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_CONTROL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_EGR_RCQ_DRB_THRSH
argument_list|,
name|V_HIRCQDRBTHRSH
argument_list|(
literal|512
argument_list|)
operator||
name|V_LORCQDRBTHRSH
argument_list|(
literal|512
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_TIMER_TICK
argument_list|,
name|core_ticks_per_usec
argument_list|(
name|adap
argument_list|)
operator|/
literal|10
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_CMDQ_CREDIT_TH
argument_list|,
name|V_THRESHOLD
argument_list|(
literal|32
argument_list|)
operator||
name|V_TIMEOUT
argument_list|(
literal|200
operator|*
name|core_ticks_per_usec
argument_list|(
name|adap
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_HI_DRB_HI_THRSH
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_HI_DRB_LO_THRSH
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_LO_DRB_HI_THRSH
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_LO_DRB_LO_THRSH
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_OCO_BASE
argument_list|,
name|V_BASE1
argument_list|(
literal|0xfff
argument_list|)
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_DRB_PRI_THRESH
argument_list|,
literal|63
operator|*
literal|1024
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	sgl_len - calculates the size of an SGL of the given capacity  *	@n: the number of SGL entries  *  *	Calculates the number of flits needed for a scatter/gather list that  *	can hold the given number of entries.  */
end_comment

begin_function
specifier|static
name|__inline
name|unsigned
name|int
name|sgl_len
parameter_list|(
name|unsigned
name|int
name|n
parameter_list|)
block|{
return|return
operator|(
operator|(
literal|3
operator|*
name|n
operator|)
operator|/
literal|2
operator|+
operator|(
name|n
operator|&
literal|1
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	get_imm_packet - return the next ingress packet buffer from a response  *	@resp: the response descriptor containing the packet data  *  *	Return a packet containing the immediate data of the given response.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DISABLE_MBUF_IOVEC
end_ifdef

begin_function
specifier|static
name|__inline
name|int
name|get_imm_packet
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|rsp_desc
modifier|*
name|resp
parameter_list|,
name|struct
name|t3_mbuf_hdr
modifier|*
name|mh
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|mh
operator|->
name|m_head
decl_stmt|;
name|memcpy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
argument_list|,
name|resp
operator|->
name|imm_data
argument_list|,
name|IMMED_PKT_SIZE
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|int
name|get_imm_packet
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|rsp_desc
modifier|*
name|resp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|void
modifier|*
name|cl
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|IMMED_PKT_SIZE
expr_stmt|;
name|memcpy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
argument_list|,
name|resp
operator|->
name|imm_data
argument_list|,
name|IMMED_PKT_SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|__inline
name|u_int
name|flits_to_desc
parameter_list|(
name|u_int
name|n
parameter_list|)
block|{
return|return
operator|(
name|flit_desc_map
index|[
name|n
index|]
operator|)
return|;
block|}
end_function

begin_function
name|void
name|t3_sge_err_intr_handler
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
name|unsigned
name|int
name|v
decl_stmt|,
name|status
decl_stmt|;
name|status
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_INT_CAUSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|F_RSPQCREDITOVERFOW
condition|)
name|CH_ALERT
argument_list|(
name|adapter
argument_list|,
literal|"SGE response queue credit overflow\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|F_RSPQDISABLED
condition|)
block|{
name|v
operator|=
name|t3_read_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_RSPQ_FL_STATUS
argument_list|)
expr_stmt|;
name|CH_ALERT
argument_list|(
name|adapter
argument_list|,
literal|"packet delivered to disabled response queue (0x%x)\n"
argument_list|,
operator|(
name|v
operator|>>
name|S_RSPQ0DISABLED
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_SG_INT_CAUSE
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
operator|(
name|F_RSPQCREDITOVERFOW
operator||
name|F_RSPQDISABLED
operator|)
condition|)
name|t3_fatal_err
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t3_sge_prep
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|struct
name|sge_params
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* XXX Does ETHER_ALIGN need to be accounted for here? */
name|p
operator|->
name|max_pkt_size
operator|=
name|adap
operator|->
name|sge
operator|.
name|qs
index|[
literal|0
index|]
operator|.
name|fl
index|[
literal|1
index|]
operator|.
name|buf_size
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|cpl_rx_data
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SGE_QSETS
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|qset_params
modifier|*
name|q
init|=
name|p
operator|->
name|qset
operator|+
name|i
decl_stmt|;
name|q
operator|->
name|polling
operator|=
name|adap
operator|->
name|params
operator|.
name|rev
operator|>
literal|0
expr_stmt|;
if|if
condition|(
name|adap
operator|->
name|params
operator|.
name|nports
operator|>
literal|2
condition|)
block|{
name|q
operator|->
name|coalesce_nsecs
operator|=
literal|50000
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|q
operator|->
name|coalesce_nsecs
operator|=
literal|10000
expr_stmt|;
else|#
directive|else
name|q
operator|->
name|coalesce_nsecs
operator|=
literal|5000
expr_stmt|;
endif|#
directive|endif
block|}
name|q
operator|->
name|rspq_size
operator|=
name|RSPQ_Q_SIZE
expr_stmt|;
name|q
operator|->
name|fl_size
operator|=
name|FL_Q_SIZE
expr_stmt|;
name|q
operator|->
name|jumbo_size
operator|=
name|JUMBO_Q_SIZE
expr_stmt|;
name|q
operator|->
name|txq_size
index|[
name|TXQ_ETH
index|]
operator|=
name|TX_ETH_Q_SIZE
expr_stmt|;
name|q
operator|->
name|txq_size
index|[
name|TXQ_OFLD
index|]
operator|=
literal|1024
expr_stmt|;
name|q
operator|->
name|txq_size
index|[
name|TXQ_CTRL
index|]
operator|=
literal|256
expr_stmt|;
name|q
operator|->
name|cong_thres
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|t3_sge_alloc
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|)
block|{
comment|/* The parent tag. */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* maxsize */
name|BUS_SPACE_UNRESTRICTED
argument_list|,
comment|/* nsegments */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lock, lockarg */
operator|&
name|sc
operator|->
name|parent_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot allocate parent DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* 	 * DMA tag for normal sized RX frames 	 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_dmat
argument_list|,
name|MCLBYTES
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MCLBYTES
argument_list|,
literal|1
argument_list|,
name|MCLBYTES
argument_list|,
name|BUS_DMA_ALLOCNOW
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|rx_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot allocate RX DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/*  	 * DMA tag for jumbo sized RX frames. 	 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_dmat
argument_list|,
name|MJUM16BYTES
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MJUM16BYTES
argument_list|,
literal|1
argument_list|,
name|MJUM16BYTES
argument_list|,
name|BUS_DMA_ALLOCNOW
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|rx_jumbo_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot allocate RX jumbo DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/*  	 * DMA tag for TX frames. 	 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_dmat
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|TX_MAX_SIZE
argument_list|,
name|TX_MAX_SEGS
argument_list|,
name|TX_MAX_SIZE
argument_list|,
name|BUS_DMA_ALLOCNOW
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|tx_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot allocate TX DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t3_sge_free
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|tx_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|tx_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rx_jumbo_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|rx_jumbo_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rx_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|rx_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|parent_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|t3_update_qset_coalesce
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
specifier|const
name|struct
name|qset_params
modifier|*
name|p
parameter_list|)
block|{
name|qs
operator|->
name|rspq
operator|.
name|holdoff_tmr
operator|=
name|max
argument_list|(
name|p
operator|->
name|coalesce_nsecs
operator|/
literal|100
argument_list|,
literal|1U
argument_list|)
expr_stmt|;
name|qs
operator|->
name|rspq
operator|.
name|polling
operator|=
literal|0
comment|/* p->polling */
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__amd64__
argument_list|)
end_if

begin_function
specifier|static
name|void
name|refill_fl_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|refill_fl_cb_arg
modifier|*
name|cb_arg
init|=
name|arg
decl_stmt|;
name|cb_arg
operator|->
name|error
operator|=
name|error
expr_stmt|;
name|cb_arg
operator|->
name|seg
operator|=
name|segs
index|[
literal|0
index|]
expr_stmt|;
name|cb_arg
operator|->
name|nseg
operator|=
name|nseg
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  *	refill_fl - refill an SGE free-buffer list  *	@sc: the controller softc  *	@q: the free-list to refill  *	@n: the number of new buffers to allocate  *  *	(Re)populate an SGE free-buffer list with up to @n new packet buffers.  *	The caller must assure that @n does not exceed the queue's capacity.  */
end_comment

begin_function
specifier|static
name|void
name|refill_fl
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_fl
modifier|*
name|q
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|struct
name|rx_sw_desc
modifier|*
name|sd
init|=
operator|&
name|q
operator|->
name|sdesc
index|[
name|q
operator|->
name|pidx
index|]
decl_stmt|;
name|struct
name|rx_desc
modifier|*
name|d
init|=
operator|&
name|q
operator|->
name|desc
index|[
name|q
operator|->
name|pidx
index|]
decl_stmt|;
name|struct
name|refill_fl_cb_arg
name|cb_arg
decl_stmt|;
name|caddr_t
name|cl
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|header_size
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|m_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pkthdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|m_ext_
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
decl_stmt|;
name|cb_arg
operator|.
name|error
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
comment|/* 		 * We only allocate a cluster, mbuf allocation happens after rx 		 */
if|if
condition|(
operator|(
name|cl
operator|=
name|cxgb_cache_get
argument_list|(
name|q
operator|->
name|zone
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"Failed to allocate cluster\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|(
name|sd
operator|->
name|flags
operator|&
name|RX_SW_DESC_MAP_CREATED
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|bus_dmamap_create
argument_list|(
name|q
operator|->
name|entry_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|sd
operator|->
name|map
argument_list|)
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"bus_dmamap_create failed %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|q
operator|->
name|zone
argument_list|,
name|cl
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|sd
operator|->
name|flags
operator||=
name|RX_SW_DESC_MAP_CREATED
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__amd64__
argument_list|)
name|err
operator|=
name|bus_dmamap_load
argument_list|(
name|q
operator|->
name|entry_tag
argument_list|,
name|sd
operator|->
name|map
argument_list|,
name|cl
operator|+
name|header_size
argument_list|,
name|q
operator|->
name|buf_size
argument_list|,
name|refill_fl_cb
argument_list|,
operator|&
name|cb_arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|||
name|cb_arg
operator|.
name|error
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"failure in refill_fl %d\n"
argument_list|,
name|cb_arg
operator|.
name|error
argument_list|)
expr_stmt|;
comment|/* 			 * XXX free cluster 			 */
return|return;
block|}
else|#
directive|else
name|cb_arg
operator|.
name|seg
operator|.
name|ds_addr
operator|=
name|pmap_kextract
argument_list|(
call|(
name|vm_offset_t
call|)
argument_list|(
name|cl
operator|+
name|header_size
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sd
operator|->
name|flags
operator||=
name|RX_SW_DESC_INUSE
expr_stmt|;
name|sd
operator|->
name|rxsd_cl
operator|=
name|cl
expr_stmt|;
name|sd
operator|->
name|data
operator|=
name|cl
operator|+
name|header_size
expr_stmt|;
name|d
operator|->
name|addr_lo
operator|=
name|htobe32
argument_list|(
name|cb_arg
operator|.
name|seg
operator|.
name|ds_addr
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|d
operator|->
name|addr_hi
operator|=
name|htobe32
argument_list|(
operator|(
operator|(
name|uint64_t
operator|)
name|cb_arg
operator|.
name|seg
operator|.
name|ds_addr
operator|>>
literal|32
operator|)
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|d
operator|->
name|len_gen
operator|=
name|htobe32
argument_list|(
name|V_FLD_GEN1
argument_list|(
name|q
operator|->
name|gen
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|gen2
operator|=
name|htobe32
argument_list|(
name|V_FLD_GEN2
argument_list|(
name|q
operator|->
name|gen
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|++
expr_stmt|;
name|sd
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|q
operator|->
name|pidx
operator|==
name|q
operator|->
name|size
condition|)
block|{
name|q
operator|->
name|pidx
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|gen
operator|^=
literal|1
expr_stmt|;
name|sd
operator|=
name|q
operator|->
name|sdesc
expr_stmt|;
name|d
operator|=
name|q
operator|->
name|desc
expr_stmt|;
block|}
name|q
operator|->
name|credits
operator|++
expr_stmt|;
block|}
name|done
label|:
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|A_SG_KDOORBELL
argument_list|,
name|V_EGRCNTX
argument_list|(
name|q
operator|->
name|cntxt_id
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	free_rx_bufs - free the Rx buffers on an SGE free list  *	@sc: the controle softc  *	@q: the SGE free list to clean up  *  *	Release the buffers on an SGE free-buffer Rx queue.  HW fetching from  *	this queue should be stopped before calling this function.  */
end_comment

begin_function
specifier|static
name|void
name|free_rx_bufs
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_fl
modifier|*
name|q
parameter_list|)
block|{
name|u_int
name|cidx
init|=
name|q
operator|->
name|cidx
decl_stmt|;
while|while
condition|(
name|q
operator|->
name|credits
operator|--
condition|)
block|{
name|struct
name|rx_sw_desc
modifier|*
name|d
init|=
operator|&
name|q
operator|->
name|sdesc
index|[
name|cidx
index|]
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|RX_SW_DESC_INUSE
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|q
operator|->
name|entry_tag
argument_list|,
name|d
operator|->
name|map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|q
operator|->
name|entry_tag
argument_list|,
name|d
operator|->
name|map
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|q
operator|->
name|zone
argument_list|,
name|d
operator|->
name|rxsd_cl
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|rxsd_cl
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|++
name|cidx
operator|==
name|q
operator|->
name|size
condition|)
name|cidx
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|__refill_fl
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|struct
name|sge_fl
modifier|*
name|fl
parameter_list|)
block|{
name|refill_fl
argument_list|(
name|adap
argument_list|,
name|fl
argument_list|,
name|min
argument_list|(
literal|16U
argument_list|,
name|fl
operator|->
name|size
operator|-
name|fl
operator|->
name|credits
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|__refill_fl_lt
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|struct
name|sge_fl
modifier|*
name|fl
parameter_list|,
name|int
name|max
parameter_list|)
block|{
if|if
condition|(
operator|(
name|fl
operator|->
name|size
operator|-
name|fl
operator|->
name|credits
operator|)
operator|<
name|max
condition|)
name|refill_fl
argument_list|(
name|adap
argument_list|,
name|fl
argument_list|,
name|min
argument_list|(
name|max
argument_list|,
name|fl
operator|->
name|size
operator|-
name|fl
operator|->
name|credits
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|refill_fl_service
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|struct
name|sge_fl
modifier|*
name|fl
parameter_list|)
block|{
name|__refill_fl_lt
argument_list|(
name|adap
argument_list|,
name|fl
argument_list|,
literal|512
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	recycle_rx_buf - recycle a receive buffer  *	@adapter: the adapter  *	@q: the SGE free list  *	@idx: index of buffer to recycle  *  *	Recycles the specified buffer on the given free list by adding it at  *	the next available slot on the list.  */
end_comment

begin_function
specifier|static
name|void
name|recycle_rx_buf
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|struct
name|sge_fl
modifier|*
name|q
parameter_list|,
name|unsigned
name|int
name|idx
parameter_list|)
block|{
name|struct
name|rx_desc
modifier|*
name|from
init|=
operator|&
name|q
operator|->
name|desc
index|[
name|idx
index|]
decl_stmt|;
name|struct
name|rx_desc
modifier|*
name|to
init|=
operator|&
name|q
operator|->
name|desc
index|[
name|q
operator|->
name|pidx
index|]
decl_stmt|;
name|q
operator|->
name|sdesc
index|[
name|q
operator|->
name|pidx
index|]
operator|=
name|q
operator|->
name|sdesc
index|[
name|idx
index|]
expr_stmt|;
name|to
operator|->
name|addr_lo
operator|=
name|from
operator|->
name|addr_lo
expr_stmt|;
comment|// already big endian
name|to
operator|->
name|addr_hi
operator|=
name|from
operator|->
name|addr_hi
expr_stmt|;
comment|// likewise
name|wmb
argument_list|()
expr_stmt|;
name|to
operator|->
name|len_gen
operator|=
name|htobe32
argument_list|(
name|V_FLD_GEN1
argument_list|(
name|q
operator|->
name|gen
argument_list|)
argument_list|)
expr_stmt|;
name|to
operator|->
name|gen2
operator|=
name|htobe32
argument_list|(
name|V_FLD_GEN2
argument_list|(
name|q
operator|->
name|gen
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|credits
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|q
operator|->
name|pidx
operator|==
name|q
operator|->
name|size
condition|)
block|{
name|q
operator|->
name|pidx
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|gen
operator|^=
literal|1
expr_stmt|;
block|}
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_KDOORBELL
argument_list|,
name|V_EGRCNTX
argument_list|(
name|q
operator|->
name|cntxt_id
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|alloc_ring_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|uint32_t
modifier|*
name|addr
decl_stmt|;
name|addr
operator|=
name|arg
expr_stmt|;
operator|*
name|addr
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|alloc_ring
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|,
name|size_t
name|nelem
parameter_list|,
name|size_t
name|elem_size
parameter_list|,
name|size_t
name|sw_size
parameter_list|,
name|bus_addr_t
modifier|*
name|phys
parameter_list|,
name|void
modifier|*
name|desc
parameter_list|,
name|void
modifier|*
name|sdesc
parameter_list|,
name|bus_dma_tag_t
modifier|*
name|tag
parameter_list|,
name|bus_dmamap_t
modifier|*
name|map
parameter_list|,
name|bus_dma_tag_t
name|parent_entry_tag
parameter_list|,
name|bus_dma_tag_t
modifier|*
name|entry_tag
parameter_list|)
block|{
name|size_t
name|len
init|=
name|nelem
operator|*
name|elem_size
decl_stmt|;
name|void
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_dmat
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|tag
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot allocate descriptor tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|bus_dmamem_alloc
argument_list|(
operator|*
name|tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|p
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
name|map
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot allocate descriptor memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bus_dmamap_load
argument_list|(
operator|*
name|tag
argument_list|,
operator|*
name|map
argument_list|,
name|p
argument_list|,
name|len
argument_list|,
name|alloc_ring_cb
argument_list|,
name|phys
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
operator|(
name|void
operator|*
operator|*
operator|)
name|desc
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|sw_size
condition|)
block|{
name|len
operator|=
name|nelem
operator|*
name|sw_size
expr_stmt|;
name|s
operator|=
name|malloc
argument_list|(
name|len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
operator|(
name|void
operator|*
operator|*
operator|)
name|sdesc
operator|=
name|s
expr_stmt|;
block|}
if|if
condition|(
name|parent_entry_tag
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|err
operator|=
name|bus_dma_tag_create
argument_list|(
name|parent_entry_tag
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|TX_MAX_SIZE
argument_list|,
name|TX_MAX_SEGS
argument_list|,
name|TX_MAX_SIZE
argument_list|,
name|BUS_DMA_ALLOCNOW
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|entry_tag
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot allocate descriptor entry tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sge_slow_intr_handler
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|ncount
parameter_list|)
block|{
name|adapter_t
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|t3_slow_intr_handler
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	sge_timer_cb - perform periodic maintenance of an SGE qset  *	@data: the SGE queue set to maintain  *  *	Runs periodically from a timer to perform maintenance of an SGE queue  *	set.  It performs two tasks:  *  *	a) Cleans up any completed Tx descriptors that may still be pending.  *	Normal descriptor cleanup happens when new packets are added to a Tx  *	queue so this timer is relatively infrequent and does any cleanup only  *	if the Tx queue has not seen any new packets in a while.  We make a  *	best effort attempt to reclaim descriptors, in that we don't wait  *	around if we cannot get a queue's lock (which most likely is because  *	someone else is queueing new packets and so will also handle the clean  *	up).  Since control queues use immediate data exclusively we don't  *	bother cleaning them up here.  *  *	b) Replenishes Rx queues that have run out due to memory shortage.  *	Normally new Rx buffers are added when existing ones are consumed but  *	when out of memory a queue can become empty.  We try to add only a few  *	buffers here, the queue will be replenished fully as these new buffers  *	are used up if memory shortage has subsided.  *	  *	c) Return coalesced response queue credits in case a response queue is  *	starved.  *  *	d) Ring doorbells for T304 tunnel queues since we have seen doorbell   *	fifo overflows and the FW doesn't implement any recovery scheme yet.  */
end_comment

begin_function
specifier|static
name|void
name|sge_timer_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|adapter_t
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
ifndef|#
directive|ifndef
name|IFNET_MULTIQUEUE
name|struct
name|port_info
modifier|*
name|pi
decl_stmt|;
name|struct
name|sge_qset
modifier|*
name|qs
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|reclaim_eth
decl_stmt|,
name|reclaim_ofl
decl_stmt|,
name|refill_rx
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|params
operator|.
name|nports
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sc
operator|->
name|port
index|[
name|i
index|]
operator|.
name|nqsets
condition|;
name|j
operator|++
control|)
block|{
name|qs
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
name|i
operator|+
name|j
index|]
expr_stmt|;
name|txq
operator|=
operator|&
name|qs
operator|->
name|txq
index|[
literal|0
index|]
expr_stmt|;
name|reclaim_eth
operator|=
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|processed
operator|-
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|cleaned
expr_stmt|;
name|reclaim_ofl
operator|=
name|txq
index|[
name|TXQ_OFLD
index|]
operator|.
name|processed
operator|-
name|txq
index|[
name|TXQ_OFLD
index|]
operator|.
name|cleaned
expr_stmt|;
name|refill_rx
operator|=
operator|(
operator|(
name|qs
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|credits
operator|<
name|qs
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|size
operator|)
operator|||
operator|(
name|qs
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|credits
operator|<
name|qs
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|size
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|reclaim_eth
operator|||
name|reclaim_ofl
operator|||
name|refill_rx
condition|)
block|{
name|pi
operator|=
operator|&
name|sc
operator|->
name|port
index|[
name|i
index|]
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|pi
operator|->
name|tq
argument_list|,
operator|&
name|pi
operator|->
name|timer_reclaim_task
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|params
operator|.
name|nports
operator|>
literal|2
condition|)
block|{
name|int
name|i
decl_stmt|;
name|for_each_port
argument_list|(
argument|sc
argument_list|,
argument|i
argument_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
operator|&
name|sc
operator|->
name|port
index|[
name|i
index|]
decl_stmt|;
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|A_SG_KDOORBELL
argument_list|,
name|F_SELEGRCNTX
operator||
operator|(
name|FW_TUNNEL_SGEEC_START
operator|+
name|pi
operator|->
name|first_qset
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|open_device_map
operator|!=
literal|0
condition|)
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sge_timer_ch
argument_list|,
name|TX_RECLAIM_PERIOD
argument_list|,
name|sge_timer_cb
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is meant to be a catch-all function to keep sge state private  * to sge.c  *  */
end_comment

begin_function
name|int
name|t3_sge_init_adapter
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|)
block|{
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sge_timer_ch
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sge_timer_ch
argument_list|,
name|TX_RECLAIM_PERIOD
argument_list|,
name|sge_timer_cb
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|slow_intr_task
argument_list|,
literal|0
argument_list|,
name|sge_slow_intr_handler
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|mi_init
argument_list|()
expr_stmt|;
name|cxgb_cache_init
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t3_sge_reset_adapter
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|)
block|{
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sge_timer_ch
argument_list|,
name|TX_RECLAIM_PERIOD
argument_list|,
name|sge_timer_cb
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t3_sge_init_port
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
name|TASK_INIT
argument_list|(
operator|&
name|pi
operator|->
name|timer_reclaim_task
argument_list|,
literal|0
argument_list|,
name|sge_timer_reclaim
argument_list|,
name|pi
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|t3_sge_deinit_sw
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sge_timer_ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tq
condition|)
name|taskqueue_drain
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|sc
operator|->
name|slow_intr_task
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|params
operator|.
name|nports
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|port
index|[
name|i
index|]
operator|.
name|tq
operator|!=
name|NULL
condition|)
name|taskqueue_drain
argument_list|(
name|sc
operator|->
name|port
index|[
name|i
index|]
operator|.
name|tq
argument_list|,
operator|&
name|sc
operator|->
name|port
index|[
name|i
index|]
operator|.
name|timer_reclaim_task
argument_list|)
expr_stmt|;
name|mi_deinit
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	refill_rspq - replenish an SGE response queue  *	@adapter: the adapter  *	@q: the response queue to replenish  *	@credits: how many new responses to make available  *  *	Replenishes a response queue by making the supplied number of responses  *	available to HW.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|refill_rspq
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|sge_rspq
modifier|*
name|q
parameter_list|,
name|u_int
name|credits
parameter_list|)
block|{
comment|/* mbufs are allocated on demand when a rspq entry is processed. */
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|A_SG_RSPQ_CREDIT_RETURN
argument_list|,
name|V_RSPQ
argument_list|(
name|q
operator|->
name|cntxt_id
argument_list|)
operator||
name|V_CREDITS
argument_list|(
name|credits
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|sge_txq_reclaim_
parameter_list|(
name|struct
name|sge_txq
modifier|*
name|txq
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|int
name|reclaimable
decl_stmt|,
name|n
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
decl_stmt|;
name|pi
operator|=
name|txq
operator|->
name|port
expr_stmt|;
name|reclaim_more
label|:
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|reclaimable
operator|=
name|desc_reclaimable
argument_list|(
name|txq
argument_list|)
operator|)
operator|<
literal|16
condition|)
return|return;
if|if
condition|(
name|mtx_trylock
argument_list|(
operator|&
name|txq
operator|->
name|lock
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|n
operator|=
name|reclaim_completed_tx_
argument_list|(
name|txq
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|txq
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|&&
name|pi
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_OACTIVE
operator|&&
name|txq
operator|->
name|size
operator|-
name|txq
operator|->
name|in_use
operator|>=
name|TX_START_MAX_DESC
condition|)
block|{
name|struct
name|sge_qset
modifier|*
name|qs
init|=
name|txq_to_qset
argument_list|(
name|txq
argument_list|,
name|TXQ_ETH
argument_list|)
decl_stmt|;
name|txq_fills
operator|++
expr_stmt|;
name|pi
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|clrbit
argument_list|(
operator|&
name|qs
operator|->
name|txq_stopped
argument_list|,
name|TXQ_ETH
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|pi
operator|->
name|tq
argument_list|,
operator|&
name|pi
operator|->
name|start_task
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
condition|)
goto|goto
name|reclaim_more
goto|;
block|}
end_function

begin_function
specifier|static
name|void
name|sge_txq_reclaim_handler
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|ncount
parameter_list|)
block|{
name|struct
name|sge_txq
modifier|*
name|q
init|=
name|arg
decl_stmt|;
name|sge_txq_reclaim_
argument_list|(
name|q
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sge_timer_reclaim
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|ncount
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|arg
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nqsets
init|=
name|pi
operator|->
name|nqsets
decl_stmt|;
name|adapter_t
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|sge_qset
modifier|*
name|qs
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
name|struct
name|mtx
modifier|*
name|lock
decl_stmt|;
ifdef|#
directive|ifdef
name|IFNET_MULTIQUEUE
name|panic
argument_list|(
literal|"%s should not be called with multiqueue support\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nqsets
condition|;
name|i
operator|++
control|)
block|{
name|qs
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
name|i
index|]
expr_stmt|;
name|txq
operator|=
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
expr_stmt|;
name|sge_txq_reclaim_
argument_list|(
name|txq
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|txq
operator|=
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
expr_stmt|;
name|sge_txq_reclaim_
argument_list|(
name|txq
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|lock
operator|=
operator|(
name|sc
operator|->
name|flags
operator|&
name|USING_MSIX
operator|)
condition|?
operator|&
name|qs
operator|->
name|rspq
operator|.
name|lock
else|:
operator|&
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
literal|0
index|]
operator|.
name|rspq
operator|.
name|lock
expr_stmt|;
if|if
condition|(
name|mtx_trylock
argument_list|(
name|lock
argument_list|)
condition|)
block|{
comment|/* XXX currently assume that we are *NOT* polling */
name|uint32_t
name|status
init|=
name|t3_read_reg
argument_list|(
name|sc
argument_list|,
name|A_SG_RSPQ_FL_STATUS
argument_list|)
decl_stmt|;
if|if
condition|(
name|qs
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|credits
operator|<
name|qs
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|size
operator|-
literal|16
condition|)
name|__refill_fl
argument_list|(
name|sc
argument_list|,
operator|&
name|qs
operator|->
name|fl
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|qs
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|credits
operator|<
name|qs
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|size
operator|-
literal|16
condition|)
name|__refill_fl
argument_list|(
name|sc
argument_list|,
operator|&
name|qs
operator|->
name|fl
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
operator|(
literal|1
operator|<<
name|qs
operator|->
name|rspq
operator|.
name|cntxt_id
operator|)
condition|)
block|{
if|if
condition|(
name|qs
operator|->
name|rspq
operator|.
name|credits
condition|)
block|{
name|refill_rspq
argument_list|(
name|sc
argument_list|,
operator|&
name|qs
operator|->
name|rspq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|qs
operator|->
name|rspq
operator|.
name|credits
operator|--
expr_stmt|;
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|A_SG_RSPQ_FL_STATUS
argument_list|,
literal|1
operator|<<
name|qs
operator|->
name|rspq
operator|.
name|cntxt_id
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  *	init_qset_cntxt - initialize an SGE queue set context info  *	@qs: the queue set  *	@id: the queue set id  *  *	Initializes the TIDs and context ids for the queues of a queue set.  */
end_comment

begin_function
specifier|static
name|void
name|init_qset_cntxt
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|u_int
name|id
parameter_list|)
block|{
name|qs
operator|->
name|rspq
operator|.
name|cntxt_id
operator|=
name|id
expr_stmt|;
name|qs
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|cntxt_id
operator|=
literal|2
operator|*
name|id
expr_stmt|;
name|qs
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|cntxt_id
operator|=
literal|2
operator|*
name|id
operator|+
literal|1
expr_stmt|;
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|cntxt_id
operator|=
name|FW_TUNNEL_SGEEC_START
operator|+
name|id
expr_stmt|;
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|token
operator|=
name|FW_TUNNEL_TID_START
operator|+
name|id
expr_stmt|;
name|qs
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
operator|.
name|cntxt_id
operator|=
name|FW_OFLD_SGEEC_START
operator|+
name|id
expr_stmt|;
name|qs
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
operator|.
name|cntxt_id
operator|=
name|FW_CTRL_SGEEC_START
operator|+
name|id
expr_stmt|;
name|qs
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
operator|.
name|token
operator|=
name|FW_CTRL_TID_START
operator|+
name|id
expr_stmt|;
name|mbufq_init
argument_list|(
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|sendq
argument_list|)
expr_stmt|;
name|mbufq_init
argument_list|(
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
operator|.
name|sendq
argument_list|)
expr_stmt|;
name|mbufq_init
argument_list|(
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
operator|.
name|sendq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|txq_prod
parameter_list|(
name|struct
name|sge_txq
modifier|*
name|txq
parameter_list|,
name|unsigned
name|int
name|ndesc
parameter_list|,
name|struct
name|txq_state
modifier|*
name|txqs
parameter_list|)
block|{
name|txq
operator|->
name|in_use
operator|+=
name|ndesc
expr_stmt|;
comment|/* 	 * XXX we don't handle stopping of queue 	 * presumably start handles this when we bump against the end 	 */
name|txqs
operator|->
name|gen
operator|=
name|txq
operator|->
name|gen
expr_stmt|;
name|txq
operator|->
name|unacked
operator|+=
name|ndesc
expr_stmt|;
name|txqs
operator|->
name|compl
operator|=
operator|(
name|txq
operator|->
name|unacked
operator|&
literal|8
operator|)
operator|<<
operator|(
name|S_WR_COMPL
operator|-
literal|3
operator|)
expr_stmt|;
name|txq
operator|->
name|unacked
operator|&=
literal|7
expr_stmt|;
name|txqs
operator|->
name|pidx
operator|=
name|txq
operator|->
name|pidx
expr_stmt|;
name|txq
operator|->
name|pidx
operator|+=
name|ndesc
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|pidx
operator|>=
name|txq
operator|->
name|size
condition|)
block|{
name|txq
operator|->
name|pidx
operator|-=
name|txq
operator|->
name|size
expr_stmt|;
name|txq
operator|->
name|gen
operator|^=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	calc_tx_descs - calculate the number of Tx descriptors for a packet  *	@m: the packet mbufs  *      @nsegs: the number of segments   *  * 	Returns the number of Tx descriptors needed for the given Ethernet  * 	packet.  Ethernet packets require addition of WR and CPL headers.  */
end_comment

begin_function
specifier|static
name|__inline
name|unsigned
name|int
name|calc_tx_descs
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|nsegs
parameter_list|)
block|{
name|unsigned
name|int
name|flits
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<=
name|WR_LEN
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|cpl_tx_pkt
argument_list|)
condition|)
return|return
literal|1
return|;
name|flits
operator|=
name|sgl_len
argument_list|(
name|nsegs
argument_list|)
operator|+
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|TSO_SUPPORTED
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
condition|)
name|flits
operator|++
expr_stmt|;
endif|#
directive|endif
return|return
name|flits_to_desc
argument_list|(
name|flits
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|busdma_map_mbufs
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|,
name|struct
name|sge_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|tx_sw_desc
modifier|*
name|txsd
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
modifier|*
name|nsegs
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|int
name|err
decl_stmt|,
name|pktlen
decl_stmt|,
name|pass
init|=
literal|0
decl_stmt|;
name|retry
label|:
name|err
operator|=
literal|0
expr_stmt|;
name|m0
operator|=
operator|*
name|m
expr_stmt|;
name|pktlen
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
if|if
condition|(
name|busdma_map_sg_collapse
argument_list|(
name|m
argument_list|,
name|segs
argument_list|,
name|nsegs
argument_list|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|done
goto|;
block|}
else|else
endif|#
directive|endif
name|err
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|txq
operator|->
name|entry_tag
argument_list|,
name|txsd
operator|->
name|map
argument_list|,
name|m0
argument_list|,
name|segs
argument_list|,
name|nsegs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|err
operator|==
name|EFBIG
operator|&&
name|pass
operator|==
literal|0
condition|)
block|{
name|pass
operator|=
literal|1
expr_stmt|;
comment|/* Too many segments, try to defrag */
name|m0
operator|=
name|m_defrag
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|m
argument_list|)
expr_stmt|;
operator|*
name|m
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
operator|*
name|m
operator|=
name|m0
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
elseif|else
if|if
condition|(
name|err
operator|==
name|ENOMEM
condition|)
block|{
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|cxgb_debug
condition|)
name|printf
argument_list|(
literal|"map failure err=%d pktlen=%d\n"
argument_list|,
name|err
argument_list|,
name|pktlen
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
operator|*
name|m
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|done
label|:
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__amd64__
argument_list|)
name|bus_dmamap_sync
argument_list|(
name|txq
operator|->
name|entry_tag
argument_list|,
name|txsd
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|txsd
operator|->
name|flags
operator||=
name|TX_SW_DESC_MAPPED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	make_sgl - populate a scatter/gather list for a packet  *	@sgp: the SGL to populate  *	@segs: the packet dma segments  *	@nsegs: the number of segments  *  *	Generates a scatter/gather list for the buffers that make up a packet  *	and returns the SGL size in 8-byte words.  The caller must size the SGL  *	appropriately.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|make_sgl
parameter_list|(
name|struct
name|sg_ent
modifier|*
name|sgp
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|idx
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * firmware doesn't like empty segments 		 */
if|if
condition|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|i
operator|&&
name|idx
operator|==
literal|0
condition|)
operator|++
name|sgp
expr_stmt|;
name|sgp
operator|->
name|len
index|[
name|idx
index|]
operator|=
name|htobe32
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
name|sgp
operator|->
name|addr
index|[
name|idx
index|]
operator|=
name|htobe64
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|idx
operator|^=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|idx
condition|)
block|{
name|sgp
operator|->
name|len
index|[
name|idx
index|]
operator|=
literal|0
expr_stmt|;
name|sgp
operator|->
name|addr
index|[
name|idx
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	check_ring_tx_db - check and potentially ring a Tx queue's doorbell  *	@adap: the adapter  *	@q: the Tx queue  *  *	Ring the doorbel if a Tx queue is asleep.  There is a natural race,  *	where the HW is going to sleep just after we checked, however,  *	then the interrupt handler will detect the outstanding TX packet  *	and ring the doorbell for us.  *  *	When GTS is disabled we unconditionally ring the doorbell.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|check_ring_tx_db
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|struct
name|sge_txq
modifier|*
name|q
parameter_list|)
block|{
if|#
directive|if
name|USE_GTS
name|clear_bit
argument_list|(
name|TXQ_LAST_PKT_DB
argument_list|,
operator|&
name|q
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|test_and_set_bit
argument_list|(
name|TXQ_RUNNING
argument_list|,
operator|&
name|q
operator|->
name|flags
argument_list|)
operator|==
literal|0
condition|)
block|{
name|set_bit
argument_list|(
name|TXQ_LAST_PKT_DB
argument_list|,
operator|&
name|q
operator|->
name|flags
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|T3_TRACE
name|T3_TRACE1
argument_list|(
name|adap
operator|->
name|tb
index|[
name|q
operator|->
name|cntxt_id
operator|&
literal|7
index|]
argument_list|,
literal|"doorbell Tx, cntxt %d"
argument_list|,
name|q
operator|->
name|cntxt_id
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_KDOORBELL
argument_list|,
name|F_SELEGRCNTX
operator||
name|V_EGRCNTX
argument_list|(
name|q
operator|->
name|cntxt_id
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|wmb
argument_list|()
expr_stmt|;
comment|/* write descriptors before telling HW */
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_KDOORBELL
argument_list|,
name|F_SELEGRCNTX
operator||
name|V_EGRCNTX
argument_list|(
name|q
operator|->
name|cntxt_id
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|wr_gen2
parameter_list|(
name|struct
name|tx_desc
modifier|*
name|d
parameter_list|,
name|unsigned
name|int
name|gen
parameter_list|)
block|{
if|#
directive|if
name|SGE_NUM_GENBITS
operator|==
literal|2
name|d
operator|->
name|flit
index|[
name|TX_DESC_FLITS
operator|-
literal|1
index|]
operator|=
name|htobe64
argument_list|(
name|gen
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/**  *	write_wr_hdr_sgl - write a WR header and, optionally, SGL  *	@ndesc: number of Tx descriptors spanned by the SGL  *	@txd: first Tx descriptor to be written  *	@txqs: txq state (generation and producer index)  *	@txq: the SGE Tx queue  *	@sgl: the SGL  *	@flits: number of flits to the start of the SGL in the first descriptor  *	@sgl_flits: the SGL size in flits  *	@wr_hi: top 32 bits of WR header based on WR type (big endian)  *	@wr_lo: low 32 bits of WR header based on WR type (big endian)  *  *	Write a work request header and an associated SGL.  If the SGL is  *	small enough to fit into one Tx descriptor it has already been written  *	and we just need to write the WR header.  Otherwise we distribute the  *	SGL across the number of descriptors it spans.  */
end_comment

begin_function
specifier|static
name|void
name|write_wr_hdr_sgl
parameter_list|(
name|unsigned
name|int
name|ndesc
parameter_list|,
name|struct
name|tx_desc
modifier|*
name|txd
parameter_list|,
name|struct
name|txq_state
modifier|*
name|txqs
parameter_list|,
specifier|const
name|struct
name|sge_txq
modifier|*
name|txq
parameter_list|,
specifier|const
name|struct
name|sg_ent
modifier|*
name|sgl
parameter_list|,
name|unsigned
name|int
name|flits
parameter_list|,
name|unsigned
name|int
name|sgl_flits
parameter_list|,
name|unsigned
name|int
name|wr_hi
parameter_list|,
name|unsigned
name|int
name|wr_lo
parameter_list|)
block|{
name|struct
name|work_request_hdr
modifier|*
name|wrp
init|=
operator|(
expr|struct
name|work_request_hdr
operator|*
operator|)
name|txd
decl_stmt|;
name|struct
name|tx_sw_desc
modifier|*
name|txsd
init|=
operator|&
name|txq
operator|->
name|sdesc
index|[
name|txqs
operator|->
name|pidx
index|]
decl_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
name|ndesc
operator|==
literal|1
argument_list|)
condition|)
block|{
name|wrp
operator|->
name|wr_hi
operator|=
name|htonl
argument_list|(
name|F_WR_SOP
operator||
name|F_WR_EOP
operator||
name|V_WR_DATATYPE
argument_list|(
literal|1
argument_list|)
operator||
name|V_WR_SGLSFLT
argument_list|(
name|flits
argument_list|)
argument_list|)
operator||
name|wr_hi
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
name|wrp
operator|->
name|wr_lo
operator|=
name|htonl
argument_list|(
name|V_WR_LEN
argument_list|(
name|flits
operator|+
name|sgl_flits
argument_list|)
operator||
name|V_WR_GEN
argument_list|(
name|txqs
operator|->
name|gen
argument_list|)
argument_list|)
operator||
name|wr_lo
expr_stmt|;
comment|/* XXX gen? */
name|wr_gen2
argument_list|(
name|txd
argument_list|,
name|txqs
operator|->
name|gen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|int
name|ogen
init|=
name|txqs
operator|->
name|gen
decl_stmt|;
specifier|const
name|uint64_t
modifier|*
name|fp
init|=
operator|(
specifier|const
name|uint64_t
operator|*
operator|)
name|sgl
decl_stmt|;
name|struct
name|work_request_hdr
modifier|*
name|wp
init|=
name|wrp
decl_stmt|;
name|wrp
operator|->
name|wr_hi
operator|=
name|htonl
argument_list|(
name|F_WR_SOP
operator||
name|V_WR_DATATYPE
argument_list|(
literal|1
argument_list|)
operator||
name|V_WR_SGLSFLT
argument_list|(
name|flits
argument_list|)
argument_list|)
operator||
name|wr_hi
expr_stmt|;
while|while
condition|(
name|sgl_flits
condition|)
block|{
name|unsigned
name|int
name|avail
init|=
name|WR_FLITS
operator|-
name|flits
decl_stmt|;
if|if
condition|(
name|avail
operator|>
name|sgl_flits
condition|)
name|avail
operator|=
name|sgl_flits
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|txd
operator|->
name|flit
index|[
name|flits
index|]
argument_list|,
name|fp
argument_list|,
name|avail
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|fp
argument_list|)
argument_list|)
expr_stmt|;
name|sgl_flits
operator|-=
name|avail
expr_stmt|;
name|ndesc
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|sgl_flits
condition|)
break|break;
name|fp
operator|+=
name|avail
expr_stmt|;
name|txd
operator|++
expr_stmt|;
name|txsd
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|txqs
operator|->
name|pidx
operator|==
name|txq
operator|->
name|size
condition|)
block|{
name|txqs
operator|->
name|pidx
operator|=
literal|0
expr_stmt|;
name|txqs
operator|->
name|gen
operator|^=
literal|1
expr_stmt|;
name|txd
operator|=
name|txq
operator|->
name|desc
expr_stmt|;
name|txsd
operator|=
name|txq
operator|->
name|sdesc
expr_stmt|;
block|}
comment|/* 			 * when the head of the mbuf chain 			 * is freed all clusters will be freed 			 * with it 			 */
name|txsd
operator|->
name|mi
operator|.
name|mi_base
operator|=
name|NULL
expr_stmt|;
name|wrp
operator|=
operator|(
expr|struct
name|work_request_hdr
operator|*
operator|)
name|txd
expr_stmt|;
name|wrp
operator|->
name|wr_hi
operator|=
name|htonl
argument_list|(
name|V_WR_DATATYPE
argument_list|(
literal|1
argument_list|)
operator||
name|V_WR_SGLSFLT
argument_list|(
literal|1
argument_list|)
argument_list|)
operator||
name|wr_hi
expr_stmt|;
name|wrp
operator|->
name|wr_lo
operator|=
name|htonl
argument_list|(
name|V_WR_LEN
argument_list|(
name|min
argument_list|(
name|WR_FLITS
argument_list|,
name|sgl_flits
operator|+
literal|1
argument_list|)
argument_list|)
operator||
name|V_WR_GEN
argument_list|(
name|txqs
operator|->
name|gen
argument_list|)
argument_list|)
operator||
name|wr_lo
expr_stmt|;
name|wr_gen2
argument_list|(
name|txd
argument_list|,
name|txqs
operator|->
name|gen
argument_list|)
expr_stmt|;
name|flits
operator|=
literal|1
expr_stmt|;
block|}
name|wrp
operator|->
name|wr_hi
operator||=
name|htonl
argument_list|(
name|F_WR_EOP
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
name|wp
operator|->
name|wr_lo
operator|=
name|htonl
argument_list|(
name|V_WR_LEN
argument_list|(
name|WR_FLITS
argument_list|)
operator||
name|V_WR_GEN
argument_list|(
name|ogen
argument_list|)
argument_list|)
operator||
name|wr_lo
expr_stmt|;
name|wr_gen2
argument_list|(
operator|(
expr|struct
name|tx_desc
operator|*
operator|)
name|wp
argument_list|,
name|ogen
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* sizeof(*eh) + sizeof(*vhdr) + sizeof(*ip) + sizeof(*tcp) */
end_comment

begin_define
define|#
directive|define
name|TCPPKTHDRSIZE
value|(ETHER_HDR_LEN + ETHER_VLAN_ENCAP_LEN + 20 + 20)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|VLAN_SUPPORTED
end_ifdef

begin_define
define|#
directive|define
name|GET_VTAG
parameter_list|(
name|cntrl
parameter_list|,
name|m
parameter_list|)
define|\
value|do { \ 	if ((m)->m_flags& M_VLANTAG)					            \ 		cntrl |= F_TXPKT_VLAN_VLD | V_TXPKT_VLAN((m)->m_pkthdr.ether_vtag); \ } while (0)
end_define

begin_define
define|#
directive|define
name|GET_VTAG_MI
parameter_list|(
name|cntrl
parameter_list|,
name|mi
parameter_list|)
define|\
value|do { \ 	if ((mi)->mi_flags& M_VLANTAG)					\ 		cntrl |= F_TXPKT_VLAN_VLD | V_TXPKT_VLAN((mi)->mi_ether_vtag); \ } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|GET_VTAG
parameter_list|(
name|cntrl
parameter_list|,
name|m
parameter_list|)
end_define

begin_define
define|#
directive|define
name|GET_VTAG_MI
parameter_list|(
name|cntrl
parameter_list|,
name|m
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|t3_encap
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|adapter_t
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
name|struct
name|txq_state
name|txqs
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
decl_stmt|;
name|unsigned
name|int
name|ndesc
decl_stmt|,
name|flits
decl_stmt|,
name|cntrl
decl_stmt|,
name|mlen
decl_stmt|;
name|int
name|err
decl_stmt|,
name|nsegs
decl_stmt|,
name|tso_info
init|=
literal|0
decl_stmt|;
name|struct
name|work_request_hdr
modifier|*
name|wrp
decl_stmt|;
name|struct
name|tx_sw_desc
modifier|*
name|txsd
decl_stmt|;
name|struct
name|sg_ent
modifier|*
name|sgp
decl_stmt|,
modifier|*
name|sgl
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|segs
decl_stmt|;
name|uint32_t
name|wr_hi
decl_stmt|,
name|wr_lo
decl_stmt|,
name|sgl_flits
decl_stmt|;
name|struct
name|tx_desc
modifier|*
name|txd
decl_stmt|;
name|struct
name|mbuf_vec
modifier|*
name|mv
decl_stmt|;
name|struct
name|mbuf_iovec
modifier|*
name|mi
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"t3_encap cpu=%d "
argument_list|,
name|curcpu
argument_list|)
expr_stmt|;
name|pi
operator|=
name|qs
operator|->
name|port
expr_stmt|;
name|sc
operator|=
name|pi
operator|->
name|adapter
expr_stmt|;
name|txq
operator|=
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
expr_stmt|;
name|txsd
operator|=
operator|&
name|txq
operator|->
name|sdesc
index|[
name|txq
operator|->
name|pidx
index|]
expr_stmt|;
name|txd
operator|=
operator|&
name|txq
operator|->
name|desc
index|[
name|txq
operator|->
name|pidx
index|]
expr_stmt|;
name|sgl
operator|=
name|txq
operator|->
name|txq_sgl
expr_stmt|;
name|segs
operator|=
name|txq
operator|->
name|txq_segs
expr_stmt|;
name|m0
operator|=
operator|*
name|m
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"t3_encap port_id=%d qsidx=%d "
argument_list|,
name|pi
operator|->
name|port_id
argument_list|,
name|pi
operator|->
name|first_qset
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"mlen=%d txpkt_intf=%d tx_chan=%d\n"
argument_list|,
name|m
index|[
literal|0
index|]
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|pi
operator|->
name|txpkt_intf
argument_list|,
name|pi
operator|->
name|tx_chan
argument_list|)
expr_stmt|;
name|cntrl
operator|=
name|V_TXPKT_INTF
argument_list|(
name|pi
operator|->
name|txpkt_intf
argument_list|)
expr_stmt|;
comment|/*  * XXX need to add VLAN support for 6.x  */
ifdef|#
directive|ifdef
name|VLAN_SUPPORTED
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_TSO
operator|)
condition|)
name|tso_info
operator|=
name|V_LSO_MSS
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|count
operator|>
literal|1
condition|)
block|{
name|panic
argument_list|(
literal|"count> 1 not support in CVS\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|busdma_map_sg_vec
argument_list|(
name|m
argument_list|,
operator|&
name|m0
argument_list|,
name|segs
argument_list|,
name|count
argument_list|)
operator|)
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|nsegs
operator|=
name|count
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|err
operator|=
name|busdma_map_sg_collapse
argument_list|(
operator|&
name|m0
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|cxgb_debug
condition|)
name|printf
argument_list|(
literal|"failed ... err=%d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|KASSERT
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
operator|(
literal|"empty packet nsegs=%d count=%d"
operator|,
name|nsegs
operator|,
name|count
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|->
name|m_type
operator|==
name|MT_DATA
condition|)
name|DPRINTF
argument_list|(
literal|"mbuf type=%d tags:%d head=%p"
argument_list|,
name|m0
operator|->
name|m_type
argument_list|,
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|m0
operator|->
name|m_pkthdr
operator|.
name|tags
argument_list|)
argument_list|,
name|SLIST_FIRST
argument_list|(
operator|&
name|m0
operator|->
name|m_pkthdr
operator|.
name|tags
argument_list|)
argument_list|)
expr_stmt|;
name|mi_collapse_mbuf
argument_list|(
operator|&
name|txsd
operator|->
name|mi
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|mi
operator|=
operator|&
name|txsd
operator|->
name|mi
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
block|{
name|struct
name|cpl_tx_pkt_batch
modifier|*
name|cpl_batch
init|=
operator|(
expr|struct
name|cpl_tx_pkt_batch
operator|*
operator|)
name|txd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|fidx
decl_stmt|;
name|struct
name|mbuf_iovec
modifier|*
name|batchmi
decl_stmt|;
name|mv
operator|=
name|mtomv
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|batchmi
operator|=
name|mv
operator|->
name|mv_vec
expr_stmt|;
name|wrp
operator|=
operator|(
expr|struct
name|work_request_hdr
operator|*
operator|)
name|txd
expr_stmt|;
name|flits
operator|=
name|count
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
name|txq_prod
argument_list|(
name|txq
argument_list|,
literal|1
argument_list|,
operator|&
name|txqs
argument_list|)
expr_stmt|;
for|for
control|(
name|fidx
operator|=
literal|1
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|batchmi
operator|++
operator|,
name|fidx
operator|+=
literal|2
control|)
block|{
name|struct
name|cpl_tx_pkt_batch_entry
modifier|*
name|cbe
init|=
operator|&
name|cpl_batch
operator|->
name|pkt_entry
index|[
name|i
index|]
decl_stmt|;
name|cntrl
operator|=
name|V_TXPKT_INTF
argument_list|(
name|pi
operator|->
name|txpkt_intf
argument_list|)
expr_stmt|;
name|GET_VTAG_MI
argument_list|(
name|cntrl
argument_list|,
name|batchmi
argument_list|)
expr_stmt|;
name|cntrl
operator||=
name|V_TXPKT_OPCODE
argument_list|(
name|CPL_TX_PKT
argument_list|)
expr_stmt|;
name|cbe
operator|->
name|cntrl
operator|=
name|htonl
argument_list|(
name|cntrl
argument_list|)
expr_stmt|;
name|cbe
operator|->
name|len
operator|=
name|htonl
argument_list|(
name|batchmi
operator|->
name|mi_len
operator||
literal|0x80000000
argument_list|)
expr_stmt|;
name|cbe
operator|->
name|addr
operator|=
name|htobe64
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|txd
operator|->
name|flit
index|[
name|fidx
index|]
operator||=
name|htobe64
argument_list|(
literal|1
operator|<<
literal|24
argument_list|)
expr_stmt|;
block|}
name|wrp
operator|->
name|wr_hi
operator|=
name|htonl
argument_list|(
name|F_WR_SOP
operator||
name|F_WR_EOP
operator||
name|V_WR_DATATYPE
argument_list|(
literal|1
argument_list|)
operator||
name|V_WR_SGLSFLT
argument_list|(
name|flits
argument_list|)
argument_list|)
operator||
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_TUNNEL_TX_PKT
argument_list|)
operator||
name|txqs
operator|.
name|compl
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
name|wrp
operator|->
name|wr_lo
operator|=
name|htonl
argument_list|(
name|V_WR_LEN
argument_list|(
name|flits
argument_list|)
operator||
name|V_WR_GEN
argument_list|(
name|txqs
operator|.
name|gen
argument_list|)
argument_list|)
operator||
name|htonl
argument_list|(
name|V_WR_TID
argument_list|(
name|txq
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX gen? */
name|wr_gen2
argument_list|(
name|txd
argument_list|,
name|txqs
operator|.
name|gen
argument_list|)
expr_stmt|;
name|check_ring_tx_db
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|tso_info
condition|)
block|{
name|int
name|undersized
decl_stmt|,
name|eth_type
decl_stmt|;
name|struct
name|cpl_tx_pkt_lso
modifier|*
name|hdr
init|=
operator|(
expr|struct
name|cpl_tx_pkt_lso
operator|*
operator|)
name|txd
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|tcp
decl_stmt|;
name|char
modifier|*
name|pkthdr
decl_stmt|,
name|tmp
index|[
name|TCPPKTHDRSIZE
index|]
decl_stmt|;
name|struct
name|mbuf_vec
modifier|*
name|mv
decl_stmt|;
name|struct
name|mbuf_iovec
modifier|*
name|tmpmi
decl_stmt|;
name|mv
operator|=
name|mtomv
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|tmpmi
operator|=
name|mv
operator|->
name|mv_vec
expr_stmt|;
name|txd
operator|->
name|flit
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|GET_VTAG_MI
argument_list|(
name|cntrl
argument_list|,
name|mi
argument_list|)
expr_stmt|;
name|cntrl
operator||=
name|V_TXPKT_OPCODE
argument_list|(
name|CPL_TX_PKT_LSO
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|cntrl
operator|=
name|htonl
argument_list|(
name|cntrl
argument_list|)
expr_stmt|;
name|mlen
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|hdr
operator|->
name|len
operator|=
name|htonl
argument_list|(
name|mlen
operator||
literal|0x80000000
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"tso buf len=%d\n"
argument_list|,
name|mlen
argument_list|)
expr_stmt|;
name|undersized
operator|=
operator|(
operator|(
operator|(
name|tmpmi
operator|->
name|mi_len
operator|<
name|TCPPKTHDRSIZE
operator|)
operator|&&
operator|(
name|m0
operator|->
name|m_flags
operator|&
name|M_VLANTAG
operator|)
operator|)
operator|||
operator|(
name|tmpmi
operator|->
name|mi_len
operator|<
name|TCPPKTHDRSIZE
operator|-
name|ETHER_VLAN_ENCAP_LEN
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|undersized
argument_list|)
condition|)
block|{
name|pkthdr
operator|=
name|tmp
expr_stmt|;
name|dump_mi
argument_list|(
name|mi
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"discontig packet - fixxorz"
argument_list|)
expr_stmt|;
block|}
else|else
name|pkthdr
operator|=
name|m0
operator|->
name|m_data
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|m0
operator|->
name|m_flags
operator|&
name|M_VLANTAG
argument_list|)
condition|)
block|{
name|eth_type
operator|=
name|CPL_ETH_II_VLAN
expr_stmt|;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|pkthdr
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
operator|)
expr_stmt|;
block|}
else|else
block|{
name|eth_type
operator|=
name|CPL_ETH_II
expr_stmt|;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|pkthdr
operator|+
name|ETHER_HDR_LEN
operator|)
expr_stmt|;
block|}
name|tcp
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|ip
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
operator|)
expr_stmt|;
name|tso_info
operator||=
name|V_LSO_ETH_TYPE
argument_list|(
name|eth_type
argument_list|)
operator||
name|V_LSO_IPHDR_WORDS
argument_list|(
name|ip
operator|->
name|ip_hl
argument_list|)
operator||
name|V_LSO_TCPHDR_WORDS
argument_list|(
name|tcp
operator|->
name|th_off
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|lso_info
operator|=
name|htonl
argument_list|(
name|tso_info
argument_list|)
expr_stmt|;
name|flits
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|struct
name|cpl_tx_pkt
modifier|*
name|cpl
init|=
operator|(
expr|struct
name|cpl_tx_pkt
operator|*
operator|)
name|txd
decl_stmt|;
name|GET_VTAG
argument_list|(
name|cntrl
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|cntrl
operator||=
name|V_TXPKT_OPCODE
argument_list|(
name|CPL_TX_PKT
argument_list|)
expr_stmt|;
name|cpl
operator|->
name|cntrl
operator|=
name|htonl
argument_list|(
name|cntrl
argument_list|)
expr_stmt|;
name|mlen
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|cpl
operator|->
name|len
operator|=
name|htonl
argument_list|(
name|mlen
operator||
literal|0x80000000
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlen
operator|<=
name|WR_LEN
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|cpl
argument_list|)
condition|)
block|{
name|txq_prod
argument_list|(
name|txq
argument_list|,
literal|1
argument_list|,
operator|&
name|txqs
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"mlen==%d max=%ld\n"
argument_list|,
name|mlen
argument_list|,
operator|(
name|WR_LEN
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|cpl
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mi
operator|->
name|mi_type
operator|!=
name|MT_IOVEC
operator|&&
name|mi
operator|->
name|mi_type
operator|!=
name|MT_CLIOVEC
condition|)
name|memcpy
argument_list|(
operator|&
name|txd
operator|->
name|flit
index|[
literal|2
index|]
argument_list|,
name|mi
operator|->
name|mi_data
argument_list|,
name|mlen
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* 				 * XXX mbuf_iovec 				 */
if|#
directive|if
literal|0
block|m_copydata(m0, 0, mlen, (caddr_t)&txd->flit[2]);
endif|#
directive|endif
name|printf
argument_list|(
literal|"bailing on m_copydata\n"
argument_list|)
expr_stmt|;
block|}
name|m_freem_iovec
argument_list|(
operator|&
name|txsd
operator|->
name|mi
argument_list|)
expr_stmt|;
name|txsd
operator|->
name|mi
operator|.
name|mi_base
operator|=
name|NULL
expr_stmt|;
name|flits
operator|=
operator|(
name|mlen
operator|+
literal|7
operator|)
operator|/
literal|8
operator|+
literal|2
expr_stmt|;
name|cpl
operator|->
name|wr
operator|.
name|wr_hi
operator|=
name|htonl
argument_list|(
name|V_WR_BCNTLFLT
argument_list|(
name|mlen
operator|&
literal|7
argument_list|)
operator||
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_TUNNEL_TX_PKT
argument_list|)
operator||
name|F_WR_SOP
operator||
name|F_WR_EOP
operator||
name|txqs
operator|.
name|compl
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
name|cpl
operator|->
name|wr
operator|.
name|wr_lo
operator|=
name|htonl
argument_list|(
name|V_WR_LEN
argument_list|(
name|flits
argument_list|)
operator||
name|V_WR_GEN
argument_list|(
name|txqs
operator|.
name|gen
argument_list|)
operator||
name|V_WR_TID
argument_list|(
name|txq
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|wr_gen2
argument_list|(
name|txd
argument_list|,
name|txqs
operator|.
name|gen
argument_list|)
expr_stmt|;
name|check_ring_tx_db
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"pio buf\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|DPRINTF
argument_list|(
literal|"regular buf\n"
argument_list|)
expr_stmt|;
name|flits
operator|=
literal|2
expr_stmt|;
block|}
name|wrp
operator|=
operator|(
expr|struct
name|work_request_hdr
operator|*
operator|)
name|txd
expr_stmt|;
ifdef|#
directive|ifdef
name|nomore
comment|/* 	 * XXX need to move into one of the helper routines above 	 * 	 */
if|if
condition|(
operator|(
name|err
operator|=
name|busdma_map_mbufs
argument_list|(
name|m
argument_list|,
name|txq
argument_list|,
name|txsd
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|m0
operator|=
operator|*
name|m
expr_stmt|;
endif|#
directive|endif
name|ndesc
operator|=
name|calc_tx_descs
argument_list|(
name|m0
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
name|sgp
operator|=
operator|(
name|ndesc
operator|==
literal|1
operator|)
condition|?
operator|(
expr|struct
name|sg_ent
operator|*
operator|)
operator|&
name|txd
operator|->
name|flit
index|[
name|flits
index|]
else|:
name|sgl
expr_stmt|;
name|make_sgl
argument_list|(
name|sgp
argument_list|,
name|segs
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
name|sgl_flits
operator|=
name|sgl_len
argument_list|(
name|nsegs
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"make_sgl success nsegs==%d ndesc==%d\n"
argument_list|,
name|nsegs
argument_list|,
name|ndesc
argument_list|)
expr_stmt|;
name|txq_prod
argument_list|(
name|txq
argument_list|,
name|ndesc
argument_list|,
operator|&
name|txqs
argument_list|)
expr_stmt|;
name|wr_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_TUNNEL_TX_PKT
argument_list|)
operator||
name|txqs
operator|.
name|compl
argument_list|)
expr_stmt|;
name|wr_lo
operator|=
name|htonl
argument_list|(
name|V_WR_TID
argument_list|(
name|txq
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|write_wr_hdr_sgl
argument_list|(
name|ndesc
argument_list|,
name|txd
argument_list|,
operator|&
name|txqs
argument_list|,
name|txq
argument_list|,
name|sgl
argument_list|,
name|flits
argument_list|,
name|sgl_flits
argument_list|,
name|wr_hi
argument_list|,
name|wr_lo
argument_list|)
expr_stmt|;
name|check_ring_tx_db
argument_list|(
name|pi
operator|->
name|adapter
argument_list|,
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m0
operator|->
name|m_type
operator|==
name|MT_DATA
operator|)
operator|&&
operator|(
operator|(
name|m0
operator|->
name|m_flags
operator|&
operator|(
name|M_EXT
operator||
name|M_NOFREE
operator|)
operator|)
operator|==
name|M_EXT
operator|)
condition|)
block|{
name|m0
operator|->
name|m_flags
operator|&=
operator|~
name|M_EXT
expr_stmt|;
name|m_free
argument_list|(
name|m0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	write_imm - write a packet into a Tx descriptor as immediate data  *	@d: the Tx descriptor to write  *	@m: the packet  *	@len: the length of packet data to write as immediate data  *	@gen: the generation bit value to write  *  *	Writes a packet as immediate data into a Tx descriptor.  The packet  *	contains a work request at its beginning.  We must write the packet  *	carefully so the SGE doesn't read accidentally before it's written in  *	its entirety.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|write_imm
parameter_list|(
name|struct
name|tx_desc
modifier|*
name|d
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|,
name|unsigned
name|int
name|gen
parameter_list|)
block|{
name|struct
name|work_request_hdr
modifier|*
name|from
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|work_request_hdr
operator|*
argument_list|)
decl_stmt|;
name|struct
name|work_request_hdr
modifier|*
name|to
init|=
operator|(
expr|struct
name|work_request_hdr
operator|*
operator|)
name|d
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|WR_LEN
condition|)
name|panic
argument_list|(
literal|"len too big %d\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|from
argument_list|)
condition|)
name|panic
argument_list|(
literal|"len too small %d"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|to
index|[
literal|1
index|]
argument_list|,
operator|&
name|from
index|[
literal|1
index|]
argument_list|,
name|len
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|to
operator|->
name|wr_hi
operator|=
name|from
operator|->
name|wr_hi
operator||
name|htonl
argument_list|(
name|F_WR_SOP
operator||
name|F_WR_EOP
operator||
name|V_WR_BCNTLFLT
argument_list|(
name|len
operator|&
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
name|to
operator|->
name|wr_lo
operator|=
name|from
operator|->
name|wr_lo
operator||
name|htonl
argument_list|(
name|V_WR_GEN
argument_list|(
name|gen
argument_list|)
operator||
name|V_WR_LEN
argument_list|(
operator|(
name|len
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|wr_gen2
argument_list|(
name|d
argument_list|,
name|gen
argument_list|)
expr_stmt|;
comment|/* 	 * This check is a hack we should really fix the logic so 	 * that this can't happen 	 */
if|if
condition|(
name|m
operator|->
name|m_type
operator|!=
name|MT_DONTFREE
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	check_desc_avail - check descriptor availability on a send queue  *	@adap: the adapter  *	@q: the TX queue  *	@m: the packet needing the descriptors  *	@ndesc: the number of Tx descriptors needed  *	@qid: the Tx queue number in its queue set (TXQ_OFLD or TXQ_CTRL)  *  *	Checks if the requested number of Tx descriptors is available on an  *	SGE send queue.  If the queue is already suspended or not enough  *	descriptors are available the packet is queued for later transmission.  *	Must be called with the Tx queue locked.  *  *	Returns 0 if enough descriptors are available, 1 if there aren't  *	enough descriptors and the packet has been queued, and 2 if the caller  *	needs to retry because there weren't enough descriptors at the  *	beginning of the call but some freed up in the mean time.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|check_desc_avail
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|struct
name|sge_txq
modifier|*
name|q
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|unsigned
name|int
name|ndesc
parameter_list|,
name|unsigned
name|int
name|qid
parameter_list|)
block|{
comment|/*  	 * XXX We currently only use this for checking the control queue 	 * the control queue is only used for binding qsets which happens 	 * at init time so we are guaranteed enough descriptors 	 */
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
name|mbufq_empty
argument_list|(
operator|&
name|q
operator|->
name|sendq
argument_list|)
argument_list|)
condition|)
block|{
name|addq_exit
label|:
name|mbufq_tail
argument_list|(
operator|&
name|q
operator|->
name|sendq
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|__predict_false
argument_list|(
name|q
operator|->
name|size
operator|-
name|q
operator|->
name|in_use
operator|<
name|ndesc
argument_list|)
condition|)
block|{
name|struct
name|sge_qset
modifier|*
name|qs
init|=
name|txq_to_qset
argument_list|(
name|q
argument_list|,
name|qid
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"stopping q\n"
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
operator|&
name|qs
operator|->
name|txq_stopped
argument_list|,
name|qid
argument_list|)
expr_stmt|;
name|smp_mb
argument_list|()
expr_stmt|;
if|if
condition|(
name|should_restart_tx
argument_list|(
name|q
argument_list|)
operator|&&
name|test_and_clear_bit
argument_list|(
name|qid
argument_list|,
operator|&
name|qs
operator|->
name|txq_stopped
argument_list|)
condition|)
return|return
literal|2
return|;
name|q
operator|->
name|stops
operator|++
expr_stmt|;
goto|goto
name|addq_exit
goto|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *	reclaim_completed_tx_imm - reclaim completed control-queue Tx descs  *	@q: the SGE control Tx queue  *  *	This is a variant of reclaim_completed_tx() that is used for Tx queues  *	that send only immediate data (presently just the control queues) and  *	thus do not have any mbufs  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|reclaim_completed_tx_imm
parameter_list|(
name|struct
name|sge_txq
modifier|*
name|q
parameter_list|)
block|{
name|unsigned
name|int
name|reclaim
init|=
name|q
operator|->
name|processed
operator|-
name|q
operator|->
name|cleaned
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|q
operator|->
name|lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|q
operator|->
name|in_use
operator|-=
name|reclaim
expr_stmt|;
name|q
operator|->
name|cleaned
operator|+=
name|reclaim
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|immediate
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
return|return
name|m
operator|->
name|m_len
operator|<=
name|WR_LEN
operator|&&
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<=
name|WR_LEN
return|;
block|}
end_function

begin_comment
comment|/**  *	ctrl_xmit - send a packet through an SGE control Tx queue  *	@adap: the adapter  *	@q: the control queue  *	@m: the packet  *  *	Send a packet through an SGE control Tx queue.  Packets sent through  *	a control queue must fit entirely as immediate data in a single Tx  *	descriptor and have no page fragments.  */
end_comment

begin_function
specifier|static
name|int
name|ctrl_xmit
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|struct
name|sge_txq
modifier|*
name|q
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|struct
name|work_request_hdr
modifier|*
name|wrp
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|work_request_hdr
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
name|immediate
argument_list|(
name|m
argument_list|)
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|wrp
operator|->
name|wr_hi
operator||=
name|htonl
argument_list|(
name|F_WR_SOP
operator||
name|F_WR_EOP
argument_list|)
expr_stmt|;
name|wrp
operator|->
name|wr_lo
operator|=
name|htonl
argument_list|(
name|V_WR_TID
argument_list|(
name|q
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|q
operator|->
name|lock
argument_list|)
expr_stmt|;
name|again
label|:
name|reclaim_completed_tx_imm
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|ret
operator|=
name|check_desc_avail
argument_list|(
name|adap
argument_list|,
name|q
argument_list|,
name|m
argument_list|,
literal|1
argument_list|,
name|TXQ_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|ret
argument_list|)
condition|)
block|{
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|q
operator|->
name|lock
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no desc available\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
goto|goto
name|again
goto|;
block|}
name|write_imm
argument_list|(
operator|&
name|q
operator|->
name|desc
index|[
name|q
operator|->
name|pidx
index|]
argument_list|,
name|m
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|q
operator|->
name|gen
argument_list|)
expr_stmt|;
name|q
operator|->
name|in_use
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|q
operator|->
name|pidx
operator|>=
name|q
operator|->
name|size
condition|)
block|{
name|q
operator|->
name|pidx
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|gen
operator|^=
literal|1
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|q
operator|->
name|lock
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_KDOORBELL
argument_list|,
name|F_SELEGRCNTX
operator||
name|V_EGRCNTX
argument_list|(
name|q
operator|->
name|cntxt_id
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	restart_ctrlq - restart a suspended control queue  *	@qs: the queue set cotaining the control queue  *  *	Resumes transmission on a suspended Tx control queue.  */
end_comment

begin_function
specifier|static
name|void
name|restart_ctrlq
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sge_qset
modifier|*
name|qs
init|=
operator|(
expr|struct
name|sge_qset
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|q
init|=
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
decl_stmt|;
name|adapter_t
modifier|*
name|adap
init|=
name|qs
operator|->
name|port
operator|->
name|adapter
decl_stmt|;
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"Restart_ctrlq in_use=%d\n"
argument_list|,
name|q
operator|->
name|in_use
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|q
operator|->
name|lock
argument_list|)
expr_stmt|;
name|again
label|:
name|reclaim_completed_tx_imm
argument_list|(
name|q
argument_list|)
expr_stmt|;
while|while
condition|(
name|q
operator|->
name|in_use
operator|<
name|q
operator|->
name|size
operator|&&
operator|(
name|m
operator|=
name|mbufq_dequeue
argument_list|(
operator|&
name|q
operator|->
name|sendq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|write_imm
argument_list|(
operator|&
name|q
operator|->
name|desc
index|[
name|q
operator|->
name|pidx
index|]
argument_list|,
name|m
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|q
operator|->
name|gen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|q
operator|->
name|pidx
operator|>=
name|q
operator|->
name|size
condition|)
block|{
name|q
operator|->
name|pidx
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|gen
operator|^=
literal|1
expr_stmt|;
block|}
name|q
operator|->
name|in_use
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mbufq_empty
argument_list|(
operator|&
name|q
operator|->
name|sendq
argument_list|)
condition|)
block|{
name|setbit
argument_list|(
operator|&
name|qs
operator|->
name|txq_stopped
argument_list|,
name|TXQ_CTRL
argument_list|)
expr_stmt|;
name|smp_mb
argument_list|()
expr_stmt|;
if|if
condition|(
name|should_restart_tx
argument_list|(
name|q
argument_list|)
operator|&&
name|test_and_clear_bit
argument_list|(
name|TXQ_CTRL
argument_list|,
operator|&
name|qs
operator|->
name|txq_stopped
argument_list|)
condition|)
goto|goto
name|again
goto|;
name|q
operator|->
name|stops
operator|++
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|q
operator|->
name|lock
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_KDOORBELL
argument_list|,
name|F_SELEGRCNTX
operator||
name|V_EGRCNTX
argument_list|(
name|q
operator|->
name|cntxt_id
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send a management message through control queue 0  */
end_comment

begin_function
name|int
name|t3_mgmt_tx
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
return|return
name|ctrl_xmit
argument_list|(
name|adap
argument_list|,
operator|&
name|adap
operator|->
name|sge
operator|.
name|qs
index|[
literal|0
index|]
operator|.
name|txq
index|[
name|TXQ_CTRL
index|]
argument_list|,
name|m
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	free_qset - free the resources of an SGE queue set  *	@sc: the controller owning the queue set  *	@q: the queue set  *  *	Release the HW and SW resources associated with an SGE queue set, such  *	as HW contexts, packet buffers, and descriptor rings.  Traffic to the  *	queue set must be quiesced prior to calling this.  */
end_comment

begin_function
name|void
name|t3_free_qset
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|,
name|struct
name|sge_qset
modifier|*
name|q
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|t3_free_tx_desc_all
argument_list|(
operator|&
name|q
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SGE_TXQ_PER_SET
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|txq_mr
operator|.
name|br_ring
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|txq_mr
operator|.
name|br_ring
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|txq_mr
operator|.
name|br_lock
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SGE_RXQ_PER_SET
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|desc
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
name|t3_sge_disable_fl
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|cntxt_id
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|desc_tag
argument_list|,
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|desc_map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|desc_tag
argument_list|,
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|desc
argument_list|,
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|desc_map
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|desc_tag
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|entry_tag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|sdesc
condition|)
block|{
name|free_rx_bufs
argument_list|(
name|sc
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|sdesc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SGE_TXQ_PER_SET
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|desc
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
name|t3_sge_enable_ecntxt
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|cntxt_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|desc_tag
argument_list|,
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|desc_map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|desc_tag
argument_list|,
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|desc
argument_list|,
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|desc_map
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|desc_tag
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|entry_tag
argument_list|)
expr_stmt|;
name|MTX_DESTROY
argument_list|(
operator|&
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|sdesc
condition|)
block|{
name|free
argument_list|(
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|sdesc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|q
operator|->
name|rspq
operator|.
name|desc
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
name|t3_sge_disable_rspcntxt
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|rspq
operator|.
name|cntxt_id
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|q
operator|->
name|rspq
operator|.
name|desc_tag
argument_list|,
name|q
operator|->
name|rspq
operator|.
name|desc_map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|q
operator|->
name|rspq
operator|.
name|desc_tag
argument_list|,
name|q
operator|->
name|rspq
operator|.
name|desc
argument_list|,
name|q
operator|->
name|rspq
operator|.
name|desc_map
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|q
operator|->
name|rspq
operator|.
name|desc_tag
argument_list|)
expr_stmt|;
name|MTX_DESTROY
argument_list|(
operator|&
name|q
operator|->
name|rspq
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
name|q
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|q
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t3_free_sge_resources - free SGE resources  *	@sc: the adapter softc  *  *	Frees resources used by the SGE queue sets.  */
end_comment

begin_function
name|void
name|t3_free_sge_resources
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|nqsets
decl_stmt|;
ifdef|#
directive|ifdef
name|IFNET_MULTIQUEUE
name|panic
argument_list|(
literal|"%s should not be called when IFNET_MULTIQUEUE is defined"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|nqsets
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|sc
operator|)
operator|->
name|params
operator|.
name|nports
condition|;
name|i
operator|++
control|)
name|nqsets
operator|+=
name|sc
operator|->
name|port
index|[
name|i
index|]
operator|.
name|nqsets
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nqsets
condition|;
operator|++
name|i
control|)
name|t3_free_qset
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t3_sge_start - enable SGE  *	@sc: the controller softc  *  *	Enables the SGE for DMAs.  This is the last step in starting packet  *	transfers.  */
end_comment

begin_function
name|void
name|t3_sge_start
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|)
block|{
name|t3_set_reg_field
argument_list|(
name|sc
argument_list|,
name|A_SG_CONTROL
argument_list|,
name|F_GLOBALENABLE
argument_list|,
name|F_GLOBALENABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t3_sge_stop - disable SGE operation  *	@sc: the adapter  *  *	Disables the DMA engine.  This can be called in emeregencies (e.g.,  *	from error interrupts) or from normal process context.  In the latter  *	case it also disables any pending queue restart tasklets.  Note that  *	if it is called in interrupt context it cannot disable the restart  *	tasklets as it cannot wait, however the tasklets will have no effect  *	since the doorbells are disabled and the driver will call this again  *	later from process context, at which time the tasklets will be stopped  *	if they are still running.  */
end_comment

begin_function
name|void
name|t3_sge_stop
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|nqsets
decl_stmt|;
name|t3_set_reg_field
argument_list|(
name|sc
argument_list|,
name|A_SG_CONTROL
argument_list|,
name|F_GLOBALENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tq
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|nqsets
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|sc
operator|)
operator|->
name|params
operator|.
name|nports
condition|;
name|i
operator|++
control|)
name|nqsets
operator|+=
name|sc
operator|->
name|port
index|[
name|i
index|]
operator|.
name|nqsets
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nqsets
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|sge_qset
modifier|*
name|qs
init|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
name|i
index|]
decl_stmt|;
name|taskqueue_drain
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
operator|.
name|qresume_task
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
operator|.
name|qresume_task
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	t3_free_tx_desc - reclaims Tx descriptors and their buffers  *	@adapter: the adapter  *	@q: the Tx queue to reclaim descriptors from  *	@reclaimable: the number of descriptors to reclaim  *      @m_vec_size: maximum number of buffers to reclaim  *      @desc_reclaimed: returns the number of descriptors reclaimed  *  *	Reclaims Tx descriptors from an SGE Tx queue and frees the associated  *	Tx buffers.  Called with the Tx queue lock held.  *  *      Returns number of buffers of reclaimed     */
end_comment

begin_function
name|void
name|t3_free_tx_desc
parameter_list|(
name|struct
name|sge_txq
modifier|*
name|q
parameter_list|,
name|int
name|reclaimable
parameter_list|)
block|{
name|struct
name|tx_sw_desc
modifier|*
name|txsd
decl_stmt|;
name|unsigned
name|int
name|cidx
decl_stmt|;
ifdef|#
directive|ifdef
name|T3_TRACE
name|T3_TRACE2
argument_list|(
name|sc
operator|->
name|tb
index|[
name|q
operator|->
name|cntxt_id
operator|&
literal|7
index|]
argument_list|,
literal|"reclaiming %u Tx descriptors at cidx %u"
argument_list|,
name|reclaimable
argument_list|,
name|cidx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cidx
operator|=
name|q
operator|->
name|cidx
expr_stmt|;
name|txsd
operator|=
operator|&
name|q
operator|->
name|sdesc
index|[
name|cidx
index|]
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"reclaiming %d WR\n"
argument_list|,
name|reclaimable
argument_list|)
expr_stmt|;
while|while
condition|(
name|reclaimable
operator|--
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"cidx=%d d=%p\n"
argument_list|,
name|cidx
argument_list|,
name|txsd
argument_list|)
expr_stmt|;
if|if
condition|(
name|txsd
operator|->
name|mi
operator|.
name|mi_base
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|txsd
operator|->
name|flags
operator|&
name|TX_SW_DESC_MAPPED
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|q
operator|->
name|entry_tag
argument_list|,
name|txsd
operator|->
name|map
argument_list|)
expr_stmt|;
name|txsd
operator|->
name|flags
operator|&=
operator|~
name|TX_SW_DESC_MAPPED
expr_stmt|;
block|}
name|m_freem_iovec
argument_list|(
operator|&
name|txsd
operator|->
name|mi
argument_list|)
expr_stmt|;
name|txsd
operator|->
name|mi
operator|.
name|mi_base
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DIAGNOSTIC
argument_list|)
operator|&&
literal|0
if|if
condition|(
name|m_get_priority
argument_list|(
name|txsd
operator|->
name|m
index|[
literal|0
index|]
argument_list|)
operator|!=
name|cidx
condition|)
name|printf
argument_list|(
literal|"pri=%d cidx=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|m_get_priority
argument_list|(
name|txsd
operator|->
name|m
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|cidx
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|q
operator|->
name|txq_skipped
operator|++
expr_stmt|;
operator|++
name|txsd
expr_stmt|;
if|if
condition|(
operator|++
name|cidx
operator|==
name|q
operator|->
name|size
condition|)
block|{
name|cidx
operator|=
literal|0
expr_stmt|;
name|txsd
operator|=
name|q
operator|->
name|sdesc
expr_stmt|;
block|}
block|}
name|q
operator|->
name|cidx
operator|=
name|cidx
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t3_free_tx_desc_all
parameter_list|(
name|struct
name|sge_txq
modifier|*
name|q
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|tx_sw_desc
modifier|*
name|txsd
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|q
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
name|txsd
operator|=
operator|&
name|q
operator|->
name|sdesc
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|txsd
operator|->
name|mi
operator|.
name|mi_base
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|txsd
operator|->
name|flags
operator|&
name|TX_SW_DESC_MAPPED
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|q
operator|->
name|entry_tag
argument_list|,
name|txsd
operator|->
name|map
argument_list|)
expr_stmt|;
name|txsd
operator|->
name|flags
operator|&=
operator|~
name|TX_SW_DESC_MAPPED
expr_stmt|;
block|}
name|m_freem_iovec
argument_list|(
operator|&
name|txsd
operator|->
name|mi
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|txsd
operator|->
name|mi
argument_list|,
sizeof|sizeof
argument_list|(
name|txsd
operator|->
name|mi
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  *	is_new_response - check if a response is newly written  *	@r: the response descriptor  *	@q: the response queue  *  *	Returns true if a response descriptor contains a yet unprocessed  *	response.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|is_new_response
parameter_list|(
specifier|const
name|struct
name|rsp_desc
modifier|*
name|r
parameter_list|,
specifier|const
name|struct
name|sge_rspq
modifier|*
name|q
parameter_list|)
block|{
return|return
operator|(
name|r
operator|->
name|intr_gen
operator|&
name|F_RSPD_GEN2
operator|)
operator|==
name|q
operator|->
name|gen
return|;
block|}
end_function

begin_define
define|#
directive|define
name|RSPD_GTS_MASK
value|(F_RSPD_TXQ0_GTS | F_RSPD_TXQ1_GTS)
end_define

begin_define
define|#
directive|define
name|RSPD_CTRL_MASK
value|(RSPD_GTS_MASK | \ 			V_RSPD_TXQ0_CR(M_RSPD_TXQ0_CR) | \ 			V_RSPD_TXQ1_CR(M_RSPD_TXQ1_CR) | \ 			V_RSPD_TXQ2_CR(M_RSPD_TXQ2_CR))
end_define

begin_comment
comment|/* How long to delay the next interrupt in case of memory shortage, in 0.1us. */
end_comment

begin_define
define|#
directive|define
name|NOMEM_INTR_DELAY
value|2500
end_define

begin_comment
comment|/**  *	write_ofld_wr - write an offload work request  *	@adap: the adapter  *	@m: the packet to send  *	@q: the Tx queue  *	@pidx: index of the first Tx descriptor to write  *	@gen: the generation value to use  *	@ndesc: number of descriptors the packet will occupy  *  *	Write an offload work request to send the supplied packet.  The packet  *	data already carry the work request with most fields populated.  */
end_comment

begin_function
specifier|static
name|void
name|write_ofld_wr
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sge_txq
modifier|*
name|q
parameter_list|,
name|unsigned
name|int
name|pidx
parameter_list|,
name|unsigned
name|int
name|gen
parameter_list|,
name|unsigned
name|int
name|ndesc
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|unsigned
name|int
name|nsegs
parameter_list|)
block|{
name|unsigned
name|int
name|sgl_flits
decl_stmt|,
name|flits
decl_stmt|;
name|struct
name|work_request_hdr
modifier|*
name|from
decl_stmt|;
name|struct
name|sg_ent
modifier|*
name|sgp
decl_stmt|,
name|sgl
index|[
name|TX_MAX_SEGS
operator|/
literal|2
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|tx_desc
modifier|*
name|d
init|=
operator|&
name|q
operator|->
name|desc
index|[
name|pidx
index|]
decl_stmt|;
name|struct
name|txq_state
name|txqs
decl_stmt|;
if|if
condition|(
name|immediate
argument_list|(
name|m
argument_list|)
operator|&&
name|segs
operator|==
name|NULL
condition|)
block|{
name|write_imm
argument_list|(
name|d
argument_list|,
name|m
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|gen
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Only TX_DATA builds SGLs */
name|from
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|work_request_hdr
operator|*
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|d
operator|->
name|flit
index|[
literal|1
index|]
argument_list|,
operator|&
name|from
index|[
literal|1
index|]
argument_list|,
name|m
operator|->
name|m_len
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|flits
operator|=
name|m
operator|->
name|m_len
operator|/
literal|8
expr_stmt|;
name|sgp
operator|=
operator|(
name|ndesc
operator|==
literal|1
operator|)
condition|?
operator|(
expr|struct
name|sg_ent
operator|*
operator|)
operator|&
name|d
operator|->
name|flit
index|[
name|flits
index|]
else|:
name|sgl
expr_stmt|;
name|make_sgl
argument_list|(
name|sgp
argument_list|,
name|segs
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
name|sgl_flits
operator|=
name|sgl_len
argument_list|(
name|nsegs
argument_list|)
expr_stmt|;
name|txqs
operator|.
name|gen
operator|=
name|gen
expr_stmt|;
name|txqs
operator|.
name|pidx
operator|=
name|pidx
expr_stmt|;
name|txqs
operator|.
name|compl
operator|=
literal|0
expr_stmt|;
name|write_wr_hdr_sgl
argument_list|(
name|ndesc
argument_list|,
name|d
argument_list|,
operator|&
name|txqs
argument_list|,
name|q
argument_list|,
name|sgl
argument_list|,
name|flits
argument_list|,
name|sgl_flits
argument_list|,
name|from
operator|->
name|wr_hi
argument_list|,
name|from
operator|->
name|wr_lo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	calc_tx_descs_ofld - calculate # of Tx descriptors for an offload packet  *	@m: the packet  *  * 	Returns the number of Tx descriptors needed for the given offload  * 	packet.  These packets are already fully constructed.  */
end_comment

begin_function
specifier|static
name|__inline
name|unsigned
name|int
name|calc_tx_descs_ofld
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|unsigned
name|int
name|nsegs
parameter_list|)
block|{
name|unsigned
name|int
name|flits
decl_stmt|,
name|cnt
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<=
name|WR_LEN
condition|)
return|return
literal|1
return|;
comment|/* packet fits as immediate data */
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_IOVEC
condition|)
name|cnt
operator|=
name|mtomv
argument_list|(
name|m
argument_list|)
operator|->
name|mv_count
expr_stmt|;
comment|/* headers */
name|flits
operator|=
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|header
operator|-
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|)
operator|/
literal|8
expr_stmt|;
return|return
name|flits_to_desc
argument_list|(
name|flits
operator|+
name|sgl_len
argument_list|(
name|cnt
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	ofld_xmit - send a packet through an offload queue  *	@adap: the adapter  *	@q: the Tx offload queue  *	@m: the packet  *  *	Send an offload packet through an SGE offload queue.  */
end_comment

begin_function
specifier|static
name|int
name|ofld_xmit
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|struct
name|sge_txq
modifier|*
name|q
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|nsegs
decl_stmt|;
name|unsigned
name|int
name|ndesc
decl_stmt|;
name|unsigned
name|int
name|pidx
decl_stmt|,
name|gen
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
name|TX_MAX_SEGS
index|]
decl_stmt|,
modifier|*
name|vsegs
decl_stmt|;
name|struct
name|tx_sw_desc
modifier|*
name|stx
decl_stmt|;
name|nsegs
operator|=
name|m_get_sgllen
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vsegs
operator|=
name|m_get_sgl
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ndesc
operator|=
name|calc_tx_descs_ofld
argument_list|(
name|m
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
name|busdma_map_sgl
argument_list|(
name|vsegs
argument_list|,
name|segs
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
name|stx
operator|=
operator|&
name|q
operator|->
name|sdesc
index|[
name|q
operator|->
name|pidx
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|stx
operator|->
name|mi
operator|.
name|mi_base
operator|==
name|NULL
argument_list|,
operator|(
literal|"mi_base set"
operator|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|q
operator|->
name|lock
argument_list|)
expr_stmt|;
name|again
label|:
name|reclaim_completed_tx_
argument_list|(
name|q
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|ret
operator|=
name|check_desc_avail
argument_list|(
name|adap
argument_list|,
name|q
argument_list|,
name|m
argument_list|,
name|ndesc
argument_list|,
name|TXQ_OFLD
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|ret
argument_list|)
condition|)
block|{
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"no ofld desc avail\n"
argument_list|)
expr_stmt|;
name|m_set_priority
argument_list|(
name|m
argument_list|,
name|ndesc
argument_list|)
expr_stmt|;
comment|/* save for restart */
name|mtx_unlock
argument_list|(
operator|&
name|q
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINTR
operator|)
return|;
block|}
goto|goto
name|again
goto|;
block|}
name|gen
operator|=
name|q
operator|->
name|gen
expr_stmt|;
name|q
operator|->
name|in_use
operator|+=
name|ndesc
expr_stmt|;
name|pidx
operator|=
name|q
operator|->
name|pidx
expr_stmt|;
name|q
operator|->
name|pidx
operator|+=
name|ndesc
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|pidx
operator|>=
name|q
operator|->
name|size
condition|)
block|{
name|q
operator|->
name|pidx
operator|-=
name|q
operator|->
name|size
expr_stmt|;
name|q
operator|->
name|gen
operator|^=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|T3_TRACE
name|T3_TRACE5
argument_list|(
name|adap
operator|->
name|tb
index|[
name|q
operator|->
name|cntxt_id
operator|&
literal|7
index|]
argument_list|,
literal|"ofld_xmit: ndesc %u, pidx %u, len %u, main %u, frags %u"
argument_list|,
name|ndesc
argument_list|,
name|pidx
argument_list|,
name|skb
operator|->
name|len
argument_list|,
name|skb
operator|->
name|len
operator|-
name|skb
operator|->
name|data_len
argument_list|,
name|skb_shinfo
argument_list|(
name|skb
argument_list|)
operator|->
name|nr_frags
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mtx_unlock
argument_list|(
operator|&
name|q
operator|->
name|lock
argument_list|)
expr_stmt|;
name|write_ofld_wr
argument_list|(
name|adap
argument_list|,
name|m
argument_list|,
name|q
argument_list|,
name|pidx
argument_list|,
name|gen
argument_list|,
name|ndesc
argument_list|,
name|segs
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
name|check_ring_tx_db
argument_list|(
name|adap
argument_list|,
name|q
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	restart_offloadq - restart a suspended offload queue  *	@qs: the queue set cotaining the offload queue  *  *	Resumes transmission on a suspended Tx offload queue.  */
end_comment

begin_function
specifier|static
name|void
name|restart_offloadq
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sge_qset
modifier|*
name|qs
init|=
name|data
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|q
init|=
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
decl_stmt|;
name|adapter_t
modifier|*
name|adap
init|=
name|qs
operator|->
name|port
operator|->
name|adapter
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
name|TX_MAX_SEGS
index|]
decl_stmt|;
name|struct
name|tx_sw_desc
modifier|*
name|stx
init|=
operator|&
name|q
operator|->
name|sdesc
index|[
name|q
operator|->
name|pidx
index|]
decl_stmt|;
name|int
name|nsegs
decl_stmt|,
name|cleaned
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|q
operator|->
name|lock
argument_list|)
expr_stmt|;
name|again
label|:
name|cleaned
operator|=
name|reclaim_completed_tx_
argument_list|(
name|q
argument_list|,
literal|16
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|mbufq_peek
argument_list|(
operator|&
name|q
operator|->
name|sendq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|int
name|gen
decl_stmt|,
name|pidx
decl_stmt|;
name|unsigned
name|int
name|ndesc
init|=
name|m_get_priority
argument_list|(
name|m
argument_list|)
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|q
operator|->
name|size
operator|-
name|q
operator|->
name|in_use
operator|<
name|ndesc
argument_list|)
condition|)
block|{
name|setbit
argument_list|(
operator|&
name|qs
operator|->
name|txq_stopped
argument_list|,
name|TXQ_OFLD
argument_list|)
expr_stmt|;
name|smp_mb
argument_list|()
expr_stmt|;
if|if
condition|(
name|should_restart_tx
argument_list|(
name|q
argument_list|)
operator|&&
name|test_and_clear_bit
argument_list|(
name|TXQ_OFLD
argument_list|,
operator|&
name|qs
operator|->
name|txq_stopped
argument_list|)
condition|)
goto|goto
name|again
goto|;
name|q
operator|->
name|stops
operator|++
expr_stmt|;
break|break;
block|}
name|gen
operator|=
name|q
operator|->
name|gen
expr_stmt|;
name|q
operator|->
name|in_use
operator|+=
name|ndesc
expr_stmt|;
name|pidx
operator|=
name|q
operator|->
name|pidx
expr_stmt|;
name|q
operator|->
name|pidx
operator|+=
name|ndesc
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|pidx
operator|>=
name|q
operator|->
name|size
condition|)
block|{
name|q
operator|->
name|pidx
operator|-=
name|q
operator|->
name|size
expr_stmt|;
name|q
operator|->
name|gen
operator|^=
literal|1
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|mbufq_dequeue
argument_list|(
operator|&
name|q
operator|->
name|sendq
argument_list|)
expr_stmt|;
name|busdma_map_mbufs
argument_list|(
operator|&
name|m
argument_list|,
name|q
argument_list|,
name|stx
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|q
operator|->
name|lock
argument_list|)
expr_stmt|;
name|write_ofld_wr
argument_list|(
name|adap
argument_list|,
name|m
argument_list|,
name|q
argument_list|,
name|pidx
argument_list|,
name|gen
argument_list|,
name|ndesc
argument_list|,
name|segs
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|q
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|q
operator|->
name|lock
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_GTS
name|set_bit
argument_list|(
name|TXQ_RUNNING
argument_list|,
operator|&
name|q
operator|->
name|flags
argument_list|)
expr_stmt|;
name|set_bit
argument_list|(
name|TXQ_LAST_PKT_DB
argument_list|,
operator|&
name|q
operator|->
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_KDOORBELL
argument_list|,
name|F_SELEGRCNTX
operator||
name|V_EGRCNTX
argument_list|(
name|q
operator|->
name|cntxt_id
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	queue_set - return the queue set a packet should use  *	@m: the packet  *  *	Maps a packet to the SGE queue set it should use.  The desired queue  *	set is carried in bits 1-3 in the packet's priority.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|queue_set
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
return|return
name|m_get_priority
argument_list|(
name|m
argument_list|)
operator|>>
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  *	is_ctrl_pkt - return whether an offload packet is a control packet  *	@m: the packet  *  *	Determines whether an offload packet should use an OFLD or a CTRL  *	Tx queue.  This is indicated by bit 0 in the packet's priority.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|is_ctrl_pkt
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
return|return
name|m_get_priority
argument_list|(
name|m
argument_list|)
operator|&
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_offload_tx - send an offload packet  *	@tdev: the offload device to send to  *	@m: the packet  *  *	Sends an offload packet.  We use the packet priority to select the  *	appropriate Tx queue as follows: bit 0 indicates whether the packet  *	should be sent as regular or control, bits 1-3 select the queue set.  */
end_comment

begin_function
name|int
name|t3_offload_tx
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|tdev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|adapter_t
modifier|*
name|adap
init|=
name|tdev2adap
argument_list|(
name|tdev
argument_list|)
decl_stmt|;
name|struct
name|sge_qset
modifier|*
name|qs
init|=
operator|&
name|adap
operator|->
name|sge
operator|.
name|qs
index|[
name|queue_set
argument_list|(
name|m
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|is_ctrl_pkt
argument_list|(
name|m
argument_list|)
argument_list|)
condition|)
return|return
name|ctrl_xmit
argument_list|(
name|adap
argument_list|,
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
argument_list|,
name|m
argument_list|)
return|;
return|return
name|ofld_xmit
argument_list|(
name|adap
argument_list|,
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
argument_list|,
name|m
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	deliver_partial_bundle - deliver a (partial) bundle of Rx offload pkts  *	@tdev: the offload device that will be receiving the packets  *	@q: the SGE response queue that assembled the bundle  *	@m: the partial bundle  *	@n: the number of packets in the bundle  *  *	Delivers a (partial) bundle of Rx offload packets to an offload device.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|deliver_partial_bundle
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|tdev
parameter_list|,
name|struct
name|sge_rspq
modifier|*
name|q
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mbufs
index|[]
parameter_list|,
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
name|n
condition|)
block|{
name|q
operator|->
name|offload_bundles
operator|++
expr_stmt|;
name|cxgb_ofld_recv
argument_list|(
name|tdev
argument_list|,
name|mbufs
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|rx_offload
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|tdev
parameter_list|,
name|struct
name|sge_rspq
modifier|*
name|rq
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|mbuf
modifier|*
name|rx_gather
index|[]
parameter_list|,
name|unsigned
name|int
name|gather_idx
parameter_list|)
block|{
name|rq
operator|->
name|offload_pkts
operator|++
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|header
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
name|rx_gather
index|[
name|gather_idx
operator|++
index|]
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|gather_idx
operator|==
name|RX_BUNDLE_SIZE
condition|)
block|{
name|cxgb_ofld_recv
argument_list|(
name|tdev
argument_list|,
name|rx_gather
argument_list|,
name|RX_BUNDLE_SIZE
argument_list|)
expr_stmt|;
name|gather_idx
operator|=
literal|0
expr_stmt|;
name|rq
operator|->
name|offload_bundles
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|gather_idx
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|restart_tx
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|qs
operator|->
name|port
operator|->
name|adapter
decl_stmt|;
if|if
condition|(
name|isset
argument_list|(
operator|&
name|qs
operator|->
name|txq_stopped
argument_list|,
name|TXQ_OFLD
argument_list|)
operator|&&
name|should_restart_tx
argument_list|(
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
argument_list|)
operator|&&
name|test_and_clear_bit
argument_list|(
name|TXQ_OFLD
argument_list|,
operator|&
name|qs
operator|->
name|txq_stopped
argument_list|)
condition|)
block|{
name|qs
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
operator|.
name|restarts
operator|++
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"restarting TXQ_OFLD\n"
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
operator|.
name|qresume_task
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|"stopped=0x%x restart=%d processed=%d cleaned=%d in_use=%d\n"
argument_list|,
name|qs
operator|->
name|txq_stopped
argument_list|,
name|should_restart_tx
argument_list|(
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
argument_list|)
argument_list|,
name|qs
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
operator|.
name|processed
argument_list|,
name|qs
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
operator|.
name|cleaned
argument_list|,
name|qs
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
operator|.
name|in_use
argument_list|)
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
operator|&
name|qs
operator|->
name|txq_stopped
argument_list|,
name|TXQ_CTRL
argument_list|)
operator|&&
name|should_restart_tx
argument_list|(
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
argument_list|)
operator|&&
name|test_and_clear_bit
argument_list|(
name|TXQ_CTRL
argument_list|,
operator|&
name|qs
operator|->
name|txq_stopped
argument_list|)
condition|)
block|{
name|qs
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
operator|.
name|restarts
operator|++
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"restarting TXQ_CTRL\n"
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
operator|.
name|qresume_task
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  *	t3_sge_alloc_qset - initialize an SGE queue set  *	@sc: the controller softc  *	@id: the queue set id  *	@nports: how many Ethernet ports will be using this queue set  *	@irq_vec_idx: the IRQ vector index for response queue interrupts  *	@p: configuration parameters for this queue set  *	@ntxq: number of Tx queues for the queue set  *	@pi: port info for queue set  *  *	Allocate resources and initialize an SGE queue set.  A queue set  *	comprises a response queue, two Rx free-buffer queues, and up to 3  *	Tx queues.  The Tx queues are assigned roles in the order Ethernet  *	queue, offload queue, and control queue.  */
end_comment

begin_function
name|int
name|t3_sge_alloc_qset
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|,
name|u_int
name|id
parameter_list|,
name|int
name|nports
parameter_list|,
name|int
name|irq_vec_idx
parameter_list|,
specifier|const
name|struct
name|qset_params
modifier|*
name|p
parameter_list|,
name|int
name|ntxq
parameter_list|,
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|sge_qset
modifier|*
name|q
init|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
name|id
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|header_size
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SGE_TXQ_PER_SET
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|txq_mr
operator|.
name|br_ring
operator|=
name|malloc
argument_list|(
name|cxgb_txq_buf_ring_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mbuf
operator|*
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to allocate mbuf ring\n"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|txq_mr
operator|.
name|br_prod
operator|=
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|txq_mr
operator|.
name|br_cons
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|txq_mr
operator|.
name|br_size
operator|=
name|cxgb_txq_buf_ring_size
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|txq_mr
operator|.
name|br_lock
argument_list|,
literal|"txq mbuf ring"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
block|}
name|init_qset_cntxt
argument_list|(
name|q
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|alloc_ring
argument_list|(
name|sc
argument_list|,
name|p
operator|->
name|fl_size
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rx_desc
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rx_sw_desc
argument_list|)
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|phys_addr
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|desc
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|sdesc
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|desc_tag
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|desc_map
argument_list|,
name|sc
operator|->
name|rx_dmat
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|entry_tag
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"error %d from alloc ring fl0\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|(
name|ret
operator|=
name|alloc_ring
argument_list|(
name|sc
argument_list|,
name|p
operator|->
name|jumbo_size
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rx_desc
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rx_sw_desc
argument_list|)
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|phys_addr
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|desc
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|sdesc
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|desc_tag
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|desc_map
argument_list|,
name|sc
operator|->
name|rx_jumbo_dmat
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|entry_tag
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"error %d from alloc ring fl1\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|(
name|ret
operator|=
name|alloc_ring
argument_list|(
name|sc
argument_list|,
name|p
operator|->
name|rspq_size
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rsp_desc
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|q
operator|->
name|rspq
operator|.
name|phys_addr
argument_list|,
operator|&
name|q
operator|->
name|rspq
operator|.
name|desc
argument_list|,
name|NULL
argument_list|,
operator|&
name|q
operator|->
name|rspq
operator|.
name|desc_tag
argument_list|,
operator|&
name|q
operator|->
name|rspq
operator|.
name|desc_map
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"error %d from alloc ring rspq\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntxq
condition|;
operator|++
name|i
control|)
block|{
comment|/* 		 * The control queue always uses immediate data so does not 		 * need to keep track of any mbufs. 		 * XXX Placeholder for future TOE support. 		 */
name|size_t
name|sz
init|=
name|i
operator|==
name|TXQ_CTRL
condition|?
literal|0
else|:
sizeof|sizeof
argument_list|(
expr|struct
name|tx_sw_desc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|alloc_ring
argument_list|(
name|sc
argument_list|,
name|p
operator|->
name|txq_size
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tx_desc
argument_list|)
argument_list|,
name|sz
argument_list|,
operator|&
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|phys_addr
argument_list|,
operator|&
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|desc
argument_list|,
operator|&
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|sdesc
argument_list|,
operator|&
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|desc_tag
argument_list|,
operator|&
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|desc_map
argument_list|,
name|sc
operator|->
name|tx_dmat
argument_list|,
operator|&
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|entry_tag
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"error %d from alloc ring tx %i\n"
argument_list|,
name|ret
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|mbufq_init
argument_list|(
operator|&
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|sendq
argument_list|)
expr_stmt|;
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|gen
operator|=
literal|1
expr_stmt|;
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|size
operator|=
name|p
operator|->
name|txq_size
index|[
name|i
index|]
expr_stmt|;
name|snprintf
argument_list|(
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|lockbuf
argument_list|,
name|TXQ_NAME_LEN
argument_list|,
literal|"t3 txq lock %d:%d:%d"
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|irq_vec_idx
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|MTX_INIT
argument_list|(
operator|&
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|lock
argument_list|,
name|q
operator|->
name|txq
index|[
name|i
index|]
operator|.
name|lockbuf
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
block|}
name|q
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|port
operator|=
name|pi
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|q
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
operator|.
name|qresume_task
argument_list|,
literal|0
argument_list|,
name|restart_offloadq
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|q
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
operator|.
name|qresume_task
argument_list|,
literal|0
argument_list|,
name|restart_ctrlq
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|q
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|qreclaim_task
argument_list|,
literal|0
argument_list|,
name|sge_txq_reclaim_handler
argument_list|,
operator|&
name|q
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|q
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
operator|.
name|qreclaim_task
argument_list|,
literal|0
argument_list|,
name|sge_txq_reclaim_handler
argument_list|,
operator|&
name|q
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
argument_list|)
expr_stmt|;
name|q
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|gen
operator|=
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|gen
operator|=
literal|1
expr_stmt|;
name|q
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|size
operator|=
name|p
operator|->
name|fl_size
expr_stmt|;
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|size
operator|=
name|p
operator|->
name|jumbo_size
expr_stmt|;
name|q
operator|->
name|rspq
operator|.
name|gen
operator|=
literal|1
expr_stmt|;
name|q
operator|->
name|rspq
operator|.
name|cidx
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|rspq
operator|.
name|size
operator|=
name|p
operator|->
name|rspq_size
expr_stmt|;
name|header_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|m_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pkthdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|m_ext_
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|q
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|stop_thres
operator|=
name|nports
operator|*
name|flits_to_desc
argument_list|(
name|sgl_len
argument_list|(
name|TX_MAX_SEGS
operator|+
literal|1
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|q
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|buf_size
operator|=
operator|(
name|MCLBYTES
operator|-
name|header_size
operator|)
expr_stmt|;
name|q
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|zone
operator|=
name|zone_clust
expr_stmt|;
name|q
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|EXT_CLUSTER
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|800000
if|if
condition|(
name|cxgb_use_16k_clusters
condition|)
block|{
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|buf_size
operator|=
name|MJUM16BYTES
operator|-
name|header_size
expr_stmt|;
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|zone
operator|=
name|zone_jumbo16
expr_stmt|;
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|EXT_JUMBO16
expr_stmt|;
block|}
else|else
block|{
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|buf_size
operator|=
name|MJUM9BYTES
operator|-
name|header_size
expr_stmt|;
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|zone
operator|=
name|zone_jumbo9
expr_stmt|;
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|EXT_JUMBO9
expr_stmt|;
block|}
else|#
directive|else
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|buf_size
operator|=
name|MJUMPAGESIZE
operator|-
name|header_size
expr_stmt|;
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|zone
operator|=
name|zone_jumbop
expr_stmt|;
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|EXT_JUMBOP
expr_stmt|;
endif|#
directive|endif
name|q
operator|->
name|lro
operator|.
name|enabled
operator|=
name|lro_default
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|t3_sge_init_rspcntxt
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|rspq
operator|.
name|cntxt_id
argument_list|,
name|irq_vec_idx
argument_list|,
name|q
operator|->
name|rspq
operator|.
name|phys_addr
argument_list|,
name|q
operator|->
name|rspq
operator|.
name|size
argument_list|,
name|q
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|buf_size
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|printf
argument_list|(
literal|"error %d from t3_sge_init_rspcntxt\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
goto|goto
name|err_unlock
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SGE_RXQ_PER_SET
condition|;
operator|++
name|i
control|)
block|{
name|ret
operator|=
operator|-
name|t3_sge_init_flcntxt
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|cntxt_id
argument_list|,
literal|0
argument_list|,
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|phys_addr
argument_list|,
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|size
argument_list|,
name|q
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|buf_size
argument_list|,
name|p
operator|->
name|cong_thres
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|printf
argument_list|(
literal|"error %d from t3_sge_init_flcntxt for index i=%d\n"
argument_list|,
name|ret
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|err_unlock
goto|;
block|}
block|}
name|ret
operator|=
operator|-
name|t3_sge_init_ecntxt
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|cntxt_id
argument_list|,
name|USE_GTS
argument_list|,
name|SGE_CNTXT_ETH
argument_list|,
name|id
argument_list|,
name|q
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|phys_addr
argument_list|,
name|q
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|size
argument_list|,
name|q
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|token
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|printf
argument_list|(
literal|"error %d from t3_sge_init_ecntxt\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
goto|goto
name|err_unlock
goto|;
block|}
if|if
condition|(
name|ntxq
operator|>
literal|1
condition|)
block|{
name|ret
operator|=
operator|-
name|t3_sge_init_ecntxt
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
operator|.
name|cntxt_id
argument_list|,
name|USE_GTS
argument_list|,
name|SGE_CNTXT_OFLD
argument_list|,
name|id
argument_list|,
name|q
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
operator|.
name|phys_addr
argument_list|,
name|q
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
operator|.
name|size
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|printf
argument_list|(
literal|"error %d from t3_sge_init_ecntxt\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
goto|goto
name|err_unlock
goto|;
block|}
block|}
if|if
condition|(
name|ntxq
operator|>
literal|2
condition|)
block|{
name|ret
operator|=
operator|-
name|t3_sge_init_ecntxt
argument_list|(
name|sc
argument_list|,
name|q
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
operator|.
name|cntxt_id
argument_list|,
literal|0
argument_list|,
name|SGE_CNTXT_CTRL
argument_list|,
name|id
argument_list|,
name|q
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
operator|.
name|phys_addr
argument_list|,
name|q
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
operator|.
name|size
argument_list|,
name|q
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
operator|.
name|token
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|printf
argument_list|(
literal|"error %d from t3_sge_init_ecntxt\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
goto|goto
name|err_unlock
goto|;
block|}
block|}
name|snprintf
argument_list|(
name|q
operator|->
name|rspq
operator|.
name|lockbuf
argument_list|,
name|RSPQ_NAME_LEN
argument_list|,
literal|"t3 rspq lock %d:%d"
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|irq_vec_idx
argument_list|)
expr_stmt|;
name|MTX_INIT
argument_list|(
operator|&
name|q
operator|->
name|rspq
operator|.
name|lock
argument_list|,
name|q
operator|->
name|rspq
operator|.
name|lockbuf
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
name|t3_update_qset_coalesce
argument_list|(
name|q
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|q
operator|->
name|port
operator|=
name|pi
expr_stmt|;
name|refill_fl
argument_list|(
name|sc
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
literal|0
index|]
argument_list|,
name|q
operator|->
name|fl
index|[
literal|0
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
name|refill_fl
argument_list|(
name|sc
argument_list|,
operator|&
name|q
operator|->
name|fl
index|[
literal|1
index|]
argument_list|,
name|q
operator|->
name|fl
index|[
literal|1
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
name|refill_rspq
argument_list|(
name|sc
argument_list|,
operator|&
name|q
operator|->
name|rspq
argument_list|,
name|q
operator|->
name|rspq
operator|.
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|A_SG_GTS
argument_list|,
name|V_RSPQ
argument_list|(
name|q
operator|->
name|rspq
operator|.
name|cntxt_id
argument_list|)
operator||
name|V_NEWTIMER
argument_list|(
name|q
operator|->
name|rspq
operator|.
name|holdoff_tmr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err_unlock
label|:
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
name|err
label|:
name|t3_free_qset
argument_list|(
name|sc
argument_list|,
name|q
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
name|t3_rx_eth
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|struct
name|sge_rspq
modifier|*
name|rq
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|ethpad
parameter_list|)
block|{
name|struct
name|cpl_rx_pkt
modifier|*
name|cpl
init|=
operator|(
expr|struct
name|cpl_rx_pkt
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|ethpad
operator|)
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
operator|&
name|adap
operator|->
name|port
index|[
name|adap
operator|->
name|rxpkt_map
index|[
name|cpl
operator|->
name|iff
index|]
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|pi
operator|->
name|ifp
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"rx_eth m=%p m->m_data=%p p->iff=%d\n"
argument_list|,
name|m
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
argument_list|,
name|cpl
operator|->
name|iff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
operator|)
operator|&&
operator|!
name|cpl
operator|->
name|fragment
operator|&&
name|cpl
operator|->
name|csum_valid
operator|&&
name|cpl
operator|->
name|csum
operator|==
literal|0xffff
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
operator|(
name|CSUM_IP_CHECKED
operator||
name|CSUM_IP_VALID
operator|)
expr_stmt|;
name|rspq_to_qset
argument_list|(
name|rq
argument_list|)
operator|->
name|port_stats
index|[
name|SGE_PSTAT_RX_CSUM_GOOD
index|]
operator|++
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
operator|(
name|CSUM_IP_CHECKED
operator||
name|CSUM_IP_VALID
operator||
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xffff
expr_stmt|;
block|}
comment|/*  	 * XXX need to add VLAN support for 6.x 	 */
ifdef|#
directive|ifdef
name|VLAN_SUPPORTED
if|if
condition|(
name|__predict_false
argument_list|(
name|cpl
operator|->
name|vlan_valid
argument_list|)
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|=
name|ntohs
argument_list|(
name|cpl
operator|->
name|vlan
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_VLANTAG
expr_stmt|;
block|}
endif|#
directive|endif
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|header
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|cpl
argument_list|)
operator|+
name|ethpad
expr_stmt|;
ifndef|#
directive|ifndef
name|DISABLE_MBUF_IOVEC
name|m_explode
argument_list|(
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * adjust after conversion to mbuf chain 	 */
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|cpl
argument_list|)
operator|+
name|ethpad
operator|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|cpl
argument_list|)
operator|+
name|ethpad
operator|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|cpl
argument_list|)
operator|+
name|ethpad
operator|)
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ext_free_handler
parameter_list|(
name|void
modifier|*
name|cl
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|uintptr_t
name|type
init|=
operator|(
name|uintptr_t
operator|)
name|arg
decl_stmt|;
name|uma_zone_t
name|zone
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|cl
expr_stmt|;
name|zone
operator|=
name|m_getzonefromtype
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_ext
operator|.
name|ext_type
operator|=
operator|(
name|int
operator|)
name|type
expr_stmt|;
name|cxgb_ext_freed
operator|++
expr_stmt|;
name|cxgb_cache_put
argument_list|(
name|zone
argument_list|,
name|cl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_cluster_mbuf
parameter_list|(
name|caddr_t
name|cl
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|type
parameter_list|,
name|uma_zone_t
name|zone
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|header_size
decl_stmt|;
name|header_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|m_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pkthdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|m_ext_
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|cl
argument_list|,
name|header_size
argument_list|)
expr_stmt|;
name|m
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|cl
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|m
operator|->
name|m_pkthdr
operator|.
name|tags
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_type
operator|=
name|MT_DATA
expr_stmt|;
name|m
operator|->
name|m_flags
operator|=
name|flags
operator||
name|M_NOFREE
operator||
name|M_EXT
expr_stmt|;
name|m
operator|->
name|m_data
operator|=
name|cl
operator|+
name|header_size
expr_stmt|;
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
operator|=
name|cl
expr_stmt|;
name|m
operator|->
name|m_ext
operator|.
name|ref_cnt
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|cl
operator|+
name|header_size
operator|-
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
name|m
operator|->
name|m_ext
operator|.
name|ext_size
operator|=
name|m_getsizefromtype
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_ext
operator|.
name|ext_free
operator|=
name|ext_free_handler
expr_stmt|;
name|m
operator|->
name|m_ext
operator|.
name|ext_args
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|type
expr_stmt|;
name|m
operator|->
name|m_ext
operator|.
name|ext_type
operator|=
name|EXT_EXTREF
expr_stmt|;
operator|*
operator|(
name|m
operator|->
name|m_ext
operator|.
name|ref_cnt
operator|)
operator|=
literal|1
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"data=%p ref_cnt=%p\n"
argument_list|,
name|m
operator|->
name|m_data
argument_list|,
name|m
operator|->
name|m_ext
operator|.
name|ref_cnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	get_packet - return the next ingress packet buffer from a free list  *	@adap: the adapter that received the packet  *	@drop_thres: # of remaining buffers before we start dropping packets  *	@qs: the qset that the SGE free list holding the packet belongs to  *      @mh: the mbuf header, contains a pointer to the head and tail of the mbuf chain  *      @r: response descriptor   *  *	Get the next packet from a free list and complete setup of the  *	sk_buff.  If the packet is small we make a copy and recycle the  *	original buffer, otherwise we use the original buffer itself.  If a  *	positive drop threshold is supplied packets are dropped and their  *	buffers recycled if (a) the number of remaining buffers is under the  *	threshold and the packet is too big to copy, or (b) the packet should  *	be copied but there is no memory for the copy.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DISABLE_MBUF_IOVEC
end_ifdef

begin_function
specifier|static
name|int
name|get_packet
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|drop_thres
parameter_list|,
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|struct
name|t3_mbuf_hdr
modifier|*
name|mh
parameter_list|,
name|struct
name|rsp_desc
modifier|*
name|r
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|unsigned
name|int
name|len_cq
init|=
name|ntohl
argument_list|(
name|r
operator|->
name|len_cq
argument_list|)
decl_stmt|;
name|struct
name|sge_fl
modifier|*
name|fl
init|=
operator|(
name|len_cq
operator|&
name|F_RSPD_FLQ
operator|)
condition|?
operator|&
name|qs
operator|->
name|fl
index|[
literal|1
index|]
else|:
operator|&
name|qs
operator|->
name|fl
index|[
literal|0
index|]
decl_stmt|;
name|struct
name|rx_sw_desc
modifier|*
name|sd
init|=
operator|&
name|fl
operator|->
name|sdesc
index|[
name|fl
operator|->
name|cidx
index|]
decl_stmt|;
name|uint32_t
name|len
init|=
name|G_RSPD_LEN
argument_list|(
name|len_cq
argument_list|)
decl_stmt|;
name|uint32_t
name|flags
init|=
name|ntohl
argument_list|(
name|r
operator|->
name|flags
argument_list|)
decl_stmt|;
name|uint8_t
name|sopeop
init|=
name|G_RSPD_SOP_EOP
argument_list|(
name|flags
argument_list|)
decl_stmt|;
name|uint32_t
modifier|*
name|ref
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|prefetch
argument_list|(
name|sd
operator|->
name|rxsd_cl
argument_list|)
expr_stmt|;
name|fl
operator|->
name|credits
operator|--
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|fl
operator|->
name|entry_tag
argument_list|,
name|sd
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|recycle_enable
operator|&&
name|len
operator|<=
name|SGE_RX_COPY_THRES
operator|&&
name|sopeop
operator|==
name|RSPQ_SOP_EOP
condition|)
block|{
if|if
condition|(
operator|(
name|m0
operator|=
name|m_gethdr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|skip_recycle
goto|;
name|cl
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cl
argument_list|,
name|sd
operator|->
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|recycle_rx_buf
argument_list|(
name|adap
argument_list|,
name|fl
argument_list|,
name|fl
operator|->
name|cidx
argument_list|)
expr_stmt|;
operator|*
name|m
operator|=
name|m0
expr_stmt|;
block|}
else|else
block|{
name|skip_recycle
label|:
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|bus_dmamap_unload
argument_list|(
name|fl
operator|->
name|entry_tag
argument_list|,
name|sd
operator|->
name|map
argument_list|)
expr_stmt|;
name|cl
operator|=
name|sd
operator|->
name|rxsd_cl
expr_stmt|;
operator|*
name|m
operator|=
name|m0
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|cl
expr_stmt|;
name|m0
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
if|if
condition|(
operator|(
name|sopeop
operator|==
name|RSPQ_SOP_EOP
operator|)
operator|||
operator|(
name|sopeop
operator|==
name|RSPQ_SOP
operator|)
condition|)
name|flags
operator|=
name|M_PKTHDR
expr_stmt|;
name|init_cluster_mbuf
argument_list|(
name|cl
argument_list|,
name|flags
argument_list|,
name|fl
operator|->
name|type
argument_list|,
name|fl
operator|->
name|zone
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|sopeop
condition|)
block|{
case|case
name|RSPQ_SOP_EOP
case|:
name|DBG
argument_list|(
name|DBG_RX
argument_list|,
operator|(
literal|"get_packet: SOP-EOP m %p\n"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|mh
operator|->
name|mh_head
operator|=
name|mh
operator|->
name|mh_tail
operator|=
name|m
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|RSPQ_NSOP_NEOP
case|:
name|DBG
argument_list|(
name|DBG_RX
argument_list|,
operator|(
literal|"get_packet: NO_SOP-NO_EOP m %p\n"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mh
operator|->
name|mh_tail
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|cxgb_debug
condition|)
name|printf
argument_list|(
literal|"discarding intermediate descriptor entry\n"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
name|mh
operator|->
name|mh_tail
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|mh
operator|->
name|mh_tail
operator|=
name|m
expr_stmt|;
name|mh
operator|->
name|mh_head
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|len
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|RSPQ_SOP
case|:
name|DBG
argument_list|(
name|DBG_RX
argument_list|,
operator|(
literal|"get_packet: SOP m %p\n"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|mh
operator|->
name|mh_head
operator|=
name|mh
operator|->
name|mh_tail
operator|=
name|m
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|RSPQ_EOP
case|:
name|DBG
argument_list|(
name|DBG_RX
argument_list|,
operator|(
literal|"get_packet: EOP m %p\n"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|mh
operator|->
name|mh_head
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|len
expr_stmt|;
name|mh
operator|->
name|mh_tail
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|mh
operator|->
name|mh_tail
operator|=
name|m
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|++
name|fl
operator|->
name|cidx
operator|==
name|fl
operator|->
name|size
condition|)
name|fl
operator|->
name|cidx
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|int
name|get_packet
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|unsigned
name|int
name|drop_thres
parameter_list|,
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|,
name|struct
name|rsp_desc
modifier|*
name|r
parameter_list|)
block|{
name|unsigned
name|int
name|len_cq
init|=
name|ntohl
argument_list|(
name|r
operator|->
name|len_cq
argument_list|)
decl_stmt|;
name|struct
name|sge_fl
modifier|*
name|fl
init|=
operator|(
name|len_cq
operator|&
name|F_RSPD_FLQ
operator|)
condition|?
operator|&
name|qs
operator|->
name|fl
index|[
literal|1
index|]
else|:
operator|&
name|qs
operator|->
name|fl
index|[
literal|0
index|]
decl_stmt|;
name|struct
name|rx_sw_desc
modifier|*
name|sd
init|=
operator|&
name|fl
operator|->
name|sdesc
index|[
name|fl
operator|->
name|cidx
index|]
decl_stmt|;
name|uint32_t
name|len
init|=
name|G_RSPD_LEN
argument_list|(
name|len_cq
argument_list|)
decl_stmt|;
name|uint32_t
name|flags
init|=
name|ntohl
argument_list|(
name|r
operator|->
name|flags
argument_list|)
decl_stmt|;
name|uint8_t
name|sopeop
init|=
name|G_RSPD_SOP_EOP
argument_list|(
name|flags
argument_list|)
decl_stmt|;
name|void
modifier|*
name|cl
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
if|#
directive|if
literal|0
block|if ((sd + 1 )->rxsd_cl) 		prefetch((sd + 1)->rxsd_cl); 	if ((sd + 2)->rxsd_cl) 		prefetch((sd + 2)->rxsd_cl);
endif|#
directive|endif
name|DPRINTF
argument_list|(
literal|"rx cpu=%d\n"
argument_list|,
name|curcpu
argument_list|)
expr_stmt|;
name|fl
operator|->
name|credits
operator|--
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|fl
operator|->
name|entry_tag
argument_list|,
name|sd
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|recycle_enable
operator|&&
name|len
operator|<=
name|SGE_RX_COPY_THRES
operator|&&
name|sopeop
operator|==
name|RSPQ_SOP_EOP
condition|)
block|{
if|if
condition|(
operator|(
name|m0
operator|=
name|m_gethdr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|skip_recycle
goto|;
name|cl
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cl
argument_list|,
name|sd
operator|->
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|recycle_rx_buf
argument_list|(
name|adap
argument_list|,
name|fl
argument_list|,
name|fl
operator|->
name|cidx
argument_list|)
expr_stmt|;
operator|*
name|m
operator|=
name|m0
expr_stmt|;
block|}
else|else
block|{
name|skip_recycle
label|:
name|bus_dmamap_unload
argument_list|(
name|fl
operator|->
name|entry_tag
argument_list|,
name|sd
operator|->
name|map
argument_list|)
expr_stmt|;
name|cl
operator|=
name|sd
operator|->
name|rxsd_cl
expr_stmt|;
operator|*
name|m
operator|=
name|m0
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|cl
expr_stmt|;
block|}
switch|switch
condition|(
name|sopeop
condition|)
block|{
case|case
name|RSPQ_SOP_EOP
case|:
name|DBG
argument_list|(
name|DBG_RX
argument_list|,
operator|(
literal|"get_packet: SOP-EOP m %p\n"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
operator|==
name|sd
operator|->
name|rxsd_cl
condition|)
name|init_cluster_mbuf
argument_list|(
name|cl
argument_list|,
name|M_PKTHDR
argument_list|,
name|fl
operator|->
name|type
argument_list|,
name|fl
operator|->
name|zone
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_len
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
break|break;
case|case
name|RSPQ_NSOP_NEOP
case|:
name|DBG
argument_list|(
name|DBG_RX
argument_list|,
operator|(
literal|"get_packet: NO_SOP-NO_EOP m %p\n"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"chaining unsupported"
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|RSPQ_SOP
case|:
name|DBG
argument_list|(
name|DBG_RX
argument_list|,
operator|(
literal|"get_packet: SOP m %p\n"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"chaining unsupported"
argument_list|)
expr_stmt|;
name|m_iovinit
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|RSPQ_EOP
case|:
name|DBG
argument_list|(
name|DBG_RX
argument_list|,
operator|(
literal|"get_packet: EOP m %p\n"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"chaining unsupported"
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|panic
argument_list|(
literal|"append not supported"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|m_iovappend(m0, cl, fl->buf_size, len, sizeof(uint32_t), sd->rxsd_ref);
endif|#
directive|endif
name|done
label|:
if|if
condition|(
operator|++
name|fl
operator|->
name|cidx
operator|==
name|fl
operator|->
name|size
condition|)
name|fl
operator|->
name|cidx
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  *	handle_rsp_cntrl_info - handles control information in a response  *	@qs: the queue set corresponding to the response  *	@flags: the response control flags  *  *	Handles the control information of an SGE response, such as GTS  *	indications and completion credits for the queue set's Tx queues.  *	HW coalesces credits, we don't do any extra SW coalescing.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|handle_rsp_cntrl_info
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|unsigned
name|int
name|credits
decl_stmt|;
if|#
directive|if
name|USE_GTS
if|if
condition|(
name|flags
operator|&
name|F_RSPD_TXQ0_GTS
condition|)
name|clear_bit
argument_list|(
name|TXQ_RUNNING
argument_list|,
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|credits
operator|=
name|G_RSPD_TXQ0_CR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|credits
condition|)
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|processed
operator|+=
name|credits
expr_stmt|;
name|credits
operator|=
name|G_RSPD_TXQ2_CR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|credits
condition|)
name|qs
operator|->
name|txq
index|[
name|TXQ_CTRL
index|]
operator|.
name|processed
operator|+=
name|credits
expr_stmt|;
if|#
directive|if
name|USE_GTS
if|if
condition|(
name|flags
operator|&
name|F_RSPD_TXQ1_GTS
condition|)
name|clear_bit
argument_list|(
name|TXQ_RUNNING
argument_list|,
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
operator|.
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|credits
operator|=
name|G_RSPD_TXQ1_CR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|credits
condition|)
name|qs
operator|->
name|txq
index|[
name|TXQ_OFLD
index|]
operator|.
name|processed
operator|+=
name|credits
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_ring_db
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|unsigned
name|int
name|sleeping
parameter_list|)
block|{
empty_stmt|;
block|}
end_function

begin_comment
comment|/**  *	process_responses - process responses from an SGE response queue  *	@adap: the adapter  *	@qs: the queue set to which the response queue belongs  *	@budget: how many responses can be processed in this round  *  *	Process responses from an SGE response queue up to the supplied budget.  *	Responses include received packets as well as credits and other events  *	for the queues that belong to the response queue's queue set.  *	A negative budget is effectively unlimited.  *  *	Additionally choose the interrupt holdoff time for the next interrupt  *	on this queue.  If the system is under memory shortage use a fairly  *	long delay to help recovery.  */
end_comment

begin_function
name|int
name|process_responses
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|int
name|budget
parameter_list|)
block|{
name|struct
name|sge_rspq
modifier|*
name|rspq
init|=
operator|&
name|qs
operator|->
name|rspq
decl_stmt|;
name|struct
name|rsp_desc
modifier|*
name|r
init|=
operator|&
name|rspq
operator|->
name|desc
index|[
name|rspq
operator|->
name|cidx
index|]
decl_stmt|;
name|int
name|budget_left
init|=
name|budget
decl_stmt|;
name|unsigned
name|int
name|sleeping
init|=
literal|0
decl_stmt|;
name|int
name|lro
init|=
name|qs
operator|->
name|lro
operator|.
name|enabled
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|offload_mbufs
index|[
name|RX_BUNDLE_SIZE
index|]
decl_stmt|;
name|int
name|ngathered
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
specifier|static
name|int
name|last_holdoff
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cxgb_debug
operator|&&
name|rspq
operator|->
name|holdoff_tmr
operator|!=
name|last_holdoff
condition|)
block|{
name|printf
argument_list|(
literal|"next_holdoff=%d\n"
argument_list|,
name|rspq
operator|->
name|holdoff_tmr
argument_list|)
expr_stmt|;
name|last_holdoff
operator|=
name|rspq
operator|->
name|holdoff_tmr
expr_stmt|;
block|}
endif|#
directive|endif
name|rspq
operator|->
name|next_holdoff
operator|=
name|rspq
operator|->
name|holdoff_tmr
expr_stmt|;
while|while
condition|(
name|__predict_true
argument_list|(
name|budget_left
operator|&&
name|is_new_response
argument_list|(
name|r
argument_list|,
name|rspq
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|eth
decl_stmt|,
name|eop
init|=
literal|0
decl_stmt|,
name|ethpad
init|=
literal|0
decl_stmt|;
name|uint32_t
name|flags
init|=
name|ntohl
argument_list|(
name|r
operator|->
name|flags
argument_list|)
decl_stmt|;
name|uint32_t
name|rss_csum
init|=
operator|*
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|r
decl_stmt|;
name|uint32_t
name|rss_hash
init|=
name|be32toh
argument_list|(
name|r
operator|->
name|rss_hdr
operator|.
name|rss_hash_val
argument_list|)
decl_stmt|;
name|eth
operator|=
operator|(
name|r
operator|->
name|rss_hdr
operator|.
name|opcode
operator|==
name|CPL_RX_PKT
operator|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|flags
operator|&
name|F_RSPD_ASYNC_NOTIF
argument_list|)
condition|)
block|{
comment|/* XXX */
name|printf
argument_list|(
literal|"async notification\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|F_RSPD_IMM_DATA_VALID
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|DISABLE_MBUF_IOVEC
name|DPRINTF
argument_list|(
literal|"IMM DATA VALID opcode=0x%x rspq->cidx=%d\n"
argument_list|,
name|r
operator|->
name|rss_hdr
operator|.
name|opcode
argument_list|,
name|rspq
operator|->
name|cidx
argument_list|)
expr_stmt|;
name|m
operator|=
name|rspq
operator|->
name|rspq_mh
operator|.
name|mh_head
operator|=
name|m_gethdr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|rspq
operator|->
name|next_holdoff
operator|=
name|NOMEM_INTR_DELAY
expr_stmt|;
name|budget_left
operator|--
expr_stmt|;
break|break;
block|}
name|get_imm_packet
argument_list|(
name|adap
argument_list|,
name|r
argument_list|,
operator|&
name|rspq
operator|->
name|rspq_mh
argument_list|)
expr_stmt|;
name|eop
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|DPRINTF
argument_list|(
literal|"IMM DATA VALID opcode=0x%x rspq->cidx=%d\n"
argument_list|,
name|r
operator|->
name|rss_hdr
operator|.
name|opcode
argument_list|,
name|rspq
operator|->
name|cidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|rspq
operator|->
name|rspq_mbuf
operator|==
name|NULL
condition|)
name|rspq
operator|->
name|rspq_mbuf
operator|=
name|m_gethdr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
else|else
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
comment|/* 			 * XXX revisit me 			 */
if|if
condition|(
name|rspq
operator|->
name|rspq_mbuf
operator|==
name|NULL
operator|&&
name|m
operator|==
name|NULL
condition|)
block|{
name|rspq
operator|->
name|next_holdoff
operator|=
name|NOMEM_INTR_DELAY
expr_stmt|;
name|budget_left
operator|--
expr_stmt|;
break|break;
block|}
name|get_imm_packet
argument_list|(
name|adap
argument_list|,
name|r
argument_list|,
name|rspq
operator|->
name|rspq_mbuf
argument_list|,
name|m
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|eop
operator|=
literal|1
expr_stmt|;
name|rspq
operator|->
name|imm_data
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|r
operator|->
name|len_cq
condition|)
block|{
name|int
name|drop_thresh
init|=
name|eth
condition|?
name|SGE_RX_DROP_THRES
else|:
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DISABLE_MBUF_IOVEC
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"failed to get mbuf for packet\n"
argument_list|)
expr_stmt|;
name|budget_left
operator|--
expr_stmt|;
break|break;
block|}
else|else
block|{
name|m
operator|->
name|m_next
operator|=
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
block|}
name|eop
operator|=
name|get_packet
argument_list|(
name|adap
argument_list|,
name|drop_thresh
argument_list|,
name|qs
argument_list|,
operator|&
name|rspq
operator|->
name|rspq_mh
argument_list|,
name|r
argument_list|,
name|m
argument_list|)
expr_stmt|;
else|#
directive|else
name|eop
operator|=
name|get_packet
argument_list|(
name|adap
argument_list|,
name|drop_thresh
argument_list|,
name|qs
argument_list|,
operator|&
name|rspq
operator|->
name|rspq_mbuf
argument_list|,
name|r
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IFNET_MULTIQUEUE
name|rspq
operator|->
name|rspq_mbuf
operator|->
name|m_pkthdr
operator|.
name|rss_hash
operator|=
name|rss_hash
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|ethpad
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
literal|"pure response\n"
argument_list|)
expr_stmt|;
name|rspq
operator|->
name|pure_rsps
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|RSPD_CTRL_MASK
condition|)
block|{
name|sleeping
operator||=
name|flags
operator|&
name|RSPD_GTS_MASK
expr_stmt|;
name|handle_rsp_cntrl_info
argument_list|(
name|qs
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|r
operator|++
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|++
name|rspq
operator|->
name|cidx
operator|==
name|rspq
operator|->
name|size
argument_list|)
condition|)
block|{
name|rspq
operator|->
name|cidx
operator|=
literal|0
expr_stmt|;
name|rspq
operator|->
name|gen
operator|^=
literal|1
expr_stmt|;
name|r
operator|=
name|rspq
operator|->
name|desc
expr_stmt|;
block|}
name|prefetch
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|rspq
operator|->
name|credits
operator|>=
operator|(
name|rspq
operator|->
name|size
operator|/
literal|4
operator|)
condition|)
block|{
name|refill_rspq
argument_list|(
name|adap
argument_list|,
name|rspq
argument_list|,
name|rspq
operator|->
name|credits
argument_list|)
expr_stmt|;
name|rspq
operator|->
name|credits
operator|=
literal|0
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|"eth=%d eop=%d flags=0x%x\n"
argument_list|,
name|eth
argument_list|,
name|eop
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eth
operator|&&
name|eop
condition|)
block|{
name|rspq
operator|->
name|rspq_mh
operator|.
name|mh_head
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
name|rss_csum
expr_stmt|;
comment|/* 			 * XXX size mismatch 			 */
name|m_set_priority
argument_list|(
name|rspq
operator|->
name|rspq_mh
operator|.
name|mh_head
argument_list|,
name|rss_hash
argument_list|)
expr_stmt|;
name|ngathered
operator|=
name|rx_offload
argument_list|(
operator|&
name|adap
operator|->
name|tdev
argument_list|,
name|rspq
argument_list|,
name|rspq
operator|->
name|rspq_mh
operator|.
name|mh_head
argument_list|,
name|offload_mbufs
argument_list|,
name|ngathered
argument_list|)
expr_stmt|;
name|rspq
operator|->
name|rspq_mh
operator|.
name|mh_head
operator|=
name|NULL
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"received offload packet\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eth
operator|&&
name|eop
condition|)
block|{
name|prefetch
argument_list|(
name|mtod
argument_list|(
name|rspq
operator|->
name|rspq_mh
operator|.
name|mh_head
argument_list|,
name|uint8_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|prefetch
argument_list|(
name|mtod
argument_list|(
name|rspq
operator|->
name|rspq_mh
operator|.
name|mh_head
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|L1_CACHE_BYTES
argument_list|)
expr_stmt|;
name|t3_rx_eth_lro
argument_list|(
name|adap
argument_list|,
name|rspq
argument_list|,
name|rspq
operator|->
name|rspq_mh
operator|.
name|mh_head
argument_list|,
name|ethpad
argument_list|,
name|rss_hash
argument_list|,
name|rss_csum
argument_list|,
name|lro
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"received tunnel packet\n"
argument_list|)
expr_stmt|;
name|rspq
operator|->
name|rspq_mh
operator|.
name|mh_head
operator|=
name|NULL
expr_stmt|;
block|}
name|__refill_fl_lt
argument_list|(
name|adap
argument_list|,
operator|&
name|qs
operator|->
name|fl
index|[
literal|0
index|]
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|__refill_fl_lt
argument_list|(
name|adap
argument_list|,
operator|&
name|qs
operator|->
name|fl
index|[
literal|1
index|]
argument_list|,
literal|32
argument_list|)
expr_stmt|;
operator|--
name|budget_left
expr_stmt|;
block|}
name|deliver_partial_bundle
argument_list|(
operator|&
name|adap
operator|->
name|tdev
argument_list|,
name|rspq
argument_list|,
name|offload_mbufs
argument_list|,
name|ngathered
argument_list|)
expr_stmt|;
name|t3_lro_flush
argument_list|(
name|adap
argument_list|,
name|qs
argument_list|,
operator|&
name|qs
operator|->
name|lro
argument_list|)
expr_stmt|;
if|if
condition|(
name|sleeping
condition|)
name|check_ring_db
argument_list|(
name|adap
argument_list|,
name|qs
argument_list|,
name|sleeping
argument_list|)
expr_stmt|;
name|smp_mb
argument_list|()
expr_stmt|;
comment|/* commit Tx queue processed updates */
if|if
condition|(
name|__predict_false
argument_list|(
name|qs
operator|->
name|txq_stopped
operator|>
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"restarting tx on %p\n"
argument_list|,
name|qs
argument_list|)
expr_stmt|;
name|restart_tx
argument_list|(
name|qs
argument_list|)
expr_stmt|;
block|}
name|__refill_fl_lt
argument_list|(
name|adap
argument_list|,
operator|&
name|qs
operator|->
name|fl
index|[
literal|0
index|]
argument_list|,
literal|512
argument_list|)
expr_stmt|;
name|__refill_fl_lt
argument_list|(
name|adap
argument_list|,
operator|&
name|qs
operator|->
name|fl
index|[
literal|1
index|]
argument_list|,
literal|512
argument_list|)
expr_stmt|;
name|budget
operator|-=
name|budget_left
expr_stmt|;
return|return
operator|(
name|budget
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * A helper function that processes responses and issues GTS.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|process_responses_gts
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|struct
name|sge_rspq
modifier|*
name|rq
parameter_list|)
block|{
name|int
name|work
decl_stmt|;
specifier|static
name|int
name|last_holdoff
init|=
literal|0
decl_stmt|;
name|work
operator|=
name|process_responses
argument_list|(
name|adap
argument_list|,
name|rspq_to_qset
argument_list|(
name|rq
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cxgb_debug
operator|&&
operator|(
name|rq
operator|->
name|next_holdoff
operator|!=
name|last_holdoff
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"next_holdoff=%d\n"
argument_list|,
name|rq
operator|->
name|next_holdoff
argument_list|)
expr_stmt|;
name|last_holdoff
operator|=
name|rq
operator|->
name|next_holdoff
expr_stmt|;
block|}
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_GTS
argument_list|,
name|V_RSPQ
argument_list|(
name|rq
operator|->
name|cntxt_id
argument_list|)
operator||
name|V_NEWTIMER
argument_list|(
name|rq
operator|->
name|next_holdoff
argument_list|)
operator||
name|V_NEWINDEX
argument_list|(
name|rq
operator|->
name|cidx
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|work
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Interrupt handler for legacy INTx interrupts for T3B-based cards.  * Handles data events from SGE response queues as well as error and other  * async events as they all use the same interrupt pin.  We use one SGE  * response queue per port in this mode and protect all response queues with  * queue 0's lock.  */
end_comment

begin_function
name|void
name|t3b_intr
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|,
name|map
decl_stmt|;
name|adapter_t
modifier|*
name|adap
init|=
name|data
decl_stmt|;
name|struct
name|sge_rspq
modifier|*
name|q0
init|=
operator|&
name|adap
operator|->
name|sge
operator|.
name|qs
index|[
literal|0
index|]
operator|.
name|rspq
decl_stmt|;
name|t3_write_reg
argument_list|(
name|adap
argument_list|,
name|A_PL_CLI
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|map
operator|=
name|t3_read_reg
argument_list|(
name|adap
argument_list|,
name|A_SG_DATA_INTR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|map
condition|)
return|return;
if|if
condition|(
name|__predict_false
argument_list|(
name|map
operator|&
name|F_ERRINTR
argument_list|)
condition|)
name|taskqueue_enqueue
argument_list|(
name|adap
operator|->
name|tq
argument_list|,
operator|&
name|adap
operator|->
name|slow_intr_task
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|q0
operator|->
name|lock
argument_list|)
expr_stmt|;
name|for_each_port
argument_list|(
argument|adap
argument_list|,
argument|i
argument_list|)
if|if
condition|(
name|map
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|process_responses_gts
argument_list|(
name|adap
argument_list|,
operator|&
name|adap
operator|->
name|sge
operator|.
name|qs
index|[
name|i
index|]
operator|.
name|rspq
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|q0
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The MSI interrupt handler.  This needs to handle data events from SGE  * response queues as well as error and other async events as they all use  * the same MSI vector.  We use one SGE response queue per port in this mode  * and protect all response queues with queue 0's lock.  */
end_comment

begin_function
name|void
name|t3_intr_msi
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|adapter_t
modifier|*
name|adap
init|=
name|data
decl_stmt|;
name|struct
name|sge_rspq
modifier|*
name|q0
init|=
operator|&
name|adap
operator|->
name|sge
operator|.
name|qs
index|[
literal|0
index|]
operator|.
name|rspq
decl_stmt|;
name|int
name|i
decl_stmt|,
name|new_packets
init|=
literal|0
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|q0
operator|->
name|lock
argument_list|)
expr_stmt|;
name|for_each_port
argument_list|(
argument|adap
argument_list|,
argument|i
argument_list|)
if|if
condition|(
name|process_responses_gts
argument_list|(
name|adap
argument_list|,
operator|&
name|adap
operator|->
name|sge
operator|.
name|qs
index|[
name|i
index|]
operator|.
name|rspq
argument_list|)
condition|)
name|new_packets
operator|=
literal|1
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|q0
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_packets
operator|==
literal|0
condition|)
name|taskqueue_enqueue
argument_list|(
name|adap
operator|->
name|tq
argument_list|,
operator|&
name|adap
operator|->
name|slow_intr_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t3_intr_msix
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|sge_qset
modifier|*
name|qs
init|=
name|data
decl_stmt|;
name|adapter_t
modifier|*
name|adap
init|=
name|qs
operator|->
name|port
operator|->
name|adapter
decl_stmt|;
name|struct
name|sge_rspq
modifier|*
name|rspq
init|=
operator|&
name|qs
operator|->
name|rspq
decl_stmt|;
ifndef|#
directive|ifndef
name|IFNET_MULTIQUEUE
name|mtx_lock
argument_list|(
operator|&
name|rspq
operator|->
name|lock
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|mtx_trylock
argument_list|(
operator|&
name|rspq
operator|->
name|lock
argument_list|)
condition|)
endif|#
directive|endif
block|{
if|if
condition|(
name|process_responses_gts
argument_list|(
name|adap
argument_list|,
name|rspq
argument_list|)
operator|==
literal|0
condition|)
name|rspq
operator|->
name|unhandled_irqs
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|rspq
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|QDUMP_SBUF_SIZE
value|32 * 400
end_define

begin_function
specifier|static
name|int
name|t3_dump_rspq
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|sge_rspq
modifier|*
name|rspq
decl_stmt|;
name|struct
name|sge_qset
modifier|*
name|qs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|err
decl_stmt|,
name|dump_end
decl_stmt|,
name|idx
decl_stmt|;
specifier|static
name|int
name|multiplier
init|=
literal|1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|struct
name|rsp_desc
modifier|*
name|rspd
decl_stmt|;
name|uint32_t
name|data
index|[
literal|4
index|]
decl_stmt|;
name|rspq
operator|=
name|arg1
expr_stmt|;
name|qs
operator|=
name|rspq_to_qset
argument_list|(
name|rspq
argument_list|)
expr_stmt|;
if|if
condition|(
name|rspq
operator|->
name|rspq_dump_count
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|rspq
operator|->
name|rspq_dump_count
operator|>
name|RSPQ_Q_SIZE
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"dump count is too large %d\n"
argument_list|,
name|rspq
operator|->
name|rspq_dump_count
argument_list|)
expr_stmt|;
name|rspq
operator|->
name|rspq_dump_count
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|rspq
operator|->
name|rspq_dump_start
operator|>
operator|(
name|RSPQ_Q_SIZE
operator|-
literal|1
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"dump start of %d is greater than queue size\n"
argument_list|,
name|rspq
operator|->
name|rspq_dump_start
argument_list|)
expr_stmt|;
name|rspq
operator|->
name|rspq_dump_start
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|err
operator|=
name|t3_sge_read_rspq
argument_list|(
name|qs
operator|->
name|port
operator|->
name|adapter
argument_list|,
name|rspq
operator|->
name|cntxt_id
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|retry_sbufops
label|:
name|sb
operator|=
name|sbuf_new
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|QDUMP_SBUF_SIZE
operator|*
name|multiplier
argument_list|,
name|SBUF_FIXEDLEN
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" \n index=%u size=%u MSI-X/RspQ=%u intr enable=%u intr armed=%u\n"
argument_list|,
operator|(
name|data
index|[
literal|0
index|]
operator|&
literal|0xffff
operator|)
argument_list|,
name|data
index|[
literal|0
index|]
operator|>>
literal|16
argument_list|,
operator|(
operator|(
name|data
index|[
literal|2
index|]
operator|>>
literal|20
operator|)
operator|&
literal|0x3f
operator|)
argument_list|,
operator|(
operator|(
name|data
index|[
literal|2
index|]
operator|>>
literal|26
operator|)
operator|&
literal|1
operator|)
argument_list|,
operator|(
operator|(
name|data
index|[
literal|2
index|]
operator|>>
literal|27
operator|)
operator|&
literal|1
operator|)
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" generation=%u CQ mode=%u FL threshold=%u\n"
argument_list|,
operator|(
operator|(
name|data
index|[
literal|2
index|]
operator|>>
literal|28
operator|)
operator|&
literal|1
operator|)
argument_list|,
operator|(
operator|(
name|data
index|[
literal|2
index|]
operator|>>
literal|31
operator|)
operator|&
literal|1
operator|)
argument_list|,
name|data
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" start=%d -> end=%d\n"
argument_list|,
name|rspq
operator|->
name|rspq_dump_start
argument_list|,
operator|(
name|rspq
operator|->
name|rspq_dump_start
operator|+
name|rspq
operator|->
name|rspq_dump_count
operator|)
operator|&
operator|(
name|RSPQ_Q_SIZE
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|dump_end
operator|=
name|rspq
operator|->
name|rspq_dump_start
operator|+
name|rspq
operator|->
name|rspq_dump_count
expr_stmt|;
for|for
control|(
name|i
operator|=
name|rspq
operator|->
name|rspq_dump_start
init|;
name|i
operator|<
name|dump_end
condition|;
name|i
operator|++
control|)
block|{
name|idx
operator|=
name|i
operator|&
operator|(
name|RSPQ_Q_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|rspd
operator|=
operator|&
name|rspq
operator|->
name|desc
index|[
name|idx
index|]
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\tidx=%04d opcode=%02x cpu_idx=%x hash_type=%x cq_idx=%x\n"
argument_list|,
name|idx
argument_list|,
name|rspd
operator|->
name|rss_hdr
operator|.
name|opcode
argument_list|,
name|rspd
operator|->
name|rss_hdr
operator|.
name|cpu_idx
argument_list|,
name|rspd
operator|->
name|rss_hdr
operator|.
name|hash_type
argument_list|,
name|be16toh
argument_list|(
name|rspd
operator|->
name|rss_hdr
operator|.
name|cq_idx
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\trss_hash_val=%x flags=%08x len_cq=%x intr_gen=%x\n"
argument_list|,
name|rspd
operator|->
name|rss_hdr
operator|.
name|rss_hash_val
argument_list|,
name|be32toh
argument_list|(
name|rspd
operator|->
name|flags
argument_list|)
argument_list|,
name|be32toh
argument_list|(
name|rspd
operator|->
name|len_cq
argument_list|)
argument_list|,
name|rspd
operator|->
name|intr_gen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sbuf_overflowed
argument_list|(
name|sb
argument_list|)
condition|)
block|{
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|multiplier
operator|++
expr_stmt|;
goto|goto
name|retry_sbufops
goto|;
block|}
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|err
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|sbuf_data
argument_list|(
name|sb
argument_list|)
argument_list|,
name|sbuf_len
argument_list|(
name|sb
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * broken by recent mbuf changes   */
end_comment

begin_function
specifier|static
name|int
name|t3_dump_txq
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
name|struct
name|sge_qset
modifier|*
name|qs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|err
decl_stmt|,
name|dump_end
decl_stmt|;
specifier|static
name|int
name|multiplier
init|=
literal|1
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|struct
name|tx_desc
modifier|*
name|txd
decl_stmt|;
name|uint32_t
modifier|*
name|WR
decl_stmt|,
name|wr_hi
decl_stmt|,
name|wr_lo
decl_stmt|,
name|gen
decl_stmt|;
name|uint32_t
name|data
index|[
literal|4
index|]
decl_stmt|;
name|txq
operator|=
name|arg1
expr_stmt|;
name|qs
operator|=
name|txq_to_qset
argument_list|(
name|txq
argument_list|,
name|TXQ_ETH
argument_list|)
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|txq_dump_count
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|txq
operator|->
name|txq_dump_count
operator|>
name|TX_ETH_Q_SIZE
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"dump count is too large %d\n"
argument_list|,
name|txq
operator|->
name|txq_dump_count
argument_list|)
expr_stmt|;
name|txq
operator|->
name|txq_dump_count
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|txq
operator|->
name|txq_dump_start
operator|>
operator|(
name|TX_ETH_Q_SIZE
operator|-
literal|1
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"dump start of %d is greater than queue size\n"
argument_list|,
name|txq
operator|->
name|txq_dump_start
argument_list|)
expr_stmt|;
name|txq
operator|->
name|txq_dump_start
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|err
operator|=
name|t3_sge_read_ecntxt
argument_list|(
name|qs
operator|->
name|port
operator|->
name|adapter
argument_list|,
name|txq
operator|->
name|cntxt_id
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|retry_sbufops
label|:
name|sb
operator|=
name|sbuf_new
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|QDUMP_SBUF_SIZE
operator|*
name|multiplier
argument_list|,
name|SBUF_FIXEDLEN
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" \n credits=%u GTS=%u index=%u size=%u rspq#=%u cmdq#=%u\n"
argument_list|,
operator|(
name|data
index|[
literal|0
index|]
operator|&
literal|0x7fff
operator|)
argument_list|,
operator|(
operator|(
name|data
index|[
literal|0
index|]
operator|>>
literal|15
operator|)
operator|&
literal|1
operator|)
argument_list|,
operator|(
name|data
index|[
literal|0
index|]
operator|>>
literal|16
operator|)
argument_list|,
operator|(
name|data
index|[
literal|1
index|]
operator|&
literal|0xffff
operator|)
argument_list|,
operator|(
operator|(
name|data
index|[
literal|3
index|]
operator|>>
literal|4
operator|)
operator|&
literal|7
operator|)
argument_list|,
operator|(
operator|(
name|data
index|[
literal|3
index|]
operator|>>
literal|7
operator|)
operator|&
literal|1
operator|)
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" TUN=%u TOE=%u generation%u uP token=%u valid=%u\n"
argument_list|,
operator|(
operator|(
name|data
index|[
literal|3
index|]
operator|>>
literal|8
operator|)
operator|&
literal|1
operator|)
argument_list|,
operator|(
operator|(
name|data
index|[
literal|3
index|]
operator|>>
literal|9
operator|)
operator|&
literal|1
operator|)
argument_list|,
operator|(
operator|(
name|data
index|[
literal|3
index|]
operator|>>
literal|10
operator|)
operator|&
literal|1
operator|)
argument_list|,
operator|(
operator|(
name|data
index|[
literal|3
index|]
operator|>>
literal|11
operator|)
operator|&
literal|0xfffff
operator|)
argument_list|,
operator|(
operator|(
name|data
index|[
literal|3
index|]
operator|>>
literal|31
operator|)
operator|&
literal|1
operator|)
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" qid=%d start=%d -> end=%d\n"
argument_list|,
name|qs
operator|->
name|idx
argument_list|,
name|txq
operator|->
name|txq_dump_start
argument_list|,
operator|(
name|txq
operator|->
name|txq_dump_start
operator|+
name|txq
operator|->
name|txq_dump_count
operator|)
operator|&
operator|(
name|TX_ETH_Q_SIZE
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|dump_end
operator|=
name|txq
operator|->
name|txq_dump_start
operator|+
name|txq
operator|->
name|txq_dump_count
expr_stmt|;
for|for
control|(
name|i
operator|=
name|txq
operator|->
name|txq_dump_start
init|;
name|i
operator|<
name|dump_end
condition|;
name|i
operator|++
control|)
block|{
name|txd
operator|=
operator|&
name|txq
operator|->
name|desc
index|[
name|i
operator|&
operator|(
name|TX_ETH_Q_SIZE
operator|-
literal|1
operator|)
index|]
expr_stmt|;
name|WR
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|txd
operator|->
name|flit
expr_stmt|;
name|wr_hi
operator|=
name|ntohl
argument_list|(
name|WR
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|wr_lo
operator|=
name|ntohl
argument_list|(
name|WR
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|gen
operator|=
name|G_WR_GEN
argument_list|(
name|wr_lo
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" wr_hi %08x wr_lo %08x gen %d\n"
argument_list|,
name|wr_hi
argument_list|,
name|wr_lo
argument_list|,
name|gen
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|2
init|;
name|j
operator|<
literal|30
condition|;
name|j
operator|+=
literal|4
control|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"\t%08x %08x %08x %08x \n"
argument_list|,
name|WR
index|[
name|j
index|]
argument_list|,
name|WR
index|[
name|j
operator|+
literal|1
index|]
argument_list|,
name|WR
index|[
name|j
operator|+
literal|2
index|]
argument_list|,
name|WR
index|[
name|j
operator|+
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sbuf_overflowed
argument_list|(
name|sb
argument_list|)
condition|)
block|{
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|multiplier
operator|++
expr_stmt|;
goto|goto
name|retry_sbufops
goto|;
block|}
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|err
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|sbuf_data
argument_list|(
name|sb
argument_list|)
argument_list|,
name|sbuf_len
argument_list|(
name|sb
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|t3_lro_enable
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|adapter_t
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|enabled
decl_stmt|,
name|err
decl_stmt|,
name|nqsets
init|=
literal|0
decl_stmt|;
ifndef|#
directive|ifndef
name|LRO_WORKING
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
name|sc
operator|=
name|arg1
expr_stmt|;
name|enabled
operator|=
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
literal|0
index|]
operator|.
name|lro
operator|.
name|enabled
expr_stmt|;
name|err
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|enabled
argument_list|,
name|arg2
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|enabled
operator|==
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
literal|0
index|]
operator|.
name|lro
operator|.
name|enabled
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|params
operator|.
name|nports
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sc
operator|->
name|port
index|[
name|i
index|]
operator|.
name|nqsets
condition|;
name|j
operator|++
control|)
name|nqsets
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nqsets
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
name|i
index|]
operator|.
name|lro
operator|.
name|enabled
operator|=
name|enabled
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|t3_set_coalesce_nsecs
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|adapter_t
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|qset_params
modifier|*
name|qsp
init|=
operator|&
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|qset
index|[
literal|0
index|]
decl_stmt|;
name|int
name|coalesce_nsecs
decl_stmt|;
name|struct
name|sge_qset
modifier|*
name|qs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|err
decl_stmt|,
name|nqsets
init|=
literal|0
decl_stmt|;
name|struct
name|mtx
modifier|*
name|lock
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|coalesce_nsecs
operator|=
name|qsp
operator|->
name|coalesce_nsecs
expr_stmt|;
name|err
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|coalesce_nsecs
argument_list|,
name|arg2
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|coalesce_nsecs
operator|==
name|qsp
operator|->
name|coalesce_nsecs
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|params
operator|.
name|nports
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sc
operator|->
name|port
index|[
name|i
index|]
operator|.
name|nqsets
condition|;
name|j
operator|++
control|)
name|nqsets
operator|++
expr_stmt|;
name|coalesce_nsecs
operator|=
name|max
argument_list|(
literal|100
argument_list|,
name|coalesce_nsecs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nqsets
condition|;
name|i
operator|++
control|)
block|{
name|qs
operator|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
name|i
index|]
expr_stmt|;
name|qsp
operator|=
operator|&
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|qset
index|[
name|i
index|]
expr_stmt|;
name|qsp
operator|->
name|coalesce_nsecs
operator|=
name|coalesce_nsecs
expr_stmt|;
name|lock
operator|=
operator|(
name|sc
operator|->
name|flags
operator|&
name|USING_MSIX
operator|)
condition|?
operator|&
name|qs
operator|->
name|rspq
operator|.
name|lock
else|:
operator|&
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
literal|0
index|]
operator|.
name|rspq
operator|.
name|lock
expr_stmt|;
name|mtx_lock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|t3_update_qset_coalesce
argument_list|(
name|qs
argument_list|,
name|qsp
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|A_SG_GTS
argument_list|,
name|V_RSPQ
argument_list|(
name|qs
operator|->
name|rspq
operator|.
name|cntxt_id
argument_list|)
operator||
name|V_NEWTIMER
argument_list|(
name|qs
operator|->
name|rspq
operator|.
name|holdoff_tmr
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|t3_add_attach_sysctls
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|children
decl_stmt|;
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* random information */
name|SYSCTL_ADD_STRING
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"firmware_version"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|fw_version
argument_list|,
literal|0
argument_list|,
literal|"firmware version"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"enable_lro"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|t3_lro_enable
argument_list|,
literal|"I"
argument_list|,
literal|"enable large receive offload"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"enable_debug"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|cxgb_debug
argument_list|,
literal|0
argument_list|,
literal|"enable verbose debugging output"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tunq_coalesce"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|tunq_coalesce
argument_list|,
literal|"#tunneled packets freed"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txq_overrun"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq_fills
argument_list|,
literal|0
argument_list|,
literal|"#times txq overrun"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"bogus_imm"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|bogus_imm
argument_list|,
literal|0
argument_list|,
literal|"#times a bogus immediate response was seen"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cache_alloc"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|cxgb_cached_allocations
argument_list|,
literal|0
argument_list|,
literal|"#times a cluster was allocated from cache"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cached"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|cxgb_cached
argument_list|,
literal|0
argument_list|,
literal|"#times a cluster was cached"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ext_freed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|cxgb_ext_freed
argument_list|,
literal|0
argument_list|,
literal|"#times a cluster was freed through ext_free"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|rspq_name
init|=
literal|"rspq"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|txq_names
index|[]
init|=
block|{
literal|"txq_eth"
block|,
literal|"txq_ofld"
block|,
literal|"txq_ctrl"
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|t3_add_configured_sysctls
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|children
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"intr_coal"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|t3_set_coalesce_nsecs
argument_list|,
literal|"I"
argument_list|,
literal|"interrupt coalescing timer (ns)"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|params
operator|.
name|nports
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
operator|&
name|sc
operator|->
name|port
index|[
name|i
index|]
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|poid
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|poidlist
decl_stmt|;
name|snprintf
argument_list|(
name|pi
operator|->
name|namebuf
argument_list|,
name|PORT_NAME_LEN
argument_list|,
literal|"port%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|poid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
name|pi
operator|->
name|namebuf
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"port statistics"
argument_list|)
expr_stmt|;
name|poidlist
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|poid
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|poidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"nqsets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pi
operator|->
name|nqsets
argument_list|,
literal|0
argument_list|,
literal|"#queue sets"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pi
operator|->
name|nqsets
condition|;
name|j
operator|++
control|)
block|{
name|struct
name|sge_qset
modifier|*
name|qs
init|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
name|pi
operator|->
name|first_qset
operator|+
name|j
index|]
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|qspoid
decl_stmt|,
modifier|*
name|rspqpoid
decl_stmt|,
modifier|*
name|txqpoid
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|qspoidlist
decl_stmt|,
modifier|*
name|rspqpoidlist
decl_stmt|,
modifier|*
name|txqpoidlist
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
init|=
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|qs
operator|->
name|namebuf
argument_list|,
name|QS_NAME_LEN
argument_list|,
literal|"qs%d"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|qspoid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|poidlist
argument_list|,
name|OID_AUTO
argument_list|,
name|qs
operator|->
name|namebuf
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"qset statistics"
argument_list|)
expr_stmt|;
name|qspoidlist
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|qspoid
argument_list|)
expr_stmt|;
name|rspqpoid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|qspoidlist
argument_list|,
name|OID_AUTO
argument_list|,
name|rspq_name
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"rspq statistics"
argument_list|)
expr_stmt|;
name|rspqpoidlist
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|rspqpoid
argument_list|)
expr_stmt|;
name|txqpoid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|qspoidlist
argument_list|,
name|OID_AUTO
argument_list|,
name|txq_names
index|[
literal|0
index|]
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"txq statistics"
argument_list|)
expr_stmt|;
name|txqpoidlist
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|txqpoid
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|rspqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"size"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|qs
operator|->
name|rspq
operator|.
name|size
argument_list|,
literal|0
argument_list|,
literal|"#entries in response queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|rspqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cidx"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|qs
operator|->
name|rspq
operator|.
name|cidx
argument_list|,
literal|0
argument_list|,
literal|"consumer index"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|rspqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"credits"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|qs
operator|->
name|rspq
operator|.
name|credits
argument_list|,
literal|0
argument_list|,
literal|"#credits"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_XLONG
argument_list|(
name|ctx
argument_list|,
name|rspqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"phys_addr"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|qs
operator|->
name|rspq
operator|.
name|phys_addr
argument_list|,
literal|"physical_address_of the queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|rspqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dump_start"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|qs
operator|->
name|rspq
operator|.
name|rspq_dump_start
argument_list|,
literal|0
argument_list|,
literal|"start rspq dump entry"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|rspqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dump_count"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|qs
operator|->
name|rspq
operator|.
name|rspq_dump_count
argument_list|,
literal|0
argument_list|,
literal|"#rspq entries to dump"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|rspqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"qdump"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|qs
operator|->
name|rspq
argument_list|,
literal|0
argument_list|,
name|t3_dump_rspq
argument_list|,
literal|"A"
argument_list|,
literal|"dump of the response queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|txqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dropped"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|txq_drops
argument_list|,
literal|0
argument_list|,
literal|"#tunneled packets dropped"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|txqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"sendqlen"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|sendq
operator|.
name|qlen
argument_list|,
literal|0
argument_list|,
literal|"#tunneled packets waiting to be sent"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|txqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"queue_pidx"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|txq_mr
operator|.
name|br_prod
argument_list|,
literal|0
argument_list|,
literal|"#tunneled packets queue producer index"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|txqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"queue_cidx"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|txq_mr
operator|.
name|br_cons
argument_list|,
literal|0
argument_list|,
literal|"#tunneled packets queue consumer index"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|txqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"processed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|processed
argument_list|,
literal|0
argument_list|,
literal|"#tunneled packets processed by the card"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|txqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cleaned"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|cleaned
argument_list|,
literal|0
argument_list|,
literal|"#tunneled packets cleaned"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|txqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"in_use"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|in_use
argument_list|,
literal|0
argument_list|,
literal|"#tunneled packet slots in use"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|txqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"frees"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|txq_frees
argument_list|,
literal|"#tunneled packets freed"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|txqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"skipped"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|txq_skipped
argument_list|,
literal|0
argument_list|,
literal|"#tunneled packet descriptors skipped"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|txqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"coalesced"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|txq_coalesced
argument_list|,
literal|0
argument_list|,
literal|"#tunneled packets coalesced"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|txqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"enqueued"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|txq_enqueued
argument_list|,
literal|0
argument_list|,
literal|"#tunneled packets enqueued to hardware"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|txqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stopped_flags"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|qs
operator|->
name|txq_stopped
argument_list|,
literal|0
argument_list|,
literal|"tx queues stopped"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_XLONG
argument_list|(
name|ctx
argument_list|,
name|txqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"phys_addr"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|phys_addr
argument_list|,
literal|"physical_address_of the queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|txqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"qgen"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|gen
argument_list|,
literal|0
argument_list|,
literal|"txq generation"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|txqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"hw_cidx"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|cidx
argument_list|,
literal|0
argument_list|,
literal|"hardware queue cidx"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|txqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"hw_pidx"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|pidx
argument_list|,
literal|0
argument_list|,
literal|"hardware queue pidx"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|txqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dump_start"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|txq_dump_start
argument_list|,
literal|0
argument_list|,
literal|"txq start idx for dump"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|ctx
argument_list|,
name|txqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dump_count"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|txq_dump_count
argument_list|,
literal|0
argument_list|,
literal|"txq #entries to dump"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|txqpoidlist
argument_list|,
name|OID_AUTO
argument_list|,
literal|"qdump"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
argument_list|,
literal|0
argument_list|,
name|t3_dump_txq
argument_list|,
literal|"A"
argument_list|,
literal|"dump of the transmit queue"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  *	t3_get_desc - dump an SGE descriptor for debugging purposes  *	@qs: the queue set  *	@qnum: identifies the specific queue (0..2: Tx, 3:response, 4..5: Rx)  *	@idx: the descriptor index in the queue  *	@data: where to dump the descriptor contents  *  *	Dumps the contents of a HW descriptor of an SGE queue.  Returns the  *	size of the descriptor.  */
end_comment

begin_function
name|int
name|t3_get_desc
parameter_list|(
specifier|const
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|unsigned
name|int
name|qnum
parameter_list|,
name|unsigned
name|int
name|idx
parameter_list|,
name|unsigned
name|char
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|qnum
operator|>=
literal|6
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|qnum
operator|<
literal|3
condition|)
block|{
if|if
condition|(
operator|!
name|qs
operator|->
name|txq
index|[
name|qnum
index|]
operator|.
name|desc
operator|||
name|idx
operator|>=
name|qs
operator|->
name|txq
index|[
name|qnum
index|]
operator|.
name|size
condition|)
return|return
operator|-
name|EINVAL
return|;
name|memcpy
argument_list|(
name|data
argument_list|,
operator|&
name|qs
operator|->
name|txq
index|[
name|qnum
index|]
operator|.
name|desc
index|[
name|idx
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tx_desc
argument_list|)
argument_list|)
expr_stmt|;
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|tx_desc
argument_list|)
return|;
block|}
if|if
condition|(
name|qnum
operator|==
literal|3
condition|)
block|{
if|if
condition|(
operator|!
name|qs
operator|->
name|rspq
operator|.
name|desc
operator|||
name|idx
operator|>=
name|qs
operator|->
name|rspq
operator|.
name|size
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|memcpy
argument_list|(
name|data
argument_list|,
operator|&
name|qs
operator|->
name|rspq
operator|.
name|desc
index|[
name|idx
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rsp_desc
argument_list|)
argument_list|)
expr_stmt|;
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|rsp_desc
argument_list|)
return|;
block|}
name|qnum
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
operator|!
name|qs
operator|->
name|fl
index|[
name|qnum
index|]
operator|.
name|desc
operator|||
name|idx
operator|>=
name|qs
operator|->
name|fl
index|[
name|qnum
index|]
operator|.
name|size
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|memcpy
argument_list|(
name|data
argument_list|,
operator|&
name|qs
operator|->
name|fl
index|[
name|qnum
index|]
operator|.
name|desc
index|[
name|idx
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rx_desc
argument_list|)
argument_list|)
expr_stmt|;
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|rx_desc
argument_list|)
return|;
block|}
end_function

end_unit

