begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************************  Copyright (c) 2007, Chelsio Inc. All rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:   1. Redistributions of source code must retain the above copyright notice,     this list of conditions and the following disclaimer.   2. Redistributions in binary form must reproduce the above copyright     notice, this list of conditions and the following disclaimer in the     documentation and/or other materials provided with the distribution.   3. Neither the name of the Chelsio Corporation nor the names of its     contributors may be used to endorse or promote products derived from     this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus_dma.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/cxgb_osdep.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_common.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_t3_cpl.h>
end_include

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|M_LRO
end_ifndef

begin_define
define|#
directive|define
name|M_LRO
value|0x0200
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|MBUF_HEADER_CHECK
parameter_list|(
name|mh
parameter_list|)
value|do { \ 	struct mbuf *head = mh->mh_head; \ 	struct mbuf *tail = mh->mh_tail; \ 	if (head->m_len == 0 || head->m_pkthdr.len == 0 \ 	    || (head->m_flags& M_PKTHDR) == 0) 			\ 		panic("lro_flush_session - mbuf len=%d pktlen=%d flags=0x%x\n", \ 		    head->m_len, head->m_pkthdr.len, head->m_flags); \ 	if ((head->m_flags& M_PKTHDR) == 0) \ 		panic("first mbuf is not packet header - flags=0x%x\n", \ 		    head->m_flags);  \ 	if ((head == tail&& head->m_len != head->m_pkthdr.len)) \ 		panic("len=%d pktlen=%d mismatch\n", \ 		    head->m_len, head->m_pkthdr.len);			\ 	if (head->m_len< ETHER_HDR_LEN || head->m_pkthdr.len< ETHER_HDR_LEN) \ 		panic("packet too small len=%d pktlen=%d\n", \ 		    head->m_len, head->m_pkthdr.len);\ } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MBUF_HEADER_CHECK
parameter_list|(
name|m
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|IPH_OFFSET
value|(2 + sizeof (struct cpl_rx_pkt) + ETHER_HDR_LEN)
end_define

begin_define
define|#
directive|define
name|LRO_SESSION_IDX_HINT_HASH
parameter_list|(
name|hash
parameter_list|)
value|(hash& (MAX_LRO_PER_QSET - 1))
end_define

begin_define
define|#
directive|define
name|LRO_IDX_INC
parameter_list|(
name|idx
parameter_list|)
value|idx = (idx + 1)& (MAX_LRO_PER_QSET - 1)
end_define

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|sge_lro_session
operator|*
name|lro_session
argument_list|(
argument|struct sge_lro *l
argument_list|,
argument|int idx
argument_list|)
block|{
return|return
name|l
operator|->
name|s
operator|+
name|idx
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|__inline
name|int
name|lro_match_session
parameter_list|(
name|struct
name|sge_lro_session
modifier|*
name|s
parameter_list|,
name|struct
name|ip
modifier|*
name|ih
parameter_list|,
name|struct
name|tcphdr
modifier|*
name|th
parameter_list|)
block|{
name|struct
name|ip
modifier|*
name|sih
init|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|s
operator|->
name|mh
operator|.
name|mh_head
operator|->
name|m_data
operator|+
name|IPH_OFFSET
operator|)
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|sth
init|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
name|sih
operator|+
literal|1
operator|)
decl_stmt|;
comment|/* 	 * Linux driver doesn't include destination port check -- 	 * need to find out why XXX 	 */
return|return
operator|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|th
operator|->
name|th_sport
operator|==
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|sth
operator|->
name|th_sport
operator|&&
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|th
operator|->
name|th_dport
operator|==
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|sth
operator|->
name|th_dport
operator|&&
name|ih
operator|->
name|ip_src
operator|.
name|s_addr
operator|==
name|ih
operator|->
name|ip_src
operator|.
name|s_addr
operator|&&
name|ih
operator|->
name|ip_dst
operator|.
name|s_addr
operator|==
name|sih
operator|->
name|ip_dst
operator|.
name|s_addr
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|sge_lro_session
operator|*
name|lro_find_session
argument_list|(
argument|struct sge_lro *l
argument_list|,
argument|int idx
argument_list|,
argument|struct ip *ih
argument_list|,
argument|struct tcphdr *th
argument_list|)
block|{ 	struct
name|sge_lro_session
operator|*
name|s
block|;
name|int
name|active
operator|=
literal|0
block|;
while|while
condition|(
name|active
operator|<
name|l
operator|->
name|num_active
condition|)
block|{
name|s
operator|=
name|lro_session
argument_list|(
name|l
argument_list|,
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|mh
operator|.
name|mh_head
condition|)
block|{
if|if
condition|(
name|lro_match_session
argument_list|(
name|s
argument_list|,
name|ih
argument_list|,
name|th
argument_list|)
condition|)
block|{
name|l
operator|->
name|last_s
operator|=
name|s
expr_stmt|;
return|return
name|s
return|;
block|}
name|active
operator|++
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|} 		LRO_IDX_INC
operator|(
name|idx
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  	return
name|NULL
expr_stmt|;
end_expr_stmt

begin_function
unit|}  static
name|__inline
name|int
name|can_lro_packet
parameter_list|(
name|struct
name|cpl_rx_pkt
modifier|*
name|cpl
parameter_list|,
name|unsigned
name|int
name|rss_hi
parameter_list|)
block|{
name|struct
name|ether_header
modifier|*
name|eh
init|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
operator|(
name|cpl
operator|+
literal|1
operator|)
decl_stmt|;
name|struct
name|ip
modifier|*
name|ih
init|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|eh
operator|+
literal|1
operator|)
decl_stmt|;
comment|/*  	 * XXX VLAN support? 	 */
if|if
condition|(
name|__predict_false
argument_list|(
name|G_HASHTYPE
argument_list|(
name|ntohl
argument_list|(
name|rss_hi
argument_list|)
argument_list|)
operator|!=
name|RSS_HASH_4_TUPLE
operator|||
operator|(
operator|*
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|cpl
operator|+
literal|1
operator|)
operator|&
literal|0x90
operator|)
operator|!=
literal|0x10
operator|||
name|cpl
operator|->
name|csum
operator|!=
literal|0xffff
operator|||
name|eh
operator|->
name|ether_type
operator|!=
name|ntohs
argument_list|(
name|ETHERTYPE_IP
argument_list|)
operator|||
name|ih
operator|->
name|ip_hl
operator|!=
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|ih
argument_list|)
operator|>>
literal|2
operator|)
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|can_lro_tcpsegment
parameter_list|(
name|struct
name|tcphdr
modifier|*
name|th
parameter_list|)
block|{
name|int
name|olen
init|=
operator|(
name|th
operator|->
name|th_off
operator|<<
literal|2
operator|)
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|th
argument_list|)
decl_stmt|;
name|u8
name|control_bits
init|=
operator|*
operator|(
operator|(
name|u8
operator|*
operator|)
name|th
operator|+
literal|13
operator|)
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|(
name|control_bits
operator|&
literal|0xB7
operator|)
operator|!=
literal|0x10
argument_list|)
condition|)
goto|goto
name|no_lro
goto|;
if|if
condition|(
name|olen
condition|)
block|{
name|uint32_t
modifier|*
name|ptr
init|=
operator|(
name|u32
operator|*
operator|)
operator|(
name|th
operator|+
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|olen
operator|!=
name|TCPOLEN_TSTAMP_APPA
operator|||
operator|*
name|ptr
operator|!=
name|ntohl
argument_list|(
operator|(
name|TCPOPT_NOP
operator|<<
literal|24
operator|)
operator||
operator|(
name|TCPOPT_NOP
operator|<<
literal|16
operator|)
operator||
operator|(
name|TCPOPT_TIMESTAMP
operator|<<
literal|8
operator|)
operator||
name|TCPOLEN_TIMESTAMP
argument_list|)
argument_list|)
condition|)
goto|goto
name|no_lro
goto|;
block|}
return|return
literal|1
return|;
name|no_lro
label|:
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|lro_new_session_init
parameter_list|(
name|struct
name|sge_lro_session
modifier|*
name|s
parameter_list|,
name|struct
name|t3_mbuf_hdr
modifier|*
name|mh
parameter_list|)
block|{
name|struct
name|ip
modifier|*
name|ih
init|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|mh
operator|->
name|mh_head
operator|->
name|m_data
operator|+
name|IPH_OFFSET
operator|)
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|th
init|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
name|ih
operator|+
literal|1
operator|)
decl_stmt|;
name|int
name|ip_len
init|=
name|ntohs
argument_list|(
name|ih
operator|->
name|ip_len
argument_list|)
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"%s(s=%p, mh->mh_head=%p, mh->mh_tail=%p)\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|s
argument_list|,
name|mh
operator|->
name|mh_head
argument_list|,
name|mh
operator|->
name|mh_tail
argument_list|)
expr_stmt|;
operator|*
operator|&
operator|(
name|s
operator|->
name|mh
operator|)
operator|=
operator|*
name|mh
expr_stmt|;
name|MBUF_HEADER_CHECK
argument_list|(
name|mh
argument_list|)
expr_stmt|;
name|s
operator|->
name|ip_len
operator|=
name|ip_len
expr_stmt|;
name|s
operator|->
name|seq
operator|=
name|ntohl
argument_list|(
name|th
operator|->
name|th_seq
argument_list|)
operator|+
name|ip_len
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|ih
argument_list|)
operator|-
operator|(
name|th
operator|->
name|th_off
operator|<<
literal|2
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lro_flush_session
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|,
name|struct
name|sge_lro_session
modifier|*
name|s
parameter_list|,
name|struct
name|t3_mbuf_hdr
modifier|*
name|mh
parameter_list|)
block|{
name|struct
name|sge_lro
modifier|*
name|l
init|=
operator|&
name|qs
operator|->
name|lro
decl_stmt|;
name|struct
name|t3_mbuf_hdr
modifier|*
name|smh
init|=
operator|&
name|s
operator|->
name|mh
decl_stmt|;
name|struct
name|ip
modifier|*
name|ih
init|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|smh
operator|->
name|mh_head
operator|->
name|m_data
operator|+
name|IPH_OFFSET
operator|)
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"%s(qs=%p, s=%p, "
argument_list|,
name|__FUNCTION__
argument_list|,
name|qs
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|mh
condition|)
name|DPRINTF
argument_list|(
literal|"mh->mh_head=%p, mh->mh_tail=%p)\n"
argument_list|,
name|mh
operator|->
name|mh_head
argument_list|,
name|mh
operator|->
name|mh_tail
argument_list|)
expr_stmt|;
else|else
name|DPRINTF
argument_list|(
literal|"mh=NULL)\n"
argument_list|)
expr_stmt|;
name|ih
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|s
operator|->
name|ip_len
argument_list|)
expr_stmt|;
name|ih
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
name|ih
operator|->
name|ip_sum
operator|=
name|in_cksum_hdr
argument_list|(
name|ih
argument_list|)
expr_stmt|;
name|MBUF_HEADER_CHECK
argument_list|(
name|smh
argument_list|)
expr_stmt|;
name|smh
operator|->
name|mh_head
operator|->
name|m_flags
operator||=
name|M_LRO
expr_stmt|;
name|t3_rx_eth
argument_list|(
name|qs
operator|->
name|port
argument_list|,
operator|&
name|qs
operator|->
name|rspq
argument_list|,
name|smh
operator|->
name|mh_head
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|mh
condition|)
block|{
operator|*
name|smh
operator|=
operator|*
name|mh
expr_stmt|;
name|lro_new_session_init
argument_list|(
name|s
argument_list|,
name|mh
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|smh
operator|->
name|mh_head
operator|=
name|NULL
expr_stmt|;
name|smh
operator|->
name|mh_tail
operator|=
name|NULL
expr_stmt|;
name|l
operator|->
name|num_active
operator|--
expr_stmt|;
block|}
name|qs
operator|->
name|port_stats
index|[
name|SGE_PSTATS_LRO_FLUSHED
index|]
operator|++
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|sge_lro_session
operator|*
name|lro_new_session
argument_list|(
argument|struct sge_qset *qs
argument_list|,
argument|struct t3_mbuf_hdr *mh
argument_list|,
argument|uint32_t rss_hash
argument_list|)
block|{ 	struct
name|sge_lro
operator|*
name|l
operator|=
operator|&
name|qs
operator|->
name|lro
block|;
name|int
name|idx
operator|=
name|LRO_SESSION_IDX_HINT_HASH
argument_list|(
name|rss_hash
argument_list|)
block|;  	struct
name|sge_lro_session
operator|*
name|s
operator|=
name|lro_session
argument_list|(
name|l
argument_list|,
name|idx
argument_list|)
block|;
name|DPRINTF
argument_list|(
literal|"%s(qs=%p,  mh->mh_head=%p, mh->mh_tail=%p, rss_hash=0x%x)\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|qs
argument_list|,
name|mh
operator|->
name|mh_head
argument_list|,
name|mh
operator|->
name|mh_tail
argument_list|,
name|rss_hash
argument_list|)
block|;
if|if
condition|(
name|__predict_true
argument_list|(
operator|!
name|s
operator|->
name|mh
operator|.
name|mh_head
argument_list|)
condition|)
goto|goto
name|done
goto|;
end_expr_stmt

begin_if
if|if
condition|(
name|l
operator|->
name|num_active
operator|>
name|MAX_LRO_PER_QSET
condition|)
name|panic
argument_list|(
literal|"MAX_LRO_PER_QSET exceeded"
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|l
operator|->
name|num_active
operator|==
name|MAX_LRO_PER_QSET
condition|)
block|{
name|lro_flush_session
argument_list|(
name|qs
argument_list|,
name|s
argument_list|,
name|mh
argument_list|)
expr_stmt|;
name|qs
operator|->
name|port_stats
index|[
name|SGE_PSTATS_LRO_X_STREAMS
index|]
operator|++
expr_stmt|;
return|return
name|s
return|;
block|}
end_if

begin_while
while|while
condition|(
literal|1
condition|)
block|{
name|LRO_IDX_INC
argument_list|(
name|idx
argument_list|)
expr_stmt|;
name|s
operator|=
name|lro_session
argument_list|(
name|l
argument_list|,
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|mh
operator|.
name|mh_head
condition|)
break|break;
block|}
end_while

begin_label
name|done
label|:
end_label

begin_expr_stmt
name|lro_new_session_init
argument_list|(
name|s
argument_list|,
name|mh
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|l
operator|->
name|num_active
operator|++
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|s
return|;
end_return

begin_function
unit|}  static
name|__inline
name|int
name|lro_update_session
parameter_list|(
name|struct
name|sge_lro_session
modifier|*
name|s
parameter_list|,
name|struct
name|t3_mbuf_hdr
modifier|*
name|mh
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|mh
operator|->
name|mh_head
decl_stmt|;
name|struct
name|t3_mbuf_hdr
modifier|*
name|smh
init|=
operator|&
name|s
operator|->
name|mh
decl_stmt|;
name|struct
name|cpl_rx_pkt
modifier|*
name|cpl
init|=
operator|(
expr|struct
name|cpl_rx_pkt
operator|*
operator|)
operator|(
name|smh
operator|->
name|mh_head
operator|->
name|m_data
operator|+
literal|2
operator|)
decl_stmt|;
name|struct
name|cpl_rx_pkt
modifier|*
name|ncpl
init|=
operator|(
expr|struct
name|cpl_rx_pkt
operator|*
operator|)
operator|(
name|m
operator|->
name|m_data
operator|+
literal|2
operator|)
decl_stmt|;
name|struct
name|ip
modifier|*
name|nih
init|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|m
operator|->
name|m_data
operator|+
name|IPH_OFFSET
operator|)
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|,
modifier|*
name|nth
init|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
name|nih
operator|+
literal|1
operator|)
decl_stmt|;
name|uint32_t
name|seq
init|=
name|ntohl
argument_list|(
name|nth
operator|->
name|th_seq
argument_list|)
decl_stmt|;
name|int
name|plen
decl_stmt|,
name|tcpiphlen
decl_stmt|,
name|olen
init|=
operator|(
name|nth
operator|->
name|th_off
operator|<<
literal|2
operator|)
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|nth
argument_list|)
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"%s(s=%p,  mh->mh_head=%p, mh->mh_tail=%p)\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|s
argument_list|,
name|mh
operator|->
name|mh_head
argument_list|,
name|mh
operator|->
name|mh_tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpl
operator|->
name|vlan_valid
operator|&&
name|cpl
operator|->
name|vlan
operator|!=
name|ncpl
operator|->
name|vlan
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|__predict_false
argument_list|(
name|seq
operator|!=
name|s
operator|->
name|seq
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"sequence mismatch\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|MBUF_HEADER_CHECK
argument_list|(
name|smh
argument_list|)
expr_stmt|;
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
name|smh
operator|->
name|mh_head
operator|->
name|m_data
operator|+
name|IPH_OFFSET
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|olen
condition|)
block|{
name|uint32_t
modifier|*
name|ptr
init|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|th
operator|+
literal|1
operator|)
decl_stmt|;
name|uint32_t
modifier|*
name|nptr
init|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|nth
operator|+
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|ntohl
argument_list|(
operator|*
operator|(
name|ptr
operator|+
literal|1
operator|)
argument_list|)
operator|>
name|ntohl
argument_list|(
operator|*
operator|(
name|nptr
operator|+
literal|1
operator|)
argument_list|)
operator|||
operator|!
operator|*
operator|(
name|nptr
operator|+
literal|2
operator|)
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
operator|*
operator|(
name|ptr
operator|+
literal|1
operator|)
operator|=
operator|*
operator|(
name|nptr
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
operator|(
name|ptr
operator|+
literal|2
operator|)
operator|=
operator|*
operator|(
name|nptr
operator|+
literal|2
operator|)
expr_stmt|;
block|}
name|th
operator|->
name|th_ack
operator|=
name|nth
operator|->
name|th_ack
expr_stmt|;
name|th
operator|->
name|th_win
operator|=
name|nth
operator|->
name|th_win
expr_stmt|;
name|tcpiphlen
operator|=
operator|(
name|nth
operator|->
name|th_off
operator|<<
literal|2
operator|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|nih
argument_list|)
expr_stmt|;
name|plen
operator|=
name|ntohs
argument_list|(
name|nih
operator|->
name|ip_len
argument_list|)
operator|-
name|tcpiphlen
expr_stmt|;
name|s
operator|->
name|seq
operator|+=
name|plen
expr_stmt|;
name|s
operator|->
name|ip_len
operator|+=
name|plen
expr_stmt|;
name|smh
operator|->
name|mh_head
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|plen
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX this I *do not* understand */
block|if (plen> skb_shinfo(s->skb)->gso_size) 		skb_shinfo(s->skb)->gso_size = plen;
endif|#
directive|endif
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|700000
if|if
condition|(
name|plen
operator|>
name|smh
operator|->
name|mh_head
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
condition|)
name|smh
operator|->
name|mh_head
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
operator|=
name|plen
expr_stmt|;
endif|#
directive|endif
name|DPRINTF
argument_list|(
literal|"m_adj(%d)\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|IPH_OFFSET
operator|+
name|tcpiphlen
argument_list|)
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
name|IPH_OFFSET
operator|+
name|tcpiphlen
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (__predict_false(!skb_shinfo(s->skb)->frag_list)) 		skb_shinfo(s->skb)->frag_list = skb;
endif|#
directive|endif
name|mh
operator|->
name|mh_head
operator|->
name|m_flags
operator|&=
operator|~
name|M_PKTHDR
expr_stmt|;
name|smh
operator|->
name|mh_tail
operator|->
name|m_next
operator|=
name|mh
operator|->
name|mh_head
expr_stmt|;
name|smh
operator|->
name|mh_tail
operator|=
name|mh
operator|->
name|mh_tail
expr_stmt|;
if|#
directive|if
literal|0
comment|/*  	 * XXX we really need to be able to 	 * support vectors of buffers in FreeBSD 	 */
block|int nr = skb_shinfo(s->skb)->nr_frags; 	skb_shinfo(s->skb)->frags[nr].page = frag->page; 	skb_shinfo(s->skb)->frags[nr].page_offset =  	    frag->page_offset + IPH_OFFSET + tcpiphlen; 	skb_shinfo(s->skb)->frags[nr].size = plen;  	skb_shinfo(s->skb)->nr_frags = ++nr;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|t3_rx_eth_lro
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|struct
name|sge_rspq
modifier|*
name|rq
parameter_list|,
name|struct
name|t3_mbuf_hdr
modifier|*
name|mh
parameter_list|,
name|int
name|ethpad
parameter_list|,
name|uint32_t
name|rss_hash
parameter_list|,
name|uint32_t
name|rss_csum
parameter_list|,
name|int
name|lro
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|mh
operator|->
name|mh_head
decl_stmt|;
name|struct
name|sge_qset
modifier|*
name|qs
init|=
name|rspq_to_qset
argument_list|(
name|rq
argument_list|)
decl_stmt|;
name|struct
name|cpl_rx_pkt
modifier|*
name|cpl
init|=
operator|(
expr|struct
name|cpl_rx_pkt
operator|*
operator|)
operator|(
name|m
operator|->
name|m_data
operator|+
name|ethpad
operator|)
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
init|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
operator|(
name|cpl
operator|+
literal|1
operator|)
decl_stmt|;
name|struct
name|ip
modifier|*
name|ih
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|;
name|struct
name|sge_lro_session
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|qs
operator|->
name|port
decl_stmt|;
if|if
condition|(
name|lro
operator|==
literal|0
condition|)
goto|goto
name|no_lro
goto|;
if|if
condition|(
operator|!
name|can_lro_packet
argument_list|(
name|cpl
argument_list|,
name|rss_csum
argument_list|)
condition|)
goto|goto
name|no_lro
goto|;
if|if
condition|(
operator|&
name|adap
operator|->
name|port
index|[
name|cpl
operator|->
name|iff
index|]
operator|!=
name|pi
condition|)
name|panic
argument_list|(
literal|"bad port index %d\n"
argument_list|,
name|cpl
operator|->
name|iff
argument_list|)
expr_stmt|;
name|ih
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|eh
operator|+
literal|1
operator|)
expr_stmt|;
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
name|ih
operator|+
literal|1
operator|)
expr_stmt|;
name|s
operator|=
name|lro_find_session
argument_list|(
operator|&
name|qs
operator|->
name|lro
argument_list|,
name|LRO_SESSION_IDX_HINT_HASH
argument_list|(
name|rss_hash
argument_list|)
argument_list|,
name|ih
argument_list|,
name|th
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
name|can_lro_tcpsegment
argument_list|(
name|th
argument_list|)
argument_list|)
condition|)
block|{
goto|goto
name|no_lro
goto|;
block|}
elseif|else
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
name|s
argument_list|)
condition|)
block|{
name|s
operator|=
name|lro_new_session
argument_list|(
name|qs
argument_list|,
name|mh
argument_list|,
name|rss_hash
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|lro_update_session
argument_list|(
name|s
argument_list|,
name|mh
argument_list|)
condition|)
block|{
name|lro_flush_session
argument_list|(
name|qs
argument_list|,
name|s
argument_list|,
name|mh
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|__predict_false
argument_list|(
name|s
operator|->
name|mh
operator|.
name|mh_head
operator|->
name|m_pkthdr
operator|.
name|len
operator|+
name|pi
operator|->
name|ifp
operator|->
name|if_mtu
operator|>
literal|65535
argument_list|)
condition|)
block|{
name|lro_flush_session
argument_list|(
name|qs
argument_list|,
name|s
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|qs
operator|->
name|port_stats
index|[
name|SGE_PSTATS_LRO_QUEUED
index|]
operator|++
expr_stmt|;
return|return;
name|no_lro
label|:
if|if
condition|(
name|s
condition|)
name|lro_flush_session
argument_list|(
name|qs
argument_list|,
name|s
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|==
literal|0
operator|||
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|==
literal|0
operator|||
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
condition|)
name|DPRINTF
argument_list|(
literal|"rx_eth_lro mbuf len=%d pktlen=%d flags=0x%x\n"
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
expr_stmt|;
name|t3_rx_eth
argument_list|(
name|pi
argument_list|,
name|rq
argument_list|,
name|m
argument_list|,
name|ethpad
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t3_sge_lro_flush_all
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|,
name|struct
name|sge_qset
modifier|*
name|qs
parameter_list|)
block|{
name|struct
name|sge_lro
modifier|*
name|l
init|=
operator|&
name|qs
operator|->
name|lro
decl_stmt|;
name|struct
name|sge_lro_session
modifier|*
name|s
init|=
name|l
operator|->
name|last_s
decl_stmt|;
name|int
name|active
init|=
literal|0
decl_stmt|,
name|idx
init|=
literal|0
decl_stmt|,
name|num_active
init|=
name|l
operator|->
name|num_active
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
name|s
argument_list|)
condition|)
name|s
operator|=
name|lro_session
argument_list|(
name|l
argument_list|,
name|idx
argument_list|)
expr_stmt|;
while|while
condition|(
name|active
operator|<
name|num_active
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|mh
operator|.
name|mh_head
condition|)
block|{
name|lro_flush_session
argument_list|(
name|qs
argument_list|,
name|s
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|active
operator|++
expr_stmt|;
block|}
name|LRO_IDX_INC
argument_list|(
name|idx
argument_list|)
expr_stmt|;
name|s
operator|=
name|lro_session
argument_list|(
name|l
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

