begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************************  Copyright (c) 2007-2009, Chelsio Inc. All rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:   1. Redistributions of source code must retain the above copyright notice,     this list of conditions and the following disclaimer.   2. Neither the name of the Chelsio Corporation nor the names of its     contributors may be used to endorse or promote products derived from     this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/pciio.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/firmware.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pci_private.h>
end_include

begin_include
include|#
directive|include
file|<cxgb_include.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PRIV_SUPPORTED
end_ifdef

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|cxgb_setup_interrupts
parameter_list|(
name|adapter_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgb_teardown_interrupts
parameter_list|(
name|adapter_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgb_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgb_init_locked
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgb_uninit_locked
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgb_uninit_synchronized
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgb_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|unsigned
name|long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgb_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgb_ifm_type
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgb_build_medialist
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgb_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|cxgb_get_counter
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|ift_counter
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|setup_sge_qsets
parameter_list|(
name|adapter_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgb_async_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgb_tick_handler
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgb_tick
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|link_check_callout
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_link_status
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|setup_rss
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|alloc_filters
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|setup_hw_filters
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_filter
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|struct
name|filter_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|mk_set_tcb_field
parameter_list|(
name|struct
name|cpl_set_tcb_field
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|u64
parameter_list|,
name|u64
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|set_tcb_field_ulp
parameter_list|(
name|struct
name|cpl_set_tcb_field
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|u64
parameter_list|,
name|u64
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
end_ifdef

begin_function_decl
specifier|static
name|int
name|cpl_not_handled
parameter_list|(
name|struct
name|sge_qset
modifier|*
parameter_list|,
name|struct
name|rsp_desc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Attachment glue for the PCI controller end of the device.  Each port of  * the device is attached separately, as defined later.  */
end_comment

begin_function_decl
specifier|static
name|int
name|cxgb_controller_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgb_controller_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgb_controller_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgb_free
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|reg_block_dump
parameter_list|(
name|struct
name|adapter
modifier|*
name|ap
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|unsigned
name|int
name|start
parameter_list|,
name|unsigned
name|int
name|end
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgb_get_regs
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|,
name|struct
name|ch_ifconf_regs
modifier|*
name|regs
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgb_get_regs_len
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|touch_bars
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgb_update_mac_settings
parameter_list|(
name|struct
name|port_info
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
end_ifdef

begin_function_decl
specifier|static
name|int
name|toe_capability
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|device_method_t
name|cxgb_controller_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|cxgb_controller_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|cxgb_controller_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|cxgb_controller_detach
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|cxgb_controller_driver
init|=
block|{
literal|"cxgbc"
block|,
name|cxgb_controller_methods
block|,
expr|sizeof
operator|(
expr|struct
name|adapter
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|cxgbc_mod_event
parameter_list|(
name|module_t
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|devclass_t
name|cxgb_controller_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|cxgbc
argument_list|,
name|pci
argument_list|,
name|cxgb_controller_driver
argument_list|,
name|cxgb_controller_devclass
argument_list|,
name|cxgbc_mod_event
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|cxgbc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|cxgbc
argument_list|,
name|firmware
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Attachment glue for the ports.  Attachment is done directly to the  * controller device.  */
end_comment

begin_function_decl
specifier|static
name|int
name|cxgb_port_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgb_port_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgb_port_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|cxgb_port_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|cxgb_port_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|cxgb_port_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|cxgb_port_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|cxgb_port_driver
init|=
block|{
literal|"cxgb"
block|,
name|cxgb_port_methods
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|cxgb_extension_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|cxgb_extension_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|cxgb_extension_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|cxgb_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
literal|0
block|,
operator|.
name|d_open
operator|=
name|cxgb_extension_open
block|,
operator|.
name|d_close
operator|=
name|cxgb_extension_close
block|,
operator|.
name|d_ioctl
operator|=
name|cxgb_extension_ioctl
block|,
operator|.
name|d_name
operator|=
literal|"cxgb"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|cxgb_port_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|cxgb
argument_list|,
name|cxgbc
argument_list|,
name|cxgb_port_driver
argument_list|,
name|cxgb_port_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|cxgb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|t3_list_lock
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|SLIST_HEAD
argument_list|(
argument_list|,
argument|adapter
argument_list|)
name|t3_list
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|t3_uld_list_lock
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|SLIST_HEAD
argument_list|(
argument_list|,
argument|uld_info
argument_list|)
name|t3_uld_list
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The driver uses the best interrupt scheme available on a platform in the  * order MSI-X, MSI, legacy pin interrupts.  This parameter determines which  * of these schemes the driver may consider as follows:  *  * msi = 2: choose from among all three options  * msi = 1 : only consider MSI and pin interrupts  * msi = 0: force pin interrupts  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|msi_allowed
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|cxgb
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"CXGB driver parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_cxgb
argument_list|,
name|OID_AUTO
argument_list|,
name|msi_allowed
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|msi_allowed
argument_list|,
literal|0
argument_list|,
literal|"MSI-X, MSI, INTx selector"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * The driver uses an auto-queue algorithm by default.  * To disable it and force a single queue-set per port, use multiq = 0  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|multiq
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_cxgb
argument_list|,
name|OID_AUTO
argument_list|,
name|multiq
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|multiq
argument_list|,
literal|0
argument_list|,
literal|"use min(ncpus/ports, 8) queue-sets per port"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * By default the driver will not update the firmware unless  * it was compiled against a newer version  *   */
end_comment

begin_decl_stmt
specifier|static
name|int
name|force_fw_update
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_cxgb
argument_list|,
name|OID_AUTO
argument_list|,
name|force_fw_update
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|force_fw_update
argument_list|,
literal|0
argument_list|,
literal|"update firmware even if up to date"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|cxgb_use_16k_clusters
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_cxgb
argument_list|,
name|OID_AUTO
argument_list|,
name|use_16k_clusters
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|cxgb_use_16k_clusters
argument_list|,
literal|0
argument_list|,
literal|"use 16kB clusters for the jumbo queue "
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|nfilters
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_cxgb
argument_list|,
name|OID_AUTO
argument_list|,
name|nfilters
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|nfilters
argument_list|,
literal|0
argument_list|,
literal|"max number of entries in the filter table"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_enum
enum|enum
block|{
name|MAX_TXQ_ENTRIES
init|=
literal|16384
block|,
name|MAX_CTRL_TXQ_ENTRIES
init|=
literal|1024
block|,
name|MAX_RSPQ_ENTRIES
init|=
literal|16384
block|,
name|MAX_RX_BUFFERS
init|=
literal|16384
block|,
name|MAX_RX_JUMBO_BUFFERS
init|=
literal|16384
block|,
name|MIN_TXQ_ENTRIES
init|=
literal|4
block|,
name|MIN_CTRL_TXQ_ENTRIES
init|=
literal|4
block|,
name|MIN_RSPQ_ENTRIES
init|=
literal|32
block|,
name|MIN_FL_ENTRIES
init|=
literal|32
block|,
name|MIN_FL_JUMBO_ENTRIES
init|=
literal|32
block|}
enum|;
end_enum

begin_struct
struct|struct
name|filter_info
block|{
name|u32
name|sip
decl_stmt|;
name|u32
name|sip_mask
decl_stmt|;
name|u32
name|dip
decl_stmt|;
name|u16
name|sport
decl_stmt|;
name|u16
name|dport
decl_stmt|;
name|u32
name|vlan
range|:
literal|12
decl_stmt|;
name|u32
name|vlan_prio
range|:
literal|3
decl_stmt|;
name|u32
name|mac_hit
range|:
literal|1
decl_stmt|;
name|u32
name|mac_idx
range|:
literal|4
decl_stmt|;
name|u32
name|mac_vld
range|:
literal|1
decl_stmt|;
name|u32
name|pkt_type
range|:
literal|2
decl_stmt|;
name|u32
name|report_filter_id
range|:
literal|1
decl_stmt|;
name|u32
name|pass
range|:
literal|1
decl_stmt|;
name|u32
name|rss
range|:
literal|1
decl_stmt|;
name|u32
name|qset
range|:
literal|3
decl_stmt|;
name|u32
name|locked
range|:
literal|1
decl_stmt|;
name|u32
name|valid
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
block|{
name|FILTER_NO_VLAN_PRI
init|=
literal|7
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|EEPROM_MAGIC
value|0x38E2F10C
end_define

begin_define
define|#
directive|define
name|PORT_MASK
value|((1<< MAX_NPORTS) - 1)
end_define

begin_comment
comment|/* Table for probing the cards.  The desc field isn't actually used */
end_comment

begin_struct
struct|struct
name|cxgb_ident
block|{
name|uint16_t
name|vendor
decl_stmt|;
name|uint16_t
name|device
decl_stmt|;
name|int
name|index
decl_stmt|;
name|char
modifier|*
name|desc
decl_stmt|;
block|}
name|cxgb_identifiers
index|[]
init|=
block|{
block|{
name|PCI_VENDOR_ID_CHELSIO
block|,
literal|0x0020
block|,
literal|0
block|,
literal|"PE9000"
block|}
block|,
block|{
name|PCI_VENDOR_ID_CHELSIO
block|,
literal|0x0021
block|,
literal|1
block|,
literal|"T302E"
block|}
block|,
block|{
name|PCI_VENDOR_ID_CHELSIO
block|,
literal|0x0022
block|,
literal|2
block|,
literal|"T310E"
block|}
block|,
block|{
name|PCI_VENDOR_ID_CHELSIO
block|,
literal|0x0023
block|,
literal|3
block|,
literal|"T320X"
block|}
block|,
block|{
name|PCI_VENDOR_ID_CHELSIO
block|,
literal|0x0024
block|,
literal|1
block|,
literal|"T302X"
block|}
block|,
block|{
name|PCI_VENDOR_ID_CHELSIO
block|,
literal|0x0025
block|,
literal|3
block|,
literal|"T320E"
block|}
block|,
block|{
name|PCI_VENDOR_ID_CHELSIO
block|,
literal|0x0026
block|,
literal|2
block|,
literal|"T310X"
block|}
block|,
block|{
name|PCI_VENDOR_ID_CHELSIO
block|,
literal|0x0030
block|,
literal|2
block|,
literal|"T3B10"
block|}
block|,
block|{
name|PCI_VENDOR_ID_CHELSIO
block|,
literal|0x0031
block|,
literal|3
block|,
literal|"T3B20"
block|}
block|,
block|{
name|PCI_VENDOR_ID_CHELSIO
block|,
literal|0x0032
block|,
literal|1
block|,
literal|"T3B02"
block|}
block|,
block|{
name|PCI_VENDOR_ID_CHELSIO
block|,
literal|0x0033
block|,
literal|4
block|,
literal|"T3B04"
block|}
block|,
block|{
name|PCI_VENDOR_ID_CHELSIO
block|,
literal|0x0035
block|,
literal|6
block|,
literal|"T3C10"
block|}
block|,
block|{
name|PCI_VENDOR_ID_CHELSIO
block|,
literal|0x0036
block|,
literal|3
block|,
literal|"S320E-CR"
block|}
block|,
block|{
name|PCI_VENDOR_ID_CHELSIO
block|,
literal|0x0037
block|,
literal|7
block|,
literal|"N320E-G2"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|set_eeprom
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|__inline
name|char
name|t3rev2char
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|char
name|rev
init|=
literal|'z'
decl_stmt|;
switch|switch
condition|(
name|adapter
operator|->
name|params
operator|.
name|rev
condition|)
block|{
case|case
name|T3_REV_A
case|:
name|rev
operator|=
literal|'a'
expr_stmt|;
break|break;
case|case
name|T3_REV_B
case|:
case|case
name|T3_REV_B2
case|:
name|rev
operator|=
literal|'b'
expr_stmt|;
break|break;
case|case
name|T3_REV_C
case|:
name|rev
operator|=
literal|'c'
expr_stmt|;
break|break;
block|}
return|return
name|rev
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|cxgb_ident
modifier|*
name|cxgb_get_ident
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|cxgb_ident
modifier|*
name|id
decl_stmt|;
for|for
control|(
name|id
operator|=
name|cxgb_identifiers
init|;
name|id
operator|->
name|desc
operator|!=
name|NULL
condition|;
name|id
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|id
operator|->
name|vendor
operator|==
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|)
operator|&&
operator|(
name|id
operator|->
name|device
operator|==
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
name|id
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|struct
name|adapter_info
modifier|*
name|cxgb_get_adapter_info
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|cxgb_ident
modifier|*
name|id
decl_stmt|;
specifier|const
name|struct
name|adapter_info
modifier|*
name|ai
decl_stmt|;
name|id
operator|=
name|cxgb_get_ident
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ai
operator|=
name|t3_get_adapter_info
argument_list|(
name|id
operator|->
name|index
argument_list|)
expr_stmt|;
return|return
operator|(
name|ai
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_controller_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
specifier|const
name|struct
name|adapter_info
modifier|*
name|ai
decl_stmt|;
name|char
modifier|*
name|ports
decl_stmt|,
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|int
name|nports
decl_stmt|;
name|ai
operator|=
name|cxgb_get_adapter_info
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|nports
operator|=
name|ai
operator|->
name|nports0
operator|+
name|ai
operator|->
name|nports1
expr_stmt|;
if|if
condition|(
name|nports
operator|==
literal|1
condition|)
name|ports
operator|=
literal|"port"
expr_stmt|;
else|else
name|ports
operator|=
literal|"ports"
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s, %d %s"
argument_list|,
name|ai
operator|->
name|desc
argument_list|,
name|nports
argument_list|,
name|ports
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|FW_FNAME
value|"cxgb_t3fw"
end_define

begin_define
define|#
directive|define
name|TPEEPROM_NAME
value|"cxgb_t3%c_tp_eeprom"
end_define

begin_define
define|#
directive|define
name|TPSRAM_NAME
value|"cxgb_t3%c_protocol_sram"
end_define

begin_function
specifier|static
name|int
name|upgrade_fw
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|struct
name|firmware
modifier|*
name|fw
decl_stmt|;
name|int
name|status
decl_stmt|;
name|u32
name|vers
decl_stmt|;
if|if
condition|(
operator|(
name|fw
operator|=
name|firmware_get
argument_list|(
name|FW_FNAME
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Could not find firmware image %s\n"
argument_list|,
name|FW_FNAME
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
else|else
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"installing firmware on card\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|t3_load_fw
argument_list|(
name|sc
argument_list|,
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|fw
operator|->
name|data
argument_list|,
name|fw
operator|->
name|datasize
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to install firmware: %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t3_get_fw_version
argument_list|(
name|sc
argument_list|,
operator|&
name|vers
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
operator|&
name|sc
operator|->
name|fw_version
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|fw_version
argument_list|)
argument_list|,
literal|"%d.%d.%d"
argument_list|,
name|G_FW_VERSION_MAJOR
argument_list|(
name|vers
argument_list|)
argument_list|,
name|G_FW_VERSION_MINOR
argument_list|(
name|vers
argument_list|)
argument_list|,
name|G_FW_VERSION_MICRO
argument_list|(
name|vers
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|firmware_put
argument_list|(
name|fw
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The cxgb_controller_attach function is responsible for the initial  * bringup of the device.  Its responsibilities include:  *  *  1. Determine if the device supports MSI or MSI-X.  *  2. Allocate bus resources so that we can access the Base Address Register  *  3. Create and initialize mutexes for the controller and its control  *     logic such as SGE and MDIO.  *  4. Call hardware specific setup routine for the adapter as a whole.  *  5. Allocate the BAR for doing MSI-X.  *  6. Setup the line interrupt iff MSI-X is not supported.  *  7. Create the driver's taskq.  *  8. Start one task queue service thread.  *  9. Check if the firmware and SRAM are up-to-date.  They will be  *     auto-updated later (before FULL_INIT_DONE), if required.  * 10. Create a child device for each MAC (port)  * 11. Initialize T3 private state.  * 12. Trigger the LED  * 13. Setup offload iff supported.  * 14. Reset/restart the tick callout.  * 15. Attach sysctls  *  * NOTE: Any modification or deviation from this list MUST be reflected in  * the above comment.  Failure to do so will result in problems on various  * error conditions including link flapping.  */
end_comment

begin_function
specifier|static
name|int
name|cxgb_controller_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_t
name|child
decl_stmt|;
specifier|const
name|struct
name|adapter_info
modifier|*
name|ai
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|uint32_t
name|vers
decl_stmt|;
name|int
name|port_qsets
init|=
literal|1
decl_stmt|;
name|int
name|msi_needed
decl_stmt|,
name|reg
decl_stmt|;
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|msi_count
operator|=
literal|0
expr_stmt|;
name|ai
operator|=
name|cxgb_get_adapter_info
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|sc
operator|->
name|lockbuf
argument_list|,
name|ADAPTER_LOCK_NAME_LEN
argument_list|,
literal|"cxgb controller lock %d"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ADAPTER_LOCK_INIT
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|lockbuf
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|sc
operator|->
name|reglockbuf
argument_list|,
name|ADAPTER_LOCK_NAME_LEN
argument_list|,
literal|"SGE reg lock %d"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|sc
operator|->
name|mdiolockbuf
argument_list|,
name|ADAPTER_LOCK_NAME_LEN
argument_list|,
literal|"cxgb mdio lock %d"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|sc
operator|->
name|elmerlockbuf
argument_list|,
name|ADAPTER_LOCK_NAME_LEN
argument_list|,
literal|"cxgb elmer lock %d"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|MTX_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|reg_lock
argument_list|,
name|sc
operator|->
name|reglockbuf
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
name|MTX_INIT
argument_list|(
operator|&
name|sc
operator|->
name|mdio_lock
argument_list|,
name|sc
operator|->
name|mdiolockbuf
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|MTX_INIT
argument_list|(
operator|&
name|sc
operator|->
name|elmer_lock
argument_list|,
name|sc
operator|->
name|elmerlockbuf
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|t3_list_lock
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|t3_list
argument_list|,
name|sc
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|t3_list_lock
argument_list|)
expr_stmt|;
comment|/* find the PCIe link width and set max read request to 4KB*/
if|if
condition|(
name|pci_find_cap
argument_list|(
name|dev
argument_list|,
name|PCIY_EXPRESS
argument_list|,
operator|&
name|reg
argument_list|)
operator|==
literal|0
condition|)
block|{
name|uint16_t
name|lnk
decl_stmt|;
name|lnk
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|reg
operator|+
name|PCIER_LINK_STA
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|link_width
operator|=
operator|(
name|lnk
operator|&
name|PCIEM_LINK_STA_WIDTH
operator|)
operator|>>
literal|4
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|link_width
operator|<
literal|8
operator|&&
operator|(
name|ai
operator|->
name|caps
operator|&
name|SUPPORTED_10000baseT_Full
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"PCIe x%d Link, expect reduced performance\n"
argument_list|,
name|sc
operator|->
name|link_width
argument_list|)
expr_stmt|;
block|}
name|pci_set_max_read_req
argument_list|(
name|dev
argument_list|,
literal|4096
argument_list|)
expr_stmt|;
block|}
name|touch_bars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate the registers and make them available to the driver. 	 * The registers that we care about for NIC mode are in BAR 0 	 */
name|sc
operator|->
name|regs_rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|regs_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|regs_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot allocate BAR region 0\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|sc
operator|->
name|bt
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|regs_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|regs_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mmio_len
operator|=
name|rman_get_size
argument_list|(
name|sc
operator|->
name|regs_res
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_NPORTS
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|port
index|[
name|i
index|]
operator|.
name|adapter
operator|=
name|sc
expr_stmt|;
if|if
condition|(
name|t3_prep_adapter
argument_list|(
name|sc
argument_list|,
name|ai
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"prep adapter failed\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|sc
operator|->
name|udbs_rid
operator|=
name|PCIR_BAR
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|udbs_res
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|is_offload
argument_list|(
name|sc
argument_list|)
operator|&&
operator|(
operator|(
name|sc
operator|->
name|udbs_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|udbs_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot allocate BAR region 1\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Allocate the BAR for doing MSI-X.  If it succeeds, try to allocate 	 * enough messages for the queue sets.  If that fails, try falling 	 * back to MSI.  If that fails, then try falling back to the legacy 	 * interrupt pin model. 	 */
name|sc
operator|->
name|msix_regs_rid
operator|=
literal|0x20
expr_stmt|;
if|if
condition|(
operator|(
name|msi_allowed
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|sc
operator|->
name|msix_regs_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|msix_regs_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|multiq
condition|)
name|port_qsets
operator|=
name|min
argument_list|(
name|SGE_QSETS
operator|/
name|sc
operator|->
name|params
operator|.
name|nports
argument_list|,
name|mp_ncpus
argument_list|)
expr_stmt|;
name|msi_needed
operator|=
name|sc
operator|->
name|msi_count
operator|=
name|sc
operator|->
name|params
operator|.
name|nports
operator|*
name|port_qsets
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|pci_msix_count
argument_list|(
name|dev
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|error
operator|=
name|pci_alloc_msix
argument_list|(
name|dev
argument_list|,
operator|&
name|sc
operator|->
name|msi_count
argument_list|)
operator|)
operator|!=
literal|0
operator|||
name|sc
operator|->
name|msi_count
operator|!=
name|msi_needed
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"alloc msix failed - "
literal|"msi_count=%d, msi_needed=%d, err=%d; "
literal|"will try MSI\n"
argument_list|,
name|sc
operator|->
name|msi_count
argument_list|,
name|msi_needed
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msi_count
operator|=
literal|0
expr_stmt|;
name|port_qsets
operator|=
literal|1
expr_stmt|;
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|msix_regs_rid
argument_list|,
name|sc
operator|->
name|msix_regs_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msix_regs_res
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|flags
operator||=
name|USING_MSIX
expr_stmt|;
name|sc
operator|->
name|cxgb_intr
operator|=
name|cxgb_async_intr
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"using MSI-X interrupts (%u vectors)\n"
argument_list|,
name|sc
operator|->
name|msi_count
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|msi_allowed
operator|>=
literal|1
operator|)
operator|&&
operator|(
name|sc
operator|->
name|msi_count
operator|==
literal|0
operator|)
condition|)
block|{
name|sc
operator|->
name|msi_count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|pci_alloc_msi
argument_list|(
name|dev
argument_list|,
operator|&
name|sc
operator|->
name|msi_count
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"alloc msi failed - "
literal|"err=%d; will try INTx\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msi_count
operator|=
literal|0
expr_stmt|;
name|port_qsets
operator|=
literal|1
expr_stmt|;
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|flags
operator||=
name|USING_MSI
expr_stmt|;
name|sc
operator|->
name|cxgb_intr
operator|=
name|t3_intr_msi
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"using MSI interrupts\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|msi_count
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"using line interrupts\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cxgb_intr
operator|=
name|t3b_intr
expr_stmt|;
block|}
comment|/* Create a private taskqueue thread for handling driver events */
name|sc
operator|->
name|tq
operator|=
name|taskqueue_create
argument_list|(
literal|"cxgb_taskq"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|sc
operator|->
name|tq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to allocate controller task queue\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|taskqueue_start_threads
argument_list|(
operator|&
name|sc
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s taskq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|tick_task
argument_list|,
literal|0
argument_list|,
name|cxgb_tick_handler
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* Create a periodic callout for checking adapter status */
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|cxgb_tick_ch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t3_check_fw_version
argument_list|(
name|sc
argument_list|)
operator|<
literal|0
operator|||
name|force_fw_update
condition|)
block|{
comment|/* 		 * Warn user that a firmware update will be attempted in init. 		 */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"firmware needs to be updated to version %d.%d.%d\n"
argument_list|,
name|FW_VERSION_MAJOR
argument_list|,
name|FW_VERSION_MINOR
argument_list|,
name|FW_VERSION_MICRO
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator|&=
operator|~
name|FW_UPTODATE
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|flags
operator||=
name|FW_UPTODATE
expr_stmt|;
block|}
if|if
condition|(
name|t3_check_tpsram_version
argument_list|(
name|sc
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* 		 * Warn user that a firmware update will be attempted in init. 		 */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"SRAM needs to be updated to version %c-%d.%d.%d\n"
argument_list|,
name|t3rev2char
argument_list|(
name|sc
argument_list|)
argument_list|,
name|TP_VERSION_MAJOR
argument_list|,
name|TP_VERSION_MINOR
argument_list|,
name|TP_VERSION_MICRO
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator|&=
operator|~
name|TPS_UPTODATE
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|flags
operator||=
name|TPS_UPTODATE
expr_stmt|;
block|}
comment|/* 	 * Create a child device for each MAC.  The ethernet attachment 	 * will be done in these children. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|sc
operator|)
operator|->
name|params
operator|.
name|nports
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|port_info
modifier|*
name|pi
decl_stmt|;
if|if
condition|(
operator|(
name|child
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"cxgb"
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to add child port\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|pi
operator|=
operator|&
name|sc
operator|->
name|port
index|[
name|i
index|]
expr_stmt|;
name|pi
operator|->
name|adapter
operator|=
name|sc
expr_stmt|;
name|pi
operator|->
name|nqsets
operator|=
name|port_qsets
expr_stmt|;
name|pi
operator|->
name|first_qset
operator|=
name|i
operator|*
name|port_qsets
expr_stmt|;
name|pi
operator|->
name|port_id
operator|=
name|i
expr_stmt|;
name|pi
operator|->
name|tx_chan
operator|=
name|i
operator|>=
name|ai
operator|->
name|nports0
expr_stmt|;
name|pi
operator|->
name|txpkt_intf
operator|=
name|pi
operator|->
name|tx_chan
condition|?
literal|2
operator|*
operator|(
name|i
operator|-
name|ai
operator|->
name|nports0
operator|)
operator|+
literal|1
else|:
literal|2
operator|*
name|i
expr_stmt|;
name|sc
operator|->
name|rxpkt_map
index|[
name|pi
operator|->
name|txpkt_intf
index|]
operator|=
name|i
expr_stmt|;
name|sc
operator|->
name|port
index|[
name|i
index|]
operator|.
name|tx_chan
operator|=
name|i
operator|>=
name|ai
operator|->
name|nports0
expr_stmt|;
name|sc
operator|->
name|portdev
index|[
name|i
index|]
operator|=
name|child
expr_stmt|;
name|device_set_softc
argument_list|(
name|child
argument_list|,
name|pi
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* initialize sge private state */
name|t3_sge_init_adapter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|t3_led_ready
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|t3_get_fw_version
argument_list|(
name|sc
argument_list|,
operator|&
name|vers
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|snprintf
argument_list|(
operator|&
name|sc
operator|->
name|fw_version
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|fw_version
argument_list|)
argument_list|,
literal|"%d.%d.%d"
argument_list|,
name|G_FW_VERSION_MAJOR
argument_list|(
name|vers
argument_list|)
argument_list|,
name|G_FW_VERSION_MINOR
argument_list|(
name|vers
argument_list|)
argument_list|,
name|G_FW_VERSION_MICRO
argument_list|(
name|vers
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s %sNIC\t E/C: %s S/N: %s"
argument_list|,
name|ai
operator|->
name|desc
argument_list|,
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|?
literal|"R"
else|:
literal|""
argument_list|,
name|sc
operator|->
name|params
operator|.
name|vpd
operator|.
name|ec
argument_list|,
name|sc
operator|->
name|params
operator|.
name|vpd
operator|.
name|sn
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
operator|&
name|sc
operator|->
name|port_types
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|port_types
argument_list|)
argument_list|,
literal|"%x%x%x%x"
argument_list|,
name|sc
operator|->
name|params
operator|.
name|vpd
operator|.
name|port_type
index|[
literal|0
index|]
argument_list|,
name|sc
operator|->
name|params
operator|.
name|vpd
operator|.
name|port_type
index|[
literal|1
index|]
argument_list|,
name|sc
operator|->
name|params
operator|.
name|vpd
operator|.
name|port_type
index|[
literal|2
index|]
argument_list|,
name|sc
operator|->
name|params
operator|.
name|vpd
operator|.
name|port_type
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Firmware Version %s\n"
argument_list|,
operator|&
name|sc
operator|->
name|fw_version
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|cxgb_tick_ch
argument_list|,
name|hz
argument_list|,
name|cxgb_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|t3_add_attach_sysctls
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_CPL_HANDLERS
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|cpl_handler
index|[
name|i
index|]
operator|=
name|cpl_not_handled
expr_stmt|;
endif|#
directive|endif
name|t3_intr_clear
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|cxgb_setup_interrupts
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|error
condition|)
name|cxgb_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The cxgb_controller_detach routine is called with the device is  * unloaded from the system.  */
end_comment

begin_function
specifier|static
name|int
name|cxgb_controller_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|cxgb_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The cxgb_free() is called by the cxgb_controller_detach() routine  * to tear down the structures that were built up in  * cxgb_controller_attach(), and should be the final piece of work  * done when fully unloading the driver.  *   *  *  1. Shutting down the threads started by the cxgb_controller_attach()  *     routine.  *  2. Stopping the lower level device and all callouts (cxgb_down_locked()).  *  3. Detaching all of the port devices created during the  *     cxgb_controller_attach() routine.  *  4. Removing the device children created via cxgb_controller_attach().  *  5. Releasing PCI resources associated with the device.  *  6. Turning off the offload support, iff it was turned on.  *  7. Destroying the mutexes created in cxgb_controller_attach().  *  */
end_comment

begin_function
specifier|static
name|void
name|cxgb_free
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|nqsets
init|=
literal|0
decl_stmt|;
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|CXGB_SHUTDOWN
expr_stmt|;
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure all child devices are gone. 	 */
name|bus_generic_detach
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|sc
operator|)
operator|->
name|params
operator|.
name|nports
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|portdev
index|[
name|i
index|]
operator|&&
name|device_delete_child
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|portdev
index|[
name|i
index|]
argument_list|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to delete child port\n"
argument_list|)
expr_stmt|;
name|nqsets
operator|+=
name|sc
operator|->
name|port
index|[
name|i
index|]
operator|.
name|nqsets
expr_stmt|;
block|}
comment|/* 	 * At this point, it is as if cxgb_port_detach has run on all ports, and 	 * cxgb_down has run on the adapter.  All interrupts have been silenced, 	 * all open devices have been closed. 	 */
name|KASSERT
argument_list|(
name|sc
operator|->
name|open_device_map
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: device(s) still open (%x)"
operator|,
name|__func__
operator|,
name|sc
operator|->
name|open_device_map
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|params
operator|.
name|nports
condition|;
name|i
operator|++
control|)
block|{
name|KASSERT
argument_list|(
name|sc
operator|->
name|port
index|[
name|i
index|]
operator|.
name|ifp
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: port %i undead!"
operator|,
name|__func__
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Finish off the adapter's callouts. 	 */
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|cxgb_tick_ch
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sge_timer_ch
argument_list|)
expr_stmt|;
comment|/* 	 * Release resources grabbed under FULL_INIT_DONE by cxgb_up.  The 	 * sysctls are cleaned up by the kernel linker. 	 */
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
condition|)
block|{
name|t3_free_sge_resources
argument_list|(
name|sc
argument_list|,
name|nqsets
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator|&=
operator|~
name|FULL_INIT_DONE
expr_stmt|;
block|}
comment|/* 	 * Release all interrupt resources. 	 */
name|cxgb_teardown_interrupts
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
operator|(
name|USING_MSI
operator||
name|USING_MSIX
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"releasing msi message(s)\n"
argument_list|)
expr_stmt|;
name|pci_release_msi
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"no msi message to release\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|msix_regs_res
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|msix_regs_rid
argument_list|,
name|sc
operator|->
name|msix_regs_res
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Free the adapter's taskqueue. 	 */
if|if
condition|(
name|sc
operator|->
name|tq
operator|!=
name|NULL
condition|)
block|{
name|taskqueue_free
argument_list|(
name|sc
operator|->
name|tq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tq
operator|=
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
name|sc
operator|->
name|filters
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|t3_sge_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|udbs_res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|udbs_rid
argument_list|,
name|sc
operator|->
name|udbs_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|regs_res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|regs_rid
argument_list|,
name|sc
operator|->
name|regs_res
argument_list|)
expr_stmt|;
name|MTX_DESTROY
argument_list|(
operator|&
name|sc
operator|->
name|mdio_lock
argument_list|)
expr_stmt|;
name|MTX_DESTROY
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
name|MTX_DESTROY
argument_list|(
operator|&
name|sc
operator|->
name|elmer_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|t3_list_lock
argument_list|)
expr_stmt|;
name|SLIST_REMOVE
argument_list|(
operator|&
name|t3_list
argument_list|,
name|sc
argument_list|,
name|adapter
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|t3_list_lock
argument_list|)
expr_stmt|;
name|ADAPTER_LOCK_DEINIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	setup_sge_qsets - configure SGE Tx/Rx/response queues  *	@sc: the controller softc  *  *	Determines how many sets of SGE queues to use and initializes them.  *	We support multiple queue sets per port if we have MSI-X, otherwise  *	just one queue set per port.  */
end_comment

begin_function
specifier|static
name|int
name|setup_sge_qsets
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|err
decl_stmt|,
name|irq_idx
init|=
literal|0
decl_stmt|,
name|qset_idx
init|=
literal|0
decl_stmt|;
name|u_int
name|ntxq
init|=
name|SGE_TXQ_PER_SET
decl_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|t3_sge_alloc
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"t3_sge_alloc returned %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|params
operator|.
name|rev
operator|>
literal|0
operator|&&
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|USING_MSI
operator|)
condition|)
name|irq_idx
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|sc
operator|)
operator|->
name|params
operator|.
name|nports
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
operator|&
name|sc
operator|->
name|port
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pi
operator|->
name|nqsets
condition|;
name|j
operator|++
operator|,
name|qset_idx
operator|++
control|)
block|{
name|err
operator|=
name|t3_sge_alloc_qset
argument_list|(
name|sc
argument_list|,
name|qset_idx
argument_list|,
operator|(
name|sc
operator|)
operator|->
name|params
operator|.
name|nports
argument_list|,
operator|(
name|sc
operator|->
name|flags
operator|&
name|USING_MSIX
operator|)
condition|?
name|qset_idx
operator|+
literal|1
else|:
name|irq_idx
argument_list|,
operator|&
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|qset
index|[
name|qset_idx
index|]
argument_list|,
name|ntxq
argument_list|,
name|pi
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|t3_free_sge_resources
argument_list|(
name|sc
argument_list|,
name|qset_idx
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"t3_sge_alloc_qset failed with %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_teardown_interrupts
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SGE_QSETS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|msix_intr_tag
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
comment|/* Should have been setup fully or not at all */
name|KASSERT
argument_list|(
name|sc
operator|->
name|msix_irq_res
index|[
name|i
index|]
operator|==
name|NULL
operator|&&
name|sc
operator|->
name|msix_irq_rid
index|[
name|i
index|]
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: half-done interrupt (%d)."
operator|,
name|__func__
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|bus_teardown_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|msix_irq_res
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|msix_intr_tag
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|msix_irq_rid
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|msix_irq_res
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msix_irq_res
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|msix_intr_tag
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|msix_irq_rid
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|intr_tag
condition|)
block|{
name|KASSERT
argument_list|(
name|sc
operator|->
name|irq_res
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: half-done interrupt."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|sc
operator|->
name|intr_tag
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irq_rid
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq_res
operator|=
name|sc
operator|->
name|intr_tag
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|irq_rid
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_setup_interrupts
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|void
modifier|*
name|tag
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rid
decl_stmt|,
name|err
decl_stmt|,
name|intr_flag
init|=
name|sc
operator|->
name|flags
operator|&
operator|(
name|USING_MSI
operator||
name|USING_MSIX
operator|)
decl_stmt|;
name|sc
operator|->
name|irq_rid
operator|=
name|intr_flag
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|sc
operator|->
name|irq_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|irq_rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot allocate interrupt (%x, %u)\n"
argument_list|,
name|intr_flag
argument_list|,
name|sc
operator|->
name|irq_rid
argument_list|)
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
name|sc
operator|->
name|irq_rid
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|INTR_MPSAFE
operator||
name|INTR_TYPE_NET
argument_list|,
name|NULL
argument_list|,
name|sc
operator|->
name|cxgb_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|intr_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot set up interrupt (%x, %u, %d)\n"
argument_list|,
name|intr_flag
argument_list|,
name|sc
operator|->
name|irq_rid
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irq_rid
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq_res
operator|=
name|sc
operator|->
name|intr_tag
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|irq_rid
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* That's all for INTx or MSI */
if|if
condition|(
operator|!
operator|(
name|intr_flag
operator|&
name|USING_MSIX
operator|)
operator|||
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|bus_describe_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|sc
operator|->
name|intr_tag
argument_list|,
literal|"err"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|msi_count
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|rid
operator|=
name|i
operator|+
literal|2
expr_stmt|;
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot allocate interrupt "
literal|"for message %d\n"
argument_list|,
name|rid
argument_list|)
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|err
operator|=
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|res
argument_list|,
name|INTR_MPSAFE
operator||
name|INTR_TYPE_NET
argument_list|,
name|NULL
argument_list|,
name|t3_intr_msix
argument_list|,
operator|&
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
name|i
index|]
argument_list|,
operator|&
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot set up interrupt "
literal|"for message %d (%d)\n"
argument_list|,
name|rid
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
name|res
argument_list|)
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|msix_irq_rid
index|[
name|i
index|]
operator|=
name|rid
expr_stmt|;
name|sc
operator|->
name|msix_irq_res
index|[
name|i
index|]
operator|=
name|res
expr_stmt|;
name|sc
operator|->
name|msix_intr_tag
index|[
name|i
index|]
operator|=
name|tag
expr_stmt|;
name|bus_describe_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|res
argument_list|,
name|tag
argument_list|,
literal|"qs%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
name|cxgb_teardown_interrupts
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_port_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|p
decl_stmt|;
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|desc
decl_stmt|;
name|p
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|desc
operator|=
name|p
operator|->
name|phy
operator|.
name|desc
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"Port %d %s"
argument_list|,
name|p
operator|->
name|port_id
argument_list|,
name|desc
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_makedev
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
name|pi
operator|->
name|port_cdev
operator|=
name|make_dev
argument_list|(
operator|&
name|cxgb_cdevsw
argument_list|,
name|pi
operator|->
name|ifp
operator|->
name|if_dunit
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"%s"
argument_list|,
name|if_name
argument_list|(
name|pi
operator|->
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|port_cdev
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|pi
operator|->
name|port_cdev
operator|->
name|si_drv1
operator|=
operator|(
name|void
operator|*
operator|)
name|pi
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|CXGB_CAP
value|(IFCAP_VLAN_HWTAGGING | IFCAP_VLAN_MTU | IFCAP_HWCSUM | \     IFCAP_VLAN_HWCSUM | IFCAP_TSO | IFCAP_JUMBO_MTU | IFCAP_LRO | \     IFCAP_VLAN_HWTSO | IFCAP_LINKSTATE | IFCAP_HWCSUM_IPV6)
end_define

begin_define
define|#
directive|define
name|CXGB_CAP_ENABLE
value|CXGB_CAP
end_define

begin_function
specifier|static
name|int
name|cxgb_port_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|p
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|err
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
decl_stmt|;
name|p
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|=
name|p
operator|->
name|adapter
expr_stmt|;
name|snprintf
argument_list|(
name|p
operator|->
name|lockbuf
argument_list|,
name|PORT_NAME_LEN
argument_list|,
literal|"cxgb port lock %d:%d"
argument_list|,
name|device_get_unit
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|p
operator|->
name|port_id
argument_list|)
expr_stmt|;
name|PORT_LOCK_INIT
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|lockbuf
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|p
operator|->
name|link_check_ch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|p
operator|->
name|link_check_task
argument_list|,
literal|0
argument_list|,
name|check_link_status
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* Allocate an ifnet object and set it up */
name|ifp
operator|=
name|p
operator|->
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot allocate ifnet\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|cxgb_init
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|p
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|cxgb_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_transmit
operator|=
name|cxgb_transmit
expr_stmt|;
name|ifp
operator|->
name|if_qflush
operator|=
name|cxgb_qflush
expr_stmt|;
name|ifp
operator|->
name|if_get_counter
operator|=
name|cxgb_get_counter
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator|=
name|CXGB_CAP
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
if|if
condition|(
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|)
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_TOE4
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_capenable
operator|=
name|CXGB_CAP_ENABLE
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|=
name|CSUM_TCP
operator||
name|CSUM_UDP
operator||
name|CSUM_IP
operator||
name|CSUM_TSO
operator||
name|CSUM_UDP_IPV6
operator||
name|CSUM_TCP_IPV6
expr_stmt|;
comment|/* 	 * Disable TSO on 4-port - it isn't supported by the firmware. 	 */
if|if
condition|(
name|sc
operator|->
name|params
operator|.
name|nports
operator|>
literal|2
condition|)
block|{
name|ifp
operator|->
name|if_capabilities
operator|&=
operator|~
operator|(
name|IFCAP_TSO
operator||
name|IFCAP_VLAN_HWTSO
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
operator|(
name|IFCAP_TSO
operator||
name|IFCAP_VLAN_HWTSO
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|&=
operator|~
name|CSUM_TSO
expr_stmt|;
block|}
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|p
operator|->
name|hw_addr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEFAULT_JUMBO
if|if
condition|(
name|sc
operator|->
name|params
operator|.
name|nports
operator|<=
literal|2
condition|)
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU_JUMBO
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|err
operator|=
name|cxgb_makedev
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"makedev failed %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* Create a list of media supported by this port */
name|ifmedia_init
argument_list|(
operator|&
name|p
operator|->
name|media
argument_list|,
name|IFM_IMASK
argument_list|,
name|cxgb_media_change
argument_list|,
name|cxgb_media_status
argument_list|)
expr_stmt|;
name|cxgb_build_medialist
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|t3_sge_init_port
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cxgb_port_detach() is called via the device_detach methods when  * cxgb_free() calls the bus_generic_detach.  It is responsible for   * removing the device from the view of the kernel, i.e. from all   * interfaces lists etc.  This routine is only called when the driver is   * being unloaded, not when the link goes down.  */
end_comment

begin_function
specifier|static
name|int
name|cxgb_port_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|p
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|p
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|=
name|p
operator|->
name|adapter
expr_stmt|;
comment|/* Tell cxgb_ioctl and if_init that the port is going away */
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|SET_DOOMED
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|flags
argument_list|)
expr_stmt|;
while|while
condition|(
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
condition|)
name|mtx_sleep
argument_list|(
operator|&
name|sc
operator|->
name|flags
argument_list|,
operator|&
name|sc
operator|->
name|lock
argument_list|,
literal|0
argument_list|,
literal|"cxgbdtch"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SET_BUSY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|port_cdev
operator|!=
name|NULL
condition|)
name|destroy_dev
argument_list|(
name|p
operator|->
name|port_cdev
argument_list|)
expr_stmt|;
name|cxgb_uninit_synchronized
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|p
operator|->
name|ifp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|p
operator|->
name|first_qset
init|;
name|i
operator|<
name|p
operator|->
name|first_qset
operator|+
name|p
operator|->
name|nqsets
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|sge_qset
modifier|*
name|qs
init|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
name|i
index|]
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
init|=
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
decl_stmt|;
name|callout_drain
argument_list|(
operator|&
name|txq
operator|->
name|txq_watchdog
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|txq
operator|->
name|txq_timer
argument_list|)
expr_stmt|;
block|}
name|PORT_LOCK_DEINIT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|p
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|p
operator|->
name|ifp
operator|=
name|NULL
expr_stmt|;
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CLR_BUSY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wakeup_one
argument_list|(
operator|&
name|sc
operator|->
name|flags
argument_list|)
expr_stmt|;
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|t3_fatal_err
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|u_int
name|fw_status
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
condition|)
block|{
name|t3_sge_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|A_XGM_TX_CTRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|A_XGM_RX_CTRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|XGM_REG
argument_list|(
name|A_XGM_TX_CTRL
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|XGM_REG
argument_list|(
name|A_XGM_RX_CTRL
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_intr_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"encountered fatal error, operation suspended\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t3_cim_ctl_blk_read
argument_list|(
name|sc
argument_list|,
literal|0xa0
argument_list|,
literal|4
argument_list|,
name|fw_status
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"FW_ status: 0x%x, 0x%x, 0x%x, 0x%x\n"
argument_list|,
name|fw_status
index|[
literal|0
index|]
argument_list|,
name|fw_status
index|[
literal|1
index|]
argument_list|,
name|fw_status
index|[
literal|2
index|]
argument_list|,
name|fw_status
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|t3_os_find_pci_capability
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|,
name|int
name|cap
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|uint8_t
name|ptr
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|cfg
operator|=
operator|&
name|dinfo
operator|->
name|cfg
expr_stmt|;
name|status
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_STATUS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|PCIM_STATUS_CAPPRESENT
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|cfg
operator|->
name|hdrtype
operator|&
name|PCIM_HDRTYPE
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
name|ptr
operator|=
name|PCIR_CAP_PTR
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|ptr
operator|=
name|PCIR_CAP_PTR_2
expr_stmt|;
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
break|break;
block|}
name|ptr
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|ptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|ptr
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|ptr
operator|+
name|PCICAP_ID
argument_list|,
literal|1
argument_list|)
operator|==
name|cap
condition|)
return|return
operator|(
name|ptr
operator|)
return|;
name|ptr
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|ptr
operator|+
name|PCICAP_NEXTPTR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t3_os_pci_save_state
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_cfg_save
argument_list|(
name|dev
argument_list|,
name|dinfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t3_os_pci_restore_state
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_cfg_restore
argument_list|(
name|dev
argument_list|,
name|dinfo
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_os_link_changed - handle link status changes  *	@sc: the adapter associated with the link change  *	@port_id: the port index whose link status has changed  *	@link_status: the new status of the link  *	@speed: the new speed setting  *	@duplex: the new duplex setting  *	@fc: the new flow-control setting  *  *	This is the OS-dependent handler for link status changes.  The OS  *	neutral handler takes care of most of the processing for these events,  *	then calls this handler for any OS-specific processing.  */
end_comment

begin_function
name|void
name|t3_os_link_changed
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|port_id
parameter_list|,
name|int
name|link_status
parameter_list|,
name|int
name|speed
parameter_list|,
name|int
name|duplex
parameter_list|,
name|int
name|fc
parameter_list|,
name|int
name|mac_was_reset
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
operator|&
name|adapter
operator|->
name|port
index|[
name|port_id
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|pi
operator|->
name|ifp
decl_stmt|;
comment|/* no race with detach, so ifp should always be good */
name|KASSERT
argument_list|(
name|ifp
argument_list|,
operator|(
literal|"%s: if detached."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* Reapply mac settings if they were lost due to a reset */
if|if
condition|(
name|mac_was_reset
condition|)
block|{
name|PORT_LOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|cxgb_update_mac_settings
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|PORT_UNLOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|link_status
condition|)
block|{
name|ifp
operator|->
name|if_baudrate
operator|=
name|IF_Mbps
argument_list|(
name|speed
argument_list|)
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
block|}
else|else
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t3_os_phymod_changed - handle PHY module changes  *	@phy: the PHY reporting the module change  *	@mod_type: new module type  *  *	This is the OS-dependent handler for PHY module changes.  It is  *	invoked when a PHY module is removed or inserted for any OS-specific  *	processing.  */
end_comment

begin_function
name|void
name|t3_os_phymod_changed
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|int
name|port_id
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|mod_str
index|[]
init|=
block|{
name|NULL
block|,
literal|"SR"
block|,
literal|"LR"
block|,
literal|"LRM"
block|,
literal|"TWINAX"
block|,
literal|"TWINAX-L"
block|,
literal|"unknown"
block|}
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
operator|&
name|adap
operator|->
name|port
index|[
name|port_id
index|]
decl_stmt|;
name|int
name|mod
init|=
name|pi
operator|->
name|phy
operator|.
name|modtype
decl_stmt|;
if|if
condition|(
name|mod
operator|!=
name|pi
operator|->
name|media
operator|.
name|ifm_cur
operator|->
name|ifm_data
condition|)
name|cxgb_build_medialist
argument_list|(
name|pi
argument_list|)
expr_stmt|;
if|if
condition|(
name|mod
operator|==
name|phy_modtype_none
condition|)
name|if_printf
argument_list|(
name|pi
operator|->
name|ifp
argument_list|,
literal|"PHY module unplugged\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|KASSERT
argument_list|(
name|mod
operator|<
name|ARRAY_SIZE
argument_list|(
name|mod_str
argument_list|)
argument_list|,
operator|(
literal|"invalid PHY module type %d"
operator|,
name|mod
operator|)
argument_list|)
expr_stmt|;
name|if_printf
argument_list|(
name|pi
operator|->
name|ifp
argument_list|,
literal|"%s PHY module inserted\n"
argument_list|,
name|mod_str
index|[
name|mod
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|t3_os_set_hw_addr
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|port_idx
parameter_list|,
name|u8
name|hw_addr
index|[]
parameter_list|)
block|{
comment|/* 	 * The ifnet might not be allocated before this gets called, 	 * as this is called early on in attach by t3_prep_adapter 	 * save the address off in the port structure 	 */
if|if
condition|(
name|cxgb_debug
condition|)
name|printf
argument_list|(
literal|"set_hw_addr on idx %d addr %6D\n"
argument_list|,
name|port_idx
argument_list|,
name|hw_addr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|hw_addr
argument_list|,
name|adapter
operator|->
name|port
index|[
name|port_idx
index|]
operator|.
name|hw_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Programs the XGMAC based on the settings in the ifnet.  These settings  * include MTU, MAC address, mcast addresses, etc.  */
end_comment

begin_function
specifier|static
name|void
name|cxgb_update_mac_settings
parameter_list|(
name|struct
name|port_info
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|p
operator|->
name|ifp
decl_stmt|;
name|struct
name|t3_rx_mode
name|rm
decl_stmt|;
name|struct
name|cmac
modifier|*
name|mac
init|=
operator|&
name|p
operator|->
name|mac
decl_stmt|;
name|int
name|mtu
decl_stmt|,
name|hwtagging
decl_stmt|;
name|PORT_LOCK_ASSERT_OWNED
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|p
operator|->
name|hw_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|mtu
operator|=
name|ifp
operator|->
name|if_mtu
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_MTU
condition|)
name|mtu
operator|+=
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
name|hwtagging
operator|=
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWTAGGING
operator|)
operator|!=
literal|0
expr_stmt|;
name|t3_mac_set_mtu
argument_list|(
name|mac
argument_list|,
name|mtu
argument_list|)
expr_stmt|;
name|t3_set_vlan_accel
argument_list|(
name|p
operator|->
name|adapter
argument_list|,
literal|1
operator|<<
name|p
operator|->
name|tx_chan
argument_list|,
name|hwtagging
argument_list|)
expr_stmt|;
name|t3_mac_set_address
argument_list|(
name|mac
argument_list|,
literal|0
argument_list|,
name|p
operator|->
name|hw_addr
argument_list|)
expr_stmt|;
name|t3_init_rx_mode
argument_list|(
operator|&
name|rm
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|t3_mac_set_rx_mode
argument_list|(
name|mac
argument_list|,
operator|&
name|rm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|await_mgmt_replies
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|long
name|init_cnt
parameter_list|,
name|unsigned
name|long
name|n
parameter_list|)
block|{
name|int
name|attempts
init|=
literal|5
decl_stmt|;
while|while
condition|(
name|adap
operator|->
name|sge
operator|.
name|qs
index|[
literal|0
index|]
operator|.
name|rspq
operator|.
name|offload_pkts
operator|<
name|init_cnt
operator|+
name|n
condition|)
block|{
if|if
condition|(
operator|!
operator|--
name|attempts
condition|)
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
name|t3_os_sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|init_tp_parity
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|cpl_set_tcb_field
modifier|*
name|greq
decl_stmt|;
name|unsigned
name|long
name|cnt
init|=
name|adap
operator|->
name|sge
operator|.
name|qs
index|[
literal|0
index|]
operator|.
name|rspq
operator|.
name|offload_pkts
decl_stmt|;
name|t3_tp_set_offload_mode
argument_list|(
name|adap
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|cpl_smt_write_req
modifier|*
name|req
decl_stmt|;
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_WAITOK
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|req
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|cpl_smt_write_req
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|req
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wrh_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_FORWARD
argument_list|)
argument_list|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|req
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_SMT_WRITE_REQ
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|iff
operator|=
name|i
expr_stmt|;
name|t3_mgmt_tx
argument_list|(
name|adap
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2048
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|cpl_l2t_write_req
modifier|*
name|req
decl_stmt|;
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_WAITOK
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|req
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|cpl_l2t_write_req
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|req
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wrh_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_FORWARD
argument_list|)
argument_list|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|req
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_L2T_WRITE_REQ
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|params
operator|=
name|htonl
argument_list|(
name|V_L2T_W_IDX
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|t3_mgmt_tx
argument_list|(
name|adap
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2048
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|cpl_rte_write_req
modifier|*
name|req
decl_stmt|;
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_WAITOK
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|req
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|cpl_rte_write_req
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|req
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wrh_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_FORWARD
argument_list|)
argument_list|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|req
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_RTE_WRITE_REQ
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|l2t_idx
operator|=
name|htonl
argument_list|(
name|V_L2T_W_IDX
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|t3_mgmt_tx
argument_list|(
name|adap
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_WAITOK
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|greq
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|cpl_set_tcb_field
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|greq
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|greq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|greq
argument_list|)
argument_list|)
expr_stmt|;
name|greq
operator|->
name|wr
operator|.
name|wrh_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_FORWARD
argument_list|)
argument_list|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|greq
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_SET_TCB_FIELD
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|greq
operator|->
name|mask
operator|=
name|htobe64
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|t3_mgmt_tx
argument_list|(
name|adap
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|i
operator|=
name|await_mgmt_replies
argument_list|(
name|adap
argument_list|,
name|cnt
argument_list|,
literal|16
operator|+
literal|2048
operator|+
literal|2048
operator|+
literal|1
argument_list|)
expr_stmt|;
name|t3_tp_set_offload_mode
argument_list|(
name|adap
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	setup_rss - configure Receive Side Steering (per-queue connection demux)   *	@adap: the adapter  *  *	Sets up RSS to distribute packets to multiple receive queues.  We  *	configure the RSS CPU lookup table to distribute to the number of HW  *	receive queues, and the response queue lookup table to narrow that  *	down to the response queues actually configured for each port.  *	We always configure the RSS mapping for two ports since the mapping  *	table has plenty of entries.  */
end_comment

begin_function
specifier|static
name|void
name|setup_rss
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int
name|nq
index|[
literal|2
index|]
decl_stmt|;
name|uint8_t
name|cpus
index|[
name|SGE_QSETS
operator|+
literal|1
index|]
decl_stmt|;
name|uint16_t
name|rspq_map
index|[
name|RSS_TABLE_SIZE
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SGE_QSETS
condition|;
operator|++
name|i
control|)
name|cpus
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|cpus
index|[
name|SGE_QSETS
index|]
operator|=
literal|0xff
expr_stmt|;
name|nq
index|[
literal|0
index|]
operator|=
name|nq
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|for_each_port
argument_list|(
argument|adap
argument_list|,
argument|i
argument_list|)
block|{
specifier|const
name|struct
name|port_info
modifier|*
name|pi
init|=
name|adap2pinfo
argument_list|(
name|adap
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|nq
index|[
name|pi
operator|->
name|tx_chan
index|]
operator|+=
name|pi
operator|->
name|nqsets
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RSS_TABLE_SIZE
operator|/
literal|2
condition|;
operator|++
name|i
control|)
block|{
name|rspq_map
index|[
name|i
index|]
operator|=
name|nq
index|[
literal|0
index|]
condition|?
name|i
operator|%
name|nq
index|[
literal|0
index|]
else|:
literal|0
expr_stmt|;
name|rspq_map
index|[
name|i
operator|+
name|RSS_TABLE_SIZE
operator|/
literal|2
index|]
operator|=
name|nq
index|[
literal|1
index|]
condition|?
name|i
operator|%
name|nq
index|[
literal|1
index|]
operator|+
name|nq
index|[
literal|0
index|]
else|:
literal|0
expr_stmt|;
block|}
comment|/* Calculate the reverse RSS map table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SGE_QSETS
condition|;
operator|++
name|i
control|)
name|adap
operator|->
name|rrss_map
index|[
name|i
index|]
operator|=
literal|0xff
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RSS_TABLE_SIZE
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|adap
operator|->
name|rrss_map
index|[
name|rspq_map
index|[
name|i
index|]
index|]
operator|==
literal|0xff
condition|)
name|adap
operator|->
name|rrss_map
index|[
name|rspq_map
index|[
name|i
index|]
index|]
operator|=
name|i
expr_stmt|;
name|t3_config_rss
argument_list|(
name|adap
argument_list|,
name|F_RQFEEDBACKENABLE
operator||
name|F_TNLLKPEN
operator||
name|F_TNLMAPEN
operator||
name|F_TNLPRTEN
operator||
name|F_TNL2TUPEN
operator||
name|F_TNL4TUPEN
operator||
name|F_OFDMAPEN
operator||
name|F_RRCPLMAPEN
operator||
name|V_RRCPLCPUSIZE
argument_list|(
literal|6
argument_list|)
operator||
name|F_HASHTOEPLITZ
argument_list|,
name|cpus
argument_list|,
name|rspq_map
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|send_pktsched_cmd
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|int
name|sched
parameter_list|,
name|int
name|qidx
parameter_list|,
name|int
name|lo
parameter_list|,
name|int
name|hi
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|mngt_pktsched_wr
modifier|*
name|req
decl_stmt|;
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|req
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|mngt_pktsched_wr
operator|*
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wrh_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_MNGT
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|mngt_opcode
operator|=
name|FW_MNGTOPCODE_PKTSCHED_SET
expr_stmt|;
name|req
operator|->
name|sched
operator|=
name|sched
expr_stmt|;
name|req
operator|->
name|idx
operator|=
name|qidx
expr_stmt|;
name|req
operator|->
name|min
operator|=
name|lo
expr_stmt|;
name|req
operator|->
name|max
operator|=
name|hi
expr_stmt|;
name|req
operator|->
name|binding
operator|=
name|port
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
expr_stmt|;
name|t3_mgmt_tx
argument_list|(
name|adap
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bind_qsets
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|sc
operator|)
operator|->
name|params
operator|.
name|nports
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|struct
name|port_info
modifier|*
name|pi
init|=
name|adap2pinfo
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pi
operator|->
name|nqsets
condition|;
operator|++
name|j
control|)
block|{
name|send_pktsched_cmd
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|,
name|pi
operator|->
name|first_qset
operator|+
name|j
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|pi
operator|->
name|tx_chan
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|update_tpeeprom
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|)
block|{
specifier|const
name|struct
name|firmware
modifier|*
name|tpeeprom
decl_stmt|;
name|uint32_t
name|version
decl_stmt|;
name|unsigned
name|int
name|major
decl_stmt|,
name|minor
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|len
decl_stmt|;
name|char
name|rev
decl_stmt|,
name|name
index|[
literal|32
index|]
decl_stmt|;
name|t3_seeprom_read
argument_list|(
name|adap
argument_list|,
name|TP_SRAM_OFFSET
argument_list|,
operator|&
name|version
argument_list|)
expr_stmt|;
name|major
operator|=
name|G_TP_VERSION_MAJOR
argument_list|(
name|version
argument_list|)
expr_stmt|;
name|minor
operator|=
name|G_TP_VERSION_MINOR
argument_list|(
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|major
operator|==
name|TP_VERSION_MAJOR
operator|&&
name|minor
operator|==
name|TP_VERSION_MINOR
condition|)
return|return;
name|rev
operator|=
name|t3rev2char
argument_list|(
name|adap
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
name|TPEEPROM_NAME
argument_list|,
name|rev
argument_list|)
expr_stmt|;
name|tpeeprom
operator|=
name|firmware_get
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpeeprom
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|adap
operator|->
name|dev
argument_list|,
literal|"could not load TP EEPROM: unable to load %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|len
operator|=
name|tpeeprom
operator|->
name|datasize
operator|-
literal|4
expr_stmt|;
name|ret
operator|=
name|t3_check_tpsram
argument_list|(
name|adap
argument_list|,
name|tpeeprom
operator|->
name|data
argument_list|,
name|tpeeprom
operator|->
name|datasize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|release_tpeeprom
goto|;
if|if
condition|(
name|len
operator|!=
name|TP_SRAM_LEN
condition|)
block|{
name|device_printf
argument_list|(
name|adap
operator|->
name|dev
argument_list|,
literal|"%s length is wrong len=%d expected=%d\n"
argument_list|,
name|name
argument_list|,
name|len
argument_list|,
name|TP_SRAM_LEN
argument_list|)
expr_stmt|;
return|return;
block|}
name|ret
operator|=
name|set_eeprom
argument_list|(
operator|&
name|adap
operator|->
name|port
index|[
literal|0
index|]
argument_list|,
name|tpeeprom
operator|->
name|data
argument_list|,
name|tpeeprom
operator|->
name|datasize
argument_list|,
name|TP_SRAM_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|device_printf
argument_list|(
name|adap
operator|->
name|dev
argument_list|,
literal|"Protocol SRAM image updated in EEPROM to %d.%d.%d\n"
argument_list|,
name|TP_VERSION_MAJOR
argument_list|,
name|TP_VERSION_MINOR
argument_list|,
name|TP_VERSION_MICRO
argument_list|)
expr_stmt|;
block|}
else|else
name|device_printf
argument_list|(
name|adap
operator|->
name|dev
argument_list|,
literal|"Protocol SRAM image update in EEPROM failed\n"
argument_list|)
expr_stmt|;
name|release_tpeeprom
label|:
name|firmware_put
argument_list|(
name|tpeeprom
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|update_tpsram
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|)
block|{
specifier|const
name|struct
name|firmware
modifier|*
name|tpsram
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|char
name|rev
decl_stmt|,
name|name
index|[
literal|32
index|]
decl_stmt|;
name|rev
operator|=
name|t3rev2char
argument_list|(
name|adap
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
name|TPSRAM_NAME
argument_list|,
name|rev
argument_list|)
expr_stmt|;
name|update_tpeeprom
argument_list|(
name|adap
argument_list|)
expr_stmt|;
name|tpsram
operator|=
name|firmware_get
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpsram
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|adap
operator|->
name|dev
argument_list|,
literal|"could not load TP SRAM\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
else|else
name|device_printf
argument_list|(
name|adap
operator|->
name|dev
argument_list|,
literal|"updating TP SRAM\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t3_check_tpsram
argument_list|(
name|adap
argument_list|,
name|tpsram
operator|->
name|data
argument_list|,
name|tpsram
operator|->
name|datasize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|release_tpsram
goto|;
name|ret
operator|=
name|t3_set_proto_sram
argument_list|(
name|adap
argument_list|,
name|tpsram
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|device_printf
argument_list|(
name|adap
operator|->
name|dev
argument_list|,
literal|"loading protocol SRAM failed\n"
argument_list|)
expr_stmt|;
name|release_tpsram
label|:
name|firmware_put
argument_list|(
name|tpsram
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  *	cxgb_up - enable the adapter  *	@adap: adapter being enabled  *  *	Called when the first port is enabled, this function performs the  *	actions necessary to make an adapter operational, such as completing  *	the initialization of HW modules, and enabling interrupts.  */
end_comment

begin_function
specifier|static
name|int
name|cxgb_up
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|mxf
init|=
name|t3_mc5_size
argument_list|(
operator|&
name|sc
operator|->
name|mc5
argument_list|)
operator|-
name|MC5_MIN_TIDS
decl_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|open_device_map
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: device(s) already open (%x)"
operator|,
name|__func__
operator|,
name|sc
operator|->
name|open_device_map
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
operator|)
operator|==
literal|0
condition|)
block|{
name|ADAPTER_LOCK_ASSERT_NOTOWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|FW_UPTODATE
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
operator|(
name|err
operator|=
name|upgrade_fw
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|TPS_UPTODATE
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
operator|(
name|err
operator|=
name|update_tpsram
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|is_offload
argument_list|(
name|sc
argument_list|)
operator|&&
name|nfilters
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|params
operator|.
name|mc5
operator|.
name|nservers
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nfilters
operator|<
literal|0
condition|)
name|sc
operator|->
name|params
operator|.
name|mc5
operator|.
name|nfilters
operator|=
name|mxf
expr_stmt|;
else|else
name|sc
operator|->
name|params
operator|.
name|mc5
operator|.
name|nfilters
operator|=
name|min
argument_list|(
name|nfilters
argument_list|,
name|mxf
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|t3_init_hw
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|t3_set_reg_field
argument_list|(
name|sc
argument_list|,
name|A_TP_PARA_REG5
argument_list|,
literal|0
argument_list|,
name|F_RXDDPOFFINIT
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|A_ULPRX_TDDP_PSZ
argument_list|,
name|V_HPZ0
argument_list|(
name|PAGE_SHIFT
operator|-
literal|12
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|setup_sge_qsets
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|alloc_filters
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|setup_rss
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|t3_add_configured_sysctls
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|FULL_INIT_DONE
expr_stmt|;
block|}
name|t3_intr_clear
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|t3_sge_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|t3_intr_enable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|params
operator|.
name|rev
operator|>=
name|T3_REV_C
operator|&&
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|TP_PARITY_INIT
operator|)
operator|&&
name|is_offload
argument_list|(
name|sc
argument_list|)
operator|&&
name|init_tp_parity
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|flags
operator||=
name|TP_PARITY_INIT
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|TP_PARITY_INIT
condition|)
block|{
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_INT_CAUSE
argument_list|,
name|F_CMCACHEPERR
operator||
name|F_ARPLUTPERR
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_INT_ENABLE
argument_list|,
literal|0x7fbfffff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|QUEUES_BOUND
operator|)
condition|)
block|{
name|bind_qsets
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|setup_hw_filters
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|QUEUES_BOUND
expr_stmt|;
block|}
name|t3_sge_reset_adapter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|out
label|:
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called when the last open device is closed.  Does NOT undo all of cxgb_up's  * work.  Specifically, the resources grabbed under FULL_INIT_DONE are released  * during controller_detach, not here.  */
end_comment

begin_function
specifier|static
name|void
name|cxgb_down
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|t3_sge_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|t3_intr_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * if_init for cxgb ports.  */
end_comment

begin_function
specifier|static
name|void
name|cxgb_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|p
init|=
name|arg
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|p
operator|->
name|adapter
decl_stmt|;
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cxgb_init_locked
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* releases adapter lock */
name|ADAPTER_LOCK_ASSERT_NOTOWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_init_locked
parameter_list|(
name|struct
name|port_info
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|p
operator|->
name|adapter
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|p
operator|->
name|ifp
decl_stmt|;
name|struct
name|cmac
modifier|*
name|mac
init|=
operator|&
name|p
operator|->
name|mac
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
init|=
literal|0
decl_stmt|,
name|may_sleep
init|=
literal|0
decl_stmt|,
name|gave_up_lock
init|=
literal|0
decl_stmt|;
name|ADAPTER_LOCK_ASSERT_OWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|IS_DOOMED
argument_list|(
name|p
argument_list|)
operator|&&
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|gave_up_lock
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|mtx_sleep
argument_list|(
operator|&
name|sc
operator|->
name|flags
argument_list|,
operator|&
name|sc
operator|->
name|lock
argument_list|,
name|PCATCH
argument_list|,
literal|"cxgbinit"
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rc
operator|=
name|EINTR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
name|IS_DOOMED
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|KASSERT
argument_list|(
operator|!
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
argument_list|,
operator|(
literal|"%s: controller busy."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * The code that runs during one-time adapter initialization can sleep 	 * so it's important not to hold any locks across it. 	 */
name|may_sleep
operator|=
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
condition|?
literal|0
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|may_sleep
condition|)
block|{
name|SET_BUSY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|gave_up_lock
operator|=
literal|1
expr_stmt|;
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|open_device_map
operator|==
literal|0
operator|&&
operator|(
operator|(
name|rc
operator|=
name|cxgb_up
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
goto|goto
name|done
goto|;
name|PORT_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
operator|&
name|sc
operator|->
name|open_device_map
argument_list|,
name|p
operator|->
name|port_id
argument_list|)
operator|&&
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|PORT_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|t3_port_intr_enable
argument_list|(
name|sc
argument_list|,
name|p
operator|->
name|port_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mac
operator|->
name|multiport
condition|)
name|t3_mac_init
argument_list|(
name|mac
argument_list|)
expr_stmt|;
name|cxgb_update_mac_settings
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|t3_link_start
argument_list|(
operator|&
name|p
operator|->
name|phy
argument_list|,
name|mac
argument_list|,
operator|&
name|p
operator|->
name|link_config
argument_list|)
expr_stmt|;
name|t3_mac_enable
argument_list|(
name|mac
argument_list|,
name|MAC_DIRECTION_RX
operator||
name|MAC_DIRECTION_TX
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|PORT_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|p
operator|->
name|first_qset
init|;
name|i
operator|<
name|p
operator|->
name|first_qset
operator|+
name|p
operator|->
name|nqsets
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|sge_qset
modifier|*
name|qs
init|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
name|i
index|]
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
init|=
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
decl_stmt|;
name|callout_reset_on
argument_list|(
operator|&
name|txq
operator|->
name|txq_watchdog
argument_list|,
name|hz
argument_list|,
name|cxgb_tx_watchdog
argument_list|,
name|qs
argument_list|,
name|txq
operator|->
name|txq_watchdog
operator|.
name|c_cpu
argument_list|)
expr_stmt|;
block|}
comment|/* all ok */
name|setbit
argument_list|(
operator|&
name|sc
operator|->
name|open_device_map
argument_list|,
name|p
operator|->
name|port_id
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|p
operator|->
name|link_check_ch
argument_list|,
name|p
operator|->
name|phy
operator|.
name|caps
operator|&
name|SUPPORTED_LINK_IRQ
condition|?
name|hz
operator|*
literal|3
else|:
name|hz
operator|/
literal|4
argument_list|,
name|link_check_callout
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|may_sleep
condition|)
block|{
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
argument_list|,
operator|(
literal|"%s: controller not busy."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|CLR_BUSY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gave_up_lock
condition|)
name|wakeup_one
argument_list|(
operator|&
name|sc
operator|->
name|flags
argument_list|)
expr_stmt|;
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_uninit_locked
parameter_list|(
name|struct
name|port_info
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|p
operator|->
name|adapter
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|ADAPTER_LOCK_ASSERT_OWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|IS_DOOMED
argument_list|(
name|p
argument_list|)
operator|&&
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
condition|)
block|{
if|if
condition|(
name|mtx_sleep
argument_list|(
operator|&
name|sc
operator|->
name|flags
argument_list|,
operator|&
name|sc
operator|->
name|lock
argument_list|,
name|PCATCH
argument_list|,
literal|"cxgbunin"
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rc
operator|=
name|EINTR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
name|IS_DOOMED
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|rc
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|KASSERT
argument_list|(
operator|!
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
argument_list|,
operator|(
literal|"%s: controller busy."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|SET_BUSY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rc
operator|=
name|cxgb_uninit_synchronized
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
argument_list|,
operator|(
literal|"%s: controller not busy."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|CLR_BUSY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wakeup_one
argument_list|(
operator|&
name|sc
operator|->
name|flags
argument_list|)
expr_stmt|;
name|done
label|:
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called on "ifconfig down", and from port_detach  */
end_comment

begin_function
specifier|static
name|int
name|cxgb_uninit_synchronized
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|pi
operator|->
name|ifp
decl_stmt|;
comment|/* 	 * taskqueue_drain may cause a deadlock if the adapter lock is held. 	 */
name|ADAPTER_LOCK_ASSERT_NOTOWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Clear this port's bit from the open device map, and then drain all 	 * the tasks that can access/manipulate this port's port_info or ifp. 	 * We disable this port's interrupts here and so the slow/ext 	 * interrupt tasks won't be enqueued.  The tick task will continue to 	 * be enqueued every second but the runs after this drain will not see 	 * this port in the open device map. 	 * 	 * A well behaved task must take open_device_map into account and ignore 	 * ports that are not open. 	 */
name|clrbit
argument_list|(
operator|&
name|sc
operator|->
name|open_device_map
argument_list|,
name|pi
operator|->
name|port_id
argument_list|)
expr_stmt|;
name|t3_port_intr_disable
argument_list|(
name|sc
argument_list|,
name|pi
operator|->
name|port_id
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|sc
operator|->
name|slow_intr_task
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|sc
operator|->
name|tick_task
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|pi
operator|->
name|link_check_ch
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|pi
operator|->
name|link_check_task
argument_list|)
expr_stmt|;
name|PORT_LOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
comment|/* disable pause frames */
name|t3_set_reg_field
argument_list|(
name|sc
argument_list|,
name|A_XGM_TX_CFG
operator|+
name|pi
operator|->
name|mac
operator|.
name|offset
argument_list|,
name|F_TXPAUSEEN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reset RX FIFO HWM */
name|t3_set_reg_field
argument_list|(
name|sc
argument_list|,
name|A_XGM_RXFIFO_CFG
operator|+
name|pi
operator|->
name|mac
operator|.
name|offset
argument_list|,
name|V_RXFIFOPAUSEHWM
argument_list|(
name|M_RXFIFOPAUSEHWM
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|/* Wait for TXFIFO empty */
name|t3_wait_op_done
argument_list|(
name|sc
argument_list|,
name|A_XGM_TXFIFO_CFG
operator|+
name|pi
operator|->
name|mac
operator|.
name|offset
argument_list|,
name|F_TXFIFO_EMPTY
argument_list|,
literal|1
argument_list|,
literal|20
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|t3_mac_disable
argument_list|(
operator|&
name|pi
operator|->
name|mac
argument_list|,
name|MAC_DIRECTION_RX
argument_list|)
expr_stmt|;
name|pi
operator|->
name|phy
operator|.
name|ops
operator|->
name|power_down
argument_list|(
operator|&
name|pi
operator|->
name|phy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PORT_UNLOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|pi
operator|->
name|link_config
operator|.
name|link_ok
operator|=
literal|0
expr_stmt|;
name|t3_os_link_changed
argument_list|(
name|sc
argument_list|,
name|pi
operator|->
name|port_id
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|open_device_map
operator|==
literal|0
condition|)
name|cxgb_down
argument_list|(
name|pi
operator|->
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Mark lro enabled or disabled in all qsets for this port  */
end_comment

begin_function
specifier|static
name|int
name|cxgb_set_lro
parameter_list|(
name|struct
name|port_info
modifier|*
name|p
parameter_list|,
name|int
name|enabled
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adp
init|=
name|p
operator|->
name|adapter
decl_stmt|;
name|struct
name|sge_qset
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|nqsets
condition|;
name|i
operator|++
control|)
block|{
name|q
operator|=
operator|&
name|adp
operator|->
name|sge
operator|.
name|qs
index|[
name|p
operator|->
name|first_qset
operator|+
name|i
index|]
expr_stmt|;
name|q
operator|->
name|lro
operator|.
name|enabled
operator|=
operator|(
name|enabled
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|unsigned
name|long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|p
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|p
operator|->
name|adapter
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|,
name|mtu
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFMTU
case|:
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|IS_DOOMED
argument_list|(
name|p
argument_list|)
condition|?
name|ENXIO
else|:
operator|(
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
condition|?
name|EBUSY
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|fail
label|:
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
if|if
condition|(
operator|(
name|mtu
operator|<
name|ETHERMIN
operator|)
operator|||
operator|(
name|mtu
operator|>
name|ETHERMTU_JUMBO
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_mtu
operator|=
name|mtu
expr_stmt|;
name|PORT_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|cxgb_update_mac_settings
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|PORT_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_DOOMED
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|flags
operator|=
name|p
operator|->
name|if_flags
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|^
name|flags
operator|)
operator|&
name|IFF_PROMISC
operator|)
operator|||
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|^
name|flags
operator|)
operator|&
name|IFF_ALLMULTI
operator|)
condition|)
block|{
if|if
condition|(
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|PORT_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|cxgb_update_mac_settings
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|PORT_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|cxgb_init_locked
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|error
operator|=
name|cxgb_uninit_locked
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ADAPTER_LOCK_ASSERT_NOTOWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|IS_DOOMED
argument_list|(
name|p
argument_list|)
condition|?
name|ENXIO
else|:
operator|(
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
condition|?
name|EBUSY
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|PORT_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|cxgb_update_mac_settings
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|PORT_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|IS_DOOMED
argument_list|(
name|p
argument_list|)
condition|?
name|ENXIO
else|:
operator|(
name|IS_BUSY
argument_list|(
name|sc
argument_list|)
condition|?
name|EBUSY
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail
goto|;
name|mask
operator|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TXCSUM
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|^=
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator||
name|CSUM_IP
operator|)
expr_stmt|;
if|if
condition|(
name|IFCAP_TSO4
operator|&
name|ifp
operator|->
name|if_capenable
operator|&&
operator|!
operator|(
name|IFCAP_TXCSUM
operator|&
name|ifp
operator|->
name|if_capenable
operator|)
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_TSO4
expr_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"tso4 disabled due to -txcsum.\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM_IPV6
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TXCSUM_IPV6
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|^=
operator|(
name|CSUM_UDP_IPV6
operator||
name|CSUM_TCP_IPV6
operator|)
expr_stmt|;
if|if
condition|(
name|IFCAP_TSO6
operator|&
name|ifp
operator|->
name|if_capenable
operator|&&
operator|!
operator|(
name|IFCAP_TXCSUM_IPV6
operator|&
name|ifp
operator|->
name|if_capenable
operator|)
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_TSO6
expr_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"tso6 disabled due to -txcsum6.\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_RXCSUM
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_RXCSUM
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_RXCSUM_IPV6
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_RXCSUM_IPV6
expr_stmt|;
comment|/* 		 * Note that we leave CSUM_TSO alone (it is always set).  The 		 * kernel takes both IFCAP_TSOx and CSUM_TSO into account before 		 * sending a TSO request our way, so it's sufficient to toggle 		 * IFCAP_TSOx only. 		 */
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO4
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|IFCAP_TSO4
operator|&
name|ifp
operator|->
name|if_capenable
operator|)
operator|&&
operator|!
operator|(
name|IFCAP_TXCSUM
operator|&
name|ifp
operator|->
name|if_capenable
operator|)
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"enable txcsum first.\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EAGAIN
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TSO4
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO6
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|IFCAP_TSO6
operator|&
name|ifp
operator|->
name|if_capenable
operator|)
operator|&&
operator|!
operator|(
name|IFCAP_TXCSUM_IPV6
operator|&
name|ifp
operator|->
name|if_capenable
operator|)
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"enable txcsum6 first.\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EAGAIN
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TSO6
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_LRO
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_LRO
expr_stmt|;
comment|/* Safe to do this even if cxgb_up not called yet */
name|cxgb_set_lro
argument_list|(
name|p
argument_list|,
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_LRO
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
if|if
condition|(
name|mask
operator|&
name|IFCAP_TOE4
condition|)
block|{
name|int
name|enable
init|=
operator|(
name|ifp
operator|->
name|if_capenable
operator|^
name|mask
operator|)
operator|&
name|IFCAP_TOE4
decl_stmt|;
name|error
operator|=
name|toe_capability
argument_list|(
name|p
argument_list|,
name|enable
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|mask
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWTAGGING
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTAGGING
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|PORT_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|cxgb_update_mac_settings
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|PORT_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_MTU
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_MTU
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|PORT_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|cxgb_update_mac_settings
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|PORT_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWTSO
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTSO
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWCSUM
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWCSUM
expr_stmt|;
ifdef|#
directive|ifdef
name|VLAN_CAPABILITIES
name|VLAN_CAPABILITIES
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|p
operator|->
name|media
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Translates phy->modtype to the correct Ethernet media subtype.  */
end_comment

begin_function
specifier|static
name|int
name|cxgb_ifm_type
parameter_list|(
name|int
name|mod
parameter_list|)
block|{
switch|switch
condition|(
name|mod
condition|)
block|{
case|case
name|phy_modtype_sr
case|:
return|return
operator|(
name|IFM_10G_SR
operator|)
return|;
case|case
name|phy_modtype_lr
case|:
return|return
operator|(
name|IFM_10G_LR
operator|)
return|;
case|case
name|phy_modtype_lrm
case|:
return|return
operator|(
name|IFM_10G_LRM
operator|)
return|;
case|case
name|phy_modtype_twinax
case|:
return|return
operator|(
name|IFM_10G_TWINAX
operator|)
return|;
case|case
name|phy_modtype_twinax_long
case|:
return|return
operator|(
name|IFM_10G_TWINAX_LONG
operator|)
return|;
case|case
name|phy_modtype_none
case|:
return|return
operator|(
name|IFM_NONE
operator|)
return|;
case|case
name|phy_modtype_unknown
case|:
return|return
operator|(
name|IFM_UNKNOWN
operator|)
return|;
block|}
name|KASSERT
argument_list|(
literal|0
argument_list|,
operator|(
literal|"%s: modtype %d unknown"
operator|,
name|__func__
operator|,
name|mod
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|IFM_UNKNOWN
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Rebuilds the ifmedia list for this port, and sets the current media.  */
end_comment

begin_function
specifier|static
name|void
name|cxgb_build_medialist
parameter_list|(
name|struct
name|port_info
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|cphy
modifier|*
name|phy
init|=
operator|&
name|p
operator|->
name|phy
decl_stmt|;
name|struct
name|ifmedia
modifier|*
name|media
init|=
operator|&
name|p
operator|->
name|media
decl_stmt|;
name|int
name|mod
init|=
name|phy
operator|->
name|modtype
decl_stmt|;
name|int
name|m
init|=
name|IFM_ETHER
operator||
name|IFM_FDX
decl_stmt|;
name|PORT_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ifmedia_removeall
argument_list|(
name|media
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|caps
operator|&
name|SUPPORTED_TP
operator|&&
name|phy
operator|->
name|caps
operator|&
name|SUPPORTED_Autoneg
condition|)
block|{
comment|/* Copper (RJ45) */
if|if
condition|(
name|phy
operator|->
name|caps
operator|&
name|SUPPORTED_10000baseT_Full
condition|)
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_T
argument_list|,
name|mod
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|caps
operator|&
name|SUPPORTED_1000baseT_Full
condition|)
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_1000_T
argument_list|,
name|mod
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|caps
operator|&
name|SUPPORTED_100baseT_Full
condition|)
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_100_TX
argument_list|,
name|mod
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|->
name|caps
operator|&
name|SUPPORTED_10baseT_Full
condition|)
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10_T
argument_list|,
name|mod
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
name|mod
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|phy
operator|->
name|caps
operator|&
name|SUPPORTED_TP
condition|)
block|{
comment|/* Copper (CX4) */
name|KASSERT
argument_list|(
name|phy
operator|->
name|caps
operator|&
name|SUPPORTED_10000baseT_Full
argument_list|,
operator|(
literal|"%s: unexpected cap 0x%x"
operator|,
name|__func__
operator|,
name|phy
operator|->
name|caps
operator|)
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_CX4
argument_list|,
name|mod
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_10G_CX4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|phy
operator|->
name|caps
operator|&
name|SUPPORTED_FIBRE
operator|&&
name|phy
operator|->
name|caps
operator|&
name|SUPPORTED_10000baseT_Full
condition|)
block|{
comment|/* 10G optical (but includes SFP+ twinax) */
name|m
operator||=
name|cxgb_ifm_type
argument_list|(
name|mod
argument_list|)
expr_stmt|;
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|m
argument_list|)
operator|==
name|IFM_NONE
condition|)
name|m
operator|&=
operator|~
name|IFM_FDX
expr_stmt|;
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
argument_list|,
name|mod
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|phy
operator|->
name|caps
operator|&
name|SUPPORTED_FIBRE
operator|&&
name|phy
operator|->
name|caps
operator|&
name|SUPPORTED_1000baseT_Full
condition|)
block|{
comment|/* 1G optical */
comment|/* XXX: Lie and claim to be SX, could actually be any 1G-X */
name|ifmedia_add
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_1000_SX
argument_list|,
name|mod
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
name|media
argument_list|,
name|m
operator||
name|IFM_1000_SX
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
literal|0
argument_list|,
operator|(
literal|"%s: don't know how to handle 0x%x."
operator|,
name|__func__
operator|,
name|phy
operator|->
name|caps
operator|)
argument_list|)
expr_stmt|;
block|}
name|PORT_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|p
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifmedia_entry
modifier|*
name|cur
init|=
name|p
operator|->
name|media
operator|.
name|ifm_cur
decl_stmt|;
name|int
name|speed
init|=
name|p
operator|->
name|link_config
operator|.
name|speed
decl_stmt|;
if|if
condition|(
name|cur
operator|->
name|ifm_data
operator|!=
name|p
operator|->
name|phy
operator|.
name|modtype
condition|)
block|{
name|cxgb_build_medialist
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|cur
operator|=
name|p
operator|->
name|media
operator|.
name|ifm_cur
expr_stmt|;
block|}
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|link_config
operator|.
name|link_ok
condition|)
return|return;
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
comment|/* 	 * active and current will differ iff current media is autoselect.  That 	 * can happen only for copper RJ45. 	 */
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|cur
operator|->
name|ifm_media
argument_list|)
operator|!=
name|IFM_AUTO
condition|)
return|return;
name|KASSERT
argument_list|(
name|p
operator|->
name|phy
operator|.
name|caps
operator|&
name|SUPPORTED_TP
operator|&&
name|p
operator|->
name|phy
operator|.
name|caps
operator|&
name|SUPPORTED_Autoneg
argument_list|,
operator|(
literal|"%s: unexpected PHY caps 0x%x"
operator|,
name|__func__
operator|,
name|p
operator|->
name|phy
operator|.
name|caps
operator|)
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
operator||
name|IFM_FDX
expr_stmt|;
if|if
condition|(
name|speed
operator|==
name|SPEED_10000
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10G_T
expr_stmt|;
elseif|else
if|if
condition|(
name|speed
operator|==
name|SPEED_1000
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_1000_T
expr_stmt|;
elseif|else
if|if
condition|(
name|speed
operator|==
name|SPEED_100
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_100_TX
expr_stmt|;
elseif|else
if|if
condition|(
name|speed
operator|==
name|SPEED_10
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10_T
expr_stmt|;
else|else
name|KASSERT
argument_list|(
literal|0
argument_list|,
operator|(
literal|"%s: link up but speed unknown (%u)"
operator|,
name|__func__
operator|,
name|speed
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|cxgb_get_counter
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|ift_counter
name|c
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|cmac
modifier|*
name|mac
init|=
operator|&
name|pi
operator|->
name|mac
decl_stmt|;
name|struct
name|mac_stats
modifier|*
name|mstats
init|=
operator|&
name|mac
operator|->
name|stats
decl_stmt|;
name|cxgb_refresh_stats
argument_list|(
name|pi
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|IFCOUNTER_IPACKETS
case|:
return|return
operator|(
name|mstats
operator|->
name|rx_frames
operator|)
return|;
case|case
name|IFCOUNTER_IERRORS
case|:
return|return
operator|(
name|mstats
operator|->
name|rx_jabber
operator|+
name|mstats
operator|->
name|rx_data_errs
operator|+
name|mstats
operator|->
name|rx_sequence_errs
operator|+
name|mstats
operator|->
name|rx_runt
operator|+
name|mstats
operator|->
name|rx_too_long
operator|+
name|mstats
operator|->
name|rx_mac_internal_errs
operator|+
name|mstats
operator|->
name|rx_short
operator|+
name|mstats
operator|->
name|rx_fcs_errs
operator|)
return|;
case|case
name|IFCOUNTER_OPACKETS
case|:
return|return
operator|(
name|mstats
operator|->
name|tx_frames
operator|)
return|;
case|case
name|IFCOUNTER_OERRORS
case|:
return|return
operator|(
name|mstats
operator|->
name|tx_excess_collisions
operator|+
name|mstats
operator|->
name|tx_underrun
operator|+
name|mstats
operator|->
name|tx_len_errs
operator|+
name|mstats
operator|->
name|tx_mac_internal_errs
operator|+
name|mstats
operator|->
name|tx_excess_deferral
operator|+
name|mstats
operator|->
name|tx_fcs_errs
operator|)
return|;
case|case
name|IFCOUNTER_COLLISIONS
case|:
return|return
operator|(
name|mstats
operator|->
name|tx_total_collisions
operator|)
return|;
case|case
name|IFCOUNTER_IBYTES
case|:
return|return
operator|(
name|mstats
operator|->
name|rx_octets
operator|)
return|;
case|case
name|IFCOUNTER_OBYTES
case|:
return|return
operator|(
name|mstats
operator|->
name|tx_octets
operator|)
return|;
case|case
name|IFCOUNTER_IMCASTS
case|:
return|return
operator|(
name|mstats
operator|->
name|rx_mcast_frames
operator|)
return|;
case|case
name|IFCOUNTER_OMCASTS
case|:
return|return
operator|(
name|mstats
operator|->
name|tx_mcast_frames
operator|)
return|;
case|case
name|IFCOUNTER_IQDROPS
case|:
return|return
operator|(
name|mstats
operator|->
name|rx_cong_drops
operator|)
return|;
case|case
name|IFCOUNTER_OQDROPS
case|:
block|{
name|int
name|i
decl_stmt|;
name|uint64_t
name|drops
decl_stmt|;
name|drops
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
condition|)
block|{
for|for
control|(
name|i
operator|=
name|pi
operator|->
name|first_qset
init|;
name|i
operator|<
name|pi
operator|->
name|first_qset
operator|+
name|pi
operator|->
name|nqsets
condition|;
name|i
operator|++
control|)
name|drops
operator|+=
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
name|i
index|]
operator|.
name|txq
index|[
name|TXQ_ETH
index|]
operator|.
name|txq_mr
operator|->
name|br_drops
expr_stmt|;
block|}
return|return
operator|(
name|drops
operator|)
return|;
block|}
default|default:
return|return
operator|(
name|if_get_counter_default
argument_list|(
name|ifp
argument_list|,
name|c
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_async_intr
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|adapter_t
modifier|*
name|sc
init|=
name|data
decl_stmt|;
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|A_PL_INT_ENABLE0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|t3_read_reg
argument_list|(
name|sc
argument_list|,
name|A_PL_INT_ENABLE0
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|sc
operator|->
name|slow_intr_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|link_check_callout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|arg
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
if|if
condition|(
operator|!
name|isset
argument_list|(
operator|&
name|sc
operator|->
name|open_device_map
argument_list|,
name|pi
operator|->
name|port_id
argument_list|)
condition|)
return|return;
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|pi
operator|->
name|link_check_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_link_status
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|arg
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
if|if
condition|(
operator|!
name|isset
argument_list|(
operator|&
name|sc
operator|->
name|open_device_map
argument_list|,
name|pi
operator|->
name|port_id
argument_list|)
condition|)
return|return;
name|t3_link_changed
argument_list|(
name|sc
argument_list|,
name|pi
operator|->
name|port_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|link_fault
operator|||
operator|!
operator|(
name|pi
operator|->
name|phy
operator|.
name|caps
operator|&
name|SUPPORTED_LINK_IRQ
operator|)
operator|||
name|pi
operator|->
name|link_config
operator|.
name|link_ok
operator|==
literal|0
condition|)
name|callout_reset
argument_list|(
operator|&
name|pi
operator|->
name|link_check_ch
argument_list|,
name|hz
argument_list|,
name|link_check_callout
argument_list|,
name|pi
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t3_os_link_intr
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
comment|/* 	 * Schedule a link check in the near future.  If the link is flapping 	 * rapidly we'll keep resetting the callout and delaying the check until 	 * things stabilize a bit. 	 */
name|callout_reset
argument_list|(
operator|&
name|pi
operator|->
name|link_check_ch
argument_list|,
name|hz
operator|/
literal|4
argument_list|,
name|link_check_callout
argument_list|,
name|pi
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_t3b2_mac
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|CXGB_SHUTDOWN
condition|)
return|return;
name|for_each_port
argument_list|(
argument|sc
argument_list|,
argument|i
argument_list|)
block|{
name|struct
name|port_info
modifier|*
name|p
init|=
operator|&
name|sc
operator|->
name|port
index|[
name|i
index|]
decl_stmt|;
name|int
name|status
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|p
operator|->
name|ifp
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|isset
argument_list|(
operator|&
name|sc
operator|->
name|open_device_map
argument_list|,
name|p
operator|->
name|port_id
argument_list|)
operator|||
name|p
operator|->
name|link_fault
operator|||
operator|!
name|p
operator|->
name|link_config
operator|.
name|link_ok
condition|)
continue|continue;
name|KASSERT
argument_list|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
argument_list|,
operator|(
literal|"%s: state mismatch (drv_flags %x, device_map %x)"
operator|,
name|__func__
operator|,
name|ifp
operator|->
name|if_drv_flags
operator|,
name|sc
operator|->
name|open_device_map
operator|)
argument_list|)
expr_stmt|;
name|PORT_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|status
operator|=
name|t3b2_mac_watchdog_task
argument_list|(
operator|&
name|p
operator|->
name|mac
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|1
condition|)
name|p
operator|->
name|mac
operator|.
name|stats
operator|.
name|num_toggled
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
literal|2
condition|)
block|{
name|struct
name|cmac
modifier|*
name|mac
init|=
operator|&
name|p
operator|->
name|mac
decl_stmt|;
name|cxgb_update_mac_settings
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|t3_link_start
argument_list|(
operator|&
name|p
operator|->
name|phy
argument_list|,
name|mac
argument_list|,
operator|&
name|p
operator|->
name|link_config
argument_list|)
expr_stmt|;
name|t3_mac_enable
argument_list|(
name|mac
argument_list|,
name|MAC_DIRECTION_RX
operator||
name|MAC_DIRECTION_TX
argument_list|)
expr_stmt|;
name|t3_port_intr_enable
argument_list|(
name|sc
argument_list|,
name|p
operator|->
name|port_id
argument_list|)
expr_stmt|;
name|p
operator|->
name|mac
operator|.
name|stats
operator|.
name|num_resets
operator|++
expr_stmt|;
block|}
name|PORT_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_tick
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|adapter_t
modifier|*
name|sc
init|=
operator|(
name|adapter_t
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|CXGB_SHUTDOWN
condition|)
return|return;
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|sc
operator|->
name|tick_task
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|cxgb_tick_ch
argument_list|,
name|hz
argument_list|,
name|cxgb_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cxgb_refresh_stats
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
specifier|const
name|struct
name|timeval
name|interval
init|=
block|{
literal|0
block|,
literal|250000
block|}
decl_stmt|;
comment|/* 250ms */
name|getmicrotime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|interval
argument_list|)
expr_stmt|;
if|if
condition|(
name|timevalcmp
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|pi
operator|->
name|last_refreshed
argument_list|,
operator|<
argument_list|)
condition|)
return|return;
name|PORT_LOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|t3_mac_update_stats
argument_list|(
operator|&
name|pi
operator|->
name|mac
argument_list|)
expr_stmt|;
name|PORT_UNLOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|getmicrotime
argument_list|(
operator|&
name|pi
operator|->
name|last_refreshed
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_tick_handler
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|adapter_t
modifier|*
name|sc
init|=
operator|(
name|adapter_t
operator|*
operator|)
name|arg
decl_stmt|;
specifier|const
name|struct
name|adapter_params
modifier|*
name|p
init|=
operator|&
name|sc
operator|->
name|params
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint32_t
name|cause
decl_stmt|,
name|reset
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|CXGB_SHUTDOWN
operator|||
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
operator|)
condition|)
return|return;
if|if
condition|(
name|p
operator|->
name|rev
operator|==
name|T3_REV_B2
operator|&&
name|p
operator|->
name|nports
operator|<
literal|4
operator|&&
name|sc
operator|->
name|open_device_map
condition|)
name|check_t3b2_mac
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cause
operator|=
name|t3_read_reg
argument_list|(
name|sc
argument_list|,
name|A_SG_INT_CAUSE
argument_list|)
operator|&
operator|(
name|F_RSPQSTARVE
operator||
name|F_FLEMPTY
operator|)
expr_stmt|;
if|if
condition|(
name|cause
condition|)
block|{
name|struct
name|sge_qset
modifier|*
name|qs
init|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
literal|0
index|]
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|,
name|v
decl_stmt|;
name|v
operator|=
name|t3_read_reg
argument_list|(
name|sc
argument_list|,
name|A_SG_RSPQ_FL_STATUS
argument_list|)
operator|&
operator|~
literal|0xff00
expr_stmt|;
name|mask
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SGE_QSETS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|v
operator|&
name|mask
condition|)
name|qs
index|[
name|i
index|]
operator|.
name|rspq
operator|.
name|starved
operator|++
expr_stmt|;
name|mask
operator|<<=
literal|1
expr_stmt|;
block|}
name|mask
operator|<<=
name|SGE_QSETS
expr_stmt|;
comment|/* skip RSPQXDISABLED */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SGE_QSETS
operator|*
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|v
operator|&
name|mask
condition|)
block|{
name|qs
index|[
name|i
operator|/
literal|2
index|]
operator|.
name|fl
index|[
name|i
operator|%
literal|2
index|]
operator|.
name|empty
operator|++
expr_stmt|;
block|}
name|mask
operator|<<=
literal|1
expr_stmt|;
block|}
comment|/* clear */
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|A_SG_RSPQ_FL_STATUS
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|A_SG_INT_CAUSE
argument_list|,
name|cause
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|params
operator|.
name|nports
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
operator|&
name|sc
operator|->
name|port
index|[
name|i
index|]
decl_stmt|;
name|struct
name|cmac
modifier|*
name|mac
init|=
operator|&
name|pi
operator|->
name|mac
decl_stmt|;
if|if
condition|(
operator|!
name|isset
argument_list|(
operator|&
name|sc
operator|->
name|open_device_map
argument_list|,
name|pi
operator|->
name|port_id
argument_list|)
condition|)
continue|continue;
name|cxgb_refresh_stats
argument_list|(
name|pi
argument_list|)
expr_stmt|;
if|if
condition|(
name|mac
operator|->
name|multiport
condition|)
continue|continue;
comment|/* Count rx fifo overflows, once per second */
name|cause
operator|=
name|t3_read_reg
argument_list|(
name|sc
argument_list|,
name|A_XGM_INT_CAUSE
operator|+
name|mac
operator|->
name|offset
argument_list|)
expr_stmt|;
name|reset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_RXFIFO_OVERFLOW
condition|)
block|{
name|mac
operator|->
name|stats
operator|.
name|rx_fifo_ovfl
operator|++
expr_stmt|;
name|reset
operator||=
name|F_RXFIFO_OVERFLOW
expr_stmt|;
block|}
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|A_XGM_INT_CAUSE
operator|+
name|mac
operator|->
name|offset
argument_list|,
name|reset
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|touch_bars
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
comment|/* 	 * Don't enable yet 	 */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__LP64__
argument_list|)
operator|&&
literal|0
name|u32
name|v
decl_stmt|;
name|pci_read_config_dword
argument_list|(
name|pdev
argument_list|,
name|PCI_BASE_ADDRESS_1
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
name|pci_write_config_dword
argument_list|(
name|pdev
argument_list|,
name|PCI_BASE_ADDRESS_1
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|pci_read_config_dword
argument_list|(
name|pdev
argument_list|,
name|PCI_BASE_ADDRESS_3
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
name|pci_write_config_dword
argument_list|(
name|pdev
argument_list|,
name|PCI_BASE_ADDRESS_3
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|pci_read_config_dword
argument_list|(
name|pdev
argument_list|,
name|PCI_BASE_ADDRESS_5
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
name|pci_write_config_dword
argument_list|(
name|pdev
argument_list|,
name|PCI_BASE_ADDRESS_5
argument_list|,
name|v
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|set_eeprom
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|uint8_t
modifier|*
name|buf
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|u32
name|aligned_offset
decl_stmt|,
name|aligned_len
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|aligned_offset
operator|=
name|offset
operator|&
operator|~
literal|3
expr_stmt|;
name|aligned_len
operator|=
operator|(
name|len
operator|+
operator|(
name|offset
operator|&
literal|3
operator|)
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
if|if
condition|(
name|aligned_offset
operator|!=
name|offset
operator|||
name|aligned_len
operator|!=
name|len
condition|)
block|{
name|buf
operator|=
name|malloc
argument_list|(
name|aligned_len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|err
operator|=
name|t3_seeprom_read
argument_list|(
name|adapter
argument_list|,
name|aligned_offset
argument_list|,
operator|(
name|u32
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
operator|&&
name|aligned_len
operator|>
literal|4
condition|)
name|err
operator|=
name|t3_seeprom_read
argument_list|(
name|adapter
argument_list|,
name|aligned_offset
operator|+
name|aligned_len
operator|-
literal|4
argument_list|,
operator|(
name|u32
operator|*
operator|)
operator|&
name|buf
index|[
name|aligned_len
operator|-
literal|4
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|memcpy
argument_list|(
name|buf
operator|+
operator|(
name|offset
operator|&
literal|3
operator|)
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
name|buf
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|data
expr_stmt|;
name|err
operator|=
name|t3_seeprom_wp
argument_list|(
name|adapter
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
for|for
control|(
name|p
operator|=
operator|(
name|u32
operator|*
operator|)
name|buf
init|;
operator|!
name|err
operator|&&
name|aligned_len
condition|;
name|aligned_len
operator|-=
literal|4
operator|,
name|p
operator|++
control|)
block|{
name|err
operator|=
name|t3_seeprom_write
argument_list|(
name|adapter
argument_list|,
name|aligned_offset
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|aligned_offset
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|t3_seeprom_wp
argument_list|(
name|adapter
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|buf
operator|!=
name|data
condition|)
name|free
argument_list|(
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|in_range
parameter_list|(
name|int
name|val
parameter_list|,
name|int
name|lo
parameter_list|,
name|int
name|hi
parameter_list|)
block|{
return|return
name|val
operator|<
literal|0
operator|||
operator|(
name|val
operator|<=
name|hi
operator|&&
name|val
operator|>=
name|lo
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_extension_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_extension_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_extension_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|unsigned
name|long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|mmd
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
name|adapter_t
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
ifdef|#
directive|ifdef
name|PRIV_SUPPORTED
if|if
condition|(
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
condition|)
block|{
if|if
condition|(
name|cxgb_debug
condition|)
name|printf
argument_list|(
literal|"user does not have access to privileged ioctls\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
else|#
directive|else
if|if
condition|(
name|suser
argument_list|(
name|td
argument_list|)
condition|)
block|{
if|if
condition|(
name|cxgb_debug
condition|)
name|printf
argument_list|(
literal|"user does not have access to privileged ioctls\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|CHELSIO_GET_MIIREG
case|:
block|{
name|uint32_t
name|val
decl_stmt|;
name|struct
name|cphy
modifier|*
name|phy
init|=
operator|&
name|pi
operator|->
name|phy
decl_stmt|;
name|struct
name|ch_mii_data
modifier|*
name|mid
init|=
operator|(
expr|struct
name|ch_mii_data
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|phy
operator|->
name|mdio_read
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
if|if
condition|(
name|is_10G
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|mmd
operator|=
name|mid
operator|->
name|phy_id
operator|>>
literal|8
expr_stmt|;
if|if
condition|(
operator|!
name|mmd
condition|)
name|mmd
operator|=
name|MDIO_DEV_PCS
expr_stmt|;
elseif|else
if|if
condition|(
name|mmd
operator|>
name|MDIO_DEV_VEND2
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|phy
operator|->
name|mdio_read
argument_list|(
name|sc
argument_list|,
name|mid
operator|->
name|phy_id
operator|&
literal|0x1f
argument_list|,
name|mmd
argument_list|,
name|mid
operator|->
name|reg_num
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|phy
operator|->
name|mdio_read
argument_list|(
name|sc
argument_list|,
name|mid
operator|->
name|phy_id
operator|&
literal|0x1f
argument_list|,
literal|0
argument_list|,
name|mid
operator|->
name|reg_num
operator|&
literal|0x1f
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|mid
operator|->
name|val_out
operator|=
name|val
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_SET_MIIREG
case|:
block|{
name|struct
name|cphy
modifier|*
name|phy
init|=
operator|&
name|pi
operator|->
name|phy
decl_stmt|;
name|struct
name|ch_mii_data
modifier|*
name|mid
init|=
operator|(
expr|struct
name|ch_mii_data
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|phy
operator|->
name|mdio_write
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
if|if
condition|(
name|is_10G
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|mmd
operator|=
name|mid
operator|->
name|phy_id
operator|>>
literal|8
expr_stmt|;
if|if
condition|(
operator|!
name|mmd
condition|)
name|mmd
operator|=
name|MDIO_DEV_PCS
expr_stmt|;
elseif|else
if|if
condition|(
name|mmd
operator|>
name|MDIO_DEV_VEND2
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|phy
operator|->
name|mdio_write
argument_list|(
name|sc
argument_list|,
name|mid
operator|->
name|phy_id
operator|&
literal|0x1f
argument_list|,
name|mmd
argument_list|,
name|mid
operator|->
name|reg_num
argument_list|,
name|mid
operator|->
name|val_in
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|phy
operator|->
name|mdio_write
argument_list|(
name|sc
argument_list|,
name|mid
operator|->
name|phy_id
operator|&
literal|0x1f
argument_list|,
literal|0
argument_list|,
name|mid
operator|->
name|reg_num
operator|&
literal|0x1f
argument_list|,
name|mid
operator|->
name|val_in
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_SETREG
case|:
block|{
name|struct
name|ch_reg
modifier|*
name|edata
init|=
operator|(
expr|struct
name|ch_reg
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
operator|(
name|edata
operator|->
name|addr
operator|&
literal|0x3
operator|)
operator|!=
literal|0
operator|||
name|edata
operator|->
name|addr
operator|>=
name|sc
operator|->
name|mmio_len
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|edata
operator|->
name|addr
argument_list|,
name|edata
operator|->
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_GETREG
case|:
block|{
name|struct
name|ch_reg
modifier|*
name|edata
init|=
operator|(
expr|struct
name|ch_reg
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
operator|(
name|edata
operator|->
name|addr
operator|&
literal|0x3
operator|)
operator|!=
literal|0
operator|||
name|edata
operator|->
name|addr
operator|>=
name|sc
operator|->
name|mmio_len
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|edata
operator|->
name|val
operator|=
name|t3_read_reg
argument_list|(
name|sc
argument_list|,
name|edata
operator|->
name|addr
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_GET_SGE_CONTEXT
case|:
block|{
name|struct
name|ch_cntxt
modifier|*
name|ecntxt
init|=
operator|(
expr|struct
name|ch_cntxt
operator|*
operator|)
name|data
decl_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ecntxt
operator|->
name|cntxt_type
condition|)
block|{
case|case
name|CNTXT_TYPE_EGRESS
case|:
name|error
operator|=
operator|-
name|t3_sge_read_ecntxt
argument_list|(
name|sc
argument_list|,
name|ecntxt
operator|->
name|cntxt_id
argument_list|,
name|ecntxt
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|CNTXT_TYPE_FL
case|:
name|error
operator|=
operator|-
name|t3_sge_read_fl
argument_list|(
name|sc
argument_list|,
name|ecntxt
operator|->
name|cntxt_id
argument_list|,
name|ecntxt
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|CNTXT_TYPE_RSP
case|:
name|error
operator|=
operator|-
name|t3_sge_read_rspq
argument_list|(
name|sc
argument_list|,
name|ecntxt
operator|->
name|cntxt_id
argument_list|,
name|ecntxt
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|CNTXT_TYPE_CQ
case|:
name|error
operator|=
operator|-
name|t3_sge_read_cq
argument_list|(
name|sc
argument_list|,
name|ecntxt
operator|->
name|cntxt_id
argument_list|,
name|ecntxt
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_GET_SGE_DESC
case|:
block|{
name|struct
name|ch_desc
modifier|*
name|edesc
init|=
operator|(
expr|struct
name|ch_desc
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|edesc
operator|->
name|queue_num
operator|>=
name|SGE_QSETS
operator|*
literal|6
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ret
operator|=
name|t3_get_desc
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
name|edesc
operator|->
name|queue_num
operator|/
literal|6
index|]
argument_list|,
name|edesc
operator|->
name|queue_num
operator|%
literal|6
argument_list|,
name|edesc
operator|->
name|idx
argument_list|,
name|edesc
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|edesc
operator|->
name|size
operator|=
name|ret
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_GET_QSET_PARAMS
case|:
block|{
name|struct
name|qset_params
modifier|*
name|q
decl_stmt|;
name|struct
name|ch_qset_params
modifier|*
name|t
init|=
operator|(
expr|struct
name|ch_qset_params
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|q1
init|=
name|pi
operator|->
name|first_qset
decl_stmt|;
name|int
name|nqsets
init|=
name|pi
operator|->
name|nqsets
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|qset_idx
operator|>=
name|nqsets
condition|)
return|return
name|EINVAL
return|;
name|i
operator|=
name|q1
operator|+
name|t
operator|->
name|qset_idx
expr_stmt|;
name|q
operator|=
operator|&
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|qset
index|[
name|i
index|]
expr_stmt|;
name|t
operator|->
name|rspq_size
operator|=
name|q
operator|->
name|rspq_size
expr_stmt|;
name|t
operator|->
name|txq_size
index|[
literal|0
index|]
operator|=
name|q
operator|->
name|txq_size
index|[
literal|0
index|]
expr_stmt|;
name|t
operator|->
name|txq_size
index|[
literal|1
index|]
operator|=
name|q
operator|->
name|txq_size
index|[
literal|1
index|]
expr_stmt|;
name|t
operator|->
name|txq_size
index|[
literal|2
index|]
operator|=
name|q
operator|->
name|txq_size
index|[
literal|2
index|]
expr_stmt|;
name|t
operator|->
name|fl_size
index|[
literal|0
index|]
operator|=
name|q
operator|->
name|fl_size
expr_stmt|;
name|t
operator|->
name|fl_size
index|[
literal|1
index|]
operator|=
name|q
operator|->
name|jumbo_size
expr_stmt|;
name|t
operator|->
name|polling
operator|=
name|q
operator|->
name|polling
expr_stmt|;
name|t
operator|->
name|lro
operator|=
name|q
operator|->
name|lro
expr_stmt|;
name|t
operator|->
name|intr_lat
operator|=
name|q
operator|->
name|coalesce_usecs
expr_stmt|;
name|t
operator|->
name|cong_thres
operator|=
name|q
operator|->
name|cong_thres
expr_stmt|;
name|t
operator|->
name|qnum
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
operator|)
operator|==
literal|0
condition|)
name|t
operator|->
name|vector
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|USING_MSIX
condition|)
name|t
operator|->
name|vector
operator|=
name|rman_get_start
argument_list|(
name|sc
operator|->
name|msix_irq_res
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|t
operator|->
name|vector
operator|=
name|rman_get_start
argument_list|(
name|sc
operator|->
name|irq_res
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_GET_QSET_NUM
case|:
block|{
name|struct
name|ch_reg
modifier|*
name|edata
init|=
operator|(
expr|struct
name|ch_reg
operator|*
operator|)
name|data
decl_stmt|;
name|edata
operator|->
name|val
operator|=
name|pi
operator|->
name|nqsets
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_LOAD_FW
case|:
block|{
name|uint8_t
modifier|*
name|fw_data
decl_stmt|;
name|uint32_t
name|vers
decl_stmt|;
name|struct
name|ch_mem_range
modifier|*
name|t
init|=
operator|(
expr|struct
name|ch_mem_range
operator|*
operator|)
name|data
decl_stmt|;
comment|/* 		 * You're allowed to load a firmware only before FULL_INIT_DONE 		 * 		 * FW_UPTODATE is also set so the rest of the initialization 		 * will not overwrite what was loaded here.  This gives you the 		 * flexibility to load any firmware (and maybe shoot yourself in 		 * the foot). 		 */
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|open_device_map
operator|||
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
condition|)
block|{
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|fw_data
operator|=
name|malloc
argument_list|(
name|t
operator|->
name|len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fw_data
condition|)
name|error
operator|=
name|ENOMEM
expr_stmt|;
else|else
name|error
operator|=
name|copyin
argument_list|(
name|t
operator|->
name|buf
argument_list|,
name|fw_data
argument_list|,
name|t
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
operator|-
name|t3_load_fw
argument_list|(
name|sc
argument_list|,
name|fw_data
argument_list|,
name|t
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|t3_get_fw_version
argument_list|(
name|sc
argument_list|,
operator|&
name|vers
argument_list|)
operator|==
literal|0
condition|)
block|{
name|snprintf
argument_list|(
operator|&
name|sc
operator|->
name|fw_version
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|fw_version
argument_list|)
argument_list|,
literal|"%d.%d.%d"
argument_list|,
name|G_FW_VERSION_MAJOR
argument_list|(
name|vers
argument_list|)
argument_list|,
name|G_FW_VERSION_MINOR
argument_list|(
name|vers
argument_list|)
argument_list|,
name|G_FW_VERSION_MICRO
argument_list|(
name|vers
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
name|sc
operator|->
name|flags
operator||=
name|FW_UPTODATE
expr_stmt|;
name|free
argument_list|(
name|fw_data
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_LOAD_BOOT
case|:
block|{
name|uint8_t
modifier|*
name|boot_data
decl_stmt|;
name|struct
name|ch_mem_range
modifier|*
name|t
init|=
operator|(
expr|struct
name|ch_mem_range
operator|*
operator|)
name|data
decl_stmt|;
name|boot_data
operator|=
name|malloc
argument_list|(
name|t
operator|->
name|len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|boot_data
condition|)
return|return
name|ENOMEM
return|;
name|error
operator|=
name|copyin
argument_list|(
name|t
operator|->
name|buf
argument_list|,
name|boot_data
argument_list|,
name|t
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
operator|-
name|t3_load_boot
argument_list|(
name|sc
argument_list|,
name|boot_data
argument_list|,
name|t
operator|->
name|len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|boot_data
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_GET_PM
case|:
block|{
name|struct
name|ch_pm
modifier|*
name|m
init|=
operator|(
expr|struct
name|ch_pm
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|tp_params
modifier|*
name|p
init|=
operator|&
name|sc
operator|->
name|params
operator|.
name|tp
decl_stmt|;
if|if
condition|(
operator|!
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|m
operator|->
name|tx_pg_sz
operator|=
name|p
operator|->
name|tx_pg_size
expr_stmt|;
name|m
operator|->
name|tx_num_pg
operator|=
name|p
operator|->
name|tx_num_pgs
expr_stmt|;
name|m
operator|->
name|rx_pg_sz
operator|=
name|p
operator|->
name|rx_pg_size
expr_stmt|;
name|m
operator|->
name|rx_num_pg
operator|=
name|p
operator|->
name|rx_num_pgs
expr_stmt|;
name|m
operator|->
name|pm_total
operator|=
name|p
operator|->
name|pmtx_size
operator|+
name|p
operator|->
name|chan_rx_size
operator|*
name|p
operator|->
name|nchan
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_SET_PM
case|:
block|{
name|struct
name|ch_pm
modifier|*
name|m
init|=
operator|(
expr|struct
name|ch_pm
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|tp_params
modifier|*
name|p
init|=
operator|&
name|sc
operator|->
name|params
operator|.
name|tp
decl_stmt|;
if|if
condition|(
operator|!
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
operator|!
name|m
operator|->
name|rx_pg_sz
operator|||
operator|(
name|m
operator|->
name|rx_pg_sz
operator|&
operator|(
name|m
operator|->
name|rx_pg_sz
operator|-
literal|1
operator|)
operator|)
operator|||
operator|!
name|m
operator|->
name|tx_pg_sz
operator|||
operator|(
name|m
operator|->
name|tx_pg_sz
operator|&
operator|(
name|m
operator|->
name|tx_pg_sz
operator|-
literal|1
operator|)
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* not power of 2 */
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|rx_pg_sz
operator|&
literal|0x14000
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* not 16KB or 64KB */
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|tx_pg_sz
operator|&
literal|0x1554000
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|m
operator|->
name|tx_num_pg
operator|==
operator|-
literal|1
condition|)
name|m
operator|->
name|tx_num_pg
operator|=
name|p
operator|->
name|tx_num_pgs
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|rx_num_pg
operator|==
operator|-
literal|1
condition|)
name|m
operator|->
name|rx_num_pg
operator|=
name|p
operator|->
name|rx_num_pgs
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|tx_num_pg
operator|%
literal|24
operator|||
name|m
operator|->
name|rx_num_pg
operator|%
literal|24
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|m
operator|->
name|rx_num_pg
operator|*
name|m
operator|->
name|rx_pg_sz
operator|>
name|p
operator|->
name|chan_rx_size
operator|||
name|m
operator|->
name|tx_num_pg
operator|*
name|m
operator|->
name|tx_pg_sz
operator|>
name|p
operator|->
name|chan_tx_size
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|p
operator|->
name|rx_pg_size
operator|=
name|m
operator|->
name|rx_pg_sz
expr_stmt|;
name|p
operator|->
name|tx_pg_size
operator|=
name|m
operator|->
name|tx_pg_sz
expr_stmt|;
name|p
operator|->
name|rx_num_pgs
operator|=
name|m
operator|->
name|rx_num_pg
expr_stmt|;
name|p
operator|->
name|tx_num_pgs
operator|=
name|m
operator|->
name|tx_num_pg
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_SETMTUTAB
case|:
block|{
name|struct
name|ch_mtus
modifier|*
name|m
init|=
operator|(
expr|struct
name|ch_mtus
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
if|if
condition|(
name|offload_running
argument_list|(
name|sc
argument_list|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
name|m
operator|->
name|nmtus
operator|!=
name|NMTUS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|m
operator|->
name|mtus
index|[
literal|0
index|]
operator|<
literal|81
condition|)
comment|/* accommodate SACK */
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 		 * MTUs must be in ascending order 		 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NMTUS
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|m
operator|->
name|mtus
index|[
name|i
index|]
operator|<
name|m
operator|->
name|mtus
index|[
name|i
operator|-
literal|1
index|]
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|memcpy
argument_list|(
name|sc
operator|->
name|params
operator|.
name|mtus
argument_list|,
name|m
operator|->
name|mtus
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|params
operator|.
name|mtus
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_GETMTUTAB
case|:
block|{
name|struct
name|ch_mtus
modifier|*
name|m
init|=
operator|(
expr|struct
name|ch_mtus
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|memcpy
argument_list|(
name|m
operator|->
name|mtus
argument_list|,
name|sc
operator|->
name|params
operator|.
name|mtus
argument_list|,
sizeof|sizeof
argument_list|(
name|m
operator|->
name|mtus
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|nmtus
operator|=
name|NMTUS
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_GET_MEM
case|:
block|{
name|struct
name|ch_mem_range
modifier|*
name|t
init|=
operator|(
expr|struct
name|ch_mem_range
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|mc7
modifier|*
name|mem
decl_stmt|;
name|uint8_t
modifier|*
name|useraddr
decl_stmt|;
name|u64
name|buf
index|[
literal|32
index|]
decl_stmt|;
comment|/* 		 * Use these to avoid modifying len/addr in the return 		 * struct 		 */
name|uint32_t
name|len
init|=
name|t
operator|->
name|len
decl_stmt|,
name|addr
init|=
name|t
operator|->
name|addr
decl_stmt|;
if|if
condition|(
operator|!
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
operator|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* need the memory controllers */
if|if
condition|(
operator|(
name|addr
operator|&
literal|0x7
operator|)
operator|||
operator|(
name|len
operator|&
literal|0x7
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|t
operator|->
name|mem_id
operator|==
name|MEM_CM
condition|)
name|mem
operator|=
operator|&
name|sc
operator|->
name|cm
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|->
name|mem_id
operator|==
name|MEM_PMRX
condition|)
name|mem
operator|=
operator|&
name|sc
operator|->
name|pmrx
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|->
name|mem_id
operator|==
name|MEM_PMTX
condition|)
name|mem
operator|=
operator|&
name|sc
operator|->
name|pmtx
expr_stmt|;
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 		 * Version scheme: 		 * bits 0..9: chip version 		 * bits 10..15: chip revision 		 */
name|t
operator|->
name|version
operator|=
literal|3
operator||
operator|(
name|sc
operator|->
name|params
operator|.
name|rev
operator|<<
literal|10
operator|)
expr_stmt|;
comment|/* 		 * Read 256 bytes at a time as len can be large and we don't 		 * want to use huge intermediate buffers. 		 */
name|useraddr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|t
operator|->
name|buf
expr_stmt|;
while|while
condition|(
name|len
condition|)
block|{
name|unsigned
name|int
name|chunk
init|=
name|min
argument_list|(
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
decl_stmt|;
name|error
operator|=
name|t3_mc7_bd_read
argument_list|(
name|mem
argument_list|,
name|addr
operator|/
literal|8
argument_list|,
name|chunk
operator|/
literal|8
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
operator|-
name|error
operator|)
return|;
if|if
condition|(
name|copyout
argument_list|(
name|buf
argument_list|,
name|useraddr
argument_list|,
name|chunk
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|useraddr
operator|+=
name|chunk
expr_stmt|;
name|addr
operator|+=
name|chunk
expr_stmt|;
name|len
operator|-=
name|chunk
expr_stmt|;
block|}
break|break;
block|}
case|case
name|CHELSIO_READ_TCAM_WORD
case|:
block|{
name|struct
name|ch_tcam_word
modifier|*
name|t
init|=
operator|(
expr|struct
name|ch_tcam_word
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
operator|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* need MC5 */
return|return
operator|-
name|t3_read_mc5_range
argument_list|(
operator|&
name|sc
operator|->
name|mc5
argument_list|,
name|t
operator|->
name|addr
argument_list|,
literal|1
argument_list|,
name|t
operator|->
name|buf
argument_list|)
return|;
break|break;
block|}
case|case
name|CHELSIO_SET_TRACE_FILTER
case|:
block|{
name|struct
name|ch_trace
modifier|*
name|t
init|=
operator|(
expr|struct
name|ch_trace
operator|*
operator|)
name|data
decl_stmt|;
specifier|const
name|struct
name|trace_params
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
operator|(
specifier|const
expr|struct
name|trace_params
operator|*
operator|)
operator|&
name|t
operator|->
name|sip
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|config_tx
condition|)
name|t3_config_trace_filter
argument_list|(
name|sc
argument_list|,
name|tp
argument_list|,
literal|0
argument_list|,
name|t
operator|->
name|invert_match
argument_list|,
name|t
operator|->
name|trace_tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|config_rx
condition|)
name|t3_config_trace_filter
argument_list|(
name|sc
argument_list|,
name|tp
argument_list|,
literal|1
argument_list|,
name|t
operator|->
name|invert_match
argument_list|,
name|t
operator|->
name|trace_rx
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_SET_PKTSCHED
case|:
block|{
name|struct
name|ch_pktsched_params
modifier|*
name|p
init|=
operator|(
expr|struct
name|ch_pktsched_params
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|open_device_map
operator|==
literal|0
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
name|send_pktsched_cmd
argument_list|(
name|sc
argument_list|,
name|p
operator|->
name|sched
argument_list|,
name|p
operator|->
name|idx
argument_list|,
name|p
operator|->
name|min
argument_list|,
name|p
operator|->
name|max
argument_list|,
name|p
operator|->
name|binding
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_IFCONF_GETREGS
case|:
block|{
name|struct
name|ch_ifconf_regs
modifier|*
name|regs
init|=
operator|(
expr|struct
name|ch_ifconf_regs
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|reglen
init|=
name|cxgb_get_regs_len
argument_list|()
decl_stmt|;
name|uint8_t
modifier|*
name|buf
init|=
name|malloc
argument_list|(
name|reglen
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
decl_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|regs
operator|->
name|len
operator|>
name|reglen
condition|)
name|regs
operator|->
name|len
operator|=
name|reglen
expr_stmt|;
elseif|else
if|if
condition|(
name|regs
operator|->
name|len
operator|<
name|reglen
condition|)
name|error
operator|=
name|ENOBUFS
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|cxgb_get_regs
argument_list|(
name|sc
argument_list|,
name|regs
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|buf
argument_list|,
name|regs
operator|->
name|data
argument_list|,
name|reglen
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_SET_HW_SCHED
case|:
block|{
name|struct
name|ch_hw_sched
modifier|*
name|t
init|=
operator|(
expr|struct
name|ch_hw_sched
operator|*
operator|)
name|data
decl_stmt|;
name|unsigned
name|int
name|ticks_per_usec
init|=
name|core_ticks_per_usec
argument_list|(
name|sc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
comment|/* need TP to be initialized */
if|if
condition|(
name|t
operator|->
name|sched
operator|>=
name|NTX_SCHED
operator|||
operator|!
name|in_range
argument_list|(
name|t
operator|->
name|mode
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|||
operator|!
name|in_range
argument_list|(
name|t
operator|->
name|channel
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|||
operator|!
name|in_range
argument_list|(
name|t
operator|->
name|kbps
argument_list|,
literal|0
argument_list|,
literal|10000000
argument_list|)
operator|||
operator|!
name|in_range
argument_list|(
name|t
operator|->
name|class_ipg
argument_list|,
literal|0
argument_list|,
literal|10000
operator|*
literal|65535
operator|/
name|ticks_per_usec
argument_list|)
operator|||
operator|!
name|in_range
argument_list|(
name|t
operator|->
name|flow_ipg
argument_list|,
literal|0
argument_list|,
name|dack_ticks_to_usec
argument_list|(
name|sc
argument_list|,
literal|0x7ff
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|t
operator|->
name|kbps
operator|>=
literal|0
condition|)
block|{
name|error
operator|=
name|t3_config_sched
argument_list|(
name|sc
argument_list|,
name|t
operator|->
name|kbps
argument_list|,
name|t
operator|->
name|sched
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
name|error
operator|)
return|;
block|}
if|if
condition|(
name|t
operator|->
name|class_ipg
operator|>=
literal|0
condition|)
name|t3_set_sched_ipg
argument_list|(
name|sc
argument_list|,
name|t
operator|->
name|sched
argument_list|,
name|t
operator|->
name|class_ipg
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|flow_ipg
operator|>=
literal|0
condition|)
block|{
name|t
operator|->
name|flow_ipg
operator|*=
literal|1000
expr_stmt|;
comment|/* us -> ns */
name|t3_set_pace_tbl
argument_list|(
name|sc
argument_list|,
operator|&
name|t
operator|->
name|flow_ipg
argument_list|,
name|t
operator|->
name|sched
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|->
name|mode
operator|>=
literal|0
condition|)
block|{
name|int
name|bit
init|=
literal|1
operator|<<
operator|(
name|S_TX_MOD_TIMER_MODE
operator|+
name|t
operator|->
name|sched
operator|)
decl_stmt|;
name|t3_set_reg_field
argument_list|(
name|sc
argument_list|,
name|A_TP_TX_MOD_QUEUE_REQ_MAP
argument_list|,
name|bit
argument_list|,
name|t
operator|->
name|mode
condition|?
name|bit
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|->
name|channel
operator|>=
literal|0
condition|)
name|t3_set_reg_field
argument_list|(
name|sc
argument_list|,
name|A_TP_TX_MOD_QUEUE_REQ_MAP
argument_list|,
literal|1
operator|<<
name|t
operator|->
name|sched
argument_list|,
name|t
operator|->
name|channel
operator|<<
name|t
operator|->
name|sched
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_GET_EEPROM
case|:
block|{
name|int
name|i
decl_stmt|;
name|struct
name|ch_eeprom
modifier|*
name|e
init|=
operator|(
expr|struct
name|ch_eeprom
operator|*
operator|)
name|data
decl_stmt|;
name|uint8_t
modifier|*
name|buf
init|=
name|malloc
argument_list|(
name|EEPROMSIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
decl_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|e
operator|->
name|magic
operator|=
name|EEPROM_MAGIC
expr_stmt|;
for|for
control|(
name|i
operator|=
name|e
operator|->
name|offset
operator|&
operator|~
literal|3
init|;
operator|!
name|error
operator|&&
name|i
operator|<
name|e
operator|->
name|offset
operator|+
name|e
operator|->
name|len
condition|;
name|i
operator|+=
literal|4
control|)
name|error
operator|=
operator|-
name|t3_seeprom_read
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|copyout
argument_list|(
name|buf
operator|+
name|e
operator|->
name|offset
argument_list|,
name|e
operator|->
name|data
argument_list|,
name|e
operator|->
name|len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_CLEAR_STATS
case|:
block|{
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
operator|)
condition|)
return|return
name|EAGAIN
return|;
name|PORT_LOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|t3_mac_update_stats
argument_list|(
operator|&
name|pi
operator|->
name|mac
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|pi
operator|->
name|mac
operator|.
name|stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pi
operator|->
name|mac
operator|.
name|stats
argument_list|)
argument_list|)
expr_stmt|;
name|PORT_UNLOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_GET_UP_LA
case|:
block|{
name|struct
name|ch_up_la
modifier|*
name|la
init|=
operator|(
expr|struct
name|ch_up_la
operator|*
operator|)
name|data
decl_stmt|;
name|uint8_t
modifier|*
name|buf
init|=
name|malloc
argument_list|(
name|LA_BUFSIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
decl_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|la
operator|->
name|bufsize
operator|<
name|LA_BUFSIZE
condition|)
name|error
operator|=
name|ENOBUFS
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
operator|-
name|t3_get_up_la
argument_list|(
name|sc
argument_list|,
operator|&
name|la
operator|->
name|stopped
argument_list|,
operator|&
name|la
operator|->
name|idx
argument_list|,
operator|&
name|la
operator|->
name|bufsize
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|copyout
argument_list|(
name|buf
argument_list|,
name|la
operator|->
name|data
argument_list|,
name|la
operator|->
name|bufsize
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_GET_UP_IOQS
case|:
block|{
name|struct
name|ch_up_ioqs
modifier|*
name|ioqs
init|=
operator|(
expr|struct
name|ch_up_ioqs
operator|*
operator|)
name|data
decl_stmt|;
name|uint8_t
modifier|*
name|buf
init|=
name|malloc
argument_list|(
name|IOQS_BUFSIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
decl_stmt|;
name|uint32_t
modifier|*
name|v
decl_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|ioqs
operator|->
name|bufsize
operator|<
name|IOQS_BUFSIZE
condition|)
name|error
operator|=
name|ENOBUFS
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
operator|-
name|t3_get_up_ioqs
argument_list|(
name|sc
argument_list|,
operator|&
name|ioqs
operator|->
name|bufsize
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|v
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|buf
expr_stmt|;
name|ioqs
operator|->
name|ioq_rx_enable
operator|=
operator|*
name|v
operator|++
expr_stmt|;
name|ioqs
operator|->
name|ioq_tx_enable
operator|=
operator|*
name|v
operator|++
expr_stmt|;
name|ioqs
operator|->
name|ioq_rx_status
operator|=
operator|*
name|v
operator|++
expr_stmt|;
name|ioqs
operator|->
name|ioq_tx_status
operator|=
operator|*
name|v
operator|++
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|v
argument_list|,
name|ioqs
operator|->
name|data
argument_list|,
name|ioqs
operator|->
name|bufsize
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_SET_FILTER
case|:
block|{
name|struct
name|ch_filter
modifier|*
name|f
init|=
operator|(
expr|struct
name|ch_filter
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|filter_info
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|nfilters
init|=
name|sc
operator|->
name|params
operator|.
name|mc5
operator|.
name|nfilters
decl_stmt|;
if|if
condition|(
operator|!
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
comment|/* No TCAM */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
operator|)
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
comment|/* mc5 not setup yet */
if|if
condition|(
name|nfilters
operator|==
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* TOE will use TCAM */
comment|/* sanity checks */
if|if
condition|(
name|f
operator|->
name|filter_id
operator|>=
name|nfilters
operator|||
operator|(
name|f
operator|->
name|val
operator|.
name|dip
operator|&&
name|f
operator|->
name|mask
operator|.
name|dip
operator|!=
literal|0xffffffff
operator|)
operator|||
operator|(
name|f
operator|->
name|val
operator|.
name|sport
operator|&&
name|f
operator|->
name|mask
operator|.
name|sport
operator|!=
literal|0xffff
operator|)
operator|||
operator|(
name|f
operator|->
name|val
operator|.
name|dport
operator|&&
name|f
operator|->
name|mask
operator|.
name|dport
operator|!=
literal|0xffff
operator|)
operator|||
operator|(
name|f
operator|->
name|val
operator|.
name|vlan
operator|&&
name|f
operator|->
name|mask
operator|.
name|vlan
operator|!=
literal|0xfff
operator|)
operator|||
operator|(
name|f
operator|->
name|val
operator|.
name|vlan_prio
operator|&&
name|f
operator|->
name|mask
operator|.
name|vlan_prio
operator|!=
name|FILTER_NO_VLAN_PRI
operator|)
operator|||
operator|(
name|f
operator|->
name|mac_addr_idx
operator|!=
literal|0xffff
operator|&&
name|f
operator|->
name|mac_addr_idx
operator|>
literal|15
operator|)
operator|||
name|f
operator|->
name|qset
operator|>=
name|SGE_QSETS
operator|||
name|sc
operator|->
name|rrss_map
index|[
name|f
operator|->
name|qset
index|]
operator|>=
name|RSS_TABLE_SIZE
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Was allocated with M_WAITOK */
name|KASSERT
argument_list|(
name|sc
operator|->
name|filters
argument_list|,
operator|(
literal|"filter table NULL\n"
operator|)
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|sc
operator|->
name|filters
index|[
name|f
operator|->
name|filter_id
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|locked
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|bzero
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|sip
operator|=
name|f
operator|->
name|val
operator|.
name|sip
expr_stmt|;
name|p
operator|->
name|sip_mask
operator|=
name|f
operator|->
name|mask
operator|.
name|sip
expr_stmt|;
name|p
operator|->
name|dip
operator|=
name|f
operator|->
name|val
operator|.
name|dip
expr_stmt|;
name|p
operator|->
name|sport
operator|=
name|f
operator|->
name|val
operator|.
name|sport
expr_stmt|;
name|p
operator|->
name|dport
operator|=
name|f
operator|->
name|val
operator|.
name|dport
expr_stmt|;
name|p
operator|->
name|vlan
operator|=
name|f
operator|->
name|mask
operator|.
name|vlan
condition|?
name|f
operator|->
name|val
operator|.
name|vlan
else|:
literal|0xfff
expr_stmt|;
name|p
operator|->
name|vlan_prio
operator|=
name|f
operator|->
name|mask
operator|.
name|vlan_prio
condition|?
operator|(
name|f
operator|->
name|val
operator|.
name|vlan_prio
operator|&
literal|6
operator|)
else|:
name|FILTER_NO_VLAN_PRI
expr_stmt|;
name|p
operator|->
name|mac_hit
operator|=
name|f
operator|->
name|mac_hit
expr_stmt|;
name|p
operator|->
name|mac_vld
operator|=
name|f
operator|->
name|mac_addr_idx
operator|!=
literal|0xffff
expr_stmt|;
name|p
operator|->
name|mac_idx
operator|=
name|f
operator|->
name|mac_addr_idx
expr_stmt|;
name|p
operator|->
name|pkt_type
operator|=
name|f
operator|->
name|proto
expr_stmt|;
name|p
operator|->
name|report_filter_id
operator|=
name|f
operator|->
name|want_filter_id
expr_stmt|;
name|p
operator|->
name|pass
operator|=
name|f
operator|->
name|pass
expr_stmt|;
name|p
operator|->
name|rss
operator|=
name|f
operator|->
name|rss
expr_stmt|;
name|p
operator|->
name|qset
operator|=
name|f
operator|->
name|qset
expr_stmt|;
name|error
operator|=
name|set_filter
argument_list|(
name|sc
argument_list|,
name|f
operator|->
name|filter_id
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|p
operator|->
name|valid
operator|=
literal|1
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_DEL_FILTER
case|:
block|{
name|struct
name|ch_filter
modifier|*
name|f
init|=
operator|(
expr|struct
name|ch_filter
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|filter_info
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|nfilters
init|=
name|sc
operator|->
name|params
operator|.
name|mc5
operator|.
name|nfilters
decl_stmt|;
if|if
condition|(
operator|!
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
operator|)
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
if|if
condition|(
name|nfilters
operator|==
literal|0
operator|||
name|sc
operator|->
name|filters
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|f
operator|->
name|filter_id
operator|>=
name|nfilters
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|p
operator|=
operator|&
name|sc
operator|->
name|filters
index|[
name|f
operator|->
name|filter_id
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|locked
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|if
condition|(
operator|!
name|p
operator|->
name|valid
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
comment|/* Read "Bad address" as "Bad index" */
name|bzero
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|sip
operator|=
name|p
operator|->
name|sip_mask
operator|=
literal|0xffffffff
expr_stmt|;
name|p
operator|->
name|vlan
operator|=
literal|0xfff
expr_stmt|;
name|p
operator|->
name|vlan_prio
operator|=
name|FILTER_NO_VLAN_PRI
expr_stmt|;
name|p
operator|->
name|pkt_type
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|set_filter
argument_list|(
name|sc
argument_list|,
name|f
operator|->
name|filter_id
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_GET_FILTER
case|:
block|{
name|struct
name|ch_filter
modifier|*
name|f
init|=
operator|(
expr|struct
name|ch_filter
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|filter_info
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|nfilters
init|=
name|sc
operator|->
name|params
operator|.
name|mc5
operator|.
name|nfilters
decl_stmt|;
if|if
condition|(
operator|!
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
operator|)
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
if|if
condition|(
name|nfilters
operator|==
literal|0
operator|||
name|sc
operator|->
name|filters
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|i
operator|=
name|f
operator|->
name|filter_id
operator|==
literal|0xffffffff
condition|?
literal|0
else|:
name|f
operator|->
name|filter_id
operator|+
literal|1
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|nfilters
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
operator|&
name|sc
operator|->
name|filters
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|valid
condition|)
continue|continue;
name|bzero
argument_list|(
name|f
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|->
name|filter_id
operator|=
name|i
expr_stmt|;
name|f
operator|->
name|val
operator|.
name|sip
operator|=
name|p
operator|->
name|sip
expr_stmt|;
name|f
operator|->
name|mask
operator|.
name|sip
operator|=
name|p
operator|->
name|sip_mask
expr_stmt|;
name|f
operator|->
name|val
operator|.
name|dip
operator|=
name|p
operator|->
name|dip
expr_stmt|;
name|f
operator|->
name|mask
operator|.
name|dip
operator|=
name|p
operator|->
name|dip
condition|?
literal|0xffffffff
else|:
literal|0
expr_stmt|;
name|f
operator|->
name|val
operator|.
name|sport
operator|=
name|p
operator|->
name|sport
expr_stmt|;
name|f
operator|->
name|mask
operator|.
name|sport
operator|=
name|p
operator|->
name|sport
condition|?
literal|0xffff
else|:
literal|0
expr_stmt|;
name|f
operator|->
name|val
operator|.
name|dport
operator|=
name|p
operator|->
name|dport
expr_stmt|;
name|f
operator|->
name|mask
operator|.
name|dport
operator|=
name|p
operator|->
name|dport
condition|?
literal|0xffff
else|:
literal|0
expr_stmt|;
name|f
operator|->
name|val
operator|.
name|vlan
operator|=
name|p
operator|->
name|vlan
operator|==
literal|0xfff
condition|?
literal|0
else|:
name|p
operator|->
name|vlan
expr_stmt|;
name|f
operator|->
name|mask
operator|.
name|vlan
operator|=
name|p
operator|->
name|vlan
operator|==
literal|0xfff
condition|?
literal|0
else|:
literal|0xfff
expr_stmt|;
name|f
operator|->
name|val
operator|.
name|vlan_prio
operator|=
name|p
operator|->
name|vlan_prio
operator|==
name|FILTER_NO_VLAN_PRI
condition|?
literal|0
else|:
name|p
operator|->
name|vlan_prio
expr_stmt|;
name|f
operator|->
name|mask
operator|.
name|vlan_prio
operator|=
name|p
operator|->
name|vlan_prio
operator|==
name|FILTER_NO_VLAN_PRI
condition|?
literal|0
else|:
name|FILTER_NO_VLAN_PRI
expr_stmt|;
name|f
operator|->
name|mac_hit
operator|=
name|p
operator|->
name|mac_hit
expr_stmt|;
name|f
operator|->
name|mac_addr_idx
operator|=
name|p
operator|->
name|mac_vld
condition|?
name|p
operator|->
name|mac_idx
else|:
literal|0xffff
expr_stmt|;
name|f
operator|->
name|proto
operator|=
name|p
operator|->
name|pkt_type
expr_stmt|;
name|f
operator|->
name|want_filter_id
operator|=
name|p
operator|->
name|report_filter_id
expr_stmt|;
name|f
operator|->
name|pass
operator|=
name|p
operator|->
name|pass
expr_stmt|;
name|f
operator|->
name|rss
operator|=
name|p
operator|->
name|rss
expr_stmt|;
name|f
operator|->
name|qset
operator|=
name|p
operator|->
name|qset
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|nfilters
condition|)
name|f
operator|->
name|filter_id
operator|=
literal|0xffffffff
expr_stmt|;
break|break;
block|}
default|default:
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|reg_block_dump
parameter_list|(
name|struct
name|adapter
modifier|*
name|ap
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|unsigned
name|int
name|start
parameter_list|,
name|unsigned
name|int
name|end
parameter_list|)
block|{
name|uint32_t
modifier|*
name|p
init|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|buf
operator|+
name|start
operator|)
decl_stmt|;
for|for
control|(
init|;
name|start
operator|<=
name|end
condition|;
name|start
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
control|)
operator|*
name|p
operator|++
operator|=
name|t3_read_reg
argument_list|(
name|ap
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|T3_REGMAP_SIZE
value|(3 * 1024)
end_define

begin_function
specifier|static
name|int
name|cxgb_get_regs_len
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|T3_REGMAP_SIZE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_get_regs
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|,
name|struct
name|ch_ifconf_regs
modifier|*
name|regs
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|)
block|{
comment|/* 	 * Version scheme: 	 * bits 0..9: chip version 	 * bits 10..15: chip revision 	 * bit 31: set for PCIe cards 	 */
name|regs
operator|->
name|version
operator|=
literal|3
operator||
operator|(
name|sc
operator|->
name|params
operator|.
name|rev
operator|<<
literal|10
operator|)
operator||
operator|(
name|is_pcie
argument_list|(
name|sc
argument_list|)
operator|<<
literal|31
operator|)
expr_stmt|;
comment|/* 	 * We skip the MAC statistics registers because they are clear-on-read. 	 * Also reading multi-register stats would need to synchronize with the 	 * periodic mac stats accumulation.  Hard to justify the complexity. 	 */
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|cxgb_get_regs_len
argument_list|()
argument_list|)
expr_stmt|;
name|reg_block_dump
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|A_SG_RSPQ_CREDIT_RETURN
argument_list|)
expr_stmt|;
name|reg_block_dump
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|A_SG_HI_DRB_HI_THRSH
argument_list|,
name|A_ULPRX_PBL_ULIMIT
argument_list|)
expr_stmt|;
name|reg_block_dump
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|A_ULPTX_CONFIG
argument_list|,
name|A_MPS_INT_CAUSE
argument_list|)
expr_stmt|;
name|reg_block_dump
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|A_CPL_SWITCH_CNTRL
argument_list|,
name|A_CPL_MAP_TBL_DATA
argument_list|)
expr_stmt|;
name|reg_block_dump
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|A_SMB_GLOBAL_TIME_CFG
argument_list|,
name|A_XGM_SERDES_STAT3
argument_list|)
expr_stmt|;
name|reg_block_dump
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|A_XGM_SERDES_STATUS0
argument_list|,
name|XGM_REG
argument_list|(
name|A_XGM_SERDES_STAT3
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|reg_block_dump
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|XGM_REG
argument_list|(
name|A_XGM_SERDES_STATUS0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XGM_REG
argument_list|(
name|A_XGM_RX_SPI4_SOP_EOP_CNT
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|alloc_filters
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|filter_info
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|nfilters
init|=
name|sc
operator|->
name|params
operator|.
name|mc5
operator|.
name|nfilters
decl_stmt|;
if|if
condition|(
name|nfilters
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|p
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
operator|*
name|nfilters
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sc
operator|->
name|filters
operator|=
name|p
expr_stmt|;
name|p
operator|=
operator|&
name|sc
operator|->
name|filters
index|[
name|nfilters
operator|-
literal|1
index|]
expr_stmt|;
name|p
operator|->
name|vlan
operator|=
literal|0xfff
expr_stmt|;
name|p
operator|->
name|vlan_prio
operator|=
name|FILTER_NO_VLAN_PRI
expr_stmt|;
name|p
operator|->
name|pass
operator|=
name|p
operator|->
name|rss
operator|=
name|p
operator|->
name|valid
operator|=
name|p
operator|->
name|locked
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setup_hw_filters
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|unsigned
name|int
name|nfilters
init|=
name|sc
operator|->
name|params
operator|.
name|mc5
operator|.
name|nfilters
decl_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|filters
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|t3_enable_filters
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|rc
operator|=
literal|0
init|;
name|i
operator|<
name|nfilters
operator|&&
operator|!
name|rc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|filters
index|[
name|i
index|]
operator|.
name|locked
condition|)
name|rc
operator|=
name|set_filter
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
operator|&
name|sc
operator|->
name|filters
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_filter
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|id
parameter_list|,
specifier|const
name|struct
name|filter_info
modifier|*
name|f
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ulp_txpkt
modifier|*
name|txpkt
decl_stmt|;
name|struct
name|work_request_hdr
modifier|*
name|wr
decl_stmt|;
name|struct
name|cpl_pass_open_req
modifier|*
name|oreq
decl_stmt|;
name|struct
name|cpl_set_tcb_field
modifier|*
name|sreq
decl_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|wr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|oreq
argument_list|)
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|sreq
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|len
operator|<=
name|MHLEN
argument_list|,
operator|(
literal|"filter request too big for an mbuf"
operator|)
argument_list|)
expr_stmt|;
name|id
operator|+=
name|t3_mc5_size
argument_list|(
operator|&
name|sc
operator|->
name|mc5
argument_list|)
operator|-
name|sc
operator|->
name|params
operator|.
name|mc5
operator|.
name|nroutes
operator|-
name|sc
operator|->
name|params
operator|.
name|mc5
operator|.
name|nfilters
expr_stmt|;
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_WAITOK
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|bzero
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|wr
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|work_request_hdr
operator|*
argument_list|)
expr_stmt|;
name|wr
operator|->
name|wrh_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_BYPASS
argument_list|)
operator||
name|F_WR_ATOMIC
argument_list|)
expr_stmt|;
name|oreq
operator|=
operator|(
expr|struct
name|cpl_pass_open_req
operator|*
operator|)
operator|(
name|wr
operator|+
literal|1
operator|)
expr_stmt|;
name|txpkt
operator|=
operator|(
expr|struct
name|ulp_txpkt
operator|*
operator|)
name|oreq
expr_stmt|;
name|txpkt
operator|->
name|cmd_dest
operator|=
name|htonl
argument_list|(
name|V_ULPTX_CMD
argument_list|(
name|ULP_TXPKT
argument_list|)
argument_list|)
expr_stmt|;
name|txpkt
operator|->
name|len
operator|=
name|htonl
argument_list|(
name|V_ULPTX_NFLITS
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|oreq
argument_list|)
operator|/
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|oreq
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_PASS_OPEN_REQ
argument_list|,
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|oreq
operator|->
name|local_port
operator|=
name|htons
argument_list|(
name|f
operator|->
name|dport
argument_list|)
expr_stmt|;
name|oreq
operator|->
name|peer_port
operator|=
name|htons
argument_list|(
name|f
operator|->
name|sport
argument_list|)
expr_stmt|;
name|oreq
operator|->
name|local_ip
operator|=
name|htonl
argument_list|(
name|f
operator|->
name|dip
argument_list|)
expr_stmt|;
name|oreq
operator|->
name|peer_ip
operator|=
name|htonl
argument_list|(
name|f
operator|->
name|sip
argument_list|)
expr_stmt|;
name|oreq
operator|->
name|peer_netmask
operator|=
name|htonl
argument_list|(
name|f
operator|->
name|sip_mask
argument_list|)
expr_stmt|;
name|oreq
operator|->
name|opt0h
operator|=
literal|0
expr_stmt|;
name|oreq
operator|->
name|opt0l
operator|=
name|htonl
argument_list|(
name|F_NO_OFFLOAD
argument_list|)
expr_stmt|;
name|oreq
operator|->
name|opt1
operator|=
name|htonl
argument_list|(
name|V_MAC_MATCH_VALID
argument_list|(
name|f
operator|->
name|mac_vld
argument_list|)
operator||
name|V_CONN_POLICY
argument_list|(
name|CPL_CONN_POLICY_FILTER
argument_list|)
operator||
name|V_VLAN_PRI
argument_list|(
name|f
operator|->
name|vlan_prio
operator|>>
literal|1
argument_list|)
operator||
name|V_VLAN_PRI_VALID
argument_list|(
name|f
operator|->
name|vlan_prio
operator|!=
name|FILTER_NO_VLAN_PRI
argument_list|)
operator||
name|V_PKT_TYPE
argument_list|(
name|f
operator|->
name|pkt_type
argument_list|)
operator||
name|V_OPT1_VLAN
argument_list|(
name|f
operator|->
name|vlan
argument_list|)
operator||
name|V_MAC_MATCH
argument_list|(
name|f
operator|->
name|mac_idx
operator||
operator|(
name|f
operator|->
name|mac_hit
operator|<<
literal|4
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|sreq
operator|=
operator|(
expr|struct
name|cpl_set_tcb_field
operator|*
operator|)
operator|(
name|oreq
operator|+
literal|1
operator|)
expr_stmt|;
name|set_tcb_field_ulp
argument_list|(
name|sreq
argument_list|,
name|id
argument_list|,
literal|1
argument_list|,
literal|0x1800808000ULL
argument_list|,
operator|(
name|f
operator|->
name|report_filter_id
operator|<<
literal|15
operator|)
operator||
operator|(
literal|1
operator|<<
literal|23
operator|)
operator||
operator|(
operator|(
name|u64
operator|)
name|f
operator|->
name|pass
operator|<<
literal|35
operator|)
operator||
operator|(
operator|(
name|u64
operator|)
operator|!
name|f
operator|->
name|rss
operator|<<
literal|36
operator|)
argument_list|)
expr_stmt|;
name|set_tcb_field_ulp
argument_list|(
name|sreq
operator|+
literal|1
argument_list|,
name|id
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
operator|(
literal|2
operator|<<
literal|19
operator|)
operator||
literal|1
argument_list|)
expr_stmt|;
name|t3_mgmt_tx
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|pass
operator|&&
operator|!
name|f
operator|->
name|rss
condition|)
block|{
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sreq
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_WAITOK
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|bzero
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sreq
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|cpl_set_tcb_field
operator|*
argument_list|)
expr_stmt|;
name|sreq
operator|->
name|wr
operator|.
name|wrh_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_FORWARD
argument_list|)
argument_list|)
expr_stmt|;
name|mk_set_tcb_field
argument_list|(
name|sreq
argument_list|,
name|id
argument_list|,
literal|25
argument_list|,
literal|0x3f80000
argument_list|,
operator|(
name|u64
operator|)
name|sc
operator|->
name|rrss_map
index|[
name|f
operator|->
name|qset
index|]
operator|<<
literal|19
argument_list|)
expr_stmt|;
name|t3_mgmt_tx
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|mk_set_tcb_field
parameter_list|(
name|struct
name|cpl_set_tcb_field
modifier|*
name|req
parameter_list|,
name|unsigned
name|int
name|tid
parameter_list|,
name|unsigned
name|int
name|word
parameter_list|,
name|u64
name|mask
parameter_list|,
name|u64
name|val
parameter_list|)
block|{
name|OPCODE_TID
argument_list|(
name|req
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_SET_TCB_FIELD
argument_list|,
name|tid
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|reply
operator|=
name|V_NO_REPLY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|req
operator|->
name|cpu_idx
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|word
operator|=
name|htons
argument_list|(
name|word
argument_list|)
expr_stmt|;
name|req
operator|->
name|mask
operator|=
name|htobe64
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|req
operator|->
name|val
operator|=
name|htobe64
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|set_tcb_field_ulp
parameter_list|(
name|struct
name|cpl_set_tcb_field
modifier|*
name|req
parameter_list|,
name|unsigned
name|int
name|tid
parameter_list|,
name|unsigned
name|int
name|word
parameter_list|,
name|u64
name|mask
parameter_list|,
name|u64
name|val
parameter_list|)
block|{
name|struct
name|ulp_txpkt
modifier|*
name|txpkt
init|=
operator|(
expr|struct
name|ulp_txpkt
operator|*
operator|)
name|req
decl_stmt|;
name|txpkt
operator|->
name|cmd_dest
operator|=
name|htonl
argument_list|(
name|V_ULPTX_CMD
argument_list|(
name|ULP_TXPKT
argument_list|)
argument_list|)
expr_stmt|;
name|txpkt
operator|->
name|len
operator|=
name|htonl
argument_list|(
name|V_ULPTX_NFLITS
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
operator|/
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|mk_set_tcb_field
argument_list|(
name|req
argument_list|,
name|tid
argument_list|,
name|word
argument_list|,
name|mask
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t3_iterate
parameter_list|(
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|t3_list_lock
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|sc
argument_list|,
argument|&t3_list
argument_list|,
argument|link
argument_list|)
block|{
comment|/* 		 * func should not make any assumptions about what state sc is 		 * in - the only guarantee is that sc->sc_lock is a valid lock. 		 */
name|func
argument_list|(
name|sc
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|t3_list_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
end_ifdef

begin_function
specifier|static
name|int
name|toe_capability
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|ADAPTER_LOCK_ASSERT_OWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
if|if
condition|(
name|enable
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"You must enable a cxgb interface first\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
if|if
condition|(
name|isset
argument_list|(
operator|&
name|sc
operator|->
name|offload_map
argument_list|,
name|pi
operator|->
name|port_id
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|TOM_INIT_DONE
operator|)
condition|)
block|{
name|rc
operator|=
name|t3_activate_uld
argument_list|(
name|sc
argument_list|,
name|ULD_TOM
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|EAGAIN
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"You must kldload t3_tom.ko before trying "
literal|"to enable TOE on a cxgb interface.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|tom_softc
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: TOM activated but softc NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|flags
operator|&
name|TOM_INIT_DONE
argument_list|,
operator|(
literal|"%s: TOM activated but flag not set"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
block|}
name|setbit
argument_list|(
operator|&
name|sc
operator|->
name|offload_map
argument_list|,
name|pi
operator|->
name|port_id
argument_list|)
expr_stmt|;
comment|/* 		 * XXX: Temporary code to allow iWARP to be enabled when TOE is 		 * enabled on any port.  Need to figure out how to enable, 		 * disable, load, and unload iWARP cleanly. 		 */
if|if
condition|(
operator|!
name|isset
argument_list|(
operator|&
name|sc
operator|->
name|offload_map
argument_list|,
name|MAX_NPORTS
argument_list|)
operator|&&
name|t3_activate_uld
argument_list|(
name|sc
argument_list|,
name|ULD_IWARP
argument_list|)
operator|==
literal|0
condition|)
name|setbit
argument_list|(
operator|&
name|sc
operator|->
name|offload_map
argument_list|,
name|MAX_NPORTS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|isset
argument_list|(
operator|&
name|sc
operator|->
name|offload_map
argument_list|,
name|pi
operator|->
name|port_id
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|flags
operator|&
name|TOM_INIT_DONE
argument_list|,
operator|(
literal|"%s: TOM never initialized?"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|clrbit
argument_list|(
operator|&
name|sc
operator|->
name|offload_map
argument_list|,
name|pi
operator|->
name|port_id
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add an upper layer driver to the global list.  */
end_comment

begin_function
name|int
name|t3_register_uld
parameter_list|(
name|struct
name|uld_info
modifier|*
name|ui
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|struct
name|uld_info
modifier|*
name|u
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|t3_uld_list_lock
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|u
argument_list|,
argument|&t3_uld_list
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|u
operator|->
name|uld_id
operator|==
name|ui
operator|->
name|uld_id
condition|)
block|{
name|rc
operator|=
name|EEXIST
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|t3_uld_list
argument_list|,
name|ui
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ui
operator|->
name|refcount
operator|=
literal|0
expr_stmt|;
name|done
label|:
name|mtx_unlock
argument_list|(
operator|&
name|t3_uld_list_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t3_unregister_uld
parameter_list|(
name|struct
name|uld_info
modifier|*
name|ui
parameter_list|)
block|{
name|int
name|rc
init|=
name|EINVAL
decl_stmt|;
name|struct
name|uld_info
modifier|*
name|u
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|t3_uld_list_lock
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|u
argument_list|,
argument|&t3_uld_list
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|u
operator|==
name|ui
condition|)
block|{
if|if
condition|(
name|ui
operator|->
name|refcount
operator|>
literal|0
condition|)
block|{
name|rc
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|SLIST_REMOVE
argument_list|(
operator|&
name|t3_uld_list
argument_list|,
name|ui
argument_list|,
name|uld_info
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|done
label|:
name|mtx_unlock
argument_list|(
operator|&
name|t3_uld_list_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t3_activate_uld
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|int
name|rc
init|=
name|EAGAIN
decl_stmt|;
name|struct
name|uld_info
modifier|*
name|ui
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|t3_uld_list_lock
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|ui
argument_list|,
argument|&t3_uld_list
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|ui
operator|->
name|uld_id
operator|==
name|id
condition|)
block|{
name|rc
operator|=
name|ui
operator|->
name|activate
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
name|ui
operator|->
name|refcount
operator|++
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|done
label|:
name|mtx_unlock
argument_list|(
operator|&
name|t3_uld_list_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t3_deactivate_uld
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|int
name|rc
init|=
name|EINVAL
decl_stmt|;
name|struct
name|uld_info
modifier|*
name|ui
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|t3_uld_list_lock
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|ui
argument_list|,
argument|&t3_uld_list
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|ui
operator|->
name|uld_id
operator|==
name|id
condition|)
block|{
name|rc
operator|=
name|ui
operator|->
name|deactivate
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
name|ui
operator|->
name|refcount
operator|--
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|done
label|:
name|mtx_unlock
argument_list|(
operator|&
name|t3_uld_list_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cpl_not_handled
parameter_list|(
name|struct
name|sge_qset
modifier|*
name|qs
name|__unused
parameter_list|,
name|struct
name|rsp_desc
modifier|*
name|r
name|__unused
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EDOOFUS
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t3_register_cpl_handler
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|,
name|int
name|opcode
parameter_list|,
name|cpl_handler_t
name|h
parameter_list|)
block|{
name|uintptr_t
modifier|*
name|loc
decl_stmt|,
name|new
decl_stmt|;
if|if
condition|(
name|opcode
operator|>=
name|NUM_CPL_HANDLERS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|new
operator|=
name|h
condition|?
operator|(
name|uintptr_t
operator|)
name|h
else|:
operator|(
name|uintptr_t
operator|)
name|cpl_not_handled
expr_stmt|;
name|loc
operator|=
operator|(
name|uintptr_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|cpl_handler
index|[
name|opcode
index|]
expr_stmt|;
name|atomic_store_rel_ptr
argument_list|(
name|loc
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|cxgbc_mod_event
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|cmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|mtx_init
argument_list|(
operator|&
name|t3_list_lock
argument_list|,
literal|"T3 adapters"
argument_list|,
literal|0
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|t3_list
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|mtx_init
argument_list|(
operator|&
name|t3_uld_list_lock
argument_list|,
literal|"T3 ULDs"
argument_list|,
literal|0
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|t3_uld_list
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|MOD_UNLOAD
case|:
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|mtx_lock
argument_list|(
operator|&
name|t3_uld_list_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|t3_uld_list
argument_list|)
condition|)
block|{
name|rc
operator|=
name|EBUSY
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|t3_uld_list_lock
argument_list|)
expr_stmt|;
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|t3_uld_list_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|t3_uld_list_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mtx_lock
argument_list|(
operator|&
name|t3_list_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|t3_list
argument_list|)
condition|)
block|{
name|rc
operator|=
name|EBUSY
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|t3_list_lock
argument_list|)
expr_stmt|;
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|t3_list_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|t3_list_lock
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

end_unit

