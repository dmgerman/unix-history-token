begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************************  Copyright (c) 2007-2009, Chelsio Inc. All rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:   1. Redistributions of source code must retain the above copyright notice,     this list of conditions and the following disclaimer.   2. Neither the name of the Chelsio Corporation nor the names of its     contributors may be used to endorse or promote products derived from     this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/pciio.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus_dma.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/firmware.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pci_private.h>
end_include

begin_include
include|#
directive|include
file|<cxgb_include.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PRIV_SUPPORTED
end_ifdef

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|cxgb_setup_interrupts
parameter_list|(
name|adapter_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgb_teardown_interrupts
parameter_list|(
name|adapter_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgb_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgb_init_locked
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgb_stop_locked
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgb_set_rxmode
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgb_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|unsigned
name|long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgb_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgb_ifm_type
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgb_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|setup_sge_qsets
parameter_list|(
name|adapter_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgb_async_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgb_ext_intr_handler
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgb_tick_handler
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgb_down_locked
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgb_tick
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|setup_rss
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Attachment glue for the PCI controller end of the device.  Each port of  * the device is attached separately, as defined later.  */
end_comment

begin_function_decl
specifier|static
name|int
name|cxgb_controller_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgb_controller_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgb_controller_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgb_free
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|reg_block_dump
parameter_list|(
name|struct
name|adapter
modifier|*
name|ap
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|unsigned
name|int
name|start
parameter_list|,
name|unsigned
name|int
name|end
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgb_get_regs
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|,
name|struct
name|ch_ifconf_regs
modifier|*
name|regs
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgb_get_regs_len
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|offload_open
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|touch_bars
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|offload_close
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|tdev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgb_link_start
parameter_list|(
name|struct
name|port_info
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|t3_detect_link_fault
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|port_id
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|cxgb_controller_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|cxgb_controller_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|cxgb_controller_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|cxgb_controller_detach
argument_list|)
block|,
comment|/* bus interface */
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|bus_generic_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_driver_added
argument_list|,
name|bus_generic_driver_added
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|cxgb_controller_driver
init|=
block|{
literal|"cxgbc"
block|,
name|cxgb_controller_methods
block|,
expr|sizeof
operator|(
expr|struct
name|adapter
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|cxgb_controller_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|cxgbc
argument_list|,
name|pci
argument_list|,
name|cxgb_controller_driver
argument_list|,
name|cxgb_controller_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Attachment glue for the ports.  Attachment is done directly to the  * controller device.  */
end_comment

begin_function_decl
specifier|static
name|int
name|cxgb_port_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgb_port_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgb_port_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|cxgb_port_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|cxgb_port_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|cxgb_port_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|cxgb_port_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|cxgb_port_driver
init|=
block|{
literal|"cxgb"
block|,
name|cxgb_port_methods
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|cxgb_extension_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|cxgb_extension_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|cxgb_extension_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|cxgb_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
literal|0
block|,
operator|.
name|d_open
operator|=
name|cxgb_extension_open
block|,
operator|.
name|d_close
operator|=
name|cxgb_extension_close
block|,
operator|.
name|d_ioctl
operator|=
name|cxgb_extension_ioctl
block|,
operator|.
name|d_name
operator|=
literal|"cxgb"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|cxgb_port_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|cxgb
argument_list|,
name|cxgbc
argument_list|,
name|cxgb_port_driver
argument_list|,
name|cxgb_port_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * The driver uses the best interrupt scheme available on a platform in the  * order MSI-X, MSI, legacy pin interrupts.  This parameter determines which  * of these schemes the driver may consider as follows:  *  * msi = 2: choose from among all three options  * msi = 1 : only consider MSI and pin interrupts  * msi = 0: force pin interrupts  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|msi_allowed
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgb.msi_allowed"
argument_list|,
operator|&
name|msi_allowed
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|cxgb
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"CXGB driver parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_cxgb
argument_list|,
name|OID_AUTO
argument_list|,
name|msi_allowed
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|msi_allowed
argument_list|,
literal|0
argument_list|,
literal|"MSI-X, MSI, INTx selector"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * The driver enables offload as a default.  * To disable it, use ofld_disable = 1.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ofld_disable
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgb.ofld_disable"
argument_list|,
operator|&
name|ofld_disable
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_cxgb
argument_list|,
name|OID_AUTO
argument_list|,
name|ofld_disable
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|ofld_disable
argument_list|,
literal|0
argument_list|,
literal|"disable ULP offload"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * The driver uses an auto-queue algorithm by default.  * To disable it and force a single queue-set per port, use multiq = 0  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|multiq
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgb.multiq"
argument_list|,
operator|&
name|multiq
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_cxgb
argument_list|,
name|OID_AUTO
argument_list|,
name|multiq
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|multiq
argument_list|,
literal|0
argument_list|,
literal|"use min(ncpus/ports, 8) queue-sets per port"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * By default the driver will not update the firmware unless  * it was compiled against a newer version  *   */
end_comment

begin_decl_stmt
specifier|static
name|int
name|force_fw_update
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgb.force_fw_update"
argument_list|,
operator|&
name|force_fw_update
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_cxgb
argument_list|,
name|OID_AUTO
argument_list|,
name|force_fw_update
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|force_fw_update
argument_list|,
literal|0
argument_list|,
literal|"update firmware even if up to date"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|cxgb_use_16k_clusters
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgb.use_16k_clusters"
argument_list|,
operator|&
name|cxgb_use_16k_clusters
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_cxgb
argument_list|,
name|OID_AUTO
argument_list|,
name|use_16k_clusters
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|cxgb_use_16k_clusters
argument_list|,
literal|0
argument_list|,
literal|"use 16kB clusters for the jumbo queue "
argument_list|)
expr_stmt|;
end_expr_stmt

begin_enum
enum|enum
block|{
name|MAX_TXQ_ENTRIES
init|=
literal|16384
block|,
name|MAX_CTRL_TXQ_ENTRIES
init|=
literal|1024
block|,
name|MAX_RSPQ_ENTRIES
init|=
literal|16384
block|,
name|MAX_RX_BUFFERS
init|=
literal|16384
block|,
name|MAX_RX_JUMBO_BUFFERS
init|=
literal|16384
block|,
name|MIN_TXQ_ENTRIES
init|=
literal|4
block|,
name|MIN_CTRL_TXQ_ENTRIES
init|=
literal|4
block|,
name|MIN_RSPQ_ENTRIES
init|=
literal|32
block|,
name|MIN_FL_ENTRIES
init|=
literal|32
block|,
name|MIN_FL_JUMBO_ENTRIES
init|=
literal|32
block|}
enum|;
end_enum

begin_struct
struct|struct
name|filter_info
block|{
name|u32
name|sip
decl_stmt|;
name|u32
name|sip_mask
decl_stmt|;
name|u32
name|dip
decl_stmt|;
name|u16
name|sport
decl_stmt|;
name|u16
name|dport
decl_stmt|;
name|u32
name|vlan
range|:
literal|12
decl_stmt|;
name|u32
name|vlan_prio
range|:
literal|3
decl_stmt|;
name|u32
name|mac_hit
range|:
literal|1
decl_stmt|;
name|u32
name|mac_idx
range|:
literal|4
decl_stmt|;
name|u32
name|mac_vld
range|:
literal|1
decl_stmt|;
name|u32
name|pkt_type
range|:
literal|2
decl_stmt|;
name|u32
name|report_filter_id
range|:
literal|1
decl_stmt|;
name|u32
name|pass
range|:
literal|1
decl_stmt|;
name|u32
name|rss
range|:
literal|1
decl_stmt|;
name|u32
name|qset
range|:
literal|3
decl_stmt|;
name|u32
name|locked
range|:
literal|1
decl_stmt|;
name|u32
name|valid
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
block|{
name|FILTER_NO_VLAN_PRI
init|=
literal|7
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|EEPROM_MAGIC
value|0x38E2F10C
end_define

begin_define
define|#
directive|define
name|PORT_MASK
value|((1<< MAX_NPORTS) - 1)
end_define

begin_comment
comment|/* Table for probing the cards.  The desc field isn't actually used */
end_comment

begin_struct
struct|struct
name|cxgb_ident
block|{
name|uint16_t
name|vendor
decl_stmt|;
name|uint16_t
name|device
decl_stmt|;
name|int
name|index
decl_stmt|;
name|char
modifier|*
name|desc
decl_stmt|;
block|}
name|cxgb_identifiers
index|[]
init|=
block|{
block|{
name|PCI_VENDOR_ID_CHELSIO
block|,
literal|0x0020
block|,
literal|0
block|,
literal|"PE9000"
block|}
block|,
block|{
name|PCI_VENDOR_ID_CHELSIO
block|,
literal|0x0021
block|,
literal|1
block|,
literal|"T302E"
block|}
block|,
block|{
name|PCI_VENDOR_ID_CHELSIO
block|,
literal|0x0022
block|,
literal|2
block|,
literal|"T310E"
block|}
block|,
block|{
name|PCI_VENDOR_ID_CHELSIO
block|,
literal|0x0023
block|,
literal|3
block|,
literal|"T320X"
block|}
block|,
block|{
name|PCI_VENDOR_ID_CHELSIO
block|,
literal|0x0024
block|,
literal|1
block|,
literal|"T302X"
block|}
block|,
block|{
name|PCI_VENDOR_ID_CHELSIO
block|,
literal|0x0025
block|,
literal|3
block|,
literal|"T320E"
block|}
block|,
block|{
name|PCI_VENDOR_ID_CHELSIO
block|,
literal|0x0026
block|,
literal|2
block|,
literal|"T310X"
block|}
block|,
block|{
name|PCI_VENDOR_ID_CHELSIO
block|,
literal|0x0030
block|,
literal|2
block|,
literal|"T3B10"
block|}
block|,
block|{
name|PCI_VENDOR_ID_CHELSIO
block|,
literal|0x0031
block|,
literal|3
block|,
literal|"T3B20"
block|}
block|,
block|{
name|PCI_VENDOR_ID_CHELSIO
block|,
literal|0x0032
block|,
literal|1
block|,
literal|"T3B02"
block|}
block|,
block|{
name|PCI_VENDOR_ID_CHELSIO
block|,
literal|0x0033
block|,
literal|4
block|,
literal|"T3B04"
block|}
block|,
block|{
name|PCI_VENDOR_ID_CHELSIO
block|,
literal|0x0035
block|,
literal|6
block|,
literal|"N310E"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|set_eeprom
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|__inline
name|char
name|t3rev2char
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|char
name|rev
init|=
literal|'z'
decl_stmt|;
switch|switch
condition|(
name|adapter
operator|->
name|params
operator|.
name|rev
condition|)
block|{
case|case
name|T3_REV_A
case|:
name|rev
operator|=
literal|'a'
expr_stmt|;
break|break;
case|case
name|T3_REV_B
case|:
case|case
name|T3_REV_B2
case|:
name|rev
operator|=
literal|'b'
expr_stmt|;
break|break;
case|case
name|T3_REV_C
case|:
name|rev
operator|=
literal|'c'
expr_stmt|;
break|break;
block|}
return|return
name|rev
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|cxgb_ident
modifier|*
name|cxgb_get_ident
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|cxgb_ident
modifier|*
name|id
decl_stmt|;
for|for
control|(
name|id
operator|=
name|cxgb_identifiers
init|;
name|id
operator|->
name|desc
operator|!=
name|NULL
condition|;
name|id
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|id
operator|->
name|vendor
operator|==
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|)
operator|&&
operator|(
name|id
operator|->
name|device
operator|==
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
name|id
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|struct
name|adapter_info
modifier|*
name|cxgb_get_adapter_info
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|cxgb_ident
modifier|*
name|id
decl_stmt|;
specifier|const
name|struct
name|adapter_info
modifier|*
name|ai
decl_stmt|;
name|id
operator|=
name|cxgb_get_ident
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ai
operator|=
name|t3_get_adapter_info
argument_list|(
name|id
operator|->
name|index
argument_list|)
expr_stmt|;
return|return
operator|(
name|ai
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_controller_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
specifier|const
name|struct
name|adapter_info
modifier|*
name|ai
decl_stmt|;
name|char
modifier|*
name|ports
decl_stmt|,
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|int
name|nports
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|ai
operator|=
name|cxgb_get_adapter_info
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|nports
operator|=
name|ai
operator|->
name|nports0
operator|+
name|ai
operator|->
name|nports1
expr_stmt|;
if|if
condition|(
name|nports
operator|==
literal|1
condition|)
name|ports
operator|=
literal|"port"
expr_stmt|;
else|else
name|ports
operator|=
literal|"ports"
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s %sNIC, rev: %d nports: %d %s"
argument_list|,
name|ai
operator|->
name|desc
argument_list|,
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|?
literal|"R"
else|:
literal|""
argument_list|,
name|sc
operator|->
name|params
operator|.
name|rev
argument_list|,
name|nports
argument_list|,
name|ports
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|FW_FNAME
value|"cxgb_t3fw"
end_define

begin_define
define|#
directive|define
name|TPEEPROM_NAME
value|"cxgb_t3%c_tp_eeprom"
end_define

begin_define
define|#
directive|define
name|TPSRAM_NAME
value|"cxgb_t3%c_protocol_sram"
end_define

begin_function
specifier|static
name|int
name|upgrade_fw
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|FIRMWARE_LATEST
specifier|const
name|struct
name|firmware
modifier|*
name|fw
decl_stmt|;
else|#
directive|else
name|struct
name|firmware
modifier|*
name|fw
decl_stmt|;
endif|#
directive|endif
name|int
name|status
decl_stmt|;
if|if
condition|(
operator|(
name|fw
operator|=
name|firmware_get
argument_list|(
name|FW_FNAME
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Could not find firmware image %s\n"
argument_list|,
name|FW_FNAME
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
else|else
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"updating firmware on card\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|t3_load_fw
argument_list|(
name|sc
argument_list|,
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|fw
operator|->
name|data
argument_list|,
name|fw
operator|->
name|datasize
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"firmware update returned %s %d\n"
argument_list|,
operator|(
name|status
operator|==
literal|0
operator|)
condition|?
literal|"success"
else|:
literal|"fail"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|firmware_put
argument_list|(
name|fw
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The cxgb_controller_attach function is responsible for the initial  * bringup of the device.  Its responsibilities include:  *  *  1. Determine if the device supports MSI or MSI-X.  *  2. Allocate bus resources so that we can access the Base Address Register  *  3. Create and initialize mutexes for the controller and its control  *     logic such as SGE and MDIO.  *  4. Call hardware specific setup routine for the adapter as a whole.  *  5. Allocate the BAR for doing MSI-X.  *  6. Setup the line interrupt iff MSI-X is not supported.  *  7. Create the driver's taskq.  *  8. Start one task queue service thread.  *  9. Check if the firmware and SRAM are up-to-date.  They will be  *     auto-updated later (before FULL_INIT_DONE), if required.  * 10. Create a child device for each MAC (port)  * 11. Initialize T3 private state.  * 12. Trigger the LED  * 13. Setup offload iff supported.  * 14. Reset/restart the tick callout.  * 15. Attach sysctls  *  * NOTE: Any modification or deviation from this list MUST be reflected in  * the above comment.  Failure to do so will result in problems on various  * error conditions including link flapping.  */
end_comment

begin_function
specifier|static
name|int
name|cxgb_controller_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_t
name|child
decl_stmt|;
specifier|const
name|struct
name|adapter_info
modifier|*
name|ai
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|uint32_t
name|vers
decl_stmt|;
name|int
name|port_qsets
init|=
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|MSI_SUPPORTED
name|int
name|msi_needed
decl_stmt|,
name|reg
decl_stmt|;
endif|#
directive|endif
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|msi_count
operator|=
literal|0
expr_stmt|;
name|ai
operator|=
name|cxgb_get_adapter_info
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * XXX not really related but a recent addition 	 */
ifdef|#
directive|ifdef
name|MSI_SUPPORTED
comment|/* find the PCIe link width and set max read request to 4KB*/
if|if
condition|(
name|pci_find_extcap
argument_list|(
name|dev
argument_list|,
name|PCIY_EXPRESS
argument_list|,
operator|&
name|reg
argument_list|)
operator|==
literal|0
condition|)
block|{
name|uint16_t
name|lnk
decl_stmt|,
name|pectl
decl_stmt|;
name|lnk
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|reg
operator|+
literal|0x12
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|link_width
operator|=
operator|(
name|lnk
operator|>>
literal|4
operator|)
operator|&
literal|0x3f
expr_stmt|;
name|pectl
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|reg
operator|+
literal|0x8
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pectl
operator|=
operator|(
name|pectl
operator|&
operator|~
literal|0x7000
operator|)
operator||
operator|(
literal|5
operator|<<
literal|12
operator|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|reg
operator|+
literal|0x8
argument_list|,
name|pectl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|link_width
operator|!=
literal|0
operator|&&
name|sc
operator|->
name|link_width
operator|<=
literal|4
operator|&&
operator|(
name|ai
operator|->
name|nports0
operator|+
name|ai
operator|->
name|nports1
operator|)
operator|<=
literal|2
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"PCIe x%d Link, expect reduced performance\n"
argument_list|,
name|sc
operator|->
name|link_width
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|touch_bars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate the registers and make them available to the driver. 	 * The registers that we care about for NIC mode are in BAR 0 	 */
name|sc
operator|->
name|regs_rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|regs_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|regs_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot allocate BAR region 0\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|udbs_rid
operator|=
name|PCIR_BAR
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|udbs_res
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|is_offload
argument_list|(
name|sc
argument_list|)
operator|&&
operator|(
operator|(
name|sc
operator|->
name|udbs_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|udbs_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot allocate BAR region 1\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|snprintf
argument_list|(
name|sc
operator|->
name|lockbuf
argument_list|,
name|ADAPTER_LOCK_NAME_LEN
argument_list|,
literal|"cxgb controller lock %d"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ADAPTER_LOCK_INIT
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|lockbuf
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|sc
operator|->
name|reglockbuf
argument_list|,
name|ADAPTER_LOCK_NAME_LEN
argument_list|,
literal|"SGE reg lock %d"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|sc
operator|->
name|mdiolockbuf
argument_list|,
name|ADAPTER_LOCK_NAME_LEN
argument_list|,
literal|"cxgb mdio lock %d"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|sc
operator|->
name|elmerlockbuf
argument_list|,
name|ADAPTER_LOCK_NAME_LEN
argument_list|,
literal|"cxgb elmer lock %d"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|MTX_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|reg_lock
argument_list|,
name|sc
operator|->
name|reglockbuf
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
name|MTX_INIT
argument_list|(
operator|&
name|sc
operator|->
name|mdio_lock
argument_list|,
name|sc
operator|->
name|mdiolockbuf
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|MTX_INIT
argument_list|(
operator|&
name|sc
operator|->
name|elmer_lock
argument_list|,
name|sc
operator|->
name|elmerlockbuf
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bt
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|regs_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|regs_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mmio_len
operator|=
name|rman_get_size
argument_list|(
name|sc
operator|->
name|regs_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|t3_prep_adapter
argument_list|(
name|sc
argument_list|,
name|ai
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"prep adapter failed\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Allocate the BAR for doing MSI-X.  If it succeeds, try to allocate 	 * enough messages for the queue sets.  If that fails, try falling 	 * back to MSI.  If that fails, then try falling back to the legacy 	 * interrupt pin model. 	 */
ifdef|#
directive|ifdef
name|MSI_SUPPORTED
name|sc
operator|->
name|msix_regs_rid
operator|=
literal|0x20
expr_stmt|;
if|if
condition|(
operator|(
name|msi_allowed
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|sc
operator|->
name|msix_regs_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|msix_regs_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|multiq
condition|)
name|port_qsets
operator|=
name|min
argument_list|(
name|SGE_QSETS
operator|/
name|sc
operator|->
name|params
operator|.
name|nports
argument_list|,
name|mp_ncpus
argument_list|)
expr_stmt|;
name|msi_needed
operator|=
name|sc
operator|->
name|msi_count
operator|=
name|sc
operator|->
name|params
operator|.
name|nports
operator|*
name|port_qsets
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|pci_msix_count
argument_list|(
name|dev
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|error
operator|=
name|pci_alloc_msix
argument_list|(
name|dev
argument_list|,
operator|&
name|sc
operator|->
name|msi_count
argument_list|)
operator|)
operator|!=
literal|0
operator|||
name|sc
operator|->
name|msi_count
operator|!=
name|msi_needed
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"alloc msix failed - "
literal|"msi_count=%d, msi_needed=%d, err=%d; "
literal|"will try MSI\n"
argument_list|,
name|sc
operator|->
name|msi_count
argument_list|,
name|msi_needed
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msi_count
operator|=
literal|0
expr_stmt|;
name|port_qsets
operator|=
literal|1
expr_stmt|;
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|msix_regs_rid
argument_list|,
name|sc
operator|->
name|msix_regs_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msix_regs_res
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|flags
operator||=
name|USING_MSIX
expr_stmt|;
name|sc
operator|->
name|cxgb_intr
operator|=
name|cxgb_async_intr
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"using MSI-X interrupts (%u vectors)\n"
argument_list|,
name|sc
operator|->
name|msi_count
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|msi_allowed
operator|>=
literal|1
operator|)
operator|&&
operator|(
name|sc
operator|->
name|msi_count
operator|==
literal|0
operator|)
condition|)
block|{
name|sc
operator|->
name|msi_count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|pci_alloc_msi
argument_list|(
name|dev
argument_list|,
operator|&
name|sc
operator|->
name|msi_count
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"alloc msi failed - "
literal|"err=%d; will try INTx\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msi_count
operator|=
literal|0
expr_stmt|;
name|port_qsets
operator|=
literal|1
expr_stmt|;
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|flags
operator||=
name|USING_MSI
expr_stmt|;
name|sc
operator|->
name|cxgb_intr
operator|=
name|t3_intr_msi
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"using MSI interrupts\n"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|msi_count
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"using line interrupts\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cxgb_intr
operator|=
name|t3b_intr
expr_stmt|;
block|}
comment|/* Create a private taskqueue thread for handling driver events */
ifdef|#
directive|ifdef
name|TASKQUEUE_CURRENT
name|sc
operator|->
name|tq
operator|=
name|taskqueue_create
argument_list|(
literal|"cxgb_taskq"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|sc
operator|->
name|tq
argument_list|)
expr_stmt|;
else|#
directive|else
name|sc
operator|->
name|tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"cxgb_taskq"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|sc
operator|->
name|tq
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|tq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to allocate controller task queue\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|taskqueue_start_threads
argument_list|(
operator|&
name|sc
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s taskq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|ext_intr_task
argument_list|,
literal|0
argument_list|,
name|cxgb_ext_intr_handler
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|tick_task
argument_list|,
literal|0
argument_list|,
name|cxgb_tick_handler
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* Create a periodic callout for checking adapter status */
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|cxgb_tick_ch
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|t3_check_fw_version
argument_list|(
name|sc
argument_list|)
operator|<
literal|0
operator|||
name|force_fw_update
condition|)
block|{
comment|/* 		 * Warn user that a firmware update will be attempted in init. 		 */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"firmware needs to be updated to version %d.%d.%d\n"
argument_list|,
name|FW_VERSION_MAJOR
argument_list|,
name|FW_VERSION_MINOR
argument_list|,
name|FW_VERSION_MICRO
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator|&=
operator|~
name|FW_UPTODATE
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|flags
operator||=
name|FW_UPTODATE
expr_stmt|;
block|}
if|if
condition|(
name|t3_check_tpsram_version
argument_list|(
name|sc
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* 		 * Warn user that a firmware update will be attempted in init. 		 */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"SRAM needs to be updated to version %c-%d.%d.%d\n"
argument_list|,
name|t3rev2char
argument_list|(
name|sc
argument_list|)
argument_list|,
name|TP_VERSION_MAJOR
argument_list|,
name|TP_VERSION_MINOR
argument_list|,
name|TP_VERSION_MICRO
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator|&=
operator|~
name|TPS_UPTODATE
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|flags
operator||=
name|TPS_UPTODATE
expr_stmt|;
block|}
comment|/* 	 * Create a child device for each MAC.  The ethernet attachment 	 * will be done in these children. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|sc
operator|)
operator|->
name|params
operator|.
name|nports
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|port_info
modifier|*
name|pi
decl_stmt|;
if|if
condition|(
operator|(
name|child
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"cxgb"
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to add child port\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|pi
operator|=
operator|&
name|sc
operator|->
name|port
index|[
name|i
index|]
expr_stmt|;
name|pi
operator|->
name|adapter
operator|=
name|sc
expr_stmt|;
name|pi
operator|->
name|nqsets
operator|=
name|port_qsets
expr_stmt|;
name|pi
operator|->
name|first_qset
operator|=
name|i
operator|*
name|port_qsets
expr_stmt|;
name|pi
operator|->
name|port_id
operator|=
name|i
expr_stmt|;
name|pi
operator|->
name|tx_chan
operator|=
name|i
operator|>=
name|ai
operator|->
name|nports0
expr_stmt|;
name|pi
operator|->
name|txpkt_intf
operator|=
name|pi
operator|->
name|tx_chan
condition|?
literal|2
operator|*
operator|(
name|i
operator|-
name|ai
operator|->
name|nports0
operator|)
operator|+
literal|1
else|:
literal|2
operator|*
name|i
expr_stmt|;
name|sc
operator|->
name|rxpkt_map
index|[
name|pi
operator|->
name|txpkt_intf
index|]
operator|=
name|i
expr_stmt|;
name|sc
operator|->
name|port
index|[
name|i
index|]
operator|.
name|tx_chan
operator|=
name|i
operator|>=
name|ai
operator|->
name|nports0
expr_stmt|;
name|sc
operator|->
name|portdev
index|[
name|i
index|]
operator|=
name|child
expr_stmt|;
name|device_set_softc
argument_list|(
name|child
argument_list|,
name|pi
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* initialize sge private state */
name|t3_sge_init_adapter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|t3_led_ready
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cxgb_offload_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|setbit
argument_list|(
operator|&
name|sc
operator|->
name|registered_device_map
argument_list|,
name|OFFLOAD_DEVMAP_BIT
argument_list|)
expr_stmt|;
name|cxgb_adapter_ofld
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|t3_get_fw_version
argument_list|(
name|sc
argument_list|,
operator|&
name|vers
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|snprintf
argument_list|(
operator|&
name|sc
operator|->
name|fw_version
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|fw_version
argument_list|)
argument_list|,
literal|"%d.%d.%d"
argument_list|,
name|G_FW_VERSION_MAJOR
argument_list|(
name|vers
argument_list|)
argument_list|,
name|G_FW_VERSION_MINOR
argument_list|(
name|vers
argument_list|)
argument_list|,
name|G_FW_VERSION_MICRO
argument_list|(
name|vers
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s\t E/C: %s S/N: %s"
argument_list|,
name|ai
operator|->
name|desc
argument_list|,
name|sc
operator|->
name|params
operator|.
name|vpd
operator|.
name|ec
argument_list|,
name|sc
operator|->
name|params
operator|.
name|vpd
operator|.
name|sn
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
operator|&
name|sc
operator|->
name|port_types
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|port_types
argument_list|)
argument_list|,
literal|"%x%x%x%x"
argument_list|,
name|sc
operator|->
name|params
operator|.
name|vpd
operator|.
name|port_type
index|[
literal|0
index|]
argument_list|,
name|sc
operator|->
name|params
operator|.
name|vpd
operator|.
name|port_type
index|[
literal|1
index|]
argument_list|,
name|sc
operator|->
name|params
operator|.
name|vpd
operator|.
name|port_type
index|[
literal|2
index|]
argument_list|,
name|sc
operator|->
name|params
operator|.
name|vpd
operator|.
name|port_type
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Firmware Version %s\n"
argument_list|,
operator|&
name|sc
operator|->
name|fw_version
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|cxgb_tick_ch
argument_list|,
name|CXGB_TICKS
argument_list|(
name|sc
argument_list|)
argument_list|,
name|cxgb_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|t3_add_attach_sysctls
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|error
condition|)
name|cxgb_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The cxgb_controller_detach routine is called with the device is  * unloaded from the system.  */
end_comment

begin_function
specifier|static
name|int
name|cxgb_controller_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|cxgb_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The cxgb_free() is called by the cxgb_controller_detach() routine  * to tear down the structures that were built up in  * cxgb_controller_attach(), and should be the final piece of work  * done when fully unloading the driver.  *   *  *  1. Shutting down the threads started by the cxgb_controller_attach()  *     routine.  *  2. Stopping the lower level device and all callouts (cxgb_down_locked()).  *  3. Detaching all of the port devices created during the  *     cxgb_controller_attach() routine.  *  4. Removing the device children created via cxgb_controller_attach().  *  5. Releasing PCI resources associated with the device.  *  6. Turning off the offload support, iff it was turned on.  *  7. Destroying the mutexes created in cxgb_controller_attach().  *  */
end_comment

begin_function
specifier|static
name|void
name|cxgb_free
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|CXGB_SHUTDOWN
expr_stmt|;
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cxgb_pcpu_shutdown_threads
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cxgb_down_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|t3_sge_deinit_sw
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for last callout 	 */
name|DELAY
argument_list|(
name|hz
operator|*
literal|100
argument_list|)
expr_stmt|;
name|bus_generic_detach
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|sc
operator|)
operator|->
name|params
operator|.
name|nports
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|portdev
index|[
name|i
index|]
operator|&&
name|device_delete_child
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|portdev
index|[
name|i
index|]
argument_list|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to delete child port\n"
argument_list|)
expr_stmt|;
block|}
name|cxgb_teardown_interrupts
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MSI_SUPPORTED
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
operator|(
name|USING_MSI
operator||
name|USING_MSIX
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"releasing msi message(s)\n"
argument_list|)
expr_stmt|;
name|pci_release_msi
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"no msi message to release\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|msix_regs_res
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|msix_regs_rid
argument_list|,
name|sc
operator|->
name|msix_regs_res
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|tq
operator|!=
name|NULL
condition|)
block|{
name|taskqueue_free
argument_list|(
name|sc
operator|->
name|tq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tq
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|cxgb_adapter_unofld
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
operator|&
name|sc
operator|->
name|open_device_map
argument_list|,
name|OFFLOAD_DEVMAP_BIT
argument_list|)
condition|)
name|offload_close
argument_list|(
operator|&
name|sc
operator|->
name|tdev
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"cxgb_free: DEVMAP_BIT not set\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"not offloading set\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|CXGB_OFLD_INIT
condition|)
name|cxgb_offload_deactivate
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|sc
operator|->
name|filters
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|t3_sge_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cxgb_offload_exit
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|udbs_res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|udbs_rid
argument_list|,
name|sc
operator|->
name|udbs_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|regs_res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|regs_rid
argument_list|,
name|sc
operator|->
name|regs_res
argument_list|)
expr_stmt|;
name|MTX_DESTROY
argument_list|(
operator|&
name|sc
operator|->
name|mdio_lock
argument_list|)
expr_stmt|;
name|MTX_DESTROY
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
name|MTX_DESTROY
argument_list|(
operator|&
name|sc
operator|->
name|elmer_lock
argument_list|)
expr_stmt|;
name|ADAPTER_LOCK_DEINIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	setup_sge_qsets - configure SGE Tx/Rx/response queues  *	@sc: the controller softc  *  *	Determines how many sets of SGE queues to use and initializes them.  *	We support multiple queue sets per port if we have MSI-X, otherwise  *	just one queue set per port.  */
end_comment

begin_function
specifier|static
name|int
name|setup_sge_qsets
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|err
decl_stmt|,
name|irq_idx
init|=
literal|0
decl_stmt|,
name|qset_idx
init|=
literal|0
decl_stmt|;
name|u_int
name|ntxq
init|=
name|SGE_TXQ_PER_SET
decl_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|t3_sge_alloc
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"t3_sge_alloc returned %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|params
operator|.
name|rev
operator|>
literal|0
operator|&&
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|USING_MSI
operator|)
condition|)
name|irq_idx
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|sc
operator|)
operator|->
name|params
operator|.
name|nports
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
operator|&
name|sc
operator|->
name|port
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pi
operator|->
name|nqsets
condition|;
name|j
operator|++
operator|,
name|qset_idx
operator|++
control|)
block|{
name|err
operator|=
name|t3_sge_alloc_qset
argument_list|(
name|sc
argument_list|,
name|qset_idx
argument_list|,
operator|(
name|sc
operator|)
operator|->
name|params
operator|.
name|nports
argument_list|,
operator|(
name|sc
operator|->
name|flags
operator|&
name|USING_MSIX
operator|)
condition|?
name|qset_idx
operator|+
literal|1
else|:
name|irq_idx
argument_list|,
operator|&
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|qset
index|[
name|qset_idx
index|]
argument_list|,
name|ntxq
argument_list|,
name|pi
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|t3_free_sge_resources
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"t3_sge_alloc_qset failed with %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_teardown_interrupts
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SGE_QSETS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|msix_intr_tag
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
comment|/* Should have been setup fully or not at all */
name|KASSERT
argument_list|(
name|sc
operator|->
name|msix_irq_res
index|[
name|i
index|]
operator|==
name|NULL
operator|&&
name|sc
operator|->
name|msix_irq_rid
index|[
name|i
index|]
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: half-done interrupt (%d)."
operator|,
name|__func__
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|bus_teardown_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|msix_irq_res
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|msix_intr_tag
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|msix_irq_rid
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|msix_irq_res
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msix_irq_res
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|msix_intr_tag
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|msix_irq_rid
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|intr_tag
condition|)
block|{
name|KASSERT
argument_list|(
name|sc
operator|->
name|irq_res
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: half-done interrupt."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|sc
operator|->
name|intr_tag
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irq_rid
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq_res
operator|=
name|sc
operator|->
name|intr_tag
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|irq_rid
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_setup_interrupts
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|void
modifier|*
name|tag
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rid
decl_stmt|,
name|err
decl_stmt|,
name|intr_flag
init|=
name|sc
operator|->
name|flags
operator|&
operator|(
name|USING_MSI
operator||
name|USING_MSIX
operator|)
decl_stmt|;
name|sc
operator|->
name|irq_rid
operator|=
name|intr_flag
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|sc
operator|->
name|irq_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|irq_rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot allocate interrupt (%x, %u)\n"
argument_list|,
name|intr_flag
argument_list|,
name|sc
operator|->
name|irq_rid
argument_list|)
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
name|sc
operator|->
name|irq_rid
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|INTR_MPSAFE
operator||
name|INTR_TYPE_NET
argument_list|,
ifdef|#
directive|ifdef
name|INTR_FILTERS
name|NULL
argument_list|,
endif|#
directive|endif
name|sc
operator|->
name|cxgb_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|intr_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot set up interrupt (%x, %u, %d)\n"
argument_list|,
name|intr_flag
argument_list|,
name|sc
operator|->
name|irq_rid
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irq_rid
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq_res
operator|=
name|sc
operator|->
name|intr_tag
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|irq_rid
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* That's all for INTx or MSI */
if|if
condition|(
operator|!
operator|(
name|intr_flag
operator|&
name|USING_MSIX
operator|)
operator|||
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|msi_count
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|rid
operator|=
name|i
operator|+
literal|2
expr_stmt|;
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot allocate interrupt "
literal|"for message %d\n"
argument_list|,
name|rid
argument_list|)
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|err
operator|=
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|res
argument_list|,
name|INTR_MPSAFE
operator||
name|INTR_TYPE_NET
argument_list|,
ifdef|#
directive|ifdef
name|INTR_FILTERS
name|NULL
argument_list|,
endif|#
directive|endif
name|t3_intr_msix
argument_list|,
operator|&
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
name|i
index|]
argument_list|,
operator|&
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot set up interrupt "
literal|"for message %d (%d)\n"
argument_list|,
name|rid
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
name|res
argument_list|)
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|msix_irq_rid
index|[
name|i
index|]
operator|=
name|rid
expr_stmt|;
name|sc
operator|->
name|msix_irq_res
index|[
name|i
index|]
operator|=
name|res
expr_stmt|;
name|sc
operator|->
name|msix_intr_tag
index|[
name|i
index|]
operator|=
name|tag
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
name|cxgb_teardown_interrupts
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_port_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|p
decl_stmt|;
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|desc
decl_stmt|;
name|p
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|desc
operator|=
name|p
operator|->
name|phy
operator|.
name|desc
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"Port %d %s"
argument_list|,
name|p
operator|->
name|port_id
argument_list|,
name|desc
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_makedev
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
name|pi
operator|->
name|port_cdev
operator|=
name|make_dev
argument_list|(
operator|&
name|cxgb_cdevsw
argument_list|,
name|pi
operator|->
name|ifp
operator|->
name|if_dunit
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
name|if_name
argument_list|(
name|pi
operator|->
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|port_cdev
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|pi
operator|->
name|port_cdev
operator|->
name|si_drv1
operator|=
operator|(
name|void
operator|*
operator|)
name|pi
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|LRO_SUPPORTED
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|IFCAP_LRO
end_ifdef

begin_undef
undef|#
directive|undef
name|IFCAP_LRO
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|IFCAP_LRO
value|0x0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TSO_SUPPORTED
end_ifdef

begin_define
define|#
directive|define
name|CXGB_CAP
value|(IFCAP_VLAN_HWTAGGING | IFCAP_VLAN_MTU | IFCAP_HWCSUM | IFCAP_VLAN_HWCSUM | IFCAP_TSO | IFCAP_JUMBO_MTU | IFCAP_LRO)
end_define

begin_comment
comment|/* Don't enable TSO6 yet */
end_comment

begin_define
define|#
directive|define
name|CXGB_CAP_ENABLE
value|(IFCAP_VLAN_HWTAGGING | IFCAP_VLAN_MTU | IFCAP_HWCSUM | IFCAP_VLAN_HWCSUM | IFCAP_TSO4 | IFCAP_JUMBO_MTU | IFCAP_LRO)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CXGB_CAP
value|(IFCAP_VLAN_HWTAGGING | IFCAP_VLAN_MTU | IFCAP_HWCSUM | IFCAP_JUMBO_MTU)
end_define

begin_comment
comment|/* Don't enable TSO6 yet */
end_comment

begin_define
define|#
directive|define
name|CXGB_CAP_ENABLE
value|(IFCAP_VLAN_HWTAGGING | IFCAP_VLAN_MTU | IFCAP_HWCSUM |  IFCAP_JUMBO_MTU)
end_define

begin_define
define|#
directive|define
name|IFCAP_TSO4
value|0x0
end_define

begin_define
define|#
directive|define
name|IFCAP_TSO6
value|0x0
end_define

begin_define
define|#
directive|define
name|CSUM_TSO
value|0x0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|cxgb_port_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|p
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|err
decl_stmt|,
name|media_flags
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
decl_stmt|;
name|p
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|=
name|p
operator|->
name|adapter
expr_stmt|;
name|snprintf
argument_list|(
name|p
operator|->
name|lockbuf
argument_list|,
name|PORT_NAME_LEN
argument_list|,
literal|"cxgb port lock %d:%d"
argument_list|,
name|device_get_unit
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|p
operator|->
name|port_id
argument_list|)
expr_stmt|;
name|PORT_LOCK_INIT
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|lockbuf
argument_list|)
expr_stmt|;
comment|/* Allocate an ifnet object and set it up */
name|ifp
operator|=
name|p
operator|->
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot allocate ifnet\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* 	 * Note that there is currently no watchdog timer. 	 */
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|cxgb_init
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|p
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|cxgb_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|cxgb_start
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
comment|/* Disable ifnet watchdog */
name|ifp
operator|->
name|if_watchdog
operator|=
name|NULL
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
argument_list|)
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|=
name|ifp
operator|->
name|if_capabilities
operator|=
name|ifp
operator|->
name|if_capenable
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|CXGB_CAP
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator||=
name|CXGB_CAP_ENABLE
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator||=
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator||
name|CSUM_IP
operator||
name|CSUM_TSO
operator|)
expr_stmt|;
comment|/* 	 * disable TSO on 4-port - it isn't supported by the firmware yet 	 */
if|if
condition|(
name|p
operator|->
name|adapter
operator|->
name|params
operator|.
name|nports
operator|>
literal|2
condition|)
block|{
name|ifp
operator|->
name|if_capabilities
operator|&=
operator|~
operator|(
name|IFCAP_TSO4
operator||
name|IFCAP_TSO6
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
operator|(
name|IFCAP_TSO4
operator||
name|IFCAP_TSO6
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|&=
operator|~
name|CSUM_TSO
expr_stmt|;
block|}
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|p
operator|->
name|hw_addr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IFNET_MULTIQUEUE
name|ifp
operator|->
name|if_transmit
operator|=
name|cxgb_pcpu_transmit
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Only default to jumbo frames on 10GigE 	 */
if|if
condition|(
name|p
operator|->
name|adapter
operator|->
name|params
operator|.
name|nports
operator|<=
literal|2
condition|)
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU_JUMBO
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|cxgb_makedev
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"makedev failed %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|ifmedia_init
argument_list|(
operator|&
name|p
operator|->
name|media
argument_list|,
name|IFM_IMASK
argument_list|,
name|cxgb_media_change
argument_list|,
name|cxgb_media_status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
operator|->
name|phy
operator|.
name|desc
argument_list|,
literal|"10GBASE-CX4"
argument_list|)
condition|)
block|{
name|media_flags
operator|=
name|IFM_ETHER
operator||
name|IFM_10G_CX4
operator||
name|IFM_FDX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
operator|->
name|phy
operator|.
name|desc
argument_list|,
literal|"10GBASE-SR"
argument_list|)
condition|)
block|{
name|media_flags
operator|=
name|IFM_ETHER
operator||
name|IFM_10G_SR
operator||
name|IFM_FDX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
operator|->
name|phy
operator|.
name|desc
argument_list|,
literal|"10GBASE-R"
argument_list|)
condition|)
block|{
name|media_flags
operator|=
name|cxgb_ifm_type
argument_list|(
name|p
operator|->
name|phy
operator|.
name|modtype
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
operator|->
name|phy
operator|.
name|desc
argument_list|,
literal|"10/100/1000BASE-T"
argument_list|)
condition|)
block|{
name|ifmedia_add
argument_list|(
operator|&
name|p
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10_T
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|p
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10_T
operator||
name|IFM_FDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|p
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_100_TX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|p
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_100_TX
operator||
name|IFM_FDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|p
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_1000_T
operator||
name|IFM_FDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|media_flags
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
operator|->
name|phy
operator|.
name|desc
argument_list|,
literal|"1000BASE-X"
argument_list|)
condition|)
block|{
comment|/* 		 * XXX: This is not very accurate.  Fix when common code 		 * returns more specific value - eg 1000BASE-SX, LX, etc. 		 * 		 * XXX: In the meantime, don't lie. Consider setting IFM_AUTO 		 * instead of SX. 		 */
name|media_flags
operator|=
name|IFM_ETHER
operator||
name|IFM_1000_SX
operator||
name|IFM_FDX
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"unsupported media type %s\n"
argument_list|,
name|p
operator|->
name|phy
operator|.
name|desc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|media_flags
condition|)
block|{
comment|/* 		 * Note the modtype on which we based our flags.  If modtype 		 * changes, we'll redo the ifmedia for this ifp.  modtype may 		 * change when transceivers are plugged in/out, and in other 		 * situations. 		 */
name|ifmedia_add
argument_list|(
operator|&
name|p
operator|->
name|media
argument_list|,
name|media_flags
argument_list|,
name|p
operator|->
name|phy
operator|.
name|modtype
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|p
operator|->
name|media
argument_list|,
name|media_flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ifmedia_add
argument_list|(
operator|&
name|p
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|p
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
block|}
comment|/* Get the latest mac address, User can use a LAA */
name|bcopy
argument_list|(
name|IF_LLADDR
argument_list|(
name|p
operator|->
name|ifp
argument_list|)
argument_list|,
name|p
operator|->
name|hw_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|t3_sge_init_port
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|LINK_ATTACH
argument_list|)
name|cxgb_link_start
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|t3_link_changed
argument_list|(
name|sc
argument_list|,
name|p
operator|->
name|port_id
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cxgb_port_detach() is called via the device_detach methods when  * cxgb_free() calls the bus_generic_detach.  It is responsible for   * removing the device from the view of the kernel, i.e. from all   * interfaces lists etc.  This routine is only called when the driver is   * being unloaded, not when the link goes down.  *   */
end_comment

begin_function
specifier|static
name|int
name|cxgb_port_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|p
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
decl_stmt|;
name|p
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|=
name|p
operator|->
name|adapter
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|port_cdev
operator|!=
name|NULL
condition|)
name|destroy_dev
argument_list|(
name|p
operator|->
name|port_cdev
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|p
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|PORT_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|cxgb_stop_locked
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|PORT_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|cxgb_tick_ch
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sge_timer_ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tq
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"draining slow intr\n"
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|sc
operator|->
name|slow_intr_task
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"draining ext intr\n"
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|sc
operator|->
name|ext_intr_task
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"draining tick task\n"
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|sc
operator|->
name|tick_task
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * the lock may be acquired in ifdetach 	 */
name|PORT_LOCK_DEINIT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|p
operator|->
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|t3_fatal_err
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|u_int
name|fw_status
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
condition|)
block|{
name|t3_sge_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|A_XGM_TX_CTRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|A_XGM_RX_CTRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|XGM_REG
argument_list|(
name|A_XGM_TX_CTRL
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|XGM_REG
argument_list|(
name|A_XGM_RX_CTRL
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t3_intr_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"encountered fatal error, operation suspended\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t3_cim_ctl_blk_read
argument_list|(
name|sc
argument_list|,
literal|0xa0
argument_list|,
literal|4
argument_list|,
name|fw_status
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"FW_ status: 0x%x, 0x%x, 0x%x, 0x%x\n"
argument_list|,
name|fw_status
index|[
literal|0
index|]
argument_list|,
name|fw_status
index|[
literal|1
index|]
argument_list|,
name|fw_status
index|[
literal|2
index|]
argument_list|,
name|fw_status
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|t3_os_find_pci_capability
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|,
name|int
name|cap
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|uint8_t
name|ptr
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|cfg
operator|=
operator|&
name|dinfo
operator|->
name|cfg
expr_stmt|;
name|status
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_STATUS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|PCIM_STATUS_CAPPRESENT
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|cfg
operator|->
name|hdrtype
operator|&
name|PCIM_HDRTYPE
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
name|ptr
operator|=
name|PCIR_CAP_PTR
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|ptr
operator|=
name|PCIR_CAP_PTR_2
expr_stmt|;
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
break|break;
block|}
name|ptr
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|ptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|ptr
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|ptr
operator|+
name|PCICAP_ID
argument_list|,
literal|1
argument_list|)
operator|==
name|cap
condition|)
return|return
operator|(
name|ptr
operator|)
return|;
name|ptr
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|ptr
operator|+
name|PCICAP_NEXTPTR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t3_os_pci_save_state
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_cfg_save
argument_list|(
name|dev
argument_list|,
name|dinfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t3_os_pci_restore_state
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_cfg_restore
argument_list|(
name|dev
argument_list|,
name|dinfo
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_os_link_changed - handle link status changes  *	@adapter: the adapter associated with the link change  *	@port_id: the port index whose limk status has changed  *	@link_status: the new status of the link  *	@speed: the new speed setting  *	@duplex: the new duplex setting  *	@fc: the new flow-control setting  *  *	This is the OS-dependent handler for link status changes.  The OS  *	neutral handler takes care of most of the processing for these events,  *	then calls this handler for any OS-specific processing.  */
end_comment

begin_function
name|void
name|t3_os_link_changed
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|port_id
parameter_list|,
name|int
name|link_status
parameter_list|,
name|int
name|speed
parameter_list|,
name|int
name|duplex
parameter_list|,
name|int
name|fc
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
operator|&
name|adapter
operator|->
name|port
index|[
name|port_id
index|]
decl_stmt|;
if|if
condition|(
name|link_status
condition|)
block|{
name|pi
operator|->
name|ifp
operator|->
name|if_baudrate
operator|=
name|IF_Mbps
argument_list|(
name|speed
argument_list|)
expr_stmt|;
name|if_link_state_change
argument_list|(
name|pi
operator|->
name|ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
block|}
else|else
name|if_link_state_change
argument_list|(
name|pi
operator|->
name|ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	t3_os_phymod_changed - handle PHY module changes  *	@phy: the PHY reporting the module change  *	@mod_type: new module type  *  *	This is the OS-dependent handler for PHY module changes.  It is  *	invoked when a PHY module is removed or inserted for any OS-specific  *	processing.  */
end_comment

begin_function
name|void
name|t3_os_phymod_changed
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|int
name|port_id
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|mod_str
index|[]
init|=
block|{
name|NULL
block|,
literal|"SR"
block|,
literal|"LR"
block|,
literal|"LRM"
block|,
literal|"TWINAX"
block|,
literal|"TWINAX"
block|,
literal|"unknown"
block|}
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
operator|&
name|adap
operator|->
name|port
index|[
name|port_id
index|]
decl_stmt|;
if|if
condition|(
name|pi
operator|->
name|phy
operator|.
name|modtype
operator|==
name|phy_modtype_none
condition|)
name|device_printf
argument_list|(
name|adap
operator|->
name|dev
argument_list|,
literal|"PHY module unplugged\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|KASSERT
argument_list|(
name|pi
operator|->
name|phy
operator|.
name|modtype
operator|<
name|ARRAY_SIZE
argument_list|(
name|mod_str
argument_list|)
argument_list|,
operator|(
literal|"invalid PHY module type %d"
operator|,
name|pi
operator|->
name|phy
operator|.
name|modtype
operator|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|adap
operator|->
name|dev
argument_list|,
literal|"%s PHY module inserted\n"
argument_list|,
name|mod_str
index|[
name|pi
operator|->
name|phy
operator|.
name|modtype
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Interrupt-context handler for external (PHY) interrupts.  */
end_comment

begin_function
name|void
name|t3_os_ext_intr_handler
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|cxgb_debug
condition|)
name|printf
argument_list|(
literal|"t3_os_ext_intr_handler\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Schedule a task to handle external interrupts as they may be slow 	 * and we use a mutex to protect MDIO registers.  We disable PHY 	 * interrupts in the meantime and let the task reenable them when 	 * it's done. 	 */
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|slow_intr_mask
condition|)
block|{
name|sc
operator|->
name|slow_intr_mask
operator|&=
operator|~
name|F_T3DBG
expr_stmt|;
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|A_PL_INT_ENABLE0
argument_list|,
name|sc
operator|->
name|slow_intr_mask
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|sc
operator|->
name|ext_intr_task
argument_list|)
expr_stmt|;
block|}
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|t3_os_set_hw_addr
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|port_idx
parameter_list|,
name|u8
name|hw_addr
index|[]
parameter_list|)
block|{
comment|/* 	 * The ifnet might not be allocated before this gets called, 	 * as this is called early on in attach by t3_prep_adapter 	 * save the address off in the port structure 	 */
if|if
condition|(
name|cxgb_debug
condition|)
name|printf
argument_list|(
literal|"set_hw_addr on idx %d addr %6D\n"
argument_list|,
name|port_idx
argument_list|,
name|hw_addr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|hw_addr
argument_list|,
name|adapter
operator|->
name|port
index|[
name|port_idx
index|]
operator|.
name|hw_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	link_start - enable a port  *	@p: the port to enable  *  *	Performs the MAC and PHY actions needed to enable a port.  */
end_comment

begin_function
specifier|static
name|void
name|cxgb_link_start
parameter_list|(
name|struct
name|port_info
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|t3_rx_mode
name|rm
decl_stmt|;
name|struct
name|cmac
modifier|*
name|mac
init|=
operator|&
name|p
operator|->
name|mac
decl_stmt|;
name|int
name|mtu
decl_stmt|,
name|hwtagging
decl_stmt|;
name|ifp
operator|=
name|p
operator|->
name|ifp
expr_stmt|;
name|bcopy
argument_list|(
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|p
operator|->
name|hw_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|mtu
operator|=
name|ifp
operator|->
name|if_mtu
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_MTU
condition|)
name|mtu
operator|+=
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
name|hwtagging
operator|=
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWTAGGING
operator|)
operator|!=
literal|0
expr_stmt|;
name|t3_init_rx_mode
argument_list|(
operator|&
name|rm
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mac
operator|->
name|multiport
condition|)
name|t3_mac_reset
argument_list|(
name|mac
argument_list|)
expr_stmt|;
name|t3_mac_set_mtu
argument_list|(
name|mac
argument_list|,
name|mtu
argument_list|)
expr_stmt|;
name|t3_set_vlan_accel
argument_list|(
name|p
operator|->
name|adapter
argument_list|,
literal|1
operator|<<
name|p
operator|->
name|tx_chan
argument_list|,
name|hwtagging
argument_list|)
expr_stmt|;
name|t3_mac_set_address
argument_list|(
name|mac
argument_list|,
literal|0
argument_list|,
name|p
operator|->
name|hw_addr
argument_list|)
expr_stmt|;
name|t3_mac_set_rx_mode
argument_list|(
name|mac
argument_list|,
operator|&
name|rm
argument_list|)
expr_stmt|;
name|t3_link_start
argument_list|(
operator|&
name|p
operator|->
name|phy
argument_list|,
name|mac
argument_list|,
operator|&
name|p
operator|->
name|link_config
argument_list|)
expr_stmt|;
name|t3_mac_enable
argument_list|(
name|mac
argument_list|,
name|MAC_DIRECTION_RX
operator||
name|MAC_DIRECTION_TX
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|await_mgmt_replies
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|unsigned
name|long
name|init_cnt
parameter_list|,
name|unsigned
name|long
name|n
parameter_list|)
block|{
name|int
name|attempts
init|=
literal|5
decl_stmt|;
while|while
condition|(
name|adap
operator|->
name|sge
operator|.
name|qs
index|[
literal|0
index|]
operator|.
name|rspq
operator|.
name|offload_pkts
operator|<
name|init_cnt
operator|+
name|n
condition|)
block|{
if|if
condition|(
operator|!
operator|--
name|attempts
condition|)
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
name|t3_os_sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|init_tp_parity
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|cpl_set_tcb_field
modifier|*
name|greq
decl_stmt|;
name|unsigned
name|long
name|cnt
init|=
name|adap
operator|->
name|sge
operator|.
name|qs
index|[
literal|0
index|]
operator|.
name|rspq
operator|.
name|offload_pkts
decl_stmt|;
name|t3_tp_set_offload_mode
argument_list|(
name|adap
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|cpl_smt_write_req
modifier|*
name|req
decl_stmt|;
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_WAITOK
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|req
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|cpl_smt_write_req
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|req
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wr_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_FORWARD
argument_list|)
argument_list|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|req
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_SMT_WRITE_REQ
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|iff
operator|=
name|i
expr_stmt|;
name|t3_mgmt_tx
argument_list|(
name|adap
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2048
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|cpl_l2t_write_req
modifier|*
name|req
decl_stmt|;
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_WAITOK
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|req
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|cpl_l2t_write_req
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|req
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wr_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_FORWARD
argument_list|)
argument_list|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|req
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_L2T_WRITE_REQ
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|params
operator|=
name|htonl
argument_list|(
name|V_L2T_W_IDX
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|t3_mgmt_tx
argument_list|(
name|adap
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2048
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|cpl_rte_write_req
modifier|*
name|req
decl_stmt|;
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_WAITOK
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|req
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|cpl_rte_write_req
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|req
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wr_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_FORWARD
argument_list|)
argument_list|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|req
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_RTE_WRITE_REQ
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|l2t_idx
operator|=
name|htonl
argument_list|(
name|V_L2T_W_IDX
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|t3_mgmt_tx
argument_list|(
name|adap
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_WAITOK
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|greq
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|cpl_set_tcb_field
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|greq
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|greq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|greq
argument_list|)
argument_list|)
expr_stmt|;
name|greq
operator|->
name|wr
operator|.
name|wr_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_FORWARD
argument_list|)
argument_list|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|greq
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_SET_TCB_FIELD
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|greq
operator|->
name|mask
operator|=
name|htobe64
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|t3_mgmt_tx
argument_list|(
name|adap
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|i
operator|=
name|await_mgmt_replies
argument_list|(
name|adap
argument_list|,
name|cnt
argument_list|,
literal|16
operator|+
literal|2048
operator|+
literal|2048
operator|+
literal|1
argument_list|)
expr_stmt|;
name|t3_tp_set_offload_mode
argument_list|(
name|adap
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	setup_rss - configure Receive Side Steering (per-queue connection demux)   *	@adap: the adapter  *  *	Sets up RSS to distribute packets to multiple receive queues.  We  *	configure the RSS CPU lookup table to distribute to the number of HW  *	receive queues, and the response queue lookup table to narrow that  *	down to the response queues actually configured for each port.  *	We always configure the RSS mapping for two ports since the mapping  *	table has plenty of entries.  */
end_comment

begin_function
specifier|static
name|void
name|setup_rss
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int
name|nq
index|[
literal|2
index|]
decl_stmt|;
name|uint8_t
name|cpus
index|[
name|SGE_QSETS
operator|+
literal|1
index|]
decl_stmt|;
name|uint16_t
name|rspq_map
index|[
name|RSS_TABLE_SIZE
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SGE_QSETS
condition|;
operator|++
name|i
control|)
name|cpus
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|cpus
index|[
name|SGE_QSETS
index|]
operator|=
literal|0xff
expr_stmt|;
name|nq
index|[
literal|0
index|]
operator|=
name|nq
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|for_each_port
argument_list|(
argument|adap
argument_list|,
argument|i
argument_list|)
block|{
specifier|const
name|struct
name|port_info
modifier|*
name|pi
init|=
name|adap2pinfo
argument_list|(
name|adap
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|nq
index|[
name|pi
operator|->
name|tx_chan
index|]
operator|+=
name|pi
operator|->
name|nqsets
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RSS_TABLE_SIZE
operator|/
literal|2
condition|;
operator|++
name|i
control|)
block|{
name|rspq_map
index|[
name|i
index|]
operator|=
name|nq
index|[
literal|0
index|]
condition|?
name|i
operator|%
name|nq
index|[
literal|0
index|]
else|:
literal|0
expr_stmt|;
name|rspq_map
index|[
name|i
operator|+
name|RSS_TABLE_SIZE
operator|/
literal|2
index|]
operator|=
name|nq
index|[
literal|1
index|]
condition|?
name|i
operator|%
name|nq
index|[
literal|1
index|]
operator|+
name|nq
index|[
literal|0
index|]
else|:
literal|0
expr_stmt|;
block|}
comment|/* Calculate the reverse RSS map table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RSS_TABLE_SIZE
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|adap
operator|->
name|rrss_map
index|[
name|rspq_map
index|[
name|i
index|]
index|]
operator|==
literal|0xff
condition|)
name|adap
operator|->
name|rrss_map
index|[
name|rspq_map
index|[
name|i
index|]
index|]
operator|=
name|i
expr_stmt|;
name|t3_config_rss
argument_list|(
name|adap
argument_list|,
name|F_RQFEEDBACKENABLE
operator||
name|F_TNLLKPEN
operator||
name|F_TNLMAPEN
operator||
name|F_TNLPRTEN
operator||
name|F_TNL2TUPEN
operator||
name|F_TNL4TUPEN
operator||
name|F_OFDMAPEN
operator||
name|F_RRCPLMAPEN
operator||
name|V_RRCPLCPUSIZE
argument_list|(
literal|6
argument_list|)
operator||
name|F_HASHTOEPLITZ
argument_list|,
name|cpus
argument_list|,
name|rspq_map
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Sends an mbuf to an offload queue driver  * after dealing with any active network taps.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|offload_tx
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|tdev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|t3_offload_tx
argument_list|(
name|tdev
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|write_smt_entry
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
operator|&
name|adapter
operator|->
name|port
index|[
name|idx
index|]
decl_stmt|;
name|struct
name|cpl_smt_write_req
modifier|*
name|req
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|req
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|cpl_smt_write_req
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|cpl_smt_write_req
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr
operator|.
name|wr_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_FORWARD
argument_list|)
argument_list|)
expr_stmt|;
name|OPCODE_TID
argument_list|(
name|req
argument_list|)
operator|=
name|htonl
argument_list|(
name|MK_OPCODE_TID
argument_list|(
name|CPL_SMT_WRITE_REQ
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|mtu_idx
operator|=
name|NMTUS
operator|-
literal|1
expr_stmt|;
comment|/* should be 0 but there's a T3 bug */
name|req
operator|->
name|iff
operator|=
name|idx
expr_stmt|;
name|memset
argument_list|(
name|req
operator|->
name|src_mac1
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|->
name|src_mac1
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|req
operator|->
name|src_mac0
argument_list|,
name|pi
operator|->
name|hw_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|m_set_priority
argument_list|(
name|m
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|offload_tx
argument_list|(
operator|&
name|adapter
operator|->
name|tdev
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|init_smt
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|for_each_port
argument_list|(
argument|adapter
argument_list|,
argument|i
argument_list|)
name|write_smt_entry
argument_list|(
name|adapter
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_port_mtus
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|)
block|{
name|unsigned
name|int
name|mtus
init|=
name|adapter
operator|->
name|port
index|[
literal|0
index|]
operator|.
name|ifp
operator|->
name|if_mtu
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|port
index|[
literal|1
index|]
operator|.
name|ifp
condition|)
name|mtus
operator||=
name|adapter
operator|->
name|port
index|[
literal|1
index|]
operator|.
name|ifp
operator|->
name|if_mtu
operator|<<
literal|16
expr_stmt|;
name|t3_write_reg
argument_list|(
name|adapter
argument_list|,
name|A_TP_MTU_PORT_TABLE
argument_list|,
name|mtus
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|send_pktsched_cmd
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|int
name|sched
parameter_list|,
name|int
name|qidx
parameter_list|,
name|int
name|lo
parameter_list|,
name|int
name|hi
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|mngt_pktsched_wr
modifier|*
name|req
decl_stmt|;
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|req
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|mngt_pktsched_wr
operator|*
argument_list|)
expr_stmt|;
name|req
operator|->
name|wr_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_MNGT
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|mngt_opcode
operator|=
name|FW_MNGTOPCODE_PKTSCHED_SET
expr_stmt|;
name|req
operator|->
name|sched
operator|=
name|sched
expr_stmt|;
name|req
operator|->
name|idx
operator|=
name|qidx
expr_stmt|;
name|req
operator|->
name|min
operator|=
name|lo
expr_stmt|;
name|req
operator|->
name|max
operator|=
name|hi
expr_stmt|;
name|req
operator|->
name|binding
operator|=
name|port
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
expr_stmt|;
name|t3_mgmt_tx
argument_list|(
name|adap
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bind_qsets
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|cxgb_pcpu_startup_threads
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|sc
operator|)
operator|->
name|params
operator|.
name|nports
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|struct
name|port_info
modifier|*
name|pi
init|=
name|adap2pinfo
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pi
operator|->
name|nqsets
condition|;
operator|++
name|j
control|)
block|{
name|send_pktsched_cmd
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|,
name|pi
operator|->
name|first_qset
operator|+
name|j
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|pi
operator|->
name|tx_chan
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|update_tpeeprom
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|FIRMWARE_LATEST
specifier|const
name|struct
name|firmware
modifier|*
name|tpeeprom
decl_stmt|;
else|#
directive|else
name|struct
name|firmware
modifier|*
name|tpeeprom
decl_stmt|;
endif|#
directive|endif
name|uint32_t
name|version
decl_stmt|;
name|unsigned
name|int
name|major
decl_stmt|,
name|minor
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|len
decl_stmt|;
name|char
name|rev
decl_stmt|,
name|name
index|[
literal|32
index|]
decl_stmt|;
name|t3_seeprom_read
argument_list|(
name|adap
argument_list|,
name|TP_SRAM_OFFSET
argument_list|,
operator|&
name|version
argument_list|)
expr_stmt|;
name|major
operator|=
name|G_TP_VERSION_MAJOR
argument_list|(
name|version
argument_list|)
expr_stmt|;
name|minor
operator|=
name|G_TP_VERSION_MINOR
argument_list|(
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|major
operator|==
name|TP_VERSION_MAJOR
operator|&&
name|minor
operator|==
name|TP_VERSION_MINOR
condition|)
return|return;
name|rev
operator|=
name|t3rev2char
argument_list|(
name|adap
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
name|TPEEPROM_NAME
argument_list|,
name|rev
argument_list|)
expr_stmt|;
name|tpeeprom
operator|=
name|firmware_get
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpeeprom
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|adap
operator|->
name|dev
argument_list|,
literal|"could not load TP EEPROM: unable to load %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|len
operator|=
name|tpeeprom
operator|->
name|datasize
operator|-
literal|4
expr_stmt|;
name|ret
operator|=
name|t3_check_tpsram
argument_list|(
name|adap
argument_list|,
name|tpeeprom
operator|->
name|data
argument_list|,
name|tpeeprom
operator|->
name|datasize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|release_tpeeprom
goto|;
if|if
condition|(
name|len
operator|!=
name|TP_SRAM_LEN
condition|)
block|{
name|device_printf
argument_list|(
name|adap
operator|->
name|dev
argument_list|,
literal|"%s length is wrong len=%d expected=%d\n"
argument_list|,
name|name
argument_list|,
name|len
argument_list|,
name|TP_SRAM_LEN
argument_list|)
expr_stmt|;
return|return;
block|}
name|ret
operator|=
name|set_eeprom
argument_list|(
operator|&
name|adap
operator|->
name|port
index|[
literal|0
index|]
argument_list|,
name|tpeeprom
operator|->
name|data
argument_list|,
name|tpeeprom
operator|->
name|datasize
argument_list|,
name|TP_SRAM_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|device_printf
argument_list|(
name|adap
operator|->
name|dev
argument_list|,
literal|"Protocol SRAM image updated in EEPROM to %d.%d.%d\n"
argument_list|,
name|TP_VERSION_MAJOR
argument_list|,
name|TP_VERSION_MINOR
argument_list|,
name|TP_VERSION_MICRO
argument_list|)
expr_stmt|;
block|}
else|else
name|device_printf
argument_list|(
name|adap
operator|->
name|dev
argument_list|,
literal|"Protocol SRAM image update in EEPROM failed\n"
argument_list|)
expr_stmt|;
name|release_tpeeprom
label|:
name|firmware_put
argument_list|(
name|tpeeprom
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|update_tpsram
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|FIRMWARE_LATEST
specifier|const
name|struct
name|firmware
modifier|*
name|tpsram
decl_stmt|;
else|#
directive|else
name|struct
name|firmware
modifier|*
name|tpsram
decl_stmt|;
endif|#
directive|endif
name|int
name|ret
decl_stmt|;
name|char
name|rev
decl_stmt|,
name|name
index|[
literal|32
index|]
decl_stmt|;
name|rev
operator|=
name|t3rev2char
argument_list|(
name|adap
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
name|TPSRAM_NAME
argument_list|,
name|rev
argument_list|)
expr_stmt|;
name|update_tpeeprom
argument_list|(
name|adap
argument_list|)
expr_stmt|;
name|tpsram
operator|=
name|firmware_get
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpsram
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|adap
operator|->
name|dev
argument_list|,
literal|"could not load TP SRAM\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
else|else
name|device_printf
argument_list|(
name|adap
operator|->
name|dev
argument_list|,
literal|"updating TP SRAM\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t3_check_tpsram
argument_list|(
name|adap
argument_list|,
name|tpsram
operator|->
name|data
argument_list|,
name|tpsram
operator|->
name|datasize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|release_tpsram
goto|;
name|ret
operator|=
name|t3_set_proto_sram
argument_list|(
name|adap
argument_list|,
name|tpsram
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|device_printf
argument_list|(
name|adap
operator|->
name|dev
argument_list|,
literal|"loading protocol SRAM failed\n"
argument_list|)
expr_stmt|;
name|release_tpsram
label|:
name|firmware_put
argument_list|(
name|tpsram
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  *	cxgb_up - enable the adapter  *	@adap: adapter being enabled  *  *	Called when the first port is enabled, this function performs the  *	actions necessary to make an adapter operational, such as completing  *	the initialization of HW modules, and enabling interrupts.  */
end_comment

begin_function
specifier|static
name|int
name|cxgb_up
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|FW_UPTODATE
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
operator|(
name|err
operator|=
name|upgrade_fw
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|TPS_UPTODATE
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
operator|(
name|err
operator|=
name|update_tpsram
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
name|err
operator|=
name|t3_init_hw
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|t3_set_reg_field
argument_list|(
name|sc
argument_list|,
name|A_TP_PARA_REG5
argument_list|,
literal|0
argument_list|,
name|F_RXDDPOFFINIT
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|A_ULPRX_TDDP_PSZ
argument_list|,
name|V_HPZ0
argument_list|(
name|PAGE_SHIFT
operator|-
literal|12
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|setup_sge_qsets
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|setup_rss
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|t3_intr_clear
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|err
operator|=
name|cxgb_setup_interrupts
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|t3_add_configured_sysctls
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|FULL_INIT_DONE
expr_stmt|;
block|}
name|t3_intr_clear
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|t3_sge_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|t3_intr_enable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|params
operator|.
name|rev
operator|>=
name|T3_REV_C
operator|&&
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|TP_PARITY_INIT
operator|)
operator|&&
name|is_offload
argument_list|(
name|sc
argument_list|)
operator|&&
name|init_tp_parity
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|flags
operator||=
name|TP_PARITY_INIT
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|TP_PARITY_INIT
condition|)
block|{
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_INT_CAUSE
argument_list|,
name|F_CMCACHEPERR
operator||
name|F_ARPLUTPERR
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|A_TP_INT_ENABLE
argument_list|,
literal|0x7fbfffff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|QUEUES_BOUND
operator|)
condition|)
block|{
name|bind_qsets
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|QUEUES_BOUND
expr_stmt|;
block|}
name|out
label|:
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Bring down the interface but do not free any resources.  */
end_comment

begin_function
specifier|static
name|void
name|cxgb_down_locked
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|t3_sge_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|t3_intr_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|cxgb_tick_ch
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sge_timer_ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|offload_open
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|struct
name|t3cdev
modifier|*
name|tdev
init|=
operator|&
name|adapter
operator|->
name|tdev
decl_stmt|;
name|int
name|adap_up
init|=
name|adapter
operator|->
name|open_device_map
operator|&
name|PORT_MASK
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|atomic_cmpset_int
argument_list|(
operator|&
name|adapter
operator|->
name|open_device_map
argument_list|,
operator|(
name|adapter
operator|->
name|open_device_map
operator|&
operator|~
operator|(
literal|1
operator|<<
name|OFFLOAD_DEVMAP_BIT
operator|)
operator|)
argument_list|,
operator|(
name|adapter
operator|->
name|open_device_map
operator||
operator|(
literal|1
operator|<<
name|OFFLOAD_DEVMAP_BIT
operator|)
operator|)
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|isset
argument_list|(
operator|&
name|adapter
operator|->
name|open_device_map
argument_list|,
name|OFFLOAD_DEVMAP_BIT
argument_list|)
condition|)
name|printf
argument_list|(
literal|"offload_open: DEVMAP_BIT did not get set 0x%x\n"
argument_list|,
name|adapter
operator|->
name|open_device_map
argument_list|)
expr_stmt|;
name|ADAPTER_LOCK
argument_list|(
name|pi
operator|->
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|adap_up
condition|)
name|err
operator|=
name|cxgb_up
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ADAPTER_UNLOCK
argument_list|(
name|pi
operator|->
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|t3_tp_set_offload_mode
argument_list|(
name|adapter
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tdev
operator|->
name|lldev
operator|=
name|pi
operator|->
name|ifp
expr_stmt|;
name|init_port_mtus
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|t3_load_mtus
argument_list|(
name|adapter
argument_list|,
name|adapter
operator|->
name|params
operator|.
name|mtus
argument_list|,
name|adapter
operator|->
name|params
operator|.
name|a_wnd
argument_list|,
name|adapter
operator|->
name|params
operator|.
name|b_wnd
argument_list|,
name|adapter
operator|->
name|params
operator|.
name|rev
operator|==
literal|0
condition|?
name|adapter
operator|->
name|port
index|[
literal|0
index|]
operator|.
name|ifp
operator|->
name|if_mtu
else|:
literal|0xffff
argument_list|)
expr_stmt|;
name|init_smt
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* Call back all registered clients */
name|cxgb_add_clients
argument_list|(
name|tdev
argument_list|)
expr_stmt|;
comment|/* restore them in case the offload module has changed them */
if|if
condition|(
name|err
condition|)
block|{
name|t3_tp_set_offload_mode
argument_list|(
name|adapter
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrbit
argument_list|(
operator|&
name|adapter
operator|->
name|open_device_map
argument_list|,
name|OFFLOAD_DEVMAP_BIT
argument_list|)
expr_stmt|;
name|cxgb_set_dummy_ops
argument_list|(
name|tdev
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|offload_close
parameter_list|(
name|struct
name|t3cdev
modifier|*
name|tdev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|tdev2adap
argument_list|(
name|tdev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isset
argument_list|(
operator|&
name|adapter
operator|->
name|open_device_map
argument_list|,
name|OFFLOAD_DEVMAP_BIT
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Call back all registered clients */
name|cxgb_remove_clients
argument_list|(
name|tdev
argument_list|)
expr_stmt|;
name|tdev
operator|->
name|lldev
operator|=
name|NULL
expr_stmt|;
name|cxgb_set_dummy_ops
argument_list|(
name|tdev
argument_list|)
expr_stmt|;
name|t3_tp_set_offload_mode
argument_list|(
name|adapter
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrbit
argument_list|(
operator|&
name|adapter
operator|->
name|open_device_map
argument_list|,
name|OFFLOAD_DEVMAP_BIT
argument_list|)
expr_stmt|;
name|ADAPTER_LOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|adapter
operator|->
name|open_device_map
condition|)
name|cxgb_down_locked
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|ADAPTER_UNLOCK
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|p
init|=
name|arg
decl_stmt|;
name|PORT_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|cxgb_init_locked
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|PORT_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_init_locked
parameter_list|(
name|struct
name|port_info
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|adapter_t
modifier|*
name|sc
init|=
name|p
operator|->
name|adapter
decl_stmt|;
name|int
name|err
decl_stmt|;
name|PORT_LOCK_ASSERT_OWNED
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|p
operator|->
name|ifp
expr_stmt|;
name|ADAPTER_LOCK
argument_list|(
name|p
operator|->
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|open_device_map
operator|==
literal|0
operator|)
operator|&&
operator|(
name|err
operator|=
name|cxgb_up
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
block|{
name|ADAPTER_UNLOCK
argument_list|(
name|p
operator|->
name|adapter
argument_list|)
expr_stmt|;
name|cxgb_stop_locked
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|p
operator|->
name|adapter
operator|->
name|open_device_map
operator|==
literal|0
condition|)
block|{
name|t3_intr_clear
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|setbit
argument_list|(
operator|&
name|p
operator|->
name|adapter
operator|->
name|open_device_map
argument_list|,
name|p
operator|->
name|port_id
argument_list|)
expr_stmt|;
name|ADAPTER_UNLOCK
argument_list|(
name|p
operator|->
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_offload
argument_list|(
name|sc
argument_list|)
operator|&&
operator|!
name|ofld_disable
condition|)
block|{
name|err
operator|=
name|offload_open
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"Could not initialize offload capabilities\n"
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"enabling interrupts on port=%d\n"
argument_list|,
name|p
operator|->
name|port_id
argument_list|)
expr_stmt|;
name|t3_port_intr_enable
argument_list|(
name|sc
argument_list|,
name|p
operator|->
name|port_id
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LINK_ATTACH
argument_list|)
name|cxgb_link_start
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|t3_link_changed
argument_list|(
name|sc
argument_list|,
name|p
operator|->
name|port_id
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_baudrate
operator|=
name|IF_Mbps
argument_list|(
name|p
operator|->
name|link_config
operator|.
name|speed
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|cxgb_tick_ch
argument_list|,
name|CXGB_TICKS
argument_list|(
name|sc
argument_list|)
argument_list|,
name|cxgb_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|t3_sge_reset_adapter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_set_rxmode
parameter_list|(
name|struct
name|port_info
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|t3_rx_mode
name|rm
decl_stmt|;
name|struct
name|cmac
modifier|*
name|mac
init|=
operator|&
name|p
operator|->
name|mac
decl_stmt|;
name|t3_init_rx_mode
argument_list|(
operator|&
name|rm
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|p
operator|->
name|adapter
operator|->
name|mdio_lock
argument_list|)
expr_stmt|;
name|t3_mac_set_rx_mode
argument_list|(
name|mac
argument_list|,
operator|&
name|rm
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|p
operator|->
name|adapter
operator|->
name|mdio_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_stop_locked
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|PORT_LOCK_ASSERT_OWNED
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|ADAPTER_LOCK_ASSERT_NOTOWNED
argument_list|(
name|pi
operator|->
name|adapter
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|pi
operator|->
name|ifp
expr_stmt|;
name|t3_port_intr_disable
argument_list|(
name|pi
operator|->
name|adapter
argument_list|,
name|pi
operator|->
name|port_id
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
comment|/* disable pause frames */
name|t3_set_reg_field
argument_list|(
name|pi
operator|->
name|adapter
argument_list|,
name|A_XGM_TX_CFG
operator|+
name|pi
operator|->
name|mac
operator|.
name|offset
argument_list|,
name|F_TXPAUSEEN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reset RX FIFO HWM */
name|t3_set_reg_field
argument_list|(
name|pi
operator|->
name|adapter
argument_list|,
name|A_XGM_RXFIFO_CFG
operator|+
name|pi
operator|->
name|mac
operator|.
name|offset
argument_list|,
name|V_RXFIFOPAUSEHWM
argument_list|(
name|M_RXFIFOPAUSEHWM
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ADAPTER_LOCK
argument_list|(
name|pi
operator|->
name|adapter
argument_list|)
expr_stmt|;
name|clrbit
argument_list|(
operator|&
name|pi
operator|->
name|adapter
operator|->
name|open_device_map
argument_list|,
name|pi
operator|->
name|port_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|adapter
operator|->
name|open_device_map
operator|==
literal|0
condition|)
name|cxgb_down_locked
argument_list|(
name|pi
operator|->
name|adapter
argument_list|)
expr_stmt|;
name|ADAPTER_UNLOCK
argument_list|(
name|pi
operator|->
name|adapter
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LINK_ATTACH
argument_list|)
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* Wait for TXFIFO empty */
name|t3_wait_op_done
argument_list|(
name|pi
operator|->
name|adapter
argument_list|,
name|A_XGM_TXFIFO_CFG
operator|+
name|pi
operator|->
name|mac
operator|.
name|offset
argument_list|,
name|F_TXFIFO_EMPTY
argument_list|,
literal|1
argument_list|,
literal|20
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|t3_mac_disable
argument_list|(
operator|&
name|pi
operator|->
name|mac
argument_list|,
name|MAC_DIRECTION_TX
operator||
name|MAC_DIRECTION_RX
argument_list|)
expr_stmt|;
name|pi
operator|->
name|phy
operator|.
name|ops
operator|->
name|power_down
argument_list|(
operator|&
name|pi
operator|->
name|phy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_set_mtu
parameter_list|(
name|struct
name|port_info
modifier|*
name|p
parameter_list|,
name|int
name|mtu
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|p
operator|->
name|ifp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|mtu
operator|<
name|ETHERMIN
operator|)
operator|||
operator|(
name|mtu
operator|>
name|ETHERMTU_JUMBO
operator|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_mtu
operator|!=
name|mtu
condition|)
block|{
name|PORT_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|mtu
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|cxgb_stop_locked
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|cxgb_init_locked
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|PORT_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|LRO_SUPPORTED
end_ifdef

begin_comment
comment|/*  * Mark lro enabled or disabled in all qsets for this port  */
end_comment

begin_function
specifier|static
name|int
name|cxgb_set_lro
parameter_list|(
name|struct
name|port_info
modifier|*
name|p
parameter_list|,
name|int
name|enabled
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adp
init|=
name|p
operator|->
name|adapter
decl_stmt|;
name|struct
name|sge_qset
modifier|*
name|q
decl_stmt|;
name|PORT_LOCK_ASSERT_OWNED
argument_list|(
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|nqsets
condition|;
name|i
operator|++
control|)
block|{
name|q
operator|=
operator|&
name|adp
operator|->
name|sge
operator|.
name|qs
index|[
name|p
operator|->
name|first_qset
operator|+
name|i
index|]
expr_stmt|;
name|q
operator|->
name|lro
operator|.
name|enabled
operator|=
operator|(
name|enabled
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|cxgb_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|unsigned
name|long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|p
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
endif|#
directive|endif
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|,
name|reinit
init|=
literal|0
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|;
comment|/*  	 * XXX need to check that we aren't in the middle of an unload 	 */
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFMTU
case|:
name|error
operator|=
name|cxgb_set_mtu
argument_list|(
name|p
argument_list|,
name|ifr
operator|->
name|ifr_mtu
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFADDR
case|:
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|PORT_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|cxgb_init_locked
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|PORT_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|arp_ifinit
argument_list|(
name|ifp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|PORT_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|flags
operator|=
name|p
operator|->
name|if_flags
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|^
name|flags
operator|)
operator|&
name|IFF_PROMISC
operator|)
operator|||
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|^
name|flags
operator|)
operator|&
name|IFF_ALLMULTI
operator|)
condition|)
name|cxgb_set_rxmode
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
name|cxgb_init_locked
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|cxgb_stop_locked
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|PORT_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|cxgb_set_rxmode
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|PORT_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|p
operator|->
name|media
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|PORT_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
name|PORT_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mask
operator|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
if|if
condition|(
name|IFCAP_TXCSUM
operator|&
name|ifp
operator|->
name|if_capenable
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
operator|(
name|IFCAP_TXCSUM
operator||
name|IFCAP_TSO4
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|&=
operator|~
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator||
name|CSUM_IP
operator||
name|CSUM_TSO
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TXCSUM
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator||=
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator||
name|CSUM_IP
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_RXCSUM
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_RXCSUM
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO4
condition|)
block|{
if|if
condition|(
name|IFCAP_TSO4
operator|&
name|ifp
operator|->
name|if_capenable
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_TSO4
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|&=
operator|~
name|CSUM_TSO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IFCAP_TXCSUM
operator|&
name|ifp
operator|->
name|if_capenable
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TSO4
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_TSO
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cxgb_debug
condition|)
name|printf
argument_list|(
literal|"cxgb requires tx checksum offload"
literal|" be enabled to use TSO\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|LRO_SUPPORTED
if|if
condition|(
name|mask
operator|&
name|IFCAP_LRO
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_LRO
expr_stmt|;
comment|/* Safe to do this even if cxgb_up not called yet */
name|cxgb_set_lro
argument_list|(
name|p
argument_list|,
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_LRO
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWTAGGING
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTAGGING
expr_stmt|;
name|reinit
operator|=
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_MTU
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_MTU
expr_stmt|;
name|reinit
operator|=
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWCSUM
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWCSUM
expr_stmt|;
block|}
if|if
condition|(
name|reinit
condition|)
block|{
name|cxgb_stop_locked
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|cxgb_init_locked
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|PORT_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VLAN_CAPABILITIES
name|VLAN_CAPABILITIES
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"media change not supported\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Translates from phy->modtype to IFM_TYPE.  */
end_comment

begin_function
specifier|static
name|int
name|cxgb_ifm_type
parameter_list|(
name|int
name|phymod
parameter_list|)
block|{
name|int
name|rc
init|=
name|IFM_ETHER
operator||
name|IFM_FDX
decl_stmt|;
switch|switch
condition|(
name|phymod
condition|)
block|{
case|case
name|phy_modtype_sr
case|:
name|rc
operator||=
name|IFM_10G_SR
expr_stmt|;
break|break;
case|case
name|phy_modtype_lr
case|:
name|rc
operator||=
name|IFM_10G_LR
expr_stmt|;
break|break;
case|case
name|phy_modtype_lrm
case|:
ifdef|#
directive|ifdef
name|IFM_10G_LRM
name|rc
operator||=
name|IFM_10G_LRM
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|phy_modtype_twinax
case|:
ifdef|#
directive|ifdef
name|IFM_10G_TWINAX
name|rc
operator||=
name|IFM_10G_TWINAX
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|phy_modtype_twinax_long
case|:
ifdef|#
directive|ifdef
name|IFM_10G_TWINAX_LONG
name|rc
operator||=
name|IFM_10G_TWINAX_LONG
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|phy_modtype_none
case|:
name|rc
operator|=
name|IFM_ETHER
operator||
name|IFM_NONE
expr_stmt|;
break|break;
case|case
name|phy_modtype_unknown
case|:
break|break;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|p
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifmedia_entry
modifier|*
name|cur
init|=
name|p
operator|->
name|media
operator|.
name|ifm_cur
decl_stmt|;
name|int
name|m
decl_stmt|;
if|if
condition|(
name|cur
operator|->
name|ifm_data
operator|!=
name|p
operator|->
name|phy
operator|.
name|modtype
condition|)
block|{
comment|/* p->media about to be rebuilt, must hold lock */
name|PORT_LOCK_ASSERT_OWNED
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|m
operator|=
name|cxgb_ifm_type
argument_list|(
name|p
operator|->
name|phy
operator|.
name|modtype
argument_list|)
expr_stmt|;
name|ifmedia_removeall
argument_list|(
operator|&
name|p
operator|->
name|media
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|p
operator|->
name|media
argument_list|,
name|m
argument_list|,
name|p
operator|->
name|phy
operator|.
name|modtype
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|p
operator|->
name|media
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|cur
operator|=
name|p
operator|->
name|media
operator|.
name|ifm_cur
expr_stmt|;
comment|/* ifmedia_set modified ifm_cur */
name|ifmr
operator|->
name|ifm_current
operator|=
name|m
expr_stmt|;
block|}
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|link_config
operator|.
name|link_ok
condition|)
return|return;
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|link_config
operator|.
name|speed
condition|)
block|{
case|case
literal|10
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_10_T
expr_stmt|;
break|break;
case|case
literal|100
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_100_TX
expr_stmt|;
break|break;
case|case
literal|1000
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_1000_T
expr_stmt|;
break|break;
case|case
literal|10000
case|:
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_SUBTYPE
argument_list|(
name|cur
operator|->
name|ifm_media
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|p
operator|->
name|link_config
operator|.
name|duplex
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_FDX
expr_stmt|;
else|else
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_HDX
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_async_intr
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|adapter_t
modifier|*
name|sc
init|=
name|data
decl_stmt|;
if|if
condition|(
name|cxgb_debug
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"cxgb_async_intr\n"
argument_list|)
expr_stmt|;
comment|/* 	 * May need to sleep - defer to taskqueue 	 */
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|sc
operator|->
name|slow_intr_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_ext_intr_handler
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|adapter_t
modifier|*
name|sc
init|=
operator|(
name|adapter_t
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|cxgb_debug
condition|)
name|printf
argument_list|(
literal|"cxgb_ext_intr_handler\n"
argument_list|)
expr_stmt|;
name|t3_phy_intr_handler
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Now reenable external interrupts */
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|slow_intr_mask
condition|)
block|{
name|sc
operator|->
name|slow_intr_mask
operator||=
name|F_T3DBG
expr_stmt|;
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|A_PL_INT_CAUSE0
argument_list|,
name|F_T3DBG
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|A_PL_INT_ENABLE0
argument_list|,
name|sc
operator|->
name|slow_intr_mask
argument_list|)
expr_stmt|;
block|}
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_link_status
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* For synchronized access to open_device_map */
name|ADAPTER_LOCK_ASSERT_OWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|sc
operator|)
operator|->
name|params
operator|.
name|nports
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|port_info
modifier|*
name|p
init|=
operator|&
name|sc
operator|->
name|port
index|[
name|i
index|]
decl_stmt|;
name|struct
name|link_config
modifier|*
name|lc
init|=
operator|&
name|p
operator|->
name|link_config
decl_stmt|;
if|if
condition|(
operator|!
name|isset
argument_list|(
operator|&
name|sc
operator|->
name|open_device_map
argument_list|,
name|p
operator|->
name|port_id
argument_list|)
condition|)
block|{
comment|/* 			 * port is down, report link down too.  Note 			 * that we do this for IRQ based PHYs too. 			 */
name|lc
operator|->
name|link_ok
operator|=
literal|0
expr_stmt|;
name|t3_os_link_changed
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|lc
operator|->
name|link_ok
argument_list|,
name|lc
operator|->
name|speed
argument_list|,
name|lc
operator|->
name|duplex
argument_list|,
name|lc
operator|->
name|fc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|link_fault
operator|||
operator|!
operator|(
name|p
operator|->
name|phy
operator|.
name|caps
operator|&
name|SUPPORTED_IRQ
operator|)
condition|)
name|t3_link_changed
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|check_t3b2_mac
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|flags
operator|&
name|CXGB_SHUTDOWN
condition|)
return|return;
name|for_each_port
argument_list|(
argument|adapter
argument_list|,
argument|i
argument_list|)
block|{
name|struct
name|port_info
modifier|*
name|p
init|=
operator|&
name|adapter
operator|->
name|port
index|[
name|i
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|p
operator|->
name|ifp
decl_stmt|;
name|int
name|status
decl_stmt|;
if|if
condition|(
name|adapter
operator|->
name|flags
operator|&
name|CXGB_SHUTDOWN
condition|)
return|return;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|status
operator|=
literal|0
expr_stmt|;
name|PORT_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
name|status
operator|=
name|t3b2_mac_watchdog_task
argument_list|(
operator|&
name|p
operator|->
name|mac
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|1
condition|)
name|p
operator|->
name|mac
operator|.
name|stats
operator|.
name|num_toggled
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
literal|2
condition|)
block|{
name|struct
name|cmac
modifier|*
name|mac
init|=
operator|&
name|p
operator|->
name|mac
decl_stmt|;
name|int
name|mtu
init|=
name|ifp
operator|->
name|if_mtu
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_MTU
condition|)
name|mtu
operator|+=
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
name|t3_mac_set_mtu
argument_list|(
name|mac
argument_list|,
name|mtu
argument_list|)
expr_stmt|;
name|t3_mac_set_address
argument_list|(
name|mac
argument_list|,
literal|0
argument_list|,
name|p
operator|->
name|hw_addr
argument_list|)
expr_stmt|;
name|cxgb_set_rxmode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|t3_link_start
argument_list|(
operator|&
name|p
operator|->
name|phy
argument_list|,
name|mac
argument_list|,
operator|&
name|p
operator|->
name|link_config
argument_list|)
expr_stmt|;
name|t3_mac_enable
argument_list|(
name|mac
argument_list|,
name|MAC_DIRECTION_RX
operator||
name|MAC_DIRECTION_TX
argument_list|)
expr_stmt|;
name|t3_port_intr_enable
argument_list|(
name|adapter
argument_list|,
name|p
operator|->
name|port_id
argument_list|)
expr_stmt|;
name|p
operator|->
name|mac
operator|.
name|stats
operator|.
name|num_resets
operator|++
expr_stmt|;
block|}
name|PORT_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_tick
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|adapter_t
modifier|*
name|sc
init|=
operator|(
name|adapter_t
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|CXGB_SHUTDOWN
condition|)
return|return;
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|sc
operator|->
name|tick_task
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|cxgb_tick_ch
argument_list|,
name|CXGB_TICKS
argument_list|(
name|sc
argument_list|)
argument_list|,
name|cxgb_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_tick_handler
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|adapter_t
modifier|*
name|sc
init|=
operator|(
name|adapter_t
operator|*
operator|)
name|arg
decl_stmt|;
specifier|const
name|struct
name|adapter_params
modifier|*
name|p
init|=
operator|&
name|sc
operator|->
name|params
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint32_t
name|cause
decl_stmt|,
name|reset
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|CXGB_SHUTDOWN
operator|||
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
operator|)
condition|)
return|return;
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|check_link_status
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|check_task_cnt
operator|++
expr_stmt|;
comment|/* 	 * adapter lock can currently only be acquired after the 	 * port lock 	 */
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|rev
operator|==
name|T3_REV_B2
operator|&&
name|p
operator|->
name|nports
operator|<
literal|4
operator|&&
name|sc
operator|->
name|open_device_map
condition|)
name|check_t3b2_mac
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cause
operator|=
name|t3_read_reg
argument_list|(
name|sc
argument_list|,
name|A_SG_INT_CAUSE
argument_list|)
expr_stmt|;
name|reset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_FLEMPTY
condition|)
block|{
name|struct
name|sge_qset
modifier|*
name|qs
init|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
literal|0
index|]
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|reset
operator||=
name|F_FLEMPTY
expr_stmt|;
name|cause
operator|=
operator|(
name|t3_read_reg
argument_list|(
name|sc
argument_list|,
name|A_SG_RSPQ_FL_STATUS
argument_list|)
operator|>>
name|S_FL0EMPTY
operator|)
operator|&
literal|0xffff
expr_stmt|;
while|while
condition|(
name|cause
condition|)
block|{
name|qs
operator|->
name|fl
index|[
name|i
index|]
operator|.
name|empty
operator|+=
operator|(
name|cause
operator|&
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|qs
operator|++
expr_stmt|;
name|i
operator|^=
literal|1
expr_stmt|;
name|cause
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|A_SG_INT_CAUSE
argument_list|,
name|reset
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|params
operator|.
name|nports
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
operator|&
name|sc
operator|->
name|port
index|[
name|i
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|pi
operator|->
name|ifp
decl_stmt|;
name|struct
name|cmac
modifier|*
name|mac
init|=
operator|&
name|pi
operator|->
name|mac
decl_stmt|;
name|struct
name|mac_stats
modifier|*
name|mstats
init|=
operator|&
name|mac
operator|->
name|stats
decl_stmt|;
name|PORT_LOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|t3_mac_update_stats
argument_list|(
name|mac
argument_list|)
expr_stmt|;
name|PORT_UNLOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|=
name|mstats
operator|->
name|tx_frames_64
operator|+
name|mstats
operator|->
name|tx_frames_65_127
operator|+
name|mstats
operator|->
name|tx_frames_128_255
operator|+
name|mstats
operator|->
name|tx_frames_256_511
operator|+
name|mstats
operator|->
name|tx_frames_512_1023
operator|+
name|mstats
operator|->
name|tx_frames_1024_1518
operator|+
name|mstats
operator|->
name|tx_frames_1519_max
expr_stmt|;
name|ifp
operator|->
name|if_ipackets
operator|=
name|mstats
operator|->
name|rx_frames_64
operator|+
name|mstats
operator|->
name|rx_frames_65_127
operator|+
name|mstats
operator|->
name|rx_frames_128_255
operator|+
name|mstats
operator|->
name|rx_frames_256_511
operator|+
name|mstats
operator|->
name|rx_frames_512_1023
operator|+
name|mstats
operator|->
name|rx_frames_1024_1518
operator|+
name|mstats
operator|->
name|rx_frames_1519_max
expr_stmt|;
name|ifp
operator|->
name|if_obytes
operator|=
name|mstats
operator|->
name|tx_octets
expr_stmt|;
name|ifp
operator|->
name|if_ibytes
operator|=
name|mstats
operator|->
name|rx_octets
expr_stmt|;
name|ifp
operator|->
name|if_omcasts
operator|=
name|mstats
operator|->
name|tx_mcast_frames
expr_stmt|;
name|ifp
operator|->
name|if_imcasts
operator|=
name|mstats
operator|->
name|rx_mcast_frames
expr_stmt|;
name|ifp
operator|->
name|if_collisions
operator|=
name|mstats
operator|->
name|tx_total_collisions
expr_stmt|;
name|ifp
operator|->
name|if_iqdrops
operator|=
name|mstats
operator|->
name|rx_cong_drops
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|=
name|mstats
operator|->
name|tx_excess_collisions
operator|+
name|mstats
operator|->
name|tx_underrun
operator|+
name|mstats
operator|->
name|tx_len_errs
operator|+
name|mstats
operator|->
name|tx_mac_internal_errs
operator|+
name|mstats
operator|->
name|tx_excess_deferral
operator|+
name|mstats
operator|->
name|tx_fcs_errs
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|=
name|mstats
operator|->
name|rx_jabber
operator|+
name|mstats
operator|->
name|rx_data_errs
operator|+
name|mstats
operator|->
name|rx_sequence_errs
operator|+
name|mstats
operator|->
name|rx_runt
operator|+
name|mstats
operator|->
name|rx_too_long
operator|+
name|mstats
operator|->
name|rx_mac_internal_errs
operator|+
name|mstats
operator|->
name|rx_short
operator|+
name|mstats
operator|->
name|rx_fcs_errs
expr_stmt|;
if|if
condition|(
name|mac
operator|->
name|multiport
condition|)
continue|continue;
comment|/* Count rx fifo overflows, once per second */
name|cause
operator|=
name|t3_read_reg
argument_list|(
name|sc
argument_list|,
name|A_XGM_INT_CAUSE
operator|+
name|mac
operator|->
name|offset
argument_list|)
expr_stmt|;
name|reset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cause
operator|&
name|F_RXFIFO_OVERFLOW
condition|)
block|{
name|mac
operator|->
name|stats
operator|.
name|rx_fifo_ovfl
operator|++
expr_stmt|;
name|reset
operator||=
name|F_RXFIFO_OVERFLOW
expr_stmt|;
block|}
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|A_XGM_INT_CAUSE
operator|+
name|mac
operator|->
name|offset
argument_list|,
name|reset
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|touch_bars
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
comment|/* 	 * Don't enable yet 	 */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__LP64__
argument_list|)
operator|&&
literal|0
name|u32
name|v
decl_stmt|;
name|pci_read_config_dword
argument_list|(
name|pdev
argument_list|,
name|PCI_BASE_ADDRESS_1
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
name|pci_write_config_dword
argument_list|(
name|pdev
argument_list|,
name|PCI_BASE_ADDRESS_1
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|pci_read_config_dword
argument_list|(
name|pdev
argument_list|,
name|PCI_BASE_ADDRESS_3
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
name|pci_write_config_dword
argument_list|(
name|pdev
argument_list|,
name|PCI_BASE_ADDRESS_3
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|pci_read_config_dword
argument_list|(
name|pdev
argument_list|,
name|PCI_BASE_ADDRESS_5
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
name|pci_write_config_dword
argument_list|(
name|pdev
argument_list|,
name|PCI_BASE_ADDRESS_5
argument_list|,
name|v
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|set_eeprom
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|uint8_t
modifier|*
name|buf
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|u32
name|aligned_offset
decl_stmt|,
name|aligned_len
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|struct
name|adapter
modifier|*
name|adapter
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
name|aligned_offset
operator|=
name|offset
operator|&
operator|~
literal|3
expr_stmt|;
name|aligned_len
operator|=
operator|(
name|len
operator|+
operator|(
name|offset
operator|&
literal|3
operator|)
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
if|if
condition|(
name|aligned_offset
operator|!=
name|offset
operator|||
name|aligned_len
operator|!=
name|len
condition|)
block|{
name|buf
operator|=
name|malloc
argument_list|(
name|aligned_len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|err
operator|=
name|t3_seeprom_read
argument_list|(
name|adapter
argument_list|,
name|aligned_offset
argument_list|,
operator|(
name|u32
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
operator|&&
name|aligned_len
operator|>
literal|4
condition|)
name|err
operator|=
name|t3_seeprom_read
argument_list|(
name|adapter
argument_list|,
name|aligned_offset
operator|+
name|aligned_len
operator|-
literal|4
argument_list|,
operator|(
name|u32
operator|*
operator|)
operator|&
name|buf
index|[
name|aligned_len
operator|-
literal|4
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|memcpy
argument_list|(
name|buf
operator|+
operator|(
name|offset
operator|&
literal|3
operator|)
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
name|buf
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|data
expr_stmt|;
name|err
operator|=
name|t3_seeprom_wp
argument_list|(
name|adapter
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
for|for
control|(
name|p
operator|=
operator|(
name|u32
operator|*
operator|)
name|buf
init|;
operator|!
name|err
operator|&&
name|aligned_len
condition|;
name|aligned_len
operator|-=
literal|4
operator|,
name|p
operator|++
control|)
block|{
name|err
operator|=
name|t3_seeprom_write
argument_list|(
name|adapter
argument_list|,
name|aligned_offset
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|aligned_offset
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|t3_seeprom_wp
argument_list|(
name|adapter
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|buf
operator|!=
name|data
condition|)
name|free
argument_list|(
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|in_range
parameter_list|(
name|int
name|val
parameter_list|,
name|int
name|lo
parameter_list|,
name|int
name|hi
parameter_list|)
block|{
return|return
name|val
operator|<
literal|0
operator|||
operator|(
name|val
operator|<=
name|hi
operator|&&
name|val
operator|>=
name|lo
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_extension_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_extension_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_extension_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|unsigned
name|long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|mmd
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
name|adapter_t
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
ifdef|#
directive|ifdef
name|PRIV_SUPPORTED
if|if
condition|(
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
condition|)
block|{
if|if
condition|(
name|cxgb_debug
condition|)
name|printf
argument_list|(
literal|"user does not have access to privileged ioctls\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
else|#
directive|else
if|if
condition|(
name|suser
argument_list|(
name|td
argument_list|)
condition|)
block|{
if|if
condition|(
name|cxgb_debug
condition|)
name|printf
argument_list|(
literal|"user does not have access to privileged ioctls\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|CHELSIO_GET_MIIREG
case|:
block|{
name|uint32_t
name|val
decl_stmt|;
name|struct
name|cphy
modifier|*
name|phy
init|=
operator|&
name|pi
operator|->
name|phy
decl_stmt|;
name|struct
name|ch_mii_data
modifier|*
name|mid
init|=
operator|(
expr|struct
name|ch_mii_data
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|phy
operator|->
name|mdio_read
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
if|if
condition|(
name|is_10G
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|mmd
operator|=
name|mid
operator|->
name|phy_id
operator|>>
literal|8
expr_stmt|;
if|if
condition|(
operator|!
name|mmd
condition|)
name|mmd
operator|=
name|MDIO_DEV_PCS
expr_stmt|;
elseif|else
if|if
condition|(
name|mmd
operator|>
name|MDIO_DEV_VEND2
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|phy
operator|->
name|mdio_read
argument_list|(
name|sc
argument_list|,
name|mid
operator|->
name|phy_id
operator|&
literal|0x1f
argument_list|,
name|mmd
argument_list|,
name|mid
operator|->
name|reg_num
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|phy
operator|->
name|mdio_read
argument_list|(
name|sc
argument_list|,
name|mid
operator|->
name|phy_id
operator|&
literal|0x1f
argument_list|,
literal|0
argument_list|,
name|mid
operator|->
name|reg_num
operator|&
literal|0x1f
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|mid
operator|->
name|val_out
operator|=
name|val
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_SET_MIIREG
case|:
block|{
name|struct
name|cphy
modifier|*
name|phy
init|=
operator|&
name|pi
operator|->
name|phy
decl_stmt|;
name|struct
name|ch_mii_data
modifier|*
name|mid
init|=
operator|(
expr|struct
name|ch_mii_data
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|phy
operator|->
name|mdio_write
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
if|if
condition|(
name|is_10G
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|mmd
operator|=
name|mid
operator|->
name|phy_id
operator|>>
literal|8
expr_stmt|;
if|if
condition|(
operator|!
name|mmd
condition|)
name|mmd
operator|=
name|MDIO_DEV_PCS
expr_stmt|;
elseif|else
if|if
condition|(
name|mmd
operator|>
name|MDIO_DEV_VEND2
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|phy
operator|->
name|mdio_write
argument_list|(
name|sc
argument_list|,
name|mid
operator|->
name|phy_id
operator|&
literal|0x1f
argument_list|,
name|mmd
argument_list|,
name|mid
operator|->
name|reg_num
argument_list|,
name|mid
operator|->
name|val_in
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|phy
operator|->
name|mdio_write
argument_list|(
name|sc
argument_list|,
name|mid
operator|->
name|phy_id
operator|&
literal|0x1f
argument_list|,
literal|0
argument_list|,
name|mid
operator|->
name|reg_num
operator|&
literal|0x1f
argument_list|,
name|mid
operator|->
name|val_in
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_SETREG
case|:
block|{
name|struct
name|ch_reg
modifier|*
name|edata
init|=
operator|(
expr|struct
name|ch_reg
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
operator|(
name|edata
operator|->
name|addr
operator|&
literal|0x3
operator|)
operator|!=
literal|0
operator|||
name|edata
operator|->
name|addr
operator|>=
name|sc
operator|->
name|mmio_len
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|edata
operator|->
name|addr
argument_list|,
name|edata
operator|->
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_GETREG
case|:
block|{
name|struct
name|ch_reg
modifier|*
name|edata
init|=
operator|(
expr|struct
name|ch_reg
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
operator|(
name|edata
operator|->
name|addr
operator|&
literal|0x3
operator|)
operator|!=
literal|0
operator|||
name|edata
operator|->
name|addr
operator|>=
name|sc
operator|->
name|mmio_len
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|edata
operator|->
name|val
operator|=
name|t3_read_reg
argument_list|(
name|sc
argument_list|,
name|edata
operator|->
name|addr
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_GET_SGE_CONTEXT
case|:
block|{
name|struct
name|ch_cntxt
modifier|*
name|ecntxt
init|=
operator|(
expr|struct
name|ch_cntxt
operator|*
operator|)
name|data
decl_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ecntxt
operator|->
name|cntxt_type
condition|)
block|{
case|case
name|CNTXT_TYPE_EGRESS
case|:
name|error
operator|=
operator|-
name|t3_sge_read_ecntxt
argument_list|(
name|sc
argument_list|,
name|ecntxt
operator|->
name|cntxt_id
argument_list|,
name|ecntxt
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|CNTXT_TYPE_FL
case|:
name|error
operator|=
operator|-
name|t3_sge_read_fl
argument_list|(
name|sc
argument_list|,
name|ecntxt
operator|->
name|cntxt_id
argument_list|,
name|ecntxt
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|CNTXT_TYPE_RSP
case|:
name|error
operator|=
operator|-
name|t3_sge_read_rspq
argument_list|(
name|sc
argument_list|,
name|ecntxt
operator|->
name|cntxt_id
argument_list|,
name|ecntxt
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|CNTXT_TYPE_CQ
case|:
name|error
operator|=
operator|-
name|t3_sge_read_cq
argument_list|(
name|sc
argument_list|,
name|ecntxt
operator|->
name|cntxt_id
argument_list|,
name|ecntxt
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_GET_SGE_DESC
case|:
block|{
name|struct
name|ch_desc
modifier|*
name|edesc
init|=
operator|(
expr|struct
name|ch_desc
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|edesc
operator|->
name|queue_num
operator|>=
name|SGE_QSETS
operator|*
literal|6
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ret
operator|=
name|t3_get_desc
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
name|edesc
operator|->
name|queue_num
operator|/
literal|6
index|]
argument_list|,
name|edesc
operator|->
name|queue_num
operator|%
literal|6
argument_list|,
name|edesc
operator|->
name|idx
argument_list|,
name|edesc
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|edesc
operator|->
name|size
operator|=
name|ret
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_GET_QSET_PARAMS
case|:
block|{
name|struct
name|qset_params
modifier|*
name|q
decl_stmt|;
name|struct
name|ch_qset_params
modifier|*
name|t
init|=
operator|(
expr|struct
name|ch_qset_params
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|q1
init|=
name|pi
operator|->
name|first_qset
decl_stmt|;
name|int
name|nqsets
init|=
name|pi
operator|->
name|nqsets
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|qset_idx
operator|>=
name|nqsets
condition|)
return|return
name|EINVAL
return|;
name|i
operator|=
name|q1
operator|+
name|t
operator|->
name|qset_idx
expr_stmt|;
name|q
operator|=
operator|&
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|qset
index|[
name|i
index|]
expr_stmt|;
name|t
operator|->
name|rspq_size
operator|=
name|q
operator|->
name|rspq_size
expr_stmt|;
name|t
operator|->
name|txq_size
index|[
literal|0
index|]
operator|=
name|q
operator|->
name|txq_size
index|[
literal|0
index|]
expr_stmt|;
name|t
operator|->
name|txq_size
index|[
literal|1
index|]
operator|=
name|q
operator|->
name|txq_size
index|[
literal|1
index|]
expr_stmt|;
name|t
operator|->
name|txq_size
index|[
literal|2
index|]
operator|=
name|q
operator|->
name|txq_size
index|[
literal|2
index|]
expr_stmt|;
name|t
operator|->
name|fl_size
index|[
literal|0
index|]
operator|=
name|q
operator|->
name|fl_size
expr_stmt|;
name|t
operator|->
name|fl_size
index|[
literal|1
index|]
operator|=
name|q
operator|->
name|jumbo_size
expr_stmt|;
name|t
operator|->
name|polling
operator|=
name|q
operator|->
name|polling
expr_stmt|;
name|t
operator|->
name|lro
operator|=
name|q
operator|->
name|lro
expr_stmt|;
name|t
operator|->
name|intr_lat
operator|=
name|q
operator|->
name|coalesce_usecs
expr_stmt|;
name|t
operator|->
name|cong_thres
operator|=
name|q
operator|->
name|cong_thres
expr_stmt|;
name|t
operator|->
name|qnum
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|USING_MSIX
condition|)
name|t
operator|->
name|vector
operator|=
name|rman_get_start
argument_list|(
name|sc
operator|->
name|msix_irq_res
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|t
operator|->
name|vector
operator|=
name|rman_get_start
argument_list|(
name|sc
operator|->
name|irq_res
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_GET_QSET_NUM
case|:
block|{
name|struct
name|ch_reg
modifier|*
name|edata
init|=
operator|(
expr|struct
name|ch_reg
operator|*
operator|)
name|data
decl_stmt|;
name|edata
operator|->
name|val
operator|=
name|pi
operator|->
name|nqsets
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_LOAD_FW
case|:
block|{
name|uint8_t
modifier|*
name|fw_data
decl_stmt|;
name|uint32_t
name|vers
decl_stmt|;
name|struct
name|ch_mem_range
modifier|*
name|t
init|=
operator|(
expr|struct
name|ch_mem_range
operator|*
operator|)
name|data
decl_stmt|;
comment|/* 		 * You're allowed to load a firmware only before FULL_INIT_DONE 		 * 		 * FW_UPTODATE is also set so the rest of the initialization 		 * will not overwrite what was loaded here.  This gives you the 		 * flexibility to load any firmware (and maybe shoot yourself in 		 * the foot). 		 */
name|ADAPTER_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|open_device_map
operator|||
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
condition|)
block|{
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|fw_data
operator|=
name|malloc
argument_list|(
name|t
operator|->
name|len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fw_data
condition|)
name|error
operator|=
name|ENOMEM
expr_stmt|;
else|else
name|error
operator|=
name|copyin
argument_list|(
name|t
operator|->
name|buf
argument_list|,
name|fw_data
argument_list|,
name|t
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
operator|-
name|t3_load_fw
argument_list|(
name|sc
argument_list|,
name|fw_data
argument_list|,
name|t
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|t3_get_fw_version
argument_list|(
name|sc
argument_list|,
operator|&
name|vers
argument_list|)
operator|==
literal|0
condition|)
block|{
name|snprintf
argument_list|(
operator|&
name|sc
operator|->
name|fw_version
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|fw_version
argument_list|)
argument_list|,
literal|"%d.%d.%d"
argument_list|,
name|G_FW_VERSION_MAJOR
argument_list|(
name|vers
argument_list|)
argument_list|,
name|G_FW_VERSION_MINOR
argument_list|(
name|vers
argument_list|)
argument_list|,
name|G_FW_VERSION_MICRO
argument_list|(
name|vers
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
name|sc
operator|->
name|flags
operator||=
name|FW_UPTODATE
expr_stmt|;
name|free
argument_list|(
name|fw_data
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_LOAD_BOOT
case|:
block|{
name|uint8_t
modifier|*
name|boot_data
decl_stmt|;
name|struct
name|ch_mem_range
modifier|*
name|t
init|=
operator|(
expr|struct
name|ch_mem_range
operator|*
operator|)
name|data
decl_stmt|;
name|boot_data
operator|=
name|malloc
argument_list|(
name|t
operator|->
name|len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|boot_data
condition|)
return|return
name|ENOMEM
return|;
name|error
operator|=
name|copyin
argument_list|(
name|t
operator|->
name|buf
argument_list|,
name|boot_data
argument_list|,
name|t
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
operator|-
name|t3_load_boot
argument_list|(
name|sc
argument_list|,
name|boot_data
argument_list|,
name|t
operator|->
name|len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|boot_data
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_GET_PM
case|:
block|{
name|struct
name|ch_pm
modifier|*
name|m
init|=
operator|(
expr|struct
name|ch_pm
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|tp_params
modifier|*
name|p
init|=
operator|&
name|sc
operator|->
name|params
operator|.
name|tp
decl_stmt|;
if|if
condition|(
operator|!
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|m
operator|->
name|tx_pg_sz
operator|=
name|p
operator|->
name|tx_pg_size
expr_stmt|;
name|m
operator|->
name|tx_num_pg
operator|=
name|p
operator|->
name|tx_num_pgs
expr_stmt|;
name|m
operator|->
name|rx_pg_sz
operator|=
name|p
operator|->
name|rx_pg_size
expr_stmt|;
name|m
operator|->
name|rx_num_pg
operator|=
name|p
operator|->
name|rx_num_pgs
expr_stmt|;
name|m
operator|->
name|pm_total
operator|=
name|p
operator|->
name|pmtx_size
operator|+
name|p
operator|->
name|chan_rx_size
operator|*
name|p
operator|->
name|nchan
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_SET_PM
case|:
block|{
name|struct
name|ch_pm
modifier|*
name|m
init|=
operator|(
expr|struct
name|ch_pm
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|tp_params
modifier|*
name|p
init|=
operator|&
name|sc
operator|->
name|params
operator|.
name|tp
decl_stmt|;
if|if
condition|(
operator|!
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
operator|!
name|m
operator|->
name|rx_pg_sz
operator|||
operator|(
name|m
operator|->
name|rx_pg_sz
operator|&
operator|(
name|m
operator|->
name|rx_pg_sz
operator|-
literal|1
operator|)
operator|)
operator|||
operator|!
name|m
operator|->
name|tx_pg_sz
operator|||
operator|(
name|m
operator|->
name|tx_pg_sz
operator|&
operator|(
name|m
operator|->
name|tx_pg_sz
operator|-
literal|1
operator|)
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* not power of 2 */
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|rx_pg_sz
operator|&
literal|0x14000
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* not 16KB or 64KB */
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|tx_pg_sz
operator|&
literal|0x1554000
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|m
operator|->
name|tx_num_pg
operator|==
operator|-
literal|1
condition|)
name|m
operator|->
name|tx_num_pg
operator|=
name|p
operator|->
name|tx_num_pgs
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|rx_num_pg
operator|==
operator|-
literal|1
condition|)
name|m
operator|->
name|rx_num_pg
operator|=
name|p
operator|->
name|rx_num_pgs
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|tx_num_pg
operator|%
literal|24
operator|||
name|m
operator|->
name|rx_num_pg
operator|%
literal|24
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|m
operator|->
name|rx_num_pg
operator|*
name|m
operator|->
name|rx_pg_sz
operator|>
name|p
operator|->
name|chan_rx_size
operator|||
name|m
operator|->
name|tx_num_pg
operator|*
name|m
operator|->
name|tx_pg_sz
operator|>
name|p
operator|->
name|chan_tx_size
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|p
operator|->
name|rx_pg_size
operator|=
name|m
operator|->
name|rx_pg_sz
expr_stmt|;
name|p
operator|->
name|tx_pg_size
operator|=
name|m
operator|->
name|tx_pg_sz
expr_stmt|;
name|p
operator|->
name|rx_num_pgs
operator|=
name|m
operator|->
name|rx_num_pg
expr_stmt|;
name|p
operator|->
name|tx_num_pgs
operator|=
name|m
operator|->
name|tx_num_pg
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_SETMTUTAB
case|:
block|{
name|struct
name|ch_mtus
modifier|*
name|m
init|=
operator|(
expr|struct
name|ch_mtus
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
if|if
condition|(
name|offload_running
argument_list|(
name|sc
argument_list|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
name|m
operator|->
name|nmtus
operator|!=
name|NMTUS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|m
operator|->
name|mtus
index|[
literal|0
index|]
operator|<
literal|81
condition|)
comment|/* accommodate SACK */
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 		 * MTUs must be in ascending order 		 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NMTUS
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|m
operator|->
name|mtus
index|[
name|i
index|]
operator|<
name|m
operator|->
name|mtus
index|[
name|i
operator|-
literal|1
index|]
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|memcpy
argument_list|(
name|sc
operator|->
name|params
operator|.
name|mtus
argument_list|,
name|m
operator|->
name|mtus
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|params
operator|.
name|mtus
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_GETMTUTAB
case|:
block|{
name|struct
name|ch_mtus
modifier|*
name|m
init|=
operator|(
expr|struct
name|ch_mtus
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|memcpy
argument_list|(
name|m
operator|->
name|mtus
argument_list|,
name|sc
operator|->
name|params
operator|.
name|mtus
argument_list|,
sizeof|sizeof
argument_list|(
name|m
operator|->
name|mtus
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|nmtus
operator|=
name|NMTUS
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_GET_MEM
case|:
block|{
name|struct
name|ch_mem_range
modifier|*
name|t
init|=
operator|(
expr|struct
name|ch_mem_range
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|mc7
modifier|*
name|mem
decl_stmt|;
name|uint8_t
modifier|*
name|useraddr
decl_stmt|;
name|u64
name|buf
index|[
literal|32
index|]
decl_stmt|;
comment|/* 		 * Use these to avoid modifying len/addr in the the return 		 * struct 		 */
name|uint32_t
name|len
init|=
name|t
operator|->
name|len
decl_stmt|,
name|addr
init|=
name|t
operator|->
name|addr
decl_stmt|;
if|if
condition|(
operator|!
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
operator|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* need the memory controllers */
if|if
condition|(
operator|(
name|addr
operator|&
literal|0x7
operator|)
operator|||
operator|(
name|len
operator|&
literal|0x7
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|t
operator|->
name|mem_id
operator|==
name|MEM_CM
condition|)
name|mem
operator|=
operator|&
name|sc
operator|->
name|cm
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|->
name|mem_id
operator|==
name|MEM_PMRX
condition|)
name|mem
operator|=
operator|&
name|sc
operator|->
name|pmrx
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|->
name|mem_id
operator|==
name|MEM_PMTX
condition|)
name|mem
operator|=
operator|&
name|sc
operator|->
name|pmtx
expr_stmt|;
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 		 * Version scheme: 		 * bits 0..9: chip version 		 * bits 10..15: chip revision 		 */
name|t
operator|->
name|version
operator|=
literal|3
operator||
operator|(
name|sc
operator|->
name|params
operator|.
name|rev
operator|<<
literal|10
operator|)
expr_stmt|;
comment|/* 		 * Read 256 bytes at a time as len can be large and we don't 		 * want to use huge intermediate buffers. 		 */
name|useraddr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|t
operator|->
name|buf
expr_stmt|;
while|while
condition|(
name|len
condition|)
block|{
name|unsigned
name|int
name|chunk
init|=
name|min
argument_list|(
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
decl_stmt|;
name|error
operator|=
name|t3_mc7_bd_read
argument_list|(
name|mem
argument_list|,
name|addr
operator|/
literal|8
argument_list|,
name|chunk
operator|/
literal|8
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
operator|-
name|error
operator|)
return|;
if|if
condition|(
name|copyout
argument_list|(
name|buf
argument_list|,
name|useraddr
argument_list|,
name|chunk
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|useraddr
operator|+=
name|chunk
expr_stmt|;
name|addr
operator|+=
name|chunk
expr_stmt|;
name|len
operator|-=
name|chunk
expr_stmt|;
block|}
break|break;
block|}
case|case
name|CHELSIO_READ_TCAM_WORD
case|:
block|{
name|struct
name|ch_tcam_word
modifier|*
name|t
init|=
operator|(
expr|struct
name|ch_tcam_word
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
operator|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* need MC5 */
return|return
operator|-
name|t3_read_mc5_range
argument_list|(
operator|&
name|sc
operator|->
name|mc5
argument_list|,
name|t
operator|->
name|addr
argument_list|,
literal|1
argument_list|,
name|t
operator|->
name|buf
argument_list|)
return|;
break|break;
block|}
case|case
name|CHELSIO_SET_TRACE_FILTER
case|:
block|{
name|struct
name|ch_trace
modifier|*
name|t
init|=
operator|(
expr|struct
name|ch_trace
operator|*
operator|)
name|data
decl_stmt|;
specifier|const
name|struct
name|trace_params
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
operator|(
specifier|const
expr|struct
name|trace_params
operator|*
operator|)
operator|&
name|t
operator|->
name|sip
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|config_tx
condition|)
name|t3_config_trace_filter
argument_list|(
name|sc
argument_list|,
name|tp
argument_list|,
literal|0
argument_list|,
name|t
operator|->
name|invert_match
argument_list|,
name|t
operator|->
name|trace_tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|config_rx
condition|)
name|t3_config_trace_filter
argument_list|(
name|sc
argument_list|,
name|tp
argument_list|,
literal|1
argument_list|,
name|t
operator|->
name|invert_match
argument_list|,
name|t
operator|->
name|trace_rx
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_SET_PKTSCHED
case|:
block|{
name|struct
name|ch_pktsched_params
modifier|*
name|p
init|=
operator|(
expr|struct
name|ch_pktsched_params
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|open_device_map
operator|==
literal|0
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
name|send_pktsched_cmd
argument_list|(
name|sc
argument_list|,
name|p
operator|->
name|sched
argument_list|,
name|p
operator|->
name|idx
argument_list|,
name|p
operator|->
name|min
argument_list|,
name|p
operator|->
name|max
argument_list|,
name|p
operator|->
name|binding
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_IFCONF_GETREGS
case|:
block|{
name|struct
name|ch_ifconf_regs
modifier|*
name|regs
init|=
operator|(
expr|struct
name|ch_ifconf_regs
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|reglen
init|=
name|cxgb_get_regs_len
argument_list|()
decl_stmt|;
name|uint8_t
modifier|*
name|buf
init|=
name|malloc
argument_list|(
name|reglen
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
decl_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|regs
operator|->
name|len
operator|>
name|reglen
condition|)
name|regs
operator|->
name|len
operator|=
name|reglen
expr_stmt|;
elseif|else
if|if
condition|(
name|regs
operator|->
name|len
operator|<
name|reglen
condition|)
name|error
operator|=
name|ENOBUFS
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|cxgb_get_regs
argument_list|(
name|sc
argument_list|,
name|regs
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|buf
argument_list|,
name|regs
operator|->
name|data
argument_list|,
name|reglen
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_SET_HW_SCHED
case|:
block|{
name|struct
name|ch_hw_sched
modifier|*
name|t
init|=
operator|(
expr|struct
name|ch_hw_sched
operator|*
operator|)
name|data
decl_stmt|;
name|unsigned
name|int
name|ticks_per_usec
init|=
name|core_ticks_per_usec
argument_list|(
name|sc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
comment|/* need TP to be initialized */
if|if
condition|(
name|t
operator|->
name|sched
operator|>=
name|NTX_SCHED
operator|||
operator|!
name|in_range
argument_list|(
name|t
operator|->
name|mode
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|||
operator|!
name|in_range
argument_list|(
name|t
operator|->
name|channel
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|||
operator|!
name|in_range
argument_list|(
name|t
operator|->
name|kbps
argument_list|,
literal|0
argument_list|,
literal|10000000
argument_list|)
operator|||
operator|!
name|in_range
argument_list|(
name|t
operator|->
name|class_ipg
argument_list|,
literal|0
argument_list|,
literal|10000
operator|*
literal|65535
operator|/
name|ticks_per_usec
argument_list|)
operator|||
operator|!
name|in_range
argument_list|(
name|t
operator|->
name|flow_ipg
argument_list|,
literal|0
argument_list|,
name|dack_ticks_to_usec
argument_list|(
name|sc
argument_list|,
literal|0x7ff
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|t
operator|->
name|kbps
operator|>=
literal|0
condition|)
block|{
name|error
operator|=
name|t3_config_sched
argument_list|(
name|sc
argument_list|,
name|t
operator|->
name|kbps
argument_list|,
name|t
operator|->
name|sched
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
name|error
operator|)
return|;
block|}
if|if
condition|(
name|t
operator|->
name|class_ipg
operator|>=
literal|0
condition|)
name|t3_set_sched_ipg
argument_list|(
name|sc
argument_list|,
name|t
operator|->
name|sched
argument_list|,
name|t
operator|->
name|class_ipg
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|flow_ipg
operator|>=
literal|0
condition|)
block|{
name|t
operator|->
name|flow_ipg
operator|*=
literal|1000
expr_stmt|;
comment|/* us -> ns */
name|t3_set_pace_tbl
argument_list|(
name|sc
argument_list|,
operator|&
name|t
operator|->
name|flow_ipg
argument_list|,
name|t
operator|->
name|sched
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|->
name|mode
operator|>=
literal|0
condition|)
block|{
name|int
name|bit
init|=
literal|1
operator|<<
operator|(
name|S_TX_MOD_TIMER_MODE
operator|+
name|t
operator|->
name|sched
operator|)
decl_stmt|;
name|t3_set_reg_field
argument_list|(
name|sc
argument_list|,
name|A_TP_TX_MOD_QUEUE_REQ_MAP
argument_list|,
name|bit
argument_list|,
name|t
operator|->
name|mode
condition|?
name|bit
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|->
name|channel
operator|>=
literal|0
condition|)
name|t3_set_reg_field
argument_list|(
name|sc
argument_list|,
name|A_TP_TX_MOD_QUEUE_REQ_MAP
argument_list|,
literal|1
operator|<<
name|t
operator|->
name|sched
argument_list|,
name|t
operator|->
name|channel
operator|<<
name|t
operator|->
name|sched
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_GET_EEPROM
case|:
block|{
name|int
name|i
decl_stmt|;
name|struct
name|ch_eeprom
modifier|*
name|e
init|=
operator|(
expr|struct
name|ch_eeprom
operator|*
operator|)
name|data
decl_stmt|;
name|uint8_t
modifier|*
name|buf
init|=
name|malloc
argument_list|(
name|EEPROMSIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
decl_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|e
operator|->
name|magic
operator|=
name|EEPROM_MAGIC
expr_stmt|;
for|for
control|(
name|i
operator|=
name|e
operator|->
name|offset
operator|&
operator|~
literal|3
init|;
operator|!
name|error
operator|&&
name|i
operator|<
name|e
operator|->
name|offset
operator|+
name|e
operator|->
name|len
condition|;
name|i
operator|+=
literal|4
control|)
name|error
operator|=
operator|-
name|t3_seeprom_read
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|copyout
argument_list|(
name|buf
operator|+
name|e
operator|->
name|offset
argument_list|,
name|e
operator|->
name|data
argument_list|,
name|e
operator|->
name|len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_CLEAR_STATS
case|:
block|{
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
operator|)
condition|)
return|return
name|EAGAIN
return|;
name|PORT_LOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|t3_mac_update_stats
argument_list|(
operator|&
name|pi
operator|->
name|mac
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|pi
operator|->
name|mac
operator|.
name|stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pi
operator|->
name|mac
operator|.
name|stats
argument_list|)
argument_list|)
expr_stmt|;
name|PORT_UNLOCK
argument_list|(
name|pi
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_GET_UP_LA
case|:
block|{
name|struct
name|ch_up_la
modifier|*
name|la
init|=
operator|(
expr|struct
name|ch_up_la
operator|*
operator|)
name|data
decl_stmt|;
name|uint8_t
modifier|*
name|buf
init|=
name|malloc
argument_list|(
name|LA_BUFSIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
decl_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|la
operator|->
name|bufsize
operator|<
name|LA_BUFSIZE
condition|)
name|error
operator|=
name|ENOBUFS
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
operator|-
name|t3_get_up_la
argument_list|(
name|sc
argument_list|,
operator|&
name|la
operator|->
name|stopped
argument_list|,
operator|&
name|la
operator|->
name|idx
argument_list|,
operator|&
name|la
operator|->
name|bufsize
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|copyout
argument_list|(
name|buf
argument_list|,
name|la
operator|->
name|data
argument_list|,
name|la
operator|->
name|bufsize
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_GET_UP_IOQS
case|:
block|{
name|struct
name|ch_up_ioqs
modifier|*
name|ioqs
init|=
operator|(
expr|struct
name|ch_up_ioqs
operator|*
operator|)
name|data
decl_stmt|;
name|uint8_t
modifier|*
name|buf
init|=
name|malloc
argument_list|(
name|IOQS_BUFSIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
decl_stmt|;
name|uint32_t
modifier|*
name|v
decl_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|ioqs
operator|->
name|bufsize
operator|<
name|IOQS_BUFSIZE
condition|)
name|error
operator|=
name|ENOBUFS
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
operator|-
name|t3_get_up_ioqs
argument_list|(
name|sc
argument_list|,
operator|&
name|ioqs
operator|->
name|bufsize
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|v
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|buf
expr_stmt|;
name|ioqs
operator|->
name|bufsize
operator|-=
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|ioqs
operator|->
name|ioq_rx_enable
operator|=
operator|*
name|v
operator|++
expr_stmt|;
name|ioqs
operator|->
name|ioq_tx_enable
operator|=
operator|*
name|v
operator|++
expr_stmt|;
name|ioqs
operator|->
name|ioq_rx_status
operator|=
operator|*
name|v
operator|++
expr_stmt|;
name|ioqs
operator|->
name|ioq_tx_status
operator|=
operator|*
name|v
operator|++
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|v
argument_list|,
name|ioqs
operator|->
name|data
argument_list|,
name|ioqs
operator|->
name|bufsize
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|reg_block_dump
parameter_list|(
name|struct
name|adapter
modifier|*
name|ap
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|unsigned
name|int
name|start
parameter_list|,
name|unsigned
name|int
name|end
parameter_list|)
block|{
name|uint32_t
modifier|*
name|p
init|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|buf
operator|+
name|start
operator|)
decl_stmt|;
for|for
control|(
init|;
name|start
operator|<=
name|end
condition|;
name|start
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
control|)
operator|*
name|p
operator|++
operator|=
name|t3_read_reg
argument_list|(
name|ap
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|T3_REGMAP_SIZE
value|(3 * 1024)
end_define

begin_function
specifier|static
name|int
name|cxgb_get_regs_len
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|T3_REGMAP_SIZE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_get_regs
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|,
name|struct
name|ch_ifconf_regs
modifier|*
name|regs
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|)
block|{
comment|/* 	 * Version scheme: 	 * bits 0..9: chip version 	 * bits 10..15: chip revision 	 * bit 31: set for PCIe cards 	 */
name|regs
operator|->
name|version
operator|=
literal|3
operator||
operator|(
name|sc
operator|->
name|params
operator|.
name|rev
operator|<<
literal|10
operator|)
operator||
operator|(
name|is_pcie
argument_list|(
name|sc
argument_list|)
operator|<<
literal|31
operator|)
expr_stmt|;
comment|/* 	 * We skip the MAC statistics registers because they are clear-on-read. 	 * Also reading multi-register stats would need to synchronize with the 	 * periodic mac stats accumulation.  Hard to justify the complexity. 	 */
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|cxgb_get_regs_len
argument_list|()
argument_list|)
expr_stmt|;
name|reg_block_dump
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|A_SG_RSPQ_CREDIT_RETURN
argument_list|)
expr_stmt|;
name|reg_block_dump
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|A_SG_HI_DRB_HI_THRSH
argument_list|,
name|A_ULPRX_PBL_ULIMIT
argument_list|)
expr_stmt|;
name|reg_block_dump
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|A_ULPTX_CONFIG
argument_list|,
name|A_MPS_INT_CAUSE
argument_list|)
expr_stmt|;
name|reg_block_dump
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|A_CPL_SWITCH_CNTRL
argument_list|,
name|A_CPL_MAP_TBL_DATA
argument_list|)
expr_stmt|;
name|reg_block_dump
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|A_SMB_GLOBAL_TIME_CFG
argument_list|,
name|A_XGM_SERDES_STAT3
argument_list|)
expr_stmt|;
name|reg_block_dump
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|A_XGM_SERDES_STATUS0
argument_list|,
name|XGM_REG
argument_list|(
name|A_XGM_SERDES_STAT3
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|reg_block_dump
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|XGM_REG
argument_list|(
name|A_XGM_SERDES_STATUS0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XGM_REG
argument_list|(
name|A_XGM_RX_SPI4_SOP_EOP_CNT
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|if_cxgb
argument_list|,
name|cxgb_t3fw
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

