begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************************  Copyright (c) 2007, Chelsio Inc. All rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:   1. Redistributions of source code must retain the above copyright notice,     this list of conditions and the following disclaimer.   2. Redistributions in binary form must reproduce the above copyright     notice, this list of conditions and the following disclaimer in the     documentation and/or other materials provided with the distribution.   3. Neither the name of the Chelsio Corporation nor the names of its     contributors may be used to endorse or promote products derived from     this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/pciio.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus_dma.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/firmware.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pci_private.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/cxgb_osdep.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_common.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/cxgb_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_regs.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_t3_cpl.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_firmware_exports.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PRIV_SUPPORTED
end_ifdef

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|cxgb_setup_msix
parameter_list|(
name|adapter_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgb_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgb_init_locked
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgb_stop_locked
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgb_set_rxmode
parameter_list|(
name|struct
name|port_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgb_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|unsigned
name|long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgb_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgb_start_proc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
name|ncount
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgb_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgb_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|setup_sge_qsets
parameter_list|(
name|adapter_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgb_async_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgb_ext_intr_handler
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgb_tick
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|setup_rss
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Attachment glue for the PCI controller end of the device.  Each port of  * the device is attached separately, as defined later.  */
end_comment

begin_function_decl
specifier|static
name|int
name|cxgb_controller_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgb_controller_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgb_controller_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgb_free
parameter_list|(
name|struct
name|adapter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|reg_block_dump
parameter_list|(
name|struct
name|adapter
modifier|*
name|ap
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|unsigned
name|int
name|start
parameter_list|,
name|unsigned
name|int
name|end
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxgb_get_regs
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|,
name|struct
name|ifconf_regs
modifier|*
name|regs
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgb_get_regs_len
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|cxgb_controller_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|cxgb_controller_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|cxgb_controller_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|cxgb_controller_detach
argument_list|)
block|,
comment|/* bus interface */
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|bus_generic_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_driver_added
argument_list|,
name|bus_generic_driver_added
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|cxgb_controller_driver
init|=
block|{
literal|"cxgbc"
block|,
name|cxgb_controller_methods
block|,
expr|sizeof
operator|(
expr|struct
name|adapter
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|cxgb_controller_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|cxgbc
argument_list|,
name|pci
argument_list|,
name|cxgb_controller_driver
argument_list|,
name|cxgb_controller_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Attachment glue for the ports.  Attachment is done directly to the  * controller device.  */
end_comment

begin_function_decl
specifier|static
name|int
name|cxgb_port_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgb_port_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxgb_port_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|cxgb_port_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|cxgb_port_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|cxgb_port_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|cxgb_port_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|cxgb_port_driver
init|=
block|{
literal|"cxgb"
block|,
name|cxgb_port_methods
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|cxgb_extension_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|cxgb_port_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|cxgb
argument_list|,
name|cxgbc
argument_list|,
name|cxgb_port_driver
argument_list|,
name|cxgb_port_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|SGE_MSIX_COUNT
value|(SGE_QSETS + 1)
end_define

begin_comment
comment|/*  * The driver uses the best interrupt scheme available on a platform in the  * order MSI-X, MSI, legacy pin interrupts.  This parameter determines which  * of these schemes the driver may consider as follows:  *  * msi = 2: choose from among all three options  * msi = 1 : only consider MSI and pin interrupts  * msi = 0: force pin interrupts  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|msi_allowed
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cxgb.msi_allowed"
argument_list|,
operator|&
name|msi_allowed
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|cxgb
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"CXGB driver parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_cxgb
argument_list|,
name|OID_AUTO
argument_list|,
name|msi_allowed
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|msi_allowed
argument_list|,
literal|0
argument_list|,
literal|"MSI-X, MSI, INTx selector"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_enum
enum|enum
block|{
name|MAX_TXQ_ENTRIES
init|=
literal|16384
block|,
name|MAX_CTRL_TXQ_ENTRIES
init|=
literal|1024
block|,
name|MAX_RSPQ_ENTRIES
init|=
literal|16384
block|,
name|MAX_RX_BUFFERS
init|=
literal|16384
block|,
name|MAX_RX_JUMBO_BUFFERS
init|=
literal|16384
block|,
name|MIN_TXQ_ENTRIES
init|=
literal|4
block|,
name|MIN_CTRL_TXQ_ENTRIES
init|=
literal|4
block|,
name|MIN_RSPQ_ENTRIES
init|=
literal|32
block|,
name|MIN_FL_ENTRIES
init|=
literal|32
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|PORT_MASK
value|((1<< MAX_NPORTS) - 1)
end_define

begin_comment
comment|/* Table for probing the cards.  The desc field isn't actually used */
end_comment

begin_struct
struct|struct
name|cxgb_ident
block|{
name|uint16_t
name|vendor
decl_stmt|;
name|uint16_t
name|device
decl_stmt|;
name|int
name|index
decl_stmt|;
name|char
modifier|*
name|desc
decl_stmt|;
block|}
name|cxgb_identifiers
index|[]
init|=
block|{
block|{
name|PCI_VENDOR_ID_CHELSIO
block|,
literal|0x0020
block|,
literal|0
block|,
literal|"PE9000"
block|}
block|,
block|{
name|PCI_VENDOR_ID_CHELSIO
block|,
literal|0x0021
block|,
literal|1
block|,
literal|"T302E"
block|}
block|,
block|{
name|PCI_VENDOR_ID_CHELSIO
block|,
literal|0x0022
block|,
literal|2
block|,
literal|"T310E"
block|}
block|,
block|{
name|PCI_VENDOR_ID_CHELSIO
block|,
literal|0x0023
block|,
literal|3
block|,
literal|"T320X"
block|}
block|,
block|{
name|PCI_VENDOR_ID_CHELSIO
block|,
literal|0x0024
block|,
literal|1
block|,
literal|"T302X"
block|}
block|,
block|{
name|PCI_VENDOR_ID_CHELSIO
block|,
literal|0x0025
block|,
literal|3
block|,
literal|"T320E"
block|}
block|,
block|{
name|PCI_VENDOR_ID_CHELSIO
block|,
literal|0x0026
block|,
literal|2
block|,
literal|"T310X"
block|}
block|,
block|{
name|PCI_VENDOR_ID_CHELSIO
block|,
literal|0x0030
block|,
literal|2
block|,
literal|"T3B10"
block|}
block|,
block|{
name|PCI_VENDOR_ID_CHELSIO
block|,
literal|0x0031
block|,
literal|3
block|,
literal|"T3B20"
block|}
block|,
block|{
name|PCI_VENDOR_ID_CHELSIO
block|,
literal|0x0032
block|,
literal|1
block|,
literal|"T3B02"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|struct
name|cxgb_ident
modifier|*
name|cxgb_get_ident
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|cxgb_ident
modifier|*
name|id
decl_stmt|;
for|for
control|(
name|id
operator|=
name|cxgb_identifiers
init|;
name|id
operator|->
name|desc
operator|!=
name|NULL
condition|;
name|id
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|id
operator|->
name|vendor
operator|==
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|)
operator|&&
operator|(
name|id
operator|->
name|device
operator|==
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
name|id
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|struct
name|adapter_info
modifier|*
name|cxgb_get_adapter_info
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|cxgb_ident
modifier|*
name|id
decl_stmt|;
specifier|const
name|struct
name|adapter_info
modifier|*
name|ai
decl_stmt|;
name|id
operator|=
name|cxgb_get_ident
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ai
operator|=
name|t3_get_adapter_info
argument_list|(
name|id
operator|->
name|index
argument_list|)
expr_stmt|;
return|return
operator|(
name|ai
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_controller_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
specifier|const
name|struct
name|adapter_info
modifier|*
name|ai
decl_stmt|;
name|char
modifier|*
name|ports
decl_stmt|,
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|ai
operator|=
name|cxgb_get_adapter_info
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|ai
operator|->
name|nports
operator|==
literal|1
condition|)
name|ports
operator|=
literal|"port"
expr_stmt|;
else|else
name|ports
operator|=
literal|"ports"
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s RNIC, %d %s"
argument_list|,
name|ai
operator|->
name|desc
argument_list|,
name|ai
operator|->
name|nports
argument_list|,
name|ports
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_fw_download
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|FIRMWARE_LATEST
specifier|const
name|struct
name|firmware
modifier|*
name|fw
decl_stmt|;
else|#
directive|else
name|struct
name|firmware
modifier|*
name|fw
decl_stmt|;
endif|#
directive|endif
name|int
name|status
decl_stmt|;
name|snprintf
argument_list|(
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"t3fw%d%d"
argument_list|,
name|FW_VERSION_MAJOR
argument_list|,
name|FW_VERSION_MINOR
argument_list|)
expr_stmt|;
name|fw
operator|=
name|firmware_get
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not find firmware image %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|ENOENT
return|;
block|}
name|status
operator|=
name|t3_load_fw
argument_list|(
name|sc
argument_list|,
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|fw
operator|->
name|data
argument_list|,
name|fw
operator|->
name|datasize
argument_list|)
expr_stmt|;
name|firmware_put
argument_list|(
name|fw
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_controller_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|driver_intr_t
modifier|*
name|cxgb_intr
init|=
name|NULL
decl_stmt|;
name|device_t
name|child
decl_stmt|;
specifier|const
name|struct
name|adapter_info
modifier|*
name|ai
decl_stmt|;
name|struct
name|adapter
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|msi_needed
decl_stmt|,
name|msi_count
init|=
literal|0
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|uint32_t
name|vers
decl_stmt|;
name|int
name|port_qsets
init|=
literal|1
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate the registers and make them available to the driver. 	 * The registers that we care about for NIC mode are in BAR 0 	 */
name|sc
operator|->
name|regs_rid
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|regs_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|regs_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot allocate BAR\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|reg_lock
argument_list|,
literal|"SGE reg lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|,
literal|"cxgb controller lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|mdio_lock
argument_list|,
literal|"cxgb mdio"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bt
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|regs_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|regs_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mmio_len
operator|=
name|rman_get_size
argument_list|(
name|sc
operator|->
name|regs_res
argument_list|)
expr_stmt|;
comment|/* Allocate the BAR for doing MSI-X.  If it succeeds, try to allocate 	 * enough messages for the queue sets.  If that fails, try falling 	 * back to MSI.  If that fails, then try falling back to the legacy 	 * interrupt pin model. 	 */
ifdef|#
directive|ifdef
name|MSI_SUPPORTED
name|sc
operator|->
name|msix_regs_rid
operator|=
literal|0x20
expr_stmt|;
if|if
condition|(
operator|(
name|msi_allowed
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|sc
operator|->
name|msix_regs_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|msix_regs_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|msi_needed
operator|=
name|msi_count
operator|=
name|SGE_MSIX_COUNT
expr_stmt|;
if|if
condition|(
operator|(
name|pci_alloc_msix
argument_list|(
name|dev
argument_list|,
operator|&
name|msi_count
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|msi_count
operator|!=
name|msi_needed
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"msix allocation failed"
literal|" will try msi\n"
argument_list|)
expr_stmt|;
name|msi_count
operator|=
literal|0
expr_stmt|;
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|msix_regs_rid
argument_list|,
name|sc
operator|->
name|msix_regs_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msix_regs_res
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|flags
operator||=
name|USING_MSIX
expr_stmt|;
name|cxgb_intr
operator|=
name|t3_intr_msix
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|msi_allowed
operator|>=
literal|1
operator|)
operator|&&
operator|(
name|msi_count
operator|==
literal|0
operator|)
condition|)
block|{
name|msi_count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pci_alloc_msi
argument_list|(
name|dev
argument_list|,
operator|&
name|msi_count
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"alloc msi failed - will try INTx\n"
argument_list|)
expr_stmt|;
name|msi_count
operator|=
literal|0
expr_stmt|;
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|flags
operator||=
name|USING_MSI
expr_stmt|;
name|sc
operator|->
name|irq_rid
operator|=
literal|1
expr_stmt|;
name|cxgb_intr
operator|=
name|t3_intr_msi
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|msi_count
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"using line interrupts\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq_rid
operator|=
literal|0
expr_stmt|;
name|cxgb_intr
operator|=
name|t3b_intr
expr_stmt|;
block|}
comment|/* Create a private taskqueue thread for handling driver events */
ifdef|#
directive|ifdef
name|TASKQUEUE_CURRENT
name|sc
operator|->
name|tq
operator|=
name|taskqueue_create
argument_list|(
literal|"cxgb_taskq"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|sc
operator|->
name|tq
argument_list|)
expr_stmt|;
else|#
directive|else
name|sc
operator|->
name|tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"cxgb_taskq"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|sc
operator|->
name|tq
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|tq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to allocate controller task queue\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|taskqueue_start_threads
argument_list|(
operator|&
name|sc
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s taskq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|ext_intr_task
argument_list|,
literal|0
argument_list|,
name|cxgb_ext_intr_handler
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* Create a periodic callout for checking adapter status */
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|cxgb_tick_ch
argument_list|,
operator|&
name|sc
operator|->
name|lock
argument_list|,
name|CALLOUT_RETURNUNLOCKED
argument_list|)
expr_stmt|;
name|ai
operator|=
name|cxgb_get_adapter_info
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|t3_prep_adapter
argument_list|(
name|sc
argument_list|,
name|ai
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|t3_check_fw_version
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Warn user that a firmware update will be attempted in init. 		 */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"firmware needs to be updated to version %d.%d\n"
argument_list|,
name|FW_VERSION_MAJOR
argument_list|,
name|FW_VERSION_MINOR
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator|&=
operator|~
name|FW_UPTODATE
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|flags
operator||=
name|FW_UPTODATE
expr_stmt|;
block|}
if|if
condition|(
name|t3_init_hw
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"hw initialization failed\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|A_ULPRX_TDDP_PSZ
argument_list|,
name|V_HPZ0
argument_list|(
name|PAGE_SHIFT
operator|-
literal|12
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|USING_MSIX
condition|)
name|port_qsets
operator|=
name|min
argument_list|(
operator|(
name|SGE_QSETS
operator|/
operator|(
name|sc
operator|)
operator|->
name|params
operator|.
name|nports
operator|)
argument_list|,
name|mp_ncpus
argument_list|)
expr_stmt|;
comment|/* 	 * Create a child device for each MAC.  The ethernet attachment 	 * will be done in these children. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|sc
operator|)
operator|->
name|params
operator|.
name|nports
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|child
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"cxgb"
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to add child port\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|sc
operator|->
name|portdev
index|[
name|i
index|]
operator|=
name|child
expr_stmt|;
name|sc
operator|->
name|port
index|[
name|i
index|]
operator|.
name|adapter
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|port
index|[
name|i
index|]
operator|.
name|nqsets
operator|=
name|port_qsets
expr_stmt|;
name|sc
operator|->
name|port
index|[
name|i
index|]
operator|.
name|first_qset
operator|=
name|i
operator|*
name|port_qsets
expr_stmt|;
name|sc
operator|->
name|port
index|[
name|i
index|]
operator|.
name|port
operator|=
name|i
expr_stmt|;
name|device_set_softc
argument_list|(
name|child
argument_list|,
operator|&
name|sc
operator|->
name|port
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
empty_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|setup_sge_qsets
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|setup_rss
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* If it's MSI or INTx, allocate a single interrupt for everything */
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|USING_MSIX
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|irq_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|irq_rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot allocate interrupt rid=%d\n"
argument_list|,
name|sc
operator|->
name|irq_rid
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"allocated irq_res=%p\n"
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|INTR_MPSAFE
operator||
name|INTR_TYPE_NET
argument_list|,
ifdef|#
directive|ifdef
name|INTR_FILTERS
name|NULL
argument_list|,
endif|#
directive|endif
name|cxgb_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|intr_tag
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot set up interrupt\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
name|cxgb_setup_msix
argument_list|(
name|sc
argument_list|,
name|msi_count
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|params
operator|.
name|stats_update_period
operator|=
literal|1
expr_stmt|;
comment|/* initialize sge private state */
name|t3_sge_init_sw
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|t3_led_ready
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|t3_get_fw_version
argument_list|(
name|sc
argument_list|,
operator|&
name|vers
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|snprintf
argument_list|(
operator|&
name|sc
operator|->
name|fw_version
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|fw_version
argument_list|)
argument_list|,
literal|"%d.%d"
argument_list|,
name|G_FW_VERSION_MAJOR
argument_list|(
name|vers
argument_list|)
argument_list|,
name|G_FW_VERSION_MINOR
argument_list|(
name|vers
argument_list|)
argument_list|)
expr_stmt|;
name|t3_add_sysctls
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|error
condition|)
name|cxgb_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_controller_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|adapter
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|cxgb_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_free
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|cxgb_tick_ch
argument_list|)
expr_stmt|;
name|t3_sge_deinit_sw
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tq
operator|!=
name|NULL
condition|)
block|{
name|taskqueue_drain
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|sc
operator|->
name|ext_intr_task
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|sc
operator|->
name|tq
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|sc
operator|)
operator|->
name|params
operator|.
name|nports
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|portdev
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|device_delete_child
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|portdev
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|bus_generic_detach
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|t3_free_sge_resources
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|t3_sge_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SGE_QSETS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|msix_intr_tag
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|msix_irq_res
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|msix_intr_tag
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|msix_irq_res
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|msix_irq_rid
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|msix_irq_res
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|intr_tag
operator|!=
name|NULL
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|sc
operator|->
name|intr_tag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|irq_res
operator|!=
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"de-allocating interrupt irq_rid=%d irq_res=%p\n"
argument_list|,
name|sc
operator|->
name|irq_rid
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irq_rid
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MSI_SUPPORTED
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
operator|(
name|USING_MSI
operator||
name|USING_MSIX
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"releasing msi message(s)\n"
argument_list|)
expr_stmt|;
name|pci_release_msi
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|msix_regs_res
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|msix_regs_rid
argument_list|,
name|sc
operator|->
name|msix_regs_res
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|regs_res
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|regs_rid
argument_list|,
name|sc
operator|->
name|regs_res
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|mdio_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**  *	setup_sge_qsets - configure SGE Tx/Rx/response queues  *	@sc: the controller softc  *  *	Determines how many sets of SGE queues to use and initializes them.  *	We support multiple queue sets per port if we have MSI-X, otherwise  *	just one queue set per port.  */
end_comment

begin_function
specifier|static
name|int
name|setup_sge_qsets
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|err
decl_stmt|,
name|irq_idx
decl_stmt|,
name|qset_idx
decl_stmt|;
name|u_int
name|ntxq
init|=
literal|3
decl_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|t3_sge_alloc
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"t3_sge_alloc returned %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|params
operator|.
name|rev
operator|>
literal|0
operator|&&
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|USING_MSI
operator|)
condition|)
name|irq_idx
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|irq_idx
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|qset_idx
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|sc
operator|)
operator|->
name|params
operator|.
name|nports
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
operator|&
name|sc
operator|->
name|port
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pi
operator|->
name|nqsets
condition|;
operator|++
name|j
operator|,
operator|++
name|qset_idx
control|)
block|{
name|err
operator|=
name|t3_sge_alloc_qset
argument_list|(
name|sc
argument_list|,
name|qset_idx
argument_list|,
operator|(
name|sc
operator|)
operator|->
name|params
operator|.
name|nports
argument_list|,
operator|(
name|sc
operator|->
name|flags
operator|&
name|USING_MSIX
operator|)
condition|?
name|qset_idx
operator|+
literal|1
else|:
name|irq_idx
argument_list|,
operator|&
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|qset
index|[
name|qset_idx
index|]
argument_list|,
name|ntxq
argument_list|,
name|pi
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|t3_free_sge_resources
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"t3_sge_alloc_qset failed with %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_setup_msix
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|,
name|int
name|msix_count
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|nqsets
decl_stmt|,
name|rid
decl_stmt|;
comment|/* The first message indicates link changes and error conditions */
name|sc
operator|->
name|irq_rid
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|irq_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|irq_rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot allocate msix interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|INTR_MPSAFE
operator||
name|INTR_TYPE_NET
argument_list|,
ifdef|#
directive|ifdef
name|INTR_FILTERS
name|NULL
argument_list|,
endif|#
directive|endif
name|cxgb_async_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|intr_tag
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot set up interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|k
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|sc
operator|)
operator|->
name|params
operator|.
name|nports
condition|;
operator|++
name|i
control|)
block|{
name|nqsets
operator|=
name|sc
operator|->
name|port
index|[
name|i
index|]
operator|.
name|nqsets
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nqsets
condition|;
operator|++
name|j
operator|,
name|k
operator|++
control|)
block|{
name|struct
name|sge_qset
modifier|*
name|qs
init|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
name|k
index|]
decl_stmt|;
name|rid
operator|=
name|k
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|cxgb_debug
condition|)
name|printf
argument_list|(
literal|"rid=%d "
argument_list|,
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|msix_irq_res
index|[
name|k
index|]
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot allocate "
literal|"interrupt for message %d\n"
argument_list|,
name|rid
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|sc
operator|->
name|msix_irq_rid
index|[
name|k
index|]
operator|=
name|rid
expr_stmt|;
if|if
condition|(
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|msix_irq_res
index|[
name|j
index|]
argument_list|,
name|INTR_MPSAFE
operator||
name|INTR_TYPE_NET
argument_list|,
ifdef|#
directive|ifdef
name|INTR_FILTERS
name|NULL
argument_list|,
endif|#
directive|endif
name|t3_intr_msix
argument_list|,
name|qs
argument_list|,
operator|&
name|sc
operator|->
name|msix_intr_tag
index|[
name|k
index|]
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot set up "
literal|"interrupt for message %d\n"
argument_list|,
name|rid
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_port_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|p
decl_stmt|;
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|p
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"Port %d %s"
argument_list|,
name|p
operator|->
name|port
argument_list|,
name|p
operator|->
name|port_type
operator|->
name|desc
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_makedev
parameter_list|(
name|struct
name|port_info
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|cdevsw
modifier|*
name|cxgb_cdevsw
decl_stmt|;
if|if
condition|(
operator|(
name|cxgb_cdevsw
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cdevsw
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|cxgb_cdevsw
operator|->
name|d_version
operator|=
name|D_VERSION
expr_stmt|;
name|cxgb_cdevsw
operator|->
name|d_name
operator|=
name|strdup
argument_list|(
name|pi
operator|->
name|ifp
operator|->
name|if_xname
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|cxgb_cdevsw
operator|->
name|d_ioctl
operator|=
name|cxgb_extension_ioctl
expr_stmt|;
name|pi
operator|->
name|port_cdev
operator|=
name|make_dev
argument_list|(
name|cxgb_cdevsw
argument_list|,
literal|0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
name|pi
operator|->
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|port_cdev
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|pi
operator|->
name|port_cdev
operator|->
name|si_drv1
operator|=
operator|(
name|void
operator|*
operator|)
name|pi
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TSO_SUPPORTED
end_ifdef

begin_define
define|#
directive|define
name|CXGB_CAP
value|(IFCAP_VLAN_HWTAGGING | IFCAP_VLAN_MTU | IFCAP_HWCSUM | IFCAP_VLAN_HWCSUM | IFCAP_TSO | IFCAP_JUMBO_MTU)
end_define

begin_comment
comment|/* Don't enable TSO6 yet */
end_comment

begin_define
define|#
directive|define
name|CXGB_CAP_ENABLE
value|(IFCAP_VLAN_HWTAGGING | IFCAP_VLAN_MTU | IFCAP_HWCSUM | IFCAP_VLAN_HWCSUM | IFCAP_TSO4 | IFCAP_JUMBO_MTU)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CXGB_CAP
value|(IFCAP_VLAN_HWTAGGING | IFCAP_VLAN_MTU | IFCAP_HWCSUM | IFCAP_JUMBO_MTU)
end_define

begin_comment
comment|/* Don't enable TSO6 yet */
end_comment

begin_define
define|#
directive|define
name|CXGB_CAP_ENABLE
value|(IFCAP_VLAN_HWTAGGING | IFCAP_VLAN_MTU | IFCAP_HWCSUM |  IFCAP_JUMBO_MTU)
end_define

begin_define
define|#
directive|define
name|IFCAP_TSO4
value|0x0
end_define

begin_define
define|#
directive|define
name|CSUM_TSO
value|0x0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|cxgb_port_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|p
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|media_flags
decl_stmt|;
name|int
name|err
decl_stmt|;
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|p
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"cxgb port %d"
argument_list|,
name|p
operator|->
name|port
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|p
operator|->
name|lock
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* Allocate an ifnet object and set it up */
name|ifp
operator|=
name|p
operator|->
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot allocate ifnet\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* 	 * Note that there is currently no watchdog timer. 	 */
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|cxgb_init
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|p
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|cxgb_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|cxgb_start
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
comment|/* Disable ifnet watchdog */
name|ifp
operator|->
name|if_watchdog
operator|=
name|NULL
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|TX_ETH_Q_SIZE
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
argument_list|)
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|=
name|ifp
operator|->
name|if_capabilities
operator|=
name|ifp
operator|->
name|if_capenable
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|CXGB_CAP
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator||=
name|CXGB_CAP_ENABLE
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator||=
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator||
name|CSUM_IP
operator||
name|CSUM_TSO
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_baudrate
operator|=
literal|100000000
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|p
operator|->
name|hw_addr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEFAULT_JUMBO
name|ifp
operator|->
name|if_mtu
operator|=
literal|9000
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|err
operator|=
name|cxgb_makedev
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"makedev failed %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|ifmedia_init
argument_list|(
operator|&
name|p
operator|->
name|media
argument_list|,
name|IFM_IMASK
argument_list|,
name|cxgb_media_change
argument_list|,
name|cxgb_media_status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
operator|->
name|port_type
operator|->
name|desc
argument_list|,
literal|"10GBASE-CX4"
argument_list|)
condition|)
name|media_flags
operator|=
name|IFM_ETHER
operator||
name|IFM_10G_CX4
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
operator|->
name|port_type
operator|->
name|desc
argument_list|,
literal|"10GBASE-SR"
argument_list|)
condition|)
name|media_flags
operator|=
name|IFM_ETHER
operator||
name|IFM_10G_SR
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
operator|->
name|port_type
operator|->
name|desc
argument_list|,
literal|"10GBASE-XR"
argument_list|)
condition|)
name|media_flags
operator|=
name|IFM_ETHER
operator||
name|IFM_10G_LR
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"unsupported media type %s\n"
argument_list|,
name|p
operator|->
name|port_type
operator|->
name|desc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|ifmedia_add
argument_list|(
operator|&
name|p
operator|->
name|media
argument_list|,
name|media_flags
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|p
operator|->
name|media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|p
operator|->
name|media
argument_list|,
name|media_flags
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"cxgb_port_taskq%d"
argument_list|,
name|p
operator|->
name|port
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TASKQUEUE_CURRENT
comment|/* Create a port for handling TX without starvation */
name|p
operator|->
name|tq
operator|=
name|taskqueue_create
argument_list|(
name|buf
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|p
operator|->
name|tq
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Create a port for handling TX without starvation */
name|p
operator|->
name|tq
operator|=
name|taskqueue_create_fast
argument_list|(
name|buf
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|p
operator|->
name|tq
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p
operator|->
name|tq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to allocate port task queue\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|taskqueue_start_threads
argument_list|(
operator|&
name|p
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s taskq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|p
operator|->
name|start_task
argument_list|,
literal|0
argument_list|,
name|cxgb_start_proc
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_port_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|p
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|tq
operator|!=
name|NULL
condition|)
block|{
name|taskqueue_drain
argument_list|(
name|p
operator|->
name|tq
argument_list|,
operator|&
name|p
operator|->
name|start_task
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|p
operator|->
name|tq
argument_list|)
expr_stmt|;
name|p
operator|->
name|tq
operator|=
name|NULL
expr_stmt|;
block|}
name|ether_ifdetach
argument_list|(
name|p
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|p
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|destroy_dev
argument_list|(
name|p
operator|->
name|port_cdev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|t3_fatal_err
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|u_int
name|fw_status
index|[
literal|4
index|]
decl_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"encountered fatal error, operation suspended\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t3_cim_ctl_blk_read
argument_list|(
name|sc
argument_list|,
literal|0xa0
argument_list|,
literal|4
argument_list|,
name|fw_status
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"FW_ status: 0x%x, 0x%x, 0x%x, 0x%x\n"
argument_list|,
name|fw_status
index|[
literal|0
index|]
argument_list|,
name|fw_status
index|[
literal|1
index|]
argument_list|,
name|fw_status
index|[
literal|2
index|]
argument_list|,
name|fw_status
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|t3_os_find_pci_capability
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|,
name|int
name|cap
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|pcicfgregs
modifier|*
name|cfg
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|uint8_t
name|ptr
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|cfg
operator|=
operator|&
name|dinfo
operator|->
name|cfg
expr_stmt|;
name|status
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_STATUS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|PCIM_STATUS_CAPPRESENT
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|cfg
operator|->
name|hdrtype
operator|&
name|PCIM_HDRTYPE
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
name|ptr
operator|=
name|PCIR_CAP_PTR
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|ptr
operator|=
name|PCIR_CAP_PTR_2
expr_stmt|;
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
break|break;
block|}
name|ptr
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|ptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|ptr
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|ptr
operator|+
name|PCICAP_ID
argument_list|,
literal|1
argument_list|)
operator|==
name|cap
condition|)
return|return
operator|(
name|ptr
operator|)
return|;
name|ptr
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|ptr
operator|+
name|PCICAP_NEXTPTR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t3_os_pci_save_state
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_cfg_save
argument_list|(
name|dev
argument_list|,
name|dinfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|t3_os_pci_restore_state
parameter_list|(
name|struct
name|adapter
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_cfg_restore
argument_list|(
name|dev
argument_list|,
name|dinfo
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	t3_os_link_changed - handle link status changes  *	@adapter: the adapter associated with the link change  *	@port_id: the port index whose limk status has changed  *	@link_stat: the new status of the link  *	@speed: the new speed setting  *	@duplex: the new duplex setting  *	@fc: the new flow-control setting  *  *	This is the OS-dependent handler for link status changes.  The OS  *	neutral handler takes care of most of the processing for these events,  *	then calls this handler for any OS-specific processing.  */
end_comment

begin_function
name|void
name|t3_os_link_changed
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|port_id
parameter_list|,
name|int
name|link_status
parameter_list|,
name|int
name|speed
parameter_list|,
name|int
name|duplex
parameter_list|,
name|int
name|fc
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
operator|&
name|adapter
operator|->
name|port
index|[
name|port_id
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|pi
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|link_status
condition|)
name|if_link_state_change
argument_list|(
name|pi
operator|->
name|ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
else|else
name|if_link_state_change
argument_list|(
name|pi
operator|->
name|ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Interrupt-context handler for external (PHY) interrupts.  */
end_comment

begin_function
name|void
name|t3_os_ext_intr_handler
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|cxgb_debug
condition|)
name|printf
argument_list|(
literal|"t3_os_ext_intr_handler\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Schedule a task to handle external interrupts as they may be slow 	 * and we use a mutex to protect MDIO registers.  We disable PHY 	 * interrupts in the meantime and let the task reenable them when 	 * it's done. 	 */
if|if
condition|(
name|sc
operator|->
name|slow_intr_mask
condition|)
block|{
name|sc
operator|->
name|slow_intr_mask
operator|&=
operator|~
name|F_T3DBG
expr_stmt|;
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|A_PL_INT_ENABLE0
argument_list|,
name|sc
operator|->
name|slow_intr_mask
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|sc
operator|->
name|ext_intr_task
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|t3_os_set_hw_addr
parameter_list|(
name|adapter_t
modifier|*
name|adapter
parameter_list|,
name|int
name|port_idx
parameter_list|,
name|u8
name|hw_addr
index|[]
parameter_list|)
block|{
comment|/* 	 * The ifnet might not be allocated before this gets called, 	 * as this is called early on in attach by t3_prep_adapter 	 * save the address off in the port structure 	 */
if|if
condition|(
name|cxgb_debug
condition|)
name|printf
argument_list|(
literal|"set_hw_addr on idx %d addr %6D\n"
argument_list|,
name|port_idx
argument_list|,
name|hw_addr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|hw_addr
argument_list|,
name|adapter
operator|->
name|port
index|[
name|port_idx
index|]
operator|.
name|hw_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	link_start - enable a port  *	@p: the port to enable  *  *	Performs the MAC and PHY actions needed to enable a port.  */
end_comment

begin_function
specifier|static
name|void
name|cxgb_link_start
parameter_list|(
name|struct
name|port_info
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|t3_rx_mode
name|rm
decl_stmt|;
name|struct
name|cmac
modifier|*
name|mac
init|=
operator|&
name|p
operator|->
name|mac
decl_stmt|;
name|ifp
operator|=
name|p
operator|->
name|ifp
expr_stmt|;
name|t3_init_rx_mode
argument_list|(
operator|&
name|rm
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|t3_mac_reset
argument_list|(
name|mac
argument_list|)
expr_stmt|;
name|t3_mac_set_mtu
argument_list|(
name|mac
argument_list|,
name|ifp
operator|->
name|if_mtu
argument_list|)
expr_stmt|;
name|t3_mac_set_address
argument_list|(
name|mac
argument_list|,
literal|0
argument_list|,
name|p
operator|->
name|hw_addr
argument_list|)
expr_stmt|;
name|t3_mac_set_rx_mode
argument_list|(
name|mac
argument_list|,
operator|&
name|rm
argument_list|)
expr_stmt|;
name|t3_link_start
argument_list|(
operator|&
name|p
operator|->
name|phy
argument_list|,
name|mac
argument_list|,
operator|&
name|p
operator|->
name|link_config
argument_list|)
expr_stmt|;
name|t3_mac_enable
argument_list|(
name|mac
argument_list|,
name|MAC_DIRECTION_RX
operator||
name|MAC_DIRECTION_TX
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	setup_rss - configure Receive Side Steering (per-queue connection demux)   *	@adap: the adapter  *  *	Sets up RSS to distribute packets to multiple receive queues.  We  *	configure the RSS CPU lookup table to distribute to the number of HW  *	receive queues, and the response queue lookup table to narrow that  *	down to the response queues actually configured for each port.  *	We always configure the RSS mapping for two ports since the mapping  *	table has plenty of entries.  */
end_comment

begin_function
specifier|static
name|void
name|setup_rss
parameter_list|(
name|adapter_t
modifier|*
name|adap
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int
name|nq0
init|=
name|adap
operator|->
name|port
index|[
literal|0
index|]
operator|.
name|nqsets
decl_stmt|;
name|u_int
name|nq1
init|=
name|max
argument_list|(
operator|(
name|u_int
operator|)
name|adap
operator|->
name|port
index|[
literal|1
index|]
operator|.
name|nqsets
argument_list|,
literal|1U
argument_list|)
decl_stmt|;
name|uint8_t
name|cpus
index|[
name|SGE_QSETS
operator|+
literal|1
index|]
decl_stmt|;
name|uint16_t
name|rspq_map
index|[
name|RSS_TABLE_SIZE
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SGE_QSETS
condition|;
operator|++
name|i
control|)
name|cpus
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|cpus
index|[
name|SGE_QSETS
index|]
operator|=
literal|0xff
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RSS_TABLE_SIZE
operator|/
literal|2
condition|;
operator|++
name|i
control|)
block|{
name|rspq_map
index|[
name|i
index|]
operator|=
name|i
operator|%
name|nq0
expr_stmt|;
name|rspq_map
index|[
name|i
operator|+
name|RSS_TABLE_SIZE
operator|/
literal|2
index|]
operator|=
operator|(
name|i
operator|%
name|nq1
operator|)
operator|+
name|nq0
expr_stmt|;
block|}
name|t3_config_rss
argument_list|(
name|adap
argument_list|,
name|F_RQFEEDBACKENABLE
operator||
name|F_TNLLKPEN
operator||
name|F_TNLMAPEN
operator||
name|F_TNLPRTEN
operator||
name|F_TNL2TUPEN
operator||
name|F_TNL4TUPEN
operator||
name|V_RRCPLCPUSIZE
argument_list|(
literal|6
argument_list|)
argument_list|,
name|cpus
argument_list|,
name|rspq_map
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|send_pktsched_cmd
parameter_list|(
name|struct
name|adapter
modifier|*
name|adap
parameter_list|,
name|int
name|sched
parameter_list|,
name|int
name|qidx
parameter_list|,
name|int
name|lo
parameter_list|,
name|int
name|hi
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|mngt_pktsched_wr
modifier|*
name|req
decl_stmt|;
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|req
operator|=
operator|(
expr|struct
name|mngt_pktsched_wr
operator|*
operator|)
name|m
operator|->
name|m_data
expr_stmt|;
name|req
operator|->
name|wr_hi
operator|=
name|htonl
argument_list|(
name|V_WR_OP
argument_list|(
name|FW_WROPCODE_MNGT
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|mngt_opcode
operator|=
name|FW_MNGTOPCODE_PKTSCHED_SET
expr_stmt|;
name|req
operator|->
name|sched
operator|=
name|sched
expr_stmt|;
name|req
operator|->
name|idx
operator|=
name|qidx
expr_stmt|;
name|req
operator|->
name|min
operator|=
name|lo
expr_stmt|;
name|req
operator|->
name|max
operator|=
name|hi
expr_stmt|;
name|req
operator|->
name|binding
operator|=
name|port
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|req
argument_list|)
expr_stmt|;
name|t3_mgmt_tx
argument_list|(
name|adap
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bind_qsets
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|sc
operator|)
operator|->
name|params
operator|.
name|nports
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|struct
name|port_info
modifier|*
name|pi
init|=
name|adap2pinfo
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pi
operator|->
name|nqsets
condition|;
operator|++
name|j
control|)
name|send_pktsched_cmd
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|,
name|pi
operator|->
name|first_qset
operator|+
name|j
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|p
init|=
name|arg
decl_stmt|;
name|PORT_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|cxgb_init_locked
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|PORT_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_init_locked
parameter_list|(
name|struct
name|port_info
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|adapter_t
modifier|*
name|sc
init|=
name|p
operator|->
name|adapter
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|p
operator|->
name|lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|p
operator|->
name|ifp
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|FW_UPTODATE
operator|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"updating firmware to version %d.%d\n"
argument_list|,
name|FW_VERSION_MAJOR
argument_list|,
name|FW_VERSION_MINOR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|cxgb_fw_download
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|dev
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"firmware download failed err: %d"
literal|"interface will be unavailable\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|flags
operator||=
name|FW_UPTODATE
expr_stmt|;
block|}
name|cxgb_link_start
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ADAPTER_LOCK
argument_list|(
name|p
operator|->
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|adapter
operator|->
name|open_device_map
operator|==
literal|0
condition|)
name|t3_intr_clear
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|t3_sge_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|p
operator|->
name|adapter
operator|->
name|open_device_map
operator||=
operator|(
literal|1
operator|<<
name|p
operator|->
name|port
operator|)
expr_stmt|;
name|ADAPTER_UNLOCK
argument_list|(
name|p
operator|->
name|adapter
argument_list|)
expr_stmt|;
name|t3_intr_enable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|t3_port_intr_enable
argument_list|(
name|sc
argument_list|,
name|p
operator|->
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|adapter
operator|->
name|flags
operator|&
operator|(
name|USING_MSIX
operator||
name|QUEUES_BOUND
operator|)
operator|)
operator|==
name|USING_MSIX
condition|)
name|bind_qsets
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|p
operator|->
name|adapter
operator|->
name|flags
operator||=
name|QUEUES_BOUND
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|cxgb_tick_ch
argument_list|,
name|sc
operator|->
name|params
operator|.
name|stats_update_period
operator|*
name|hz
argument_list|,
name|cxgb_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_set_rxmode
parameter_list|(
name|struct
name|port_info
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|t3_rx_mode
name|rm
decl_stmt|;
name|struct
name|cmac
modifier|*
name|mac
init|=
operator|&
name|p
operator|->
name|mac
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|p
operator|->
name|lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|t3_init_rx_mode
argument_list|(
operator|&
name|rm
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|t3_mac_set_rx_mode
argument_list|(
name|mac
argument_list|,
operator|&
name|rm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_stop_locked
parameter_list|(
name|struct
name|port_info
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|p
operator|->
name|lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|p
operator|->
name|adapter
operator|->
name|lock
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|p
operator|->
name|ifp
expr_stmt|;
name|ADAPTER_LOCK
argument_list|(
name|p
operator|->
name|adapter
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
name|p
operator|->
name|adapter
operator|->
name|open_device_map
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|p
operator|->
name|port
operator|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|adapter
operator|->
name|open_device_map
operator|==
literal|0
condition|)
name|t3_intr_disable
argument_list|(
name|p
operator|->
name|adapter
argument_list|)
expr_stmt|;
name|ADAPTER_UNLOCK
argument_list|(
name|p
operator|->
name|adapter
argument_list|)
expr_stmt|;
name|t3_port_intr_disable
argument_list|(
name|p
operator|->
name|adapter
argument_list|,
name|p
operator|->
name|port
argument_list|)
expr_stmt|;
name|t3_mac_disable
argument_list|(
operator|&
name|p
operator|->
name|mac
argument_list|,
name|MAC_DIRECTION_TX
operator||
name|MAC_DIRECTION_RX
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|unsigned
name|long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|p
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFMTU
case|:
if|if
condition|(
operator|(
name|ifr
operator|->
name|ifr_mtu
operator|<
name|ETHERMIN
operator|)
operator|||
operator|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|ETHER_MAX_LEN_JUMBO
operator|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_mtu
operator|!=
name|ifr
operator|->
name|ifr_mtu
condition|)
block|{
name|PORT_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
name|t3_mac_set_mtu
argument_list|(
operator|&
name|p
operator|->
name|mac
argument_list|,
name|ifp
operator|->
name|if_mtu
argument_list|)
expr_stmt|;
name|PORT_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|cxgb_init
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|arp_ifinit
argument_list|(
name|ifp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
name|PORT_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|flags
operator|=
name|p
operator|->
name|if_flags
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|^
name|flags
operator|)
operator|&
name|IFF_PROMISC
operator|)
operator|||
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|^
name|flags
operator|)
operator|&
name|IFF_ALLMULTI
operator|)
condition|)
name|cxgb_set_rxmode
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
name|cxgb_init_locked
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|PORT_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|callout_drain
argument_list|(
operator|&
name|p
operator|->
name|adapter
operator|->
name|cxgb_tick_ch
argument_list|)
expr_stmt|;
name|PORT_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|cxgb_stop_locked
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|adapter_t
modifier|*
name|sc
init|=
name|p
operator|->
name|adapter
decl_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|cxgb_tick_ch
argument_list|,
name|sc
operator|->
name|params
operator|.
name|stats_update_period
operator|*
name|hz
argument_list|,
name|cxgb_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
name|PORT_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|p
operator|->
name|media
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
name|PORT_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mask
operator|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
if|if
condition|(
name|IFCAP_TXCSUM
operator|&
name|ifp
operator|->
name|if_capenable
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
operator|(
name|IFCAP_TXCSUM
operator||
name|IFCAP_TSO4
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|&=
operator|~
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator||
name|CSUM_TSO
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TXCSUM
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator||=
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mask
operator|&
name|IFCAP_RXCSUM
condition|)
block|{
if|if
condition|(
name|IFCAP_RXCSUM
operator|&
name|ifp
operator|->
name|if_capenable
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_RXCSUM
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_RXCSUM
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO4
condition|)
block|{
if|if
condition|(
name|IFCAP_TSO4
operator|&
name|ifp
operator|->
name|if_capenable
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_TSO4
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|&=
operator|~
name|CSUM_TSO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IFCAP_TXCSUM
operator|&
name|ifp
operator|->
name|if_capenable
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TSO4
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_TSO
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cxgb_debug
condition|)
name|printf
argument_list|(
literal|"cxgb requires tx checksum offload"
literal|" be enabled to use TSO\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
name|PORT_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_start_tx
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|uint32_t
name|txmax
parameter_list|)
block|{
name|struct
name|sge_qset
modifier|*
name|qs
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
name|struct
name|port_info
modifier|*
name|p
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|int
name|err
decl_stmt|,
name|in_use_init
decl_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|link_config
operator|.
name|link_ok
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|qs
operator|=
operator|&
name|p
operator|->
name|adapter
operator|->
name|sge
operator|.
name|qs
index|[
name|p
operator|->
name|first_qset
index|]
expr_stmt|;
name|txq
operator|=
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|txq
operator|->
name|lock
argument_list|)
expr_stmt|;
name|in_use_init
operator|=
name|txq
operator|->
name|in_use
expr_stmt|;
while|while
condition|(
operator|(
name|txq
operator|->
name|in_use
operator|-
name|in_use_init
operator|<
name|txmax
operator|)
operator|&&
operator|(
name|txq
operator|->
name|size
operator|>
name|txq
operator|->
name|in_use
operator|+
name|TX_MAX_DESC
operator|)
condition|)
block|{
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|(
name|err
operator|=
name|t3_encap
argument_list|(
name|p
argument_list|,
operator|&
name|m
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|txq
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|err
argument_list|)
condition|)
block|{
if|if
condition|(
name|cxgb_debug
condition|)
name|printf
argument_list|(
literal|"would set OFLAGS\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ENOMEM
condition|)
block|{
name|IFQ_LOCK
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|IFQ_DRV_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|IFQ_UNLOCK
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
name|m
operator|==
name|NULL
condition|)
name|err
operator|=
name|ENOBUFS
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_start_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|ncount
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|arg
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|sge_qset
modifier|*
name|qs
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|qs
operator|=
operator|&
name|pi
operator|->
name|adapter
operator|->
name|sge
operator|.
name|qs
index|[
name|pi
operator|->
name|first_qset
index|]
expr_stmt|;
name|txq
operator|=
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
expr_stmt|;
while|while
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|desc_reclaimable
argument_list|(
name|txq
argument_list|)
operator|>
name|TX_CLEAN_MAX_DESC
condition|)
name|taskqueue_enqueue
argument_list|(
name|pi
operator|->
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|pi
operator|->
name|adapter
operator|->
name|timer_reclaim_task
argument_list|)
expr_stmt|;
name|error
operator|=
name|cxgb_start_tx
argument_list|(
name|ifp
argument_list|,
name|TX_START_MAX_DESC
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|pi
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|sge_qset
modifier|*
name|qs
decl_stmt|;
name|struct
name|sge_txq
modifier|*
name|txq
decl_stmt|;
name|int
name|err
decl_stmt|;
name|qs
operator|=
operator|&
name|pi
operator|->
name|adapter
operator|->
name|sge
operator|.
name|qs
index|[
name|pi
operator|->
name|first_qset
index|]
expr_stmt|;
name|txq
operator|=
operator|&
name|qs
operator|->
name|txq
index|[
name|TXQ_ETH
index|]
expr_stmt|;
if|if
condition|(
name|desc_reclaimable
argument_list|(
name|txq
argument_list|)
operator|>
name|TX_CLEAN_MAX_DESC
condition|)
name|taskqueue_enqueue
argument_list|(
name|pi
operator|->
name|adapter
operator|->
name|tq
argument_list|,
operator|&
name|pi
operator|->
name|adapter
operator|->
name|timer_reclaim_task
argument_list|)
expr_stmt|;
name|err
operator|=
name|cxgb_start_tx
argument_list|(
name|ifp
argument_list|,
name|TX_START_MAX_DESC
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|taskqueue_enqueue
argument_list|(
name|pi
operator|->
name|tq
argument_list|,
operator|&
name|pi
operator|->
name|start_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"media change not supported\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|port_info
modifier|*
name|p
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|->
name|link_config
operator|.
name|link_ok
condition|)
return|return;
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|link_config
operator|.
name|duplex
condition|)
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_FDX
expr_stmt|;
else|else
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_HDX
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_async_intr
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|adapter_t
modifier|*
name|sc
init|=
name|data
decl_stmt|;
if|if
condition|(
name|cxgb_debug
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"cxgb_async_intr\n"
argument_list|)
expr_stmt|;
name|t3_slow_intr_handler
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_ext_intr_handler
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|adapter_t
modifier|*
name|sc
init|=
operator|(
name|adapter_t
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|cxgb_debug
condition|)
name|printf
argument_list|(
literal|"cxgb_ext_intr_handler\n"
argument_list|)
expr_stmt|;
name|t3_phy_intr_handler
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Now reenable external interrupts */
if|if
condition|(
name|sc
operator|->
name|slow_intr_mask
condition|)
block|{
name|sc
operator|->
name|slow_intr_mask
operator||=
name|F_T3DBG
expr_stmt|;
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|A_PL_INT_CAUSE0
argument_list|,
name|F_T3DBG
argument_list|)
expr_stmt|;
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|A_PL_INT_ENABLE0
argument_list|,
name|sc
operator|->
name|slow_intr_mask
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|check_link_status
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|sc
operator|)
operator|->
name|params
operator|.
name|nports
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|port_info
modifier|*
name|p
init|=
operator|&
name|sc
operator|->
name|port
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|port_type
operator|->
name|caps
operator|&
name|SUPPORTED_IRQ
operator|)
condition|)
name|t3_link_changed
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|check_t3b2_mac
parameter_list|(
name|struct
name|adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|for_each_port
argument_list|(
argument|adapter
argument_list|,
argument|i
argument_list|)
block|{
name|struct
name|port_info
modifier|*
name|p
init|=
operator|&
name|adapter
operator|->
name|port
index|[
name|i
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|p
operator|->
name|ifp
decl_stmt|;
name|int
name|status
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|status
operator|=
literal|0
expr_stmt|;
name|PORT_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
name|status
operator|=
name|t3b2_mac_watchdog_task
argument_list|(
operator|&
name|p
operator|->
name|mac
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|1
condition|)
name|p
operator|->
name|mac
operator|.
name|stats
operator|.
name|num_toggled
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
literal|2
condition|)
block|{
name|struct
name|cmac
modifier|*
name|mac
init|=
operator|&
name|p
operator|->
name|mac
decl_stmt|;
name|t3_mac_set_mtu
argument_list|(
name|mac
argument_list|,
name|ifp
operator|->
name|if_mtu
argument_list|)
expr_stmt|;
name|t3_mac_set_address
argument_list|(
name|mac
argument_list|,
literal|0
argument_list|,
name|p
operator|->
name|hw_addr
argument_list|)
expr_stmt|;
name|cxgb_set_rxmode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|t3_link_start
argument_list|(
operator|&
name|p
operator|->
name|phy
argument_list|,
name|mac
argument_list|,
operator|&
name|p
operator|->
name|link_config
argument_list|)
expr_stmt|;
name|t3_mac_enable
argument_list|(
name|mac
argument_list|,
name|MAC_DIRECTION_RX
operator||
name|MAC_DIRECTION_TX
argument_list|)
expr_stmt|;
name|t3_port_intr_enable
argument_list|(
name|adapter
argument_list|,
name|p
operator|->
name|port
argument_list|)
expr_stmt|;
name|p
operator|->
name|mac
operator|.
name|stats
operator|.
name|num_resets
operator|++
expr_stmt|;
block|}
name|PORT_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_tick
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|adapter_t
modifier|*
name|sc
init|=
operator|(
name|adapter_t
operator|*
operator|)
name|arg
decl_stmt|;
specifier|const
name|struct
name|adapter_params
modifier|*
name|p
init|=
operator|&
name|sc
operator|->
name|params
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|linkpoll_period
condition|)
name|check_link_status
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|cxgb_tick_ch
argument_list|,
name|sc
operator|->
name|params
operator|.
name|stats_update_period
operator|*
name|hz
argument_list|,
name|cxgb_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * adapter lock can currently only be acquire after the 	 * port lock 	 */
name|ADAPTER_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|rev
operator|==
name|T3_REV_B2
condition|)
name|check_t3b2_mac
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|in_range
parameter_list|(
name|int
name|val
parameter_list|,
name|int
name|lo
parameter_list|,
name|int
name|hi
parameter_list|)
block|{
return|return
name|val
operator|<
literal|0
operator|||
operator|(
name|val
operator|<=
name|hi
operator|&&
name|val
operator|>=
name|lo
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_extension_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|unsigned
name|long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|mmd
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|port_info
modifier|*
name|pi
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
name|adapter_t
modifier|*
name|sc
init|=
name|pi
operator|->
name|adapter
decl_stmt|;
ifdef|#
directive|ifdef
name|PRIV_SUPPORTED
if|if
condition|(
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
condition|)
block|{
if|if
condition|(
name|cxgb_debug
condition|)
name|printf
argument_list|(
literal|"user does not have access to privileged ioctls\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
else|#
directive|else
if|if
condition|(
name|suser
argument_list|(
name|td
argument_list|)
condition|)
block|{
if|if
condition|(
name|cxgb_debug
condition|)
name|printf
argument_list|(
literal|"user does not have access to privileged ioctls\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCGMIIREG
case|:
block|{
name|uint32_t
name|val
decl_stmt|;
name|struct
name|cphy
modifier|*
name|phy
init|=
operator|&
name|pi
operator|->
name|phy
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mid
init|=
operator|(
expr|struct
name|mii_data
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|phy
operator|->
name|mdio_read
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
if|if
condition|(
name|is_10G
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|mmd
operator|=
name|mid
operator|->
name|phy_id
operator|>>
literal|8
expr_stmt|;
if|if
condition|(
operator|!
name|mmd
condition|)
name|mmd
operator|=
name|MDIO_DEV_PCS
expr_stmt|;
elseif|else
if|if
condition|(
name|mmd
operator|>
name|MDIO_DEV_XGXS
condition|)
return|return
operator|-
name|EINVAL
return|;
name|error
operator|=
name|phy
operator|->
name|mdio_read
argument_list|(
name|sc
argument_list|,
name|mid
operator|->
name|phy_id
operator|&
literal|0x1f
argument_list|,
name|mmd
argument_list|,
name|mid
operator|->
name|reg_num
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|phy
operator|->
name|mdio_read
argument_list|(
name|sc
argument_list|,
name|mid
operator|->
name|phy_id
operator|&
literal|0x1f
argument_list|,
literal|0
argument_list|,
name|mid
operator|->
name|reg_num
operator|&
literal|0x1f
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|mid
operator|->
name|val_out
operator|=
name|val
expr_stmt|;
break|break;
block|}
case|case
name|SIOCSMIIREG
case|:
block|{
name|struct
name|cphy
modifier|*
name|phy
init|=
operator|&
name|pi
operator|->
name|phy
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mid
init|=
operator|(
expr|struct
name|mii_data
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|phy
operator|->
name|mdio_write
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
if|if
condition|(
name|is_10G
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|mmd
operator|=
name|mid
operator|->
name|phy_id
operator|>>
literal|8
expr_stmt|;
if|if
condition|(
operator|!
name|mmd
condition|)
name|mmd
operator|=
name|MDIO_DEV_PCS
expr_stmt|;
elseif|else
if|if
condition|(
name|mmd
operator|>
name|MDIO_DEV_XGXS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|phy
operator|->
name|mdio_write
argument_list|(
name|sc
argument_list|,
name|mid
operator|->
name|phy_id
operator|&
literal|0x1f
argument_list|,
name|mmd
argument_list|,
name|mid
operator|->
name|reg_num
argument_list|,
name|mid
operator|->
name|val_in
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|phy
operator|->
name|mdio_write
argument_list|(
name|sc
argument_list|,
name|mid
operator|->
name|phy_id
operator|&
literal|0x1f
argument_list|,
literal|0
argument_list|,
name|mid
operator|->
name|reg_num
operator|&
literal|0x1f
argument_list|,
name|mid
operator|->
name|val_in
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_SETREG
case|:
block|{
name|struct
name|ch_reg
modifier|*
name|edata
init|=
operator|(
expr|struct
name|ch_reg
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
operator|(
name|edata
operator|->
name|addr
operator|&
literal|0x3
operator|)
operator|!=
literal|0
operator|||
name|edata
operator|->
name|addr
operator|>=
name|sc
operator|->
name|mmio_len
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|t3_write_reg
argument_list|(
name|sc
argument_list|,
name|edata
operator|->
name|addr
argument_list|,
name|edata
operator|->
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_GETREG
case|:
block|{
name|struct
name|ch_reg
modifier|*
name|edata
init|=
operator|(
expr|struct
name|ch_reg
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
operator|(
name|edata
operator|->
name|addr
operator|&
literal|0x3
operator|)
operator|!=
literal|0
operator|||
name|edata
operator|->
name|addr
operator|>=
name|sc
operator|->
name|mmio_len
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|edata
operator|->
name|val
operator|=
name|t3_read_reg
argument_list|(
name|sc
argument_list|,
name|edata
operator|->
name|addr
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_GET_SGE_CONTEXT
case|:
block|{
name|struct
name|ch_cntxt
modifier|*
name|ecntxt
init|=
operator|(
expr|struct
name|ch_cntxt
operator|*
operator|)
name|data
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ecntxt
operator|->
name|cntxt_type
condition|)
block|{
case|case
name|CNTXT_TYPE_EGRESS
case|:
name|error
operator|=
name|t3_sge_read_ecntxt
argument_list|(
name|sc
argument_list|,
name|ecntxt
operator|->
name|cntxt_id
argument_list|,
name|ecntxt
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|CNTXT_TYPE_FL
case|:
name|error
operator|=
name|t3_sge_read_fl
argument_list|(
name|sc
argument_list|,
name|ecntxt
operator|->
name|cntxt_id
argument_list|,
name|ecntxt
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|CNTXT_TYPE_RSP
case|:
name|error
operator|=
name|t3_sge_read_rspq
argument_list|(
name|sc
argument_list|,
name|ecntxt
operator|->
name|cntxt_id
argument_list|,
name|ecntxt
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|CNTXT_TYPE_CQ
case|:
name|error
operator|=
name|t3_sge_read_cq
argument_list|(
name|sc
argument_list|,
name|ecntxt
operator|->
name|cntxt_id
argument_list|,
name|ecntxt
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|reg_lock
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_GET_SGE_DESC
case|:
block|{
name|struct
name|ch_desc
modifier|*
name|edesc
init|=
operator|(
expr|struct
name|ch_desc
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|edesc
operator|->
name|queue_num
operator|>=
name|SGE_QSETS
operator|*
literal|6
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ret
operator|=
name|t3_get_desc
argument_list|(
operator|&
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
name|edesc
operator|->
name|queue_num
operator|/
literal|6
index|]
argument_list|,
name|edesc
operator|->
name|queue_num
operator|%
literal|6
argument_list|,
name|edesc
operator|->
name|idx
argument_list|,
name|edesc
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|edesc
operator|->
name|size
operator|=
name|ret
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_SET_QSET_PARAMS
case|:
block|{
name|struct
name|qset_params
modifier|*
name|q
decl_stmt|;
name|struct
name|ch_qset_params
modifier|*
name|t
init|=
operator|(
expr|struct
name|ch_qset_params
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|qset_idx
operator|>=
name|SGE_QSETS
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
operator|!
name|in_range
argument_list|(
name|t
operator|->
name|intr_lat
argument_list|,
literal|0
argument_list|,
name|M_NEWTIMER
argument_list|)
operator|||
operator|!
name|in_range
argument_list|(
name|t
operator|->
name|cong_thres
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|)
operator|||
operator|!
name|in_range
argument_list|(
name|t
operator|->
name|txq_size
index|[
literal|0
index|]
argument_list|,
name|MIN_TXQ_ENTRIES
argument_list|,
name|MAX_TXQ_ENTRIES
argument_list|)
operator|||
operator|!
name|in_range
argument_list|(
name|t
operator|->
name|txq_size
index|[
literal|1
index|]
argument_list|,
name|MIN_TXQ_ENTRIES
argument_list|,
name|MAX_TXQ_ENTRIES
argument_list|)
operator|||
operator|!
name|in_range
argument_list|(
name|t
operator|->
name|txq_size
index|[
literal|2
index|]
argument_list|,
name|MIN_CTRL_TXQ_ENTRIES
argument_list|,
name|MAX_CTRL_TXQ_ENTRIES
argument_list|)
operator|||
operator|!
name|in_range
argument_list|(
name|t
operator|->
name|fl_size
index|[
literal|0
index|]
argument_list|,
name|MIN_FL_ENTRIES
argument_list|,
name|MAX_RX_BUFFERS
argument_list|)
operator|||
operator|!
name|in_range
argument_list|(
name|t
operator|->
name|fl_size
index|[
literal|1
index|]
argument_list|,
name|MIN_FL_ENTRIES
argument_list|,
name|MAX_RX_JUMBO_BUFFERS
argument_list|)
operator|||
operator|!
name|in_range
argument_list|(
name|t
operator|->
name|rspq_size
argument_list|,
name|MIN_RSPQ_ENTRIES
argument_list|,
name|MAX_RSPQ_ENTRIES
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
operator|)
operator|&&
operator|(
name|t
operator|->
name|rspq_size
operator|>=
literal|0
operator|||
name|t
operator|->
name|fl_size
index|[
literal|0
index|]
operator|>=
literal|0
operator|||
name|t
operator|->
name|fl_size
index|[
literal|1
index|]
operator|>=
literal|0
operator|||
name|t
operator|->
name|txq_size
index|[
literal|0
index|]
operator|>=
literal|0
operator|||
name|t
operator|->
name|txq_size
index|[
literal|1
index|]
operator|>=
literal|0
operator|||
name|t
operator|->
name|txq_size
index|[
literal|2
index|]
operator|>=
literal|0
operator|||
name|t
operator|->
name|polling
operator|>=
literal|0
operator|||
name|t
operator|->
name|cong_thres
operator|>=
literal|0
operator|)
condition|)
return|return
operator|-
name|EBUSY
return|;
name|q
operator|=
operator|&
name|sc
operator|->
name|params
operator|.
name|sge
operator|.
name|qset
index|[
name|t
operator|->
name|qset_idx
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|rspq_size
operator|>=
literal|0
condition|)
name|q
operator|->
name|rspq_size
operator|=
name|t
operator|->
name|rspq_size
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|fl_size
index|[
literal|0
index|]
operator|>=
literal|0
condition|)
name|q
operator|->
name|fl_size
operator|=
name|t
operator|->
name|fl_size
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|fl_size
index|[
literal|1
index|]
operator|>=
literal|0
condition|)
name|q
operator|->
name|jumbo_size
operator|=
name|t
operator|->
name|fl_size
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|txq_size
index|[
literal|0
index|]
operator|>=
literal|0
condition|)
name|q
operator|->
name|txq_size
index|[
literal|0
index|]
operator|=
name|t
operator|->
name|txq_size
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|txq_size
index|[
literal|1
index|]
operator|>=
literal|0
condition|)
name|q
operator|->
name|txq_size
index|[
literal|1
index|]
operator|=
name|t
operator|->
name|txq_size
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|txq_size
index|[
literal|2
index|]
operator|>=
literal|0
condition|)
name|q
operator|->
name|txq_size
index|[
literal|2
index|]
operator|=
name|t
operator|->
name|txq_size
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|cong_thres
operator|>=
literal|0
condition|)
name|q
operator|->
name|cong_thres
operator|=
name|t
operator|->
name|cong_thres
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|intr_lat
operator|>=
literal|0
condition|)
block|{
name|struct
name|sge_qset
modifier|*
name|qs
init|=
operator|&
name|sc
operator|->
name|sge
operator|.
name|qs
index|[
name|t
operator|->
name|qset_idx
index|]
decl_stmt|;
name|q
operator|->
name|coalesce_nsecs
operator|=
name|t
operator|->
name|intr_lat
operator|*
literal|1000
expr_stmt|;
name|t3_update_qset_coalesce
argument_list|(
name|qs
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|CHELSIO_GET_QSET_PARAMS
case|:
block|{
name|struct
name|qset_params
modifier|*
name|q
decl_stmt|;
name|struct
name|ch_qset_params
modifier|*
name|t
init|=
operator|(
expr|struct
name|ch_qset_params
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|qset_idx
operator|>=
name|SGE_QSETS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|q
operator|=
operator|&
operator|(
name|sc
operator|)
operator|->
name|params
operator|.
name|sge
operator|.
name|qset
index|[
name|t
operator|->
name|qset_idx
index|]
expr_stmt|;
name|t
operator|->
name|rspq_size
operator|=
name|q
operator|->
name|rspq_size
expr_stmt|;
name|t
operator|->
name|txq_size
index|[
literal|0
index|]
operator|=
name|q
operator|->
name|txq_size
index|[
literal|0
index|]
expr_stmt|;
name|t
operator|->
name|txq_size
index|[
literal|1
index|]
operator|=
name|q
operator|->
name|txq_size
index|[
literal|1
index|]
expr_stmt|;
name|t
operator|->
name|txq_size
index|[
literal|2
index|]
operator|=
name|q
operator|->
name|txq_size
index|[
literal|2
index|]
expr_stmt|;
name|t
operator|->
name|fl_size
index|[
literal|0
index|]
operator|=
name|q
operator|->
name|fl_size
expr_stmt|;
name|t
operator|->
name|fl_size
index|[
literal|1
index|]
operator|=
name|q
operator|->
name|jumbo_size
expr_stmt|;
name|t
operator|->
name|polling
operator|=
name|q
operator|->
name|polling
expr_stmt|;
name|t
operator|->
name|intr_lat
operator|=
name|q
operator|->
name|coalesce_nsecs
operator|/
literal|1000
expr_stmt|;
name|t
operator|->
name|cong_thres
operator|=
name|q
operator|->
name|cong_thres
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_SET_QSET_NUM
case|:
block|{
name|struct
name|ch_reg
modifier|*
name|edata
init|=
operator|(
expr|struct
name|ch_reg
operator|*
operator|)
name|data
decl_stmt|;
name|unsigned
name|int
name|port_idx
init|=
name|pi
operator|->
name|port
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
name|edata
operator|->
name|val
operator|<
literal|1
operator|||
operator|(
name|edata
operator|->
name|val
operator|>
literal|1
operator|&&
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|USING_MSIX
operator|)
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|edata
operator|->
name|val
operator|+
name|sc
operator|->
name|port
index|[
operator|!
name|port_idx
index|]
operator|.
name|nqsets
operator|>
name|SGE_QSETS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sc
operator|->
name|port
index|[
name|port_idx
index|]
operator|.
name|nqsets
operator|=
name|edata
operator|->
name|val
expr_stmt|;
comment|/* 		 * XXX we're hardcoding ourselves to 2 ports 		 * just like the LEENUX 		 */
name|sc
operator|->
name|port
index|[
literal|1
index|]
operator|.
name|first_qset
operator|=
name|sc
operator|->
name|port
index|[
literal|0
index|]
operator|.
name|nqsets
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_GET_QSET_NUM
case|:
block|{
name|struct
name|ch_reg
modifier|*
name|edata
init|=
operator|(
expr|struct
name|ch_reg
operator|*
operator|)
name|data
decl_stmt|;
name|edata
operator|->
name|val
operator|=
name|pi
operator|->
name|nqsets
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|notyet
comment|/* 		 * XXX FreeBSD driver does not currently support any 		 * offload functionality  		 */
case|case
name|CHELSIO_LOAD_FW
case|:
case|case
name|CHELSIO_DEVUP
case|:
case|case
name|CHELSIO_SETMTUTAB
case|:
case|case
name|CHELSIO_GET_PM
case|:
case|case
name|CHELSIO_SET_PM
case|:
case|case
name|CHELSIO_READ_TCAM_WORD
case|:
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
break|break;
endif|#
directive|endif
case|case
name|CHELSIO_GET_MEM
case|:
block|{
name|struct
name|ch_mem_range
modifier|*
name|t
init|=
operator|(
expr|struct
name|ch_mem_range
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|mc7
modifier|*
name|mem
decl_stmt|;
name|uint8_t
modifier|*
name|useraddr
decl_stmt|;
name|u64
name|buf
index|[
literal|32
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|is_offload
argument_list|(
name|sc
argument_list|)
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|FULL_INIT_DONE
operator|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* need the memory controllers */
if|if
condition|(
operator|(
name|t
operator|->
name|addr
operator|&
literal|0x7
operator|)
operator|||
operator|(
name|t
operator|->
name|len
operator|&
literal|0x7
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|t
operator|->
name|mem_id
operator|==
name|MEM_CM
condition|)
name|mem
operator|=
operator|&
name|sc
operator|->
name|cm
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|->
name|mem_id
operator|==
name|MEM_PMRX
condition|)
name|mem
operator|=
operator|&
name|sc
operator|->
name|pmrx
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|->
name|mem_id
operator|==
name|MEM_PMTX
condition|)
name|mem
operator|=
operator|&
name|sc
operator|->
name|pmtx
expr_stmt|;
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 		 * Version scheme: 		 * bits 0..9: chip version 		 * bits 10..15: chip revision 		 */
name|t
operator|->
name|version
operator|=
literal|3
operator||
operator|(
name|sc
operator|->
name|params
operator|.
name|rev
operator|<<
literal|10
operator|)
expr_stmt|;
comment|/* 		 * Read 256 bytes at a time as len can be large and we don't 		 * want to use huge intermediate buffers. 		 */
name|useraddr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|t
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* advance to start of buffer */
while|while
condition|(
name|t
operator|->
name|len
condition|)
block|{
name|unsigned
name|int
name|chunk
init|=
name|min
argument_list|(
name|t
operator|->
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
decl_stmt|;
name|error
operator|=
name|t3_mc7_bd_read
argument_list|(
name|mem
argument_list|,
name|t
operator|->
name|addr
operator|/
literal|8
argument_list|,
name|chunk
operator|/
literal|8
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
operator|-
name|error
operator|)
return|;
if|if
condition|(
name|copyout
argument_list|(
name|buf
argument_list|,
name|useraddr
argument_list|,
name|chunk
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|useraddr
operator|+=
name|chunk
expr_stmt|;
name|t
operator|->
name|addr
operator|+=
name|chunk
expr_stmt|;
name|t
operator|->
name|len
operator|-=
name|chunk
expr_stmt|;
block|}
break|break;
block|}
case|case
name|CHELSIO_SET_TRACE_FILTER
case|:
block|{
name|struct
name|ch_trace
modifier|*
name|t
init|=
operator|(
expr|struct
name|ch_trace
operator|*
operator|)
name|data
decl_stmt|;
specifier|const
name|struct
name|trace_params
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
operator|(
specifier|const
expr|struct
name|trace_params
operator|*
operator|)
operator|&
name|t
operator|->
name|sip
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|config_tx
condition|)
name|t3_config_trace_filter
argument_list|(
name|sc
argument_list|,
name|tp
argument_list|,
literal|0
argument_list|,
name|t
operator|->
name|invert_match
argument_list|,
name|t
operator|->
name|trace_tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|config_rx
condition|)
name|t3_config_trace_filter
argument_list|(
name|sc
argument_list|,
name|tp
argument_list|,
literal|1
argument_list|,
name|t
operator|->
name|invert_match
argument_list|,
name|t
operator|->
name|trace_rx
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_SET_PKTSCHED
case|:
block|{
name|struct
name|ch_pktsched_params
modifier|*
name|p
init|=
operator|(
expr|struct
name|ch_pktsched_params
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|open_device_map
operator|==
literal|0
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
name|send_pktsched_cmd
argument_list|(
name|sc
argument_list|,
name|p
operator|->
name|sched
argument_list|,
name|p
operator|->
name|idx
argument_list|,
name|p
operator|->
name|min
argument_list|,
name|p
operator|->
name|max
argument_list|,
name|p
operator|->
name|binding
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CHELSIO_IFCONF_GETREGS
case|:
block|{
name|struct
name|ifconf_regs
modifier|*
name|regs
init|=
operator|(
expr|struct
name|ifconf_regs
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|reglen
init|=
name|cxgb_get_regs_len
argument_list|()
decl_stmt|;
name|uint8_t
modifier|*
name|buf
init|=
name|malloc
argument_list|(
name|REGDUMP_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
decl_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|regs
operator|->
name|len
operator|>
name|reglen
condition|)
name|regs
operator|->
name|len
operator|=
name|reglen
expr_stmt|;
elseif|else
if|if
condition|(
name|regs
operator|->
name|len
operator|<
name|reglen
condition|)
block|{
name|error
operator|=
name|E2BIG
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|cxgb_get_regs
argument_list|(
name|sc
argument_list|,
name|regs
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|buf
argument_list|,
name|regs
operator|->
name|data
argument_list|,
name|reglen
argument_list|)
expr_stmt|;
name|done
label|:
name|free
argument_list|(
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|reg_block_dump
parameter_list|(
name|struct
name|adapter
modifier|*
name|ap
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|unsigned
name|int
name|start
parameter_list|,
name|unsigned
name|int
name|end
parameter_list|)
block|{
name|uint32_t
modifier|*
name|p
init|=
operator|(
name|uint32_t
operator|*
operator|)
name|buf
operator|+
name|start
decl_stmt|;
for|for
control|(
init|;
name|start
operator|<=
name|end
condition|;
name|start
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
control|)
operator|*
name|p
operator|++
operator|=
name|t3_read_reg
argument_list|(
name|ap
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|T3_REGMAP_SIZE
value|(3 * 1024)
end_define

begin_function
specifier|static
name|int
name|cxgb_get_regs_len
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|T3_REGMAP_SIZE
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|T3_REGMAP_SIZE
end_undef

begin_function
specifier|static
name|void
name|cxgb_get_regs
parameter_list|(
name|adapter_t
modifier|*
name|sc
parameter_list|,
name|struct
name|ifconf_regs
modifier|*
name|regs
parameter_list|,
name|uint8_t
modifier|*
name|buf
parameter_list|)
block|{
comment|/* 	 * Version scheme: 	 * bits 0..9: chip version 	 * bits 10..15: chip revision 	 * bit 31: set for PCIe cards 	 */
name|regs
operator|->
name|version
operator|=
literal|3
operator||
operator|(
name|sc
operator|->
name|params
operator|.
name|rev
operator|<<
literal|10
operator|)
operator||
operator|(
name|is_pcie
argument_list|(
name|sc
argument_list|)
operator|<<
literal|31
operator|)
expr_stmt|;
comment|/* 	 * We skip the MAC statistics registers because they are clear-on-read. 	 * Also reading multi-register stats would need to synchronize with the 	 * periodic mac stats accumulation.  Hard to justify the complexity. 	 */
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|REGDUMP_SIZE
argument_list|)
expr_stmt|;
name|reg_block_dump
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|A_SG_RSPQ_CREDIT_RETURN
argument_list|)
expr_stmt|;
name|reg_block_dump
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|A_SG_HI_DRB_HI_THRSH
argument_list|,
name|A_ULPRX_PBL_ULIMIT
argument_list|)
expr_stmt|;
name|reg_block_dump
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|A_ULPTX_CONFIG
argument_list|,
name|A_MPS_INT_CAUSE
argument_list|)
expr_stmt|;
name|reg_block_dump
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|A_CPL_SWITCH_CNTRL
argument_list|,
name|A_CPL_MAP_TBL_DATA
argument_list|)
expr_stmt|;
name|reg_block_dump
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|A_SMB_GLOBAL_TIME_CFG
argument_list|,
name|A_XGM_SERDES_STAT3
argument_list|)
expr_stmt|;
name|reg_block_dump
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|A_XGM_SERDES_STATUS0
argument_list|,
name|XGM_REG
argument_list|(
name|A_XGM_SERDES_STAT3
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|reg_block_dump
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|XGM_REG
argument_list|(
name|A_XGM_SERDES_STATUS0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XGM_REG
argument_list|(
name|A_XGM_RX_SPI4_SOP_EOP_CNT
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

