begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************************  Copyright (c) 2007, Chelsio Inc. All rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:   1. Redistributions of source code must retain the above copyright notice,     this list of conditions and the following disclaimer.   2. Neither the name of the Chelsio Corporation nor the names of its     contributors may be used to endorse or promote products derived from     this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_comment
comment|/*  * XXX   */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_DEFINED
end_ifdef

begin_include
include|#
directive|include
file|<cxgb_include.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<dev/cxgb/cxgb_include.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|offload_db_lock
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|toedev
argument_list|)
name|offload_dev_list
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|tom_info
argument_list|)
name|offload_module_list
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Returns the entry in the given table with the given offload id, or NULL  * if the id is not found.  */
end_comment

begin_function
specifier|static
specifier|const
name|struct
name|offload_id
modifier|*
name|id_find
parameter_list|(
name|unsigned
name|int
name|id
parameter_list|,
specifier|const
name|struct
name|offload_id
modifier|*
name|table
parameter_list|)
block|{
for|for
control|(
init|;
name|table
operator|->
name|id
condition|;
operator|++
name|table
control|)
if|if
condition|(
name|table
operator|->
name|id
operator|==
name|id
condition|)
return|return
name|table
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Returns true if an offload device is presently attached to an offload module.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|is_attached
parameter_list|(
specifier|const
name|struct
name|toedev
modifier|*
name|dev
parameter_list|)
block|{
return|return
name|dev
operator|->
name|tod_offload_mod
operator|!=
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Try to attach a new offload device to an existing TCP offload module that  * can handle the device's offload id.  Returns 0 if it succeeds.  *  * Must be called with the offload_db_lock held.  */
end_comment

begin_function
specifier|static
name|int
name|offload_attach
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|tom_info
modifier|*
name|t
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|t
argument_list|,
argument|&offload_module_list
argument_list|,
argument|entry
argument_list|)
block|{
specifier|const
name|struct
name|offload_id
modifier|*
name|entry
decl_stmt|;
name|entry
operator|=
name|id_find
argument_list|(
name|dev
operator|->
name|tod_ttid
argument_list|,
name|t
operator|->
name|ti_id_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|&&
name|t
operator|->
name|ti_attach
argument_list|(
name|dev
argument_list|,
name|entry
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dev
operator|->
name|tod_offload_mod
operator|=
name|t
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
operator|(
name|ENOPROTOOPT
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * register_tom - register a TCP Offload Module (TOM)  * @t: the offload module to register  *  * Register a TCP Offload Module (TOM).  */
end_comment

begin_function
name|int
name|register_tom
parameter_list|(
name|struct
name|tom_info
modifier|*
name|t
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|offload_db_lock
argument_list|)
expr_stmt|;
name|toedev_registration_count
operator|++
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|offload_module_list
argument_list|,
name|t
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|offload_db_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * unregister_tom - unregister a TCP Offload Module (TOM)  * @t: the offload module to register  *  * Unregister a TCP Offload Module (TOM).  Note that this does not affect any  * TOE devices to which the TOM is already attached.  */
end_comment

begin_function
name|int
name|unregister_tom
parameter_list|(
name|struct
name|tom_info
modifier|*
name|t
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|offload_db_lock
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|offload_module_list
argument_list|,
name|t
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|offload_db_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Find an offload device by name.  Must be called with offload_db_lock held.  */
end_comment

begin_function
specifier|static
name|struct
name|toedev
modifier|*
name|__find_offload_dev_by_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|toedev
modifier|*
name|dev
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|dev
argument_list|,
argument|&offload_dev_list
argument_list|,
argument|entry
argument_list|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|dev
operator|->
name|tod_name
argument_list|,
name|name
argument_list|,
name|TOENAMSIZ
argument_list|)
condition|)
return|return
name|dev
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Returns true if an offload device is already registered.  * Must be called with the offload_db_lock held.  */
end_comment

begin_function
specifier|static
name|int
name|is_registered
parameter_list|(
specifier|const
name|struct
name|toedev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|toedev
modifier|*
name|d
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|d
argument_list|,
argument|&offload_dev_list
argument_list|,
argument|entry
argument_list|)
block|{
if|if
condition|(
name|d
operator|==
name|dev
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Finalize the name of an offload device by assigning values to any format  * strings in its name.  */
end_comment

begin_function
specifier|static
name|int
name|assign_name
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
operator|++
name|i
control|)
block|{
name|char
name|s
index|[
name|TOENAMSIZ
index|]
decl_stmt|;
if|if
condition|(
name|snprintf
argument_list|(
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|,
name|name
argument_list|,
name|i
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|s
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* name too long */
if|if
condition|(
operator|!
name|__find_offload_dev_by_name
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|dev
operator|->
name|tod_name
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * register_toedev - register a TOE device  * @dev: the device  * @name: a name template for the device  *  * Register a TOE device and try to attach an appropriate TCP offload module  * to it.  @name is a template that may contain at most one %d format  * specifier.  */
end_comment

begin_function
name|int
name|register_toedev
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
comment|/* 	 * Validate the name template.  Only one %d allowed and name must be 	 * a valid filename so it can appear in sysfs. 	 */
if|if
condition|(
operator|!
name|name
operator|||
operator|!
operator|*
name|name
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"."
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".."
argument_list|)
operator|||
name|strchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
condition|)
return|return
name|EINVAL
return|;
name|p
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'%'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|!=
literal|'d'
operator|||
name|strchr
argument_list|(
name|p
operator|+
literal|2
argument_list|,
literal|'%'
argument_list|)
operator|)
condition|)
return|return
name|EINVAL
return|;
name|mtx_lock
argument_list|(
operator|&
name|offload_db_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_registered
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* device already registered */
name|ret
operator|=
name|EEXIST
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|ret
operator|=
name|assign_name
argument_list|(
name|dev
argument_list|,
name|name
argument_list|,
literal|32
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|dev
operator|->
name|tod_offload_mod
operator|=
name|NULL
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|offload_dev_list
argument_list|,
name|dev
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|out
label|:
name|mtx_unlock
argument_list|(
operator|&
name|offload_db_lock
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * unregister_toedev - unregister a TOE device  * @dev: the device  *  * Unregister a TOE device.  The device must not be attached to an offload  * module.  */
end_comment

begin_function
name|int
name|unregister_toedev
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|offload_db_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_registered
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|ret
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|is_attached
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|ret
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|offload_dev_list
argument_list|,
name|dev
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|out
label|:
name|mtx_unlock
argument_list|(
operator|&
name|offload_db_lock
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * activate_offload - activate an offload device  * @dev: the device  *  * Activate an offload device by locating an appropriate registered offload  * module.  If no module is found the operation fails and may be retried at  * a later time.  */
end_comment

begin_function
name|int
name|activate_offload
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|offload_db_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_registered
argument_list|(
name|dev
argument_list|)
condition|)
name|ret
operator|=
name|ENODEV
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|is_attached
argument_list|(
name|dev
argument_list|)
condition|)
name|ret
operator|=
name|offload_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|offload_db_lock
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * toe_send - send a packet to a TOE device  * @dev: the device  * @m: the packet  *  * Sends an mbuf to a TOE driver after dealing with any active network taps.  */
end_comment

begin_function
name|int
name|toe_send
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
comment|/* XXX neccessary? */
name|r
operator|=
name|dev
operator|->
name|tod_send
argument_list|(
name|dev
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
if|if
condition|(
name|r
condition|)
name|BPF_MTAP
argument_list|(
name|dev
operator|->
name|tod_lldev
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/**  * toe_receive_mbuf - process n received TOE packets  * @dev: the toe device  * @m: an array of offload packets  * @n: the number of offload packets  *  * Process an array of ingress offload packets.  Each packet is forwarded  * to any active network taps and then passed to the toe device's receive  * method.  We optimize passing packets to the receive method by passing  * it the whole array at once except when there are active taps.  */
end_comment

begin_function
name|int
name|toe_receive_mbuf
parameter_list|(
name|struct
name|toedev
modifier|*
name|dev
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|,
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
name|__predict_true
argument_list|(
operator|!
name|bpf_peers_present
argument_list|(
name|dev
operator|->
name|tod_lldev
operator|->
name|if_bpf
argument_list|)
argument_list|)
condition|)
return|return
name|dev
operator|->
name|tod_recv
argument_list|(
name|dev
argument_list|,
name|m
argument_list|,
name|n
argument_list|)
return|;
for|for
control|(
init|;
name|n
condition|;
name|n
operator|--
operator|,
name|m
operator|++
control|)
block|{
name|m
index|[
literal|0
index|]
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|dev
operator|->
name|tod_lldev
expr_stmt|;
name|BPF_MTAP
argument_list|(
name|dev
operator|->
name|tod_lldev
argument_list|,
name|m
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|dev
operator|->
name|tod_recv
argument_list|(
name|dev
argument_list|,
name|m
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|ifnet_is_offload
parameter_list|(
specifier|const
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
return|return
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFCAP_TOE
operator|)
return|;
block|}
end_function

begin_function
name|void
name|toe_arp_update
parameter_list|(
name|struct
name|rtentry
modifier|*
name|rt
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|rt
operator|->
name|rt_ifp
decl_stmt|;
if|if
condition|(
name|ifp
operator|&&
name|ifnet_is_offload
argument_list|(
name|ifp
argument_list|)
condition|)
block|{
name|struct
name|toedev
modifier|*
name|tdev
init|=
name|TOEDEV
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
if|if
condition|(
name|tdev
operator|&&
name|tdev
operator|->
name|tod_arp_update
condition|)
name|tdev
operator|->
name|tod_arp_update
argument_list|(
name|tdev
argument_list|,
name|rt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * offload_get_phys_egress - find the physical egress device  * @root_dev: the root device anchoring the search  * @so: the socket used to determine egress port in bonding mode  * @context: in bonding mode, indicates a connection set up or failover  *  * Given a root network device it returns the physical egress device that is a  * descendant of the root device.  The root device may be either a physical  * device, in which case it is the device returned, or a virtual device, such  * as a VLAN or bonding device.  In case of a bonding device the search  * considers the decisions of the bonding device given its mode to locate the  * correct egress device.  */
end_comment

begin_function
name|struct
name|ifnet
modifier|*
name|offload_get_phys_egress
parameter_list|(
name|struct
name|ifnet
modifier|*
name|root_dev
parameter_list|,
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|context
parameter_list|)
block|{
if|#
directive|if
literal|0
block|while (root_dev&& ifnet_is_offload(root_dev)) { 		if (root_dev->tod_priv_flags& IFF_802_1Q_VLAN) 			root_dev = VLAN_DEV_INFO(root_dev)->real_dev; 		else if (root_dev->tod_flags& IFF_MASTER) 			root_dev = toe_bond_get_slave(root_dev, sk, context); 		else 			break; 	}
endif|#
directive|endif
return|return
name|root_dev
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|toecore_load
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|cmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|mtx_init
argument_list|(
operator|&
name|offload_db_lock
argument_list|,
literal|"toedev lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|offload_dev_list
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|offload_module_list
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_QUIESCE
case|:
break|break;
case|case
name|MOD_UNLOAD
case|:
name|mtx_lock
argument_list|(
operator|&
name|offload_db_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|offload_dev_list
argument_list|)
operator|||
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|offload_module_list
argument_list|)
condition|)
block|{
name|err
operator|=
name|EBUSY
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|offload_db_lock
argument_list|)
expr_stmt|;
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|offload_db_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|offload_db_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_SHUTDOWN
case|:
break|break;
default|default:
name|err
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|mod_data
init|=
block|{
literal|"toecore"
block|,
name|toecore_load
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|toecore
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|toecore
argument_list|,
name|mod_data
argument_list|,
name|SI_SUB_EXEC
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

