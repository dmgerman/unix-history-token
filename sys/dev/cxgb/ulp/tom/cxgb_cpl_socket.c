begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************************  Copyright (c) 2007, Chelsio Inc. All rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:   1. Redistributions of source code must retain the above copyright notice,     this list of conditions and the following disclaimer.   2. Neither the name of the Chelsio Corporation nor the names of its     contributors may be used to endorse or promote products derived from     this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/cxgb_osdep.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/sys/mbufq.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_fsm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_offload.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/t3cdev.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_firmware_exports.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_t3_cpl.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_tcb.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/common/cxgb_ctl_defs.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/cxgb_l2t.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/cxgb_offload.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/sys/mvec.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/toecore/cxgb_toedev.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/tom/cxgb_defs.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/tom/cxgb_tom.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/tom/cxgb_t3_ddp.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/tom/cxgb_toepcb.h>
end_include

begin_include
include|#
directive|include
file|<dev/cxgb/ulp/tom/cxgb_tcp.h>
end_include

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|pru_sosend
function_decl|)
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|mbuf
modifier|*
name|top
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|pru_soreceive
function_decl|)
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|paddr
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp0
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|controlp
parameter_list|,
name|int
modifier|*
name|flagsp
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_define
define|#
directive|define
name|VM_HOLD_WRITEABLE
value|0x1
end_define

begin_function_decl
specifier|static
name|int
name|vm_fault_hold_user_pages
parameter_list|(
name|vm_offset_t
name|addr
parameter_list|,
name|int
name|len
parameter_list|,
name|vm_page_t
modifier|*
name|mp
parameter_list|,
name|int
modifier|*
name|count
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|vm_fault_unhold_pages
parameter_list|(
name|vm_page_t
modifier|*
name|m
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|TMP_IOV_MAX
value|16
end_define

begin_function
name|void
name|t3_init_socket_ops
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|protosw
modifier|*
name|prp
decl_stmt|;
name|prp
operator|=
name|pffindtype
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|)
expr_stmt|;
name|pru_sosend
operator|=
name|prp
operator|->
name|pr_usrreqs
operator|->
name|pru_sosend
expr_stmt|;
name|pru_soreceive
operator|=
name|prp
operator|->
name|pr_usrreqs
operator|->
name|pru_soreceive
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_USRREQS_OVERLOAD
name|tcp_usrreqs
operator|.
name|pru_connect
operator|=
name|cxgb_tcp_usrreqs
operator|.
name|pru_connect
expr_stmt|;
name|tcp_usrreqs
operator|.
name|pru_abort
operator|=
name|cxgb_tcp_usrreqs
operator|.
name|pru_abort
expr_stmt|;
name|tcp_usrreqs
operator|.
name|pru_listen
operator|=
name|cxgb_tcp_usrreqs
operator|.
name|pru_listen
expr_stmt|;
name|tcp_usrreqs
operator|.
name|pru_send
operator|=
name|cxgb_tcp_usrreqs
operator|.
name|pru_send
expr_stmt|;
name|tcp_usrreqs
operator|.
name|pru_abort
operator|=
name|cxgb_tcp_usrreqs
operator|.
name|pru_abort
expr_stmt|;
name|tcp_usrreqs
operator|.
name|pru_disconnect
operator|=
name|cxgb_tcp_usrreqs
operator|.
name|pru_disconnect
expr_stmt|;
name|tcp_usrreqs
operator|.
name|pru_close
operator|=
name|cxgb_tcp_usrreqs
operator|.
name|pru_close
expr_stmt|;
name|tcp_usrreqs
operator|.
name|pru_shutdown
operator|=
name|cxgb_tcp_usrreqs
operator|.
name|pru_shutdown
expr_stmt|;
name|tcp_usrreqs
operator|.
name|pru_rcvd
operator|=
name|cxgb_tcp_usrreqs
operator|.
name|pru_rcvd
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_struct
struct|struct
name|cxgb_dma_info
block|{
name|size_t
name|cdi_mapped
decl_stmt|;
name|int
name|cdi_nsegs
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|cdi_segs
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|cxgb_dma_callback
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|bus_size_t
name|mapsize
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|cxgb_dma_info
modifier|*
name|cdi
init|=
name|arg
decl_stmt|;
name|cdi
operator|->
name|cdi_mapped
operator|=
name|mapsize
expr_stmt|;
name|cdi
operator|->
name|cdi_nsegs
operator|=
name|nsegs
expr_stmt|;
name|cdi
operator|->
name|cdi_segs
operator|=
name|segs
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iov_adj
parameter_list|(
name|struct
name|iovec
modifier|*
modifier|*
name|iov
parameter_list|,
name|int
modifier|*
name|iovcnt
parameter_list|,
name|size_t
name|count
parameter_list|)
block|{
name|struct
name|iovec
modifier|*
name|iovtmp
decl_stmt|;
name|int
name|iovcnttmp
decl_stmt|;
name|caddr_t
name|ptmp
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|iovtmp
operator|=
operator|*
name|iov
expr_stmt|;
name|iovcnttmp
operator|=
operator|*
name|iovcnt
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|count
operator|<
name|iovtmp
operator|->
name|iov_len
condition|)
block|{
name|ptmp
operator|=
name|iovtmp
operator|->
name|iov_base
expr_stmt|;
name|ptmp
operator|+=
name|count
expr_stmt|;
name|iovtmp
operator|->
name|iov_base
operator|=
name|ptmp
expr_stmt|;
name|iovtmp
operator|->
name|iov_len
operator|-=
name|count
expr_stmt|;
break|break;
block|}
else|else
name|count
operator|-=
name|iovtmp
operator|->
name|iov_len
expr_stmt|;
name|iovtmp
operator|++
expr_stmt|;
name|iovcnttmp
operator|--
expr_stmt|;
block|}
operator|*
name|iov
operator|=
name|iovtmp
expr_stmt|;
operator|*
name|iovcnt
operator|=
name|iovcnttmp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|iovtmp
operator|=
operator|&
operator|(
operator|*
name|iov
operator|)
index|[
operator|*
name|iovcnt
operator|-
literal|1
index|]
expr_stmt|;
name|iovcnttmp
operator|=
operator|*
name|iovcnt
expr_stmt|;
while|while
condition|(
name|count
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|-
name|count
operator|<
name|iovtmp
operator|->
name|iov_len
condition|)
block|{
name|iovtmp
operator|->
name|iov_len
operator|+=
name|count
expr_stmt|;
break|break;
block|}
else|else
name|count
operator|+=
name|iovtmp
operator|->
name|iov_len
expr_stmt|;
name|iovtmp
operator|--
expr_stmt|;
name|iovcnttmp
operator|--
expr_stmt|;
block|}
operator|*
name|iovcnt
operator|=
name|iovcnttmp
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_zero_copy_free
parameter_list|(
name|void
modifier|*
name|cl
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{}
end_function

begin_function
specifier|static
name|int
name|cxgb_hold_iovec_pages
parameter_list|(
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|vm_page_t
modifier|*
name|m
parameter_list|,
name|int
modifier|*
name|held
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cxgb_wait_dma_completion
parameter_list|(
name|struct
name|toepcb
modifier|*
name|tp
parameter_list|)
block|{ 	 }
end_function

begin_function
specifier|static
name|int
name|cxgb_vm_page_to_miov
parameter_list|(
name|struct
name|toepcb
modifier|*
name|toep
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|seg_count
decl_stmt|,
name|err
decl_stmt|,
name|type
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|struct
name|cxgb_dma_info
name|cdi
decl_stmt|;
name|struct
name|mbuf_vec
modifier|*
name|mv
decl_stmt|;
name|struct
name|mbuf_iovec
modifier|*
name|mi
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|segs
decl_stmt|;
name|err
operator|=
name|bus_dmamap_load_uio
argument_list|(
name|toep
operator|->
name|tp_tx_dmat
argument_list|,
name|toep
operator|->
name|tp_dmamap
argument_list|,
name|uio
argument_list|,
name|cxgb_dma_callback
argument_list|,
operator|&
name|cdi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|seg_count
operator|=
name|cdi
operator|.
name|cdi_nsegs
expr_stmt|;
if|if
condition|(
operator|(
name|m0
operator|=
name|mcl_alloc
argument_list|(
name|seg_count
argument_list|,
operator|&
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|toep
operator|->
name|tp_tx_dmat
argument_list|,
name|toep
operator|->
name|tp_dmamap
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|segs
operator|=
name|cdi
operator|.
name|cdi_segs
expr_stmt|;
name|m0
operator|->
name|m_type
operator|=
name|type
expr_stmt|;
name|m0
operator|->
name|m_flags
operator|=
operator|(
name|M_EXT
operator||
name|M_NOFREE
operator|)
expr_stmt|;
name|m0
operator|->
name|m_ext
operator|.
name|ext_type
operator|=
name|EXT_EXTREF
expr_stmt|;
name|m0
operator|->
name|m_ext
operator|.
name|ext_free
operator|=
name|cxgb_zero_copy_free
expr_stmt|;
name|m0
operator|->
name|m_ext
operator|.
name|ext_arg1
operator|=
name|NULL
expr_stmt|;
comment|/* XXX: probably wrong /phk */
name|m0
operator|->
name|m_ext
operator|.
name|ext_arg2
operator|=
name|NULL
expr_stmt|;
name|mv
operator|=
name|mtomv
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|mv
operator|->
name|mv_count
operator|=
name|seg_count
expr_stmt|;
name|mv
operator|->
name|mv_first
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|mi
operator|=
name|mv
operator|->
name|mv_vec
init|;
name|i
operator|<
name|seg_count
condition|;
name|mi
operator|++
operator|,
name|segs
operator|++
operator|,
name|i
operator|++
control|)
name|mi_collapse_sge
argument_list|(
name|mi
argument_list|,
name|segs
argument_list|)
expr_stmt|;
operator|*
name|m
operator|=
name|m0
expr_stmt|;
if|if
condition|(
name|cdi
operator|.
name|cdi_mapped
operator|<
name|uio
operator|->
name|uio_resid
condition|)
block|{
name|uio
operator|->
name|uio_resid
operator|-=
name|cdi
operator|.
name|cdi_mapped
expr_stmt|;
block|}
else|else
name|uio
operator|->
name|uio_resid
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|t3_sosend
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|)
block|{
name|int
name|rv
decl_stmt|,
name|count
decl_stmt|,
name|hold_resid
decl_stmt|,
name|sent
decl_stmt|,
name|iovcnt
decl_stmt|;
name|struct
name|iovec
name|iovtmp
index|[
name|TMP_IOV_MAX
index|]
decl_stmt|,
modifier|*
name|iovtmpp
decl_stmt|,
modifier|*
name|iov
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|sototcpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|tp
operator|->
name|t_toe
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|uio
name|uiotmp
decl_stmt|;
comment|/* 	 * Events requiring iteration: 	 *  - number of pages exceeds max hold pages for process or system 	 *  - number of pages exceeds maximum sg entries for a single WR 	 * 	 * We're limited to holding 128 pages at once - and we're limited to 	 * 34 SG entries per work request, but each SG entry can be any number  	 * of contiguous pages 	 * 	 */
name|uiotmp
operator|=
operator|*
name|uio
expr_stmt|;
name|iovcnt
operator|=
name|uio
operator|->
name|uio_iovcnt
expr_stmt|;
name|iov
operator|=
name|uio
operator|->
name|uio_iov
expr_stmt|;
name|sent
operator|=
literal|0
expr_stmt|;
name|sendmore
label|:
comment|/* 	 * Make sure we don't exceed the socket buffer 	 */
name|count
operator|=
name|min
argument_list|(
name|toep
operator|->
name|tp_page_count
argument_list|,
operator|(
name|sbspace
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
operator|>>
name|PAGE_SHIFT
operator|)
operator|+
literal|2
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|rv
operator|=
name|cxgb_hold_iovec_pages
argument_list|(
operator|&
name|uiotmp
argument_list|,
name|toep
operator|->
name|tp_pages
argument_list|,
operator|&
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hold_resid
operator|=
name|uiotmp
operator|.
name|uio_resid
expr_stmt|;
if|if
condition|(
name|rv
condition|)
return|return
operator|(
name|rv
operator|)
return|;
comment|/* 	 * Bump past sent and shave off the unheld amount 	 */
if|if
condition|(
name|hold_resid
operator|>
literal|0
condition|)
block|{
name|iovtmpp
operator|=
name|iovtmp
expr_stmt|;
name|memcpy
argument_list|(
name|iovtmp
argument_list|,
name|iov
argument_list|,
name|iovcnt
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|iov
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sent
condition|)
name|iov_adj
argument_list|(
operator|&
name|iovtmpp
argument_list|,
operator|&
name|iovcnt
argument_list|,
name|sent
argument_list|)
expr_stmt|;
name|iov_adj
argument_list|(
operator|&
name|iovtmpp
argument_list|,
operator|&
name|iovcnt
argument_list|,
operator|-
name|hold_resid
argument_list|)
expr_stmt|;
name|uiotmp
operator|.
name|uio_iov
operator|=
name|iovtmpp
expr_stmt|;
name|uiotmp
operator|.
name|uio_iovcnt
operator|=
name|iovcnt
expr_stmt|;
block|}
name|uiotmp
operator|.
name|uio_resid
operator|=
name|uio
operator|->
name|uio_resid
operator|-
name|hold_resid
expr_stmt|;
comment|/* 	 * Push off all held pages 	 * 	 */
while|while
condition|(
name|uiotmp
operator|.
name|uio_resid
operator|>
literal|0
condition|)
block|{
name|rv
operator|=
name|cxgb_vm_page_to_miov
argument_list|(
name|toep
argument_list|,
operator|&
name|uiotmp
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
block|{
name|vm_fault_unhold_pages
argument_list|(
name|toep
operator|->
name|tp_pages
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
name|uio
operator|->
name|uio_resid
operator|-=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|sent
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|sbappend_locked
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|t3_push_frames
argument_list|(
name|so
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|iov_adj
argument_list|(
operator|&
name|uiotmp
operator|.
name|uio_iov
argument_list|,
operator|&
name|iovcnt
argument_list|,
name|uiotmp
operator|.
name|uio_resid
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Wait for pending I/O to be DMA'd to the card  	 *  	 */
name|cxgb_wait_dma_completion
argument_list|(
name|toep
argument_list|)
expr_stmt|;
name|vm_fault_unhold_pages
argument_list|(
name|toep
operator|->
name|tp_pages
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* 	 * If there is more data to send adjust local copy of iov 	 * to point to teh start 	 */
if|if
condition|(
name|hold_resid
condition|)
block|{
name|iovtmpp
operator|=
name|iovtmp
expr_stmt|;
name|memcpy
argument_list|(
name|iovtmp
argument_list|,
name|iov
argument_list|,
name|iovcnt
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|iov
argument_list|)
argument_list|)
expr_stmt|;
name|iov_adj
argument_list|(
operator|&
name|iovtmpp
argument_list|,
operator|&
name|iovcnt
argument_list|,
name|sent
argument_list|)
expr_stmt|;
name|uiotmp
operator|=
operator|*
name|uio
expr_stmt|;
name|uiotmp
operator|.
name|uio_iov
operator|=
name|iovtmpp
expr_stmt|;
name|uiotmp
operator|.
name|uio_iovcnt
operator|=
name|iovcnt
expr_stmt|;
goto|goto
name|sendmore
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_sosend
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|mbuf
modifier|*
name|top
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|sototcpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|toedev
modifier|*
name|tdev
decl_stmt|;
name|int
name|zcopy_thres
decl_stmt|,
name|zcopy_enabled
decl_stmt|,
name|rv
decl_stmt|;
comment|/* 	 * In order to use DMA direct from userspace the following 	 * conditions must be met: 	 *  - the connection is currently offloaded 	 *  - ddp is enabled 	 *  - the number of bytes to be transferred exceeds the threshold 	 *  - the number of bytes currently in flight won't exceed the in-flight 	 *    threshold XXX TODO 	 *  - vm_fault_hold_user_pages succeeds 	 *  - blocking socket XXX for now 	 * 	 */
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_TOE
condition|)
block|{
name|tdev
operator|=
name|TOE_DEV
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|zcopy_thres
operator|=
name|TOM_TUNABLE
argument_list|(
name|tdev
argument_list|,
name|zcopy_sosend_partial_thres
argument_list|)
expr_stmt|;
name|zcopy_enabled
operator|=
name|TOM_TUNABLE
argument_list|(
name|tdev
argument_list|,
name|zcopy_sosend_enabled
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uio
operator|->
name|uio_resid
operator|>
name|zcopy_thres
operator|)
operator|&&
operator|(
name|uio
operator|->
name|uio_iovcnt
operator|<
name|TMP_IOV_MAX
operator|)
operator|&&
operator|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_NBIO
operator|)
operator|==
literal|0
operator|)
operator|&&
name|zcopy_enabled
condition|)
block|{
name|rv
operator|=
name|t3_sosend
argument_list|(
name|so
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|EAGAIN
condition|)
return|return
operator|(
name|rv
operator|)
return|;
block|}
block|}
return|return
name|pru_sosend
argument_list|(
name|so
argument_list|,
name|addr
argument_list|,
name|uio
argument_list|,
name|top
argument_list|,
name|control
argument_list|,
name|flags
argument_list|,
name|td
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|t3_soreceive
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|notyet
name|int
name|i
decl_stmt|,
name|rv
decl_stmt|,
name|count
decl_stmt|,
name|hold_resid
decl_stmt|,
name|sent
decl_stmt|,
name|iovcnt
decl_stmt|;
name|struct
name|iovec
name|iovtmp
index|[
name|TMP_IOV_MAX
index|]
decl_stmt|,
modifier|*
name|iovtmpp
decl_stmt|,
modifier|*
name|iov
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|sototcpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|toepcb
modifier|*
name|toep
init|=
name|tp
operator|->
name|t_toe
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|uio
name|uiotmp
decl_stmt|;
comment|/* 	 * Events requiring iteration: 	 *  - number of pages exceeds max hold pages for process or system 	 *  - number of pages exceeds maximum sg entries for a single WR 	 * 	 * We're limited to holding 128 pages at once - and we're limited to 	 * 34 SG entries per work request, but each SG entry can be any number  	 * of contiguous pages 	 * 	 */
name|uiotmp
operator|=
operator|*
name|uio
expr_stmt|;
name|iovcnt
operator|=
name|uio
operator|->
name|uio_iovcnt
expr_stmt|;
name|iov
operator|=
name|uio
operator|->
name|uio_iov
expr_stmt|;
name|sent
operator|=
literal|0
expr_stmt|;
name|re
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxgb_soreceive
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|psa
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp0
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|controlp
parameter_list|,
name|int
modifier|*
name|flagsp
parameter_list|)
block|{
name|struct
name|toedev
modifier|*
name|tdev
decl_stmt|;
name|int
name|rv
decl_stmt|,
name|zcopy_thres
decl_stmt|,
name|zcopy_enabled
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|sototcpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
comment|/* 	 * In order to use DMA direct from userspace the following 	 * conditions must be met: 	 *  - the connection is currently offloaded 	 *  - ddp is enabled 	 *  - the number of bytes to be transferred exceeds the threshold 	 *  - the number of bytes currently in flight won't exceed the in-flight 	 *    threshold XXX TODO 	 *  - vm_fault_hold_user_pages succeeds 	 *  - blocking socket XXX for now 	 *  - iovcnt is 1 	 * 	 */
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_TOE
condition|)
block|{
name|tdev
operator|=
name|TOE_DEV
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|zcopy_thres
operator|=
name|TOM_TUNABLE
argument_list|(
name|tdev
argument_list|,
name|ddp_thres
argument_list|)
expr_stmt|;
name|zcopy_enabled
operator|=
name|TOM_TUNABLE
argument_list|(
name|tdev
argument_list|,
name|ddp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uio
operator|->
name|uio_resid
operator|>
name|zcopy_thres
operator|)
operator|&&
operator|(
name|uio
operator|->
name|uio_iovcnt
operator|==
literal|1
operator|)
operator|&&
operator|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_NBIO
operator|)
operator|==
literal|0
operator|)
operator|&&
name|zcopy_enabled
condition|)
block|{
name|rv
operator|=
name|t3_soreceive
argument_list|(
name|so
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|EAGAIN
condition|)
return|return
operator|(
name|rv
operator|)
return|;
block|}
block|}
return|return
name|pru_soreceive
argument_list|(
name|so
argument_list|,
name|psa
argument_list|,
name|uio
argument_list|,
name|mp0
argument_list|,
name|controlp
argument_list|,
name|flagsp
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|t3_install_socket_ops
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_sosend
operator|=
name|cxgb_sosend
expr_stmt|;
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_soreceive
operator|=
name|cxgb_soreceive
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine takes a user address range and does the following:  *  - validate that the user has access to those pages (flags indicates read or write) - if not fail  *  - validate that count is enough to hold range number of pages - if not fail  *  - fault in any non-resident pages  *  - if the user is doing a read force a write fault for any COWed pages  *  - if the user is doing a read mark all pages as dirty  *  - hold all pages  *  - return number of pages in count  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_function
specifier|static
name|int
name|vm_fault_hold_user_pages
parameter_list|(
name|vm_offset_t
name|addr
parameter_list|,
name|int
name|len
parameter_list|,
name|vm_page_t
modifier|*
name|mp
parameter_list|,
name|int
modifier|*
name|count
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|vm_offset_t
name|start
decl_stmt|,
name|va
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|int
name|pageslen
decl_stmt|,
name|faults
decl_stmt|,
name|rv
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|vm_map_t
name|map
decl_stmt|;
name|pmap_t
name|pmap
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|,
modifier|*
name|pages
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|;
name|start
operator|=
name|addr
operator|&
operator|~
name|PAGE_MASK
expr_stmt|;
name|pageslen
operator|=
name|roundup2
argument_list|(
name|addr
operator|+
name|len
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|count
operator|<
operator|(
name|pageslen
operator|>>
name|PAGE_SHIFT
operator|)
condition|)
return|return
operator|(
name|EFBIG
operator|)
return|;
operator|*
name|count
operator|=
name|pageslen
operator|>>
name|PAGE_SHIFT
expr_stmt|;
comment|/* 	 * Check that virtual address range is legal 	 * This check is somewhat bogus as on some architectures kernel 	 * and user do not share VA - however, it appears that all FreeBSD 	 * architectures define it 	 */
if|if
condition|(
name|addr
operator|+
name|len
operator|>
name|VM_MAXUSER_ADDRESS
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|td
operator|=
name|curthread
expr_stmt|;
name|map
operator|=
operator|&
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
operator|->
name|vm_map
expr_stmt|;
name|pmap
operator|=
operator|&
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
operator|->
name|vm_pmap
expr_stmt|;
name|pages
operator|=
name|mp
expr_stmt|;
name|prot
operator|=
operator|(
name|flags
operator|&
name|VM_HOLD_WRITEABLE
operator|)
condition|?
name|VM_PROT_WRITE
else|:
name|VM_PROT_READ
expr_stmt|;
name|bzero
argument_list|(
name|pages
argument_list|,
sizeof|sizeof
argument_list|(
name|vm_page_t
operator|*
argument_list|)
operator|*
operator|(
operator|*
name|count
operator|)
argument_list|)
expr_stmt|;
name|retry
label|:
comment|/* 	 * First optimistically assume that all pages are resident (and R/W if for write) 	 * if so just mark pages as held (and dirty if for write) and return 	 */
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
for|for
control|(
name|pages
operator|=
name|mp
operator|,
name|faults
operator|=
literal|0
operator|,
name|va
operator|=
name|start
init|;
name|va
operator|<
name|pageslen
condition|;
name|va
operator|+=
name|PAGE_SIZE
operator|,
name|pages
operator|++
control|)
block|{
comment|/* 		 * Assure that we only hold the page once 		 */
if|if
condition|(
operator|*
name|pages
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * page queue mutex is recursable so this is OK 			 * it would be really nice if we had an unlocked version of this so 			 * we were only acquiring the pmap lock 1 time as opposed to potentially 			 * many dozens of times 			 */
name|m
operator|=
name|pmap_extract_and_hold
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|prot
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|faults
operator|++
expr_stmt|;
continue|continue;
block|}
operator|*
name|pages
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|VM_HOLD_WRITEABLE
condition|)
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
if|if
condition|(
name|faults
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Pages either have insufficient permissions or are not present 	 * trigger a fault where neccessary 	 *  	 */
for|for
control|(
name|va
operator|=
name|start
init|;
name|va
operator|<
name|pageslen
condition|;
name|va
operator|+=
name|PAGE_SIZE
control|)
block|{
name|m
operator|=
name|NULL
expr_stmt|;
name|pa
operator|=
name|pmap_extract
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pa
condition|)
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|VM_HOLD_WRITEABLE
condition|)
block|{
if|if
condition|(
name|m
operator|==
name|NULL
operator|||
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_WRITEABLE
operator|)
operator|==
literal|0
condition|)
name|rv
operator|=
name|vm_fault
argument_list|(
name|map
argument_list|,
name|va
argument_list|,
name|VM_PROT_WRITE
argument_list|,
name|VM_FAULT_DIRTY
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|rv
operator|=
name|vm_fault
argument_list|(
name|map
argument_list|,
name|va
argument_list|,
name|VM_PROT_READ
argument_list|,
name|VM_FAULT_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
goto|goto
name|error
goto|;
block|}
goto|goto
name|retry
goto|;
name|error
label|:
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
for|for
control|(
name|pages
operator|=
name|mp
operator|,
name|va
operator|=
name|start
init|;
name|va
operator|<
name|pageslen
condition|;
name|va
operator|+=
name|PAGE_SIZE
operator|,
name|pages
operator|++
control|)
if|if
condition|(
operator|*
name|pages
condition|)
name|vm_page_unhold
argument_list|(
operator|*
name|pages
argument_list|)
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|vm_fault_unhold_pages
parameter_list|(
name|vm_page_t
modifier|*
name|mp
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|count
operator|>=
literal|0
argument_list|,
operator|(
literal|"negative count %d"
operator|,
name|count
operator|)
argument_list|)
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
block|{
name|vm_page_unhold
argument_list|(
operator|*
name|mp
argument_list|)
expr_stmt|;
name|mp
operator|++
expr_stmt|;
block|}
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

